Is this order guaranteed, ie ls-refs before fetch?
shouldn't you clear out restartToken and lastPackId at the start? The way you are using class variables is error prone. Any thing that should be remembered across sessions should be stored in the Session, otherwise pass the information as arguments. This will require you to create some helper types to hold data e.g. a Header class with two fields, restartToken and lastPackId. This does not apply to in and out, since they are used everywhere.
Move to a separate file? UploadPack.java is getting pretty big...
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
Could this relatively general code be reused in the needsOrderBy method?
in all these OseeArgumentException constructors, you don't need to use String.format, it does that for you.
throw an exception? this is not intended to use.
Symmetry (throw)?
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
Here is also that unusual check.
Using a boolean as abort condition for the parsers main while loop is also a deprecated pattern. Instead replace this line with outerloop: while(true) {.
Should use nextTag() and switch-case instead.
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
same as above... why not use simple if/else here?
Strings would be better to be stored in a constant
I see this duplicated in a lot of tests, maybe we should put it in it's own utility function?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
Maybe relate those hardcoded strings to the enum above?
shouldn't be setDaemon(true)
Nit: I would like this broken up into multiple statements so we can tell where it breaks if we get an NPE.
ACCESS_CONSENT_ATTR and INST_ACCESS_CONSENT_ATTR are defined in both SamlConstants and NhincConstants. Remove from NhincConstants.
Consider to use StringUtils.hasLength(str) to check
rename the method to createResourceIdAttributeStatements
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Why going for semantic here ??
Should we handle StatusPart separately?
Maybe not needed? We don't have to check if a target process definition exists in the source container.
are we not covering this when we do the merge?
This could be written as if (!invoked)
nit: create static variable for this empty set and return that static variable
return Collections.emptyList();
Check that the RyaStatement and Config are not null.
ERR_DELETE_ERROR, add if there isn't one already
Possible NPE here in case of default constructor. Let's mark the 'log' field as 'final' and initialize it in default constructor.
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
Out of interest why can you not do DecisionTableOrientation.values()?
At present, we try to avoid use of the keyword final as per our [POLICIES](<LINK_0>
map - confusing name
in what scenario path list will be empty with copy error set to true ?
This is File copy error not file system retry case.
switch them. checking boolean is faster than checking isMaster
No need to log here: return binary.getLong();
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
What about l < Integer.MIN_VALUE?
no need to specify type on RHS
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
check to make sure notificationUUID is not null
This should check to make sure that notificationUUID is not null before attempting to delete it.
It doesn't look like you are doing anything with the bucket here. This can be removed.
static
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
Was thinking about collisions here, <LINK_0>, theres about ~1% probability of collision in 10k tables, but we are fine I think (except for the large internal product that is creating and truncating tables). We can take a 16 character substring?
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
Two TimeAndDims might have dims of different length so I think this could cause an out of bounds array access on that.dims[i]. This also doesn't check types at all but the Comparator for sorted facts does check types. The equals impl could do return dimsComparator.compare(this, that) == 0 although this does some needless name lookups.
Did you mean --i?
Seems like there's a spacing issue here, two spaces instead of 4.
Normally, a 'validate' method should return true in case of success, and false if validation failed.
I'm probably missing something, but it seems like this is part of the next case (isn't queue.size() >= 0 an invariant?). Is this called out just to emphasize that setting 0 => "no queuing"?
do the comparison the other way around
JDBC
there is an 'n' missing at the end of 'pattern'.
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
<LINK_0> Let me know if you have any issues managing or adding items to the project
This seems like something the client would want access to, "request a new full page of cards".
You don't need this line because of green 31.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
why was this done?
Yes, polymorphism is what you want. instanceof generally is a last-resort kind of solution. Here you're in charge of the design so you can easily avoid it by adding another level to your hierarchy.
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
The responsebody annotation can be removed, because the class is annotated with RestController. suggestion public Promise<CodeSystems> searchByGet(final CodeSystemRestSearch params) {
I'm almost tending to use VRaptor specific exceptions for this case, instead of reusing IllegalArg and IllegalState... We're doing this only because of validations, right? We could create a ValidationFailedException.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
this.redisTemplate
Nit-pick for the variable name. It is really not file, so just entry would be good. The new HashMap() is bad code too. Must be with generics
Should add the rule to config file?
can't be null?
Hi, I am currently evaluating exception aggregation tools and so far bugsnag seems to be the most promising for my needs. Especially with a logback extension, which is why I am following your pull request. Here at this line you might consider making the initialization of the UncaughtExceptionHandler, which is implicitly done through the constructor, configurable. In my use-case for example I am running a centralised logging server which is reading log events from sockets and writing them to files as well as to an exception aggregation tool. In this context a global exception handler may not be wanted/needed.
Isn't it enough to declare Exception here? An exception will fail the test, regardless of the specific type.
Why the sub string ?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Can we change this to LOGGER.INFO
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
filter(Objects::nonNull)
this.
Should this be String.valueOf or is cnn the way to go?
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
ConfigurationImpl_toString = Node configuration: {0}\nEdge configuration: {1} MessageFormat.format(Messages.ConfigurationImpl_toString, nodeConfiguration, edgeConfiguration);
I think pNode.getClass() doesn't have to be in the loop, you can move to above and return empty is the condition is true
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
I would suggest moving pNode.getClass() == PointNode.class before the for loop
See above about checking the labels
See above about checking the labels
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
nit: we don't do this (argument alignment) throughout the project, any reason to start with this method?
Yeah, here's where I was thinking of using our custom exceptions. IdpResponse.fromError(...)
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
Shouldn't have printStackTrace() in production code switch to logging.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Please replace that 1 by a constant indicating what it is.
final
Make this a typed exception (e.g. PlatformServicesException)
Remove stack traces
can you change this method to call your new method instead? Make sure to pass 5 seconds as the timeout to not change the meaning of this function.
Why does this need to be ordered by the synthetic primary key?
Possible copy/paste bug in the order by clause.
Lists obtained from a message are immutable. No need for extra copying.
Was seconds an intentional omission here?
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
Hash code
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
Please store these values in a static variable, such as ASSISTANT_USERNAME :smile:
I would rather rewrite the assert to check the full URL or to chack whether the URL contains the name. Just removing the check is a bit hackish
@mcivantos-tribalyte _successCallback_ has changed in another commit, you need to update this to: _(WorkspaceProject project) -> successCallback.execute(project)_
no need to create a set here..
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Maybe it's just me, but I would find a simple if-else clause more readable.
this part looks similiar to #validateAuthenticationState consider extracting the common code into a shared method
Could call the method addCookie(String domain,....) instead.
fail
same as others: log should have Exception as arg
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
null or empty list?
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
ahh, here it is
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Can this be private (or at least package protected)? It's only used by this class.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Can this be private (or at least package protected)? It's only used by this class.
Preferably have one call the other?
can you pull this from a static string?
This looks like a good candidate for doing ImmutableMap.of(Maps.transformEntries(...)).
please apply formatting
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
you don't need this. the "+" operator does this for you.
since host_name can be ugly fqdn or ip i think it would be nice to print vds_name as well
recordCount++; doesn't work?
grammar nit: 1, not one, and no :
I would really like to optimize, but having another sorted data structure would cost more than just having iterative approach
Should use StatusHandler.log() instead
:astonished:
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
Could you check for null or empty? Via StringUtils.isBlank
Oh please, no! Don't ship a null object! :cry:
Symmetry (throw)?
rm 99
Constant
IMO, urlInitialized check here is redundant. I"m not sure how can you get to this point with urlInitialized=false. (And if it is false- don't you want to return?)
Same concern here. true looks wrong.
mapping may be null at this point
Only 'wrapTextFlag' is needed
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
put call of this method to appropriate place in each method that requires it
why not null as value?
@Serranya The same here. See above.
@Serranya The same here. See above.
@Serranya Please, add the name "body content" into the message to be more clear and specific. It's too much generic.
2xx
@mavrk I think you mixed tabs and whitespaces in the description.setConcept(this) line. in OpenMRS we use tabs. Please remove your whitespaces.
don't need the else here. Too bad java doesn't have XOR :)
You should use ThreadContext.putAll() here.
minor, is it method scope for Visible For Testing? If not please change it to private.
Unnecessary (and incompatible); revert.
I think it might be easier to create a list and compare that?
Actually this should fail, because the input isn't a list of strings, and the type of "properties" is "String[]".
This could use Collections.singletonList
same as above... why not use simple if/else here?
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
Same issue here. We should keep this as static if at all possible
For readability sake, can these two increments use the same atomic method call?
similarly here, if this is general, I've lost updates...
computeIfAbsent?
You can inject the header variable in this class too, to avoid dealing with static methods.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
Immutable?
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
Please use networkClusters instead of getNetworkClusterList().getItems()
Both of these lines should be moved into corresponding methods calculating the desired state according to the two dependencies, as I described in another file.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
so for IPv6 hosts when a machine is cloned this is going to break?
there is no need for using FQDN because only one Base64 is imported now
if that previews is showing cleaned-up code, why is this one still here?
I continue to think that **aifc** should to be here...
Can use the already defined Constants
@Nadahar Right, text/vtt, i was too fast...my bad.
SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Is there a reason not to use Util.TOLERANCE?
doing += on a Long object causes boxing every time. It'd be better to have sum be a "long", and return Long.valueOf(sum) at the end. Or simply return a long in this method.
why sink->getSink()?
This could be null, we should probably handle this if the JIRA api changes again
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
I don't see a test for this new method
Does it make sense to have this for a class that states it's "modified"?
Rename this local variable to gid as well, like the overall renaming you have done for lrecId.
More accurate error message
Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)
Style issue: @Override shuld be on line above the method declaration
would this be called often, and would the list copy be expensive?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
I understand you're trying to emphasize the connection between the two methods, but calling this onPartitionsAssigned feels a little confusing in this class; on ConsumerRebalanceListener it is intended to convey some subscription/notification semantics that do not apply here. The same applies to onPartitionsRevoked and onRecordsReceived.
Add check that non-null
is it at all possible to use standard URI building things here? Either hadoop FS path building or the java File and Path constructs?
The forbidden apis check is flagging an error here: > [ERROR] Forbidden method invocation: java.lang.String#matches(java.lang.String) [Use startsWith(), endsWith(), contains(), or compile and cache a Pattern explicitly] The regex also looks more complicated than necessary and is causing test failures: <LINK_0>  [ERROR] testIsTaskCurrent[numThreads = 1](org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest) Time elapsed: 0.142 s <<< ERROR! java.lang.IllegalArgumentException: dataSource cannot contain whitespace character. at com.google.common.base.Preconditions.checkArgument(Preconditions.java:125) at org.apache.druid.segment.indexing.DataSchema.validateDatasourceName(DataSchema.java:108) at org.apache.druid.segment.indexing.DataSchema.<init>(DataSchema.java:76) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.getDataSchema(KafkaSupervisorTest.java:3636) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.testIsTaskCurrent(KafkaSupervisorTest.java:3099)
if (realm != null) maybe - just to be safe.
Remove throws Exception
Is this really needed?
final
Most callers are assuming that this method returns a non-null DBCollection, so there's no point in having this check.
Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?
minor: don't need this. qualifiers
String.format
I think this is unnecessary => "profile =" + this.profile is sufficient.
bad name of method <LINK_0>
What's the thinking behind inverting values that are passed in?
we don't really use _ (underscore) prefx for any other variables. can you rename it to just 'e'
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
It is not public API so don't worry about changing that, but we should get @alzimmermsft and / or @jianghaolu to review this to ensure that our builders always have a serviceVersion API and not version or any other naming convention.
should this be pipeline.executor?
Seems like the previous tests should also assert on the length?
No reason to save chars here. I would strongly prefer dynamic
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "enforceNotNullNorEmpty" a "static" method. [![rule](<LINK_2>](<LINK_0>
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
A create card payment request should always have a return URL, so I don't think this should return an optional
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
EndOfStreamException is never thrown in this method, as far as I can see.
unnecessary else clause can be removed
Checking for test mode is fine, but maybe we should do it when this method is called, rather than in here -- the environment it's run in doesn't seem like a concern of this class.
We do not consider the whole resource, but only the selected elements (and their descendants). It should read "The selected elements do not contain".
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
And this change should be reverted as well.
Uses the varargs version
As we're down to one arg, just do:  return threadRecord.hashCode();
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
I'd use a different name, e.g. doStream
Missing types
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
weight is missing from toString()
We should validate that's non-null (to fail sooner).
Why did we make this public?
Given that Void is imported in the file, is there any reason to use the package name prefix?
This should return an immutable collection.
Should not this method create a copy of the set just as getStages()?
The keySet is a view... So, the caller could run into a CME using the returned Set it the Map changes. Wouldn't it be better to return a new set created by the content of the view set?
Do we want to use the platform's default charset when we read this from the database? I suggest we use a fix encoding here like UTF-8? suggestion return new String(licenseResource.getBytes(java.nio.charset.StandardCharsets.UTF_8));
Let's append java checkNotNull(event);  as the first line. EventsShould should have a "nullability check" test case (see other Spine tests for a sample).
We can also skip the query if the resourceId is *
If the code fails to close in, it will never try to close out
for such change. If the code fails to close in, it will never try to close out
Perhaps try-with-resources? And there are also tabs here that could be fixed.
I guess this will crash as well if getCompatibleOperatingSystems() returns null.
context.getClassLoader() can return null
suggestion return getChannel(context) != null;
I keep seeing these checks everywhere that provider is not in SOCIAL_PROVIDERS. I think a positive assertion would be better. Like GENERIC_PROVIDERS.contaains(providerid)
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
Create a common function for checking the regex and compiling.
You need to check that conceptUuid is not null and blank
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
+ desc
...if you do not provide...
Missing NLS
I think this should be headers.get(name).
Map
just return "" instead of new String()
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Put into constant.
Doesn't this now need a @SuppressWarnings("unchecked") ? I think there are a couple of other places just like this.
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
@apc999 This needs to be public or reflection will not work
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
I don't know much about how the serialization code works, but is this supposed to be a 1, instead of a unique serial? I'm guessing it doesn't matter because these factories will not be serialized.
No need to use ConcurrentMap.
YOu can remove the syncrhonized block.
I know this is pre-existing, but getQuery has a bunch of other usages that refers to the query text. I would rename one or the other.
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
The most likely case of this if statement is the opposite I think.
Could do this.mode != mode instead of comparing the name.
Why give relayType its own variable and rcIndex and rcIntern not? And is it safe to parse a String to an Int without a try / catch?
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
@erimerturk let's rename this to ex
style nit: we don't use braces around single line blocks
Code style: Always use curly brackets, and space after if.
Code style: Always use curly brackets, and space after if.
is DebugLogger.INSTANCE.w a sneaky way of calling the logger even when logging is disabled?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Unnecessary blank lines after a method - let's remove all these to keep it slightly shorter
I think null is default
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
I'm confused. Which of these catch clauses is the expected one?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
throw an assertion here, i should probably do that in my code as well
Can be checked on a running cluster: <LINK_0>
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
Is this necessary? We have the StructuralProbe mechanism in the parser. Could that be used instead? Structural probes have recordNewMethod(SInvokable method).
@vilchik-elena Why not make this constructor call the third one?
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
Shouldn't receive a RuntimeException anymore?
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Unknown file name and known line number? Should that be an error?
These error messages are already pretty good! I'm wondering whether we could store the character index for each token and emit it as part of the error message instead of the "token index". Thoughts?
suggestion assertThat(got).contains("Description");
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
Will * <LINK_0> * <LINK_1> work as well?
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
Do we need to handle BigDecimal as well?
Here also, comparison of value should look at similar types like long and doubles (checking for overflow)
Would it make sense to add something this.caches.clear() to the stop ?
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
Preferably have one call the other?
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
Should this return the AzureTable?
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Synchronize on private lock. <LINK_0>
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
should the message include "command _with options_:" + this.options ?
you're not logging the exception
I see a problem with this error - user doesn't know where the expected type comes from (it is already added from other task).
The model value could be passed as a parameter to the validate method in order to create a single instance of ModelValidator and reuse it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
I would probably catch throwables, because ClassDefNotFoundError..
I tend to think that this should just return - I think it's totally reasonable that I as a user might first close the writers independently (they do implement closeable after all) and _then_ close the pool which is going to call these methods again.
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
it would be easier to understand, and way easier to see whats going wrong if something breaks, if youd also compile a expected and actual list and then compare them with arrayEquals
I think you can get rid of the first condition now, due to the change above.
does this needs to also do a null check for payload before assigning a new reference ?
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
please create a more specific exception that extends this one.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
please extract to a separate method
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
<LINK_0>
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
why the new line?
I understand that we still leak off of VerifyingChannelInterceptor in our Testing Framework, but you still can use a MockIntegration.mockMessageHandler() instead of logger in the main flow to verify an incoming message. WDYT?
When you changed the code to also provide the old API, you should be able to revert these changes.
I'd rather toLowerCase() is applied after substring(), not before.
tmp must be a constant and we dont prevent nullpointerexception for filename.
It may be over thinking this but I got some errors when I tried to make a form name with spaces around the "/" e.g Form with / back slash where as Form with/back slash worked on the device. So maybe we can add another replaceAll() after the first one to replace any patterns like Form_with___back_slash?
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
could be static
devtype is not camelcased, also deviceType would be more descriptive.
Space before {
SonarLint is going complain about String concat
Let's include the giver and recipient here too
studentsWhoRespond -> studentsWhoResponded
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Expose Map if you can
let's call it updateCodeMinings() instead.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
please move the isEmpty methods to the scimSchema
We should avoid using Java8 for issues which could be backported in 2.4.
There is a duplicate implementation in PushTest. It's a good candidate for a test util function that can be imported statically.
It's pretty inefficient to create all these AclBinding instances, just to check for unknowns. Is it possible to avoid that?
kind of curious what these magic numbers are
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
@ilyakharlamov I think that this test won't run on windows, it fails on creating files on /dev/null
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
There is a lot going on this one line.
Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Could use Double.BYTES
This null check should be done in line 274
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Looks like a null check on sourcePort is missing here because sourcePort is Integer and therefore can be null. If sourcePort is null then the comparison "== 0" will cause problems when trying to debox sourcePort to int. Just tried the following similar code and it crashed with NPE: Integer sourcePort = null; int x = (sourcePort == 0 ? null : sourcePort);
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
Check if there is an appropriate constant for "no metakeys" mask.
nit: We can store this into a static final field TEST_PARTITION_INFO int this class.
This is basically a guaranteed crash right? To be avoided at all costs, it's just making future work. A toast and a fall back to the note editor or anything is better than throwing a RuntimeException if we can avoid it
nit: We should use UIUtils.showLongToast(). If it doesn't exist, we should make one.
Any reason for switching from using the PermissionsManager here?
Lots of unnecessary this. qualifiers.
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
The return statement can be simplified return (currentTime - lastHealthCheck) >= minInterval;
give some meaningful name to this thread.
I think the granularity should be 1 seconds instead of 5 seconds here.
getParent() can return null
this can be implemented with: decodeBucketIndex(EXTENDED_PREFIX_BITS, entry)?
This is the only place that add entry to the pool, is it the only way to fill the pool?
Simple for-each?
I still don't understand why the key cannot be the session id
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
this could also use the get treatment
getCells() can never be null
Please close client at the end.
restore might fail with exception => client should be closed in finally block
I suggest to clean up the client in the same class where it is created - in the parent AbstractMessagingTestCase.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
Same issue with the change in visibility of this method as with JcrRepository.start().
newline
Just return data.
nit: you can merge both lines above as checkNotNull will return the given argument
@robbavey don't we have to release this ByteBuf after we've deserialized its contents?
Let's do return fDetailedLoad; even if it is always null for now
Don't need this - regionGuidePosts is either set in the other constructor or set in the readFields method.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "e" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignored" Please use fail() <LINK_0>
may be it is going to be more obvious to have dedicated variable for that? 'boolean predefinedSamplesCount' instead of 'totalSamplesRequested != -1' ?
Get it from the model now that we have one?
Fix the method name here please.
Same as above - log or throw the weird state.
We could probably use getItem() method here, for consistency.
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
To be safe, should check gerritTrigger.getJob() != null first.
job
Should we track additional information here, like what kind of trigger it is? What would the cardinality be of that? (e.g. is it a pipeline trigger, an internal trigger, etc)
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
why do we use this. on getters but not on alpha? I would skip this. all together here and use getAlpha()
Wouldn't it be better to only show iterations OR epsilon?
fileName seems a bit redundant - why not do this in a single line? File file = new File(baseDir + "/src/main/resources/bundles/AppErrors.properties");
can we use BeforeClass annotation?
please use method directly, you don't need to store it in variable
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This should be a constant, not a magic string.
throw exception
It should throw exception
Possibly more descriptive error message?
Geometry is comparable?
There's probably some edge cases where this isn't true. Consider the case where there's 1 discrete parameter to optimize, with possible values {A,B,C}. In this case, there's only 3 candidates - and the candidate generator should terminate once all 3 have been generated.
return defaultFilterFactorEnabled ?
also check this
This represents a poor API. If you are not going to provide a working implementation for all versions, the newInstance method should be marked @Nullable and you should actually return null. This way callers explicitly have to write:  java if (mHighlighter != null) { mHighlighter.highlight(...) }  An alternative strategy is to add an isSupported method that NullHighlighter (prefer NoopHighlighter as well since null has no semantic context here) implements and returns false, then throws on all other methods, forcing callers to write:  java if (mHighlighter.isSupported()) { mHighlighter.highlight(...); }  The reason for being explicit is so that readers of the highlighting code can see plainly that it might not be supported and that would explain why it's not working for them on a naive/quick read of the source code. Forcing folks to dig all the way down into the implementation to see that possibility is frustrating.
static.
Assert.notNull(expiry,..) checking might make sense here
nit: line too long. final not required -- a static method cannot be overwritten anyway
how about we redirect to the non deprecated method? The only downside is that the closure cleaner will be applied on the AssignerWithPeriodicWatermarksAdapter.Strateg but I think its fine.
we should not throw an exception here, simply ignore
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
Does the system property check influences the dataType too?
<LINK_0>
<LINK_0>
Why are you catching and ignoring? as above, if you catch, you should do something, if you wish to ignore an exception, please say so. Typically using the word "expected" as the variable name. <LINK_0>
Question: Should not we add braces to this statement?
throw exception
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
Make it a static method in ExecutionExceptions or similar class?
Please use curly braces for conditionals
equals and hashcode are only comparing stepNumber, which is half of the key. Should compare the Progress objects or their IDs too
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
Could you add an assertion on one of the associated props? Just to be sure...
All these vars are used just once. Maybe just use the method call directly? i.e.  "<LINK_0>" + mUser.getAccountToken() + ....
Why the sub string ?
As [mentioned](<LINK_0> in #408, this variable should be renamed to "args" to be more descriptive.
Good note. I think USER_PORTRAIT would be better so it works upside down too
Why are we configuring drawer in this activity. This activity shouldn't have it.
add message to log
What if client is null?
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
@apc999 This needs to be public or reflection will not work
This is already initialized by super class.
correct.
Any reason in particular that it shouldn't give the effect to players?
Check first that target is not null.
should be ...object instances can be deleted"
static import
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
could use diamond op
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
@stefanbirkner I question using LinkedList here, because I understand that ArrayList, the main alternative, usually performs better on modern hardware because it can better exploit processor caches due to it using an array internally, whereas LinkedList cannot due to it using pointers.
why ConfigurableApplicationContext, not ApplicationContext?
Sorry forgot to mention to change the read to access here too
style nit: remove curly brackets
Should you set the module logger after calling WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(logModuleClassLoader)? (as it is done in activate)?
is this required ?
I note this is using the same namespace as the pre-existing "aggregating" metric.
can this just be collapsed into a single writeAndFlush() call?
please add new HelpTag and HashName (as in StorageListModel)
consider a ternary statement instead...
I might be wrong in understanding the bug. Correct me if I'am wrong. But, the bug says "Message in the Restore Popup is not correct when volume is online and snapshot is deactivated" and lets assume now that the snapshot is deactivated and then without this change it would go into the else which is doing the same as your change already right?
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
Could change to ProcessInstance.STATE_ACTIVE ?
This should check to make sure that notificationUUID is not null before attempting to delete it.
check to make sure notificationUUID is not null
It doesn't look like you are doing anything with the bucket here. This can be removed.
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
Maybe make this a static final List now that is is used two places? (here and line 123).
have a default constructor with reasonable default values
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Integer.parseInt
Shouldn't options be Immutable?
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
Looks ugly and potentially a source of future NPEs.
what if fParser != this? shouldn't this be fParser.createTimestamp
Please use the Spring's Asserts for that, for consistency with rest of codebase
unrelated change ?
This doesn't seem to be used?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Would return builder(SecurityLink.resolved(security)); be simpler?
nit: param doesn't need final
don't catch, but instead allow the ExceptionMapper to handle it
Better, but use logger.logAndThrow(new ...)
This method is not being used anywhere. This class has findbugs failures as well
we never use NULL, it is a bad practice in general.
is there a reason for StringBuffer instead of StringBuilder?
Since Kieker now requires Java 7, you can use the try-with-resource clause here.
don't forget default case
When you move the default keyword to the corresponding case you don't have to implement it twice. :wink: java case R.id.brick_glide_to_edit_text_duration: default: // Code
Left over from debugging?
The try-catch surounding this can be replaced with JUnits [ExpectedException](<LINK_0> rule. It reads a bit nicer.
do these test methods really require throws Exception?
should this exception be left to bubble up and fail the test ? If afterEach fails it means the repository was not shutdown properly
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
Maybe make it _this.pool_ to keep it consistent.
Actually as Part of reusability we have added Synchronized block inside TrapReceiverImpl.addToSnmpV3Users and same we are calling here.I hope this serves the cause or If still synchronized is needed even for this block i can update it.Please let me know if its necessary to wrap here as well.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Do we want the toString()= in here ?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Just return checkNotNull(id, "id").split("/");
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Consider adding null check here.
Finish implementing function?
Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute.
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
This shouldn't get thrown.
nit: style wants newline
Do you need the fully qualified class name here?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
I believe that this validation doesn't belong into the API. I'd suggest to modify this 'ticket' method so that it works similar to the 'ticket' method in the 'BackendVmGraphicsConsoleResource'. If the 'graphicsType' is null, it should pass null to the 'SetVmTicket' command. The command implementation should then check if it is null, and generate the appropriate message. It should also check if the VM is down.
Oh yuck. ;)
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
protected instead of package protected
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
public
Why we removed final?
Why do we even have this check. It seems like issue in other place of the code.
just readability - we can move 'updateAllVmsSucceeded' declaration to line 118, as it's not needed for floating disk flow.
rename to contribution
style nit: no braces around single line blocks
You should probably call super.dispose() here too
Likewise don't need the if statement since the optional value will return empty.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
Remove the if.
Please use TIME_FORMAT instead of "HH:mm:ss"
Please make the constructor private (see Invalid).
What if the string doesn't end with a " or '? You'll strip the last character.
nit: use SUBJECT
What are your thoughts on using an AndroidPreferences instead of a raw SharedPrefs?
I would use something more random here, like RandomStringUtils.randomAlpha(Tv.TEN), for example
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Local variable could be declared List instead of ArrayList. Is this worth caching?
This exposes the unicode workaround to the public.
check name?
Can we check for an empty string too, please?
shall it also be >= 0?
Have you intentionally omitted index check?
Is this correct?
This needs to be changed to return the long value.
No need to use UriBuilder
No need to use UriBuilder
Just this.home is enough
return tags;
I think we can remove this line.
returning null cause null pointer exceptions
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
shouldn't use the CLUSTER log CLUSTER.debugf("Shutdown while handling command %s", command);?
Again, we shouldn't do this.
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
Asserting the exception type is sufficient.
You don't need to add this exception to the signature as it is an [unchecked exception](<LINK_0> :)
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
sorry i missed that before, you should send "getActionType().getActionGroup()" instead of specifying the actionGroup here, and specify the correct action group in VdcActionType enum (where currently it is wrongly MANIPULATE_USERS it should be the new EDIT_PROFILE
make permissionList private variable, permissionList should be created only once
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
**USB**-serial
Do we care about threading? device is set in the thread that calls initialize (in the parent class), device is unset (set to null) in a thread used by scheduler. So, should we use volatile, some synchronization, ...?
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
agentDisconnect also sets this state.
Rest of the class does this lookup in the DataPurgeJob instantiation, this should be there also for the clarity.
sgtm
ImmutableSet.copyOf(Iterables.filter(...)) ?
ImmutableSet.copyOf(Iterables.filter(...)) ?
That's good to know.
Can this happen ?
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
you should have here setSucceeded(true) IIRC.
Do not forget to check that there is no link after enablement/disablement of the preference. With separated tests like the current stat f the class, we do not control the order of the tests.
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
Mid return may worsen readability
is it not empty if for example type is an valid empty string?
You have chose a policy=static for the reference, so it cannot be null.
The "Name" class implements correctly the "equals" method, so you can do just this: return SCHEMA_ENUMS.contains(type.getName());
if these strings are used elsewhere, create static constants and share
If the list is static, then you don't have to remove the static modifier everywhere. However, I would prefer you to use a dedicated getter lazily loading the configuration of excluded types.
Why decryption is excluded?
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
can we factor out this code, here and other places? e.g, java return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)) .subscriberContext(reactorContext -> factoredOutFunc())
assertThat(element).hasTotalSize(6)
assertThat(result).hasId("analysis")
Ik. Maven has logging facilities. We should use them.
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
formatting
We could also have a test to establish that we can be rate limited on one read and then have a smaller read succeed.
Because there is only one argument, we can pass workerMetrics instead of an object array.
Inconsistent log format. Use either {0}th or {0} th. {0}-th is even better.
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
typo notifiedMessage ?
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
make it fluent
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
This method looks horrible to me (and to whoever is a sane engineer, I should think).
We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than this.
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
just = bit != 0?
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Is this double invocation performed on purpose?
I would always call stop regardless of the mode (and make sure that stop is a no-op if it wasn't started). That way, as we implement other modes, we don't have to update that piece of code.
does this need to be a class member?
You could use METRICS_PERFIX constant here instead of priam
Typo? "BlobDet4acryptionCount"
please add setSoftLimitInterval() setter and use it.
We need to get rid of DefaultMinThreadPoolSize and DefaultMaxThreadPoolSize and define those as JMX properties inside ovirt-engine.xml.in
Consider getting this value once, and save it, instead of calling it twice.
@fanifieiev Let's put this in a constant.
@fanifieiev Why not use the constant here too?
... remove the final modifier from the method. It will be easier for future tests.
We get to rename this variable to prefix it with is I guess
Don't we usually include a test for these validations?
Does getEmails2 always return a collection? Take a look at code to be sure. Concerned about possible NPE.
should be false unless one of the vm's disks has true for this
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Why should the About dialog no longer be resizable?
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
It would be great to rename the variable to isParamCountValid.
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
this is redundant with next instanceof check
since this is the vdsbroker, you should be able to use java.util.Objects.equals()
Please remember this ctor changed.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Would be simpler as: return Arrays.asList(Action.RELOAD);
this.
Could change the return type on method to Collection
I realize that the test case was just moved, but maybe for a separate commit or a follow up: Maybe the error could also give a hint on what would be correct. E.g. StringType can only have a single parameter value, received: ... Also in the other error messages. E.g. with 0 it could point out that it must be > 0.
the method name is misleading. You insert a default organization uuid but it's failing. Why?
Since IllegalArgumentException is an unchecked exception you don't need to include throws here
user.get() can return null
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
I could be missing something, but why can't we call deleteAll with toDelete and not create a separate KeysIterable temp var? Actually, this method doesn't even need to accept an iterable over entries, just keys.
value is redundant, just return right away.
are these setters used anywhere?
Same here. Add clarifying parenthesis
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Same variable names (change to senderVouches.
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
The smile has an impact on the currency exposure. Run the test with a VOL_PROVIDER_FLAT such that RISK_REVERSAL_5_FLAT and STRANGLE_5_FLAT are 0.0 everywhere. The last 3 lines of the test are incorrect. Replace by: double ceBaseFD = pvBumped.getAmount() / (SPOT + FD_EPS) - pv.getAmount() / SPOT; assertEquals(computed.getAmount(EUR).getAmount() \* FD_EPS, ceCounterFD, NOTIONAL \* TOL); assertEquals(computed.getAmount(USD).getAmount() \* (1.0d/ (SPOT + FD_EPS) - 1.0d/ SPOT), ceBaseFD, NOTIONAL \* TOL); The code in 'BlackFxSingleBarrierOptionProductPricer' seems correct, it is only the test which is incorrect.
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Use catch (NoSuchAlgorithmException | KeyStoreException e) when having multiple catch blocks with same output inside them. Also since you are catching 'Exception' finally and throwing the same exception with same message, the 1st two catch blocks has become redundant here. BTW its not the best practice to catch Exception, its better to catch specific exceptions and handle them. Any reason for catching Exception?
this.lockVerbs (like below)
This condition seems like it'll fit in InstructorCopyFsToModal.java more, to reduce the reliance on that id string.
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Make this "info". there's relatively fewer operations scheduled on the executor, and would be good to log their completion status
nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Get the service registration reference and unregister within the deactivate method
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Let's re-word this to a forced shutdown
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
Pretty sure this is also supposed to just be the localization key.
getUsage(...) expects a localization key.
getUsage(...) expects a localization key.
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
Assertion is missing for operator name
it is not really needed, we can simplify the code here
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
Doesn't List as a Collection have a defined method to check whether it's empty or not?
idx -> index
can just do new ArrayList<ICommand>(commandMap.values()); instead of separate addAll
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
discussed a bit more, we're going to make both key-values, and make sure to split on just the first colon
studentsWhoRespond -> studentsWhoResponded
Could you check for null or empty? Via StringUtils.isBlank
these 3 methods are public do you really need them?
">=" would be robust, even though not possible as the code is now.
Can lease.getStartingAllowedRequests() every equal zero? Might want to check for that.
withMillisOfSecond(0) is not necessary here if it is used above.
same here re: serialization test; probably worth having an example string to verify consistent serialization, would recommend a non-zero duration too (because zero will frequently be serialized on a different codepath to other things).
Verify the injector has been set before using the delegate here
Similar
Similar
Please remove this line
Could this just be a plain getActivity() call? Any reason you need a BaseActivity for startSupportActionMode?
Can be transformed into an if statement.
Is it the 'native snappy library' that is missing or the java-snappy jar?
In the original code, we throw a runtime exception if the native snappy is not found. Should we follow?  throw new RuntimeException("native snappy library not available: " + "SnappyCompressor has not been loaded.");
nitpick : final Throwable t
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
u can simply use System.out.printf("Please enter a password for %s:",user);
Is there a need to have both asserts? The reason I'd prefer only one is that I don't want the user to get one error, fix it, and then get another. Since nonNull is implied by hasText, we can give the user only one error message that will repair both problems.
I think this should be > 0 since a value list item of 1=One does not work.
If the input string is "(123(456)" this approach will strip the middle bracket and parse when it shouldn't. You'll need to use substring()
Is this still needed after removing the download stuff?
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
you can collapse these 2 lines
It doesn't seem that you did what I asked for. It should be checking the toggle in addition to networkinfo. If the toggle is set to offline then it should return false. If the toggle is set to online then you can check network info and if there's no connection set the toggle to offline and return false, otherwise return true.
Pull this into a static final variable
You could have inlined this loop into the other method because this will create 3000 threads.
should this count be parameterized?
Needs to be in finally - we might get interrupted.
should this only be set if the latch.await above returned true? in the current impl I don't think it would make a difference since clientTimedOut is checked prior to clientHasReceived in the if/else below, but that order could be a fragile assumption
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
Cosmetic: Please, split the throws list clause on separate lines.
What if this path actually exists on the user's workstation?
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
scheduleTimes --> scheduleTime
same as above with the actionBarWrapper
make it protected. It was my fault to make all API constructors private. I fixed that. In master branch all API constructors are protected, so anyone can extend API in their code if they want. But couldn't instantiate directly, forcing them to use singleton
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
please use java.util.Objects.toString(username, "") instead
maybe use dnsServerAddress.isEmpty()
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
I haven't tested yet but the code seems ok
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
We can use the res variable here instead of getContext().getResources().
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
public?
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Same here, keep the order consistent with BenchmarkSuiteConfig
need to change as well
Removing the interceptors removes logging.
This cannot be removed. The scheduled task needs to be saved.
Output the message that caused an exception, possibly at the FINE log level. Also include the exception parameter so we can see a stack trace.
Here and below: previously the code used only one table lookup operation, not it performs two lookups. Please consider to use get(name) and check the value to decide if it is illegal or not.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
Use this.key
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
why exit here ?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.
not sure why this field is public
It's better to cache the values(), a new array is allocated on every invocation.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
> Use emoveCallbacksAndMessages(null) to remove all the messages. > Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
refreshJob field should also be set to null on dispose.
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I'd recommend using <LINK_0>
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
Why not just include FlagUsageException in the throws here and then if it's thrown it will still count as a failure.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
Collections.singleton?
What's the point of adding a copy here?
different value 50 versus 1. Is that intended?
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
why do we have a ; here?
remove redundant ; it will only cause static analysis to complain
previous naming was more clear.
Probably makes sense to move this up too.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Saving preferences inside a setter is not appropriate. Please follow the pattern used for other preferences.
are spaces OK in namespace strings?
as above: are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
fos can be inside try ()
Should that be 8192? 8024 seems like a strange number.
I think try with resources should be used.
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
redundant ";" character
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
For loop?
For each?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
you shouldn't need it as UnknownUserException extends LoginException
Is this reload really necessary?
If resources are not dependent on each other, reload after adding isn't needed. One reload after adding endpointConfigurationAddress and one after adding both preHandlerChainAddress and postHandlerChainAddress should be enough.
"Clean orphans from PROPERTIES" to be exact ?
Do you have time for this? We talked about it on Slack.
I think we should leave getClassName() and getMethodName() as is but _only_ pass them to PojoStackTraceWriter to "optimize" the stacktrace.
It's not a _really_ expensive computation but how about using orElseGet?
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
You could probably use the same URL as in getResultById here.
Should this refer to a platform-relative constant?
Well that's a bit dumb :/ Ah well.
If you have to cast here then you probably should have casted when reading the value from the data array.
use use java.util.Objects
Change to use this.jsonAsString.hashCode().
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
Should this constructor one just delegate to the new one with Function.identity()?
extra ()
super.init() method never throw an exception.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
Throwing the generic Exception ?
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
Here's another reason for why magic numbers are considered evil: This time it is six 9s. Over in AbstractWidget it is _five_ 9s. On purpose? Bug? With a public static constant you wouldn't have to worry or ever have to make a change in more than one place :-)
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
This cycle has very confusing brackets. Could you please add brackets to if and properly tabulate the last bracket?
Here's another unsafe cast that can be changed to use mapperType.cast() instead.
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
This one is already done on line 816. Do we need it again here?
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Likewise.
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
Is it worth distinguishing what is null in this case? Is it different if m_txnState or the invocation is null
Remove the redundant null checks.
what happens if you call this several times? It will recreate again and again the asked number of threads. You should have some flag to specify that it's already started no?
with 10 threads I can almost always reproduce the bug.
Suggested to extract a static utility function zeroOut(ByteBuffer)
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
I have doubts about this code. It means "a single-line case/default must end with a break, otherwise it needs a pair of braces". For example, this code raises two violations regardless of allowSingleLineStatement option:  switch (0) { case 1: return; // false violation default: throw new RuntimeException(""); // false violation }  and they can not be fixed by adding a trailing break. Why not check the last child's line? Something like  private static boolean isSingleLineSwitchMember(DetailAST ast) { final DetailAST slist = ast.getNextSibling(); return slist == null || slist.getFirstChild() == null || isOnSameLine(ast, slist.getLastChild()); }
it is strange to see all those code to handle null if we are using optional...
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
correct thread safe code looks like this: if (stopped.compareAndSet(false, true)) { cancel(); }
The Exception is never thrown.
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
The above 2 set* calls don't make any sense other than the fact that the call generates a logger.info line. Note that connectRetries and reconnectRetries are defined only in AbstractSolaceBaseInputOperator so super.setConnectRetries(this.connectRetries) assigns a variable value to itself via a function call. Need a reason for this code.
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
I thought empty was OK, and it would point to latest?
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
Can this be private, or is there another use case for default attribute outside the builder's call?
Please remove this field.
shall we rename this as brokerUrl ?
merge else if?
how about doing it a bit different: change #1259 to something like: devices.stream().map(VmDevice::getId).forEach(vmDeviceDao::remove) and this method to something like: removeVmDevice(devices.subList(...))
don't need to wrap safeFormat
I think it is done on purpose to avoid auto boxing/unboxing.
To be sure, we choose this format: blobExpression == null ? false : blobExpression.isLiteralText(); regarding this one: blobExpression != null && blobExpression.isLiteralText(); ?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
no!
This is good, this thread does not cause the bad failures and dealock anymore. But it should mark the analysis as failed. And for very large traces, I think some failing mechanism should be put in place, to cancel the analysis. For instance, the waitForCompletion could wake up from time to time and make sure the analysis has not failed in the meantime. While this works perfectly fine, resources on a computer _are_ limited and it is better to avoid dragging this thread, and the request thread, and the threaded backend thread and some more view threads waiting for this, imho.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
You should also update the error message in order to tell users that this option can be used in order to switch the duplicate field validation off.
Now that services are class members, we should not need to pass them internally in functions either. Please remove them from parameters and access directly in other functions. This needs to be done for all instances of ontology and germplasm data manager services that are being passed in function parameters. I will fix this @abatac while I am syncing master.
Do you want to update this one to make sure that the key _and_ the value are there?
Done, it looks like the change was not included in patchset1.
@jmmut should these checks be placed after the variant object has been constructed? I remember there was some weird situation with code being executed after the checks.
We generally prefer assertThat(..., is(..)) for better error messages.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
Ik. Maven has logging facilities. We should use them.
Use IResource.adaptTo(Class).
local variable e is never used.
one more method where it can take file location of properties would be good.
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
What's the point of adding a copy here?
close streams
I think you're missing getDefaultConfigurationFile() here.
Again, use IOUtils.
Needs some sort of assert to show it succeeded
Just for fun ... I'd fid it more readable to have a static import of Mockito.mock() (this is a complete detail, feel free to ignore).
please use static import for Mockito
You have yo use compareAndSet
maybe we don't need AtomicBoolean?
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
Why going for semantic here ??
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
requireNonNull
minor, is it method scope for Visible For Testing? If not please change it to private.
there is no need to convert to map. can we directly print headers ?
I think we should have a better exception message, it should state that the header is not allowed to be set by the user
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
This should always be read from the configs.
Why should the About dialog no longer be resizable?
I suppose this should be true ?
Why is this removed?
we need to reset this property in a @Before block
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
Use Logger instead of sys out.
Debug still needed?
Assert.areNull
Please use the correct "assert" versions. To check for equality, "assertEquals"
@gjd6640 how about making this more explicit and robust this way:  int windowsOffset = System.getProperty("os.name").contains("Windows") ? 1 : 0; assertTrue(firstHighlightingData.startOffset()).isEqualTo(1 + windowsOffset); ...
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
suggestion return format("metadata[%s]", key);
should use a format placeholder instead of string concat
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
The operator should be && not ||
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
missing final
should be named resource
flagging that we should fix this in the next major version and move back to a parameter for the id
should be called resource
This needs to be changed to support locked stream syntax now.
I think this is main issue that needs to be resolved. The problem is that this implementation can consume a lot of resources because of the retrying and the long latency. It could even end up in a livelock. The best approach is to get everything done in a single remote call. There is no retrying needed here because the operation will have exclusive access to the partition.
I think it'd be a bit cleaner to move the value type check into nullSafeValueHolder.
"else if" maybe?
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
should be logged only once, not for each block (spooling is either enabled or disabled).
extract out into a const?
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
This is not necessary.
unused variable
Why don't we make inDegrees to ConcurrentHashMap also?
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
is there a reason why this method isn't implemented?
What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
This code can be called from RefreshVdcOptionCache() method too, instead of it being written there also.
I would consider rewriting as: if (values == null) { values = new HashMap<String, Object>(); _vdcOptionCache.put(option.getoption_name(), values); } values.put(option.getversion(), GetValue(option));
This could be entirely done as a stream.
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
Also added a try with resources here.
RocksDB reference.
remove this?
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
This used to be mBoardSize.height + 1...bug?
You don't need this line because of green 31.
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
given/ execute/ assert
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
I would add in reindexing at least one ref tag to show if it updates correctly.
Not worth debugging for this QS
Not worth debugging for this QS
Not worth debugging for this QS
hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm! so we cannot validate this on gwt, but I do want to validate it at core. can we have something conditional? if the isAssignableFrom works then perform validation else not? when gwt will not use these classes any more we can just remove the conditional.
Might make sense to use a RowMutation here and have the PutAdapter take a MutationApi interface
Should this use RANDOM_PORT_INDICATOR instead of 0?
Don't we have to say that this is uniqueId JDBC?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
just use context as synch obj
One more - this will be 3
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
[Checkstyle] ERROR: '{' is not preceded with whitespace.
is Options.INDEX_ON_THE_FLY the same as Defaults.CREATE_INDEX?
I feel like there should be a Defaults.toString() or similar for this sort of thing...
Any way to combine both of these try blocks, since it's basically the same error message?
any particular reason why this method doesn't require an IJavaProject ?
are you sure we need to use OSString ?
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
This is an opportunity to stop the bleeding for this naming standard. I would suggest using the bean naming standards that archaius uses.
just return ListeningExecutorService
given that specificity of this SV is exception type I would add the exceptionType in this.
code format
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
This will add the flag to *all* read-resource operations. I'd rather add it only when necessary as suggested at <LINK_0>
shall it also be >= 0?
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
are these setters used anywhere?
this works only until you maintain the order with the values. Safer is to write it like this: return Arrays.stream(values()).filter(e -> e.getValue() == value).findFirst().get();
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
this is not thread safe, nodes can be modified while building the subgraph. I suggest to use Lock for reading and writing accordingly instead of synchronized blocks
The local var is useless, you can remove it.
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
return void
how about  java private boolean needAck(Message message) { return message.getSequence() == message.getBatch().getWindowSize() }
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
add braces
I guess this doesn't really matter but we normally use toImmutableSet so just keep it consistent?
instanceof Dataset is redundant
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
pull this out into getMockAuthorizer() {return getFileSystem().getAbfsStore.getAuthorizer()}
I think we can still end up with < max threads in the following case: there is only 1 thread doing work, rest are waiting on queue.poll the thread is going thru files or the list responses are slow. it is yet to queue up any subdir. The rest of the threads timeout and fall of their thread main
1. close() the stream and ask for the stats again, to verify they are still readable 2. call toString on opened and closed streams.
This will remove description set, please remove.
Maybe the simpler thing is to send the content type as "application/x-xsrf-token" and have the server require this as the content type of the POST body. This makes it harder for a browser to format a valid POST request using a traditional <form> tag. It also means the server won't attempt to parse the _token field from the POST into the parameter map, which means you don't need the _token hack in the CmdLineParser loop, and you don't have to worry about + or = being incorrectly handled somewhere by an incorrect escape. Alternatively we make the GET return valid JSON of {_token:"text"} and we echo that as-is using a JSON content type in the POST. Just as simple for most script language tools to work with, the client just has to strip the first line of the response body from the GET (to remove that JSON_MAGIC literal) and echo that as the POST body, with Content-Type set to JSON_TYPE ("application/json").
This will remove description set, please remove.
There is no need to set the local scope reference to null, but if you prefer...
I would prefer to use System.nanoTime() for such time, as it is independent of the system time and cannot be corrupted by time changes.
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
matter of taste, this could also be return this.profileTypeRegistry != null;
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
Can this be private, or is there another use case for default attribute outside the builder's call?
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
Is value == null a valid case here?
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
No need for super()
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
Do we need to start deprecating some of these cases if we are going to just combine them?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
What happens to dst and copier in this case? try-with-resources style wouldn't try the close() again, so should we retry the close to prevent them from leaking?
Why uppercase fs?
I would suggest using the related constant instead.
I would suggest using the related constant instead.
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
Should we add null check?
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
use return ... ? ... : ...?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
How big is the overhead to do this check on every log?
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
[nit] There is also a cleaner approach using Guava:  java return Enums.getIfPresent(LoadbalancerAlgorithm.class, value).or(UNRECOGNIZED);
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
Send this exception to the log.
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
I prefer to use the member "instance" instead of the return value. It's a little bit of confusing.
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
Catch exception.
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
Use constants
checkNotNull
With zero knowledge of the code, are you sure this object is not reused? Because if it is a scheduled task it be just reset rather than recreated, but you cannot reset the telescope client, you'll need a new one.
the workspaceitem needs to be deleted
Why Exception instead of Throwable like we did for before()?
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
final?
Binary output length can also be calculated.
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
You may also want a test case for a search value that is non-blank but invalid.
This should be public
Have this call the other tryEvaluateWithAll method
Can be reduced to throws IOException.
Can be reduced to throws IOException.
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
Should we add null check?
Assert there is no JPrimitiveType in types?
why do we have a ; here?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
copyright
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
please replase MojoExecutionException for a new generic DeploymentExecutionException
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
I think we should remove the following events
I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one.
14_000_000
You should be returning the values returned in getCalculatedProlepticMonth() here instead (ie, that leap-day is accounted with the 7th month, and year-day with 13th). Ditch the other method.
As there's no extra handling when an IndexOutOfBoundsException is caught, both old and new code behaves the same way: any exception thrown by logicalPages.get( page ) will always be thrown back! As so, the try-catch is dispensable and it's best to leave the code as it was.
Duplicated code, try to share/reuse.
Duplicated code, try to share/reuse.
get rid of "..." not enterprisy!
Can use java 8 paths.
Is there another place where we can define this, so that this does not need to be defined in RealVoltDB as well as here?
move this line before above line, After super.cleanup method couldn't do any of the server requests.
As noted above, just put the init code in init() unless there is a reason not to.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
You should use ThreadContext.putAll() here.
Unnecessary (and incompatible); revert.
Typically we use Map on the left hand side rather than HashMap
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
Is that safe to call when not holding it?
I think Long.MAX_VALUE is too long. How about using 1 hour?
:smile: We prefer to use fail("BeanDefinitionStoreException expeted.") within try...catch
I think your tests would be cleaner and more clear if the validation methods returned true/false instead of throwing an exception. If there is a good reason to keep the ValidationException then I think it would probably make more sense to have a boolean local variable here, something like success, that is initialized to true and then set to false on catch. Then you would have a single assertTrue statement at the end: assertTrue("The counts should be been the same.", success); The same goes for all the tests in this class.
y not use @Test (expected...)
You can use try with resources here so the Input stream is closed automatically.
Is it OK to swallow this entirely?
@xxDark can you link to the spec where all of this is explained ?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Should this method be private or protected?
Racy. Maybe just chuck a synchronized on.
Delegate to isNonCodedDrug() when making the check.
Remove?
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
need to remove this print or convert it to log stmt
Shouldn't options be Immutable?
throws TaskException is part of the interface, did you mean to remove it?
Config class have constant defined for default config file name
The <Integer> can probably be omitted.
EmptyConfig.INSTANCE?
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
Could be inlined here by using test()
This needs an @Override annotation.
style nit: s/if(/if (/
This is fine, but why did you think of changing it to protected ?
consider to inline uris
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Nitpick: startingCounter?
You increment just one of the counters. The total is produced by prometheus automagically. So basically, we could have: starting_attempts.total#debug=false and starting_attempts.total#debug=true and just increment one of them here. We would not have an untagged counter at all.
This is using the default locale when converting to bytes. Not sure if that is a big problem since changes of the locale should be fairly rare and under our control, but still..
Type casting again.
Type casting again.
Using a try .. catch block instead of pre-checking with contains is bad code style and also not very _fail fast_.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
Collections.emptyList() seems cleaner here.
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
We should still be able to set the dialog's title (?) In this case, title is always dynamic as it comes from UI plugin API function call.
This could be: filterListEditor = createFilterListEditor(); filterListEditor.hideLabel();
Remove public
rename to contribution
rename to contribution
enableEditingButtons(..)
Why do we have this constructor?
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
I really don't like this convention because it means that we can no longer rename-refactor the identifiers without changing the meaning of the program. It is in effect a very subtle kind of reflection. So I would prefer a distinct string field in this case and others like it. I realize that there's lots of this kind of thing in OCS, but we should fix it when we encounter it. Does this make sense?
nit: language is not supported: %s ?
Using a static map would be easier?
Put this exception in the default branch of swith.
can this just be boolean instead of Boolean?
Add TODO to not forget implement this in the future.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
.hasSize(), 2
This is not time zone?
isNull()?
Do we need to null check event.post here?
This line is redundant.
We can drop final PostModel post = event.post; at the top of this method.
Is this signum call really needed here? compareTo should already return the correct value.
Also, there's no zero comparison covered?
I suggest using "ComparisonChain.start().compare(o1.name, o2.name).result()" - Location.name can be null.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
The editor can't be null
I think this should be replaceFailed = false instead.
getFullName()
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
do u need to guard against NPE's anywhere here?
I would suggest extracting the format as a constant and hardcoding some of the format constants instead of doing it the other way. e.g.  CONTAINER_HEART_BEAT_SERVLET_FORMAT = "%s" + "/containerHeartbeat"; CONTAINER_EXECUTION_ID_PARAM_FORMAT = "executionContainerId=" + "%s"; CONTAINER_HEART_BEAT_ENDPOINT_FORMAT = CONTAINER_HEART_BEAT_SERVLET_FORMAT + CONTAINER_EXECUTION_ID_PARAM_FORMAT  Or some flavor of the above, so that you can reuse the format across the unit tests & other places in code. IMO, having the constants by themselves still forces users to figure out how they come together and repetitive code e.g. "%s%s?%s=%s" with readability hit as well.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
return Arrays.asList(boolean.class, Boolean.class)
return Arrays.asList(....)
close already done in Util.read(..)
here we should guard against null is
Since we don't usually run with assertions enabled, please consider converting assert to Preconditions.checkArgument.
Now this method does not do as it's named...
you should have here setSucceeded(true) IIRC.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
Let's have some constants here instead of repeated magic numbers.
Wouldn't it be nice to check the path was observablePath rather than _any_ path?
unsubscribe()
We could cover it with some tests.
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
only EE product can have runtime lineage
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
Check the env variable before returning true.
Check env variable before returning true.
This should check the environment variable before returning true.
We should close the FileOutputStream, relying on finalizers is very finicky
I wonder if this is really necessary... jansi uses [isatty](<LINK_0> to avoid writing the escape codes when output is redirected.
I don't like the word "command" in "where the WES command should run". If anything, you're sort of running the (client) command on your local box. How about The URL of the WES server, e.g., ..... Also, I think you should say URL, just to be consistent with --wes-url; right now it's a mixture of url and URI.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Instead of using the message, evaluate the topic to generate a good string message
Are you sure we need that condition? Are you able to cover it by test case? The null-test was not present before and I can't see any test related to that.
Why is it a list of lists, not just a list?
Style issue: @Override shuld be on line above the method declaration
You can use GenericMath.DBL_EPSILON here.
Does a straight comparison work here? NaN isn't usually equal to itself.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
Why is this removed?
Will not delete directory. You should FileUtils.deleteDirectory
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
DEFAULT_HTTP_TIMEOUT?
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
I think this method has no need to be static
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
Let's use debug level instead of info.
Encapsulation
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
Instead of repeating the addition assign it to a value on the stack.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
Release lock?
Move the logic to configAccessor.
Since this will add one more zk read, and admin.getClusterTopology(clusterId) actually reads the cluster, I am not sure how heavy this call is. I assume it is mostly used during deployment? I wonder if we can use the result in admin.getClusterTopology: if the cluster doesn't exist, an exception(HelixException/NoClusterExistException) is thrown. Rest code here catches it and returns 404. Then it saves one zk read.
These lines could be in a private check method to reduce duplicate code.
Nitpicking, but I'd prefer creating the builder with  org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder(hotRodServer);  and then setting the marshalling. Same in RemoteStoreMixedAccessTest
I don't think setting the timeouts are required in this test, especially since the default is already 60 seconds.
I believe we should add the ability to override the baseUrl of the s3 client. This will allow support for beta regions of S3, and other s3 compatible storage APIs (GCS, Azure CS) <LINK_0>
There is no call to this method outside TableManager, shouldn't we change it to private?
s/RemoteTable/RemoteReadableTable
question: why do we need the TableImpl class? The only usage of the tables map is in ExecutionPlanner.createJobGraph() and it is only taking the TableSpec keySet. Also, it seems that TableImpl class does not provide any further functions except as a container for TableSpec. Can we remove it?
Magic number <LINK_0> Try to use a constant for the timeout. Review the constants in the project.
this is already called in BasePageObject so you don't have to call it
you can remove this
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Should move this try/catch deeper into the call stack, either the public overload or in the package-private method so that we don't need to put it in multiple locations.
Did you use our code formatter? <LINK_0>
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
In alignment with valueOf, perhaps name this valueOfType or fromType?
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
Why is there a fromByteArray method? Why not call the constructor directly?
I think it is common to return the written value.
Superfluous blank line :).
For each?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
int[] props would make everyone including the style checker much happier
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
This line is redundant.
that class would be better with a builder, though I wouldn't ask changing it now
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
You could remove method("POST") as you set the HTTP method on create
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
wouldn't UnsupportedOperationException be a better match ?
Same here, no need a transaction
No need to make this a transaction, its a single insert statement.
The value checking is not needed here, only the preference. We already check the value in the other test.
HQL/JP-QL
clause?
Detail: FROM capitalized.
Could you please use DecisionTableInputType.XLSX
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
looks broken, as L262 will always get a closed stream
Optional.ofNullable could be used?
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
The original code style in this method is better:  private PagesSerde createPagesSerdeInternal(Optional<SpillCipher> spillCipher) { if (compressionEnabled) { return new PagesSerde(blockEncodingSerde, Optional.of(new Lz4Compressor()), Optional.of(new Lz4Decompressor()), spillCipher); } return new PagesSerde(blockEncodingSerde, Optional.empty(), Optional.empty(), spillCipher); }
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
I think we can use ConcurrentHashMap::computeIfAbsent to replace synchronized and containsKey
Shouldn't the restoration be in the reverse order of the activation? So that we first restore the last activated context?
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
Not a good idea to have two methods with the same signature except for the type, espcially when one is a subtype of the other.
I would have inverted the check but that may be unnecessary
Encapsulate this here. Should be returning a MapView here.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
we need a gauge metric here to ensure the thread is running
Why this debug log is removed? Not sure, if it's there for any security issues.
please provide e as argument for stacktrace
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
-1. This means input does not get read.
Style-nit: Should be after this.accountCache = accountCache.
Here you use Byte.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
You need to send cookie here.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
suggestion return Arrays.toString(value);
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
It would be even better to get rid of this line: java String.join(" ", translatedWords);  with java .collect(Collectors.joining(" "));
I would suggest using the related constant instead.
I would suggest using the related constant instead.
Why uppercase fs?
name could be more descriptive
Vague variable name s
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
throw new RuntimeException(e);
nit: how about we just use the class name of input strategy by default
could uh, use checkState(false, "") instead of a lambda ;)
AndroidStudio's inspection highlights and suggests replacing indexOf with contains for the condition expression. WDYT about replacing it? If we will touch this line, and since the index is recalculated below, how about introducing a temp variable to hold the index to avoid doing the lookup twice anyway?
These should be marked as abstract and let the subclasses should implement them.
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
Avoid duplication with:  long sliceLength = Math.min(getRemaining(), partSizeInMB << 20);
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
These seem to be covered by NUMBER_TYPES already?
This could be confusing here. How the user know the all fields?
let's call it updateCodeMinings() instead.
ooh! I ...Connector, here!
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
Please add ? and % as well
Isn't it also important that adType was async and method was top?
Please remove an excessive space character.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
Added because?
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
Should not be able to submit when there is no question selected.
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
Should the InterruptedException here be treated as a cancellation?
You can use GlowServer.logger.log(Level.X, "message", exception)
seems like synchonized is not needed here, given increment/decrement already protect
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
Not good to use Optional for collections, just return empty collection
Should we use UTF-8 instead of default character setting?
maybe test first char for empty letter as well to reuse s if possible?
can this use the MMX StringUtils functions?
Is it really worth checking before setting it?
Should you be closing the connection as well? What happens if the caller attempts to execute query after closing the prepstmt
just remove this check and the corresponding else. managementRealmOpenTask permissionRealmOpenTask may finished at the different time, so you could have managementRealm != null but permissionRealm == null
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
This could be reworked to avoid having ! in nearly every condition to make the different cases cleaner to read.
Why not push/pop methods ? bit clearer IMO.
suggestion if (this.currentTask != null) checkAndRethrow();
Same why not else if?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
I prefer ", not "+(l == null ? null : l.getClass()));
This method can be static, as all the methods it calls.
Since this logic is getting more complex, it probably makes sense to reuse isBindableType here.
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
Shall Alter database to add source_of_replication DB property and see if Dump succeed afterwards.
It looks like sparkObject could now be a byte[], so should setSparkObject call deserialize here, the same as the code you added in getLength() ?
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
final
Unnecessary.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Why not unconditionally update the SessionData?
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
Is it possible context.getAuthenticationInfo() is null or context.getAuthenticationInfo().getUser() is null
I tend to prefer having all code at the same level =>  if (0 != context.prepareSelect("select count(uuid) from quality_gates where is_built_in = ?".setBoolean(1, true).get(row -> row.getLong(1))) { return; } context.prepareUpsert("insert into quality_gates (uuid, name, is_built_in, created_at) values (?,?,?,?)") ...
minor: don't need this. qualifiers
channelId => channelName
s/id/ID
The two methods above are the same except for the first line...perhaps reuse the code instead?
The two methods above are the same except for the first line...perhaps reuse the code instead?
Can be rewritten as Assertions.assertThat(utilities.getValueList(column)).isEmpty()
Parameter should be a string instead and be called label
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This fix is incorrect. It only caused the empty oplog (created by the offline compaction) is not deleted by the recovery's auto compaction. I modified the dunit test a little bit and proved it. Unfortunately, there's no flag or status to show that a compaction is just finished. Even we want to use the empty oplog created by offline compaction, we need to careful arrange the logic. Such as: change needsCompaction to return int. 1: need to compact, -1: no need to compact, 0: there's one empty file, only need to delete it. But maybe there's better ideas.
Braces on following line
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
I don't think you need this new String
If this should never happen throw an IllegalArgumentException instead.
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
suggestion return GitHubServerConfig.GITHUB_URL;
Existing code use null as the sentinel for this field, so I think you should keep using null here. suggestion this.apiUri = null;
I believe this whole catch block can be removed. The standard WaitUntil handling will be sufficient I believe.
Is it OK to swallow this entirely?
Avoid logging an error if there's already a throw.
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
please create a more specific exception that extends this one.
factor out
you could be more specific and check instance of Function0 maybe?
Can this happen ?
Clone method is wrong. Kernel/stride/padding are already handled in superclass clone. And it doesn't set depth multiplier.
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
Format this file using our code style.
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
this is confusing, it is called router but actually it is routerUrl.
Looks like you are making double slashes here...
style nit: we don't use braces around single line blocks
style nit: we don't use braces around single line blocks
What's the point of the 6 trailing zeros ?
Apply changes similar to setVisibility.
Simpler to apply the mask after the shift.
You need to calculate the righ margin to account for the width
A message might be helpful
this seems misnamed
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
you need call addColorSettingsListener on the new instance.
They are mutually exclusive? Or is that a micro optimization?
This thing does check the value for not being null. So the previous expression is redundant.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
Just in case, please wrap with Collections.unmodifiableCollection()
It would be better to not hand out a reference to the internal data structure. The TagName objects are immutable, but the collections are not.
return Collections.emptyList();
Define "data-agent-conf.xml" as a constant
duplicate regex as above, can we reuse it?
correct.
Did you intentionally ignore the patientProgram parameter?
?? why this and the following ones could be left empty?
We could throw an UnsupportedException here.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
Great idea! Can we use Locale.ROOT instead, though?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
log.trace if at all
log.tracef
Might be cleaner in terms of minimum visibility to just return the timestamp from the transaction task.
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
The cast is not needed
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
can just be return pattern.matcher(value).matches();
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
can we move this method to Utils
Use logging framework instead of printing to stdout
assuming this was for debugging, should remove.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Should this be removed from here if this is already being updated in getValue?
I am confused b/w the description and implementation of filter here.
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
we never use NULL, it is a bad practice in general.
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
This can just be catch Exception.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Should we check for systemConfig.isOutdated() as well?
suggestion return Optional.ofNullable(getLhsType()).map(s -> s.getTypeImage() + ".").orElseGet(() -> Optional.ofNullable(getAmbiguousLhs()).map(s -> s.getName() + ".").orElse("")) + getImage();  and avoid computing the ambigousName unless necessary
Must be in format ID@ADDRESS
Just an FYI for future - You can use this method for this: <LINK_0>
An optional of not null is a bit painful. Use another constraint perhaps? Do we have one test on the payload business btw. (applying it to the wrapper)?
UnsupportedOperationException ?
The current style used for the method return annotation is to put it above the declaration. This also applies to all other usages in this PR. suggestion @NotNull public static IReferencePoint create(@NotNull Module module) {
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Would suggest to make it private.
Patametrrized logging please
Why this change?
I think it would be better to make drawing the border conditional on the line width.
public? And maybe put it next to the other setter.
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
shouldn't we do it only if getParameters().getSourceDomainId() is null or empty?
Why is it setting the SD to the Master SD? What if the disk used is not on the Master SD but on some other random SD? I think qemu-img will fail and so will the import.
Something like this.
Same here. Multiple places.
You may find many examples in the existing code base.
several style nits: spaces before {, before variable names, between functions, etc.
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
invert it
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
@andreoss Why throw Exception here instead of the original IOException?
Maybe IOException since it's supported here?
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Might this not cause extra copying of the buffer contents when transferring data between network and storage?
Just personal preference, for this, I would use java 8 style getOrDefault to make it a bit cleaner :) java _currentAssignments.getOrDefault(resource, Collections.emptySet());
Move this validation to PluginProfileService.
Move this validation to PluginProfileService.
That should be toHtmlForAnthology. You mixed those two up.
side note to bringing in this dep, installing this module would also likely start up a number of pollers/db connections/zk connections/etc which we don't want
Should you call analysisReady(false) here?
Missing call to super implementation of onResumeFragments()
LinkedHashMap please <LINK_0>
why silent catch?
ConfigurationException?
should be setSucceeded(true)
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
Doing this via double math is still 3x slower than return (nano + 1000) / 1000L;
same here - call the constructor with 4 args
Same here.. we should not have these checks here.
Here, we need to check value also along with key. A case like createBucket, DeleteBucket, we will have the key in the cache for that bucket, but with the value null. And also is this isExist will be called with the lock? As someone can modify the same key while checks are happening.
change "get(key)" to "redisSet"
Why is it public?
Can you add a check to see if the metadata is present (stream.hasMetadata()), if not create metadata?
@fabriciofx Here also, we could return the body() of our decorated object directly
Should return ReadOnlyArray.
Should return ReadOnlyDictionary.
personal preference (so up to you to take the suggestion into account) but I would go for :  if(cond) { return 1; } return 0;
ImageData for current image needs to be updated in the array?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
A List<String> would probably be simpler to use as return value
I would prefer to move this line in the if branch, so it is more clear, "return element" is done if a managed provider is available only
add(int, E)
We should not catch generic Exceptions. Can you make this more specific?
I think only one impassable entity should be allowed on a Square. Exception otherwise.
I foresee clashes here. Should at least use <type> + "/" + <name>
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
you have to add a canDoAction message if you fail canDoAction
return Optional<File>
For easier maintainability in the future, I suggest having curly braces for this if condition.
Program to interface, not to implementation - please change return type to Map<String, Object>
import that one as well, to make the code more readable, or prefix all with ConfigValues
Should this be putTransient because of IMap#putTransient?
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
Why are you calling setUp()? Is there a way to avoid this?
Alex, I don't think they can be merged. getLong is still missing in the code base. Committing this patch without test seems a bad idea to me.
there is Long.hashCode(long value) method.
Could you put this change to a separate PR?
bad hashcode.
can it be made in one line?
Please group mr, ms, and mrs together
Was the closing head at the end on purpose?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
Are we comparing InputEdge vs SourceInputConfig here?
Is it OK to assume that neither of these can be null? Couldn't a user easily create a ref entry which only has one of these defined? Perhaps you don't really support this case in the code, but perhaps it should be supported? I can easily see a project wanting to override one without overriding/specifying the other.
is logics correct here?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
ChannelClosed needs to be added to (though not strictly necessary)
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Unsigned types are not used in the current implementation. So, you can omit them.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Could throw IllegalArgumentException instead.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
Since this a string, safer to use StringUtils.isBlank
rename to child or childItem
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
suggestion list.setSourceList(new ArrayList<>());
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
This is just a quibble given that the entire thing is private and the class is tiny. Still we could separate the loading of the preference and turning it into a ScaleInterpolation from the side effect of updating the menu selection. On the other hand I guess this is never going to be pure function anyway given that it reads from mutable source (Preferences), but it still might be an improvement. Regardless, we should log the exception instead of just printing it there so it shows up in the log. Since it isn't critical it could just be at INFO priority I guess.
getItems().length > 0 implies menu.getItemCount() > 0, so menu.getItemCount check can be removed. getItems().length is not sufficent, it should be checked that any of these items is visible, e.g. Stream.of(getItems()).anyMatch(IContributionItem::isVisible)
should we use ObjectUtils.nullSafeEquals here as well?
It might be a tiny bit more readable to call this.sortFileSizeConditions as well. Ditto on line 359.
Good catch. Should be the same for initCond on the next line. It's a bit unnerving that this is not a compile-time error :( EDIT -- I checked with a structural search: Objects.equals($o1$, $o2$) with a constraint on o2's expression type java\.util\.Optional. This is the only occurrence.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
I still don't understand why the key cannot be the session id
Move this else if just after the } above
Have we tested this with a song that is currently being played
should call super.onClick() here?
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
Delegate to isNonCodedDrug() when making the check.
Please use <br /> instead of <br>
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Why not override visitClass() method?
Is there any particular reason to call getMuteReason instead of just checking the value of muteReason directly?
constant?
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().
Why fromUnfiltered(), if you then filter anyway?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This is a test for the userRepository in my opinion and should not be here.
no need for type cast
This line should be placed before the thrown.expect... calls, because the exception must be thrown by tempFolder.newFolder.
super() can be spared here.
Do we really need this? It's implicit
this("Safety Command")
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Don't initialize to empty when null.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Shouldn't this message be changed to "Should be 500"?
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
This doesn't look like a recoverable scenario, should you be re-throwing this one? Or is there some default/fallback VipAddressResolver if the instantiation fails here?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
Please group mr, ms, and mrs together
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
nit: param doesn't need final
Collectors.toList()?
Would return builder(SecurityLink.resolved(security)); be simpler?
I want to method accessor to be package private :eyes:
Please use the more compact one-line syntax:  java if (defaultUI == null) return;  for consistency with the other blocks of code in these here parts.
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
Add log.info "connecting to ATSD at host:port"
Why are we eating the exception here?
I think it's unnecessary, method is synchronized?
rename to comply java standard name convention. validateEmail
Avoid ByteSource in API. byte[] is ok here
format should default to "tar.gz" is null or empty and not throw an exception.
70-75: extract method (see following methods)
i would add additional check to make sure we will never make it to more then 100 :)
if the max stream tail moves, it calls prepareSiteRoleChange(), which call queryStreamTail() one more time, and will update totalNumEntriesToSend. Then it call queryEntriesToSend() again, will get a pretty close result as currentNumEntriesToSend. So percent calculation will always return a 0.
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
no need to say "public" here, it is always public in an interface. "static" is important though.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
I'm missing the new field in the toString method.
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Let's add a message here: "Checking if port XXXX is in use...".
Why is this still using the Id?
format should default to "tar.gz" is null or empty and not throw an exception.
Why is this still using the Id?
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
I would not print anything to stderr. I would suggest using a logger and use it in both cases (cleanMethod or invokeCleanerMethod)
rename
not all listener
maybe rename?
Should we return immutable list here?
@v-stepanov Is method marked as @Nullable ?
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
This is a bug
This is wrong.
this should be config.get("path-style-access", boolean.class, false)
It is good to have a method to convert config.get(Config.TOPOLOGY_RELIABILITY_MODE) to enum and then compare two enum values. Comparing two Strings is error prone.
This code should use instead entrySet
This method should first attempt to get it's result from a file stub.
@ivandalbosco This method should be annotated withjavax.annotation.CheckForNull.
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
Please add ioe to the exception.
Please add ioe to the exception.
we should pull the ObjectMapper out as a static final and use Afterburner, to avoid thrashing and testing too much serDe  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().registerModule(new AfterburnerModule());
Ahhh, the speaking check is here. Calling speakNames() to have to sometimes not speak names is confusing and wastes a method call. I think we should just pass the boolean into presentation manager.
null != settings
I think the existing code is correct for the "jump" plot behavior - this should advance the plot as time marches on. Although this change would result in desired behavior for the non-changing historical data, it would result in incorrect behavior for live/streaming data. The issue comes from the fact that settings.getMaxTime() is returning system time in the first place. This makes sense as a reasonable default only in the absence of a time service, but should be overridden if a time service is available. Some care should be taken to ensure that only defaults are overridden in this manner (e.g. to avoid overriding when getMaxTime() is returning a persisted user-specified value.)
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
How is this changing how it used to work previously?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Static string constants
Could you please replace this boilerplate pattern with a single method registerSerde(String, Supplier<ComplexMetricSerde>) thoughout the code?
How did this happen?
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Should have a space after add
Another space after add
binding -> bindings
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Remove this
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
My problem here is that the timeout is coming from another place (that will override this). I don't like properties coming from two places. I don't have the best answer but I don't think it's a good idea.
What is this test for?
As iirc a HC can not spontaneously become a DC, I wonder if we could cache this data. Otoh, this is a relatively light-weight call and not done often, so probably does not warrant the hassle of cache invalidation checks.
F.isEmpty()
What about skipping parenthesis, so that we still raise issue for the following: conn.setRequestProperty("Authorization", ("Basic " + encoding + encoding))
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
@tsurdilo take a look at org.jbpm.kie.services.impl.CommonUtils.getAuthenticatedUserRoles(IdentityProvider) that does some additional logic in case roles are empty list. There is an issue with some dbs handling empty list as part of in clause
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
collect to a set that can preserve order?
I don't think it's necessary to create a set here since it accepts collections and then tries to figure out the fastest way to check them.
We should check whether the variant context in the output vcf is filtered. The output vcf in testDreamTumorNormal has one filtered site (20:38245275, alt_allele_in_normal) and it's counted as a false positive. This applies to calculateConcordance in HaplotypeCallerIntegrationTest also.
Once again, just use getMonth(calendar), which embeds the knowledge of the +1 difference in its body. DRY.
But existing rows use null not "" for the parentUuid.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
CheckReturnValue?
style: extra parentheses
we need good docs here
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Remote exception handling changed a bit, so I think you can make this more specific: if (throwable instance of RemoteException && throwable.getCause() instanceof RetryPrepareException).
I think you want isPossiblyOkHttpTimeoutBug(cause) otherwise it will SO.
Optional.map
Optional.map
You should pass here message not group converted to string.
remove
NPE if header missing.
How about to use here NamedParameterJdbcTemplate as you've done in the JdbcChannelMessageStore#doPollForMessage ?
Add here if (outlinePage != null) { outlinePage.setSelection(new StructuredSelection(selected)); } to make the normal outline page follow the selection in the quick outline.
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
boolean canExecute = false; if (selection != null) { canExecute = Iterables.all(selection, Predicates.instanceof( AbstractToolDescription.class)); } return canExcute;
Is there a subclass? I'd like to see these protected methods be private if possible.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Should check if the Counterparty that should be updated belongs to the logged AppUser
A validation should be made to compare the oldCategory.getUser() to current authenticated user. Maybe...what do you think?
See UseCase.
Add not-null check here.
@aklish what do we expect if both initializer and injector are defined?
Maybe some not-null check should be added here.
Why change the name the property? Accident due to mass refactor/rename with IDE?
Translate this RuntimeException message in English please
space before {
Let's use the same logger we use for the rest of Baragon rather than System.out, for example <LINK_0>
nit, Collections.EMPTY_MAP?
what if the subExpr is empty ?
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
How about remove the property, rather than set it.
super.init() method never throw an exception.
immutable copy!
Should make sure the constructor and this method follow the same pattern around ensuring the internal values list isn't mutable. Right now the constructor will clone the list, effectively a deep clone based on how Strings work, ensuring it is immutable if the original list changes but this will return a reference to the internal list that could be mutated.
Can't this be further improved to just Arrays.asList(values)?
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Do same for this one
> new Date(mExpiresOn.getTime()) [](start = 15, length = 30) why are we returning a new object? #Closed
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Is it really filter name?
This should stay final
Should this method be final?
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
Why not closer.register(...::close), as above?
lockRefreshToken should be set to Optional.empty() here, otherwise isHeld() will still return true. There should be a test for this.
This seems needlessly complex. You're using a boolean supplier to assertTrue. Why not just call doSomething() directly?
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
We don't need this, the ConfigSaved would handle this already.
Typo
as a suggestion you could remove the followup NPE check and use Objects.requireNonNull suggestion org.eclipse.core.resources.IProject project = Objects.requireNonNull(getProject(referencePoint), "No project found for reference point: " + referencePoint);
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
Need to use parameterized logging instead of string concatenation.
Missing codes.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
same here simply inline the attributes variable
if you do not need the variable to make assertions just inline it patientService.getDuplicatePatientsByAttributes(null);
The binding shouldn't refer to the currently selected entry because this might change in the future and then the binding needs to be reevaluated. The following should work suggestion ObjectBinding<BibEntry> entry = Bindings.valueAt(selectedEntries, 0); return Bindings.createBooleanBinding(() -> { if (entry.get() == null) return false; else return entry.get().getFields().stream().anyMatch(fields::contains); }, entry, entry.getFieldsObserable());
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
does queryNextPage need the query string again?
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
you can directly put .commit() at the end of this. Editor calls always return the Editor again ;)
java @Override protected void setUp() throws Exception { super.setUp();
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
rename fileInfo to ledgerInfo
EchoParametersDao.getEchoParameters() already returns a list.
this variable may make more sense just as itag given it isn't only for items.
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
We can use guava Closer to make sure we close all of these clients (just in case if one of them throws a runtime exception in the middle of the loop)
rename to breakpointRequest
can't foreach be used here?
This might throw exception
make this private and move it after public constructor
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
I know this is not introduced in this PR, but could we consider not allocating the buffer multiple times (here we would allocate three times, each in different levels of the object's serialize() function).
if you want to be Really Fancy, you could rewrite this as:  java final Optional<TimeZoneHistory> timeZone = this.timeZoneHistoryDAODynamoDB.getCurrentTimeZone(accountId); final Optional<DateTime> nowForUser = timeZone.transform(new Function<? super TimeZoneHistory, DateTime>() { @Override public DateTime apply(TimeZoneHistory history) { return DateTime.now(DateTimeZone.UTC) .plusMillis(history.offsetMillis) .withTimeAtStartOfDay(); } }); return nowForUser.or(new Supplier<? extends DateTime>() { @Override public DateTime get() { return DateTime.now(DateTimeZone.UTC).withTimeAtStartOfDay(); } });
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
Could you check for null or empty? Via StringUtils.isBlank
Why do we need this constructor? It doesn't use the 2nd parameter...
What you should be sending is the cluster compatibility version, not a constant version.. You could send the host's version but that would be confusing to the users. The norm in oVirt is to restrict version specific features by either cluster or DC - since this is clearly related to cluster (and not related to storage), the restriction should be by cluster level.
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
when can it be null?
Lists obtained from a message are immutable. No need for extra copying.
Maybe unmodifiable
does this have to be a list or can it be an iterable?
I don't see where we handle HibernernateException.
it would be nice if we could instead use a class called Wait, that would keep trying until a certain condition was reached in the server. This type of sleep will certainly eventually fail. i'm looking for a case where the test always pass.. with this we will still have eventually a failure.
I think we should add this datum to the frame and confirm that the session also successfully moves on (just to ensure the end-to-end is also still working)
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
From the code it appears that 'nulls' may be in the Iterable<TokenCacheItem> returned. Because we create the collection as ArrayList<TokenCacheItem> tokens = new ArrayList<TokenCacheItem>(results.values().size()); If decrypt fails, we will not add the tokenCacheItem.
we never use NULL, it is a bad practice in general.
suggestion return new SearchHitsImpl<String>(hits.size(), TotalHitsRelation.EQUAL_TO, 0, "1234", hits, null);
nit, Collections.EMPTY_MAP?
- s/userPassCollection/userPass - s/userPass/userAndPassword - s/lastIndex/atPos - s/firstIndex/colonPos  for (String userPass : userPasses) { int atPos = userPass.lastIndexOf('@'); checkArgument(atPos > 0, "Invalid Credential format. Requires user:password@collection"); String userAndPassword = userPass.substring(0, atPos); String collection = userPass.substring(atPos + 1); int colonPos = userAndPassword.indexOf(':'); checkArgument(colonPos > 0, "Invalid Credential format. Requires user:password@collection"); String user = userAndPassword.substring(0, colonPos); String password = userAndPassword.substring(colonPos + 1); builder.add(createCredential(user, collection, password.toCharArray())); }
Could use assertEquals?
maybe also add?:  java mapper.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, false);
Does this need to be a perpetual change or is it bound by this method? If it is the latter, I'd reset the context classloader to its original value in a finally block in this method.
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Shouldn't this be set to false?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
No, this. when you call methods.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
We shall trim at the final values level but not the above layers. What do you think?
Consider returning a constant
Fair enough. I don't think it was meant as a cost saving thing, just to make it easier to understand when something did or did not have caught-up clients. If you find this logic easier to follow, go for it
suggestion private MockClientState getMockClientWithPreviousCaughtUpTasks(final Set<TaskId> statefulActiveTasks) {
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
should be VOT.Storage
this should be the disk id, not the image id
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
No need for the *31 here.
bad hashcode.
static
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
this can be done with a stream, filter & collect so it'd look something like this return film.getPeople().stream() .filter(crewMember -> crewMember.publisher() != Publisher.RADIO_TIMES) .collect(MoreCollectors.toImmutableList);
This should probably be private.
You can use CollectionUtils.toImmutableList
this.
This variable name is misleading. These bounds are _not_ verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).
Couple more static imports here?
Another static import?
Statics
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Immutable fileinfo
Better to return "";.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
This is the wrong method to update, replace the one that was called here. For a global check if the patch was successful check for references like registerDeploymentPlan, instantiate, they should we restricted to the EntityManagementUtils class only (outside of camp projects).
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Can StringUtils.fromUtf8 be used?
@nielsbasjes Is making this method public really necessary? Do we need to expose this method in the public APIs? Can't it be package private?
final float sleepDuration = (int) ((double)  feels odd.
Methods in Preconditions should be imported statically
This can be removed.
Do you think we can use an [unmodifiable map](<LINK_0> here?
StringPool.EMPTY instead
I think there is some findbugs issue with not using {} not sure.
Generic type not used, remove.
Why are you looping here? Can you give a use-case?
Should we return true at some point? It looks like the old code could.
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
Do we really want to always assume Latin-1?
Could just use Arrays.fill(max_byte_arr, (byte) 0xff); here
please remove TODO and printStackTrace() and use proper logging instead
Why don't we make inDegrees to ConcurrentHashMap also?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
A for each loop on the listeners can be used here instead.
should this count be parameterized?
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
you can use IStructuredViewer::getStructuredSelection
remove assertion and change ISelection to IStructuredSelection
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
The cause should really have an abstract method for this instead. And return EnumCause rather than Enum<EnumCause> from its method.
Return this enum from the Target instance.
This should be part of the try-with-resources block.
This is ok but can be made more compact: java try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()))) {
we can use try-with-resources statement and avoid the finally clause
Item dropped should be a hopper
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
this for is exactly the same in all the array tests, let's move it to a private method
is this still needed?
This will throw redundancy warnings in IntelliJ
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
The this. in getters are unnecessary too.
public @Nullable String...
Why do we return the parents name instead of the name we store a few lines above?
assertTrue or assertFalse but never equals. Also add a message so if it fails you know what has failed.
When using suggestion Assert.assertThat(testRealmResource().users().search("a", true), Matchers.hasSize(0)); Assert.assertThat(testRealmResource().users().search("apollo", true), Matchers.hasSize(1)); Assert.assertThat(testRealmResource().users().search("tbrady", true), Matchers.hasSize(1));  the output on failure shows the search results which is better for debugging potential failures.
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Missing types
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
you should probably check Item.Configure here
Single or double pipe?
I think a compare between capacity and maxPageBytes is still reasonable here - even through the capacity > maxPageBytes is always true here. Because we cannot ensure the private HeaderChannelBuffer constructor is always called in create. Maybe it will be called somewhere else someday? A compare here may seem redundant now but will decouple the private constructor and the create
Might be nice to list valid dio pins out in the message?
Can we make logger a private static final
You don't need to save an ObjectReader; you can call readValue directly on the ObjectMapper.
nit: Suggest renaming iterations and its getter as well here
what does compare and hascode mean for datanode if they have different ssl ports?
how could contributions be null? Create it at the field level if you want. It should also be final. There are minor style violations in this file, no spaces around operators
This can never be null given the code in setData above?
why this change?
I think the current state of the art is to do something like: int hc = key.hashCode(); hc *= 31; hc += value.hashCode(); return hc; But actually for an attribute there aren't too many that can can be multi-valued, are there? So just using the key's hashCode as our own hashCode might be sufficient here.
this client side GWT compiled classes needs a sort of sanitized hashCode implementaiton using our utility class HashUtils. Should look something like this @Override public int hashCode() { return HashUtil.combineHashCodes(super.hashCode(), executionSet.hashCode()); }
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
Since this method process any type of attributes, exception text is misleading. You can get eg. facility attributes with non-null value from all facilities specified by attribute definition.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
type might not always be a Class. If the API method returns List<User> this will be a ParamterizedType which isn't not a Class.
space after ,
It's not a good design pattern to close resource-parameters in methods. There are the following converntions (which may violated in certain cases) - If you pass in a resource, the caller is responsible to close it - If you wrap a stream (e.g. new BufferedInputStream(is)), closing the outer stream will close also the inner. You should fix that resource leak at the caller side, there is only one in io.ebean.config.properties.Loader: java void loadYaml(String resourcePath, Source source) { if (yamlLoader != null) { try (InputStream is = resource(resourcePath, source)) { yamlLoader.load(is); } catch (Exception e) { log.warn("Failed to read yml from:" + resourcePath, e); } } }
should be debug and consider moving logging to checkData()
Could be written on one line RemoteService.getRemoteService().doRemoteFunction(value)
we don't need to change the Creation classes.
please keep style changes separate from PRs (or better just don't create them at all)
Should reset the values in the config file too?
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
Please extract this string
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
I would try to reduce the code duplication by something like that  final Class... activity; if (PreferencesHelper.getCreateAccountStatus() == CreateAccountStatus.WAITING_FOR_SMS) { activity = VerifyNumberActivity.class; } else { activity = AgreeActivity.class; } startActivity(new Intent(this, activity).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP));
static imports
static imports
In general we use == to compare classes (Cf. *AdapterFactory implementations for example)
does this have to be a list or can it be an iterable?
why public?
What about :  names = new ArrayList<>(attributes.keySet());
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Please split this if into two and revert else if. The condition will be easy to read. Or, the whole condition can be inverted: java final DetailAST parametersNode = ast.findFirstToken(TokenTypes.PARAMETERS); if (parametersNode != null) { TokenUtil.forEachChild(parametersNode, TokenTypes.PARAMETER_DEF, super::visitToken); } else if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) { super.visitToken(ast); }
createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME); should be the first thing we try. It will be the fastest and the most common scenario. pure createObject(name) should probably be used last when user supplies full package as name. Order of finding module should be, imo: 1) our module map test 2) 3rd party map test 3) full package (or raw) test 4) fail. We can probably discuss skipping 1-2 if given name has a period in it. 3 is only really needed if we don't examine maps for the full package. I don't really see a benefit from doing this.
just return "" instead of new String()
This check is useless as the customParams can never be null.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
please inject the DAO
try to consolidate with the previous method
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
nit: s/upload/upload ID/ I was thinking of consistent log keywords so taht for any retry log we can search "upload ID" or "commit ID"
extension can't be empty or /
extension.toString()
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
I understand the purpose of the change is to make sure we streamline the value change in the class variables to happen as late in time as possible, and issue the notifyDatSetChanged() signal right after that. Can we then enclose these 3 below lines in a synchronized block to make sure these 3 are packed together in an atomic action?
Should this be as in OzaBag?  @Override protected Measurement[] getModelMeasurementsImpl() { return new Measurement[]{new Measurement("ensemble size", this.ensemble != null ? this.ensemble.length : 0)}; } @Override public Classifier[] getSubClassifiers() { return this.ensemble.clone(); }
needs US-ASCII charset, or some other simple ascii encoding conversion
use 'waitForElementByElement(newestVideoDeleteIcon); and use 'waitForElementByElement(deleteConfirmButton); before each click
this method suppose to return instance of DiffPagePageObject class, because its redirecting to diff page beginning of the method should be: public DiffPagePageObject goToDiffPageFromHistoryPage() and last step should return new object: return new DiffPagePageObject(driver);
log () here and after
Are there mandatory parameters which require validation?
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
This won't invoke the additional interceptors, is that okay?
you could invert the if to avoid negate the condition.
Wouldn't Arrays.asList() be enough here? Arrays.stream seems to have a lot of memory overhead.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
the instanceof check includes a null check
Compare with null not necessary since null instanceof FileModelSource is false
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Check if there is an appropriate constant for "no metakeys" mask.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
0 is a legitimate option value for min. selectable choices. Why not -1?
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
IMO, return (int) Math.min(size, Integer.MAX_VALUE); looks better (as you did above)
In other places we use java.util.Math.toIntExact(long).
I think it makes sense to use builder and return ImmutableSet...
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures
Use Logger instead of System.out.println
Reads nicely if this is written as if (isBinaryValueAvailable()) {.
this.sourceType
throw -> failure or exception?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Should this use RANDOM_PORT_INDICATOR instead of 0?
Please keep this.cell near the related fields (previousFamily & cell count) below
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
we can replace all these with getTxBuilder()
Why an event ID is built around project UUID?
nit: I'd prefer warn, this is probably not super actionable for us?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
is there no common place (at the broker level) we can add the unioning query runner?
Why not create the taskExecutionDAoFactoryBean in the ctor?
Should pass parameters along instead of doing null checks.
Instead of making it a singleton, why not create the connector in setUp?
if we continue with this convention, please init to true also here
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
You probably want checkNotNull here - assertNotNull is no op if assertions are disabled resulting in a NPE below, checkNotNull will always fail on null leading to a consistent error message.
This bit of code needs the same treatment as lines 120-122 I think. If the evidence type is PasswordGuessEvidence, then return the result of getCredentialAcquireSupport for any algorithm (pass in null for the third argument).
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
can be replaced by List.of
Collections.addAll saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.
Please use Collections.addAll(Collection<? super T>, T...) instead.
why not an empty map?
@ILikeToNguyen Why the change in visibility here?
You can use Map.of
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
the if and else clauses here will both result in the same behavior below
I think you can remove the surrounding if, it's quite safe :]
Before go through the loop make sure that position and symbol parameters are not null.
Extract this into method getTotalSellAmount. The refactoring tool can do it automatically. Code smell Overly long function
needs to be named something more relevant like market
What does the magic number 2 mean?
Do you have unit tests? Again you need to use equals
Did you take a look at HibernateDiagnosisDAO? The service layer will delegate to the data access layer which fetches directly filtered data from the database instead of fetch it all and then filter in the application memory.
name it github config
If you get something like an InterruptedException, this will just catch it and move on.
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
Idem this could be handled with an Optional...
If we are changing this code, then relying on Optional could be a good move.
If we are changing this code, then relying on Optional could be a good move.
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
exists is statically imported.
Unlike other tests, this test does not compose the chain using expected.
Call I18N.getString(String) (there are no parameters in the resource messages).
Can we use url building here, to avoid problems with / at the end of the server.
this is confusing, it is called router but actually it is routerUrl.
This logic needs updating to handle non-deterministic filters. See latest BooleanSelectiveStreamReader.
use filter.orElse(null) with requireNonNull this.filter = requireNonNull(filter, "filter is null").orElse(null);
Maybe add a requireNonNull for filter and outputType. Missed that before.
I think the annotations should be on separate lines
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Same backward compatibility concern as in EC2AbstractSlave.
remove static
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
Looks like this function is never used. Do we need at for this feature?
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Imagine we have 2 KIE Servers. None of them are up and running when we do the first round of client creation. So they both fall back to async creation. First KIE Server client creation then succeeds and it then forbids the scheduling of next possible tasks for other KIE Servers. I think we should just cancel the periodic task just for the KIE Server which we were able to connect to. So we should hold all tasks in a separate collection. Moreover, after the last task is removed, we can shut down the executor service.
I believe this line is incorrect and should be removed
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
It seems cleaner to make this private, and add 2 static constructors: ServerFrontEnd.udp(adapter, port) ServerFrontEnd.tcp(adapter, port)
hasAnnotatedAllParameters is already checked in the super class, right?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
What if extended SherlockActivity contains android MenuItem or vice versa? I haven't tried, but it seems that the user will get an error in generated folder.
you can either remove else or add pair of curly brackets
why this double usage of URL? Wouldnt be using URI instead of URL be fully sufficient? (URL is known to have severe flaws and should be avoided if possible)
As per bug 487713#c11, the previous revision used to return the path in case of IOException. Do you think it makes sense to add that return statement?
Is there a chance of a NPE? could be getFile() null?
Looking at the usages better throw in this case.
We need to keep the throw exception as we are not changing the existing behavior
@dmzaytsev let's inline this
Maybe expectThrowable for consistency?
Although your change enables editing the right-hand side if the left-hand side is read-only, the changes on the right-hand side still won't be saved; I assume you need to modify the check here too: (isLeft && getCompareConfiguration().isLeftEditable() || !isLeft && getCompareConfiguration().isRightEditable())
Add { and }.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
I can't believe I let this line of code get in. Terrible.
Debugging code?
The system properties that we access from Java (as opposed to Maven-only) usually start with infinispan.test
just return ListeningExecutorService
same here for node
as above for cache
super nit: make string task a public final variable.
return id;
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
JDT uses compact assignement, e.g. i= 3;
Should be added the Override annotation.
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
Maybe take the opportunity to set index = null here?
If storageManager gets a value in constructor, then we don't need to check null.
cannot be null.
Same as above: I think it is clear enough without the id variable same for below too
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
I think can just use the @FindBy defined at the top instead of findElement() againt
I think it will be better to close the other store as well.
Could you please add a null check and isClosed() check (if available)?
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
Check command and status null.
Check if address is null.
Not sure if we want to print out the exception.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
we could prevent this if the color is "white"
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
check if getters1 is null and remove firstTimeStream
Style issue: @Override shuld be on line above the method declaration
null != settings
A check for settings.getConstructorArgs() != null is not required if we check that null can't be passed to MockSetting.useConstructor(Object ...args) as described above.
return settings == null || settings.isChatColours()?
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Please check that the data buffer has at least 2 bytes to avoid a NPE.
why is this necessary?
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
this.
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Move the intent instantiation code inside the else branch, as it is not needed otherwise
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
Should be here ac.stateChangingCheck(); @zlamalp?
List<User> -> List<Facility>
Please change the return type of the method to Long: suggestion public Long call(ApiCaller ac, Deserializer parms) throws PerunException {
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
how do we utilize timeout?
why this is in vmCommand? should be in stopBase command
@Before / @After could overwrite System.out :-P
When the view is closed you need to stop the build thread
Will need a @since tag.
Which type would be assigned in this case?
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Then should we just use it to save the update items?
You could just use Closeables2.closeQuietly(azureBlob);
Remove by dn/key.
Let's keep it as it is for the being.
The original version is more precise?
[If a player is targetable becuase VANISH_PREVENTS_TARGETING is false](<LINK_0>, should spawning also be unaffected?
are you still creating new contexts here?
reference equality?
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
I guess you forgot "other." prefix
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I am not following here - why do we want this in sync block?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
The %2$s is positional and needs to be adjusted since payload type moved from position 2 to position 4. Or, alternatively keep this the same, but move getQuoteString to the end and use %3$send%3$s above rather than %send%s.
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
alias is count but the function is sum
should atleast check o being non-null and instanceof IdentityExtractionFn .
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
Can we please add limit to the exception message? So it will be much easier to see the problem!
Use checkArgument instead to throw an IllegalArgumentException?
We don't need to cast to int.
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
Maybe we can improve the message further by checking if null == operation and show a different message in case it is. Something generic (like Unable to complete operation on "event-type-name" + reason. What do you think?
@NielsCharlier this is a strange idiom. Does your intent differ from !resource.path().isEmpty()? Can resource.path() return null?
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
nit: maybe merge the lines as the formatting looks a bit strange.
This is a bit weak when it comes to IPv6 addresses, as it assumes "hostname" is properly enclosed in [ ].
I guess we can use the following instead of both lines? suggestion ensureNotEmpty("hostName", hostname);
@inverno Why public?
Only null check here, so empty string will go through. Shouldn't we check for blank strings ?
Given there is no caching going on and lazyEntriesView is not exposed externally anyways would it make more sense to remove lazyEntriesView all together and just do lazyEntries.keySet() (with the remainder of the line being as it currently is).
can we use sysprop or something for url?
version is protected. I don't think we need to access it via its accessor
options -> version
use Long.valueOf() instead of new Long() - always for performance reasons
456L
use 'L'
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
Would it not be enough to only catch MergeException here?
Can this be private, or is there another use case for default attribute outside the builder's call?
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
This should be package scoped, not public.
Did you test the response == null branch? I believe login returns either error or a valid access token, never a null response.
Why we return AsyncClient here?
Don't we have to say that this is uniqueId JDBC?
- log warning that option is not supported by SNMP
Not sure about coding style, but I wouldn't use an else here ("else after return").
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
By convention, files in Jenkins home indicate what they were based on class names. Maybe jenkins.install.InstallUtil.lastExecVersion?
Nit: it is a good practice not to reassign the input parameters so I would change this to something like the following: Map<String, String> mapToUse = (map == null) ? emptyMap() : map; JSONObject pathPartMap = new JSONObject(mapToUse);
you can use  return CollectionUtils.map("inode",contentlet.getInode(),"languageId",contentlet.getLanguageId()+"");
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
How about AM's memory mentioned at Line 111?
shardSpecFactory -> partialShardSpec. Lombok would be nice and hide all of this away :)
should this have a ,  to match the rest of the pattern?
the idea of using a builder is a bit off here :-)
I am not sure the changes here improve the situation. It would probably be best to change this into a String.format(...) call... or at least to format the code to remove the many line breaks.
one param per line; leave the first line empty
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
@weisebrazil all indentations should be 4 spaces, not 8.
It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look
it's more natural to use String.format() here
If environment accepts null, mark it as <code>@CheckForNull</code>
Maintenance of the map will be simpler than that of the list
Is this first else-if dead code? It seems to have the same condition as the initial if() statement.
Create date once and use it twice. That way the acceptance time will be the same for both.
Matchers.is
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
From reading this line I'd expect this test to pass. We should probably name this CONFIG_WITH_KEYSPACE_2, or make CONFIG_WITH_KEYSPACE receive KEYSPACE and compare it to KEYSPACE_2.
Nit: Make "content" a constant?
I wish there is a good place to have these convertor util methods so that it's more discoverable. Not sure, may be as static in GsonJsonSerializer type, just a thought.
no braces around single line block
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
It shouldn't be public
Let's do return fDetailedLoad; even if it is always null for now
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
using compareAndSet() might be better since you need not execute the rest of the statements if this is already false, right?
I would guess that the work queue itself listens to the stop event and cancels the tasks. But this would have to be verified.
what happens if the future is already completed?
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
Check if byte[] b is null.
what about location ? we do not need LocationSerializer ?
this is redundant
Will this have any effect to legacy data (i.e. those existing before this PR)?
Used to be fileSystem.deleteFileOrThrow underneath.
there is no case in which httpClient become null, right ?
the second parameter can be removed
Shouldn't we call removePropertyChangeListener, BEFORE we call doEdit, since doEdit will change the current object?
isn't it true by default?
Please have result variable.
I think we should at least log this exception here before throwing other one
log.trace if at all
log.tracef
I believe this method should be getServerMetricConf()
I would prefer not to use null ... just a empty set and then assert that its not null
Please extract some values to make this more readable.
This is a local variable, should be camelCase not fCamelCase
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet header (incorrectly).
I think 28 bytes have been read into the packet header (incorrectly...), so it will read too far into the next block?
Sort of believe We should have MetricManager in parameter given this case.
can we avoid this null check and instantiate it on fields directly (+private constructor if we don't want to create it in any other way) - it's potential race condition if we need that for tests we could have it package scoped reset method
sync
log message is about "attach" in the "detach" method. this is misleading.
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method. Update: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()
This is duplicated
make it final
To be super clear, wdyt about renaming mTryAgainButton to better match its new functionality?
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Please remove extra line
I never knew you can do typeof(...) although it's a little misleading because typeof is not a function, it's an operand, adding () makes it look like it's a function. How about triple =?
Why include the name in the comparison? fullName should be enough.
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
Check if byte[] b is null.
style-nit: avoid braces for simple constructs
could use writeInt(Float.floatToIntBits(v)) to avoid code duplication.
SHOW+DATABASES? looks strange.....
formatting
viewers > 0 implies page is non-null
Same as above, this looks like an error.
I don't think the process deploy should fail in the case of temp file deletion fail
You can safely remove the file.exists()(implicitly done by isFile
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
suggestion return Arrays.toString(value);
Please use - StringUtils.join(Entities.objectNames(networks), ", ")
events can't be null
please use {}
Why are these probably incorrect?
Would you mind if we kept our privates on bottom? I'm a class client (reader) of more code than I author, which means the most relevant source is almost always the public API. It's quicker to get to on top since codes read from top to bottom.
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
we don't need to change the Creation classes.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
should be edit
why add?
Similar to start, stop, etc. I think the name of the action enum can be more generic (VAR__ACTION__ENABLE)
why don't you just use a node here that does the right thing? There should a node to read outer, no need to duplicate that logic here, or is it somehow special?
To avoid confusion, rename the variable to sessionId.
entry
RuntimeException would be sufficient
RuntimeException will be sufficient
Should the scanner be closed after the call ?
This change could break people.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
public isn't needed
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
The operator should be && not ||
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
i would add additional check to make sure we will never make it to more then 100 :)
@decarbonization: i think this should be Math.round(0.25f * temperatureScore + 0.25f * humidityScore + 0.50f * soundScore) coz right now Math.round(0.25f * 90) + Math.round(0.25f * 90) + Math.round(0.50f * 90) returns 91
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Should this constructor one just delegate to the new one with Function.identity()?
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
Why U don't want to consider id in equals and hashCode ?
Please remove the unused method.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
Do we need this else block?
We don't need to cast to int.
checkState
Can remove the first clause if you change maxWriteSize to Integer.MAX_VALUE
DoubleMath.isMathematicalInteger?
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
final field to it's computed once and for all, as most values should be constants
Should be public.
Should be public.
Should be public.
In fact, I don't think it's a good idea to allocate a Long. This function should be fast. Thus, a three branch if seems to be the solution. if (a < b) ... else if (a > b) ... else ... The domain trick works to avoid the "sign" hack.
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
Add parens on (value - 1)
throw exception
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
can you call it first, just for consistency..
This can be simplified to model.getCommands().addAll(uiCommands).
System.out.format instead?
Symmetry (throw)?
can these parameters be grouped into smaller and more meaningful objects?
true=>false
There is no point of having separate variable. Why not to use it directly in method call or even hard code it in pollWhileWaitingForTaskCompletion.
may want to externalise to constants..in a separate patch maybe? call it GEOREP_ROOT_USER or similar
I don't think we ever use this method again
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Move both to variables for consistency.
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
Use a builder method from TestNG Collections
we don't use braces around single line blocks
@paulodamaso the braces and return are not needed here
@fanifieiev the same above.
@super132 please use Collections.emptyList()
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
for write and getActiveMessageFields, you can check if the lists are null OR if their length is 0. If either of those cases, don't write/read them.
At a high level this is what I meant.  java // member variable AtomicBoolean shouldRotate = new AtomicBoolean(); ... In the TimerTask shouldRotate.set(true); in save() if(shouldRotate.get() == true) { // do the file rotation ... shouldRotate.set(false); }
public?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I'm missing the new field in the toString method.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
Null comparisons can be replaced by UtilMethods.isSet(object)
All actions from
cannot **be** empty
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
"else if" maybe?
Same as above. this is deprecated and should no longer be used.
This is deprecated, we should use MoreObjects.ToStringHelper(this) instead.
Should just be dimensionId, ToStringHelper automatically formats and uppercase keys look odd.
reuse getAcceptableTokens()
I am a bit confused that this check will be called on almost every line of code.
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
Why is this needed?
input and expected output should be copied to test's input folder.
Use getSimpleName instead?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
<LINK_0>
projectExplorer.waitAndSelectItem(PROJECT_NAME); projectExplorer.openItemByPath(PROJECT_NAME); projectExplorer.openItemByPath(PATH_TO_GO_FILE);  Can be changed to "ProjectExplorer#expandPathInProjectExplorerAndOpenFile(String path, String fileName)"
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?
seeing this, I am a little worried that these checks are not always at the same abstraction level in the code. Why is it checked here at the level of the callee, instead of the caller as for instance in the Actor class? Not sure which version is better, also because I don't know how many callers these methods have. But, would be good if it is done somehow uniformly, if possible/sensible.
Hum seems we are already setting this listener
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
nit: you can merge both lines above as checkNotNull will return the given argument
As for me, brokerConfig variable name would be simpler here
I generally don't have an issue wit bitshifts when they are actually useful but here it only obfuscates the code for people who don't know much about them
What do you guys think about setting this method to Evolving, at least for one release.
Can we weaken the signature to throws Exception?
...this change really doesn't make sense. > Changed off screen limit for unlocks to 1(on unlock it was 2 and once activity open it would report usage of all 3 fragments, so to add little more accuracy I moved to 1 off screen as on SoldierStats) Are you really considering to give the user a WORSE experience, just so that we can get a bit more accurate analytics? I for one would rather get analytics with a known misrepresentation (all three fragments) than a random misreprentation. Example in your current implementation: 1. User opens unlocks 1.1. Fragment A and B are downloaded (A=1,B=1) 2. User scrolls to fragment B 2.1. Fragment C is downloaded (A=1, B=1, C=1) 3. User scrolls to fragment C 3.1. Fragment A is cleared (A=1, B=1, C=1) 4. User scrolls to fragment B 4.1. Fragment A is downloaded (A=2, B=1, C=1) 5. User scrolls to fragment C because he forgot something 5.1. Fragment A is unloaded (A=2, B=1, C=1) 6. User scrolls to fragment B again 6.1. Fragment A is downloaded again, third time now (A=3, B=1, C=1) So, basically, what that would generate would be... three hits for A, one for B and one for C. How is that more accurate? If we load all fragments at the same time, we get one for each, which is a more viable representation. I'm just trying to make sure that we don't do stuff that makes the app worse for the users (and the experience). For example, I would rather look into if we can use the ViewPager "hooks" and send a "trigger" once we switch to a given fragment. That way, if we go from A -> B -> C -> B -> C, we'll instead notice that the user used fragment B and C twice, and A once. This seems both possible and more useful to me, instead of causing people to re-download information just because we're doing it wrong. :+1: @peter-budo
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
I know its not your line, but please remove "driver" parameter. This parameter is not needed here, because screenshot is not needed in verification methods.
why is there "waitForCongratulationsLightBox " in PageObjectLogging.log, if you don't wait for lightbox? Maybe it should be waitForElementByElement method or in PageObjectLogging.log method should be "closeNewWikiCongratulationsLightBox" and "Congratulations lightbox closed".
IMO it's better to use different values, e.g. 0 and 1 to be sure, for example, that the "delegated" method is not simply using the first parameter twice...
If your initial value is Double.MAX_VALUE, then this reset must be the same
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
use execute i mentioned above
replace (String) js.executeScript(script) with js.executeScript(script).toString()
use js.execute(script).toString()
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Two "parallel"?
let's call it updateCodeMinings() instead.
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
Will this inject all instances of Task on the classpath?
Clarify doc. Returns a proxy not a real result set, and throws NPE if not initialized.
Why do we print a secret systemUserPassword here?
Oh yuck. ;)
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
StringUtils.isBlank(nodeId)
Style-nit: We avoid curly braces on single statements.
Item dropped should be a hopper
Change this to == and I'll merge it.
The default should be updated to return 8 parameters to the test
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
should be setSucceeded(true)
Why do we use iterators? I know the base class does, but why in the first place?
Get it from the model now that we have one?
I don't think this can return null. We should probably add an external annotation.
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
I dont see any reason for adding this to string.xml. It is not really a string resource, it is more of an id. We wouldn't want this to change if we decide to translate the App strings later. A better way would be to move it to the Constants class.
Same here, better in the constant class.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Is this already protected by a lock?
How about to check whether workersToCheck is empty or not before notifying?
Does it make sense to set globalMinimumClock as 0 when workerClockMap is empty?
I would suggest that it checks the count of the entries to see if it increases one after the recovery happens.
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
why uniqueKey, be consistent call it keyField
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
@cvrebert maybe MkIssueEvents.class.cast(?
this doesn't looks good at all :( let's log the exception using Logger.warn().
Please, add the opposite case  other.compareTo(commit)
Remove useless assert
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
This test is exactly the same as testPublishWithNullUsername. I think you meant to pass in a non-null username into resource.publish()
don't use finalize, it's a bad practice
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
This check will be needed in case of every single widget button. If so it would be better to create our own WidgetButton class that will extend com.google.android.material.button.MaterialButton (then you can use it in your layout file). In such a class we can then override:  @Override public boolean performClick() { if (MultiClickGuard.allowClick(getClass().getName())) { return super.performClick(); } else { return false; } }  what do you think about this approach?
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
Ah - guessing that we are using static Bugsnag everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?
use the constant defined earlier (moreover, aren't jdo connection options available from some sort of options class)
Could have @VisibleForTesting annotation. Also could public be removed?
Add this to WireMessages localization resource
Do we want to include data= (since it's required) similar to how we include connection= for SQL? It would also be nice if the cursor was placed at the end of data= (as we do for connection=)
I assume there is no suitable interface/class that could be used here instead of Object?
why does this test need to change ?
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Isn't that should be setWriteRate
Error message needs updated.
Can we rename from exonCollection to something more appropriate, like targetCollection?
Could this be delegated to one of the classes that deals with HDF5 specifically?(like **HDF5AllelicPoNUtils**) Seems like some other classes might want to use it too
Should we return true when file does not exists ?
@ILikeToNguyen Why the change in visibility here?
I think it is not only the platform name. W3C defines a bunch of keys, which must be supplied without prefixes and Selenium has this list somewhere in constants
Should this variable name be updated as well?
can you explain why this change ?
Does transform need a null check here?
should we have an "unsupported" status instead of successful? successful seems misleading to me.
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
It's good practice to use getters (like getPerunBl()) than directly accessing attributes.
Please catch GroupResourceMismatchException from conversion method here and wrap it to ConsistencyErrorException. Because on input, there is no group and we retrieve groups assigned to resource - hence from the same VO and there shouldn't happen any Group-Resource mismatch.
Why is it a list of lists, not just a list?
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
Calling cancel method like this will not actually cancel the task. You have to do this through task driver.
I'd make these numbers constants
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
shouldn't we return a new or immutable copy of our internal list? just returning the list allows plugins to fully modify the list. @WonderCsabo wdyt?
I think the lambda expression could be passed directly to Comparator.comparingInt
That's good to know.
Is there a need to have log.debug within transaction scope?
it appears that this change can be reverted.
also should be warning
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
please decrease severity to "debug"
just wondering, w/ slf4j do we still need the custom format() ? I hope/think that's done by the slf4j logging library
lets use loggers
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
no need for an ArrayList
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
use return ... ? ... : ...?
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
You could probably use the same URL as in getResultById here.
This is not needed anymore... now you can just return id
not all listener
not all listener
not all listener
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
unecessary test : less is more.
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
new AssertionError -> new UnsupportedOperationException
As this operation is optional, just say it won't be supported because it's not mandatory.
Lol! You're going to remove that, right :)
do not assing parameter! nowhere!
Optional<String> ?
This can be java return valueOf(value.toUpperCase(ENGLISH));
nit: Unsupported byte value ' + value + ' for row kind.
You could save a few lines by moving the return null into the default case instead of break.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
As I said in #1208 : In driver 4.0 we don't have any specific exception for codecs except CodecNotFoundException. When a codec cannot serialize or deserialize something, we use IllegalArgumentException. I don't think you need to introduce a special exception in these examples.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Seen proxies before that didn't parse multiple entries on a Cache-Control line. Do we need both, or can we just use max-age?
NB: no-cache is a value usually found in requests, not responses. I'm not sure of the effect in this case. To be on the safe side, I'd update this to read private, max-age=0 instead.
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
please move the isEmpty methods to the scimSchema
let's call it updateCodeMinings() instead.
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
These 2 conditions can be merged into 1 condition
Please call this one time and also check only one time.
This line can be combined with previous line.
upt.unifyGraph(graph) is double code. Better use this structure: new ReferencePositionTraverser(reference).referenceMapGraph(graph);. The graph = isn't needed.
same for thos changes
assertThat(graph.getEdges()).isEmpty() looks better
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
A little wasteful when all you need to do is just set the fields and return this...
BlockPos.ORIGIN
s/policies/policy
Use getSimpleName instead?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
why object? lets change it to the particular time we expect to receive so we could catch potential failures here
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Should we break the for-loop early if the condition is not met?
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
+NonNull for return type
entry
entry
entry
delete
Use [Bundle.putInt(String, int)](<LINK_0>,%20int)) instead, no need to serialize a base type.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
directly return
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
should this filter out null resources? (ie. bad paths)
Do we need to make sure these file names are also Windows-compatible? If so, we should include a few more characters to the list. - Linux/Unix: / (forward slash) - Windows: < (less than) > (greater than) : (colon - sometimes works, but is actually NTFS Alternate Data Streams) " (double quote) / (forward slash) \ (backslash) | (vertical bar or pipe) ? ( question mark) * (asterisk)
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
style guide
Default should be false
Default should be false
It could be useful to factor out this constant, which is also used by org.nuxeo.connect.client.jsf.AppCenterViewsManager.shouldValidateStudioSnapshot
return Promise just to symmetric with start()...
Should this also set engine to null in a finally block? If not, I'm not sure why it checks for null (line 177).
Need to check those variables are initialized or not to avoid NPE.
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
I would prefer IllegalStateExceptions in such cases.
This will NPE if BundleRevision.getSymbolicName() returns null, I would reverse the equals target to be symbolicName.equals(bundle.adapt(BundleRevision.class).getSymbolicName()) This does not scale well if you have large numbers of bundles. If this is a hotspot of your code you can consider using org.osgi.framework.wiring.FrameworkWiring.findProviders(Requirement) using an "osgi.identity" namespace requirement. If I recall correctly virgo uses Equinox regions. That can end up hiding bundles from a BundleContext perspective. Using FrameworkWiring.findProviders would bypass the equinox region hooks so you need to be aware of that.
This will probably be permanently unsupported.
MemStore is used for tests, so we need to implement this function.
This should be implemented for consistency.
should return false if the validation fails
You can remove all the following code: if (!(.... return false; } return true; With simply : return super.canDoAction() && canRemoveVm()
We should also check the servers which we want to update the hook content is in UP state.
The operator should be && not ||
done for patch3.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
please use (1 << priority) instead of priority + 1
This can be static.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
Better assume immutable parameters. Don't modify references to an input variable.
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
I think we can avoid this .INSTANCE. business by putting the fromV1APIJson method inside a companion object.
We mix two different comparisons styles here: "expected".equals(actual) vs. actual.equals("expected"). I would prefer to use the first one only as it is NPE safe.
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
inUse is set twice in this constructor
unnecessary
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Instead of catching NullPointerExceptions, it's better to check if session.getRemoteAddress() returns an object (and only call .toString() in that case).
Would this method stop the rebalance as well? I can not see stop call here.
Can you just change the return type of this method?
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
Should this be false or true?
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
why are you using getAdapter() and not directly mAdapter?
why getAdapter() and not mAdapter?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Since the varargs parameter of String.format(...) is of type Object for which toString() will be called if non-null, it's a bit safer to do the following in case the key schema or value schema are null: suggestion return String.format("<SchemaPair: %s, %s>", keySchema, valueSchema);
Should we just use MoreObjects.toStringHelper() for this?
this does not handle the empty 'lists', it will throw an exception
This is already done in the other method.
Why are the problems not enough?
This should follow the normal exception handling path and let the caller handle the printing of the exception.
To avoid confusion, rename the variable to sessionId.
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
we should only handle non-transient values, or?
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
You can make this method private
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
StringUtils.isEmpty
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
This branch is not needed
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This will throw redundancy warnings in IntelliJ
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Why did we make this public?
We should validate that's non-null (to fail sooner).
My point is about consistency between different codecs. Protobuf codec assumes the callback handles the flush, while this code has to call it explicitly. We should make it consistent and set the expectation that the traverse callback should handle flushing/closing the generator. Then the codec's would just close the traverse callback.
I think 15, 11, and 4542278 should be named constants.
It would be great to rename the variable to isParamCountValid.
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
could be simplified: Collections.addAll(refsSpecs, specs);
same thing, while you are cleaning, other thread could store other key.
Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue?
Formatting issues. Please use appropriate spaces between string literals.
static
sounds like it could be set on error level
unneeded throws Exception
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
or more simply: if (forceRemote != null && forceRemote)
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Use map.forEach
filename
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
If this should never happen throw an IllegalArgumentException instead.
Unsigned types are not used in the current implementation. So, you can omit them.
Is it necessary to call this again?
As there is no else branch you seem to allow unknown/unexpected fields. Is this always allowed (i.e. per setting on the mapper/parser)?
Minor, but "extra".equals(tagname) would make this more concise. Java and its endless checking for nulls...
Argument name
Argument name
MarketData.getValue never returns null
Looking at the CommandCache#reset() method you pointed me to, it made me realize that we should check here that ctx is not null first, to avoid any risk of NPE.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
So this will be used for quantity and duration too or you need separate ones?
+ NUM_HEADERS + NUM_FOOTERS;
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
.add("noShutdownOnExit", noShutdownOnExit) (was shutd **wo** n)
No interest in removing the stageTimeoutMs value?
I feel like there is a case here where there isn't an existing pipeline (via the save entrypoint), which should probably be legit from a stale checking perspective. I also suspect the submitted payload in that case would not have a last modified (unless that is magically set somewhere along the way with a default value).
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
Can you add getId() and mark id() as deprecated?
Can we make it final?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Is this method used?
Not good to use Optional for collections, just return empty collection
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
This should occur before setInput(input);
![BLOCKER](<LINK_0> 'Severity: BLOCKER') Refactor this method to not always return the same value. [![rule](<LINK_1>](<LINK_2>
this change is no longer needed.
Check other tests in this class. Replace startGrid(1); by startClientGrid(1);.
Field should be named the same as the resulting JSON object to reduce confusion (if possible).
Is payeeIdL a typo or intentional?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
make this synchronized.
This assumes the webcam res == screen size... Not the case. height:width set in reporter seems to be ignored
Worth reporting what was null?
Here it would be nice to use a static import - that would make it more consistent with the other code
Shouldn't there be an assertion checking that the shipping method was actually set, price and all?
Here it would be nice to use a static import - that would make it more consistent with the other code
Why is this necessary? This should probably use the generic updateBiometicListeningState(). I think you're doing this to turn on the iris scanner? If so, you should leave it authenticating state, like we do for fingerprint, and send another signal to go into high power mode to complete authentication. This is what we do in fingerprint.
Same question.
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null");
java Objects.requireNonNull(callable, "callable is null");
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
It's a good update
use the optional, luke! ![image](<LINK_0>
Program to interface, not to implementation - please change return type to Map<String, Object>
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
I'm seeing most of the string literals used for property names, etc are re-used in quite a few places. Let's introduce appropriate constants upon them to be able to make the code more maintainable.
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
What do you think about Comparator.naturalOrder() instead of null ?
Can we have a thread name here?
please validate ledger id
you could use Exceptions.expectExecutionException();
must be package local
Minor: Ideally we should avoid doing work in the constructor. Pas apiRooUrl and Client to the constructor, and provide a factory method receiving apiRootUrl, username and password and creating the constructor dependencies.
There are keystore types which don't require a password or gets it from another channel (e.g. WINDOWS-MY type).
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
We can strip this down quite a bit to just java this.eventReceivers.forEach(EventReceiver::close);
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
Should be a SamzaException with a message, not NPE.
Not sure, why not use @NotNull?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
use ShellIsAvailable
use ShellIsAvailable
use ShellIsAvailable
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
nit: plural naming on list?
This class has no superclass, so I'm not sure we need to call super() here.
Just curious, why do we need to change the access qualifier to protected?
so if you make this private that would prevent subclasses other than Some, right?
Why does a utility class need a protected constructor?
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
The code can be simplified to rely on autoboxing.
if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
We need to check offset + length <= arr.length?
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
@njhill just to be 100 % safe should we better use: ?  System.arraycopy(array, index, copy.array, copy.arrayOffset(), length);
We usually don final local variables.
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
I think it is better to throw exception
I thought you wanted to end this practice, Adrian?
Even if this was copied, we should fix the this.m_ references here :)
You should use assertNull.
Use Guava hashCode function
Yeah this should be return set.get();
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
!reason.isEmpty() can be used
They are mutually exclusive? Or is that a micro optimization?
The 'if' check isn't needed here, right? replaceAll will only match if these are true?
can be delegated as: putByteProperty(key(key), value)
can be delegated as: putCharProperty(key(key), value)
can be delegated as: putBytesProperty(key(key), value)
use a constants in PicsConstants for page.png
Is this an artifact or intentional? It's not in the interface.
Should it be internationalized ?
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
Should this return the AzureTable?
is there a reason why this method isn't implemented?
This should stay final
Should this method be final?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
This check is redundant because you check this in handleSelection()
I'm pretty sure we use IllegalArgumentException for these everywhere else.
backspace (bracket should be one tab back)
space
1. openHistoryPage() method should be named like openFileHistoryPage() 2. method looks better if parameter consist only from one variable e.g. historyPage.openHistoryPage(URLsContent.fileName);
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
@ILikeToNguyen Why the change in visibility here?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
@slubwama provide an error message description of what has failed in addition to the stack trace
some other Executors wait here and see if the task exits immediately. Maybe we should do that too?
Should we be concerned that the expireTask can be reset after this synchronized block completes? Whose cancels the Future in that case?
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
nitpick: just return <cond> sufficient
Why is there a fromByteArray method? Why not call the constructor directly?
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
But existing rows use null not "" for the parentUuid.
Could we reuse instances? Perhaps justified if getCoder is frequently called.
static imports
static imports
This should say "LocalTime".
This should say "OffsetTime".
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
we don't use curly brackets for single line bolocks
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
what's the intent of this change?
please fix whitespace
Huh? :-)
I think this should have its own integration test as this is nth_value specific stuff only
Would you mind improving this test to use executeFile() instead of executeString()?
have a look [<LINK_0>](here). This class should be deprecated and no longer be updated, at all.
Same here, with respect to bad exception handling.
quit can be made public, to be more explicit.
return symbol != null ? symbol.qualifiedName() : "";
It is useless to test before marking as ignored, as only the symbol which are already known could be marked. Note that to be known the symbol have to pass the "isSymbolRelevant" test, which is equivalent.
This can only happen if semantic is not present (symbol method is not annotated as returning null). As such you should test if semantic is present and not raise an issue if it is not the case.
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
This will create a new instance every time. Cache the instance in a member variable?
It would be cleaner to have this set as part of the UnitTestModule() at the guice level so people don't need to remember to do this themselves.
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
why not just return it directly?
Can you replace IDs with names in this log message?
I think you want to do this in the reverse order
empty finally block
why we don't swallow exception here for close?
Can we have a message assert on this? I think the point here is that the exception thrown by the runner close isn't the exception that happened inside the shutdown operation
You should use deadline. Furthermore what the interest to change it ?
Does it still work on Windows?
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
Remember to revert this file, it should know about the transport class.
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
final
"Path validation" instead of "Request validation"
RuntimeException will be sufficient
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
Maybe Ints.checkedCast() for sanity
Should this have output partition too?
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Camel case here too
Consider Arrays.asList("xxx","yyy", "zzz");
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Why this change?
filter could still be null when this line is reached - we should check it isn't null
Generic type not used, remove.
StringPool.EMPTY instead
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
nit: remove brackets to be consistent with 2 lines below.
I think you missed updating the parenthesis on this one
do we care to check for the length to be positive here?
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Should check if errors contains error with key "Concept.conceptClass.empty"
Should check if errors contains error with key "Concept.datatype.empty"
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
isInfoDebug
Why change the name the property? Accident due to mass refactor/rename with IDE?
Technically setting closed = false isn't needed since this is the default for a boolean
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
INITIAL_SIZE is misleading because this constructor creates a fixed-capacity queue. So this value is actually the maximum size.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
rename
rename 'listeners'
not all listener
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
cannot be null.
We can directly use updatedVolumeList instead of copying it to a local variable.
But we have already clicked the button in the command before, haven't it?
What we are waiting here on?
just reuse this method where you need  public void selectAutocompleteProposal(String item) { seleniumWebDriverHelper.waitAndClick( By.xpath(format(AUTOCOMPLETE_CONTAINER + "/li/span[text()='%s']", item))); }  <LINK_0>
If you instead call this lastItemPositions and subtract 1 here, does that save you from having to subtract 1 from the final return? I think it reads clearer not to have a "- 1" on the last return.
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
I'd rather use Money here.
Let's adjust the formatting :)
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
I would recommend an else if here to avoid comparing against a string unnecessarily.
Args.notNull
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Not sure that it's good. If path is not setup - this.dir will be still null - and we just pushing NullPointerException one level down.
think you should add it as method somewhere
FindBugs finds this line not to it's liking it seems: Exception is caught when Exception is not thrown in org.jboss.weld.probe.Reports.getDesc(ConfigurationKey) ["org.jboss.weld.probe.Reports"] At Reports.java:[lines 78-370]
Nitpick: Can probably remove both the if and the else (saving three lines) by starting with description = MoreObjects.firstNonNull(description, "") right at the top.
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
Revert back to sessionFactory.getCurrentSession()
same here. In case you want to open an ErrorScreen, you can do so by using one of the reportError() methods from <LINK_0>
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
log the exception ?
can you make all of these as just Query and not org.hibernate.Query?
Please use the positional parameters.
We can't filter by closing time?
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
If an implemented class uses this default group method, does it work with returned null or it has to override with some implementation?
studentsWhoRespond -> studentsWhoResponded
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Don't we have to say that this is uniqueId JDBC?
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
You can static import the checkState method.
return this.toInteger() == 6;  Since toInteger never returns > 6, I find the >= a bit confusing (even though it's more future-proof).
Use same order as the field declarations.
that class would be better with a builder, though I wouldn't ask changing it now
This line is redundant.
does this need to be calculated on the fly each time or can we save the iterable?
Should we throw an exception instead if a DimFilter was null?
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
We should call the init() method first, instead of letting the KerberosAuthenticator do that for us.
I don't think we need this catch - this is handled by the boolean return value.
Is it for sure targetName will contain @. I mean in case of serverName null, and when targetName is not under server control entirely.
Unsure this addition is useful.
Is there a reason that allocationPools, dnsNameServers, and hostRoutes are missing here?
Omit nulls or not?
Remove all "null" cases. There is a default case for that.
If this should never happen throw an IllegalArgumentException instead.
Gson doesn't run on these versions so I don't see any reason to include them.
static
The null check is now redundant since now we do literal.equals(variable).
remove
ctx.close()
replace with ReferenceCountUtil.release(msg)
maybe log an error message here if numConnections ever goes less than zero
is the server name mandatory still ?
assertNull? And the withTx... though I know you've just moved this code from another test.
Could you please use Map interface here (and not the implementation)?
replacing this with helper method would be great
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
You could probably use the same URL as in getResultById here.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
It should be "path".
Add a blank here, please.
I think it is better to add this to the generic 'Request' interface. To make it easier to use I think also that we should have several 'header' and 'query' methods in that interface, at least two: one to set just one header/query, and another one to set a map (I'd consider this optional), that way the user can do the following: vmService.start() .header("My", "header") .query("my", "parameter") .send(); We should also probably have a new 'BaseRequest', or similar, implementing that interface and providing the implementations of those methods.
Same, 4 spaces.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
I guess I'm out voted on using this. :-(
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
Avoid the intermediate variable and directly assign selfID.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
Try pushing methods such as getAuthorization().getViewConfig().isAdmin and getAuthorization().getAdminsConfig().isAdmin to Authorization class
Any reason for logging and throwing the exception. Normally, we log or throw.
Should be externalized.
Externalize
Externalize
Which tests fail if we don't have this line?
I think this should be replaceFailed = false instead.
Silly think but can we call this workbenchPage, wPage and Ctrl+K lands frequently on the method sho(wPage) and I like to use Ctrl+K to follow a variable
use log's parameter here
Fix logging level here (error)
suggestion logger.warn("Failed to do decode hash using base64! " + ex.getMessage());
hmm, why don't you verify the type ?
None of the tests in CaseDbQueryTests handle the condition where this Lookup is actually valid (and neither of the other two tests cover this code path)
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
to get variable replacement you need to use the idiom: if (!validate(isClusterSwitchTypeOVS()) && !validate(...)) { return false; } where the predicate methods return a validation result instead of a boolean (which will encapsulate test+result nicely) there are lots of examples in other commands
Please use StorageDomainValidator.isDataDomain()
this is 3.3 feature, not 3.2
This should be as it used to be, no need to convert to lower case as that should already be part of the "value()" implementation of SELinuxMode.
This should be 3.6, even if the "quota mode" concept was available sinnce 3.2.
This check feels a little weird for a few reasons. It behaves like a factory (in that it returns new instances) but sLock is not assigned here. It also initializes a static field from an instance method and that feels strange. I suspect that if the lock is not being acquired in one method and released in another, and there aren't any waits involved a more primitive synchronization technique may be sufficient (such as a synchronized method or block, without the use of a ReentrantLock) -- I'll leave this up to your judgement but this looks dodgy
Please remember this ctor changed.
ooh! I ...Connector, here!
Can this be private, or is there another use case for default attribute outside the builder's call?
should the message include "command _with options_:" + this.options ?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Don't need toString()
Can you add getId() and mark id() as deprecated?
Missing StringUtils.isNotNullOrEmpty() check
unused field
the attribute is not used
Can this be private, or is there another use case for default attribute outside the builder's call?
It's beeter to used int type.
Would be better to have all these methods return a primitive long rather than an Object Long.
I propose to log the actual timeout used if it differs from the default.
Maybe catch Exception? Otherwise propagation stops.
if target is already updated or expiration time = -1, in either case we can skip update
For debugging: Would it make sense to log the exceptions here?
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
Can you please move the Preconditions up to the constructor? Also perhaps check for matching with " projects/(projectId)/instances/(instanceId)/clusters/(clusterId)"?
Just return checkNotNull(id, "id").split("/");
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
it needs to be protected against concurrent modification
again I think you can use the diamond operator
There must be a more succinct way of doing this using streams.
why not replace these two lines with return (getState(key) == State.SET)
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
OPTIONS could be more suitable here, since we don't want to transport the whole value
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Can you assert the container has the right name?
Doesn't List as a Collection have a defined method to check whether it's empty or not?
throw e will never be executed.
Why do we need this change?
is this needed?
Should this return the AzureTable?
is there a reason why this method isn't implemented?
These two lines probably can be combined into one.
Remove by dn/key.
We need configuration property persistence-manager-remove-count: 1000
final
please use String.format to concatenate strings
whole expression should be wrapped into toIntExact not only rebase( index ) % entriesPerPage
shouldn't it be- (index +1) % numberOfMacsInRange ?
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
Maybe rename idToChildResource or something along those lines.
Why are you changing to patient 7 here too?
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
Using == for object comparison? :)
Log debug - not info.
method can be protected now (private if not isolated in tests).
Another option would be to use  log.debug("This is the execution root? " + result) to replace the lines 532 to 539.
could we check this without throwing an exception?
Resources is itself part of Guava, and is marked @Beta. Why not use GuavaCompatibility.class.getClassLoader()?
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
I think a special case should be made for an anonymous principal, to disallow the API in such a case.
this method is @NonNull, throw UnsupportedOperationException until we implement this ?
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
Maybe remove the package name as it is already in the import statements.
Use a builder method from TestNG Collections
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
RuntimeException would be better. Typically SI components check the exception and wrap it to MessagingException with "guilty" Message. If it is MessagingException already we lose the "guilty" Message context.
setErrorMessage
This field is written here but never read, can be removed (Findbugs)
I don't see any change that is related to elapsed-time, why is this change needed?
super.getVm() will do dao call...
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
is this necessary?
these error messages should use the name of the expected property. keyField
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
Please, use text "Project directory permission" (Name was fixed after sending this pool request) thank you.
Use "Mail" instead of "Mails". There is only one trusted mail.
This can be made static
You can chain this like  java return ImmutableList.<String>builder() .addAll(currentSeeds) .addAll(newSeeds) .addAll(oldSeeds) .build();
This can be simplified to:  java return ds3Requests.stream() .filter(this::isGetObjectAmazonS3Request) .map(this::toGetObjectCommand) .collect(GuavaCollectors.immutableList());
no need for an ArrayList
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
nit: ~Square formatting
clickGallery is not the name of the method
if scrolling if not necessary, change to .click(), if yes, leave as is
click on element
"ws" and "wss" must be defined as constants.
nit: public abstract void
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
UnknownHostException can be removed
UnknownHostException not necessary here
new QueryResult<>() is redundant here
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
@xpdavid is this the right thing to do?
Can this be private, or is there another use case for default attribute outside the builder's call?
This isn't doing anything special (such as transform) before calling forEach, so write it as a normal for-each loop
You can even go a step further with this one: suggestion options.forEach(this::addOption);
Use Guava's implementation rather Apache Commons. There is no need for the duplication.
It's better to use static import here to improve readability of code.
What about checking running the test from command pallet?
In my opinion, just renaming of variable to something like "testProject" will be enough.
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
Why do you introduce a TestTimeSource here? Is it because the SystemTimeSource is not in scope as it lives in impl module? Especially as the TestTimeSource provides the advanceTime method which is not used - so dead code. Two options: - Move SystemTimeSource fromimpltocore - Use an anonymous inner class that wraps System.currentTimeMillis()
Use ImmutableList.copyOf when lists are not null.
shouldn't print the stack trace from the test
Make this java fail("expected exception");
new String() is redundant.
should be setSucceeded(true)
* shuoldn't we call super? * worth adding some log..
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
Which type would be assigned in this case?
suggestion this.dataStoreMap = new IdentityHashMap<>();
Why don't we make inDegrees to ConcurrentHashMap also?
we can remove this validation since it's done encodeAltSequences now
Can you replace IDs with names in this log message?
Just trying to figure out why this has this been done. Under what circumstances will we update the Germplasm and its name.
Why is it a list of lists, not just a list?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Collections.emptyList()
Why protected and not private?
please extract to a separate method
why this is in vmCommand? should be in stopBase command
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isMaskFormatValid(mask).
Can this method be made private?
The input is already encoded. That's probably not what you wanted to test.
Consider adding this in another commit, it's easier to note the (important) change/fix.
What is this for? If you want to set an icon for the Stage, please do so in the DNAInator class.
suggestion 749, // CWE-749: Exposed Dangerous Method or Function  Or maybe: CWE-676: Use of Potentially Dangerous Function ?
Remove this if it's not needed.
No need for the instanciation, right?  webView.getSettings().setJavaScriptEnabled(true);
this isn't required in these setter lines.
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
I'd say "block end cannot be before block start"
Here we need to take sequence number wrap around into account. Alternatively, what we could do is unconditionally set the maxSeen, and prevent the maxSeen from being set if the end has been set. However, I don't like adding this kind of logic in the setters. Maybe it'd be better to have a getMaxOrEnd() method.
bad hashcode.
Actually, I wonder about this one. What happens if you don't do this? One could make the Switch or CheckBox fill parent, in which case it might make sense to be able to change the text alignment. Would you mind running a test of this and updating this conversation with the results?
You need to create an event in frameworks/base/core/proto/android/app/settings_enums.proto
isn't it stringbuilder better? too may strings to add.
@dmzaytsev let's inline this
canonicalize both files before calling toURI() . E.g. there can be uppercase/lowercase drive letter differences on Windows which would make the URI String comparison during relativize() fail.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
I know this is code correct, but maybe I would rename the local variable writeLock to avoid any confusion with the class variable?
out of curiosity: what meaningful exception could possibly be thrown here ?
Another %n?
It looks like these two exceptions can be combined into one. I don't believe that you need to call out the specific exception since it will print the stack trace for the exception.
you shouldn't need it as UnknownUserException extends LoginException
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
They are mutually exclusive? Or is that a micro optimization?
Please add curly bracers here. Also please check other places, because I saw it also on more other places. You could use IDEA formatting highlights for that.
want to change this logging also while you are here
Sorry, I was thinking of this:  java private void handleBadgeResetPN(Bundle data) { if (data == null || !data.containsKey(PUSH_ARG_NOTE_ID)) { // ignore the reset-badge PN if it's a global one return; } removeNotificationWithNoteIdFromSystemBar(this, data); //now that we cleared the specific notif, we can check and make any visual updates if (sActiveNotificationsMap.size() > 0) { rebuildAndUpdateNotificationsOnSystemBar(data); } EventBus.getDefault().post(new NotificationEvents.NotificationsChanged()); }
nit: you can merge both lines above as checkNotNull will return the given argument
Would be better to test against more complicated Completable, for example check that some function was invoked
static import for milliseconds please :)
Please add assertion for exception cause type and message, we must be sure that it's really expected exception.
Rename -> CosmosDbFactory to CosmosFactory
LocalDate.now(UTC);
Redundant. See DirectReplyToMessageListenerContainer ctor.
Adding content to the commit message is not a good idea. Also, it's better to have unified commit message like: Change file <pathToFile>
Is replacing separators enough? We should look into something that will work for any special characters.
Does this have the desired effect on UTF-8? I think a lot of images end up starting with a pile of underscores, sometimes even just "_____________.jpg".
nit, Collections.EMPTY_MAP?
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Why does the handler require a zkUtils reference itself? Same for the other one.
Would be cleaner to call cancelAll() here. My expectation is that we would clear state and start afresh during a new session
This guards against no processors change(for some reason processor didn't remove itself) on barrier timeout. On contrary, we could have redundant rebalancing phases (one at barrier timeout, one when processor gets deleted. We can't handle this cleanly until there's pause functionality in SamzaContainer). Let's create a JIRA for this.
I think this method could be private.
Raw type?
Raw type?
pls substitute these three lines with setInternalState( this, "toolchain", toolchain );
Not really understandable without having the source code in IDE
in this case I think return isRunning() ? this.ssl ? "https" : "http" : null; reads cleaner
i wonder if using Pattern.compile() as a static member to hold the compiled expression is more efficient.
we never use NULL, it is a bad practice in general.
Oh please, no! Don't ship a null object! :cry:
If there are tests where this is common you can create a helper (minor suggestion)
With empty lists, is it really expected to return false? Should it not rather return true?
What if you put fields, but no event names? What does/should it do? Also, what if you put no fields, but event names? Does it behave like the EventRequirement? That should be tested both with optional and mandatory requirements
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
Why not just catch "Exception"?
Which exception has been observed here? Please don't catch exceptions when we don't actually know what they are.
I think will only pass a single sql statement here, can use SqlParserFactory.parse(sql)
there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.
could be static
no need for the additional check if propertyParts.length is ok?
else throw an exception with a descriptive message about whats wrong.
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
Do we really need this override-able timeout? Or is it a nice to have that we've thought of? I'd suggest keeping this out for now and just using the configured value.
Can you please add a default value for LONG_VIEW_INDEX_ENABLED_ATTRIB to QueryServicesOptions and set it to false and look it up similar to :  boolean asyncIndexBuildEnabled = connection.getQueryServices().getProps().getBoolean( QueryServices.INDEX_ASYNC_BUILD_ENABLED, QueryServicesOptions.DEFAULT_INDEX_ASYNC_BUILD_ENABLED);
No, I mean take the Log.e() near the return null;.
Flip comparison
mark this method private as this is only used in this class.
These might look a bit tidier as static imports
optional: can use exactRef
A template rule is not necessarily a built-in rule. Please simply the creation of the rule by only using db.rules().insert(), not need to override anything
You don't need to have this condition as there's just a loop doing nothing if filters is empty.
It's kind of funny that this just has 1 record. Better than no records though!
Might replace manual checking for missing mappings with storedRecords = oafRecordsByFamilyMap.computeIfAbsent(columnFamily, k -> newArrayList());
Commit message seems to be wrong. It is Operation not Function.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
ditto, s/i/identifier/
not needed; just cut it
return Objects.requireNonNull(remoteFuture).get();
Should be removed if empty
suggestion driver.get("http://host.testcontainers.internal:" + port + "/foo");
tabs -> initialTabNumber?
- [x] Why need this? Please re-consider based #768.
restore empty line.
Actually we don't set anything here: Either we don't log at all or we log something like: "Keep [property] as [oldValue]".
I'd love to have debug output here too, in case it were to happen
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Could you check for null or empty? Via StringUtils.isBlank
we never use NULL, it is a bad practice in general.
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
why retry?
please rebase, arik removed the lock in a different patch.
I'm not sure we want to execute every REJECTED/NOT_STARTED command on engine startup, what if it took 2 hours to restart the engine? think of the following case: host went down and we run a VM that ran on it using this infra, the command didn't start and there's an engine is stopped and started after an hour - on startup we'll try to run the VM, even if no SPM was selected, so the user will see that we try to run the VM without asking and that the operation fails I think it is better no to try again to execute the commands in that case. we should do it only for special cases such as HA VMs
All above cases can be removed?
"valid times" should probably be "setup time" or just "setup"
I think the default should be there is aggregation. Same as in runMultipleAction.
you can call runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, false);
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
should call super: <LINK_0>
Why not reuse getString(R.string.text_bluetooth_disabled)?
It makes sense to introduce ICPPNodeFactory.newLiteralExpression(int, String, , char[] numericCompilerSuffixes) method, use it in GNUCPPSourceParser, and get rid of the setNumericCompilerSuffixes method.
fSuffix is guaranteed to be null at this point, but it's preferable to pass CharArrayUtils.EMPTY as the third parameter to minimize amount of work done inside the getSuffix method.
Redundant qualifier.
Integer.valueOf
i18n
you can use computeIfAbsent here
This is not time zone?
"algorithmName must be PERCEPTRON"
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
Should use the log, maybe a warning.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
Return the zone id here instead of returning an empty string.
Should this link to the course?
s/Kills/Kill
Why does the report contain a file-name pattern instead of a real file name?
This is not a robust test. The number 24 will change as soon as we change the vocabulary.
prefer == instead of !=: instance.rootWorkflowId == null ? instance.id : instance.rootWorkflowId
count(*) is more canonical than count(1).
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Constructor can be package now.
For this value, we should do something closer to what ProductDTO does. Leave the building of the URL to the actual entity so we don't have two implementations of it floating around. We should also update Pool to be nicer about generating it so we either generate a valid URL or nothing at all (see Product for an example)
IMO getHref() should point to this exact product -- using the uuid as you do below -- and should not be based on the context of the current Owner. Permissions on GET /product/:uuid would then have to be modified to check the Principal's Owner against the product's owners in order to view it via the ProductResource.
You should not change this, it is not backward compatible.
We could in theory do this multiple times within a second with concurrent access, but it doesn't seem like that big of a concern. To get around it we could create a new FetchedTime if the check passes and then do a CAS, and if the CAS succeeds, call fetchTimeMicros and fill in the fields of the new FetchedTime.
missing final
This seems wrong. I think we should consider making the seed be a String instead of a byte[]. According to RFC 2289: > The seed MUST consist of purely alphanumeric characters and MUST be of one to 16 characters in length. The seed is a string of characters that MUST not contain any blanks and SHOULD consist of strictly alphanumeric characters from the ISO-646 Invariant Code Set. The seed MUST be case insensitive and MUST be internally converted to lower case before it is processed. Since this value must always be textual in nature, it seems wrong to represent it as a byte[]. @fjuma is there a justification for this or can we make this field be a String? A String has a few advantages like immutability (one less array to copy) and ease of manipulation.
Shouldb't be this i18m
Consider using i18n instead of hardcoding the string External Components.
Use CollationKeyFunction.NAME here instead of repeating string constant.
please check here isSetPmProxies() otherwise you can get NPE
Why not to create producer method like: @Produces Host createHost() { return new Host(); }
This logic can be moved below. Here:  if (host != null) { checkHostPermission(user, respectFrontendRoles, host); }
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
suggestion this(-1, "<no-name>")
No, this isn't good. With this way we lose all the customization provided via the common shared config for EvaluationContext. I'm that won't hurt to evaluate just to Object and check it to the supported String and BasicQuery types. And of course convert String appropriately. That's how we will still pursue the backward compatibility and flexibility. Thank you for the update any way! Will take a look tomorrow closely. Right, that looks pretty much possible to backport the feature to 4.3.x
There's also a race here if someone calls setDisconnectListener(null). Do you want to allow unsetting with null? If not, prevent it.
I'm not sure why you call the onCompletion callback here.
What's wrong with setting the listener to null if it should already be guarding for null listeners
do we need a null case?
The streams created are T1 and T3, but the ones added here are T1 and T2. Something is not right?
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Please consider adding a Preconditions.checkArgument to check that base64EncodedKeyContent is not blank.
Could the cipher suite be made configurable?
In the utils package there is a class called ConverterUtils that has isEmpty and hasContent functions. I suggest using these when you want to check if lists, sets, maps, and strings are empty/null vs full.
Why can't you use MoreObjects.firstNonNull here as well?
this and m_ is redundant
I wonder if this should be more of an error. For the Repository to exist but the ProjectState not to seems bad.
@apearc03 ASL header is missing causing the build to fail on Travis.
I see. I think that makes sense. It seems like TestKind is not used for anything outside of the Trac tests. I'm not sure that it should be part of the TestConfigurationProperty because it seems like an intrinsic property of the tests and not something that should depend on which suite they are running in.
the same, add indent please
This should be package private?
Also wondering why? and how this is related to ASM 6?
I would rather that this method return "null" when cause is not an Exception, and then call initCause() just below.
Is there a situation that getAvailableNamespaces doesn't return result, so we are required to traverse over authz extensions directly here?
Don't we have to say that this is uniqueId JDBC?
Check null. The caller might pass an unknown type.
Will this have any effect to legacy data (i.e. those existing before this PR)?
what about location ? we do not need LocationSerializer ?
this is redundant
@lauravignoli Any reason you split the declaration and initialisation of the query variable into separate lines? I think it would be best to keep the style here the same as the methods above, but it's just personal preference so I will leave it up to you.
Any reason why we are packing the results of queries into ArrayLists?
We should create a separate, generic class for this execution, since the body of the method is always the same.
you have to add a canDoAction message if you fail canDoAction
perhaps do this in multiple lines
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility to be consistent with all hosts in the storage pool.
Hi, I would prefer if you will have at base class a method VdsDao getVdsDao (protected method) that returns DbFacade.getInstance().getVdsDao This reason for this as it will help us mock vds broker commands one day.
1. do we need this? if the host is already in the cluster..it means that it's already supported, not? 2. why don't we check just by the storage pool version? do we want different behaviour between the pool hosts?
Parameter should be true here, no?
you no longer need those methods to be synch right?
Seems this shouldn't be _EXACT.
But why do we handle 400 differently than all other errors?
The whole 4xx range (400 until 499) is defined for client errors.
use ObjectUtil.checkNotNull(...)
Is this method really needed? It's similar to make init public
this should go to super.reset(), shouldn't it?
Another method reset has a bug:  /** {@inheritDoc} */ @Override public void reset() { cntr = new HitRateMetricImpl(cntr.rateTimeInterval, cntr.size); }  cntr value must be copied to a local variable in order to avoid data races.
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
why synchronized ?
if (realm != null) maybe - just to be safe.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
I know this is code correct, but maybe I would rename the local variable writeLock to avoid any confusion with the class variable?
out of curiosity: what meaningful exception could possibly be thrown here ?
add {},
The params are so nicely aligned above, how about here and below ;) ?
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
this variable may make more sense just as itag given it isn't only for items.
This looks the same as the V1 version except for the Class of the version. I think you can just use a template here As an example <LINK_0>
Is it possible to use a more advanced regexpr [here](<LINK_0> instead of filter target after? I expect it should be enough something similar to src/**/*.*dmn.
Is this method really needed? It's similar to make init public
Another method reset has a bug:  /** {@inheritDoc} */ @Override public void reset() { cntr = new HitRateMetricImpl(cntr.rateTimeInterval, cntr.size); }  cntr value must be copied to a local variable in order to avoid data races.
Please check if points.clear() should be called
Streams used in proper way, however I would propose slight improvement: java categoryWidgets.entrySet() .stream() .filter(entry -> !Objects.equals(entry.getKey(), categoryId)) .forEach(entry -> entry.getValue().setVisible(false));  I think proposed formatting is more readable and prevents NPE in filter part, let me know WDYT.
If you update to Brave 5.6.0 then you can add another exit condition of: !context.isLocalRoot() that way this doesn't tag every span and blow up your storage requirements. PS: I have a feeling someone else will block this being merged until that is done
I am a little worried about the performance of this change here. getTypes can be used quite frequently, each time we will make a copy of existing types. Also changing viewof to copy will change the behavior. Many optimizer rule just call getTypes once and assign it to a member variable, newly added variable in the optimization rule will be missing in the copied TypeProvider. Can we change the TypeProvider to store only Map<String, Type> as well? It looks like we don't need to use Symbol there as well. The only other place copied the whole TypeProvider is areExpressionsEquivalent method. I am not sure if we need to convert the variable to input there though. I think variable name is unique already in TypeProvider, so I am not sure translate it to integer will help much in canonicalize the expression.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Ditto: should be type.getType()
Should this be implemented?
throws TaskException is part of the interface, did you mean to remove it?
we never use NULL, it is a bad practice in general.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Collections.emptySet() should be all that is required here, no generic.
nit, Collections.EMPTY_MAP?
Actually the underlying objectExpr could have free variables.
rename to className
Move inside if statement
Missing blanks around "=".
Use this.key
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
Same as above, let's not instantiate the FBO within process and let's try to use BindFBO in initialize() instead of this bind() line.
Notice how in many cases this line won't be needed once this node uses the SetViewportToSizeOf state change.
You should be able to do a simple: DefaultDynamicFBOs.ReadOnlyGBuffer.setRenderBufferMask(true, true, true); no?
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
throw exception
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
Does this truly need to be done in arjunaCore or could it be guarded in XTS alone? It is fine if it is an arjunaCore issue and we should code to fix it but I need to see an arjunacore test case that shows this or reasoning it can't be sole change in XTS
optString does not return null, it can return "null", "" or "value" <LINK_0> and I think it makes sense to move metadata.optString("flow_id") to var since you use it twice.
I propose to change it to:  Map<String, String> metadata = new HashMap<>(); metadata.putAll(clusterConfig.metadata()); metadata.putAll(Microservices.metadata(servicesConfig)); clusterConfig.metadata(metadata);
why not use the MessageLevel type?
Nit: unnecessary this.
Can you make all of the accessors final?
It should be Memory metadata/dump disk could not...
this check should be the same as in BackendDisksResource.add()
should be: new HashMap<>();
Assert.areNull
@gjd6640 how about making this more explicit and robust this way:  int windowsOffset = System.getProperty("os.name").contains("Windows") ? 1 : 0; assertTrue(firstHighlightingData.startOffset()).isEqualTo(1 + windowsOffset); ...
Would assertEquals work? Same for other tests.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
I think there should be a space after if here, looks like that is the convention used here.
Better to return "";.
I thought empty was OK, and it would point to latest?
use "1.0".equals(version) to avoid possible NPE
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
I know this wasn't your code, Lars, but you may want to use SubMonitor to fix this progress monitoring bug while you're in here. pm is used twice in this method.
the resource list will change during resolution if additional resources have been loaded. In this case a concurrent modification exception is thrown. I nevertheless accept the change and fix the bug by replacing the loop with EcoreUtil.resolveAll(rs); This handles the room file as well. Should that cause any problem?
rename to type
It should return ReadOnlyDictionary not ReadOnlyDictionaryInterface. Also IIRC, ReadOnlyDictionaryInterface is internal for Java.
Do we need the toString() here?
before accessing it's property, wait for element
@rui-castro why don't you keep skipsOnStream as it was?
This involves a look up of the character encoding type table. Use MessagePack.UTF8
@Serranya The same here. See above.
The SQLTable shouldn't need the default and connectionDetails map. It should just be handed the only ConnectionDetail object that pertains to it.
Would the intent be clearer here if we explicitly return EntityBinding.EMPTY_BINDING if the interface is mapped?  if (isMappedInterface(entityClass) { return EntityBindings.EMPTY_BNDING; }
Please test this method properly.
Isn't it also important that adType was async and method was top?
why both DataProviders have the same article's names inside?
Please add ? and % as well
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
I would suggest to make the return type RandomAccessible<Pair<A, B>> or even RandomAccessible<? extends Pair<A, B>>, if there is no strong need for being _exactly_ RandomAccessiblePair<A, B>. I can imagine that we might want to add other variants implementing this later.
could be a single return statement
whats special/the problem with those bundles?
Wouldn't this solution be better rather than traverse through all values and do string comparisons? private boolean eventExists(String eventName) { boolean exists = false; try { AuditLogType.valueOf(eventName); exists = true; } catch (Exception ex) { } return exists; }
Perhaps it would be beneficial to add the mac address as a replacement in this message (in a separate patch).
If this patch gets pushed: <LINK_0> Then you could use NetworkHelper.managementNetwork method and save a couple or repeating lines :)
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
code format
This is an anti-pattern. Use a StringBuilder instead. Why not comma instead of |?
Nit: if the call doesn't throw an exception, then this should print a "success" message.
Method should be synchronized probably?
You may want to test this with multi-line strings.
Do you forgot to compare items and label?
White space.
Is this meant to compare the item stacks beyond object equality, given ItemStack does not override equals *or* hashCode
I would prefer to have a constant (from the plugin providing the language) here, it will also show that the plugin is missing a Manifest dependency to the plugin that provide the language org.eclipse.papyrus.uml.textedit.transition.xtext.ui
this.defaultColor should be set as well. Otherwise, pressing "Default" will reset the color to Black
Could we instead check that this thread is fZoomThread? That should always be the latest. It would also prevent any applied result after we set fZoomThread to null (e.g. in traceClosed()).
// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off
public?
I'm missing the new field in the toString method.
(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
File
this.currentLocation.get() this may fail, as the currentLocation is not always guaranteed to be set. Check for presence
What's the point of the 6 trailing zeros ?
Package private constructor, rather than just public?
This is dangerous, as it will potentially lead to looping tests. the retryClickUntilPopupDisappears already tries clicking for 10 seconds. Let's restrict the number of iterations to some fixed (small) like 2 or 3 using for loop or something.
This message should be more descriptive. The only was for the handle to be invalid is either if: 1) There is some other thread trying to access the iterator. 2) The iterator has been previously closed. The message should reflect the above conditions.
Couldn't this just check unavailableException if it is null or not? Seems we wouldn't need the managerAvailable variable as well then.
<LINK_0>
Yes. I would say this is an api change. So we should deprecate the old method first
Don't we want this here?
It should be "Then that player shuffles their library", the oracle text in the spoiler file is outdated. I've been dragging my feet on updating all of it.
Use {this} instead of the card name. Add no full stop at the end of effect texts.
Instead of Cruel Deceiver you should add {this}
If the arg isn't modified, you can use Collections.emptyList() to avoid an allocation here suggestion writeReport(output, Collections.emptyList());
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
@cuenyad Having 2 for is not needed. Iterate lotDepositDtoList and have a map with LotUID as key
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Shall we return Collections.unmodifiablemap?
This method causes several build warning.
I think this should be fieldSet, as there is existing fields method (that returns Iterator)?
You can make this method private
Wait, this is worse than the previous version. What happened to the assertEquals()?
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
no checking flow when user sets grace period in the action
please verify response on remove()
please verify response on remove()
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
JUnit has [ExpectedException](<LINK_0> which I think works better than try catch statements. There are some examples in the Geode code base if you want some inspiration
We might want to consider calling the new method from this one so we don't duplicate code isPublishDateInTheFuture(dateCreated, new Date()) wdyt?
![MAJOR](<LINK_1> Remove those useless parentheses. [![rule](<LINK_2>](<LINK_0>
One of our helper classes must/should have a utility method to get a time relative to current time. If not, add one?
Might want to log a WARN if you are going to drop the command due to no myqOnlineData.
No need to override this or the following method if you are not going to handle commands or updates.
Use parameterized logging instead of string concatenation.
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
similarly here, if this is general, I've lost updates...
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
can you add to Builder as well
Should we have a constant for this?
We prefer the default specified in the properties file.
use new Guid(String) - this literal can't be null
"engine" can be extracted to constant
Can you use isEmpty()?
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
cannot be null.
consider caching the pool entity to avoid getting it twice from the db
"http.url" is the current name, when query parameters are present (which I think this is..)
It should be fixed. Component can't support all products if it supports only DI engine.
Arrays.singleton()?
new Not( ? Why not use the static method like for the other matchers?
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
Use LinkedList instead, as we need to remove its head frequently in endInput.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
The job of a dispose method is either to free unmanaged resources / memory and to deregister stuff properly so that the object can be garbage collected. Of course you can set all references to null / clear datastructures etc. to help the garbage collector but this is just boiler plate code with little benefits.
Unneeded change. This only used in RegexPathPredicateTest, that is in the same package.
Use same order as the field declarations.
return Collections.emptyList();
We were going to avoid signatures like IgniteFunction<Stream<UpstreamEntry<K, V>>, Stream<UpstreamEntry<K, V>>>, right?
I don't see the api for CosmosContianer (sync version). could you please add that too.
In some places we have recordStorage(), here we have the get prefix. I think it would be better to have recordStorage() everywhere.
you turned around T & I here, it should be declared as:  protected <T, I extends T> @Nullable I getService(Class<T> clazz, Class<I> implementationClass)
CanonicalizingHashSet is an internal class. It should not be visible in the public API. I think this part should stay as Set
This plays the current, not the next station.
please use curly braces even though this is a Oneliner
public final not final public
Copy-paste bug - should be "getDeviceListWithoutStatusSupported"
You could use StringUtils.endsWith(str, suffix), since it's null safe.  java return StringUtils.endsWith(version, SNAPSHOT);
Having this public feels problematic. What classes need to call this that don't live in io.realm ?
@antonini you can use Matchers.allOf() to combine these two assertions and get rid of one-time variable head
@aschworer same here, once used variable minTime can be replaced by delay
@fanifieiev the same above.
This is not clean. If this method now returns an absolute path, you should also change the method name from "getName()" to "getAbsolutePath()". Also, you will need to change the messages. With your change, the FSOperation_ConfirmFolderReplaceMessage would now say "This folder already contains a folder named /foo/bar/target/file" . Which is not accurate. Instead, the message should now say something like "Folder '/foo/bar/target/file' already exists. Do you want to...' Or you could change the code even more, to say "Follder /foo/bar/target" already contains a folder named "file". Do you want to..." Please make sure that you test the workflow, and validate that your final message makes sense.
This looks like a leftover and it hasn't any usage. Can we remove it?
((RepositoryTreeNode) object).getType()
Why uppercase fs?
can you make this a debug log? It would be easy to see if this config does not take affect. Pig creates multiple of these loaders and we will see lots of these in the log.
Do we want to check both getProjectId() and getJobProjectId() here?
does this need to catch all exceptions?
specify charset?
This try/catch would not be needed since GoraException thrown by getDataStore extends IOException :)
These two could be simplified to assertNull.
Could be simplified to assertNull.
Why are we calling getProperties here? Just call getValue on the call above.
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
Here should contains all the process type which may contains CDP DISTRIBUTION. e.g SPARK_JOBLET,SPARK_STREAMING_JOBLET,TEST_CONTAINER(only spark process related) Please ref to: public List<ERepositoryObjectType> getTypes() { if (ERepositoryObjectType.PROCESS_STORM != null) { // test if spark streaming is available (not the case with TBD license) return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM,ERepositoryObjectType.SPARK_JOBLET,ERepositoryObjectType.SPARK_STREAMING_JOBLET,ERepositoryObjectType.TEST_CONTAINER); } else { return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ,ERepositoryObjectType.SPARK_JOBLET, ERepositoryObjectType.TEST_CONTAINER); } }
Collections.emptyList()
I'm seeing MySQL use an error code like this: 533 throw SQLError.createSQLException("Unable to unwrap to " 534 + iface.toString(), SQLError.SQL_STATE_ILLEGAL_ARGUMENT, this.exceptionInterceptor);
Wouldn't it be better to only show iterations OR epsilon?
Shouldn't errString be in the exception?
This from field appears to be redundant, as this is an inner class.
using Arrays.asList create a fixed sized list, so doing later getTo().add(something) will throw an exception.
Why are you removing the setIDs here?
use getDiskVmElementDao(), please apply to all the dao calls in that class
it's already set to true
I think that it's better to split that line :)
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
Make this constructor private - this class is not intended to be instantiated.
make this constructor private since all the methods in the class are static.
This reads as if TenantIndex initializes the BoundedContext.
you can use injection for VdsGroupDao instead.
It should also initialise the proxyPanel (otherwise the defaults are not applied, e.g "Remove Unsupported Encodings" is not selected by default).
can we give different name to this variable? it is meaningless
suggestion if (this.currentTask != null && this.currentTask.isDone()) checkAndRethrow();
suggestion if (this.currentTask != null) checkAndRethrow();
Should we avoid using 'disloyal' here, since it's not about Byzantine style fault, and the vote is not disloyal against the protocol? Maybe something like 'quite leading due to a voter previously voted me changed its vote because of ....'. ?
nit: can you put "File connector started" instead?
Given it's for a test, I don't really care but... I much prefer using higher-level synchronization utils from java.util.concurrent whenever possible, rather than synchronize. An object.wait() can wake up prematurely, which is why one should always wrap it in a while block rather than an if block.
Since the menu item click has been handled, return true instead here.
Instead of finish(), you can just set the parent of the activity in the manifest to MITMainActivity, that way it'll navigate properly to the home activity
This can be replaced with return mDrawerToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);
Do we need !block.isAir(world, x, y, z) here? Wouldn't (block == Blocks.dirt || block == Blocks.grass) return false if it was air?
This should return T.
Remove this by returning null above.
style nit: we don't use braces around single line blocks
On line 226, there's another check for JDOHelper.isDeleted, is that relevant?
Shouldn't this close the iterator before returning the list?
Similar change as first(count).
Logic: Similar change to LazyFluentIterable#first()
It would be quite neat to use DimensionManager.getWorldById(0).transform here, which automatically handles the "if present" check
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
can we explain here why do we need such function?
remove this line
cleal ?
Please log Bundle ID data here.
please replase MojoExecutionException for a new generic DeploymentExecutionException
This should be handled by the nodeDelete return value, so we don't need this catch.
Did we want to have this normalize the path also by returning the normalized version from Path?
Include the file:// as constant.
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
"Initial connection"?
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
It might make sense to use try...finally here, putting enableDeepLinking in the finally block. Otherwise deep linking won't be re-enabled if something goes wrong.
I don't see the point for a wiki page, if the wiki page did not changed then why could we need to invalidate the cache ?
should the second arg be true here?
Can be cached
the null check is redundant here if you refactor this code to something like below  if (SAFARI.equals(wirApplicationName) && SAFARIBUNDLEIDENTIFER.equals(wirApplicationBundleIdentifier)){ return true; }  since we are now comparing a String constant with a variable contents, null check is automatically taken care of because "".equals(null) is always false
java return this.name.equals(a.name);
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
I wonder if this should be an atomic operation?
should the message include "command _with options_:" + this.options ?
do not call real method.
suggestion
Seems to be more than 120 characters long
other places use "error" lower case
For the sake of consistency the response should be built using [ErrorMessage](<LINK_0>, even if it's just a test class.
Do not use Throwables.getStackTraceAsString to parameterize a logging message. The correct methods on slf4j logger for logging an exception are:  public void warn(String msg, Throwable t); public void error(String msg, Throwable t);
I foresee clashes here. Should at least use <type> + "/" + <name>
Might want to catch DateTimeException, severe log and fallback to a default time zone, e.g. for existing courses using one of the now unsupported time zones.
It looks like we need to modify ContainerAttributesResource to simply take a Map in its constructor. That way it's not only simpler, but it would also mean that all attribute values (including user-provided ones beyond those available OOTB) would be represented by the resource representation.
Go ahead and be specific about size and who is in the list. A check for non-empty list is not going to be enough to ensure this doesn't break in the future.
Recommend to divide into 2 method. one for save internal hashmap and other for return url after lookup. For example: String url = ExchangeManagerHelper.getEndpointURLBySpecVersion(epType.getEndpointConfigurationList(),higestAPI); StoreUtil.addGatewayAlias(url,getGatewayAlias(exchangeName))
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
Not convinced that getCurrentVersionString() throws a NullPointerException.
Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature
urrgh, not so nice. catching exceptions in control flow. especially catching general exceptions
I'm confused. Which of these catch clauses is the expected one?
Please add a cast to Object[] here.
- [x] You should write throws Exception rather than try-catch. (Same as @Before)
should this call SQLUtil. sanitizeCondition instead?
I'm pretty sure BasePanel also has already the dialogServie object
I would have expected the tracing to happen at the writePacket(buf, pos, len) level, since that captures all packets sent (not just packets sent as strings). end() is where flush-pkts happen.
This must be supported.
I think this is cleaner  public long size() { return writeOutBytes; }
"return position;" maybe?
Do we need to swap expected and actual here (and also for the next two as well)?
please remove this "assert", it is not required , it will do no good in future updates.
Don't think the "Tenor" in the toString adds any value now. Merge toFormattedString into toString.
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
You can use CollectionUtils.toImmutableList
this.
Same here when trying to save the context without specifying the script (or when trying to import the context).
How is this going to work if there are multiple test classes using this and they are run in parallel?
Use the getProductIndex method, in case subclasses need to override
return (radius <= maxMeasurementPointRadius && radius >= minMeasurementPointRadius);
spelling: radious -> radius
+/- 1 confusion: suggestion return new Diamond3iIterable.Builder(origin, radius).start(radius);
Can this be private, or is there another use case for default attribute outside the builder's call?
nit: Could be this.conf = requireNonNull(conf);
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
By right, soft deletion should not result in InvalidParametersException
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
The contents of the email subject do not match (currently it shows the course name as "Course ID:")
Use Converters.getElementToIdConverter.convert(x) so we can swap out the conversion without having to refactor.
This sounds pretty dev-like. Let's either make this an email address, or turn it into something like When defined: >Hi First Last! When undefined: >Hi! Should be easy to implement and avoids the awkward "Hi User"
This way you're automatically older than 18 after resetting your profile.
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
nit, Collections.EMPTY_MAP?
I get the feeling this is too simple. What if one index contains an object field, and the other has a non-object field at the same path? We should fail, but we will just execute the predicate for the object field.
any special characters to block in webhook name?
you should probably check Item.Configure here
You may want to assign labels to this node; it's marked to only run jobs that are exclusively tied to itself or a label.
we need good docs here
Swap the order of modifiers, like it in all other methods in this class.
CheckReturnValue?
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
if injected 2 times, calling two times variable.symbol().metadata() is not efficient. Please use a dedicated intermediate variable.
The expression won't contain the field name.
I think we could implement this in a more concise form as well: java if (!parameter.isAnnotationPresent(Auth.class)) { return null; } else if (principalClassSet.contains(parameter.getRawType())) { return new PrincipalContainerRequestValueFactory(); } else { final boolean isOptionalPrincipal = parameter.getRawType() == Optional.class && ParameterizedType.class.isAssignableFrom(parameter.getType().getClass()) && principalClassSet.contains(((ParameterizedType) parameter.getType()).getActualTypeArguments()[0]); return isOptionalPrincipal ? new OptionalPrincipalContainerRequestValueFactory() : null; }
Same here - don't have to create a new ArrayList. Do the same in all other places too.
Need spaces where your strings concatenate because you're gonna end up with stuff like doesn't havean @ImplementedBy in the output.
need to add more information about dimension/index/length
return HConstants.EMPTY_BYTE_ARRAY; ?
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Adding this to a field is good manner.
Adding this to a field is good manner.
Adding this to a field is good manner.
Swap the order of modifiers, like it in all other methods in this class.
I would prefer a use of Collections.emptyList() here, there's no need for this array list.
Please add @since 2.8 here to indicate when method was introduced. Also, for backwards compatibility, please make this throw UnsupportedOperationException, so that existing non-json implementations will not fail to load with 2.8.
What if type is not Class type?
Please make the constructor private (see Invalid).
Actually, is there any reason the default would change for a Property? Maybe we don't need this method either -- just to think about removing this method (or making it package-private).
Can the connection or the context be null at this point?
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
The duplicate close looks strange to me. I think @rmetzger gave a nice idea above. You can just catch and log the error and move each close in a separate try block. You can take org.apache.flink.connector.hbase.sink.HBaseSinkFunction#close as an example. That will be much clean.
use Java8 stream anyMatch() instead of this loop.
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
Consider @Restricted(NoExternalUse.class), I see no reason to make this public API.
Please have a look at org.jboss.as.controller.operations.common.Util.createEmptyOperation.
In static methods rather do it like this: java LoggerFactory.getLogger(WeatherUndergroundJsonUtils.class).debug(...);
"result" variable is never used so it could be removed too, right? Currently, executeOnMaster(operation) method is called twice ...
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
Please remove an excessive space character.
? element.getName()?
null =
This piece of code really would be easier to read:  haxe ResultHolder typeResult = getType(null); ResultHolder resolved = resolver.resolve(typeResult.getType().toStringWithoutConstant());  The way my mind works, I read getType(null) to call a local function, and the following getType() I also presumed to be the local function -- which didn't make sense. It took at least a minute just to figure out what was going on in that line; basically that the return value of getType(null) was not the same type as 'this'.
simplify this
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
Should this be compared with || instead of &&?
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), CANCELLING, EMPTY_VALUE);
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE);
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Please use more specific JSON type names.
I dont think you need the RocketMQ version number in the name here.
Then I wonder if this is the correct behaviour in the case of garbage being returned. Isn't the contract to retry in the case of invalid reads?
Java 8 has some constructs for these multi-field comparison pattern that we often encounter. Here, you could do the following: java return Comparator.comparingInt((AmbryDataNode k) -> k.plainTextPort.getPort()). thenComparing(k -> k.hostName).compare(this, other);
I see that this is symmetric to the implementation in Size but are these short circuits really necessary? Long#compare() will usually just do the right thing .
Checking containsKey before calling remove is redundant and should be removed
I don't see the benefit of this. It does make it less obvious that it is the same object having cancel called and being set to null below.
Suggest to move the 2nd param to a class variable since I see that the other tests are using the same one with the same value.
I do not like this check at all. What if we want a screen free from animation?
again, this is incorrect.
incorrect.
@vilchik-elena Charset.defaultCharset() should be replaced with a given charset.
@vilchik-elena Why not have the same setup shared with analyse_minified_files_user_config, only with a difference in "settings"?
@ivandalbosco we could extract path src/test/resources/org/sonar/plugins/python used twice in this file
isn't the currentRow the instance of RowBuilder which was just added?
suggestion if (rowIdx >= rows.size() && requested > 0)
let's cancel upstream only here and do not do it inside end() method
SourceImpl?
What if we return an empty list instead of throwing an exception?
Do we need this else?
This doesn't look like it does what a stopGracefully should do. Maybe we should rename that method to something like suspend (not in this PR though). But, what it's supposed to do is suspend a task quickly so the jvm can be shut down and then restarted. Specifically it shouldn't be trying to publish or anything like that - just persist to disk and then stop.
Could you use a format string here:  log.warn("Zookeeper can't be reached, retrying (retryCount = %s out of %s)...", retryCount, this.getN());
Thread.currentThread().interrupt(); is missing here.
Several things here... First, the condition you're using is slightly wrong: a big decimal may not be normalized, in which case its "unscaled value" may end with zeros, in which case it might not require rounding after all. For example 12.34 may be represented as 123400 with scale 4. With a decimalScale of 2, value.scale() > decimalScale, which would trigger the warning despite the fact the resulting number after applying the scale, 1234.00, does not require any rounding. You really want to use value.stripTrailingZeros().scale() > decimalScale. Second, I don't think you should issue a warning when rounding. At best a trace, but only if you really want to (and please guard the computation with if ( log.isTrace() )). Rounding big decimals is really not a problem; it's even a valid use case. The user may want very high precision in the database, but he might not care as much in the index. Third, there's another problem, much more important in my opinion: values that are too precise to fit in a long after scaling will not be rounded, they will just be completely wrong. I don't know how Elasticsearch behaves, but I think that, if it doesn't fail, we should throw an exception on our side when that happen. For example try to index new BigDecimal(String.valueOf( Long.MAX_VALUE ) + "345") with a decimalScale of 0, or even -2, and watch all hell break loose.
"else if" maybe?
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
same again: do not create a new empty exception but reuse the old one.
Item dropped should be a hopper
unnecessary array new: {{true}, {false}} should work here
final
specify charset?
is it worth to add a Log.debug ? or warning?
This will silently ignore the exception. Should be throw Throwables.propagate(e);.
this mapping should happen via public enum and not via mapping backend enum to string
It's a step in the right direction, but it would be best to be uniform with the rest of the application. For full uniformity: 1) Maintain GlusterStatus.java enum in the API, and map Backend values to it. 2) Instead of status string, use the 'Status' object (I didn't mention this before) The easiest way is to follow an existing example. For example, see this from VmMapper: model.setStatus(StatusUtils.create(map(entity.getstatus(), null))); 1) Backend VM status is mapped to a rest-api status (an enum) 2) The enum is sent to StatusUtils.create() which creates a 'Status' object 3) The 'Status' object is set in the rest-api entity (and later the entity is returned) Note that this woule require changing in api.xsd, for GlusterBrick: <xs:element name="state" type="xs:string" minOccurs="0" maxOccurs="1"/> to: <xs:element name="state" type="Status" minOccurs="0" maxOccurs="1"/> And for uniformity, best also make this change to GlusterVolume state.
please make this upper case
Can you please use static exception instance?
It seems that the following does the same thing with super.unparse(...).
IF EXISTS should be reflected in unparse
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
Same here... completeLoadRequest(request) ?
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
null? why not just a () -> {} ?
Add this qualifier: this.data
move depageLock.lock() right before the try statement
Please use LOGGER.debug because this error is kind of expected.
log exception
Please add a check Objects.requireNonNull(supplier, "supplier is null");
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
In case self is a BufferedIterator should this return self instead of re-wrapping?
if ai is not null, then return appLabel. Otherwise return null. => return ai? -- edit nvm, I guess return null is more explicit!
suggestion /* package */ ApplicationInfo getAppInfo() {
Is 'return Base64.encodeToString(...);' legal? could remove variable String tag
Can you change to static variable ?
return HConstants.EMPTY_BYTE_ARRAY; ?
You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.
Why you do not call it in finally block as before?
Please reintroduce the trace logging.
use logger
is this needed?
nit: maybe ignored? :)
throw e will never be executed.
I thought I already implemented this for the MavenArtifactGenerator...?
What does this verify? There are no assertions.
suggestion
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
suggestion assertKeyPair(file, null);
suggestion assertKeyPair(file, password);
This should always be read from the configs.
I suppose this should be true ?
should be false unless one of the vm's disks has true for this
Conceptually, this should be readRaf() since querying the length is a "read" operation. (I realize that in practice, it won't matter due to the exists() check beforehand, but the code looks strange/wrong with writeRaf() here.)
What happens when one of these TypedOutput instances return -1 because they don't know their length?
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
Can header name and value be null?
Class and constructor can be package-private as only used internally.
calling super not needed
Not sure whether this will work, If it does, do you think it makes sense to just clear out the offsets for the partitions that got reassigned, This way we will still have checkpoint state for the partitions that didn't get reassigned?
A little weird to inline the @Override here and not elsewhere in the same class (or really anywhere else).
nit: create static variable for this empty set and return that static variable
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
Which type would be assigned in this case?
Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
do null check whether or not to do this append. append(null) will append the word 'null' in the WordML
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Please add logging in here for us to have an idea of what is going on.
I wonder why you return the result as array and not as list.
Extract this try-catch block to a method to avoid code duplication
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
This is redundant. If results.isEmpty() then we have empty singleton and can return results
shouldn't takeWhile take care of this already?
please final
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Doesn't the record name, org.apache.avro.compiler.UnresolvedSchema, make this an unresolved schema? I think this error message should be that the unresolved schema name was missing.
@wezell , missing return statement... This is breaking when compiling the code
we can refactor this if and the one below into more compact code by checking nonnullable using ternary operator
It would be good if you can applytrimming for white spaces on platform.
Consider ordering this up one method to group public methods.
rename to source
We could just catch "Throwable". It isn't a good practice in general, but I think it is acceptable in this case.
It seems the exception message should be updated as well, to print the actual class name (in case it was overridden by the property)?
@brettchabot doesn't this return a Filter object which is ignored? i.e. missing filter = ... <LINK_0>
Split the request line.
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.
Isn't a HTTP Status 404 just enough? Do we really need to write a json message as well?
Don't need toString()
This reset all the routes. You need to get the managed route by its id, and then call reset on that guy
Same as in Alientype2.java (add type of alien)
Same as in DiagonalBulletLeft class.
iteralien -> iterShipBullets
These tests don't seem to assert anything about their output.
it will not throw InterruptedException any more. Should also check the other places.
this method should probably be final. Also it is missing the @Override annotation AFAICT
The types could be removed.
Have this just return an Iterator<String> because a List is a bit too specific and forces extra memory to be used even if not required.
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
I see this is used just in kie-wb-common as log message, however maybe could contain also fact/field, or some more details.
maybe sth like content.avro.deserialization? so in the future we might add content.json.* metrics, it would be weird to have .json as root metric
Why this change?
specify charset?
does this need to catch all exceptions?
Exceptions.propagateIfFatal() Could we be stricter about what exception we're catching here?
better to cast to string instead of using toString() .
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
cosmetic: move the catch line to prevous line following }
is this needed?
why'd you change the content of the error message here? Seems like it doesn't make as much sense as what was there before
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
The constructor should be made protected so that users can easily make a wrapper for it.
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
As previously discussed this is not thread safe. We cannot use Map.computeIfAbsent() or Map.putIfAbsent() introduced in JDK8 so I propose to add ConcurrentMap<K, C> concurrentMap field and corresponding param to the constructor. It would be illegal to provide both suppliers. The get() method could have two branches. One for regular map:  if (map.get(key) == null) { V newValue = supplier.get(key); if (newValue != null) map.put(key, newValue); }  And second branch for ConcurrentMap - the same as the current version but using putIfAbsent() instead of put(). Of course, we would have to modify SetMultimap and ListMultimap.
And this too?
computeIfAbsent?
minor nit: can we check mSavingContentProgressDialog == null and only create a new ProgressDialog in such case? something like this:  if (mSavingContentProgressDialog == null) { mSavingContentProgressDialog = new ProgressDialog(getActivity()); mSavingContentProgressDialog.setCancelable(false); mSavingContentProgressDialog.setIndeterminate(true); mSavingContentProgressDialog.setMessage(getActivity().getString(R.string.long_post_dlg_saving)); } mSavingContentProgressDialog.show();
let's rename final PromoDialog asyncPromoDialog to final PromoDialog gbInformativeDialog
Maybe better to use android.R.string.ok, 'proceed' seems a bit formal and also sounds like you're about to take action which might confuse users - I feel 'ok' is more that just you're done reading the explanation.
Instead of returning Repository, maybe we should return a Git. That way the Git object is ready to be used by the caller.
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
The connectTimeoutMillis and readTimeoutMillis in the builder appear unused.
Missing @ Override
Why not a for each loop?
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Fix please :-)
Yes, I will change it.
Do we need to call it every time ? System.currentTimeMillis() ? Practically 60 times a second.
maybe worth calling this TimelockRpcs or TimelockRpcClient or something like that? TimelockServerInterface seems a bit fixable...
We decided to get rid of service class version parsing in favor of passing explicit service+version at config time. Don't think we want to add this back.
During rebase, just pass a new ArrayList() to IsVmfree no need for variable
lets export this to a method
The <Integer> can probably be omitted.
I think that the process here is confusing, failedOvfDisks seems to be out of context. Perhaps a better solution would be to have updateOvfStoreContent return boolean value, which will indicate whether the update succeeded or not, same as being done with createOvfStoreDisks
move it before synchronized
This is like double lock checking. You may also want to check it before synchronized which also improves performance. Considering namespace is not changed, you don't have to check it in within synchronized block.
> NoSuchElementException
suggestion Objects.requireNonNull(in, "InputStream cannot be null");
Why does next have to be invoked here?
I don't like the density here. I would prefer if all arguments of the constructor are declared as local variables.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(logTag); // Or sanitizeTag or normalizeTag, etc ...
I would just get of any semblance of support for Apache.
What problem with have with "Input"s ? Main code should not be affected by test code. If we have some extra classes that are picked up we could rename them to be our of radar, or ignore them if them do not cause problems. "test" code should not affect "main" code.
Actually the underlying objectExpr could have free variables.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
What's the point of the 6 trailing zeros ?
We normally put private methods at the end
You should statically define those colors, instead of a new Color each time
this seems like it should be a try() with resources
Can you make a separate test case to test this functionality instead of modifying an existing one?
Should we hard code file extensions or use a static variable from somewhere else?
The title should be HTML escaped here if it's going into an HTML constant (which is presumed safe)
If we continue to use a StringBuilder here, we should use it in a way that makes sense.
Please use ApplicationTemplates instead of constructing the SafeHtml.
@fchauveau there is no null handling of source, is this intended ?
move inside of for loop.
Do you want to make the check that portFields is of size 2?
Revert this.
Like the SFS this won't be backwards compatible as the HEADER_SIZE has changed, however in this case we can't workaround this using the MAGIC array as it does not exist. So I think we might need to add a magic field, and read accordingly depending on whether it is/isn't present.
Welcome to the world of limited packet sizes. This will explode and explode fast. Do not hijack the vanilla packet.
I would turn this && around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.
return void
If we move the logic to the builder factories, this would not be needed.
not needed; just cut it
The configuration is confusing it's similar to number of mutations but it's actually a timestamp. It can be something like INDEX_FAILURE_HANDLING_REBUILD_PERIOD?
Possibly shorter to just write java env.applyConfig(this, hasTag("reindex"));  but this is ok
I'd call the variable entityClass
Here, you must return getRetryAnalyzer().getClass()
@brettchabot doesn't this return a Filter object which is ignored? i.e. missing filter = ... <LINK_0>
here too, can this be done with computeIfAbsent?
I think it is common to return the written value.
Why do we ignore effectively ignore this message if back pressured?
I would prefer not to use null ... just a empty set and then assert that its not null
mark this method private as this is only used in this class.
please move the isEmpty methods to the scimSchema
Does a straight comparison work here? NaN isn't usually equal to itself.
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
There is jenkins.util.Timer.get() for these sorts of things, I'm debating with myself if that one can handle once a second... It probably would I think.
Maybe make this "Initializing monitor for..." to distinguish between the init() and configure() method below.
Do we want to keep the method names like this or give it a more general name?
Same as above. Can also move this common block into a method of Function and use at many places
In the spirit of other functions should probably return null if the first arg is null
IllegalArgumentException for consistency, needs 2 _arguments_
Should this be delegating to a different method than encodeLink, above?
Stricter check. Given that this is in 3 places, is there a better method that we can override that would only require a single path check?
Should these two methods be public?
Looks like approach proposed in line 92 would help here too. The less code duplication, the better :)
store variable
Why asserting this?
use the interface here
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
You can probably use EntityPredicates.id(), which gives back Function<Identifiable, String> (rather than just for entities).
Using the error message in the metric could get really messy. These are arbitrary strings, and could be very long. For Error, we're using the error code-a _very_ different thing, since these are well known, and short. The exception type name is enough for Exceptions.
Won't this one get logged twice now? Is the policy never to log unless you are here?
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
Maybe a wider exception would be better idea here if anything rather than sql exception happens. Since we don't deal with the exception itself.
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
Might as well add a comma
Does this code check only the parent or any ancestor? Is it valid to check only the parent?
The value for this test in the develop branch is the correct value. Changing to this value is a bug.
It's sort of important that it was _Integer_.MAX_VALUE, as Long.MAX_VALUE wouldn't work. I'd prefer this stay explicit.
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
I think that if there is more than one stereotype on the annotation (which is allowed), then this will override the variable and you will only inspect one of them which is incorrect.
nit: suggestion if (HeaderParam.class.equals(annotation.annotationType())) {
This line sets the Item.image field which can be used instead of enabledImage.
Maybe use the getStorageId method here?
You are (presumably) removing this null check since you believe that it is no longer possible for an image to not have a sequence at this point. To be fair, you are largely correct. However, this might not always be the case (getSequence is not final, and can thus be overridden). Either make getSequence final _or_ leave this null check. (I would prefer the latter).
remove printlns before this is merged
change variable to something more meaningful
pvk should not be visible. Please remove it.
I see in this diff that count = DEFAULT_COUNT. I assume somewhere else in here it is binding the value provided in the properties file that could overwrite that?
do not assing parameter! nowhere!
remove line
Is it possible in a non-HBase environment to have a non-null bulkOptions but to not have set maxInflightRpcs? If so we might not have a valid value to pass through to ResourceLimiter.
Thank you ;)
Should we reduce the scope and do an earlier return if bulkOptions is null?
shall we add some message here?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
Oh, right, that was me. Sorry!
Likewise: can this be static? That said, I think it might be simpler to do inline at the call site: objIds.stream().map(ObjectId::name).collect(toList()); Or maybe we can make a custom matcher, something like hasObjectIds("4624442d68ee402a94364191085b77137618633e", "f900c8326a43303685c46b279b9f70411bff1a4b")
Not ImageJ style.
Remember to revert this file, it should know about the transport class.
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
here you discarded .xref class, are you sure that any javascript does not depend on this?
Please generate a random reqid code here and log it into the Perun logs. If there will be an error on IS side, they will tag that error with the reqid.
revert this string
Just seen this... Would it be more convenient for this method to be named assertPredicate? The current name seems to mean that it will perform arbitrary assertions...
please use "else if" since only one option can be valid at a time. Please also format the code according to the Eclipse coding standards.
maybe consider putting this check into a method
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
I guess null check is also will be nice to see here. Like java assertNotEquals(a, null); b.setDefinition(null); assertNotEquals(a, b); assertNotEquals(b, a);
Leaks an ObjectReader.
It would be good inline the logic of isConcatCall() here and use it to pull apart n into the bits you'll need and early exit if it turns out n isn't a concat call. Then the utility methods that do the work would take the pieces, which you could check the validity of with not-very-bright checkArgument() calls etc. This reduces redundant logic and improves readability. java Node calleeNode = checkNotNull(n.getFirstChild()); if (!calleeNode.isGetProp()) { return n; // not an array.concat() call } Node callTargetNode = calleeNode.getFirstChild(); String methodName = calleeNode.getLastChild().getString(); if (!"concat".equals(methodName) { return n; // not an array.concat() call } // etc.
nit: IR.var() just because it's shorter.
These two lines can be return values.getOrDefault( v, n );
/dataset/commons-lang/ will not pass the CI test since this repo is present just on your local machine right now and hence an error will be thrown on the CI server. Make it repogit4testv0 maybe.
Could you change this into assertEquals(expected, result) ?
Formatting issue
I think we should still allow it to blow up other tnt blocks, or else it isn't very fun.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
This this. should no longer be necessary here - could you please remove it?
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
I (still) don't understand why you're not calling tokenizer.skipInt() here (and below) If the caller called "skip...()", her intention is to skip, not read, right?
what is the intent of this function call? testGetLogSegmentsNotInJournal() seems to reduce this to the case tested in the previous function call.
Isn't it more standard to use getEngine() instead of using the maybiInitialize... return getEngine().contains ... Also I would make engine private instead of protected so as any plugin using it is changed to use getEngine()
this method can be made static
The previous code was more verbose but easier to read.
static import DataSize.Unit
Would it make sense to make this return the string, rather than assign it to the instance variable result. Longer term, perhaps we need a bind method like: IO<A> bindLeft(IO<A> io, F<A, IO<B>> f) which binds, but returns the a from the left argument. But this would be another issue. I would have to check the Haskell doc to see if this exists.
This side effect is striking since getter methods tend to not mutate state. It could also be surprising if one caller were to use this class, and then we add another caller that then calls getOffensiveAa and *that* would change the state in a way the first caller might not be expecting. Making the side-effect of setting the value of offensiveAa generally helps. IE:  offensiveAa = computeRemainingOffensiveAaUnits(); return offensiveAa;  That is still odd though, which makes me wonder if instead this problem would be solved by removing all side effects and instead calling the method something like computeRemainingOffensiveAaUnits(). In that case, any place where we call the getter and need those side effects, then we call the method instead. Perhaps this would lead to the offensiveAa variable to no longer be needed at all. What are your thoughts?
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
It would be nice to have these new methods unit tested. Also String#replaceFirst is calling Pattern.compile internally. Based on how often we're expected to call this method, wouldn't it make sense to pre-compile the pattern in private static final field of this class?
nit: you can merge both lines above as checkNotNull will return the given argument
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
Change this to just firstChildDataType.isCoercibleTo(PDataType.TIMESTAMP) as DATE & TIME are coercible to TIMESTAMP. Plus we have an UNSIGNED_TIMESTAMP.
First need to check 'elements' is not null and has at least one element
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
URL Decode would be necessary for parameter name and value
Don't need this - regionGuidePosts is either set in the other constructor or set in the readFields method.
Consider returning a constant
I would change the message to: "The resume() method was called more times than pause()."
Throw IllegalStateException is pauseDepth becomes negative.
Throw IllegalStateException if pauseDepth becomes negative.
I fail to understand what is going on here. The end action mode of the command is UPDATE_COMMAND_S TATUS_ONLY. But here you are not updating the command status but changing the end action mode to RUN_END_ACTION_METHOD. Also if the parent command endAction is being execute doesn't it mean the child command has completed execution and it the responsibility of the parent command to invoke endAction if necessary on the child commands.
nonexisting are two words. So, nonexisting -> nonExisting
why not with stream API? will be cleaner
Not sure, why not use @NotNull?
don't update fields in one object in the constructor of another object.
If these fields were configured macros, then config.fileSystemProperties will not be set in the constructor, you will have to set it in prepareRun in that case.
Can you make these final?
Lets return back previous version of this code since it was more compact; and basically exactly the same.
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
This code could also be written like the following, and then maybe the map in the superclass does not need to be made visible. java for(CacheType ct : CacheType.values()) { //not sure if values() is the correct enum method name ((LruBlockCache) getBlockCache(ct)).shutdown(); }
can this throw any exceptions?
HashMap should be good here I think.
I don't have strong preference here. - Shall protected or package-private enough here? - Or, on the other hand, with these two methods made to the public, we can avoid several test codes using INSTANCE_DN_KEY and RESOURCE_DN_KEY directly. Not a must in this PR, though.
I'm not sure what exactly append here :wink:, but it seems to me possible to generate the same synthetic name both if we call this function two times in the same millisecond. Why not use an increment based on Context like with closure and decorators synthetic names?
What do you think about moving the normalization logic to getUrlForPage(String pageName) ?
At this point, too, an AtomicReference does not bring any added value compared to a volatile variable.
Even though it's java there is no reason for trailing spaces
I think we should use leftOperandList.containsOnlyConstantAndParamNodes() here just to be consistent with the right.
do you need to check for nulls on paymentWorksNewVendorDetailDTO and paymentWorksNewVendorDetailDTO.getRequesting_company()?
return operatorsToDeploy.isEmpty() && operatorsToUndeploy.isEmpty();
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
naming
Double* variant of this class uses object == null ? null that is better
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
This should stay final
Should this method be final?
if we use address instead of null when creating an ActiveMQDestination, we ensure that the fields are always non-null and this method can just return name.toString()
As above, assertions the wrong way around?
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
To avoid clogging up the majority of tests, the authorization result could be a parameter in the "full" overload (the one where you provide a planner config, context, etc). Then the "basic" overload (sql, expectedQueries, expectedResults) would stay the same.
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
magic number
Is it possible to skip the mapToObj step, and specify the key and value directly in toMap? Creating a Pair object seems unnecessary.
ConcurrentHashMap might not be necessary in getValueAndReset(). This function is called every X seconds to sample the current metrics and export by Heron instance, so it is not called from multiple threads.
You can just get it instead of doing two map accesses, doesn't work? Same with below. java return (String) dataMap.get(key);
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
It seems that cfg.isClientMode() can be used there.
Let's refactor this to cfg.setClientMode(igniteInstanceName.startsWith("client"));
@ILikeToNguyen Why the change in visibility here?
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
I would change the text to say "The encryption algorithm is not strong enough."
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
0 is a legitimate option value for min. selectable choices. Why not -1?
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
So this would leave the View in an inconsistent state with the Presenter? Should you not show an error in the View that the value was wrong? Or default to a valid value and update the View? etc
Likewise..
Likewise..
there's formatting issues here
Is it thread safe to access the mCompleterMap here?
Lists.newArrayList
nit: this is a filter function, might be better to use filter replicaIds.stream().filter(r -> replicaAndState.get(r) == state && (dcName == null || r.getDataNodeId().getDatacenterName().equals(dcName))).collect(Collections.toList());
This can be a stream - filter - collect expression.
Use LinkedHashSet instead of ArrayList.
I prefer using Preconditions.checkArgument over asserts (at least for cheap things), since the former will always run and catch issues that might crash at any point early even in production (IIRC assert is disabled there by default).
Original code does not have these increased bounds? also, spaces
I would remove the else and just return.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
In the page, projects are sorted by a comparator, so that projects.get(0) may look as a randomly chosen project. The same problem was solved in NewApplicationWizardModel.getDefaultProject() by applying the comparator.
any particular reason why this method doesn't require an IJavaProject ?
Is it possible/problematic here when the member is force set to the same effective time it currently has?
you can put these two lines in a @Before setup method so that you don't need to repeat that for every test.
2 Log statements
The coverage is not the only important thing in a unit test. Notice that the getValue method is **100%** covered, however, I could change it to this: java @Override public String getValue() { view.getValue(); return "Wrong value!!!"; }  ..and the test testGetValue would still pass. We need to **really** test the logic of the method. See the following unit test (now, it really tests the method and breaks when the logic changes): java @Test public void testGetValue() { final String expectedValue = "value"; when(view.getValue()).thenReturn(expectedValue); final String actualValue = dateSelector.getValue(); assertEquals(expectedValue, actualValue); }
?? why this and the following ones could be left empty?
Would it make sense to add something this.caches.clear() to the stop ?
you didn't use methodName here, is it intended?
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
What I'm missing here is the check if the element is null. I know that the probability is very low, but still...
Please replace the following 2 lines with return failCanDoAction(VdcBllMessages.HOT_PLUG_IS_NOT_SUPPORTED);
that check is not needed anymore as osrepository reflects the support per architecture and version.
shouldnt it return !(getConfig)?
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
This could be made static
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
Instead of assign and return, just return the last statement.
Remove this "if" statement. That said, here are a few things for future reference: 1. You use "is[Level]Enabled" to check that specific level (e.g., if you're going to log trace, you'd check "isTraceEnabled()", not "isDebugEnabled"). 2. There is no "isErrorEnabled" -- unless you disable logging altogether, it's always enabled. I suppose you could use "isEnabledFor(Level.ERROR)", but you'd only be checking if logging is on at all. 3. As a rule of thumb, unless the logging operation is extremely heavy (e.g., transforming a large object for the trace logs), you don't want to check if "Info" level or lower are enabled, only higher (debug, trace).
suggestion
Let's keep the boxing as is please and focus this PR on the new API. If you want to go through the whole code base and consistently use one boxing style that's a different PR IMO. But: I prefer to know when boxing and unboxing takes place since it is not free; this gives the compiler the opportunity to flag unintentional boxing and unboxing and let the programmer decide that's really what should happen.
... remove the final modifier from the method. It will be easier for future tests.
Here and below: previously the code used only one table lookup operation, not it performs two lookups. Please consider to use get(name) and check the value to decide if it is illegal or not.
Missing types
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Can you please revert this file. It will cause bunch of conflicts with my changes.
This is super silly. Never do this and read about java string pool. Just hit java string pool in google and you will see a lot of articles.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Thanks, can we also give a test case for Join relational expression ?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
Maybe check for if name ends with ':' so we don't do a double one?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
return null to make this more explicit ?
I agree to Robin's proposal
Who uses CR as a line delimiter nowadays?
Wrong way round.
Didn't we use the JLS suggested modifier order all the time? I would prefer to keep a consistent order in the framework.
Change the / to java.io.File.separator.
Maybe its an idea to distinguish more precisely between whats an exception because value is a filename string and when its possibly a malformed JSON string?
Minor: since locateMember has been renamed to locateMainArtifact, maybe downloadMember should be renamed, too?
Nit: You should check the return value of mkdirs and throw eventually.
Won't this logic always execute if the path doesn't exist? What is the point of the previous if?
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
macOs implementation is pending
please add sync protection, see EngineLocalConfig.
Is it really worth checking before setting it?
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
It's a good update
Could we please use <LINK_0> ?
I would say that we don't need to have one more method here, we probably can just move  ArchetypeOutput archetypeOutput = DtoFactory.newDto(ArchetypeOutput.class); archetypeOutput.setOutput(event.getOutput()); archetypeOutput.setState(event.getState()); endpointIds.forEach(it -> transmitter.newRequest() .endpointId(it) .methodName(MAVEN_ARCHETYPE_CHANEL_OUTPUT) .paramsAsDto(archetypeOutput) .sendAndSkipResult());  here or did I miss the reason that stands by this decision?
It's hard to see why one would care about having a stored value that's not current, and indeed it seems that this method is only used in ImmutableComputableGraph::statusToString, which is never used.
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
No space after ! (several occurrences). Anyway you should use StringUtils.isEmpty instead.
What if values.length is longer than COEFFICIENTS.length?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
We're on Java 8, so: IntStream.range(start, start+length).toArray()
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
Return ImmutableSpongeListValue<Text> not ImmutableSpongeValue.
you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...
Use RS_MAINTAINER instead of ALLOC_MAINTAINER ?
LIR == OrgType.getFor(originalObject.getValueForAttribute(AttributeType.ORG_TYPE)) is a bit cleaner..?
return Collections.emptyList();
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
I think we don't use 'final' in this place anymore.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
Could you check for null or empty? Via StringUtils.isBlank
Should we not _only_ create that timer once (per plugin/api we need to instrument) ?
Can be simplified, use assertNull instead.
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
If you make the outer a proper class, it can implement Disposable and dispose() can call cancel() on the field inner.
This should throw an UnsupportedOperationException instead of a RuntimeException. Also, standardize the error message with the other UOEs throughout this package.
I think you should put the volume id in parentheses after the volume name
This is changing the batch directory name. This shouldn't be changed. Only the filenames need to be changed.
These catch code blocks seem to be very repetitive, should they be factored out into a utility function/lambda?
throw exception
Why the change? This now creates a temporary collection just to stream it.
Only the first row should be explicitly typed; the rest can benefit from type inference. Alternatively, use method reference here, e.g. InstructorFeedbackResultsResponseRow::get*.
(Rather than a bunch of IF statements, you could do this all as one return statement w/ && for above.)
equals & hashCode can be generated in eclipse
Use a constant for this path.
Move String values used more then once to a constant.
Move String values used more then once to a constant.
Why setting Token or MID imply sent = false ?
Please keep this.cell near the related fields (previousFamily & cell count) below
Don't we need topic for correlation? I see IMqttToken has getTopics(). Or is messageId so unique, that there is no reason to get deal with delivered topic?
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
Should be- setTitle(text.asString()) not setText.
style nit: we don't use braces around single line blocks
This one seems too broad
We don't need to merge internalExchangeInfo and exchangeInfo. Remove the merge from WebserviceProxy, ExchangeManagerHelper and all related code.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Recommend to use ToStringBuilder
Recommend to use ToStringBuilder
suggestion return getClass().getName() + " [policy=" + this.policy + "]";
return Collections.emptyList();
You don't need this line because of green 31.
If I am understanding this correctly, If you convert both "from" and "to" their corresponding snapMillis, you dont have to do this logic right? You dont have to do it. Just wondering.
The last assert is different from the first 2
I'd rather be more defensive concerning "positions" map, for example: int posA = positions.containsKey(a) ? positions.get(a) : undefinedPosition; int posB = positions.containsKey(b) ? positions.get(b) : undefinedPosition; Also, shouldn't we compare "A vs. B" instead of "B vs. A" so that items with lower position are considered "before" items with higher positions? int posDelta = Integer.signum(posA - posB); In above code, "undefinedPosition" is similar to null item, so it could be Integer.MIN_VALUE (null first) or Integer.MAX_VALUE (null last).
I don't think this equals test is necessary
Is there a more specific exception that can be caught?
thrown.expecteMessage(). minor thing, i am fine with this.
If you want to keep the long variable name for the Statement arg then please wrap this line to make it readable:  ExpectException expectException = new ExpectException( statementThrowingAssumptionViolatedException, AssumptionViolatedException.class);  But I really prefer delegate or delegateStatement because that is what the role of the Statement is for the sut. The variable is declared one line up, so the long name isn't needed and makes the code harder to scan IMHO.
minor: could you add disabledReplicas as well?
Just some concern for security: should we output user/pass here?
Please put @Override on the standalone line
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
suggestion thrown.expect(containsCause(new ValidationException("Option 'csv.quote-character' must be a Character.")));
Please check the exception message too. If the expected message is nested in the stack, you can use org.apache.flink.core.testutils.FlinkMatchers#containsCause util.
please see the contract of Map.entrySet(): by invoking put() during the iteration the result is undefined.
Detail: FROM capitalized.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
why need this (I notice the encoded=true in all query methods)? if need it, why loss it in write method on 333 line?
add this selector to UI mapping at the beginning
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Why is this necessary?
Expand this a little, verify event request fields
Looks like you didn't use the plugin to generate these test methods
- log warning that option is not supported by SNMP
Should we add: Objects.requireNonNull(record)?
Based on how it's used, it's more like a listener not callback.
the return type could be tightened to OGCPoint
please check if list is empty instead
This should be >
I don't think this should be public; or even be a method.
please use a capital 'U' in 'Touse' to make it more readable :)
I know this is a test, but we should still make sure to release the jedis resource when we're done with it
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
Instead of instantiation via string name, we could pass the class name here and use reflection to load the dialect like a plugin.
Why not reuse existing? public static Type valueOfIgnoreCase(String name) { if (name != null) { return valueOf(name.toUpperCase()); } throw new IllegalArgumentException("Invalid value null"); }
Style issue: @Override shuld be on line above the method declaration
invokeAll on an empty list returns null. So you may want to handle that
null? why not just a () -> {} ?
can be inlined
If url params change order, this could create a false negative. I think the .equals method of Uri could help to insulate from param order: <LINK_0>
It's a good idea to run your tests before submitting them to Gerrit.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Add PageLogging
Is this conversion really necessary? The SUT does not involve an array at all.
unused
Don't need last else
Can you pull this out into a property?
Why don't you do this at the end of the running phase?
Missing opening "(" before getDescription().
I must be missing something; I don't understand how the above change would make any difference performance-wise. Was this change made to be more readable, rather than to improve performance?
Could you check for null or empty? Via StringUtils.isBlank
Symmetry (throw)?
Use Strings.isNumeric
NPE if header missing.
use artifact.getAttributeById(attrUuid, includeDeleted)
why did this swap places?
Catch exception.
Also too many dots
Why do you need the non primitive class check?
:bug: code style
You probably could reduce it to return type.isPrimitive() || Number.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type) || Char.class.isAssignableFrom(type)); (PrimitiveTypes is not really needed in this case).
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
If these values can never be null they should be stored in int not Integer.
IMO while would be better here
I have noticed a few occurrences of catch (Exception e). According to <LINK_0> we should catch the most specific type we can. Can we catch more specific exceptions here?
please replase MojoExecutionException for a new generic DeploymentExecutionException
Should not be this thread daemon?
It is not necessary to test REPLICATE region in this test.
this should be a ERROR level message
I am not sure if this alogrithm here works as expected. The JVM would choose the most specific constructor, but we choose the first matching. This can cause some trouble that is hard to detect. Assume we have two String arguments and get constructor's in this order: 1. MyClass(Object a, Object b) 2. MyClass(String a, String b) Since String is an instance of Object we would choose the first constructor, whereas the JVM would choose the second. This should be fixed!
Can you reuse the scan variable? That will save connection time for every request.
This can blow up logs. Might be better to enable at TRACE level instead.
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
Lets create constants for these strings
We only want our specific OutputFormat to disable caching, not everything else in Hadoop. So we shouldn't set this here, but only in the OutputFormat when we get a new FileSystem object.
will throw NPE?
return null to make this more explicit ?
unfortunately we still string translate these. :-(
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
return tags;
Could we return an empty map instead of null so this method doesn't have to be @Nullable?
I think we will have to discuss whether or not to include the fromKafka functions in this class.
Add stack trace to exception.
do we use anything else but RuntimeException?
Should not log under warn after testing for isInfoEnabled (or isDebugEnabled). Always log at the same level as if test. simply replace both with a single if (logger.isWarnEnabled() { logger.warn(...., ex); } (See JMS AMLC)
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
is there a specific reason for returning null? can you return an empty Email object instead?
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
seems like a string that should be stored as a constant and defined only at the side who returns this message to prevent breaking this assumption - unless it isn't doable
If someone wants two \n, this code will swallow one. Please remove the above and add a \n in the String.format line below, as it replaces a println()
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
We may also want to cancel our subscription.
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
This constructor seems redundant with the one above. Do we have any special need for it, aside from not having to specify survey? I'm concerned that if we update this class, we'd have to update 2 constructors instead of one. At the very least, we should make this constructor call this(label, activityType, ref, null) to avoid duplicate instantiation code.
could you call this(property, flags, data, null) ?
please remove or decrease log level to TRACE
I suppose this is where only an unsubscribe should happen, just disconnecting the remote source, but leaving the internal state intact. The actual "removal" (=local unsubscription) can actually wait till the next phase (OUTBOUND_COMMAND_OR_QUERY_CONNECTORS in this case). This would allow for commands already in transit to still be processed, rather than cutting those off.
Follow setUp().
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
The original code was there to demonstrate the syntax, even though all paths are locked down by default. I think you still need to permit everything but /restricted for this example to work properly. I will double check as a UAT step.
Can we delete AADAuthenticationFilter if we only want to test groupCount?
should it not pass true as third parameter? the definition of createExecutableExpression conveys that
Why are you keeping the conversion-less method?
Missing types
.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?
IOUtils already checks for null...
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
Do not use e.printStackTrace(). Log the exception. > this.logger.severe( e.getMessage()); > this.logger.finest( Utils.writeException( e ));
No key for encryption? ;-)
Need to implement
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
Could use a StringBuilder.
Delimit for-loop body with braces as per our code style
Minor nitpicking, as I've recently being removing the use of "unnecessary helpers": when you know already that "value" is not null, there is no reason to use the StringHelper. Just go with ((String) value).isEmpty() ?
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
Please remove isEmpty() check. Null check should be removed too, but the comparisons should be made null-proof.
This is apparently out of date.
Same thing about calculateInvocationTime
Thanks for the notice. I'll have a look.
I think we have an instanceMainWithExit Oops, that's in picard-public - but perhaps it should be in htsjdk?
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Typo: Ant**P**atchersPathVariablesCa**mm**elCaseVariables should be Ant**M**atchersPathVariablesCa**m**elCaseVariables
These tests might be a bit brittle since they depend on how the writer is verifying the existence of the header. If the tests did: java String value = new String("value"); this.response.setHeader(CONTENT_SECURITY_POLICY_HEADER, value); this.writer.writeHeaders(this.request, this.response); assertThat(this.response.getHeader(CONTENT_SECURITY_POLICY_HEADER)).isSameAs(value);  Then it would verify regardless of the way the writer implemented the check.
Can this be private, or is there another use case for default attribute outside the builder's call?
@gaurabdg interesting approach, but can we store this depth inside object to avoid unnecessary calculations
Why do you include the size of the binding set as part of the hash code?
maybe we can use the container here
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
use createTempFile
Why not declare GLOBAL_ID as a long?
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
We can add a checkNotNull here.
If VM's custom compatibility version is set, cluster's compatibility version is ignored. That means we don't need to display any warning, because nothing was changed for the VM.
why not to compare with the standard java way for enum comparison (== VMStatus.Suspended) ? and don't you need to check whether it is different than Suspended?
you can't get here with vm == null, so it should be removed from here.
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
@droneboost use the activity parameter instead of calling the getActivity() method.
Is it okay to only checkForDecideUpdates() in onActivityResumed()? I think with the current logic, only one call is necessary now since we register the listeners.
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
indentation is not right here
same as above with the actionBarWrapper
Check if KEY_MEASUREMENT_FILTER_ID for specific measurement filter is present in request parameters. If present set value from request parameters, otherwise don't set...
omit: Initialing...
The function name in these log messages should be updated
createCache simply
Honestly, I haven't seen TIMESTAMP(0) in BigQuery
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
It crashes because lastSearchedText is null on first launch. check for isEmpty?
Please make check for NPE before call refresh() method.
why sticky?
Lets use super.cleanUpUsingRest() here
Lets have the cleanUp() at the end as a practice
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
What does the constant mean?
If we try to create an Entity with the default values, why do we initialize it with a custom version?
maybe drop this print to minimize test spam
This shouldn't be synchronized, as nothing else in MetricRegistry uses this lock.
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
"name cannot be null"
Do we need this to be public?
See RFC7159: Adding one (charset) really has no effect on compliant recipients. @asoldano, @ronsigal WDYT about this?
What about the other forms of this? meta name=charset value=, and meta htt-equiv contenttype? There's code in DataUtils for that, should be able to reuse.
Should this not be by.css as well?
can we move By.className("og-close") to PostsCreatorDesktop to make things and selectors consistent?
This can be a class variable instead, using the @FindBy annotation; especially since this same element is used in another method.
KFSConstants has a constant for a single-space string if you want to use that here instead.
@pwillworth why not use File#separatorChar ?
What if fileName doesn't have any .?
Hi @mderamos, Add code to check if value is not null before using substring.
this and m_ is redundant
not sure if this is needed but we should check if lot is null in case that it is nullable in ims_transaction...
I think can just indent 8 spaces from [t]his
java this.onPostServerTick(this.getMinecraftServerInstance());
What event is being waited for here?
Why do you omit SecurityException e in the caused by chain?
I suggest including the uri in the exception message
should we return generic domain in such a case?
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement may execute just a tiny bit quicker as Enum comparisons are sped up by the compiler. Other than that this is looking good to go!
consider extracting local variables, this is hard to read, or early exit
another thing that seems like it could be handled by a map?
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
Suggest requesting the child monitor unconditionally at the start of the for loop. Then you won't need the "else" branch: for (int i = 0; i < ...) { SubMonitor iterationMonitor = subMonitor.newChild(1); if (foo) { resource.touch(iterationMonitor); } }
May be you do not need another submonitor conversion here?
Could you maybe look if this could be removed? I mean the new DefaultVariableNameFunction().apply(this). It's already handled in the other constructor.
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
combine with assignment this.outputType = requireNonNull(type, "type is required");
Shouldn't this be < instead? if the end of the time range of this request is before the time range that has been updated in the traceRangeUpdated signal handler?
extract to cte
Even though it's java there is no reason for trailing spaces
This can be static.
Do you need to use the "text" constant?
This could be null, we should probably handle this if the JIRA api changes again
use namespace instead of DEFAULT
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Do we really want the LocationDefinition to generate the id if null is passed in? That will hide some programming errors. If we really want it, better to overload the constructor to have a version without the id parameter.
You should test for both instructor and student?
Why are you accessing courseId from instructor?
Can correct the typo accessable since you are changing the code
Is this really needed? Is there a more deterministic way of waiting?
Is it possible to get rid of this?
Is this really needed here and in the next state-change methods?
setErrorMessage
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Remove entire wrapper finally block
can u extract a final constant with a readable name out of "<[ ]*/[ ]*%s[ ]*>" ?
Please do so.
Looks like you are making double slashes here...
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
will VDSM's settings be equivalent to set "<on_reboot>destroy</on_reboot>" in the domain xml?
do we always want to set in run-once? for example, I think about the following case: 1. define headless VM 2. run it once with a console for installing it 3. the installer reboots the machine during the installation process at this point, it is debateable whether the VM should be started with its run-once configuration (for instance, maybe the user is required to provide some input like window's timezone and user accounts after the initial reboot) or with its regular configuration. maybe this should be configurable in the run-once dialog..
Let's add a couple more here to increase code coverage -- maybe one in which there's no label, and another in which there are no options?  {r echo=TRUE} {r thisisalabel}
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
Style-nit: I'd prefer dropping the curly braces, but I'll submit this as-is.
isn't used...so perhaps do not set?
final?
move 5 and 1000 to variables. Its used in so many places
timeout exception
same - use timeout exception
Can we inject this feature directly ?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
To note potential further benefit of a value object, a value object for bonus type could encapsulate this logic and remove redundancy, eg: if(rule.getBonusType().isOldArtilleryRule())
Do we really need to check anything here? Surely the enterprise edition supports all constraints?
Should this also set engine to null in a finally block? If not, I'm not sure why it checks for null (line 177).
I see this method does something similar to execute minus the optional processing with the rowProcessor
....and then you don't need to call it on every other method
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
this and m_ is redundant
Using Builder pattern is preferred since the structure can be easily changed.
not sure if this is needed but we should check if lot is null in case that it is nullable in ims_transaction...
You forgot this!
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
Map
You want to use assertEquals instead?
You may want to use assertEquals directly?
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
this mapping should happen via public enum and not via mapping backend enum to string
It's a step in the right direction, but it would be best to be uniform with the rest of the application. For full uniformity: 1) Maintain GlusterStatus.java enum in the API, and map Backend values to it. 2) Instead of status string, use the 'Status' object (I didn't mention this before) The easiest way is to follow an existing example. For example, see this from VmMapper: model.setStatus(StatusUtils.create(map(entity.getstatus(), null))); 1) Backend VM status is mapped to a rest-api status (an enum) 2) The enum is sent to StatusUtils.create() which creates a 'Status' object 3) The 'Status' object is set in the rest-api entity (and later the entity is returned) Note that this woule require changing in api.xsd, for GlusterBrick: <xs:element name="state" type="xs:string" minOccurs="0" maxOccurs="1"/> to: <xs:element name="state" type="Status" minOccurs="0" maxOccurs="1"/> And for uniformity, best also make this change to GlusterVolume state.
please make this upper case
calling endAction here is dangerous, I don't think we have it anywhere else. it is problematic because the execute phase was not finished and there is all the infra in CommandBase that handles it. Please call endSuccessfully directly instead (and need to verify that the 'log' method is called)
I prefer a different approach that would comply better with the commands framework - not to disable the auditing here
I think its better to if (isCopyPerms()) { execInTX -> save quota copy perms } else { save quota } and remove the check for isCopy... in copyQuota method
No new line. You can actually drop the whole else if and only keep the mVersion check as early abort. getVersion() should never return null this would lead to unforseen behavior of the other methods. It actually can never return null as we can never reach this if mPkgInfo is null (Constructor would crash).
Here, you can simply call the other constructor: this(Integer.MIN_VALUE, Integer.MAX_VALUE);
Interesting... Just return null here?
You can use assertEquals here as well.
Based on how it's used, it's more like a listener not callback.
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
can be inlined into a single line by using Streams
please see the contract of Map.entrySet(): by invoking put() during the iteration the result is undefined.
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
why not final Iterator<CompareInputAdapter> candidates = Iterators.filter(node.eAdapters().iterator(), CompareInputAdadpter.class); It will avoids create an intermediate iterable (see Iterables.filter implementation)
Rename this variable
Even shorter:  return Collections.unmodifiableList(responseExceptionMappers .stream() .map(ProviderInfo::getProvider) .sorted(new ResponseExceptionMapperComparator()) .collect(Collectors.toList()));
This may be a reasonably common return value so error logging isn't appropriate. I think perhaps we should make this method return boolean (and return false if the update fails), and just do debug level logging here.
Oh dear, I'm sorry, there's a change in it that I made for testing. Could you please undo it?
It'd be safer to use [remove(Object, Object)](<LINK_0>,%20java.lang.Object)) here
~1 minute & ~3 minutes respectively?
Same as above, this can be written as  java serverWeightTaskTimerInterval = clientConfig.get(WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY, DEFAULT_TIMER_INTERVAL);
you can also test for number of attributes.
Very minor, but our code style conventions are to have a space after if and before the (
Should it be an error to call this method if you can't actually get the result set? Feels like it strongly indicates misuse / coding error.
I can't remember, is there some protection to make sure names are unique
Is order important here? Should the 2 collections correlate each to another?
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Local variable could be declared List instead of ArrayList. Is this worth caching?
Should return the empty list, not null
Collection<? extends ITmfEventField> fields = getContent().getFields(); if (index < 0 || index >= fields.size()) { return ""; //$NON-NLS-1$ } return Iterables.get(fields, index).getValue().toString();
My personal preference is always to throw an exception if you're out of bounds.
do {   } while (current == null) is more natural here.
let's call it updateCodeMinings() instead.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
The aforementioned "never return null" rule would be good for all the string getters here.
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
Actually, I'd recommend initializing principals using Collections.singletonList(SimplePrincipal.newInstance(username)). The resulting list is immutable and an efficient implementation.
Why not? Or it just doesn't support it _yet_ since there's no need?
use UnsupportedOperationException
In the original bitrate_bps is a pointer. I don't know how it should be handled here (since it is currently not used)
It could use the string constructor instead which already has that behaviour (not much advantage in providing a utility method for that IMO).
Missing codes.
Consider returning a constant
Other places in this module handle buffer == null.
Fold the CAS op in the if, no need to the local var here.
Could we add a check on the OS actually being Windows before looping like this?
Will * <LINK_0> * <LINK_1> work as well?
you can either remove else or add pair of curly brackets
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
@ptirador I mean it should be like this: java this.of(coordinates).buildPublishJson(); return getPackagePath();
Is there a specific reason to use this threadpool rather than the default one provided by the single argument overload of this method?
<LINK_0> Let me know if you have any issues managing or adding items to the project
tracef
can be info
you need something like: recoveryXids = new Xid[1]; recoveryXids[0] = xid; in here. As this class is serializable it will be saved in the basic action during save_state. Don't forget to remove the Xid after commit is called.
nit: this definition looks really awkward
Would prefer to rename this to afterCheckpoint for symmetry. This would require deprecating the existing API, but it would make the interface cleaner.
Do these methods actually get used? If not, then maybe throw UnsupportedOperationException instead. Then, if someone tries to use them, there will quickly be an exception thrown.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
are you sure we need to use OSString ?
AFAIK it would be good to shutdown the executor when it isn't needed.
So are you going to calculate all imports to remove right in EDT? Don't you think it's not really efficient?
I think this should be in a finally block in case the runnable throws.
Overriding is quiet hard now that the method is private ;-)
This should be used and check the ORGANIZATION_WQP_URL.
@ILikeToNguyen Why the change in visibility here?
Would prefer this to call getVersion(), rather than the deprecated getVersionFromStatic().
Let's make this private and introduce two factory methods known(String, UUID) and empty()
I am not so sure that creating a couple of static fields is the best approach here...
are you sure you want to search for translated tags only, don't you think it could be better to search for the tags value and the translated tags ?
static?
nit: move Pattern.compile("all", CASE_INSENSITIVE) into a static variable to avoid re-compiling on each call
Should we add: Objects.requireNonNull(record)?
You don't need to have this condition as there's just a loop doing nothing if filters is empty.
I guess I am a little uncomfortable with the use of checked exceptions here. This exception goes down through the request manager and (I think) tells us whether a user is admin OR SequencerServiceRecord that is being sent through is null. Since we don't attempt to recover and exceptions get logged anyways we have really done nothing useful with this exception. Here are some other ideas... ###### Options include: - Not throwing the exceptions in the first place and just doing the logging. - Throwing _RuntimeException_ instead so you don't have to bother catching and you get the logging for free. - Attempting some sort of recovery if this exception is caught (forward to 404 / 400 page). Personally I'm all about checking the inputs in the API before they ever make it to request manager. I think they call it _sanitizing your inputs_. That way you don't even try to save if things don't look right, you can just redirect to a friendly "Nope 404 / 400" page. It's a better user experience I think.
Why the switch statement? I propose: if (action == null) { throw new NullPointerException(); } setDeny(action == Action.DENY);
Why we want to fall through into the loading dialog in case of error?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
return Collections.emptyList();
You're not making defensive copies of the Set, how do you know that it's immutable?
I don't see the api for CosmosContianer (sync version). could you please add that too.
unsafeSubscribe shouldn't call the ERROR_HANDLER.
@jrdalpra we also need negative test cases here like e.g. it is still not allowed
there is the new UncheckedIOException
ImmutableMap.copyOf()
suggestion this.extraMetaData = Collections.unmodifiableMap(Objects.requireNonNull(extraMetaData, "extraMetaData cannot be null"));
I would tend to make the first two Preconditions.checkState (they're not arguments to this function) and the latter two as is. Also, put the field name in the call (like Objects.requireNonNull(schema "schema");) in order to give some insight into the problem without looking at the source?
is this tear down necessary? the next setup overwrites anyway, doesn't it?
Not necessary. See quality rule : MITRE, CWE-397 - Declaration of Throws for Generic Exception
Don't you need a super.tearDown() call here at the end?
Objects.requireNonNull
We'd want to use Collections.unmodifiableList() here also with null check
Load and termination parameters should belong to Load and Termination entities
I this refactoring, very nice. Could make this method protected.
No need to change this; just an FYI. We put in quite a few of these early in AS7 days, but they can be just an assert delegate != null; If this is null it's a programming error, not a mistake in user input.
It seems like defaultMessageConverter is not needed when constructing this with the provided converter. Might be use a boolean field instead, so setBeanClassLoader works only if default converter?
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
I was thinking you could remove the buffer.reset(), because the next line is dropping the reference to buffer anyway.
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
This class should abstract the client from the underlying connection, returning a Response forces the client to deal with it.
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Use static imports
Do not add the check here. Add the check just for dateuploaded.
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
Another place where the name should probably be updated
executionOrder++ increments after use, which changes the previous behaviour. Are u sure this is what you want?
this.notify() would be consistent with L63.
both filtering methods should also be abstracted I believe. edit: by both I mean this one and the one above. the only difference being && or ||.
This function is presuming that the method caller is verifying "messages" is not null prior to being called which is ok for these changes as that is happening but if this private method is used elsewhere in this class in the future that may pose an issue.
Consider ordering this up one method to group public methods.
Is there reason for throws Exception in signature?
this test is identical to hash_value_blank()
Would it make sense to add something this.caches.clear() to the stop ?
When the view is closed you need to stop the build thread
Have a Semaphore that guards this method call (make sure to release the permit in a finally block)
Please move this method and patternIsEnabled to the end of the class, similar to PassCodeManager class
we don't need to change the Creation classes.
iiuc, the AddGlusterWebhookInternal is responsible to deny the request if the action isn't supported. This is blocked by the can-do-action and not going to be recorded anywhere (maybe only by the validation failure message to log) and as for any failure during the execution of the AddGlusterWebhookInternal command: The AddGlusterWebhookInternal command is responsible for creating events log if it fails, so no need to record it in this context. Shouldn't the result of AddGlusterWebhookInternal affect the execution of initGlusterHost() ? meaning, if initGlusterPeerProcess(vds); fails, should there be an attempt to execute the AddGlusterWebhookInternal ?
Same nit as above.
please also call the vdsNonOperational event (you can see how this is done in the virtMonitoringStrategy
same here as well - on failure to stop vdo service, activate and move host to original status
but there's no reason to change this method now, no?
super.getVm() will do dao call...
Spelling
Maybe the first escape key press could dismiss the menu, but not revert the field? So in total there would be 3 possible uses for the key.
assertThat(gosecSsoUtils.userName).equals("anyUser");
call notFound
Do these need to be static?
I think I prefer "Invalid key" as exception message
Unnecessary parentheses (and an extra line break).
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
FWIW we tend to use Identifiers.makeRandomId(/* length */ 8) instead of UUID -- no big reason but it makes for more easily distinguishable identifiers, shorter and more chars
java.util.Collections.singletonList() should be prefered for singleton list. (always a better practice to rely on JDK classes rather than libs).
Collections.singletonList
Better to use Collections.singletonList rather than guava for this.
Oh yuck. ;)
Update labels to go with method names. Alternately, call super.toString for super attributes
Why do we print a secret systemUserPassword here?
Can we define a final CONSTANT for the MD5 ?
Can be static.
How about adding "java = undefined; javax = undefined; Java = undefined; load = undefined; redpenToBeBound = undefined;"); to this section, instead of introducing appllySandbox method and UnconfinedScript?
Stream closing?
Let's change this to Logger.error(this, "Invalid PDF File", e); as part of a future CR
Make this AtomicBoolean
static import?
Whatever else the virtues of this PR (and a test proving what it fixes would be desirable), the removal of the call to processWorkspaceBeforeDeletion means it is causing _some_ regression.
Please use !string.isEmpty().
this.url = checkNotNull(url, "url");
I this this(url,new HashSet<>()); would better. What do you say?
<LINK_0>
Shouldn't we use, or instead of nor ?
This is still wrong for HTTPS. S3Proxy has both a getPort and getSecurePort accessor. You should probably just create this URI once after s3Proxy.build().
Same here: should be Branding, not ProductBranding
does this have to be a list or can it be an iterable?
Argument should only contain _incomingTimeColumn?
I think, one of -c, --column or --columns is missing from here
These 2 can be called just once.
this check should be removed now
This should be replaced with a guard method.
I would rather store the response in the cache when we are sure it parses correctly.
Usually you need to validate the relay state on the way back so you'd need to save this value somehow. Is that not true in this case for logout?
Better way to do this using slf4j: <LINK_0>
add brackets to make this expression more easy to understand
Just skimming through the RFC, looks like what we can do there is send back SINGLE_PAIR_REQUIRED. Looks like the only case where we'd get multiple TS ranges (at the moment) is when it is created as part of the larval SA: Top of Page 45: If the initiator didn't generate its request based on the packet, but (for example) upon startup, there would not be the very specific first Traffic Selectors helping the responder to select the correct range. There would be no way for the responder to determine which pair of addresses should be included in this tunnel, and it would have to make a guess or reject the request with a SINGLE_PAIR_REQUIRED Notify message. Overall, as the client, we should never send a request that triggers a new SA creation, as that implies that there is an authoritative IKE daemon to handle the SA creation request.
you don't want to check that images are legal and exist?
This actually could be return !isEmpty(triggerId) || !isEmpty(triggerIds);
Can we use Locker from Weft here?
rename to element
this can be replaced by getGroups().forEach(group -> cache.flushGroup(group));
rename to breakpointRequest
rename to breakpointRequest
Not an exception
better to cast to string instead of using toString()
better to cast to string instead of using toString() .
If we test the public interfaces, can we keep the implementation package-local?
do we care to check the length to be positive here?
How about using % with args instead of +? Same below.
As I suggested in another patch, we should consider having a version for persistAsyncTaskPlaceHolder with one argument (parentCommand) which by default uses a DEFAULT_TASK_KEY. Same goes for getTaskIdForTaskKey - we should have a "getTaskIdMethod". This is not mandatory, it's a suggestion.
I think you missed a {}
I think the below is better to avoid an extra lookup on the map.  taskAppenderatorMap.computeIfAbsent(taskId, myTaskId -> new ArrayList<>()).add(appenderator);
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Put ITEM in front of OTHER_FUNCTION
why? for debugging purposes? sure, but don't keep it in testsuite by default it just messes up with CI servers
This test uses the same jboss-all_fine.xml file as FineWebFailoverTestCase.java, what about using a new one for covering the reference to an existing server profile from a jboss-all.xml file? (at present we have it from distributable-web.xml file in testsuite/integration/clustering/src/test/java/org/jboss/as/test/clustering/cluster/web/persistence/distributable-web.xml)
why changing it to static?
Can this be private, or is there another use case for default attribute outside the builder's call?
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
_sigh_
this method should be changed to private
this method should be changed to private
nit, Collections.EMPTY_MAP?
might be useful to print it, no?
vmNames
just wondering, what force means here?
Will this have any effect to legacy data (i.e. those existing before this PR)?
Since the event is really a resource rather than a model, it would make sense to me for this to return the event resource instead. You can get back to the model in other places if needed by calling .getModel() on the resource.
Can we use key format that is consistent with table configuration items format?
I would add mcast-port=0 as a default
Let's just fix the OS by default. The default location should be configured by the jclouds *Implicit Location Supplier*. The default hardware is, by default, the smallest one.
Ccan we default to a more modern version?
are these setters used anywhere?
Please make the constructor private (see Invalid).
No need for super()
At the very least, extract '(CreateImageTemplateParameters)getParameters().getImagesParameters().get(0)).getVmId());" to its own method...
there's an issue here - when running the vm as stateful, we'll get to this else block (as there's no stateless snapshot) and will detach the user although everything went fine. generally speaking, i think that in this flow we can inspect the result of RunVm instead of running the endAction() from here (Example - <LINK_0>
why do it again? already done in line 54
nitpick: tab
Could be a try-with-resources.
Should we add null check?
listeners are not notified?
Why that new close() can't do this for us, too?
Also there do not use Privilege Exception.
I would rather choose to have a while loop to implement this rather than a recursive call (call stack can grow quite big unecessarily because of this call depending on the level of nesting of the file) and moreover, I believe a while loop would be more readable.
style nit: remove curly brackets
Sorry forgot to mention to change the read to access here too
Empty line, also it could be better with more fields (use your ide toString generator).
Would be better to return "JDBC:" + dialectName.
Can you make all of the accessors final?
this can be 'long' instead of 'Long'
The empty string in the constructor is redundant.
I think, this should be wrapped inside if (!newEntries.isEmpty()) and then inside no check for firstEntry == null. Then firstEntry is not required any more.
use more descriptive names
Make it consistent with other two.
Since this is a verification we should probably use any(CacheLoaderWriter.class) to ensure the loader writer is not null.
Please use style instead of getStyle(), as this is more consistent with the rest of the code base. I.e.: if ((style & SWT.HORIZONTAL) != 0)
You could instantiate a Point here and use width/height. Like: new Point(width, height). Then if gtk>3.20, update the x/y value. Savings: 3 lines of code
paranoia: can we first set it to false, and *after* that call GTK.gtk_widget_queue_draw(widget);
Use "guid" instead of "asGuid(id)".
And then else if this
I think that this check makes more sense in the "getClusterId" method. Can we move it there?
Namespace prefix 'p:' should not be hard coded. This will generate some false positives if the namespace definition does not use 'p:', for example: xml <beans xmlns:x="<LINK_0>"> <bean class="org.springframework.jms.listener.DefaultMessageListenerContainer" x:acceptMessagesWhileStopping="true"></bean> </beans>
These asserts are unreachable
It might not always be a lambda - someone could implement their own concrete flow.define(). We should check bean.getClass().isAnonymousClass if needed, but I suspect we don't need to know whether it's a lambda or not.
@ekondrashev Here too, let's use throws Exception as per our [coding standards](www.yegor256.com/2014/04/27/typical-mistakes-in-java-code.html#test-method-names).
@ekondrashev Same here, let's declare Exception being thrown.
@ekondrashev Let's declare throws Exception as per our [coding standards](www.yegor256.com/2014/04/27/typical-mistakes-in-java-code.html#test-method-names).
-1 since the interpreter is only used with JMX now.
probably it is better to change it to  String columnName; if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) { columnName = propertyAuditingData.getExplicitModifiedFlagName(); } else { columnName = propertyAuditingData.getModifiedFlagName(); }
This can be private again.
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
nit: you can merge both lines above as checkNotNull will return the given argument
Would it be possible for a key to be null? Do we need to add a check for that?
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
4 spaces
shouldn't you return templates?
This way it won't return any VMs unless unregister param is provided, no good...
Migratable is enough.
Why not public access?
Super minor, but I'd probably just call this IDENTIFIER from within the class rather than use a qualified reference.
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
Why dashes instead of dots?
Doesn't String.format need a value to be formatted?
in this case I think return isRunning() ? this.ssl ? "https" : "http" : null; reads cleaner
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
It still needs some kind of fingerprint identifier in the message, e.g. just its ID/hash
add prefix to "About to invoke" message too
Should we add null check?
suggestion Objects.requireNonNull(in, "InputStream cannot be null");
Now it's not compatible with the write method. Revert this one too.
Why do we need those lines? Unit tests are still green if I remove them.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
there's formatting issues here
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Should be a SamzaException with a message, not NPE.
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
We could stochastically test it.
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Why does start() effectively do nothing?
why are the throws on the next line?
can't be null?
Maybe IOException since it's supported here?
for the case where the file is being thrown away (abort is called rather than commit) we could get away with not calling force. (that is the ATF.commit could call a force method which does a flush, force, and then subsequently call close)
Possible NPE with calling contains on artifact.getName() ? Better checking for nullity before calling .contains
The Class objects can be compared directly with ==.
throw exception or log some error message here to indicate the error
final float sleepDuration = (int) ((double)  feels odd.
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
can these parameters be grouped into smaller and more meaningful objects?
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Ik. Maven has logging facilities. We should use them.
local variable e is never used.
Yes, it shouldn't be cached in memory.
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
null? why not just a () -> {} ?
...this change really doesn't make sense. > Changed off screen limit for unlocks to 1(on unlock it was 2 and once activity open it would report usage of all 3 fragments, so to add little more accuracy I moved to 1 off screen as on SoldierStats) Are you really considering to give the user a WORSE experience, just so that we can get a bit more accurate analytics? I for one would rather get analytics with a known misrepresentation (all three fragments) than a random misreprentation. Example in your current implementation: 1. User opens unlocks 1.1. Fragment A and B are downloaded (A=1,B=1) 2. User scrolls to fragment B 2.1. Fragment C is downloaded (A=1, B=1, C=1) 3. User scrolls to fragment C 3.1. Fragment A is cleared (A=1, B=1, C=1) 4. User scrolls to fragment B 4.1. Fragment A is downloaded (A=2, B=1, C=1) 5. User scrolls to fragment C because he forgot something 5.1. Fragment A is unloaded (A=2, B=1, C=1) 6. User scrolls to fragment B again 6.1. Fragment A is downloaded again, third time now (A=3, B=1, C=1) So, basically, what that would generate would be... three hits for A, one for B and one for C. How is that more accurate? If we load all fragments at the same time, we get one for each, which is a more viable representation. I'm just trying to make sure that we don't do stuff that makes the app worse for the users (and the experience). For example, I would rather look into if we can use the ViewPager "hooks" and send a "trigger" once we switch to a given fragment. That way, if we go from A -> B -> C -> B -> C, we'll instead notice that the user used fragment B and C twice, and A once. This seems both possible and more useful to me, instead of causing people to re-download information just because we're doing it wrong. :+1: @peter-budo
Suggested getClass().hashCode() as something "more random"
could this be 8? the size of a char?
return id;
what if quota object is set?
in this case I think return isRunning() ? this.ssl ? "https" : "http" : null; reads cleaner
I would prefer not to use null ... just a empty set and then assert that its not null
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
It can/should be private (and remove @Restricted(NoExternalUse.class)).
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
I think a good old for loop is more readable for (int i = 0; i < size; i++) less concise but easier to understand (to me at least)
Does it have to be public? Couldn't it be package visible only?
Needs to be @Implements with an @Intrinsic
This will need a null check done to make sure the default is returned if the field isn't set (i.e. is null). See getEscapeUnderscores for an example although obviously the default return will be different :)
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
please test the value presented in the above example also:  java assertThat(sumOfFactorialDigits(10)).isEqualTo(3 + 6 + 2 + 8 + 8 + 0 + 0);
Don't we want to keep this?
I was wondering about a situation when isVaultExpression returns true (value is in the form of ${vault.xyz}) and we are unable to transcribe the value from the vault. Should we somehow notify users this situation happen? I think in the majority of cases this will be caused by a wrongly configured vault (maybe a typo in vault id, etc.). The result of this would be for example _unable to connect to the SMTP server (wrong password)_, which is actually not the root cause. Maybe we can somehow let users know that this is actually caused by vault configuration. Does it make sense?
can jsonAsString ever be null, seems like you create a PhoenixJson object you it will always have be from a string
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
lets cache interruptor instance. If JIT leaves double de-reference inside the loop - its bad
why using StringUtils, while we can use String.startWith()? Manifests.read() never returns null
we don't need to override this method from ExternalResource anymore
I think it is unnecessary to use synchronized here
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
so why is this an error and not a warning? Since the system proceeds without giving up, I think it should be a warning
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
What about items and label?
I think you need to add a null check; code in SourceFile assumes content can be null
Has to be public? Can't be package private?
we should return immutable list. You only expect caller to do read operations, right? #Closed
Couldn't you just return a String and if null is returned it was success anything else is an error
It's better if you could make a function like getStringWithFormFieldId(String formFiledId). You could call the function getStringWithFormFieldId("clientID"); getStringWithFormFieldId(clientSecret);, ....
Be careful of nullable fields!
Be careful of nullable fields!
Wouldn't it be better to redirect the user to wondergem root in this case? I seems to me that this triggers a user being logged out instantly.
In order to not make this a breaking change this method should still actually clear the data.
Should we call that method getUserStoreNames() instead?
If these values can never be null they should be stored in int not Integer.
Probably it should just return false
According to the current way how those methods are implemented, it should be return false
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
unnecessary null check
This line should be "new POSConfigurator().getConfig( new ResourceManager( configFile ) )" -- this way, the user only needs to specify non-default values in the config.
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
factory must close its cursor (which is closeable)
?? why this and the following ones could be left empty?
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
Returning 0 or 1 is not exactly a good way to estimate the progress of the algorithm. Can you come up with a better way?
Please implement toString() to provide debugging state information for debugging purposes.
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
Is it intended to not compare the size of the stack here? (FluidStack doesn't take size into account normally for equals, though it does for hashCode)
Is this meant to compare the item stacks beyond object equality, given ItemStack does not override equals *or* hashCode
- [x] I think you should wait page loading only when execute script that click button. How are you think?
you can remove this
there is no need to execute initElements method, when you're extending BasePageObject
The local var is useless, you can remove it.
Rather than instantiating the view here, I think you should just pass it to the [DatasetSourceTarget constructor](<LINK_0> That way we keep the number of places where views are instantiated to a minimum because we always want to push that as late as possible. For example, support for handleExisting will probably push that until when the job is being committed.
I guess that we should not change the behavior of the method. Because Config class is widely used within the project and it may be also used in users side. (Users can create their customized DigdagServer by using DigdagEmbed class) I hope fixing in bq_load operator or adding another method to Config class like getOptionalFromNullable().
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
getLastSibling == parent.getLastChild(), no reason for new method here.
ofNullable maybe, no?
the ofNullable makes no sense because you called profile.getId() on it at the beginning of the method: if it was null we wouldn't have arrived here in the code. The profile parameter is meant to be non-null.
This is not necessary as it is null by default.
It seems updating the delegateAvailable every time this is invoked would be remedy the issue of having another timer task?
Can simplify to return reading || (!writing && isSimpleSourceType());
Can simplify to... return writing || (!reading && isSimpleTargetType());
The error message doesn't match the actual behaviour.
unrelated change, if this is a problem, please raise another Issue/PR
Unsupported type:
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
out of curiosity: what meaningful exception could possibly be thrown here ?
Don't we have to say that this is uniqueId JDBC?
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
nit, Collections.EMPTY_MAP?
Same here for doing empty check instead of non null check.
Alternatively... java Properties properties = new Properties(); if (inputStream != null) { properties.load(inputStream); } return properties;
I think we should putAll() the defaults - a common java developer error is to use get() instead of getProperty() on a Properties object. Only getProperty() looks for the defaults if not found.
does setBrickPosition do something different than brickPosition in all other brick tests? if not, please rename to brickPosition
position is not necessary, just add them in the order you want to have them there: startScript.addBrick(new SetVariableBrick()); startScript.addBrick(new AddItemToUserListBrick());
please no abbreviations in variable names. give it some meaningful name
Why do you need to check for null here but not at the other queries above? I think it is better to change 0 : result into 0d : result for readability
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Same as for iOS, please handle this as an exception, not as a valid runtime value.
It would be good that user can resize the dialog box. If you do that set also a minimum size.
lambda?
final
I have some concerns about this. 1. Wouldn't this make crashlytics run in debug mode as well? The old Crashlytics didn't "ignore" things in debug, but we definitely don't want them reported. That was why it was in the if...else in LoggerStarter. 2. The reason for crash logging to be initialized in LoggerStarter is b/c if the content provider is accessed through a Context which is not ours (like if we export our data), then our Application does not get launched so crashes would not get reported to us. LoggerStarter is initialized in the content provider, which circumvents this limitation. 3. Does this create a Twitter singleton that we keep around for the lifetime of our app? If so, that seems like a waste of memory since we only use it for the login stuff and even then only for vendors who actually use twitter.
This can also be if-check for debug builds, otherwise, it prints a lot of failure logs in the logcat.
I think it would be good to factor out more methods here like initializeTimber/initializeJobManager etc. It might be strange to create separate methods for those one line initializations so it's ok to keep them in one method.
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
Restore the spaces.
Better: new String[fExtensionErrorParsers.size()]
substring(0, 7) why 7? please avoid magic numbers
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
you don't need the check for null here
Can we form a proper sentence there? Also I was wondering whether it would be helpful from audience side to distinguish the null and the empty case (moving it to a separate checkArgument).
Should this be marked as deprecated as it is in Page?
this variable may make more sense just as itag given it isn't only for items.
Let's change it to get the child commands CommandEntity rather then the CommandBase, it's slimmer (doesn't require to build all the command objects) and contains all the data you use in the calling class.
SINGLE_THREAD_FOR_AUTOBATCHER?
let's make a meaningful constant for 5
how will the futureList be cleaned up ? That one keeps growing in size with completed futures ?
-1 just noticed now: forgot about skipExec here. This must also be handled, otherwise it will be ignored now.
JDBC
do the comparison the other way around
I'm thinking that we should make this protected so that it can't be inadvertently called unless the subclass explicitly makes it public and provides the right Simple annotations.
I don't see any references to this setter, can you restore this class? This class is meant to be constructed with the appropriate values on creation. Maybe a properties file could support different serial settings, such as used in: /romraider/src/main/java/com/romraider/logger/external/apsx/plugin/ApsxDataSource.java
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
Same as JDBC implementation, select the smallest globalIndex for an event on or after given date. Subtract one from the result to ensure first event is included in the openStream
This is essentially one line of code, I'd prefer to inline this.
currentRemoteHostId ?
I don't understand that this line is saying.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
the ConnectorTopology.NONE is one of the supported connectors of the this component. So i don't understand this filter here.
This method should probably be synchronized.
You set B0 twice (see PRED_commit_author_3).
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
UnsupportedOperationException would be better
The agg function here should be adjusted to support the optional compression param like in the quantile version
As is the case for the UMLDiffExtensionPostProcessor, this creates a totally useless post-processor. Change the call so that it reflects the plugin.xml declaration : super(Pattern.compile("<LINK_0>\d.\d.\d/notation"), null);
A post-processor with neither NsURI nor resourceURI is totally useless; which makes this constructor a very misleading implementation. It'll basically create a post-processor which only use is to occupy memory and time (when we loop over it). This is the "UML" post-processor, and we already have a default contribution with an hard-coded URI in the plugin.xml. We can set a more sensible default NsURI than that. Change the call to super(Pattern.compile("<LINK_0>\d.0.0/UML"), null) ... or remove this constructor altogether.
Why are we keeping notfound = null? Won't it be null without this?
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
please validate ledger id
Usually a notify without any flag will have strange race problem... At least let's have a 'triggerRefresh' flag to guard redundant notification?
Maybe we should cache the BluetoothManager in onCreate instead of the BluetoothAdapter. Or both.
I think we are missing the indicate property here; we are adding the CCC descriptor below.
Does 0b01000 work here?
It probably makes sense to set up a timer to get some metrics about the download times. Similar to: <LINK_0>
should the message include "command _with options_:" + this.options ?
Typo: Ant**P**atchersPathVariablesCa**mm**elCaseVariables should be Ant**M**atchersPathVariablesCa**m**elCaseVariables
These triggers should have a type retrievable from the generic type that does not require comparison to the interrface
You should annotate parameter with @Nullable , or if you don't need to handle null argument, you don't need ofNullable
Message may be null, add a guard check
suggestion moveSequences.add(new ArrayList<>());
Are the last two lines of this test necessary? Let's go ahead and remove any unnecessary lines of code.
final
I'd prefer Assertions.assertThat(connectionPoolFactory).isInstanceOf(OkHttpClientConnectionPoolFactory.class). That way, if it fails, we have a decent message :-)
For proper testability, should these also be listed in hasService()? ...or have we just been passing this test because we run it on the right kinds of devices?
There should be an assertion I believe ;) assertTrue(conflicting.contains(...)); And probably alos useful to check that model.di and model.notation are not in conflicting state in the git repo?
I think it is better to do that on the code calling it, and in the getter.
I know the method is invoked only from 'plugToExternalNetwork', but to make it complete I would check 'getNetwork' is not 'null' and 'is external'.
if getExternalNetwork() returns null, you'll end up with NPE.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
Nit: merge this with the if above.
No need for getInstance(), the container can be passed
public?
I'm missing the new field in the toString method.
yuk! a System.out! Either remove or use a slf4j logger here
the inner if clause is not necessary because Boolean.parseBoolean can handle null or empty strings
Remove this if block. We can move check for instance HasNewPresentation  into below if.
I think this can be private. Also it seems that its only use immediately makes an ImmutableList, so maybe it'd be better for this method to just return an ImmutableList.
could this be private? RTR doesn't have subclasses as far as I know
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
@dalifreire this doesn't throw IOException anymore now, you're just creating a stream on a Strings bytes :)
what if result is null?
Could use a StringReader instead of a ByteArrayInputStream here.
It is permitted, but discouraged as a matter of style, to redundantly specify the public and/or abstract modifier for a method declared in an interface.  <LINK_0>
no qualifier?
wouldn't it be more flexible to allow to set the authenticated flag instead of always returning true in the MockEndpoint?
this debug is redundant
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Should the message be returned here or the original value?
Remove new line.
Tabs
I would recommend an else if here to avoid comparing against a string unnecessarily.
please use org.apache.commons.lang.StringUtils IsBlank()
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
@adietish we should consider throwing here/providing an indication that the path doesnt exist. If the path doesnt exist for a given property then it needs to be added to the map IMO.
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
Can this be private, or is there another use case for default attribute outside the builder's call?
nitpick: don't need keyword public
@garg-anuj Yeah doing that only.
return Collections.emptyList();
does it need to consider Windows?
I think you want to specify the encoding explicitly here.
Use .substring(1) so that we don't have to allocate a new String instance.
Should we maybe wrap other throwables in a RuntimeException here? Or throw a new RuntimeException? Seems inadvisable to just ignore an error. Someone who's already using this might see an AggregateException with no causes.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Collections.emptyList()
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
The core version doesn't actually process capabilities, but I can't think of a reason it shouldn't. A JIRA should probably be filed to enable it. Also we should process the attributes too.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
I think we can reuse GWTDateConverter java static String format(final Date value) { return GWTDateConverter.getInstance().format(value); }
Please have a default value (unknown-development?)
Please use a instance-variable for the version, this way we can configure it for each service instance separately. Also extend the service-descritor to support the version-field (and add a default-value)
This input stream is not closed. We should follow a standard try-finally pattern for closing the input stream. With java 7, you could also do the try-with-resources pattern, but I don't think hraven requires java 7, so that's out of the question.
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
should be "*notconfigured-it.war" Double check the folder because not sure how this passed.
similar to above; fix this so it actually tests something or at least does not fail.
you will want to fix this, or else the test will always fail.
Move String values used more then once to a constant.
Move String values used more then once to a constant.
Use a constant for this path.
Label should be reporting.parameter.onOrAfter
This location parameter should be renamed as in other methods I think
The labels for these date parameters are wrong. They should reflect the parameter names (eg. reporting.parameter.startedOnOrAfter"
nit: you could also move all the setUpServerChannel() calls
These two checks seem unrelated to the actual check you want to perform.
why does this test need to change ?
That's good to know.
Make sure to return a read-only version of the List (not set) here. We don't want people to think this is the method to register interceptors.
return Collections.emptyList();
Map
You forgot this!
Optimization? putAll should not be expensive if there's nothing to put...
UnlockImage is performed anyway, so it can just be removed out of the if-else.
detach?
probably a good idea to catch an EngineException (thrown by runVdsCommand) here, and log.
please use NotImplementedException()
please use NotImplementedException()
please use NotImplementedException()
I think in these cases, assertTrue() and assertFalse() would work better. It's quite a long read now :) Please consider.
Should the 3 contains be replaced by isEqualTo ?
suggestion assertThat(got).contains("Description");
why final?
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
use MAX_SIZE
HashMap should be good here I think.
IMHO it does not need to be public
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
this method deserves a description
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
Should be if (app != null) Entities.destroyAll(app.getManagementContext())
combine these two lines -> OwApplicability app = artifact.getAppId();
I would ignore empty notifications and would log warning.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
'em.persist(member);' should be enough, you only need to wrap the EntityManager when needing to access methods which are not exposed on the JPA API.
So, this seems a really long way to get from event to orders. Go via SoldProduct, thanks to @martijnjanssen
I also can't understand it, but now result is always empty. will try to debug it.
You can use Layout.INVALID_CLUSTER_ID
We try to prefer these to be the proper enum for the getter/setter methods, with the translation of char<->enum hidden inside of the getter/setter methods. That way we store the smaller char in the database, but application code isn't exposed to the database's insane char based storage.
Better to use CharArrayUtils.EMPTY_CHAR_ARRAY
No longer throws AliasServiceException
There must be a more succinct way of doing this using streams.
nit, Collections.EMPTY_MAP?
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Use the solution in the large Overall/Manage PR instead, please.
Better revert.
From what I see this call may happen when Jenkins instance is null and when the jobs are not fully loaded. It would be better to handle this cases explicitly
diff - source.readInt() == 1 ? true : false + source.readInt() == 1
Assign the return of getUserProvidedIdentifier() to a local variable, otherwise it has to be built twice.
Assert.notNull()
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
rename to segment
Please put spaces around :
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
Use Iterators.transform from Guava?
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
Let's rewrite it with the regular F.iterator F.iterator(dataSupplier.apply(filter), rowFunc::apply, true);?
Use same order as the field declarations.
As is the case for the UMLDiffExtensionPostProcessor, this creates a totally useless post-processor. Change the call so that it reflects the plugin.xml declaration : super(Pattern.compile("<LINK_0>\d.\d.\d/notation"), null);
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
As discussed before you can use WorkbenchContext for this
Doesn't this also trigger on Byte, Short and Long rather than Integer?
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Is there any reason to do that here rather than encapsulate the logic in the constructor of NewExternalSubnetModel? Especially when as far as I can see, it has to be called whenever the dialog is instantiated.
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
what if you get an exception before doing the inc. Would it be better to test <=0 instead of ==0 (and reset it to 1 in that case instead of a simple inc?) or maybe check if it's <0 after the decrement and reset to 0?
ArrayList is non thread safe. We should use a CopyOnWriteArrayList
suggestion this.dataStoreMap = new IdentityHashMap<>();
Which type would be assigned in this case?
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
I suggest to drop this conditional, type cannot be null (unless I'm wrong :-)
This method can be static, as all the methods it calls.
catch IOException and rethrow to avoid wrapping an IOException with an IOException
Use Logger or remove try-catch and throw IOException
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
If shouldSchedule() and shouldRun() are overridden, the if is not necessary here.
You can use ValidationUtils.nonNull for this.
The metatype file says this value has a minimum value of 1. Should we be enforcing that here?
Looks like the ListRejectAttributeChecker could be used here instead.
I think we want to use DiscardAttributeChecker.UNDEFINED here (and for other version transformations), since a value of true should result in rejection.
Pass in true for the second param (discardUndefined), and remove the undefined model node from the values
System.out.format instead?
But existing rows use null not "" for the parentUuid.
Symmetry (throw)?
Are there any const that can be used instead of duplicating strings like this?
Move to update please. < layout
Careful with float comparison. Although minor accuracy issues isn't a big deal here.
attr.length() doesn't do anything here, you can remove it.
This is unsafe, since attributeType is protected and can be set to null, but the contract is to return supplier only on non null values. This must be rewritten to check for the null value first.
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
you shouldn't need it as UnknownUserException extends LoginException
Should this be DOMAIN_CORE, or DOMAIN_TARIFF_SWITCHING?
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
this.
This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.
can be replaced with method reference: java .map(Response::getValue);
same here as well :)
Maybe check for if name ends with ':' so we don't do a double one?
They are mutually exclusive? Or is that a micro optimization?
unfortunately we still string translate these. :-(
suggestion private <A extends Annotation> Optional<A> getAnnotation(Class<A> annotationClass) {  Avoids the "suspicious call" warning on annotations.get.
You should use the annotations field here too, not the wrapped reference.
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
you shouldn't need it as UnknownUserException extends LoginException
Please log the bundle ID here.
Same here, would be better to leave it on the previous line
One minor suggestion. Make this a private final variable, and create the runnable once. Then return the variable instead. The outcome is the same, with the advantage of not creating an object every tick.
What about the previous mImageReader instance ? It should be closed when detached .
Should this return Flux.error instead of throwing?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
I think try with resources should be used.
firstDigitsCardNumber is already a String
Why can't you just return value here?
@dalifreire is this enough? What e.g about class name?
Are you sure this is right? Please double check.
This is not thread safe. Either use a local variable, or make the method synchronized (the same way as dispose(), getNext(), etc...). The same problem can happen with getHostId(), getCallSite(String, long), getEnvironment(), etc... It needs a class-wide review of the use of fTrace.
I think the test might be more robust if the bounds were read before indexing the trace explicitly.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
something is wong with the indentation, please fix.
Does this also require a null check similar to setcontentType() ?
suggestion "Migration: %s must have only one runnable step from state: %s", id, status.getState())); // NOSONAR
@dmzaytsev let's inline this
This code is duplicated with formatFileName(). How about extracting this String.format() to a private method and calling it from formatFileName() and formatPlainTextFileName()?
nit: line to long (break each parameter in it's own line)
needs check for stats == null
Although this is not a part of your pull request, this toString() method looks overly complicated.
I don't like it. For me it should be very simple:  return "ExpressionEvaluatingSelector for: [" + this.expressionString + "]";  The compiler optimizes it to the StringBuilder
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
Can use @Test(expected = ...), see above.
We can simplify this test method this way:  @Test public void testRollupModeEnabledShouldNotFail() throws Exception { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.ROLLUP_MODE, "true"); String[] args = new String[0]; BluefloodServiceStarter.main(args); }
Please keep this.cell near the related fields (previousFamily & cell count) below
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
Should those hashcodes be hardcoded ? They depend on HashCodeBuilder.toHashCode() implementation.
Only test it is a new instance. Maybe it should test other rules of clone contract ? Maybe assertTrue(jdbcRuntimeInfo.equals(clone)) ? <LINK_0>
...so don't pass the "intial hashcode" into location.hashCode(...) but instead mix the various hash codes yourself here. Guava Objects.hashCode() can help.
I am not following here - why do we want this in sync block?
no!
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
final
Format? action=insight-absent insight=bed-light-duration reason=timezone-offset-absent account_id={}
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
Ok if already stopped? idempotent?
Add a proper log message.
Would it make sense to add something this.caches.clear() to the stop ?
Better to organise this in a double empty try-with-resources idiom: java try (Closeable ignore = level1; Closeable ignore2 = level2) { // Just for closing }  To delegate boilerplate exception and suppression handling to the Java construct. If it appears unnatural, you could extract this in a utility method, e. g. called  void closeBoth(Closeable, Closeable) throws IOException
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
We need to close the reader here, right?
Why is the call to trim() necessary? If it's necessary, I would move it to the client.
Put the string in a constant
please extract key as constant
Might be worth having a displayName?
Nice2have: make it localizable
Should this be "Upstream Committers"? Also, it might be good to move this to a Messages.properties file so it can be translated.
Even if core.worktree wasn't set in the configuration file, it might have been set by the caller of Repository. We have like 8 forms of our constructor that takes various arguments... one of those is the work tree path, which could have come from an environment variable.
With all of the logic in the constructor, I wonder if we can simplify this method down to: public boolean isBare() { return workDir == null; }
We might want to actually make isRebasing() a method in RepositoryState.
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
All of this can be replaced with an ExecutorService
Should we also have the same tests for the email template?
Don't you need to add the Hibernate-managed StudyType before saving?
this ternary will not behave as stated in the 1. should annotation
call _loadTaskLogs_?
Please replace 2 + 1 with 3.
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
I am wondering if the error handling is ok, we used to use the  return ResponseUtil.mapExceptionResponse(e);
This can be replaced by Logger.debug(this, () -> String.format("listing languages %s", request.getRequestURI())); Using the supplier avoids the string creation when the logger is not in debug mode
Can be simplified:  private String getTemplateDirectory(String template) { String templateDirectoryName = infrastructure.toString().toLowerCase(); if (infrastructure == k8s){ templateDirectoryName = k8s.toString().toLowerCase(); } return format("/templates/factory/%s/%s", templateDirectoryName, template);
Is it OK that case is "k8s" but infrastructure which using is "openshift"?
If someone adds a new autosizing config, then it might not be obvious to remember to update this method, especially since it is a couple hundred lines away from the config key declaration. Here are a couple suggestions that might help: 1. Create a new enum class in which each autosizing config is a value in the enum. Then, you could use Enum.values() to create a set of autosizing configs. This is nice, because someone only needs to add the enum value, and then the code automatically picks it up. 2. Create a static Set of autosizing keys, and then declare that set as a static variable right next to where you declare the autosizing constants. There is still a chance of forgetting to update the set, but it's at least close in proximity to the declarations. 3. Change the implementation of this method to check that the config key matches a prefix (e.g. job.autosizing). It's "convention"-y, but then no one will need to update this implementation as long as they follow the prefix pattern.
We need to get out of the habit of returning null when bad things happen. It's a SUPER bad practice. ANd it leads to exactly this kind of defensive null checking that clutters up code is distracting.
The value here is null right? If so why we try to print the value? I think it should say Empty userID. Also, can we use StringUtils?
@wisogetnid why are you removing this block?
You have to configure formatter in IntelliJ
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. Code snippet for if condition be as follows: if (wrapper.waitForReplay) { Thread.sleep(100); continue; }
I think this is a bit too long of an if statement.
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
return Status.BACKUP_FINISHED.equals(status) || Status.RESTORE_FINISHED.equals(status);
return status != null && status.equals("ON"); is correct and sufficient
log.trace if at all
this method deserves a description
In order to be more consistent, the _Preconditions.checkNotNull(key );_ method could be used instead.
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
No key for encryption? ;-)
nit: probably it ll be better to throw exception here, in order to avoid anyone silently calling this.
You could probably use the same URL as in getResultById here.
Could return a Collections.singletonMap(key, list)
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
what will assignmentId be? Why does this change?
Fix the method name with impl$ prefix.
As mentioned above, why don't we making it a non-static method?
Same idea about exposing EPSILON and 1e-8 here (if not, should rename EPSILON to something more specific to this method).
use ShellIsAvailable
use ShellIsAvailable
use ShellIsAvailable(this)
throws
nit: throws for consistency and clarity.
throws
Maybe we should use ordinal and values()[offset] instead of writing the entire name? And actually do you find the Externalizer for enums, are they worth it still?
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
the topologyId is written/read in the ReplicableCommandExternalizer. no need to write/read it again.
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
This method needs to enhance. I mean If the first if is true, then the code bellow is always false. Also I think System.out.print("null"); should be replaced with some log.
I can't remember our usage paradigm here, but I believe if the value is not null, we should use an assertion that the value is indeed a Map. Otherwise the caller of this method is probably trying to do something wrong (i.e. expecting a map when the property is not a map), which would be a bug and should be fixed.
URL Encode
![MAJOR](<LINK_0> Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_1>
Is this a method to be used in production? Or is it more for developing/debugging purposes? If the latter, we could create the webrequestMap HashMap within this method instead making it a field in the object. It would be slower for tests because we'd have to recreate it with every print, but would be a lot lighter for production (I guess the heap and garbage collector would feel it, given that we create a WebrequestData object for each web request). Also, it's likely that for each webrequest we do only 1 print, right? In that case, speed would be the same. Also, being annoying :P, I agree that we do not need the {"webrequest": <json>} wrapper, just the json object will be fine, no?
Shouldn't be here a warning log and in else branch the actual code - setNotificationService(notificationService.get()); ?
If we are not using java 8 Optional here, maybe we can consider doing this: String taskShutDownVal = get(TASK_SHUTDOWN_MS); if (null == taskShutDownVal) { ... } else { ...} It is a minor thing (so optional for change :)), but the pattern in the old way will call get() function twice in most of the cases. I believe this get() is light, but it may be heavy in other cases. So I would suggest to consider to always make only one call as a best practice.
use static import.
you could use a newly added utility to get the color based on the state color to avoid "white on yellow": Color stateColor = gc.getBackground(); gc.setForeground(Utils.getDistinctColor(stateColor.getRGB()));
Would it make sense to print a label saying no data to chart as opposed to leaving the graph empty or do feel the user should look at the data list?
typo?
clusterVersion can never be null - if there is no cluster (which is not likely to happen), then 3.0 is returned by ClusterUtils#getCompatibilityVersion so 124-126 is redundant - can be removed
I find it more readable as: if (vmCustomCompatibilityVersion != null) { return vmCustomCompatibilityVersion; } if (vdsGroupCompatibilityVersion != null) { return vdsGroupCompatibilityVersion; } return defaultVersion; please consider
Should this return null if version is not a valid OSGI version?
In UserPortal, TabModelProvider#getCommonModel always returns null because UserPortal's ApplicationInit doesn't call CommonModelManager#init at all - there's no CommonModel instance in UserPortal. This could be refactored into something like this: if (hasModel() && handleItemsChangedEvent()) { ... } with new method in TabModelProvider: /** * Returns {@code true} if the associated model instance is available to this model provider. */ protected boolean hasModel() { return getCommonModel() != null && getModel() != null; } with UserPortal-specific override in UserPortalDataBoundModelProvider: @Override protected boolean hasModel() { // Don't call super, there's no CommonModel in UserPortal return getModel() != null; }
You probably want to disable some view components in the event of a failure!?
I think this method can be final with addition of extra "hook" (overridable) method to register handlers: public final void setEventBus(EventBus eventBus) { this.eventBus = eventBus; if (eventBus != null) { registerHandlers(); } else { unregisterHandlers(); } } /** * Override this method to register custom event handlers as necessary. */ protected void registerHandlers() { // No-op, override as necessary }
change to List
Default size not necessary.
This empty check can be removed if you add one element to values in the constructor.
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
Why is it public?
This is standard procedure in our existing registries. :+1:
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
Every time we change a JSON test using JSONPath a cute kitten is born.
Above I had asked about whether we need to validate at least one answer is provided. Could we better describe this use case where we can search licenses *without* giving any answers? Is this to lookup the types of answers allowed? If so, we should enhance this test to check the response includes info on the types of answers alllowed.
java postRunTasks = null; return Mono.empty();
Why add ignoreElements()? Is this more or less similar to the sync implementation?
Why are you blocking here? this should be async throughout.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Can't we just set without compare?
@overquota Should not #close do #closeConnection and #shutdown do #shutdownConnection?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
The raw data shouldn't be removed here. The raw data is allowed to contain invalid routing data.
I don't think you need to worry about the case you're describing. MSD makes the assumption that the root path already exists.
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
pvk should not be visible. Please remove it.
Method should be synchronized probably?
Please remove system.out.println and add assertion
unnecessary array new: {{true}, {false}} should work here
Isn't it also important that adType was async and method was top?
why both DataProviders have the same article's names inside?
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
unused try catch block
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Map.put already returns the previous value, so this can be simplified.  public int setExtraData(int index, Vector3i pos, int value) { extendExtraDataTo(index); Integer prevValue = extraData.get(index).put(pos, value); return (prevValue != null) ? prevValue : 0; }
Formatting
If metadata was not already 0, the old bits are not cleared. Also metaData should be range checked (or just & 0xF'd).
that class would be better with a builder, though I wouldn't ask changing it now
Looks ugly and potentially a source of future NPEs.
can we define this explicitly as a constant?
suggestion return Objects.equals(this.getName(), actionParameter.getName());  The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getName() returns null the previous implementation would crash
Please change to this.getVal() == that.getVal(). This will reduce the number of throwaway return objects (TaintedBooleanWithObjTag) that we are creating - any call to an instrumented method (like Objects.equals) from Phosphor code will result in a new one of these things being made. Please also add wrappers for equals and hashCode for each of the appropriate modes (for int, one that returns TaintedBooleanWithIntTag, for obj, one that returns TaintedBooleanWithObjTag, and also one for obj that *also* takes a ControlTaintTagStack).
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
suggestion timer = getMetrics().timer("file-read");
I think ex should be rethrown in else.
could we check this without throwing an exception?
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
whitespace/style
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
This is no place to update a cached member. Either do it properly or don't do it at all.
Why make this an ArrayList explicitly? Wouldn't it make the code more flexible to leave it as a List?
You can just use getVmsDiskPluggedTo()
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
use createTempFile
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
docIds.size() > 0 -> !docIds.isEmpty()
!isEmpty ?
This is the same as the condition above... is this correct? Actually, I think this is why your last song would never play.
if (!isConnected()) { return; }
Should we add return here?
Loader can be hided twice <LINK_0> and <LINK_1> What does happened if call hide method in loader twice?
Why are you using an Iterator instead of a for loop?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Why?
please use {}
Please keep annotations on separate line :-) I suggest to use Java 7 utils for easier computation: if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ValidationResult that = (ValidationResult) o; return Objects.equals(success, that.success) && Objects.equals(reasons, that.reasons);
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
Why using empty string as first argument?
something is wong with the indentation, please fix.
Maybe we can extract out the always blocking filter; would be more readable.
This should be "test-client-id", and is simpler anyway when I eliminate ClientIdentification.
can builder even be null? if not, it is just getSslBuilder().build(), or in-line it.
Could we extract this logic into a separate class? I'm worried that the BuildView is doing quite a few things already.
Actually the underlying objectExpr could have free variables.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Don't we want the normal artifact lod of the alt allele with the highest tumor lod? Say we have two alt alleles: A->C and A->AC, where A->C is a real somatic mutation and A->AC is just an artifact. Let's also assume that A->C has a higher tumor lod. Then we do not want to filter this site even if we get a high normal artifact lod for A->AC.
Here we want to extract the tumor alt allele _fraction_ from the genotype field, not the population allele _frequency_ from the INFO field, right?
Now that we use the number of passing alt alleles, we can get ride of that +1
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
I think the indentation is wrong here. Seems like you're using 2 spaces.
can be replaced by List.of
Please use Collections.addAll(Collection<? super T>, T...) instead.
use ImmutableList
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Maybe check for if name ends with ':' so we don't do a double one?
They are mutually exclusive? Or is that a micro optimization?
I am wondering where is it better to add this check here or inside RexBuilder#makeFieldAccess. Clients who call RexBuilder direclty will still get the NPE.
Should we use .getMessage() as in the remove() or .getLocalizedMessage() as is done here?
What's the reason to do it here rather than in InternalEntityFactory (analogously to the policy path)?
return this.parent == null ? this : this.parent;
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Please keep this.cell near the related fields (previousFamily & cell count) below
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
I would recommend an else if here to avoid comparing against a string unnecessarily.
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
bad using stringbuilder (I know that you did it similarly to others). Concat method from string creates new string instead of concating to existing one, however append from string builder is appending new string to the existing one.
toString() formatting.
Use this(...)
Why do you wrap here unconditionally, why there is no isValueNode() as in other place?
requireNonNull
Shouldb't be this i18m
Consider using i18n instead of hardcoding the string External Components.
Use CollationKeyFunction.NAME here instead of repeating string constant.
Are these returns used anywhere? If not, might as well make the method void. Applies throughout.
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
if format string is non-empty then String.format(..) can not be empty, so Strings.emptyToNull(..) is probably not doing anything. did you want to do following instead?  String.format(format, Strings.emptyToNull(value));
Nit: Why public?
Does this actually test the use case? To me it seems like fs.getS3ObjectMetatada will always return null here (looking at the MockAmazonS3 class). Does this test fail without the code changes?
Why uppercase fs?
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
What's the purpose of this change? Seems unrelated to the task at hand.
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
We want to allow a null value for the LDIF file, since it is not required for the developer to provide one.
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
It's probably unused code then, you can remove it thanks!
This is unnecessary, its called via canFillFluidType() in super.fill().
Can we test that after some time, reports are written to disk?
Why is this now a magic 20 instead of props.getInteger(PARTITION_OPERATION_THREAD_COUNT)?
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
please don't rely on InternalObjectNode for the new tests. we want to move away the end users to use ObjectNode instead and these tests may get used as samples. Please either use a pojo or use ObjectNode.
@apc999 This needs to be public or reflection will not work
Shouldn't we use super.hasPathCapability(path, capability) here? It would delegate to FileSystem's call, so effectively no difference (including the supportAcls() call there), but would be cleaner.
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
I think we should treat this like we do in Data, and assign currentTime if ctime <= 0. Don't let bogus ctimes be passed in.
maybe create builder - number of constuructor arguments is too big.
This should probably be called defaultTags
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
I don't think it makes sense to try to recover from this exception, we should just log and fail in the sensor (i.e. skip analysis)
Extract this from modules. "final" is not necessary on private methods
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
log this instead of printing
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
This method can be static, as all the methods it calls.
I agree hashCode() and equals() should be done same way, it should be changed for PackageMaterial as well
Ditto for java.util.Objects.hash(Object...)
permissions can't be null, otherwise the constructor would throw a NPE.
fos can be inside try ()
add it to finally? Otherwise ZIP stream may be corrupted if cf.open() or copy fail
Nit: no need for parenthesis
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
Doesn't String.format need a value to be formatted?
I don't think you need this new String
Same here, would be better to leave it on the previous line
Can we improve on this message?
Extract notification to own method notify...
nit: This seems like it should be a separate test (the name of the test would lead me only to expect line 84, not this one).
given, when then please so this is clear what are you testing here
automapSubProcess(..) ? Maybe not the best name.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
A little wasteful when all you need to do is just set the fields and return this...
What's the point of the 6 trailing zeros ?
You can remove the super();.
@lvydra Please remove 'parameterName.equals(NAME) 'from this. My apologies; I should not have listed 'name' as an invalid key in the JIRA description. I've corrected the JIRA description.
Is this checking if two strings are equal?
Usage of StringBuilder would be more readable IMO
Would you mind improving this test to use executeFile() instead of executeString()?
Please include clientTelemetryEnabled in toString() API
consider saving the value of group 1 and group 2 here rather than the whole matcher
consider being paranoid and prefix with "line.length() > 0"?
As a safety precaution, should we make this assignment just once to grab only the very first line number in case generated synthetic lambda method contains more than one line numbers?
maybe a log message here?
can this be readSafely instead of readBuffer so that read uses readSafely
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
no need for the extra '()' and missing space before '{'
This println can probably be removed.
can we validate that we actually have UQ tags?
Should we check if this file exists and throw an exception if not?
other than the previous implementation in subclasses this doesn't create the directory anymore.
Safer to check if entry already exists for the given table. If yes, re-use else put new one.
this.redisTemplate
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
"" + x.doubleValue() - is this the most elegant way to get a String from a double...? And if it is a usecase to instantiate a QuantityType without passing a unit, might we want to add a constructor for double as well)?
To be more precise, shouldn't it be "atLeastOneIsQuantity"?
Not that it matters so much, but the idiomatic way to "unpack" thing from Optional given a value to return in case of empty is [orElse](<LINK_0> which makes this common pattern i bit less verbose: return parent.orElse(null) But this kind of defeats the purpose of using the Optionals in the first place (to avoid having to return nulls). Otherwise +1 to merge.
Please use a 2-space indent and braces around the throws block.
boolean is never null. Please find a user where it is true.
I think it would be more readeable if you would return here DbUser instead of setting the private user attribute, in method which has "get" prefix. Could be confusing. Then pass the DBUser to userDbIsSet method.
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
you probably don't want ID to be editable anyway. Even more, I think only task name should be editable in the new row
It's not clear from any jdoc that the "expression" field can actually contain a comma-separated list of individual expression items. Also, a comma separator is a bit dangerous given all of the string manipulations/operations that are allowed here. I could easily see a problem occurring when a comma shows up in a string used for a value or pattern.
hmm for node based traversal the traversal id is the node id so I think getTraversalId makes sense (more general) ? But yes, let's replace the edge parameter with the adj node id.
As the setSpeed method is deprecated we need a different approach here. Some more hints: * use edge.get(accessEnc) instead accessEnc.getBool * instead of setting speed to 0, set access to false
Consider wrapping this into the constructor, and getting rid off the setter? StreamEdge(isIntermediate)
This is only valid because the empty version is defined as "0.0.0". But AFAIK it could have been "0" as well. So I'd rather use a "0.0.0" (or "1.0.0") constant here.
in calculateQualifiedVersion(), there are other ways to set the qualifier which are not being validated. rather pull this out into a dedicated validateQualifer method and call it after qualifier was determined.
please replase MojoExecutionException for a new generic DeploymentExecutionException
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
You can replace the full class name with an import.
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
please move PRIVATE to the top of this group, to not mix visibility and "kind".
Please move it close to usage.
I think you can remove the surrounding if, it's quite safe :]
Can simplify by dealing with the exceptional case first: if (!allowPushOptions) { // Reading push options without a prior setAllowPushOptions(true) // call doesn't make sense. throw new IllegalStateException(); } if (enabledCapabilities == null) { // Push options are not available until receive() has been called. throw new RequestNotYetReadException(); } if (pushOptions == null) { // The client doesn't support push options. Return null to distinguish // this from the case where the client declared support for push // options and sent an empty list of them. return null; } return Collections.unmodifiableList(pushOptions);
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
is this complete or startSnapshotApply? it seems the semantic of that method changed, we should also revisit the messages that are within that method.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
I think it would be suitable if some kind of padding is applied between messages, such as a newline
You can get rid of this "if" if you implemented the suggestion above
Shouldn't this map be a ConcurrentMap?
nit: UnsupportedOperationException (java.lang) is more descriptive.
checking at least the important fields like chromosome and position and alleles would be nice. just in case we are returning an object will all fields as null. Applies to the other test class too.
ga4ghBeaconResponse as variable for more consistent capitalization.
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
decrease to DEBUG
Use parameterized logging instead of string concatenation.
please remove this generic log statement to decrease to level to trace
Its best to just do one atomic "test" per method in this class. I'd probably break this up into - testAssignVariable - testAssignVariableMultipleAssignment - testAssignVariableNotDefined Also note that junit has some built-in exception checkers <LINK_0>
I think the getProperty has method which accepts the default value as second parameter, wouldn't it be more appropriate to use here?
if 'v' is not a member of enum why return it in upper case?
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
shall we add some message here?
why null?
this should be catch (Throwable t)
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
this should be catch (Throwable t)
import or create (considering we may not use the imported configuration)? there was a good patch by Liron [1] where he called that handleVmLease. not that important though [1] <LINK_0>
Should you call analysisReady(false) here?
subscribe()
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertErrorEventExecutionSet(emptyTop.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptyTop.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
This looks weird
Does it add an error message?
Put this string in a final static so it can be updated in a single location?
return descriptorToImageData.get(descriptor);
Please don't store these, look them up every time they are needed. We don't want to store service-derived information in long-running components.
constrained
Same here, this can be boolean
use a ternary operator like, var == null ? false : var
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
might be better to return the exception so that you can directly see that it exits in the code throw dataTableHeaderMayOnlyContainVariableNames(column.get(0));
You can combine the cast with the call below, like .map(stat -> ((Statistic) stat).getStatisticFormat()...
please merge lines
remote this
Won't fix.
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
unrelated: this can do 'super(msg, cause)' now that we require Java 7.
It might be better to override toString rather than append ValidationError because now you will get org.voltdb.exception.ValidationError: ValidationError: MESSAGE when toString is called or the stack trace is printed
Previously, if the channel data was missing (e.g. if someone tried to authorise a presence channel on an auth endpoint only configured to authorise private channels) then it looks like there would have been a null pointer exception thrown in storeMyUserId which would have been caught and converted to an AuthorizationFailureException above. It looks like now there would just be an uncaught null pointer exception. I think it might be better to wrap the call to storeMyUserId in a try catch like before.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
0 is a legitimate option value for min. selectable choices. Why not -1?
Why don't we make inDegrees to ConcurrentHashMap also?
rename to signature
Local variable could be declared List instead of ArrayList. Is this worth caching?
Small thing - I think it's better to do: List<String> result = new ArrayList<String>(allLocales); because with original code: List<String> result = allLocales; any modification of "result" will also modify "allLocales" input parameter. In other words, are we OK with modifying method input parameters? (I'd rather avoid this.)
This can be done simpler. I've refactored addSenderBuddyLinkIfAvailable as an example:  private void addSenderBuddyLinkIfAvailable(MessageDto message) { message.getSenderBuddyId().ifPresent(buddyId -> message.add( BuddyController.getBuddyLinkBuilder(goalIdMapping.getUserId(), buddyId).withRel(BuddyController.BUDDY_LINK))); }
seems like a string that should be stored as a constant and defined only at the side who returns this message to prevent breaking this assumption - unless it isn't doable
I would ignore empty notifications and would log warning.
Use dynamic string, please :)
Do we really need a toast for "bookmarking..." the page? It's not an expensive operation, especially now.
You don't need to check for null because the Task which triggers this callback should have been canceled anyway. If the problem still exists, Crashlytics will tell us.
nit: use SUBJECT
.hasSize(), 2
remove or assert ;-)
Why 0,8 if all we are setting is 7?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Sorry to be a pain, but we should use uk.gov.pay.logging.LoggingKeys.PROVIDER here, similar to how <LINK_0> does it.
Response is kinda redundant in these two methods (can return directly)
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Why is it a list of lists, not just a list?
what is this supposed to do ? Is it supposed to provide a list of just the highest checkpoint ?
it can be private, and remove method from interface
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
we'll never reach break;
Why we want to fall through into the loading dialog in case of error?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
there is no need for this.
diskModel is usually used for DiskModel instance. i.e. s/diskModel/moveOrCopyDiskModel
is there a chance that the returnValue is null? if yes, the converter would be a perfect place to handle it...
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
just use context as synch obj
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
True. I've never seen a case with -1 as the default. 0 has special meaning in the JVM, so best to stick with 0 as the default and adjust the size to cope (add one or size 0 -> -1)
Do you mean s.length() > len?
Subscribing to METHOD is only introducing confusion, and cause problem with the rule. Subscribing to METHOD_INVOCATION should be enough. When hitting a method invocation, you can then look into the map if something exist for that symbol. If it's not the case, retrieve the parameters names and add a new entry on the map. Then you check for parameter names.
Collections.singletonList
Better to use Collections.singletonList rather than guava for this.
Perhaps make it private so no one will be able to initialize it outside the class? It makes sense cause regular initialization will not do much without injecting the members
What about return VdsmManager.getInstance().getHostByName(serverName); host is not needed.
We don't want hostnames\IP's in the labels. So need to cut URL either until any IP or first dot in case of custom DNS.
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Use of reflexion as per BaseLoadingListFragment.java
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
ArrayList should be constructed with fixed capacity.
ArrayList should be constructed with fixed capacity.
ArrayList should be constructed with fixed capacity.
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
It would be nicer/easier to debug if you extract the numbers with this regex: "^(\\d+)\\.(\\d+)\\.(\\d+)" Then do a comparison separately. java int result = ComparisonChain.start() .compare(1, Integer.parse(matcher.group(1)) .compare(14, Integer.parse(matcher.group(2)) .compare(0, Integer.parse(matcher.group(3)) .result(); assertTrue(result <= 0, "Expected BigtableVersion.getVersion() to be at least 1.14.0")
please no if one liner if(!pattern.matcher(viewNameEditor.getText()).find()) { ... }
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
as I said, I think $i=1 should be part of this block (thus elem = 2)
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
In case self is a BufferedIterator should this return self instead of re-wrapping?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Immutable fileinfo
Make the fileInfo map immutable.
Is this used anywhere?
missed to implement
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
@ivandalbosco super minor: no space before !isDocStringsAndNotImplementedError(node)
If tag is empty we will have NPE here. Could we make this impl safer?
static import
other than the previous implementation in subclasses this doesn't create the directory anymore.
delete on exit?
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
let's change the semantics of this class so it is not crossing thread boundaries unnecessarily, otherwise you need to worry about the SubscribeProcessor synchronization. I would add the following fields: private Publisher pub; private List<SubscribeCommand> cmds; AtomicBoolean exit = new AtomicBoolean(); Then the methods on the task become: private void setData(Publisher pub, List<SubscribeCommand>> cmds) { // TODO: check not null synchronized (this) { this.pub = pub; this.cmds = cmds; } thread.interrupt(); } private void exit() { exit.set(true); thread.interrupt(); } private boolean isRunning() { return (thread != null) && !exit.get(); } none of the other operations are needs anymore and then your run() method becomes a loop: try { while (!exit.get()) { try { Publisher p; List<SubscribeCommand>> c; synchronized (SubscribeTask.this) { p = pub; c = cmds; } // execute .... } catch (InterruptedException e) { // re-execute with the updated commands } ... } } finally { process.close(); }
Again not an error, it's possible to have an offer with 0.0 cpu resources, but with 2048 mem resources. While it's not useful to the framework, it's not an error. Debug or info.
remove this
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
I would throw instead of just logging it.
tab starts this line, we use spaces to indent code
move it to be aside of deleteFolder
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
File.separator
could be static
SqlToRelConverterTest is a good place. Actually it seems that you can move all the tests here. Moreover this new test does not bring something significant in comparison with the previous ones so I would suggest to remove it.
you can also write this as return sql.replaceAll(TRIM_SQL_PATTERN_STRING, " ");
We should also check the servers which we want to update the hook content is in UP state.
using command line user can provide a wrong id (say, by mistake), so its better to check for getVdsGroup() == null here as well
Will the volumeId not be set in the constructor from parameters?
Switching ON admin mode...
I think we should remove a pair of parens:  mSession = new Session.Builder(this, mApiKey, mSessionId).build();
Switching OFF admin mode...
Better do this as a static variable
Is there a reason you can't use the strings.xml file for this?
Do we need to make a ticket for this or track it someway?
Too broad a catch. IndexOutOfBoundsException should be enough.
consider being paranoid and prefix with "line.length() > 0"?
Does it consume only first testSizeLimit characters? Will it be more relevant to consume the last testSizeLimit characters? I would personally introduce a new class for that.
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgment.getJudges()
Collections#unmodifiableList could be better there.
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
This should check the endorsedBy field I guess, since that is what is displayed in endorsed responses.
why would this be required again?
Why return null?
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
I (still) don't understand why you're not calling tokenizer.skipInt() here (and below) If the caller called "skip...()", her intention is to skip, not read, right?
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
same as above... why not use simple if/else here?
Should use the log, maybe a warning.
What is this for? Feels like some unintended checked in code?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
UnsupportedOperationException ?
Please change to: > ... operator cannot be used in a GIVEN clause.
nit: I was wondering if we should use covariance here and anywhere we return Strings, like we do for other types.
Should the name of the FileSystem be included in this message? Would help troubleshooting issues.
Can simplify by dealing with the exceptional case first: if (!allowPushOptions) { // Reading push options without a prior setAllowPushOptions(true) // call doesn't make sense. throw new IllegalStateException(); } if (enabledCapabilities == null) { // Push options are not available until receive() has been called. throw new RequestNotYetReadException(); } if (pushOptions == null) { // The client doesn't support push options. Return null to distinguish // this from the case where the client declared support for push // options and sent an empty list of them. return null; } return Collections.unmodifiableList(pushOptions);
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
i think this might need to encdoe the name and bitmap type too.
Should place 0xff between these guys, in the event that a fieldName is used that matches a fieldExpression but should have different results.
suggest putting 0xFF byte after a string as a terminating indicator.
Not related to this change but this should be spelled "Cancelled" to be consistent with method "isCancelled" of ProgressMonitor.
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
I would have expected the tracing to happen at the writePacket(buf, pos, len) level, since that captures all packets sent (not just packets sent as strings). end() is where flush-pkts happen.
GPS should be caps
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
null credentials and demo credentials is no the same case
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(byteArray)) != -1) { out.write(byteArray, 0, byteCount); }
You can remove this code and replace it with org.eclim.util.IOUtils.copy(in, out).
I'd suggest to assign the value of length() method before the loop, since it won't change inside the loop
Why does do all methods have to be inspected in the constructor, instead of checking for the annotation in this method, after checking the static list (possibly caching the result in a field so it does not have to be repeated on each call)? That way not all methods have to be checked for each instance created, which is quite expensive time wise. And I expect most methods will not be annotated. Furthermore if the annotation is NOT present a wait was required, so the time spent checking for it is most likely not that important.
Indentation should be deeper. These are easier on the eye (the break is less jarring)  java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {   java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {
This won't work with generic builders I think.
Static import the assertion methods
Put each on a separate line java .setMetastoreUris(null) .setHiveUserName(null));
should it be DruidAuthenticationType.NONE?
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
For Lists this should be applied to each element of the list. Please also include unit tests for stuff like {"toomany":[1234567890000000000000]} and {"funkyCoding":["foo\uD900"]}.
this can be static
When is this case triggered? If a commit is produced only when all other commits referencing it have been emitted... how can it be reached again? Is this because some interaction with other generators?
Optional: Once we are here we can update the coding style, removing this "final" and adding brackets to the "if" below.
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Throw the proper exception if something is not supported: - NullPointerException if status == null or command == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
I guess null is an invalid value for command, if so throw a NullPointerException.
parameter string might be null, avoid the NullPointerException, since null seems to be a valid value for parameter.
Same as above for otherNonCodedConceptUuid
Same as above for otherNonCodedConceptUuid
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Use Assert.fail() instead
should this exception be left to bubble up and fail the test ? If afterEach fails it means the repository was not shutdown properly
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
ChannelClosed needs to be added to (though not strictly necessary)
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Unsigned types are not used in the current implementation. So, you can omit them.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
MemStore is used for tests, so we need to implement this function.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
This should throw an UnsupportedOperationException instead of a RuntimeException. Also, standardize the error message with the other UOEs throughout this package.
is there a reason why this method isn't implemented?
I think the annotations should be on separate lines
nitpick: if ... else would be more appropriate here
You don't need to call .getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
FYI: using a map here would have given us: .map(voidDigitalTwinsResponse -> null) Even though Mono<Void> is the same as an empty Mono -> Mono that doesn't return anything, I feel Mono.empty() is a better representation of the transformation we are doing here. However, I want to point out that the end result from both would still be the same.
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Shouldn't options be Immutable?
the client user id is the first name?
Is it going to return null in case the request is not authenticated?
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
This .toString is confusing. Make it simpler. At line 144 use just "(" string. After that concat service.getClass().getCanonicalName() + "#" + method.getName() with that updated joined string.
How would you feel about using more descriptive column names? For example, day(shipdate) as ship_day and month(shipdate) as ship_month? These 2 will give you values within TINYINT range and will have meaningful names that are easy to understand.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Why do we print a secret systemUserPassword here?
I would separate the message that should be logged as info from the exception that should be logged as debug as we don't want to pollute the log with a stacktrace at all times.
uncessary call to super. No need to visit further.
![MAJOR](<LINK_1> Change this comparison to use the equals method. [![rule](<LINK_2>](<LINK_0>
hope you know the diff between ceilingKey() and higherKey() and you are using higherKey intentionally
Based on how it's used, it's more like a listener not callback.
- log warning that option is not supported by SNMP
Remove all "null" cases. There is a default case for that.
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
Unsigned types are not used in the current implementation. So, you can omit them.
Now the commit action is not enabled when I select a non-project resource. The method getRepositories does only work for projects.
@amihaiemil should be length()
This code is a bug, should fix like following: return randn(length, 1);
This should not be registered on an HC.
The super implementation is a no-op by design.
This should be in registerOperations
Remove
return Promise just to symmetric with start()...
see in Volt how to properly shutdown an executor service
This seems like a logic error here (alternate output is either some string or empty string). I cannot see a situation where alternateOutput is null.
There used to be a call here, that got removed: "fActiveConsole.consoleSelected();" Without this call, the gdb focus synchronizer will not be notified that the console has changed, and so will not change the selection in the DV. I think we need to add it back.
I think this assert is redundant... If console does not contain the text at this point it has already failed on the wait on line 71.
suggestion return Optional.of("org.junit.platform");
as above: are spaces OK in namespace strings?
are spaces OK in namespace strings?
Missing StringUtils.isNotNullOrEmpty() check
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
these setters should not be public
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
Is it really worth checking before setting it?
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
You should be able to use the diamond operator here, i.e. new ArrayList<>()
I know this doesn't require any fields in StreamCatalogService, but if we would want to make it static, maybe better to have utility class instead. Just a 2 cents.
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
Why not make implement Closeable rather than this private close?
If this is not used you might want to throw an UnsupportedOperationException
@NaitYoussef , @qasmi add this function to post to get his summay , i think that you will be useful to you
Would it be more appropriate to throw OperationNotSupportedException  here? It looks like returning null here will end up in an NPE based on current usage anyway.
static importa
This is inconsistent with the other tests but I'm assuming we want to gradually move towards using AuthCardDetailsBuilder rather than AuthUtils (how did we end up with so many different ways to build these objects?!)
This unit test has no assertions
Why do we return the parents name instead of the name we store a few lines above?
Straight returning the results of filters.get(...) has the same effect, or not? Mind, it's safer to ask the metadata map to produce a String.class using the second get parameter
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
This could be null, we should probably handle this if the JIRA api changes again
nit, Collections.EMPTY_MAP?
Minor - Unnecessary type declarations during initialization. There are a lot of these in this class, so I'm not going to address them all individually.
I think we can remove this line.
I don't know, but isn't the class also of interest?
X and Y are primitives, so should the %s be %d here?
Should have a period on the end of the string for consistency.
why is it adding null?
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
FWIW, I benchmarked Math.pow(k - m, 2) vs (k-m) * (k-m) and there is no difference in performance.
clone the header to avoid changing the old header
Excellent doc. :+1:
other.updCntrs?
This is a public API change. Does it need to be public? It would have to be reviewed with other language folks
Please change the line 38 to also use EnumMap<> for consistency.
In fact this test is not useful, the framework will fail to start if the injection can't be processed.
we open curly braces at the same line as the method signature :)
This is invalid before the change because LHS has a wildcard and RHS does not.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
please reuse the constant
use the constants defined above
Don't need last else
see below re: spaces
It looks like this isn't really what we want - the !! is character content, not an image. I'm thinking that since an image with no src can't be represented in Confluence, that we should just leave out the !!. What do you think?
It would be good to survey the world and see if there's a more popular heading style (since there are four: setext-style with hyphen underline, setext-style with equals underline, atx-style, and closed atx-style).
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
Maybe extract this if-else in a method like createResponseHandler(Logger), otherwise it is duplicated in both constructors.
Do not contacte file paths. Use HomeDir.toFile().toPath() and resolve from it.
This is another behavioral change that I don't want to see in an unrelated PR.
The value needs to be encoded/escaped when used as the key.
IMHO better "HashSet". I don't see that you use the iteration features of "LinkedHashSet".
Redundant, HashSet does not allow duplicates anyway
Can be replaced with method reference.
Simple for-each?
Note that all references to CoreRegistry.get(class) need to be replaced with either @In annotations (best idea) or context.get(class) codes (find-and-replace). You'll probably need an @In annotation to pull in a context.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
minor thing, but this doesn't need the throws clause
This is one of the reasons I didn't create a PR yet; not sure what the answer is yet but was going to explore it (possibly using ApplicationContextInitializer and creating ContainerMetadata earlier). Earlier (current master) we had a static method being called to publish the container started event from a context (static so SingleNodeApplication could also call it), but that definitely needs to change. We need a bean, with a managed lifecycle.
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
hyperlink
Repository should be a dependency inject it in the constructor
I think there's a method in Runnables that returns a do nothing runnable
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Can this be private, or is there another use case for default attribute outside the builder's call?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Wouldn't it be better to only show iterations OR epsilon?
channelId => channelName
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
should probably be named m
should probably be named m
should probably be named s. But then it's conflicting with the subscription s. So I guess ss would be more appropriate.
no need to extract this out to private method if it's only being used here. same for onClusterRemoved
Why it's "EXTERNALVIEW"?
Lets add here the target mapping as well
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
Log the exception to error.
Don't forget to update this
nit, Collections.EMPTY_MAP?
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
put(uri, stream) on a concurrentHashMap avoids the "synchronized"
Used to be fileSystem.deleteFileOrThrow underneath.
@fabriciofx Here also, we could return the body() of our decorated object directly
please remove newline
please move list initialization to where it is used.
please instantiate the list right above the check where it is used.
this for is exactly the same in all the array tests, let's move it to a private method
Maybe just throw an exception here to make this more clear?
suggestion  refresh still shouldn't be necessary.
Why we don't call onDestroy() method of playerSkinLayoutController as early?
CoreUtils.isnullorEmpty
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
nit: public abstract void
@fanifieiev RequestOf is a better name than RqOf.
Put this in parentheses for readability: mLastBssid = (scanResultInfo != null) ? MacAddress.fromString(scanResultInfo.getBssid()) : null; Or, if you prefer, mLastBssid = (scanResultInfo == null) ? null : MacAddress.fromString(scanResultInfo.getBssid());
Same here regarding the messages.
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
timeFormat:null is unnecessary
Either call getComputedValue(buffer, ...) here or remove the second signature of getComputedValue since I don't see it used anywhere.
seems like synchonized is not needed here, given increment/decrement already protect
please update the name of this variable
Absolute or just path?
does this method need to be public?
child
Can we compute this lazily only once hashCode is called, then cache it in an instance field?
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
A little wasteful when all you need to do is just set the fields and return this...
Why this change?
maybe sth like content.avro.deserialization? so in the future we might add content.json.* metrics, it would be weird to have .json as root metric
I see this is used just in kie-wb-common as log message, however maybe could contain also fact/field, or some more details.
No need for 0.0.0.0
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
local variable e is never used.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Load and termination parameters should belong to Load and Termination entities
Hi Tolis, would you mind to move the code below to another class?
private, should only be called from the builder.
For loop?
For each?
maybe make this a constant and put everything in one line
There should be a white space before else Also you could use word.charAt(i) in both the if and else statements (e.g. word.charAt(i) == 'y') instead of using substring, that might make it a bit more obvious what you're doing
Minor: tweak the spacing here? i = 0; i < 5; i++
can we use the result from the cancel attempt earlier?
why you change the sequence here?
any reason why synchronized the whole method?
handleExceptions();?
Don't rely on the JRE platform encoding here. Use a specific encoding, like Constants.encodeASCII(). This also applies to the other getBytes calls below.
"engine" can be extracted to constant
You can make this method private
Aren't there any test methods that require compatibility?
Why does it need to be HEAP?
Seems this can be simplified to just call super.clusterConfig and then invoke jmxStatistics.enable().
lowercase for package names.
Is there another place where we can define this, so that this does not need to be defined in RealVoltDB as well as here?
remove whitespace
nit: verify(callback, never()).run() before this
You may also check responses from callback.
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
this change is not correct for other content where Payload is used, obviously it has Base64 encoding there
I think we need replace op too for updating existing
this method is never called in this class
"This method is not actually very useful and will likely be deprecated in the future."
can we use a meaningful name for s? ex: security?
why is the "".equals check needed when you're using StringUtils.isEmpty?
Couldn't this just check unavailableException if it is null or not? Seems we wouldn't need the managerAvailable variable as well then.
This is a test so probably not an issue, but please re-interrupt (Thread.currentThread().interrupt()) or use Awaitility if it's available?
nit: the exception is no longer thrown.
Please throw NullPointerException instead (also, use braces for the if statement)
I would ignore empty notifications and would log warning.
seems like a string that should be stored as a constant and defined only at the side who returns this message to prevent breaking this assumption - unless it isn't doable
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
Shouldn't this return x rather than re-parsing the property?
Return y instead of re-parsing?
Why is it a list of lists, not just a list?
Local variable could be declared List instead of ArrayList. Is this worth caching?
File
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
should this count be parameterized?
Pull this into a static final variable
I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to log message.
ex.getMessage() VS "Feature is disabled"
I don't see why is isConnectionSetup() necessary. Shared in SharedPubSubWebSocket client means it is shareable and must support concurrency. It should be the responsibility of SharedPubSubWebSocket to ensure that its state is properly managed and if setup() can't be called concurrently, enforce it.
Please no, let's not have compactedChain being null legal. What is it buying us exactly?
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
The test is OK whereas it shoulf fail as the code fix is not merged
remove this?
Should be added the Override annotation.
deserialize can return null.
What's the behavior when the input is not between the min/max values?
@Description on L138 needs updating
Add name to exception message
It looks like you're now also protecting against use of double-quotes in the User's Roles/Groups; however should you not also then be protecting against \ too? Also, isn't a String.replaceAll(...) sufficient? Does LookupTranslator really bring anything new to the table!!?
I agree with trimming, but I don't understand why we need to lower-case it.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
Why is it a list of lists, not just a list?
UOE instead of ISE (x3)
how did you decide between throwing vs. silently ignoring (which is what you do in ReadableStreamChannelInputStreamTest)?
This should throw an UnsupportedOperationException instead of a RuntimeException. Also, standardize the error message with the other UOEs throughout this package.
Is this an error condition or just timing? When will it happen?
assignedPartitionIds can get large. We may want to log the whole set only in debug mode, in case addPartition gets called many times on startup.
minor: I know it wasn't done for the other similar metrics, but since this name format is used in two methods you could probably make a helper method to generate the name java String getCatchupPointFromCloudMetricName(PartitionId partitionId) { return MetricRegistry.name(ReplicaThread.class, "Partition-" + partitionId.toPathString() + "-catchupPointFromCloud"); }
Formatting
(z, z) certainly doesn't look right.
This & the other switch removals should be reverted, performance tests show that this isn't any more efficient. The change also increases memory usage, making this a net negative change.
I think you should dispose the ShapeRenderer here.
I think you might need to flush too? Or is someone else taking that into account? Would be good to have an explicit test for this: - start a backend having an extremely high refresh time - send a write operation to the backend - verify the index change is not visible - close the backend - verify all changes had been stored
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
specify charset?
wdyt about IllegalState + descriptive msg?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
[minor] Why single-quoting the id?
StringBuilder
can this use submit?
2 minutes? Seems too much, I think 1 or 2 seconds should be more than enough.
Maybe it makes sense to check the Launcher's class even before selectType(). Otherwise you try to install the plugin even for other Launcher types
Are we sure that getCanvasHandler() and event.getCanvasHandler() are always not null values? Otherwise, I think we should use Optional.ofNullable(..).
Code for this method could probably be taken out into a separate method - with a Consumer parameter for the particular view method call - and reused in the next few methods.
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
Ok if already stopped? idempotent?
Also too many dots
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Can be simplified: java return HashUtil.combineHashCodes(Objects.hashCode(ul), Objects.hashCode(ur));
Usually we use this. prefix only in constructors and setters, please remove if possible.
it can be replaced with Objects.hashCode(channel) (since java 1.7)
Why not in combination with above do this: setValue(value, false);
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
extract private method boolean waitForOperator(Operator operator, Duration timeout):  try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; }  and build assertions around this method
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
This exception is not ignored, so can you fix the variable name?
you could just do setConfirmWindow(null); like above method
do you still need this call, cant you depend only on onLooperPrepared?
style nit: we don't use braces around single line blocks
We should store LongMetric inside object instance.
Should probably remove all synchronization from this class.
Can we change this line to this(0) and remove the if (port == -1) in the other constructor?
Not sure I like this. This starts a new thread where we retrieve the access token. I'd rather we do the token retrieval right at connect time. If we need to spin off a background thread (which it looks like we do) we should do that and complete the connection stuff in a callback to ensure things are done in the proper order.
can we switch to the CommonUtils asserts?
Missing types
does this method need to be public?
I don't think the process deploy should fail in the case of temp file deletion fail
I think you're missing getDefaultConfigurationFile() here.
Please use @BeforeMethod(alwaysRun = true) insted of init() inside of test body
create instance of this object when requested not in constructor
there is no need to execute initElements method, when you're extending BasePageObject
space before trailing {
it's unclear whether this is invalid because 0 is not valid or because it's a string. I'd recommend being a bit more specific here or potentially having two tests if both are invalid to make it clear what our expectations are.
nit: no space around quotes
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Oops, this test is messed up, i think we better split it into 3 tests: testDateCanCompare testTimeCanCompare and testTimestampCanCompare
more than 120.
Need to remove codec from here too, right?
need to use the removeBaseAndBucketOverrides() code in S3ATestUtils to make sure that any per-bucket setting has turned it on. Look for other uses to see what to do
Why uppercase fs?
Does this cope with the case "The previous session ended in a crash. In other words, one session can only have 1 crash at most." in the project definition? Should we also check if there have been unhandled errors?
simplify this
maybe? return session != null && Boolean.valueOf(session.getAttribute(".."));
The message should be "definition is null". Same for all other requireNonNulls
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
Use LocatedSource here instead
(SlimefunItem.getByID(getId()) WTF...
better don't call the setter here since the configuration (from updated()) must not be called already
I think checkValidity() in JLiteral is quite wrong. Why not be more precise in all checkValidity in JValueLiteral hierarchy.
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Should this have output partition too?
Camel case here too
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
use markers like {}
ICSE is not a timeout. Maybe set containerException to this value, or log this and then set hasContainerShutdown = false?
m_totalAvailable needs to be cleared as well.
there are 4 instances of "store manager" being used like this. Can you replace with storage manager
you could simply iterate over replicaThreadPools.values() instead of the two for loops.
FYI All instances of HardSoftLongScore.ofHard(1L) may be replaced by HardSoftLongScore.ONE_HARD,
I guess "visit -> visit" is better than "Function.identity()"? Should we experiment with thisEqual() or equalToThat() ? I guess that's overkill...
Can we use the variable name "employee" in such cases? (Same for a above constraints) lamdba's don't have an explicit type written down. (It says "e", not "Employee e"), so for readability (most users start from one of these examples), let's use a full variable name. In general, in optaplanner-core only the following short var names are used: int i, Object o, Exception e.
Why do we need to first slice and then also duplicate ?
Changes to this file should go in the previous commit
nit: consider use BlockUtil#compactArray
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified label, and he selects "yes" on this option?
IndexModule.getIndexType(dbInjector) == IndexType.LUCENE
semantic units should be separated by empty lines.
does this need to catch all exceptions?
log.warn("Retrying pipeline trigger (attempt {}/{}) for {}", attempts, retryCount, pipeline);
here you can avoid the log.warn, because you're throwing an exception
Access
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Please extrace the generated url into a variable before calling HttpUtil.executeUrl(), this makes debugging much easier.
This is another minor nit, but this routine seems oddly written. The variable pos isn't really necessary.  public int getIndexOfCriteria(FilterCriteria tm) { if (tm != null && mFilterValues != null){ for (int i = 0; i < mFilterValues.length; i++) { if (mFilterValues[i].equals(tm)) { return i; } } } return -1; }
Code conventions: we don't use curly brackets around single line blocks
Let's avoid null and rework to empty string
use the interface here
Although the returned Map is unmodifiable, the values are modifiable lists. Please change to:  public List<FrameworkMethod> getAnnotatedMethods(Class<? extends Annotation> annotation) { return Collections.unmodifiableList(fMethodsForAnnotations.get(annotation)); }  (though I would prefer that the values for fMethodsForAnnotations to be unmodifiable lists)
That's good to know.
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
would be helpful to record the date/time here as well.
I think this is a behavior change
mark this method private as this is only used in this class.
wouldn't this be more readable if it were a precondition? Also, there is a NPE in the wings when uri == null.
revert this unrelated formatting change
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
use ShellIsAvailable
use ShellIsAvailable
Another place where we could note that the boolean is unused.
This one will always use the default timestamp table (though looking at atlasdb-jdbc it doesn't even use AtlasDbConstants but uses its own "_timestamp"!) I'd actually suggest doing a Preconditions.checkArgument here, this one seems a bit more dangerous than the InMemory one in that it can actually have surprising consequences!
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
Why do we play with environment variables in both MesosMaster and MesosContainer? I know, it's not exactly about changes in this PR ;)
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
I do not like this method. The way you create anonymous classes in it is bad. This method can be called 100 times per second, and each time it will create class with static initializer (new class, not instance). That means, that after 10 minutes class list in application will contain 10 \* 60 \* 100 = 60000 classes (and multiplied by 3, because there are 3 static initializers -> 180K classes), and I'm not sure if it is possible to unload it.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
I still don't understand why the key cannot be the session id
Simple for-each?
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
Use TreeMap to keep the order.
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
VmDeviceUpdate::getName
As we have ALL, I think you can just add only ALL here.
Are we sure that we can never have e.getValue() == null ?
See UseCase.
We can use the createResponseEntity() helper method like you did below.
GetCommitResponse is no longer used anymore. We can remove this class and replace its occurrences in the tests with the Commit class.
suggestion if (this.currentTask != null) checkAndRethrow();
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
@xpdavid is this the right thing to do?
Personally, I'd prefer to format it like digests elsewhere as <hash>/<size>. WDYT?
This is in a test and we know what we argument we pass (never null) so if (expected.isEmpty()) is enough.
Unrelated change
I notice a bunch of tests that use camel-undertow have been switched to WAR. Are we now mandating WAR for any camel-undertow consumer usage?
tmp.newFile(archive.getName())
Wouldn't this export it as a Compressed file even if requested to export it exploded?
Shouldn't this be wrapped in a try... finally block?
This seems rather incongruent to me - should we define a dedicated filter for managing request-lifecycle MDC keys?
again, this cannot be, there cannot be unconditional chaining... the nego should be able to stop the chaining, please see current implementation of nego.
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
Does the default case of varchar work fine for all other presto types not handled in the cases above?
Camel version 6.2.1?
Please remove that
we need to reset this property in a @Before block
As an idea: might be introduce a method like assumeMinimumServerVersion(con, ServerVersion.v9_3) ?
can we use sysprop or something for url?
Should we not use createContentString also in getVersion() (instead of toString()) now that we have it?
Do we want the toString()= in here ?
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
Huh? Item implements AccessControlled.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
This is the replacement for [this](<LINK_0> We might want to consider --non-interactive at least.
I wonder if it makes sense to echo a message here saying we're recreating the repo since something changed.
Based on whether the directory is cleaned, etc. there's a [different sync happening](<LINK_0>
Is this change related to supporting commit validation by plugins?
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
The message is missing.
I know it's specified that way, but I think it would be more interesting to only highlight the parameter.
nitpick: no need for 2 nested levels, can use } else if (isValidKeyGenSymbolOfInitializeMethod(mit)) {
Merge conflict. This should be comparing width to x and height to y
I think you should reset value of current branch in this method.
Just a small nitpick: We don't need the else here.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
It is a good idea to add all releases in a finally block, so that we never lose permits.
I think for removing a thing the order was already fine. If we remove the thing from the ThingManager before notifying listeners, they could try to disable the thing in that short gap. Moreover, if we leave the order in this method unchanged, then it will be exactly the reverse order from the notifyListenersAboutAddedElement method, which is also what I would expect.
You've got some auto formatting thing on which basically adds "this." everywhere. You may like it, but it makes for a very noisy diff :-( This diff Should be a 2 lines fix. There's no need for the incremental approach here either, given that it's a trivial change. Making it an incremental PR just delays it's acceptance.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
@exper0 let's use try/finally blocks for closing instances of Closeable
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
@d-molotchko use String.format instead of '+'
@dmzaytsev let's extract this into a private final String variable.
you might want to make 10_000_000 a constant
You can replace the for loop here with values.forEach(result::add);.
i++ is generally the convention unless you explicitly need to preincrement.
inline lists
Based on how it's used, it's more like a listener not callback.
The idea of the copy here was to sort the arrays then walk one, calling one.get(i).equals(two.get(i)) so we catch multiple entries of the same object in one or the other. Try adding some UTs for this one please.
nit: are we just checking that it doesn't throw? if so no need for the class check
For clarity, DEFAULT_SERVER_LIST could be renamed to something like ONE_SERVER, SINGLETON_SERVER_LIST, or LIST_OF_ONE_SERVER.
Usually for this it's reasonable to have a hasMessageContaining(...) to make sure the exception is what you want it to be.
nit: you can merge both lines above as checkNotNull will return the given argument
nit: you can merge both lines above as checkNotNull will return the given argument
nit: you can merge both lines above as checkNotNull will return the given argument
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
Let's keep the old code here or let's try to move this method in the IndirectClient?
Checking this is probably redundant now when we return an Optional<LabelMeta>?
I am curious couldn't we just test this by default given that all schemas need to be present in "schema/" directory. we could just load all of them and based on what schema xml reference test that by default. Overriding is still fine for all corner cases but by default it shouldn't be needed.
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
No key for encryption? ;-)
I'd need to check, but this might fail in when poolId is null or empty. If so we need to wrap this (and other lookups in similar methods) in a null or empty check.
We do not want to throw an exception to be caught by the consumer. Logging it noisily is probably the way to go.
? element.getName()?
Args need to be included in operation.
Wrap up in a SamzaException or add separate catch blocks for general exceptions and SamzaExceptions if you'd like them to be treated differently
Please use parameterized logging in all cases, avoid using String concatenation.
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i = ...; if (i == -1) { return false; } mRoutes.remove(i); return true;
This will need to check the destination instead of checking for equality. See removeLinkAddress for an example.
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
Make secrets an immutable list if present.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
I think JPA requires this to return a Long
Should use Long.class
You should be able to use the diamond operator here, i.e. new ArrayList<>()
nit: extra line after if
@korthout Use TrimmedText from cactoos
Unwanted final?
It's useful to put something like this here:  java LOGGER.info("Groovy console starting...");
This has nothing to do here. You're invoking blocking code during plugin activation and wasting this instance
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Use guava's firstNonNull: return firstNonNull( overridden.get(permissionName), Collections.<PermissionRule> emptyList());
final, Lists.newArrayList(), etc
no need to specify type on RHS
minor static import isWhitespace for readability
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
if second is not present, you return empty if second is present but has all fields absent, you return first Why? Leave some explanation in the code. (here & a few times below)
It would be quite neat to use DimensionManager.getWorldById(0).transform here, which automatically handles the "if present" check
rename the local variables too?
Please use: return !steps.isEmpty();
Immutable
why not use long and System current time?
Maybe wrap in an immutable map.
I would assume this should be: java return extracting(extractor, assertFactory);  That is, why create an ObjectAssert only to map it into a different assert type?
Maintenance of the map will be simpler than that of the list
nit: Should be public. We're only using this inside of the package, but there is no reason to restrict it, and it should have the same visibility as the constructor, since it is just a shortcut for the ctor.
Call to update is unnecessary here, as it gets called in the save method.
return STRICT_SANITIZER.sanitize(original); This would have the same result with the benefit of not needing to have an extra static variable, thus reducing the applications footprint and the resulting byte code would be more efficient because you will have one less indirection to invoke the underlying sanitize() method. The same criticism is applicable to the use of CMS_SANITIZER.sanitize(origin).
This version check could be removed as we already move to 2.6.x
This is one of the reasons I didn't create a PR yet; not sure what the answer is yet but was going to explore it (possibly using ApplicationContextInitializer and creating ContainerMetadata earlier). Earlier (current master) we had a static method being called to publish the container started event from a context (static so SingleNodeApplication could also call it), but that definitely needs to change. We need a bean, with a managed lifecycle.
Please move it to "else", it is better to have one return point.
Why absent?
Cache this value.
That's good to know.
We might not need this setup method as we are doing the static mocking within the test method.
Is this a typo? Should be "sendMessage"?
Does the actual error message have an additional space? Could we clean that up if so. suggestion .expectErrorMatches(e -> e instanceof CredentialUnavailableException && e.getMessage().contains("Azure not Login"))
checkState
We don't need to cast to int.
:+1: like here, ..isNull() makes it clear that you're checking that the last message is null
it looks like you have to adjust this one to your recent changes -> see pr build on travis.
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
If a consumer contains only a single assertion statement, should we use the shorthand notion without brackets? (Applies to other unit tests as well.) suggestion Consumer<String> consumer = s -> assertThat(s.length()).isEqualTo(4);
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
is it worth adding if it's null to return REQUIRED, to prevent old persisted items from returning null here? or have an explicit @Nullable
Fire the event outside of the monitor.
Welcome to the world of limited packet sizes. This will explode and explode fast. Do not hijack the vanilla packet.
I don't understand why we need to make this ThresholdInputStream so configurable. As I understand, this class is going to be used only inside this package. I would make it package-only visible and remove this "runnable" injection.
Why not check the flag directly on symbol then ?
Should not be public
Collections.addAll saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.
- Tested at 199 dpi, it gets mapped to 175% zoom.. reason being zoom is an 'int' and it looses it's precision in above calculation, instead it should be float.
As per <LINK_0> suggestion if (returnVal == 0) { returnVal = 1; }
bad hashcode.
So we decide this class to be a leaf ByteCode Node? (Alternative would be make this returns ImmutableList.of(block, position)
Maybe it would be better to return actual list of problems? reference.getProblems() WDYT?
an empty ArrayList is better than a null
Please remove the maverick ";"
Can we confine this change to just the calculation of the MD5 itself?
use Bytes.memcmp()
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
same here - result should be null
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Should close kill the memspace? What if someone want to reopen the key?
Nit-pick wouldn't Assert.assertThat(v, allOf(StringStartsWith.startsWith("jar:file:"),StringContains.containsString(dir.toURI().getPath()),StringEndsWith.endsWith("::hello"))); be nicer... that way you have one assert and if failing it will report exactly how it has failed... otherwise you have to run the test three times to ensure you have fixed all the potential issues: - oh its not got the right start... fix and run - oh its not got the right contains... fix and run - oh its not got the right end... fix and run vs - oh its not got the right start, contains and end... fix and run
As there is only one element, we don't need to use an object array.
If you test call to method reject you test method should include word reject but it include remove
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Constructor can be package now.
How about just context since we have it?
I think JPA requires this to return a Long
Should use Long.class
this.sourceType and this.sourceTypeDeep
exactly one sort key is required for RANGE units
There is no proper Url.Encode double check with @PaulStets how to encode
I love the +1 as to guarantee that there will always be a letter visible. Is there a reason for the asterisks in id vs. domain to be of different length? I might find it less confusing if my email test@example.org became something like te***@***le.org rather than te*****@***le.org.
According to the current way how those methods are implemented, it should be return false
Probably it should just return false
suggestion return getChannel(context) != null;
Switch the order of getting the mean and filtering:  java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace) .filter(x -> Math.abs(x - 1) < 0.1)
replace this with java return scopes.stream() .filter(this::matches) .map(AuthScope::getProject) .collect(toUnmodifiableList());
I would prefer a named constant for the Z-score threshold.
Check for null
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
You can use e.ordinal() instead of e.value, and remove the value field.
Capitalize Thrift (or remove the word)
is the Env.isMacOs() needed? as you pointed out to me. it would anyhow as raised it will just throw a NCDFE. Either that or we add Env.isLinux to epoll also. I agree i totally was wrong earlier. so i don't think the Env.IsMacOs is needed like you originally said.
Isn't the result always of length 4?
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
Add a period after "instead".
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
rename to childItem
Do we need to limit this to .in/.win for Makefile as we did before?
This will cause a merge conflict with #4244. Please do not change this file.
should the message include "command _with options_:" + this.options ?
Same here. Add e as an argument to the IllegalArgumentException constructor.
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
There should be an assertion I believe ;) assertTrue(conflicting.contains(...)); And probably alos useful to check that model.di and model.notation are not in conflicting state in the git repo?
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
missed one
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
;) forgot some autogeneration thing?
Possibly output a debug log message here to say that we saw a changes feed entry with an empty ID and are ignoring it.
Should this be protected, or do we really want to allow to call it outside this class?
pls. simplify it to 'return GeneratedMessageV3.class.isAssignableFrom(clazz);'
This makes the test analysis appear under all non-experiment traces (even non-test ones).
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
from the readability point it's better to divide verification by given/when/then sections
from the readability point it's better to divide verification by given/when/then sections.
use: import static org.hamcrest.CoreMatchers.instanceOf; ... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
use: import static org.hamcrest.CoreMatchers.instanceOf; ... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
This has to be reverted. This maps a SmartMeteringDevice domain value object to the same class. It also breaks the add meter functionality.
Is these method guaranteed to be called only by sync method (at least from us)?
Actually, I would like to have the settings object be immutable and go for a more functional approach (avoid side effects and make everything explicity by types). But that can wait for another PR ^^ This migth also help to get rid of the additional validator class altogher. I quickly sketched this, which captures the full logic contained in the validator: java validationRules .stream() .filter(rule -> rule.isBrokenBy(settings)) .forEach(rule -> { logger.warn(rule.getInvalidationMessage()); rule.correct(settings); });  Eventually, I would like to replace .forEach(...) with a .reduce(...) operation or the like...
The implementation of this method will never return a null element. I think the annotation is an overweight of the method. IMHO it is better to update java doc to said the method returns not null value instead of adding a runtime check on every method call.
Can just return this overloaded method's result rather than requesting the record twice.
Immutable?
This is duplicated several times.
Maybe we want to keep something similar to what id was before
The this. in getters are unnecessary too.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
You need the "." otherwise "javasucks.Class" and "androidsucks.Class" names will incorrectly return true.
Here you must call setRetryAnalyzer(....newInstance(clazz))
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Ditto here, if we have swallowed all possible exception inside close, then it is unnecessary to have another swallow here.
Capitalize Thrift (or remove the word)
s/executed/execute/g or maybe even simplify this to "An exception was thrown by a Executor"
1. Shouldn't it be new RuntimeException(e.getCause()) ? 2. Does this handle if e is IgnoreTransactionRollbackException and e.getCause() is null?
Have you considered <LINK_0>,%20java.nio.charset.Charset)
I'd rather not read all of them on the same line
System.identityHashCode would be more consistent than reader.toString in terms of making sure that the name never contains a massive chunk of information if toString serialises the entire Reader to a String
Please use static import where-ever possible
ImmutableList.of
Is there any reason that A_GR_projectName is missing there?
why public? Are we planning to use it outside of this class?
Please use CanDoActionAssertUtils.
check for null here
I'm worried that the current pretty print version of points is not only very verbose and will take more space in the index, but also that prettyPrinting is something that will change easily, and result in the need for index recreation. Perhaps we should have another method on Point for index printing that we do not need to change. The current PointValue.toString is actually a better choice, but could be copied to a different method for indexing only.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
This is another behavioral change that I don't want to see in an unrelated PR.
I think we should replace our new ArrayList<>(...) constructs with List.copyOf(...) especially when the list is immutable.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Can we inject this feature directly ?
should this count be parameterized?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
A for each loop on the listeners can be used here instead.
This combination of while and if-elses looks hard to parse. Could you simplify the logic a bit?
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
Please introduce and use an onResult hook
List#isEmpty()
List#isEmpty()
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
method reference
Why an array? List<String> is just as fine
specify array length (based on codecs.size) to optimize. <LINK_0>
Those two methods are similar. Consider using one.
I think canceling causing a pop-up message is unnecessary and a little wordy, but if you feel strongly about that, let's chat about it.
There is already a string defined with the name dialog_action_ok
License header is missing
this isn't required in these setter lines.
I don't think we'll need this anymore since it should be handled by the broadcast receiver. I'll test.
I don't think we should call abortWorkItem here as the work item most likely won't be there as it failed to execute.
Hi, you need to try to test this as well. otherwise looks good.
I think the annotations should be on separate lines
Possibly could store this in a field to avoid creating 3 objects every call
should be ofNullable
This should be ofNullable, right?
The method name has been refactored, but the log statement still uses the old name.
Shouldn't this be REQUEST_SYNCHRONIZE_TIME?
It should not say "synchronizeTime" in debug message.
wouldn't this fail if pattern was null?
You must not init here the command. You configuration page should configure the pattern provider and it will instantiate the command on demand.
The issue mentioned Single as return type.
Should you attempt Path.toFile() here?
Why does this return null?
Why this? Why you need a third state? true / false / undefined? Why not just keep it boolean.. either mask it or not... Besides.. if you really need the third option.. I would make DEFAULT_MASK_PASSWORD = null; instead of returning null here. I couldn't understand why you need it.
shouldn't be setDaemon(true)
Please take into account that t could be null.
:bulb: t.getType() could be replaced by ttype for efficiency.
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
should not be part of this patch
a new array list will be created per event here. Even with the best garbage collector in the world, he will be overwhelmed by the quantity of objects after a while... Cache the list as well
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
You don't need the ternary operator: the parenthesized boolean expression is already the result. Also, probably it should also be checked that the collaboration is a <<Protocol>> to start with.
The super() returns "" on null. Why should we differ?
It's confusing that find**Literals** returns a list of ExpressionTree and not LiteralTree. Similarly at line 157 checkEqualityAssertWithOneLiteral has an argument named ExpressionTree literal, while it can be something else than a literal (a typecast). Why not working with LiteralTree everywhere instead (extracting the literal from the cast)? (it could also enable you to avoid a second call to isNullLiteral at line 159)
Should this maybe be .map(e -> e == null ? "null" : e)?
Same for combineDisjuncts?
Could the instance var metricValues be dispensed with and the following done instead? java @Override protected void prepareMetrics() { long now = System.currentTimeMillis(); if ((lastUpdate + minimumRefreshDelay) < now) { recordValues(updateFromZookeeper()); lastUpdate = now; } }
Can't really understand what's going on here. We multiply by 1,000,000 a millisecond unit and add it as a nanosecond? (it would _probably_ make sense if we divided instead of multiply, but then why not just do now.plus(resyncPeriodInMillis, ChronoUnit.MILLIS))
Upstream is already thread-safe, so this isn't needed.
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Why is this not return this.kind == kind ?
this can be done simpler with contains method of java.util.Collection
Please verify the returned can-do-action message is VdcBllMessages.GLUSTER_TASKS_NOT_SUPPORTED_FOR_CLUSTER_LEVEL
In all the canDoActionFails* tests, you can also verify the exact error message, similar to what is done in EnableGlusterHookCommandTest assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_DOES_NOT_EXIST.toString()));
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
Just for consistency, please use final boolean actual
I'd put the magic port number of 9999 into a class-level constant.
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
this ought to call verifyNoAsyncErrors(defaultTimeoutMillis())
my sense of beauty tells me that this code should look like the following:  guard(); try { verifyReadOnlyModeSupport(); ctx.state().changeGlobalState(readOnly).get(); } ...  Perhaps, verifyReadOnlyModeSupport should be a part of ctx.state().changeGlobalState(readOnly) method, I am not sure here.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
What's up with this last one? Should it be in the finally block?
this may not be accurate, since the real interrupt happens in the loop below.
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
@xpdavid is this the right thing to do?
As in add command, no need for this to be here..
Could be simplified as: hasUnresolvedSequence(topicPartition) && sequence == this.partitionsWithUnresolvedSequences.get(topicPartition)
Could we reduce this to debug again (as in the current master)?
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Modifier 'private' is redundant for Enum constructor - needs to be removed.
safety might be to filter first stream().filter( it -> it instanceof AbstractDescribedNode)..anyMatch(it -> ((AbstractDescribedNode) it).getDescription() != null)
I think JPA requires this to return a Long
Should use Long.class
@carl-mastrangelo I wonder why we not just use: java return AsciiString.contentEquals(s1, s2);
this will trigger NPE on OffheapIncrementalIndex
I thin It is better to return int instead of Integer.
can be delegated as: putByteProperty(key(key), value)
can be delegated as: putBytesProperty(key(key), value)
I would prefer to use String.valueOf(value)
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
We should not force all of the refreshes
This is strange.
Should this method be private or protected?
assertTrue(d.isBinaryEquivalent(a));
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
Why do we need those lines? Unit tests are still green if I remove them.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
We have the two letter codes here only for backward compatibility and changing it will break it. I suggest we remove the two letter code for Japanese.
We need to mention some ref why we need to skip some of these languages.
This is not needed anymore... now you can just return id
Why can't you just return value here?
firstDigitsCardNumber is already a String
Default value is false to keep existing behavior for Mars dialogs
blank
= Iteration 2 / 10 = Actors per thread: [get(1), put(1), remove(4)] [remove(5), put(2), get(4), put(3), put(3), put(1)] [put(5), get(1), remove(5)] Exception in thread "main" java.lang.IllegalStateException: java.lang.reflect.InvocationTargetException at com.devexperts.dxlab.lincheck.LinChecker.lambda$check$0(LinChecker.java:84) ... Caused by: java.lang.NullPointerException at LockFreeSetImpl$Node.access$100(LockFreeSetImpl.java:4) at LockFreeSetImpl.contains(LockFreeSetImpl.java:65) at com.hpcourse.ees.linCheckTester.LockFreeSetCheck.get(LockFreeSetCheck.java:32) ... 36 more
should hashCode really depend either on taskName, or description, or hashCode?
Simplify using Objects.hash.
ditto on readability here:  int result = name == null ? 0 : name.hashCode();
if service is not present it should throw error? same question to the other methods
each param in its own line?
Seems like just sending an empty Map here would avoid all the null and isPresent checks later. Thoughts?
Create your own session to make the property to be true.
I'd just use a lambda here: (rowExpression, level, session) -> rowExpression
If you are going to do this do you need to @sychronize? If not indicate it is not threadsafe...
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
How about putting the condition in the 3rd param to avoid duplication?
Also inheriting CauseAction should be useful. Please have a look at NaginatorRetryAction#sceduleBuild. <LINK_0>
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
suggestion assertEscalationEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
should probably test for null delimiter and either ignore or preferably interpret null as "no delimiter" (the empty String)
General rule: no magic numbers. You might want to turn 0.01f into a static final class variable. This concept also applies to the 0.5f factors below, even if it's easier to figure out they are halving coefficients.
Using the dependency variable described above, you can collapse the registration of the transactionDependency and tsrDependency into: new CompositeDependency(this.transationDependency, this.tsrDependency).register();
this method seems to have some duplicate tests; to make it easier to read, consider creating a map between a pair of WKT shapes and a boolean indicating whether shape 1 contains shape 2, then loop over the map to test whether ST_Contains returns expected results; this way it will be easier to see which portion of the test matrix is covered and which is not and whether there are any duplicate tests.
nit: perhaps, test floating points as well: st_point(122.3, 10.55) Also, consider testing invalid WKT strings.
nit: would you test LINESTRING EMPTY?
Confused about the change of signature... what about keeping the field as Boolean for XStream, "boolean" for the methods, and then do a null check inside the body?
@tumijacob It's not a biggie, but this method return can remain as the original primitive boolean. We do prefer primitives - it's only a concern when the original value is not a primitive and can be null.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
I don't see the point of having a cancel action in a subtab.
Consider changing it to "command.getName().equals("OnRemove")" so it will fit the 'else if'
are you sure that == (as opposed to equals) is OK here?
we should log a warning here so that users who have wrong permissions on ~/.gitconfig by mistake have a chance to detect the problem
Here we should do the same null check.
> * git-for-windows seems to rely on XDG_CONFIG_HOME also on Windows Indeed it does (implementation of that function is in path.c). But I wonder if that is not a bug. I have yet to see a Windows system on which that environment variable is set :-) But OK, let's use it on Windows, too; with the same fallback.
Shouldn't this be !=?
get(). (Btw since inner is plain, this check may end up hoisted and you'd never see it turning null).
Can you please put @Override on its own line to be consistent with Spring Security code conventions? suggestion @Override public boolean isMergeEnabled() {
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
Does not make sense. It should be @Nonnull, and the weird code in launch should be cleaned up.  java try { result.setStatus(procStarter.quiet(quiet).cmds(args).envs(launchEnv).stdout(out).stderr(err).join()); return result; } finally { try { result.setOut(out.toString()); out.close(); } finally { result.setErr(err.toString()); err.close(); } }  can probably be simplified to  java result.setStatus(procStarter.quiet(quiet).cmds(args).envs(launchEnv).stdout(out).stderr(err).join()); result.setOut(out.toString()); result.setErr(err.toString()); return result;  (If join throws an exception, there is no point adjusting result. If it returns normally, we can assume stdio has been flushed. And a ByteArrayOutputStream need not be closed.)
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
be backwards compatible
I think methods like these should not be static. Anything interacting with external services (like cache here) should not be static
audit log ? setSucceeded(true) should be added IIRC
Will need a @since tag.
No parameter in setter method?
You can inject the header variable in this class too, to avoid dealing with static methods.
To remove?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
are the tabs here misformatted?
should have nonnull annotations: public @NonNull View getView(int position, View convertView, @NonNull ViewGroup parent) {
Local variable could be declared List instead of ArrayList. Is this worth caching?
Collections.emptyList() might make more sense here than null.
null? why not just a () -> {} ?
i18n?
i18n
I realize that this was like this before, but can you make this title localizable like all of the others?
This could be confusing here. How the user know the all fields?
Should we use a checked exception here?
Two tests in one method? Same for testFloatParseDefaultSuccess.
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
You can write return here instead of saving it to a local variable and return outside of try block.
can it be package private?
This should never have a null value. I need to work out how LeashData is going to work.
avoid using this in these cases.
Can we retrieve our actual gson instance? I don't care if it has to be exposed on the component level
Instead of defining this attribute, it would be better to invoke countdown for the latch (initialized in the constructor)
Better throw a SkipException to see the reason why this is not executed in the test output. this will also serve as a reminder for us that this needs to be implemented.
I would say that we don't need to have one more method here, we probably can just move  ArchetypeOutput archetypeOutput = DtoFactory.newDto(ArchetypeOutput.class); archetypeOutput.setOutput(event.getOutput()); archetypeOutput.setState(event.getState()); endpointIds.forEach(it -> transmitter.newRequest() .endpointId(it) .methodName(MAVEN_ARCHETYPE_CHANEL_OUTPUT) .paramsAsDto(archetypeOutput) .sendAndSkipResult());  here or did I miss the reason that stands by this decision?
This is used in the App: <LINK_0>
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
NIT: move these to separate lines?
what about getUniqueId() with some escaping (e.g. URL encoded)? It gives you human readable and unique strings like:  [engine:junit-jupiter]/[class:com.example.MyTest]/[test-factory:parameterizedTest()]/[dynamic-test:#3]
we could replace this with this(ID, description, Integer.MAX_VALUE);
Nitpick: Can probably remove both the if and the else (saving three lines) by starting with description = MoreObjects.firstNonNull(description, "") right at the top.
Don't call row.getDimension(dimension) twice. Please extract a small class, don't inline. It's unreadable.
Why do we need null first? If null happens, we should just crash.
Is it fair to assume that all Lists are Lists of Strings? What if the expression selector returns a long array?
For consistency, this should come from the Builder
Hm, this method was meant to contain GIN bindings for "frontend communication infra" classes, so I'd rather put AssetProvider binding elsewhere, e.g. at the end of bindCommonInfrastructure method?
Shouldn't this come from the builder?
Please remove printing to stdout
String.format might make this a little neater and easier to read.
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
use static import.
would be helpful to record the date/time here as well.
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
Use StringUtils.isNotEmpty instead
is always true
copy paste error here in these 3 lines
nit: can be final Vector<URL> resources = new Vector<>();
If this has to be a GroupReference, just take that as an argument.
This method should have default visibility too.
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
I'd like to understand the reason of this extra MutableMessage creation object before encoding...
I don't know about the prior art much, but it seems more idiomatic to use Message for everything and rely on headers to convey correlation data. Maybe a custom implementation of MessageHeaders would be better? Or just a helper that knows about specific sleuthy header names.
nit: put the whole statement on the same line; ditto other methods
Really?
any reason we are rounding up/down to the nearest integer?
Are these mock objects used?
Should remove, and use similar functionality in CoreAuthenticationTestUtils
This is not used anywhere
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
This constructor should use an explicit constructor invocation
this and m_ is redundant
I'm pretty sure BasePanel also has already the dialogServie object
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
"This method is not actually very useful and will likely be deprecated in the future."
Get the service registration reference and unregister within the deactivate method
Use Logger instead of sys out.
Can we weaken the signature to throws Exception?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
A for each loop on the listeners can be used here instead.
should this count be parameterized?
the 10000 looks like a wrong digit.
Or judge null place here ?
This line could merge with the next line, making the next line return new UID(requireNonNull(v));
declare throws please
it also throws other runtime exceptions
for me it's too long. Maybe Result.wrap() ?
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
To avoid sync problems with requestSent and eliminate additional locks you need to synchronize here on a FastSyncManager instance:  synchronize(FastSyncManager.this) { }
Has to be public? Can't be package private?
You can remove this since hasNext will call checkInvariants
Lack of synchronization on hasNext() whereas next() is synchronized looks looks very suspicious for me.
Minor: 'return new TimeSeriesValue...'
warn maybe? and not sure if we want the exception. maybe just the message?
tried to add blacklisted host {}
Very often this is TimedOutException or various Thrift-based things, though I don't know if this one is still useful for debugging?
again - encapsulation
can you please explain this fall back mechanics, why do we need it?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
constant or lineseparator from system?
This deserves a unit test.
Remove all "null" cases. There is a default case for that.
does this need to be calculated on the fly each time or can we save the iterable?
Replace arg0 with something more meaningful? And why are we planning to blow up here when, in similar functions below, it seems that we would silently ignore the null?
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
can we change a return type to int ?
This will loop forever if the user sets a negative size.
IMHO, for things like variable naming, local consistency is arguably more important than global consistency, so naming this e is best. If we make a global change, I would prefer to rename variables of type Throwable to e
Use logger?
I would think catch (Exception) is reasonable here.
Is there a reason not to check (offset == 0 && length == array.length) here, and only wrap if that's the case? Is there a performance advantage of ZeroCopyByteStringUtil.wrap(array, offset, length)?
We need to check offset + length <= arr.length?
shouldn't you do a defensive copy?
What does the above line mean?
better use a ? b : c here
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
Please use Objects.equals(...) (<LINK_0>,%20java.lang.Object%29) instead of manually check for equality.
Calendar.equals() requires an exact match, per the doc: <LINK_0> > The result is true if and only if the argument is a Calendar object of the same calendar system that represents the same time value (millisecond offset from the Epoch) under the same Calendar parameters as this object. > The Calendar parameters are the values represented by the isLenient, getFirstDayOfWeek, getMinimalDaysInFirstWeek and getTimeZone methods. If there is any difference in those parameters between the two Calendars, this method returns false. > > Use the compareTo method to compare only the time values. This is a problem because DateTimeType is not immutable, since getCalender() returns the mutable calendar member instead of a clone.
Objects.equals()?
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
should this exception be left to bubble up and fail the test ? If afterEach fails it means the repository was not shutdown properly
Should use the log, maybe a warning.
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
why retry?
return symbol != null ? symbol.qualifiedName() : "";
This iteration is not protected against ConcurrentModificationException. At least 3 possible solutions: 1. synchronize on fOtherProviders 2. only iterate if fIsLoaded is true (the list won't change anymore) 3. use a CopyOnWriteArrayList (iterate on old copy if it's being changed concurrently)
is this needed as anyhow last statement in method returns the address.
Also what happens when there is a non-ASCII character ?
The configure method is not meant to execute tests.
use try-with-resources and remove explicit close()
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
Should be 1
studentsWhoRespond -> studentsWhoResponded
You need to copy the array to have the object itself immutable.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));
Nice, but AFAIK MediaInfo is not able to parse it...
And AIFF ?
can be inlined
Shouldn't this file name change too?
Could you change this into assertEquals(expected, result) ?
I'd remove the whole guard, and simply return null (mSessionID MUST be set to null when the session has left a realm already - and of course it must be null when the transport is detached then too)
Release lock?
This message should be more descriptive. The only was for the handle to be invalid is either if: 1) There is some other thread trying to access the iterator. 2) The iterator has been previously closed. The message should reflect the above conditions.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Same feedback as other classes. check equals(), equalTo() methods in the changeset
this is for ensureConceptIsSet
I haven't looked at messages.properties, but this seems like an odd message code. (Other?)
nit: you can merge both lines above as checkNotNull will return the given argument
Is the throws InterruptedException declaration necessary?
Also unnecessary(?) throws InterruptedException declaration?
It's better to introduce Pull.STATE_OPEN and Pull.STATE_CLOSED and use them
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Why there are things that are irrelevant to this PR? Although we need sanitise field here.
CI build shows 90+ failing tests, and they all appear to be caused by this change. Perhaps some of the other converters are lossy as well, and some of the failures appear to be for objects which do not have hashCode and equals methods defined, so the comparison fails because we have distinct references before and after deserialization:  junit.framework.AssertionFailedError: <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> vs. <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> expected:<com.thoughtworks.acceptance.AttributeTest$Camera@50d640dd> but was:<com.thoughtworks.acceptance.AttributeTest$Camera@447bf09d>  Also one small nit, I would change the spacing to make the failure messages a bit easier to read: suggestion assertEquals(xstream.toXML(expected) + "\n vs.\n" + xstream.toXML(actual), expected, actual);
this does not handle the case where actual is not null but expected is, which leads to a NPE, this case should be unit tested.
suggestion if (Validate.classExists("jakarta.ejb.EJB")) {
GlobalDroneFactory is no longer loaded via SPI, so I should not registered.
Should we check if the Kiji table actually exists at this point, so that users don't have to wait until a job launches to discover they specified a non-existent table?
Can we stick to just probes? So name it scheduleProbes?
Nit: you could use System.clearProperty(...).
Possibly. You'll need to run the tests and make a determination.
Shouldn't we add the Transmit options field here?
Could be reframed using Collectors.toMap(TParameterDTO::getName, TParameterDTO::getValue)
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Define "data-agent-conf.xml" as a constant
Change this to  java return Optional.ofNullable(System.getProperty(C_T_R_D_P_K))
You should manually check if the triple's object is a value (i.e. the quads valuetype.isPresent()) and only recurse of it's not. If it is, then you should return Optional.empty if the path's size > 1 Otherwise <subj> <pred> "http://someValue"^^xsd:anyUri will then jump to <http://someValue> <otherPred> ... whereas that branch should return no value.
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I thought the default was false.
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
use return ... ? ... : ...?
This restriction only applies to the event name and parameter name. Parameter values can be any string, long, or double.
Should this return getDefault(); instead, so have the default specified in fewer places?
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
return null to make this more explicit ?
Are prepare commands with 0 modifications that common?
I'm not sure if this is a good idea, the input file could be very large and would be loaded into memory this way (the same is true for other cases in HttpApiSentenceChecler)...
This was like this before, but shouldn't we make this List<StoreConfiguration> stores = new ArrayList<StoreConfiguration>(stores.size()); instead. LinkedList should only really be used when removing or adding not from the tail.
I suppose we can pull this out to a static class constant.
try-with-resources
If instrumentation fails, then exception won't have location information due to this usage of instrument(ClassReader) instead of previously used instrument(byte[], String). Maybe simply preserve readFully?
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Its better to cleanup the Archived message on a server restart. Call deleteElapsedArchivedMessage() method if we find any archived message.
Please revise all if (LOG... statements in this PR according to [this answer](<LINK_0>
Why is this check necessary?
Likewise: can this be static? That said, I think it might be simpler to do inline at the call site: objIds.stream().map(ObjectId::name).collect(toList()); Or maybe we can make a custom matcher, something like hasObjectIds("4624442d68ee402a94364191085b77137618633e", "f900c8326a43303685c46b279b9f70411bff1a4b")
let's use LinkedHashMap
suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
Move this lambda in a private method to increase readability
50 seconds???
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
All above cases can be removed?
This list needs to include soul lantern.
You'd better use a logger here to ignore the exception or propagate the exception using Throwables.propagate
If you add setHasSubtypes(true) then different types of wires won't stack
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
this.subject = checkNotNull(subject, "subject");
this function should return something, not just print to the console.
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
If you don't think we want to expose it to the user, then I wouldn't include it at all. We can always add it later if there does seem to be a need for it. However, if this is part of building the response, then don't we need to include the version so it can be used for choosing prior versions to roll back to? Or at least, you need some kind of unique identifier for each version to enable that feature. If we don't want to expose the real primary key of that table, you could use sequential integers for each version (sorted), or something of that nature.
weight is missing from toString()
@cvrebert can we move this up?
Oh yuck. ;)
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
style nit: we don't use braces around single line blocks
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
This is apparently out of date.
change "get(key)" to "redisSet"
Shouldn't these methods be on the ResourceCollection?
lets address this as well.
suggestion blobSoftRef = (BlobSoftRef) field.get(accessPath.apply(descriptor.getReferenceInstance()));
It's strange - we are hiding exception here. Is it really correct behavior?
The stack trace should use the same level than the message.
Weird sentence structure. Why not Illegal choice for parameter foo: bar?
There's an extra { that got added here.
this requires a declared logger in ActiveMQRALogger and logger code
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Seems like just sending an empty Map here would avoid all the null and isPresent checks later. Thoughts?
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
How about replacing these four lines with:  this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp);  and then removing the TODO line?
Will queueSpinTake() ever return a null?
Maybe use constructor for this?
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
Extra space after synchronized.
Maybe these few lines of logic should be refactored into a normalizeInstanceName method?
The same Arrays.stream() can be applied here as well.
Arrays.asList().stream() can be replaced with Arrays.stream()
map(Queue::getActualName)
Wrong event name and bi value is getting passed here. It should be **VIDEOS_UNIT_DELETE**
remove ;
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
The debug logging can be removed
Perhaps single thread executor can be used here
Please update this string to say "developer mode" instead of "debug build".
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
Do we really want to move this from trace to debug?
uuid can never be null here because if EntityPlayer.getUUID(player.getGameProfile()) were to return null you'd already get a NPE in line 44. Maybe use something like java UUID uuid = EntityPlayer.getUUID(player.getGameProfile()); if(uuid == null) { uuid = EntityPlayer.getOfflineUUID(player.getName()); } if(uuid == null) { CrafttweakerAPI.logError("Could not get UUID for player " + getName()); return ""; } return uuid.toString().toLowerCase();  Also, since I don't know these vanilla methods that well, can player.getGameProfile return null, and if it can, will getUUID(null) throw an error?
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
@ivange94 please use hibernates criteria like we do in all other hibernate DAOs.
Are you sure that String.format is one of the effective ways to concatenate three strings together?
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
return List.of(new SimpleGrantedAuthority(getUser().getRole().getShortName()))
change roles for grantor
Seems to be a compilation issue here, new ArrayList<>() should be new ArrayList\<String\>()
Minor thing: please use "something <operator> null" convention.
suggestion
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is != locale.
Perhaps rename the temporary directory as well
dare to extract a constant which increases visibility for this hard-coded value?
By convention, files in Jenkins home indicate what they were based on class names. Maybe jenkins.install.InstallUtil.lastExecVersion?
please decrease or remove this statement
please decrease log level to trace or better remove statement
please remove this statement or enhance it to something more context/meaningful
:warning: requireNonNull on a nullable argument highlights that a UT is missing (could be testing that Optional.empty() is returned when argument is null)
Init the same as metadata
No need to check for null in primitives.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Again, perhaps I don't understand the Java API, but IIUC client.flush(...) is explicitly telling ES to flush all memory associated with an index to storage, and that ES tries to do this automatically. If we have to do this, then commit() is definitely the place to do it. But is it really required? Do we want to force a flush to get the durability of the write to disk?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
remove
please remove or decrease log level to TRACE
remove
Why do we have min() within max()?
This could be removed if you change verifyThatCleanupOccurred so that it tries to get the NotFoundException and if not sleeps for one second and tries again (until finally timing out after 30 seconds for example)
Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Does this now call stop asynchronously, rather than previously doing a blocking call? Should we do a .getUnchecked() as well? Or return the task?
Maybe we can just return this since we are not doing anything else in the if statement anymore.
Shouldb't be this i18m
Consider using i18n instead of hardcoding the string External Components.
Use CollationKeyFunction.NAME here instead of repeating string constant.
I think this can be set by spring application.properties without creating bean explictly.
H-m. Why don't call ThreadPoolTaskScheduler.shutdown() in the actualShutDown() instead?
nit: method name is awkward, maybe better just whenStandardClientStartsTransactionTimes? Also goes for all the subsequent methods
I guess this will overflow maximum instructions per method before FIELDS_PER_CLASS is reached? Again, I wonder if it would be good to generate multiple companion classes.
System.out.format instead?
INITMETHOD_ACC works here, as the JVM ignores everything beside the ACC_STATIC flag. What about a separate CLINIT_ACC constant?
Use KeyboardShortcuts.CREATE_RIGHT_PANEL?
looks like you don't need these three variables at all. Just use this at line 41?  java List<String> boardNames = TestController.getUI().getPanelControl().getAllBoardNames();  You can probably follow it up with this (not sure)  java assertEquals(boardNames, Arrays.asList(new String[]{SAMPLE_BOARD})
assertEquals(org.apache.log4j.Level.ERROR, event.getLevel());
Should also include context and suspend
Missing earlyMessageRejectionPeriod
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
FullTextSettings.closeAll appears to handle it's own synch needs, no need to mark this method as synch
Shouldn't we clear LoggerAdaptor#loggerMap here?
call tearDown on laggards operator
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
I believe the Sanitizer call is not needed here.
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
One last question. So we get and forget the returned result?
Rather than extract body and headers from HttpComponentsClientHttpRequest, we should have a toRequestProducer on that class instead, which contains all this code together with createReactiveEntityProducer below, and which returns a BasicRequestProducer. That way, all we have to do here is invoke that method.
@stefanbirkner I question using LinkedList here, because I understand that ArrayList, the main alternative, usually performs better on modern hardware because it can better exploit processor caches due to it using an array internally, whereas LinkedList cannot due to it using pointers.
are you sure that == (as opposed to equals) is OK here?
I don't see the point of having a cancel action in a subtab.
Is this the value we use for all other protocols?
Position position position.position. Hmm maybe there's a better name for some of these :thinking: Just thinking aloud, not the end of the world :+1:
This whole block can be simplified, no? You're effectively checking for negative health twice now.
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
Please just use a mod here...
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
add this selector to UI mapping at the beginning
why callback is null
abort is out of place here.
replace PutBlobOptionsBuilder().build() with PutBlobOptions.DEFAULT?
These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
Shouldn't requestLayout be called on the perspSwitcherToolbar Control directly, instead of the Shell?
Minor inconsistency: Return type is Boolean and not primitive boolean
because of synchronization, iterator() returns a slower implementation. So should be better to keep raw StepIterator
These are only used by Group. What's the motivation for defining them in Control? Will they be used by other widgets also?
Use isZKLogAvailable() instead
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Why delete this line?
Shouldn't we throw here?
It is the same in this line, leave a blanck space before "+"
All actions from
Shouldn't it be priority - Thread.MIN_PRIORITY (which is the same as priority - 1, but just by accident)?
How about quoting the offending value: "Unexpected NICE_VALUES.length=" + NICE_VALUES.length ?
I am a bit confused that this check will be called on almost every line of code.
I think this should just return null, similar to the default MyFaces implementation of InjectionProvider.
The cast is not needed
Never access FMLClientHandler (or FMLServerHandler for that matter, which breaks the whole game) directly. Use FMLCommonHandler.
what happened to handling of nullables?
maybe just replace all these error codes by default block since we are doing nothing for any other error code
Unsupported type:
return tags;
Could we return an empty map instead of null so this method doesn't have to be @Nullable?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I haven't investigated what exactly this does, but it looks a bit weird. I can understand if by default the logging level should not be DEBUG or so, but I would definitely like to see errors and probably also warnings by default (i.e. without having to investigate how to change this manually). Please disregard if I missed something.
We need to throw a BriefcaseException here. Returning null doesn't make sense in a ValueObject
I think it would be better to change the @ to : here.
We can replace this with: return date.getTime() / TimeUnit.DAYS.toMillis(1);
what if fParser != this? shouldn't this be fParser.createTimestamp
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
Lol! You're going to remove that, right :)
The new line police is upset.
Matchers.is
Sort of believe We should have MetricManager in parameter given this case.
Please tag this as a FetcherTest (because it relies on the network connection)
Why is this change necessary?
Could this relatively general code be reused in the needsOrderBy method?
add a message
should we swap method parametrr orders above?
> "When providing an 'async-rest-template'... Correct? To properly reflect the reality.
Why change from the constant to a literal here?
You can't parse to an Integer here - it might still be a property placeholder; let the context property editors take care of it.
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
I think, it's better to transfer a method parameters and keep a name at a previous position.
Using newIllegalStateException() which can format a string would make the above code more compact.
You could simply turn this into !isEmpty()
is there a reason for StringBuffer instead of StringBuilder?
I do not think you need the fully qualified name here.
You can make this a bit cleaner by calling data.isData() and data.isHole().
Actually, why does verifyPrivileges() part of get*PageData() method? If this method is narrated, it would be something like:  I want to get the *PageData, so I first verify if I have the privileges, then ...  While not entirely wrong, consider moving it to execute() instead. The narration becomes:  I want to execute this action, so I first verify if I have the privileges, then ...  Which makes much more sense. It also removes the need for you to have an empty verifyPrivileges() method. This also applies for one in ImageUploadAction.
Can you please rewrite this to use a new key class? Doing this has quite a high overhead. [Here's an example fixed version of the old LiquidContainerRegistry.](<LINK_0>
We might want to actually make isRebasing() a method in RepositoryState.
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
Looks like unnecessary microoptimization to use SearchKeywordResolver[2] instead of new ArrayList<>(2) which does pretty much the same as rest of code below. Is the impact actually measured?
dont think a setter type function should return the "this"
EMPTY_ARRAY was not good enough :)
Why static?
can this be readSafely instead of readBuffer so that read uses readSafely
I'd suggest logging the exception here, might be useful for debugging. Probably include a message indicating the consequences (the punch table may not be updated until the first user transaction).
This is not going to compile. You can't return an object in a void method.
We could throw an UnsupportedException here.
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
assertTrue(annotationMetadataMongo.isDefault());
Even though is ok to check the chromosomes the variants should be checked as well
Better to create a new set, rather than update the super set. The super set might (and should, I think) be immutable.
I'd use getPathAsString instead of getName to provide unambiguous info.
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
Somewhat counterintuitively, I don't think this specific call actually should be app restricted. If the case model changes, it should invalidate caches around that case model regardless of which app produced them.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
super.init() method never throw an exception.
This class is not thread safe. Using synchronized here is unnecessary and I think it is also misleading.
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
So this will be used for quantity and duration too or you need separate ones?
Is there any other ID we have in relation to an envelope? Why do we need a longer name in this context?
That looks like a code duplicate. Let's discuss how to do that better.
Can we please use Stringifiers on it? It'd be cool to know a type as well, not just a UUID value.
why do we need to make this method final and none of the others?
Symmetry (throw)?
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Gson doesn't run on these versions so I don't see any reason to include them.
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
remove printlns before this is merged
This should probably go to System.err, as goes e.printStackTrace()
Do we need to print all this info?
You can do it in one line. More lisibility.
Update the logs with correct messages
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
You can also use IO.close(bb) as IO.close will not throw any exception.
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
What is this for? Feels like some unintended checked in code?
why that ? I think internalCommit() returns true if a job was scheduled
Would it be appropriate to add some logger.warn() statements to these two IFs, to make more explicit what's happening, both here in the code and at runtime?
won't exit the loop. You need to return here
these should be 2 separate tests
Do we want a space here before the brackets?
I don't think the process deploy should fail in the case of temp file deletion fail
bad hashcode.
why are we casting to "int" ? it the value is a "long" we must return a "long" or we have to handle the overflow some way
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
Is that down-cast required?
Can this constructor used only in tests move to package private?
You could have inlined this loop into the other method because this will create 3000 threads.
This should be obtained from the i18n file in case there is a language specific reference. The solution should actually provide some guidance, this CS could be added to the references.
Should be hardcoded?
This should be obtained from the i18n file in case there's a language specific reference.
Should this be compared with || instead of &&?
no public
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
vus always has lastEdit?
Could use StringUtils.capitalize("your string")
suggestion AlterationUtils.getVUS(alteration).contains(alteration);
this.redisTemplate
StringUtils.isEmptry(XXX) if possible
Possible NPE here unless I am mistaken -- there may be no defaultValue.
This should be synchronized
You must cancel request on both 2 senders because, for the same registration you could have pending request in queuemode and not queuemode (as binding mode can change) (I agree this Far-fetched but I see no problem to just call cancelPendingRequests on both sender)
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
Symmetry (throw)?
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
does eventTypeService.get throw other exceptions?
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
Can this be private, or is there another use case for default attribute outside the builder's call?
suggestion bean.setSourceList(new ArrayList<>());
No reason to find @StreamEmitter annotation if !method.isBridge(). OTOH ReflectionUtils.doWithMethods() has second MethodFilter argument. And there is ReflectionUtils.USER_DECLARED_METHODS on the matter to simplify your MethodCallback impl.
Not sure if that is critical right now or will be possible according your TODO, but the bean can be proxy coming to this BPP, therefore won't be instanceof for class. Only interfaces are possible here. Or something like this:  Class<?> targetClass = bean.getClass(); if (AopUtils.isAopProxy(bean) { targetClass = AopUtils.getTargetClass(this.handler); } boolean replyMessageHandler = AbstractReplyProducingMessageHandler.class.isAssignableFrom(targetClass);
does this happen or is it an error? Maybe just throw an exception.
Where does the 5 come from? I feel like we should just throw an exception here.
Probably should use combineDegree - 1 instead of hard-coded 1 here?
These ones too.
You can call this.setTimestamp(timestamp) from here.
nit: I think in this case it would be easier with FeatureMatcher  public static Matcher<Watermark> watermark(long timestamp) { return new FeatureMatcher<Watermark, Long>( equalTo(timestamp), "a watermark with value", "value of watermark" ) { @Override protected Long featureValueOf(Watermark actual) { return actual.getTimestamp(); } }; }
remove when the export button is implemented
Don't throw the exception. It causes a lot of exception stack traces printed on the screen and stored in the .log file. It would be easy for the user to miss the usage message that is printed as well. I suggest, to find a different way to exit the application. Can't you just call CliParserManager.getInstance().parse(Platform.getCommandLineArgs()); in Application.java and exit if needed? I don't see the reason why it's done in the activator class.
please add activator ID in error message or a description of the conflict
Can header name and value be null?
Class and constructor can be package-private as only used internally.
No need for super()
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
can you reference the enum values here?
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
other than the previous implementation in subclasses this doesn't create the directory anymore.
can this be a constant string?
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
Are there mandatory parameters which require validation?
do "getEntity(id);" here to throw 404 if this is not existent entity
Initialize this in the field declaration
Can be simplified to cacheManager != null && cacheManager.getCacheManagerConfiguration().globalJmxStatistics().enabled()
We always put "XXX is null" as the error message for requireNonNull
I think the "if" is the wrong way around here. Or more precisely, we must always do the super.decrementInstallCount() The way to test if super.decrementInstallCount() is working as expected is: 1) insert breakpoint, observe it is a blue dot, no check mark 2) start debug session, the breakpoint should change to a check mark 3) Stop debug session and breakpoint should become a dot again.
Is this going to be correct if there is a loop added in the transaction as well? I'm suspecting Direction.OUTGOING is the graphdb semantics which should include loops.
Same as for outgoing, I think this augment will also include loops.
you forgot to inline into one liner method as moti suggested on patch #1 .. :-) other than that - looks good to me.
My understanding is a 'synchronized' block will be slower, but I cannot really say how much in case of AHC.
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
pls format (>120 chars)
so do not resolve groups and no recursive as you going to search it anyway.
u can simply use System.out.printf("Please enter a password for %s:",user);
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
Looks like it will have next format  SystemServiceItemStoppedEvent{item='1', ....} class org.eclipse.che.api.system.shared.event.service.SystemServiceItemStoppedEvent {evenType='someType',...}  I'd rewrite it with using getters from super class
Printing the query as keys will look something like: ... keys=[IndexQuery.ExistsPredicate[propertyKeyId=0]]. I think it is worth extracting the actual keys from the queries and only print those.
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
return new StringBuilder().append()....toString();
You could also use -> Objects.toStringHelper() from guava
.event() is might be better
I really don't like this convention because it means that we can no longer rename-refactor the identifiers without changing the meaning of the program. It is in effect a very subtle kind of reflection. So I would prefer a distinct string field in this case and others like it. I realize that there's lots of this kind of thing in OCS, but we should fix it when we encounter it. Does this make sense?
this should be: CLUSTER_UPGRADE_INIT_EVENT.event() or CLUSTER_UPGRADE_INIT_EVENT.selector()
Use config.getTrimmedStrings() instead?
Files.createTempDirectory?
can this throw an specific exception.
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
Send this exception to the log.
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
I'm probably stupid, but I can not get this code. Each time when one call subscribeForCursorsReset() there will be cursorResetCache built. call for isCursorResetInProgress is dependent on previous call. (and btw do not work all the time, cause StartingState is initialized before StreamingState)
I think this should not be executable if the review is not open
simplify this
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
style nit: we don't use braces around single line blocks
suggestion if (this.currentTask != null) checkAndRethrow();
The aforementioned "never return null" rule would be good for all the string getters here.
we prob want to default to something generic
getUsername().isEqual() make the same thing ?
audit log ? setSucceeded(true) should be added IIRC
We could throw an UnsupportedException here.
Will need a @since tag.
Can you add getId() and mark id() as deprecated?
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
Please check if it is non null and running before you cancel it.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
not needed, empty c'tor is just for satisfying gwt. its modifier can be reduced.
Do we really need this? It's implicit
There is no need to call super explicitly. Same applies to other constructors.
Does mean there's no signal for "the user typing out a correct entry, not clicking on the entry in the list, and then clicking on the next question" which results in the value being set? Clicking the ">" or swiping would do it, since that triggers a "get answer", but I wonder if, say, losing focus should also attempt to set it?
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
the superclass implementation seems to expect action may be null, also the super implementation also has some logic about whether the context is active. I don't know that we need this since our plugin XML is checking that property.
No need of this. Its marked as @NotNull.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
The setup of updatedKeyStorage is not needed if fireOnlyUpdatedPanes is false.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Missing types
IntelliJ says the type parameters are not needed
It's hard to read the multi line string. it's better to rewrote it by using **String.format()** method.
Please, express if it is permanent or random in error message:  Known permanent failure <LINK_1>
<LINK_0>
please use Assertion class
nit: you can merge both lines above as checkNotNull will return the given argument
Optional should be used in interfaces. Use null as internal value.
nice - thanks!
When pressing the remove button, the directory is not removed. In my case it was the last directory.
Uhhh I think this uses the local default filesystem to resolve that filename, which isn't necessarily what you want.
Would it make sense to add something this.caches.clear() to the stop ?
Add a proper log message.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
Add a message to checkState so that it's easier to debug if we ever hit it.
It looks like constant, extract please :)
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
@ILikeToNguyen Why the change in visibility here?
IOException is enough same as in mapToJson
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
MessageQueue.RegisterBankAccount_EventMessage
IMO while would be better here
why the double poll here? should this use drain instead ?
these are both a bit sketchy cases where compiler should have issued lint message warning: non-varargs call of varargs method with inexact argument type for last parameter;
From @blickly I think this should be Fingerprint2
If we make this quoted prop 'a', we'll get a test of that new case. After that can you squash the commits into one? Other than that, LGTM
throw exception
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
final ![200x200](<LINK_0>
Am explanation would be nice
Use new Hashtable<>
you are adding these three anyway in the bind(String principalName, String password, List<SocketInfo> ldapServers, Hashtable<String, String> props) method.
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
If the buffer isn't reused, then it is safe to cache a copy of the bytes and use it each time unsafe is called rather than copying all the time.
return HConstants.EMPTY_BYTE_ARRAY; ?
Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in ClusterManagerCallback.
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
should this filter out null resources? (ie. bad paths)
What about testing with ALTER FUNCTION sin ... instead?
Why does this have a specific line position but the others don't? I think it's fine to use a specific position for all of them, and that would be more consistent with the other tests in this class.
Why does the newline have three backslashes in front of it, but the other control characters only two?
@fuss86 we probably need to check that there were no exceptions here.
Minor: Maybe remove the type bound if it's not used?
nit: this could be reverted.
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
This list needs to include soul lantern.
can return Optional from here
I think we already fetch a full list of slaves somewhere before this. Each of these would be a zk call currently. So, we should either: - Add slaveManager stuff to leader cache so this is all in memory or - Pass through a list of slave data we have already read from zk for use here
Aren't these args backwards?
So, would the PII information be provided as plain text? If so, isn't that a security concern?
@JonathanGiles, was there guidance in the past to use Iterable or Collection instead of List as it is more flexible?
This will cause a null pointer exception if text is null. You should not be calling "trim" here. Please remove the trim() statement. "publish" methods should not alter the data that they are publishing.
please instantiate the list right above the check where it is used.
please move list initialization to where it is used.
let's rename final PromoDialog asyncPromoDialog to final PromoDialog gbInformativeDialog
suggestion return Objects.equals(caseRoles, other.caseRoles) && Objects.equals(caseFileVariables, other.caseFileVariables);
could be simplified as return (o instanceof LFUEvictionPolicyComparator);
pls use Objects.equals for comparison
This is hacky and might be error-prone. Since it is always a leaf node, it makes more sense to parse the string with path splitter "/" and return the last section.
Args.notNull
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
You should determine if you need a regression model in the scheduler
You might want to get and ACK about the execution of the operation, because otherwise it is really complex to control the behaviour of the distributed system.
false? Why not null?
Since a SAML Attribute map can have multiple values, the type here should be Map<String, List<Object>>.
With the recent writer change, I don't think this needs to be exposed any longer.
Do not assign to n. Let the compiler verify we set n in both branches below.
The value of the PGT never starts out with PGTIOU. That's a different attribute. You want to check for PGT- instead.
Whether the argument is a string or not, it should be convertable to JSON - why not just always run it through the JSON parser?
"[\W]", "_" looks simpler
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
nit: suggestion log.error("User [%s] had role [%s], but role object was not found.", user.getName(), roleName);
Is there reason for throws Exception in signature?
maybe, would not be keeping the map null better, to ensure uninitialized mapper will not be used accidentally? (even NPE is better then complex debugging why roles are not mapped...)
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
If it is clearer then method name clear looks more natural for me than remove
you're not the author of this code but still, it may be useful to add exception or message to logger.
you could be more specific and check instance of Function0 maybe?
Can this happen ?
Clone method is wrong. Kernel/stride/padding are already handled in superclass clone. And it doesn't set depth multiplier.
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
:ant: multicast is one word.
:question: do you need to do line 187 (final SolrClient c = client;)?
"0"?
"0"?
Consider Arrays.asList(
nitpick: There's an extra space after the =
Why do we need it? :smile_cat:
In accordance with similar changes maybe better to use Optional?
If the parameters were changed to (Processor processor, String key ...) there would be no need to create the List and unpack it.
If the string retrieved from hashtagTextBox is "#test1,#test2", you will only remove the hashtag from the first hashtag. Perhaps do the check in the RESTApi instead?
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
you can either remove else or add pair of curly brackets
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Will * <LINK_0> * <LINK_1> work as well?
why not just use currentBlock.write(text) here?
Not source compatible IIRC (javac fails when there is a catch block for impossible exception), may impact PCT. There are usages of it externally, e.g. in the Support Core plugin: <LINK_0> I would propose to detach it to a separate PR if you feel it's important enough
Why not single cast here?
These should refer to constants rather than the string literals.
else is rendudant
<LINK_0>
can you add mountPath here
The exception should actually be the fourth argument to the method so that it is logged as the causing exception with a full stack trace - we should never throw away debugging data. Also, the class name has changed, so the log message could lead a debugging developer astray if they are not paying close attention to the stack trace.
This is backwards. It should be log.warn(ex, ex.getMessage()).
Why not just use fixture?
You can make this method private
run already called tally, so do you need to call it again?
This method can give an incorrect result if the last buffer is moved from the inner queue (which is then empty) to the output buffer (which was previously empty) in between those two calls.
It is save to return false? Should we rather throw an IllegalStateException ?
final?
isRemote(command.getKey()) instead of false
leftover from debugging?
From the point of async store, it is not necessary to have the *function* serializable but the resulting entry. So the check does not belong here. The same holds for compute commands.
VertexInfo vs NodeTopologyEntity.
There are no backward compatibility concerns in toString(), please change the key.
virtualColumns and descending go in different order elsewhere in this class
I'd use startsWith(prefix), rather than calling this constructor directly.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Maybe make it unmodifiable?
Can we get the root class as a generic parameter of the aggregate class or, more straightforward, the repository class? If we can, we won't need to accept it as a constructor parameter.
Well, you could make BeanAttributesConfiguratorImpl.qualifiers and types package-private and use something like:  throw BeanLogger.LOG.noCallbackSpecifiedForCustomBean("Configurator [types: " + Formats.formatTypes(attributes.types) + ", qualifiers: " + Formats.formatAnnotations(attributes.qualifiers) + "]");  Hm, BeanAttributesConfiguratorImpl.types should be final - pls add this change too.
AggregateRoot is not an Entity.
Can we and should we check that the short index is shorter than the long index?
JDBC
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
Objects.hashCode could have been used here
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
Here you could use Objects.hashCode(name, uri);, right now it's taking the hash code of a hash code.
Continuation of the comme?t on line #242 - Please notice 'messageLabel' and 'externalLabel' doesn't have representation in the model. The fields you're manipulating in 'onPhysicalNetworkChange()' do have, so please move this logic to the model.
Maybe it would be better to move it to localization
Why this needs to be hidden?
Agree with you. We will probably test this on different level.
suggestion super(() -> name);
!reason.isEmpty() can be used
Why it's "EXTERNALVIEW"?
this is confusing, it is called router but actually it is routerUrl.
Doesn't String.format need a value to be formatted?
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
You can use Layout.INVALID_CLUSTER_ID
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
remove local variable
Remove the if check and simply return getFirstElement
Okay then I will apply a patch for your proposed bug report.
t1 shows up as unused variable, please remove the assignment.
Yes, unless there's something I'm missing the constructor could be private.
Can make this into a singleton as we have with UNSET.
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
looks like directory separator is missing here
This no longer needs to be public, that was only for MergeOp.
Shouldn't this still call through to the native implementation?
And check for null here before sending the cues to the listener.
No use checking if the list contains() before remove(), let's avoid double iterations.
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
Again, getMessage() should be replaced with a more informative error
Again, getMessage() can return null. Please replace with a more informative error message.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
Since this is a String, perhaps you could use Collections.nCopies
We should probably do this in a finally block.
The original commons-codec MurmurHash3.hash128 (like the Guava code) has a sign extension issue with the seed value. Since the seed is 104729 (for some reason) the hashes will work correctly. However a fair amount of work has gone into commons-codec recently and v 1.14 fixes the issue. Because of the change several of the MurmurHash3.hash128(x) methods have been deprecated. It is probably cleaner to call MurmurHash3.hash128x86( input, 0, input.length, MurmurHash3.DEFAULT_SEED) or MurmurHash3.hash128x86( input, 0, input.length, 104729L)
remove this extra line
To always be safe please use context.getApplicationContext()
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
@fanifieiev the same above.
This line should be shifted 4 chars left.
@ikhvostenkov why not codec.decode(codec.encode(identity)) ?
no reason to explicitly set to null, its default behavior
A post-processor with neither NsURI nor resourceURI is totally useless; which makes this constructor a very misleading implementation. It'll basically create a post-processor which only use is to occupy memory and time (when we loop over it). This is the "UML" post-processor, and we already have a default contribution with an hard-coded URI in the plugin.xml. We can set a more sensible default NsURI than that. Change the call to super(Pattern.compile("<LINK_0>\d.0.0/UML"), null) ... or remove this constructor altogether.
As is the case for the UMLDiffExtensionPostProcessor, this creates a totally useless post-processor. Change the call so that it reflects the plugin.xml declaration : super(Pattern.compile("<LINK_0>\d.\d.\d/notation"), null);
Don't need last else
Probably this should return 0 when doubles[index] == null && NullHandling.replaceWithDefault() == true? Otherwise it probably should throw an exception.
Met List:  @Override public boolean inputIsConnected(int index) { return index < inputs.size() && inputs.get(index).isFullyConnected(); }
Can you reduce the nesting depth here?
The pattern is to have the init before the try: AdminClient client = AdminClient.create(getDefaultAdminProperties()); try { ... } finally { client.close(); // no need to check for null if the factory never returns null } But if AdminClient is AutoCloseable you can just use try-with-resources.
Okay this is better where it can self-heal and reconnect. Fix checkstyle issue however!
I would suggest using the related constant instead.
I would suggest using the related constant instead.
Why uppercase fs?
There is also StringUtils.removeStart for that
Can you duplicate the logic from getDiscriminatorWithoutTimestamp here (ie leave getDiscriminator as it was). getDiscriminator is called a lot and any performance we can squeeze out the better.
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
Agree with you. We will probably test this on different level.
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
I think it is unnecessary to use synchronized here
Is try-catch needed here?
Log the exception to error.
Same here. Simple call to filter() is more readable
Please consider having a method overloading for the case there is no volume name.
this will be written every 5 sec (by default) i think its better in debug
It might be helpful to use different min/max values for bounding box so we can test the order is correct.  peliasWithMock.search("test", "1", "2", "3", "4", "5", "6", callback);
this smells... never use NULL, never ever :)
Please add an element instead of using a spy
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
this doesn't need to be public.
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
Can the connection or the context be null at this point?
Can the body be extracted together with commit() method to avoid code duplication?
Likewise, this should probably be /rest/script/sessions, and the sessions controller should be updated. The restlet framework handled servlet paths differently from the MVC framework I believe. Either way, you should verify in a 2.11 geoserver with script installed to be sure of the correct path.
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
Minor typo in first sentence of error message.
nit, Collections.EMPTY_MAP?
finalize?
@stefanbirkner I question using LinkedList here, because I understand that ArrayList, the main alternative, usually performs better on modern hardware because it can better exploit processor caches due to it using an array internally, whereas LinkedList cannot due to it using pointers.
This doesn't compile and should return locations.
Can throw Exception from tests.
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
would it be better to use isNotBlank here?
Shouldn't this be using the parameter value lookup for CONCUR_CUSTOMER_PROFILE_GROUP_ID?
Unneccessary
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.test.shared.TimeoutUtil#adjust to adjust the time of this test?
It is completely implausible that compile returns null if it didn't in testPattern01. So this check is redundant and should be omitted.
are you sure you want to search for translated tags only, don't you think it could be better to search for the tags value and the translated tags ?
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
Was thinking about collisions here, <LINK_0>, theres about ~1% probability of collision in 10k tables, but we are fine I think (except for the large internal product that is creating and truncating tables). We can take a 16 character substring?
static
Is this method really needed? It's similar to make init public
i do not think we need to save this line better make it more readable
Another method reset has a bug:  /** {@inheritDoc} */ @Override public void reset() { cntr = new HitRateMetricImpl(cntr.rateTimeInterval, cntr.size); }  cntr value must be copied to a local variable in order to avoid data races.
"missing labels in its"
I wonder if this should be more of an error. For the Repository to exist but the ProjectState not to seems bad.
I think it'd be simpler if you left the .map unnested from the .flatmap, like this:  return serverWebExchange.getFormData() .flatMap(formData -> voteRepository.save(new Vote(formData.getFirst("team")))) .map(vote -> String.format( "Vote successfully cast for '%s' at time %s!%n", vote.candidate, vote.timeCast));
!= -1
what's the intent of this change?
please fix whitespace
Looks ugly and potentially a source of future NPEs.
There's a formatting issue.
Should close kill the memspace? What if someone want to reopen the key?
40?
A data provider with a single entry is questionable. I was thinking the versions would be separate test cases in the provider (you'd have to duplicate the test string which is fine, and probably putting the getBytes call into the test method body) .That way, you could eliminate the rtCheck loop, and maybe the whole method.
Please add ? and % as well
Why doesn't the following method fit this test suite?  public static TestCommandFactory newInstance(Class<?> testClass)
Could you check for null or empty? Via StringUtils.isBlank
We could call: java checkNotNull("command", command);  :-)
This can now be deleted.
Set the httpclient in pipeline instead.
Same question as above
add this (also below)
does it have to be public?
extract duplicate regex to constant
This duplicate detection doesn't work for version-less features. I think a better check would be (idEqual && (version-less || versionEqual)) --> If you want to add multiple versions of a feature, you need to enter a version for the first one before adding the second. WDYT?
version == null should be bfeature.getVersion() == null --> the candidate feature always has a version, only the site feature may be version-less
please use {}
Please chain the method calls: java return new URIBuilder(BASIC_SEARCH_URL)) .addParameter("query", query) .addParameter("sort", "score") .build() .toURL();
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
Maybe we should add the core name here.
I still don't comprehend this approach - the class is used for interceptors, I get that much. We don't want/need post contruct callbacks there. What I don't get, is why we still invoke them? Putting System.out in postConstruct will trigger it. That is IMO not intended
These should include a helpful message. It is never a good idea to throw an exception with no message. Some code will strip out the stack trace and leave just the message (which is also a bad practice) and this would cause that to produce just null. It's also helpful to explain a little more why this exception was thrown, "compare(boolean,boolean) was called on a non-boolean comparator"
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
Should be done before opening a db session - for to fail fast.
I'm not sure it's worth sharing this method checking permissions: 1. the call to checkLoggedIn should be the first call in method handle so that we don't do any SQL when user is not logged in 2. this leave method checkQProfileAdminPermission with a single method call which is hardly useful to factor
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to a method called toOrganization which really should be static
Maybe use an uppercase in the text: 'Thread sleep was interrupted'.
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
LoggerUtils.logErrorWithStackTrace(LOG, e.getMessage(), e) ?
Ow damn, I broke Partitioned Search without realizing it because we clearly have no test coverage for it.
try using getOrCompute instead. Besides delaying creation of the collection to the moment where a key actually wasn't found, it also stored the result in the map, making it somewhat faster for consecutive invocations.
I prefer shorter method names, when the important information can be said by the argument type - which is the case here. LGTM.
instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
You could use StringUtils.endsWith(str, suffix), since it's null safe.  java return StringUtils.endsWith(version, SNAPSHOT);
Let's go for 422 then ;)
public?
I'm missing the new field in the toString method.
You can simplify this by reordering the states.
we need the modulo here, right?
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
you should also check that log contains GIT_COMMIT is
And why would you do that to begin with?
What is this proving? If you  groovy sh 'cat /any/file/at/all'  your log will contain  + cat /any/file/at/all
why is this return null??
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Update labels to go with method names. Alternately, call super.toString for super attributes
WTF is lala
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
similar
please use static import for Mockito
Should remove, and use similar functionality in CoreAuthenticationTestUtils
Should remove, and use similar functionality in CoreAuthenticationTestUtils
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
Is there any chance for the three conditions, some of these them are true and others are false?
should either read: "Must set either both SslSocketFactory and TrustManager, or neither" or "Must set either both sslSocketFactory and trustManager, or neither"
Make secrets an immutable list if present.
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
can these parameters be grouped into smaller and more meaningful objects?
There seems to be an output change here: original: Base32.encode("a".getBytes()) => "ME" new: Base32.encode("a".getBytes()) => "ME======" We might need omitPadding() to ensure this is an exact drop in replacement.
You could static import getMimeDecoder to match the other file
Better: new String[fExtensionErrorParsers.size()]
Why show the 'MoveUp' button by default?
return true? no need to inform the user he sent wrong vm (vm doesnt exist), or other issues?
Shouldn't this be reverted?
?? why this and the following ones could be left empty?
factory must close its cursor (which is closeable)
audit log ? setSucceeded(true) should be added IIRC
Make this private and implement a builder?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Why WARN for FAIR and INFO for other unknown entities?
throw exception
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
This is redundant.
Check this before calling get.
Remove redundant assertions.
@vzool one more printStackTrace ?
close the stream in finally block
Please don't print stack trace like that. Either log it properly or ignore if the information is useless.
I suspect that this bring in an XSS vulnerability. If for example the VM name you are about to delete contains some HTML (or JS), and you try to e.g. delete it, this dialog would interpret this HTML (JS). Please use something like SafeHtmlUtils.fromString(message).asString().replace("\n", "<br/>") or something like this.
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
would be helpful to record the date/time here as well.
Can you look at the resource test i pointed you in the ticket description and then put some thing in these method bodies? You can even just copy some ideas from the pull request i pointed you to done by one of your team members.
return newObject; and not null
There is a bug here --> returnedValue = contribution.updateCreatedObject(returnedValue, loadedVersion);
Unnecessary call to super()
Unnecessary call to super
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
This will basically do:  clearMapStore(); clearLockStore(); clearIndexedData(false); storage.clear(isDuringShutdown); mutationObserver.onClear();  The problem here is that we are clearing the data from the lock store and calling onClear for the mutation observers, one of which is the event journal. During reset, each service should clear only the data which it owns. This means that the LockService is responsible for clearing locks and the RingbufferService is resposible for clearing event journals. I also see this method is now calling clearIndexedData. Was that the leak?
Does this method need to be public?
this should go to super.reset(), shouldn't it?
does the order not matter ? is sorting not something UI should do rather than the model ?
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Please include clientTelemetryEnabled in toString() API
Here and above, can we have strings defined as constants?
Please remove the maverick ";"
braces
Consider getting this value once, and save it, instead of calling it twice.
the same, why not use method reference?
perhaps vds load blanacer
I think getExtras() is nullable, so we should handle that case.
The link member should be removed and this line may be replaced with:  java return this.baseStyleGuideLink + this.name;
checkNotNull(pattern), too?
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: java.io.IOException, java.util.concurrent.TimeoutException, org.osgp.adapter.protocol.dlms.exceptions.ProtocolAdapterException [![rule](<LINK_2>](<LINK_0>
The method getConfigurationObjectDto(DlmsConnectionHolder) can get called from both the GetConfigurationObjectCommandExecutor and the SetConfigurationObjectCommandExecutor. The description that is set on the DLMS message listener starts with "SetConfigurationObject", which would be confusing when called getting the configuration object.
You can remove 'throws ProtocolAdapterException'
Will this always be this value?
Can't we inject this in the constructor, instead of having an unused get and assertion for this set.
similar to above; fix this so it actually tests something or at least does not fail.
another log that can be removed (I know it's not part of your commit, but please do it anyway).
Why was if (!CameraManager.getInstance().hasCurrentCameraFlash()) not enough?
If you're not using the return value of compareAndSet, then just set will do just fine.
constant
nit: you can merge both lines above as checkNotNull will return the given argument
URL instead?
why 40 as a limit?
adding analysis_uuid column in the migration called "make ce task uuid column nullable" is not wise, imho at least, it is highly misleading
Can you please tell me where this variable is used?
I'm missing the new field in the toString method.
Can this be private, or is there another use case for default attribute outside the builder's call?
Please keep this.cell near the related fields (previousFamily & cell count) below
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
use error message as in startMemoryRevoking
Instead of repeating the addition assign it to a value on the stack.
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorizationWithoutAuthentication(PROCESS_DEFINITION, ONE_TASK_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
new Error -> new RuntimeException
public isn't needed
Can we have a test that sorting on 2 fields? 1 is metric and 1 is dimension.
pvk should not be visible. Please remove it.
hashCode -> System.identityHashCode
I'm not sure if I want to have this line output and each ID prefixed with spaces. My preference would be to just have one ID per line, without any prefixes. That way the output could be piped to other processes without parsing out the pretty printing. This is basically [plumbing vs porcelain](<LINK_0> distinction.
A question: Omitting the map.isEmpty() check is intended? Overrided default method does the check but here only a null check is done.
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
ArrayUtils.isNotEmpty(doc_string) so empty string is treated as no doc_string
Prefer [java.nio.Files#createDirectories(Path dir, FileAttribute<?>... attrs)](<LINK_1>,%20java.nio.file.attribute.FileAttribute...%29) (and maybe [java.nio.Files#notExists(Path path, LinkOption... options)](<LINK_0>,%20java.nio.file.LinkOption...%29) on the line above, although this has slightly different semantics)
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
path.endsWith('/')
Please use P.lazy(u -> f.f(a)
could be final.
could be final.
Why is it a list of lists, not just a list?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
suggestion ((WordPress) requireActivity().getApplication()).component().inject(this);  This getActivity() can be requireActivity().
Are both of these lines required? I'd have expected we'd only need the attachBaseContext
Why are we configuring drawer in this activity. This activity shouldn't have it.
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
what if period << difference?
I would change this "#get()" to something more meaningful, like "there is nothing here, use has() first, to check"
DimensionSelector is closer to be an "object" selector, then numeric. So I think this method should just return false. Indeed, it couldn't return null from getLong/Double/Float, but it *could* return null from it's getObject().
So we lose the typing on CacheContainerAdmin, should we define that on this method or as a generic on CacheContainer at least?
I fail to see the difference to the previous test. Is there any?
Can you use an anonymous name for the maintainer? Not something from production
Would you mind improving this test to use executeFile() instead of executeString()?
Why is it a list of lists, not just a list?
There already are tests for CollectionCopyModels in TestSerializableCollectionCopyModel and TestGenericEntityCollectionCopyModel. If you removed GenericEntityArrayListModel, this test (TestSuiteGenericEntityCollectionModel) should have gone away. If you simply deprecated GenericEntityArrayListModel, then the tests should have stayed the same (since GenericEntityArrayListModel is still used, we still want to ensure it works properly). Same goes for other models. Could you please fix that?
Here an exception should be thrown if we have a conflict
While we're renaming, might as well remove that extra _.
"==" to "="
How about just context since we have it?
You can use mapToLong here and then sum()
This TODO in the logs is a little confusing. How about putting something in the code instead and creating an issue?
I think this check can be stronger. Rather than checking the comparator's equality, why not check the underlying type? This check would allow merging stats for binary and binary/UTF8 types, but I don't think that's right.
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
The super constructor throws an IAE, so why not mark this one, that the IAE could be thrown? Wouldn't it be helpful for the caller of the constructor to know that this runtime exception could be thrown?
this seems misnamed
+ desc
The description is incorrect. Should be something along the lines of "clean up empty pubmed id entries"
Maybe remove references to versions here? You could change this to: "Migrates pom.xml files to format compatible with KIE Maven build." @porcelli WDYT?
Won't fix.
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
This is not correct, orderGroup and sortWeight need to be copied too, this should stay unchanged instead you update Order.copy to copy over these fields too
Copy this value from the previous and ensure the previous' value isn't null
You need a null check here and just return null immediately, you should not be calling addToDate with a null value
Let's avoid raw types, please.
What are key/value types ? Map<String, String> ?
I think this should return a Class<? extends Map>.
"Called only after a call to prepareEntities" Might be worth adding a flag to enforce this; I'm guessing this could be unpleasant to debug if someone tried to manipulate entities before they were ready.
I think you have failing tests because this isn't true. The HashBasedIndex coerces all numbers to doubles, and thus looses precision.
I'd say if the entry is present, the command is not successful.
Consider returning a constant
Missing codes.
These arrays could be defined statically in this class, as to not create a new array every time this method is called.
sortParameters.size() - 1 could be computed only once and result stored in a variable that is used in the loop. Curly braces around _if_ please :)
' ' should be enough, no need for a String object
Do we really need 10M ? Isn't 1MB or 500K enough for the sake of the test?
I thought this was to be debug to prevent unwanted data from appearing in the log.
should this have a ,  to match the rest of the pattern?
shardSpecFactory -> partialShardSpec. Lombok would be nice and hide all of this away :)
Or can just be omitted: java protected ToolDescriptor() {}
Does any of these have to be protected?
Is it ECDSA or EDCSA?
probably worth using a linkedlist here as well, although I doubt allocating 10 ints makes much difference though compared to other stuff we do
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
style nit: we don't use braces around single line blocks
you could just do setConfirmWindow(null); like above method
This isn't really public API so no need to deprecate, just modify the method.
You want to use FormField.getFirstValue() here and everywhere below.
public isn't needed
leftovers from StatusDTOTest. just return input; is enough here since this DTO has no primitives.
return Collections.emptyList();
I don't see the api for CosmosContianer (sync version). could you please add that too.
There is only one form indeed and a Flux read makes no sense but the method can produce a Flux, i.e. Flux.from(readMono(..)), even if it will never have more than one element..
This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.
What if the result is null? Should we check it?
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
There's no reason to box.
if you inverse the condition you can get rid of the if/else
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
I missed this one before, but if (!eventString.isEmpty())
hmm, really not sure about a cache. The aspects are not necessarily "immutable" for a given event. Calling resolve at one point may not yield the same result as calling it later, so I don't think we should cache them. Every class that calls .resolve() could only call it once and "cache" its value though. About possibly merging the two methods: If we look at the use case here, for example the classes using a TmfCpuAspect, basically what they all do comes back to: "Go through all the aspects of this trace, find me a TmfCpuAspect that returns a valid non-null value, gimme this value". Couldn't we have one utility method that does just that? It could even be specific to a TmfCpuAspect (and derived classes) too!
getTrace() being a UfTrace you are painting yourself in a corner here. Like for the TraceEventEvent thing, this provider works only on UfTrace trace, not uftrace-like events implementing the same semantic. But it does not need to be fixed right now. But it should be kept in mind for later.
Should be !socket.isValid()
get the preprocessedEnvironmentConfig and pass that along instead of finding it in all three functions.
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
I guess we could just assert without the temporary result variable.
I guess we could just assert without the temporary variable.
I think this should also be able to lookup the membership with the matching patient and remove it so that a call like the one below works too: Cohort.removeMembership(new CohortMembership(Context.getPatientService().getPatient(patientId)))
There is a better way to do this, WorldServer holds a Map of 'entitiesByUuid' which you can use to directly lookup the entity.
You cannot @Override this method to implement the method from the interface because after obfuscation it will get the srg name. Please consult [the mixin examples](<LINK_0> for how to deal with conflicting methods with the **same** signature/name. _EDIT: actually never mind, I just noticed that the MCP name has an uppercase "ID" while the sponge method has the Pascal-cased "Id" so it's all fine._
Braces
How is this expression different from "this"?
nitpick: just return <cond> sufficient
I have found a bug in this latest patch. The line 107 should be modified so it considers the RefRight.ALL value is "refs/*" but a RefControl instance to "refs/*" would have its refName member value equals to "refs/". So, the correct code to 107th line would be: if (!RefRight.ALL.substring(0, RefRight.ALL.length() - 1).equals(getRefName()) && getProjectControl().isOwner())
Why is it a list of lists, not just a list?
Local variable could be declared List instead of ArrayList. Is this worth caching?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
what about setting the permissions for that?
to be on the safe side, I would add the permission, also if getVm() == null (same as last action group, lines 862-866)
this part: new Guid(getParameters().getEvent().getVdsId().toString()) should be replaced with: getParameters().getEvent().getVdsId()
Please keep lines < 80 chars.
Same here, use config.getMessageTimestampName() directly where appropriate.
It is a Secor coding convention not to extract config values in the constructor but rather call config.getX() where appropriate. There may be a small performance penalty of this approach but I prefer it due to reduction of the number of object variables.
you don't need to check for null since this gets set in the constructor
Not ImageJ style.
You'll probably want to do the other closes even if the prior closes throw IOException
Please add a note why this cant be implemented right now
This will probably be permanently unsupported.
@komaz maybe for now we can just return empty iterable, there is no need to react so strongly about missing implementation.
double checking - do we have coverage for this case?
The object passed as the last parameter of MethodRule.apply() needs to be the test instance, not the test class. The only way to get it is to have the caller pass in the test instance into the TestRuleAdapter constructor.
I would expect that the annotation would overrule the default, even if it is smaller.
I believe you can and should add the same wait for verifyByZkCallback too. The logic of verifyByZkCallback is that 1. subscribe to changes. 2. no matter if change happens, verify the state for once. 3. if subscription results in some notification, then verify in parallel. 4. any of the paths succeed, then the verify succeeds. In this case, we shall wait until the first subscribe to ensure the waitTillVerify config takes effect. This won't cause any problem with verifying logic. Since if the change happens before we subscribe, we are still fine because the first default verify check will be done once at least.
Declared exception from update method can be removed as well as this try-catch block.
Why isn't the exception being passed into the error call to capture the stack trace of exception?
Remove this if block. We can move check for instance HasNewPresentation  into below if.
Remove empty line
Maybe better to return null
Call setFocus() on the table control.
handleExceptions();?
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
index < arguments.size() ?
I think we should also check for empty or whitespace only strings.
Preferably have one call the other?
Should this return the AzureTable?
Seems we can do this via a null check of the return value of remove ? else this isn't atomic.
Could you please remove all the unnecessary super. and this. ? Thanks!
Should this return the AzureTable?
is there a reason why this method isn't implemented?
We should use the spring.application.name boot property instead of the applicationContext.getId.
Why is this being created this way instead of using the listener correctly? This implies that the deprication doesn't make sense in the first place...
check for not null in parameters.
I would say use a flag  @garrettjonesgoogle thoughts?
This is very odd; not the sort of thing you should catch. Can this be prevented?
Create a new connection every time you send a ShuffleControlMessage?
code style
Now it's <code>@CheckForNull</code>
Add this qualifier: this.logicalDevices
Similarly
Should the override annotation be on a separate line (not sure of the convention in this codebase)?
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
Simpler: ArrayList<T> result = new ArrayList<>(collection);
Could you rename variables to make the purpose more obvious? Like: newHandlers = handlerMap.merge(address, handlers, (oldHandlers, h) -> oldHandlers.add(h.first())) At least do not use current for the second var of the remapping function.
This would not be a performance improvement. (And a tab character has appeared in the file.)
Same here. Consider just propagating the current exception.
Keep the first part of the original message too: "No hardware profile matching the given criteria was found. If you want to use exact values, please set the minCores, minRam and minDisk to positive values"
setConfig too?
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
As this if became quite complex, I did small exercise and tried to refactor <LINK_0>, please let me know what do you think about changes I propose.
And ATMOS ?
Are we sure that deleting entries in this entire **range** is safe/correct? I notice previously, this code only cleaned up Item, Collection and Community (range "2 TO 4"). Now, it's cleaning up "2 TO 11", which also includes Site, Group, and EPerson (seemingly by accident). Does, this need to be updated to clean "2 TO 4" (like original code) **and** "8 TO 11" (new objects)?
May split this up and make function calls on object
implements Constants
We can make DestroyProxyMessageTask implement the Supplier, so that this method will no create a lamda but return this instead.
why this is in vmCommand? should be in stopBase command
Could this repeated logic in message tasks & member-side map proxy be hidden within MapOperationProvider eg:  MapOperation createPutIfAbsentOperation(String name, Data dataKey, Data value, long ttl, long maxIdle) { if (ttl == DEFAULT_TTL) { return new PutIfAbsentOperation(..); } else { return new PutIfAbsentWithExpiryOperation(..); } }
since this happens before canDoAction, getVdsGroup() can be null
actually Yair reminded me that we do have the method isInternalExecution() that is true when command calls another, because it (should always) use runInternalAction
It get lock on the georep session in one case. But in else case, it will get the lock on the cluster level. Is it the expected behavior?
Should be done in the setup. Note this re-occurs in all your test methods
Maybe we can compare the whole object instead of just checksum?
assertNull
throw exception
In case self is a BufferedIterator should this return self instead of re-wrapping?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
You're not making defensive copies of the Set, how do you know that it's immutable?
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
You can use the String.join method that was introduced in java 8 to do this.
The empty string here is redundent
Should this string literal be a constant?
this doesn't fit on 1 line?
We should use **File.separator** for Windows compatibility.
Is that a valid station ID? Judging from the results of nearby stations, station IDs seem all to be prefixed with OAW:SP:.
Could you change this into assertEquals(expected, result) ?
It seems this method does similar thing 3 times - if a new method, e.g. "assertImageViaUIClient" were introduced, it would prevent code duplication.
I think we should depend on the fact that this is an instance of EmptyByteBuf... just check it's not readable and release it
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
remove extra empty line.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Please remove an excessive space character.
Reason should be optional.
Add character limit check - #2105
I think this should return Collections.emptyList() if args.length is over 1 (this will remove player auto-completion, which is not necessary here)
I thought this diff was about moving to Aggregation not away from it.
checking for nullable parent was added specially, cause going into project node simply has no meaning
node.getDistributionType() == SpatialJoinNode.DistributionType.REPLICATED
Can we use [!StringUtils.isBlank(versionSTring)](<LINK_0> to increase readability?
whitespace, but prefer if you don't change existing code style
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
I think you can get rid of the first condition now, due to the change above.
This is probably safe because of how the code above behaves but there's a risk of problems later if it changes. Can you make a constant somewhere representing the KList separator and then use that in all three places here?
What about "fail[]".length() instead of 5?
String.format
channelId => channelName
minor: don't need this. qualifiers
warning: The static field AbstractProcessor.logger should be accessed in a static way.
Do you want to rename the fields, too?
I wonder if this should be an atomic operation?
Seems like we could just use DefaultReplicaView. Similarly below.
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
Why that read() has to be under lock? We only need to protect usage of the "position" field (or even make it atomic instead) and let actual read() / write() concurrency to be taken care of by underlying FileChannel.
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
This must be supported.
This should return a BitSet.
why the addAll()?
I don't know why that logic was there, looping over all the the datasetPhenotypes. This is a nice improvement :+1:
+ desc
Missing NLS
Maybe remove references to versions here? You could change this to: "Migrates pom.xml files to format compatible with KIE Maven build." @porcelli WDYT?
nitpick: don't need keyword public
Would be nice to have all operator-specs being created consistently - instead of using statics for some and constructors for others. Also, would be great to do this as a separate clean-up so that it does not detract from the core-focus of this PR
Are these type annotations required?
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
@manstis pls replace with for-loop (or parallel stream) for performance
This exposes the unicode workaround to the public.
new ArrayList<>(causes);
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Why is it a list of lists, not just a list?
nit: For list with just one element, I think we could just make it in one line (unless it's too long..)
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
Why to return false in this case? I don't expect this to happen, but if the cfg is deleted (by deleting the refs/meta/config branch) then the default submit type applies which could be different than the submit type that was set in the old config. This is why I think it should rather return true here?
update metrics as before.
did I miss something there? why the requestTimeNanos is Long.MAX_VALUE?
other != null is redundant with other instanceof Module, which already returns false when other is null.
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
It's a little more concise and easier to follow like this:  if (other instanceof Principal ) { if (other == this) return true; if ( this.getName().equals(everyone)) return true; Principal that = (Principal)other; return this.getName().equals(that.getName()); } return false;
Is this still necessary? And saving the thread in general?
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
We should clear the list too, to not keep references to the threads longer than needed (ideally the thread/parser would remove itself once done too).
When will the write mode be DIRECT_TO_TARGET_EXISTING_DIRECTORY after the change?
I am curious about how temporaryRoot get formed on line 563. Does that mean if the targetPath is hdfs://path/to/your/table, then temporaryRoot will be hdfs://path/to/your/table/tmp/presto-userid/ ? I thought temporary path should be something like hdfs://tmp/presto-userid ?...
Redundant local variable, just return new ElasticsearchTableDescription(...)
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
Either module or this "fancy" sarosXYZ name, but do not mix it up, see all other methods.
![MAJOR](<LINK_0> Make this line start at column 7. [![rule](<LINK_2>](<LINK_1>
throw an error
lookup in the multimap here
If you annotate the interface methods you don't need to repeat them here (we have to setting to inherit annotations).
Can you have an @After method that unbinds this connection. This is more reliable.
Remove ExternalUserIdUpdateHandler, both onSuccess and onFailure are blank.
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
Use Arrays.asList instead.
I am reading the class again again and I think we do not need sourceColumnIndex to be class variable. I think we can keep its scope just in the for loop. Then I think the only usage of sourceColumnIndex can be replaced by columnIndex.
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
Should stay consistent with the rest of the params. java public VideoDecoder( final EventPublisher eventPublisher, final VideoDecoderConfig config, final String broadcast ) { ...
Please make this variable final
you can't get here with vm == null, so it should be removed from here.
since saving-state and restoring-state cannot be reported after MigratingTo, I guess we can simply change isRunning to isRunningOrPaused
given that specificity of this SV is exception type I would add the exceptionType in this.
@override and function declaration must be at same line.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Remove "TestAggregateIdFactory" as this method is already static-imported
Same "{field: null}" remark here
I like using the magic number 1 here so we know the value is not that magical and we don't need any Checkstyle suppression. I think I came across 42 in a test yesterday that was amusing but also a little distracting.
Fantastic coverage, thank you!
Looks like an invalid assertion - not passing in the name argument
nit: move config up as it's the first constructor parameter
static ?
I'm curious about the design choice that requires a new object to be instantiated for every basic operation. This seems potentially inefficient if these operations have to be performed many times.
Actually the underlying objectExpr could have free variables.
Change the getter so you don't need the cast
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
use streaming:  outputChannels.stream() .map(channel -> sourceTypes::get) .collect(toImmutableList());
although its nice to use java8 optionals. sometimes its easier to read old fashioned if null checks.
(as before, we should use the constants)
I forget the original intention behind this findFirst(), but thinking about it now, I think anyMatch() is a bit more sane
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
It is often good to change '=' things to constants. and this line has formatting issue
There is no proper Url.Encode double check with @PaulStets how to encode
"image provider ID == image ID"? Is that correct? And make protected rather than private?
style nit: we don't use braces around single line blocks
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
Could use '/' and ']' to avoid the need for extra NON-NLS
"The parameter " + parameterName + "not match with " + ParameterHelper.PATTERN
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
This whole block can be replaced with functional style Java, as per example given in Epdq.
This whole block can be replaced with functional style Java, as per example given in Epdq.
Hmm, this is going to blow up if there isn't a provider session ID for some reason. In practice, there should be, but I think I would prefer it the absence of a value meant the cookie wasn't sent at all. This will probably still result in the authorisation failing but it will be handled by our existing code authorisation errors, which is fairly graceful and cleans things up.
You'll probably want to do the other closes even if the prior closes throw IOException
Should close this even if lineIterator fails to close.
cannot be null.
This actually could be return !isEmpty(triggerId) || !isEmpty(triggerIds);
That's not very clear: if doResolve does return null, it most likely means that the CodeMining doesn't require resolution, so isResolved should be true. The implementation seems erroneous here. This may be caused by resolveFuture == null which can mean 2 different things: either the future wasn't requested yet, or the future was requested and null was returned (ie no resolution required). I believe you need some more details or another state variable in the class to distinguish both cases.
A question: Omitting the map.isEmpty() check is intended? Overrided default method does the check but here only a null check is done.
I would suggest reverting the isSytemLibrary field back
Can you use parser.getCurrentToken() to detect JSON type ?
:-1: for magic number
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
A flip != 180 rotation
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
If this should never happen throw an IllegalArgumentException instead.
return collection ? to avoid to create array
I suggest to change this signature to Iterator. Currently we use listDDFs() in a loop condition: for(ddf : listDDFS()) { ...} so it's better to return Iterator here.
i see in a lot of places "QueryImpl" is used, even "Query" is sufficient, whenever possible go down the the interface that is sufficient. by using "Query" you make the code more flexible.
Why are you assigning 0 to numElementOnPage, as you assign some value again in the next line?
log error
it is better to call client() here, since the Docker may be available but the checks are failing suggestion client();
alias is count but the function is sum
This nice plan nesting looks like you mean a specific query plan (joining tree) shape. Is it guaranteed? See com.facebook.presto.SystemSessionProperties#REORDER_JOINS
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
extra ()
Args.notNull
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
AFAIK Writer::close throws IOException, so there is posibility that exception is thrown by flush method will be suppressed.
I would wrap each close in a separate ry-catch to make sure that they and the executor shutdown all get attempted.
let's update all the includeTextDetails references to includeTextContent
No need to train if test is to check for null model Id?
Same here. No need to train, if we are not going to use the training result.
Why do you not rename your extracted method's parameters appropriately?
Extract a method for this. (You now have two 'ends with ".erl"' checks in your code)
- [x] What does this do since this is not building Java? Is this just copied from another project that this code is based on?
Cosmetic: Our loggers across the codebase are lowercase. Could you please change this? Thanks! :)
I would always suggest logging the full exception at DEBUG level for troubleshooting.
As a nit, should have a null guard here.
Why don't we make inDegrees to ConcurrentHashMap also?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Looks like index type is not persisted and not taken into account in hashCode/equals, so basically all deserialized index configs are of SORTED type.
This should have been:  this.out.close();
Please consider writing a class version number (e.g. 1) as part of SerDe in case this is ever stored on disk.
Move to a separate commit
Can we put this function after all the other field declarations? This looks a little messy.
Timestamps have no unit ?
I'd say "block end cannot be before block start"
Can the current implementation of SimpleInterval represent an unmapped interval? If so, how?
Two suggestions here: 1. You lost a linebreak I think. 2. use getOrDefault instead of the ternary.
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
all logger.error should use (String, Throwable)
I am wondering where is it better to add this check here or inside RexBuilder#makeFieldAccess. Clients who call RexBuilder direclty will still get the NPE.
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
this should be true when index == 0 to allow optimizations for this particular case.
Geometry is comparable?
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
In any event, since we're on Java7, just: new HashSet<>();
Formatting of ( DirectCompilerResult... sets ), should be (DirectCompilerResult... sets).
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
would be nice for the 4 to be a constant for readability
WithTasksContext
.. and here, we don't need .toString() if we make it a PROFILING_MODE instead.
I think you mean "Liquid Glass"
Magic numbers?
missed two
Similarly use the Java 7 template
Instead of the Guava Objects.hashCode, use Objects.hash instead. It is available since Java 7, and reduces our dependencies to Guava (furthermore, this method is not available in Guava 21 :) ).
Probably enough to have Longs.hashCode(pointer) which should be a little faster.
any reason for the double 'max' ?
what if 4*vmBase.getMemSizeMb() > maxOfMaxMemorySize ?
can we just compute the compatibility version differently and still have a single call to addSoundDevice?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
done for patch3.
Please keep this.cell near the related fields (previousFamily & cell count) below
Nit: Unnecessary extra level of indentation.
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Let's transform message to string at once, not in the getter.
Activity state util check before starting any of this, maybe?
Hey @oguzkocer, these Account settings update calls feel strange be initiated here. I think the helper methods here in ActivityLauncher.java should only launch the activities without too much business logic. May I suggest moving the update calls either closer to the caller or in the Activities themselves? Cheers!
ParkingPositionLayer - delete
Do we need the above line? What happens if we get rid of it?
This needs to tests returning multiple cash points for a single location.
Why is this necessary
Generic type not used, remove.
The call to notNull is redundant, ImmutableMap.copyOf will blow up if refs is null.
should we swap method parametrr orders above?
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
provider -> buildProvider(provider) -> this::buildProvider
Space after cast.
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
value is never null
could we use a descriptive value instead of empty string to denote the header was null?
We could remove this if we add the parser module to the list of modules in the api metadata. Better to have the complete list there?
This probably needs to be .asEagerSingleton() as otherwise it may be pruned (nobody will depend on it, it's a leaf)
side note to bringing in this dep, installing this module would also likely start up a number of pollers/db connections/zk connections/etc which we don't want
Please keep the indentation consistent.
This should also test that the value matches one of those considered acceptable.
The directory must be readable.
Should me make it default and use Objects.requireNonNull? The logic of the setter is a bit unexpected
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Pager builder can be replaced by Pager.single().
This should be "test-client-id", and is simpler anyway when I eliminate ClientIdentification.
Again, just return the boolean value.
The "brackets for single statements" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.
Add a check for the number of warnings
Same as clean_after_checkout: is there no test possible that highlights the difference between clean_after/before_checkout ?
We already have a list of FS objects we should use that here.
This breaks the contract of HashMap which allows the key to be null. StringUtils.toLowerCase(null) will throw an NPE
Missing @Override annotations?
> I feel like site_id here makes more sense just because the only use of it is for the network calls. If it's used for network calls, it's not "local". Local_id was used for blogs/sites because we can have a mixture of self hosted and wordpress.com sites, so we can't use the id provided by a network response. Will this be used for wpcom sites only?
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
Would prefer String.valueOf(previousDecl.getLocation()) as getLocation can return null.
remove
I know this default is here for backwards-compatibility but I'm not sure about the value. If I create a factory - "OffsetDateTimeFactory" - I wouldn't want that to be the logicalType name. In other words, what do you think about the default implementation being: default String getTypeName() { throw new UnsupportedOperationException(); }  This way it is required by any new LogicalTypeFactory to implement it?
Is it really filter name?
If this is intrinsic, needs to be prefixed.
waitUntilContainerStarted is executed by .start(), no need to do it here
As you attach this class here I highly suggest to implement Startable or move this handler into application scope.
I understand that this is quick and simple fix, but as experience shows we can't rely on the system clock: no guarantee that CPU will get access to the target process exactly after this timeout. In the end we are going to have sporadic test failures. The best way to sleep with short period and check the state of the component we would like to assert afterward. If you have some argument to proceed with this simple sleep, let me know here. Thanks
I'd suggest parsing the week from "MMM" to "MMMM" even in this case. TalkBack is smart in English and it reads automatically the full month name, however it works only with some languages (doesn't work with Czech).
Do you want to make the check that portFields is of size 2?
For loop?
I don't think it should be renamed
Can this happen ?
Use "gerrit". The internal server plugin name is "gerrit".
I think we will have to discuss whether or not to include the fromKafka functions in this class.
just return "" instead of new String()
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
J) we should use chamberId instead of divisionId. There is only coincidence that divisionId is equal chamberId.
use new Guid(String) - this literal can't be null
rename to clusters
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
I would remove the boolean and put this after the activateMenus() above. Since we only need to call it once.
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
nit: Intellij recommends using setProperty() instead of put(). I guess it's because the parameter type is more strict.
why do you need config temp variable?
Does this test fail without the change?
Strange naming. There is datastorePath and dsPath ? Maybe store dsPath as Path and use dsPath.resolve(applicationName.getValue()) and then dsPath.toAbsolutePath().toString() when needed.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
This doesn't check that ok has the value true, just that it exists, and it isn't null
I don't think setLenient(boolean) is needed. Based on the docs at <LINK_0> I think and have tested that the tests will work just fine without it. How about removing it ?
Now when we change handleException method in commcare controller we should also change getting message value from response in javascript handlers as you did below for other ones. Please find all handlers that can be affected by your changes and fix it
If you're not using these vars more than once, might as well inline them.
Looks like we need only keys of the map, not the whole map.
you're not the author of this code but still, it may be useful to add exception or message to logger.
What is this log statement for, exactly? Seems like a trace?
Is there a chance of a NPE? could be getFile() null?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
nit: You could have a private method that takes a preparedStatement and invokes executeQuery() on it. That way you can also put the metrics logic in that method.
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Please use the StringJoiner toString()s found elsewhere.
minor: can you regenerate toString to reflect the renamed variables.
toString() not needed
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Generics on the right side are redundant since Java7
@ILikeToNguyen Why the change in visibility here?
this seems dangerous, any reason not to manually construct the array as you did above?
I can't decide if StringBuilder is overkill. Seems like String concatenation is enough. What do you think @christiangoudreau?
This should be indented and/or parenthesis around the body of the for loop. Also the pair should be appended not concatenated to a string and then appended. builder.append("CompleteTransactionTasks: ").append(pair); The output of this will be a bit strange because there are no separators between the different completion strings. Maybe append a comma and space or something between the task strings.
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
Integer.parseInt
In what scenarios is this actually possible ?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
RuntimeServiceException is better, as some tools will warn if we use a bare RuntimeException.
Files.asCharSource(file, UTF8).read()
This can be made final
This is in a test and we know what we argument we pass (never null) so if (expected.isEmpty()) is enough.
Personally, I'd prefer to format it like digests elsewhere as <hash>/<size>. WDYT?
I think we should keep the instance of check in this method. Meaning this method should never exception of even if the object is not of the right type.
We need to check offset + length <= arr.length?
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
Why is it a list of lists, not just a list?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Please use ? ternary operator
Please use ? ternary operator
are you sure we need to use OSString ?
Default the member variable to Proxy.NOPROXY. Never mutate or translate a value in a getter, it breaks all expectations that the caller will have. This one breaks the relationship between the get and set.  options.getProxy(null); if (options.getProxy() != null) System.out.println("Whut?!");
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
We should also refactor this field as it no longer holds a BoundaryProxy but a IBoundaryStrategy
You need to remove the client.close() below too since this test class is using @AfterClass for closing client
can be extracted "/v1/api/charges"
GATEWAY_ACCOUNT_ID may be
Comparing with [TestExecutionResult](<LINK_0> shouldn't this Constructor be private?
If the expectation is that this always get built from Bugsnag.buildReport we should remove the public here to make this package protected. This will enforce the API usage which will make it easier to maintain and refactor in the future.
you can have a private base constructor, and have both call it with different parameters.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
add something like checkState(lookupSourceNotNeeded.isPresent(), "Lookup source built, but xxxx not set");
Unsigned types are not used in the current implementation. So, you can omit them.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the ".create()". The applyTo version is also shorter. Change this to: GridDataFactory.fillDefaults().align(SWT.BEGINNING, SWT.CENTER).applyTo(l);
Should this variable be renamed to control?
this should return parent2
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
good multi-thread catch
Good change... but use applyTo() rather than create() when attaching to a control. Change it to: GridLayoutFactory.fillDefaults().applyTo(shell).
What happened to this method? Why isn't it a private anymore?
This payloadTypeCache must go to the MessageSerializationUtils directly. I see you have something similar in the JavaClassMimeTypeUtils for the mimeTypesCache. So, why don't be consistent?
Why just don't expose a local variable for both storedMessage.getHeaders().getId() calls? We won't need this // NOSONAR and won't spend time for more method calls.
The classical hack is to implement read() like this: byte[] b = new byte[1]; int n = read(b); return n == 1 ? b[0] & 0xff : -1; Its almost never used and this form is short and easy to read.
Not sure how expensive buf.readableBytes() can be, but readableBytes is already calculated as a local.
Just use inCoreLimit here. Don't convert units to MiBs.
do not expose the list directly
It would be better to use... suggestion public @CheckForNull Hashtable<String,RangeSet> getUsages() {  Nullable is a soft requirement which does not trigger warnings in static analysis tools
again I think you can use the diamond operator
wouldn't it be more flexible to allow to set the authenticated flag instead of always returning true in the MockEndpoint?
Why support amend during bisect?
no, this.running must there anyway. Or we can rely on the this.contextStopped variable...
This and line 59 can be a global variable to clean up tests a bit
task.get() will throw a NoSuchElementException if the task doesn't exist. is that what you want? wouldn't it be better to return an empty string?
This can be static.
You're not closing DataOutputStream. Check SparseVectorCodec too.
@fanifieiev the same above.
@dmzaytsev let's replace this with a try-with-resources - JsonWriter is Closeable, so I think it might work. If not, let's close it in a finally block
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
The Scan constructor throws IOE now?? Not an issue for this patch, though
AS should suggest turning this into a ternary
Is it possible, that the context is null?
Noticed that the builder should be sent into the NotificationPresenter.showNotification().
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
is this needed as anyhow last statement in method returns the address.
same as for AddAddress here
please use diamond on the right side <> (no need to redeclare the type)
redundant line break?
This should probably be removed
NoSuchElementException is more accurate
log() so that log.html viewer knows what image was chosen
Maybe /accessTokens/ should be a constant defined in this class? Not a show stopper - just a thought
Why iv.removeValue(i, this) and not iv.removeValue(i, aCause)?
This implementation looks correct to me, but I think it should have its own unit test, to be sure, and to prevent regressions. I think testing all the boundary cases for arrays of length 1, 2, and 3, would be sufficient to cover all possible cases. (i == 0, i == a.len-1, and 0 < i < a.len-1)
java return state.getValue(POWERED) ? 1 : 0;
This code repeats in multiple places. Until we replace Slice, please keep the code in SliceUtil or another central place.
Minor, but I think this is redundant; the put below will overwrite the current value.
How does this work when an item is evicted from the underlying cache, but is still in locker?
this shouldn't have been here either, format is required.
need to handle case where fieldMapping is a macro, so output schema is not available in configurePipeline
are there any format properties that are required by some formats and optional for others? If so, this can run into errors
Is there a reason not to initialize this where it's declared?
This method is going to make N roundtrips to ZK where N's the number of unique task prefixes in the cluster. This number is close to 1500 in one of our bigger change capture clusters atm. Just calling this out in case extended lock cleanup duration could cause issues.
Don't we have to say that this is uniqueId JDBC?
This is a change of behavior. Some tests might not require all nodes to be up and trying to enforce that here seems like a stricter check. The earlier check createKVS can succeed if we have quorum too. We can perhaps have a classRule in the test classes to disableAutoCompaction if thats the first thing to do? Does this nodetool command require the node to be up first?
Same as above: Can we use AtlasDbConstants.DEFAULT_INITIALIZE_ASYNC?
nit: the return true; statement could be moved inside the try block.
instead of setEngineSessionId - why not having it at ctor?
just noticed... the key cannot be soft limit if session id is null, please remove condition. anyway, even if so, this condition is unneeded complexity as bellow the key is set anyway.
please reformat. the line is too long.
Should this property be moved out of the splitDeveloper namespace?
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Neater on one line, like the if below? for i in {1..x}; do
studentsWhoRespond -> studentsWhoResponded
Don't we have to say that this is uniqueId JDBC?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
i18n?
i18n
I realize that this was like this before, but can you make this title localizable like all of the others?
I don't see you overriding this in your Bounded implementation, why make this protected?
We try to remove the Globals class. Is it possible to insert the stateManager via a constructor parameter?
Should we be concerned that the expireTask can be reset after this synchronized block completes? Whose cancels the Future in that case?
Why not test and assign instance directly rather than passing it through local?
The incore merger works in memory without a working tree. Does he need attribute handling?
This isn't necessary. When you need the inserter call getObjectInserter(). Your super class manages allocation and release for you.
In this case we ALSO want to include the "if it keeps happening, talk to the person who asked you to collect data" message. I think just concatenating the two with a space would be fine (and concat does the right thing with LTR languages, I believe)
I'm almost tending to use VRaptor specific exceptions for this case, instead of reusing IllegalArg and IllegalState... We're doing this only because of validations, right? We could create a ValidationFailedException.
Recommend to rename move to decrypting to be more meaningful.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
We should probably throw a TTransportException wrapping this, right?
nit: you can merge both lines above as checkNotNull will return the given argument
does this need to be a class member?
Should there be another method for instances when you already have the MetricRegistry? I am using Dropwizard where a metrics registry is created by the framework and I would like to make that instance the default. As proposed:  java SharedMetricRegistries.add("default", bootstrap.getMetricRegistry()); SharedMetricRegistries.setDefault("default");  With the overloaded setDefault method.  java SharedMetricRegistries.setDefault("default", bootstrap.getMetricRegistry());
Typo? "BlobDet4acryptionCount"
To be consistent with AbstractAssert.isEqualTo, this assertion should pass when both actual and expected are null. a possible implementation would be to make sameInstantInActualTimeZone return null when given null.
Use hasToString assert
it makes more sense to either use the constants defined or something like CUSTOM_CLIENT_EXCEPTION.getMessage()
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
add something like checkState(lookupSourceNotNeeded.isPresent(), "Lookup source built, but xxxx not set");
Unsigned types are not used in the current implementation. So, you can omit them.
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Why is secondary always false here?
To improve, I think .warn is better.
Shouldn't it br something the reverse condition getActivePage() != getPageCount() - 1? I think you'd rather extract the expression getActivePage() == getPageCount() - 1 to a dedicated isActiveTabTextualEditor() method so it makes things clearer. There is also an occurence on line 94.
this. for consistency
Shouldn't this be <= 0? The decrementBombs doesn't have a 0 check.
Unreachable code. The button is only visible if the user is signed in and the action is defined.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
For loop?
braces here too would be great.
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
IF EXISTS should be reflected in unparse
It seems that the following does the same thing with super.unparse(...).
Also need to validate the second operand?
Same here. It's more readable when part of deserializeValue
You could move this line between 121 and 122
I think it was more readable with try-catch was part of serialize
As noted above, just put the init code in init() unless there is a reason not to.
Change to assertion
could checkNotNull(getConfig(OWNER), "owner") here, to fail fast?
Switching OFF admin mode...
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
Probably better to have this at DEBUG level for final release.
Why are you removing this? LogoutController#init() says //If sub-classess override this method they MUST CALL super.init() at some point insider their custom implementation. Removing an existing explicit invocation to a method in a parent class could cause uncaught errors if we are not sure about what we are doing. Please add it back in and we can solve any new issue that this could cause.
Wrong JSR number in validation provider.
This validation provider still uses JSR-346 string in problem's message.
Are you sure that this class contains all that is needed/changed/new in cdi 2.0 specs? Aren't they any different?
Follow the same order of argument definition. Always add requireNonNull unless we are sure it is not needed (@Inject) or the value can be null (usually annotate by @Nullable).
this.fields = checkNotNull(fields, "fields");
Let's use StandardFunctionResolution for the constructor; so it's more general
no need to say "public" here, it is always public in an interface. "static" is important though.
getHasArtifacts looks better. <LINK_0>
Maybe wrap in an immutable map.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
I'm sorry, I don't get it, could you explain why when I call getAnalysisRequirements() twice I get two different ArrayLists()
Collections.emptyList()
Shouldn't this be &&? How can they be equal if one exists and the other doesn't?
can potentially return null if both are. is that ok ?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
Should this be "shouldReturnEmptyString" instead? If so, there are also a few more occurrences of "shouldBeEmptyString" that will need to be edited.
Use ServerUtils.isMainThread() etc.
Typo: initCardModeButtons()
That's good to know.
You don't need this line because of green 31.
you'll want to throw an annotation processing error here instead of just printing the stack trace
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
Let's not do this please. We want people to explicitly add things to view rather than things getting added by accident.
I'd guess that findbugs (the reason for the build breakage) is complaining about the unsynchronized access to diskLruCache here.
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
since getTerminalAtIndex can return null there should probably be a null check here (realize that it's vanishingly unlikely given the current contents of the panel!)
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
and doing the instanceof check here instead (trace instanceof TmfExperiment)?
We're checking event.error != null twice here - but we can actually drop this entire line, since event.isError() above is actually a event.error != null check.
you can use containsKey()
Avoid calling the getAllRegistrations() method. It has poor performance.
I'm not sure this is really needed. You can use directly triggerUpdate in tests? (this is maybe a way to speed up the tests)
Here, size is the number of currencies.
Is it really necessary to put the full enum name here? If yes I'd actually be surprised because I'd consider values() a static method of every enum
Would you please explain why clear() need to call ?
Just new Date() is enough
channels.values().forEach ?
rename to breakpointRequest
be a good citizen and call System.exit too :wink:
@inverno We have 2 times "Second argument" :)
Should be create, not label.
I would remove the if an always log the number of entries removed, which can be 0
use UnsupportedOperationException
nit: I prefer the other ordering for <= or ==, it's easier for me to read "n is greater than or equal to 0" than it is "0 is less than or equal to n".
same logging here as in perform next operation
can we print the throwable?
In separate line ?
failCanDoAction?
you replace this code with return validate(getStorageDomainValidator().isDomainExistAndActive()).
Something like return joinPagesNotNeeded.map(Future::isDone).orElse(true)
Why do we need this change?
Just throw it upwards.
redundant newlines
return Collections.emptyList();
Lists obtained from a message are immutable. No need for extra copying.
The local var is useless, you can remove it.
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
Missing @Override.
why delegating
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
I wonder if this should be an atomic operation?
I'm missing the new field in the toString method.
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
I don't know why that logic was there, looping over all the the datasetPhenotypes. This is a nice improvement :+1:
Here we can use .orElse(Collections.emptyList()) as we are not manipulating with nodes afterwards.
it can be replaced with Objects.hashCode(channel) (since java 1.7)
Style-nit: This is hard to read. Maybe: if (getRepositoryName() != null) return getRepositoryName().hashCode(); return System.identityHashCode(this);
Hrmmm, why?! if encoding is null usually mean this is a binary protocol
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
RuntimeException will be sufficient
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
do you ever get nulls here?
is it not empty if for example type is an valid empty string?
Could just be a boolean then. This is only needed if the default isn't false.
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
Why are you using this instead of assertThat(...).isTrue() from assertj or assertTrue(...) from junit as used in other parts of this repo?
Assigning revisionId = ArticleRevisionIdentifier.create("0", 1) could be done within the @BeforeMethod.
please refactor to use Enumerations instead
why do the values "true", "yes" and "1" equal true?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
please remove else, code will be more readable
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
I'm not sure what this indirection with the t -> business buys us
Remove throws Exception
if (realm != null) maybe - just to be safe.
Shouldn't we assert before we cancel the transaction?
Should be- setTitle(text.asString()) not setText.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
hyperlink
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
Is it required to have doScan(...) both for producer and consumer?
Use Camel's ObjectHelper - org.apache.camel.util.ObjectHelper#isNotEmpty
StringUtils.isEmptry(XXX) if possible
Multiple method(*) methods
I know that we don't have a linter for java projects yet, but what do you think if we'll try to follow some basic formatting rules, common for most languages? Like spaces before and after = and + for example.
.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?
K **is** comparable because K extends Comparable<? super K>. We can't use natural comparator here. I believe this is correct fix:  java final Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo); RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);
Let's have this enforce that hasher is the equality hasher.
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
matter of taste, this could also be return this.profileTypeRegistry != null;
@dalifreire wrong indentation here as well
@dalifreire 4 spaces back
@lautarobock Same here, let's declare throws Exception
@Override this annotations is not needed in test inputs
Please change to !StringUtils.isEmpty(title)
Remove ExternalUserIdUpdateHandler, both onSuccess and onFailure are blank.
In the real game when a bomb explosion hits another bomb, it detonates that one regardless of time left...I just looked at the project requirements though, and it doesn't mention this...so it might be simpler to leave that out anyways.
There is a better way to do this, WorldServer holds a Map of 'entitiesByUuid' which you can use to directly lookup the entity.
Could also express the for/if as Entities.descendents(this, AmbariHostGroup.class)
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Check if an entry with the given key (name) already exists and throw in that case an exception.
Preferably have one call the other?
When can the name be null? If not possible, then add an assertion.
Would we want to preserve the previous selection (before archive radio was selected)?
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
possible refactoring:  nameToken.setEnabled(selected); btnIsCrawlable.setEnabled(selected); if(selected) { nameToken.grabFocus(); } else { nameToken.setText(""); }
A LinkedList is better since you don't seem to access specific indexes anyways.
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
Couldn't shuffle be called once after adding discovered and then configured?
log the error or re-throw wrapped in a runtime. But do not just print it. We tend to use Throwables.propagate() from guava for this kind of use case.
This could be combined with the previous line.
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
Program to interface, not to implementation - please change return type to Map<String, Object>
I do not like this method. The way you create anonymous classes in it is bad. This method can be called 100 times per second, and each time it will create class with static initializer (new class, not instance). That means, that after 10 minutes class list in application will contain 10 \* 60 \* 100 = 60000 classes (and multiplied by 3, because there are 3 static initializers -> 180K classes), and I'm not sure if it is possible to unload it.
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
check for READ_ONLY style is missing?
Curly braces in the same line of if statement. Add spaces between variables and operands, such as cursor != null
This check is redundant; the projection in the query is just 10 lines up and there's only one column.
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
no need to change at here, because it is only for Date type
return array == null || array.length == 0
This should be static technically.
Caution: array parameter could be null.
can this just be boolean instead of Boolean?
Add TODO to not forget implement this in the future.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
let's use LinkedHashMap
Let's simplify this by merging the 2 methods?
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
rename to segment
:ant: double check of a single field.
Doesn't look like you need a contains check here, "mike".split("\\.") ==> [mike]
Maybe we should add element.toString to the error
We should not catch generic Exceptions. Can you make this more specific?
We should not catch generic Exceptions. Can you make this more specific?
please verify that the amend function is actually executed
there is a lot of code duplication for each test, the only diff is that you set those 2 lines, maybe you can extract the logic to a method and call it once with floating disk check and once with an attached disk.
please verify that the amend function is actually executed
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Could you also add a check for static explain whether the table BIG is the picked as the left table of the cross join? Thanks!
order by clause must be added.
You can use a try-with-resources to simplify this: try (ResultSet rs = ps.executeQuery()) { } It will automatically close the resultset for you.
Simpler: ArrayList<T> result = new ArrayList<>(collection);
This would not be a performance improvement. (And a tab character has appeared in the file.)
Well, you could make BeanAttributesConfiguratorImpl.qualifiers and types package-private and use something like:  throw BeanLogger.LOG.noCallbackSpecifiedForCustomBean("Configurator [types: " + Formats.formatTypes(attributes.types) + ", qualifiers: " + Formats.formatAnnotations(attributes.qualifiers) + "]");  Hm, BeanAttributesConfiguratorImpl.types should be final - pls add this change too.
UncheckedIOException
Hm, should we thrown it as InternalProcessingException ?
Shouldn't we log these exceptions? They may provide useful debug info.
please move the isEmpty methods to the scimSchema
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
wouldn't it be enough that one of these is null?
It's a good idea to run your tests before submitting them to Gerrit.
dare to extract a constant which increases visibility for these hard-coded values?
@Nadahar Right, text/vtt, i was too fast...my bad.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
I should explain it better earlier, what I mean by "inline" is to move the implementation body of isNonRetryableServiceException  to inside the isRetryableException method, then the negations should be applied onto each expressions, return true -> false; etc. This is still a double negative.
Should this use a parameterized message? java logger.warning("Connection exception encountered: {}", exception);  Right now this will likely log the exception message twice.
... and below.
Remove entire wrapper finally block
Remove entire wrapper finally block
redundant ";" character
Why is no this. used in lines 320-321 but this. used in lines 322-326?
public
This could be removed if you change verifyThatCleanupOccurred so that it tries to get the NotFoundException and if not sleeps for one second and tries again (until finally timing out after 30 seconds for example)
Curious why login logic has been changed here also.
Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
Why is hard to read generic coding used here?
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
make function synchronized. Res: done with syncronized block
given that you re modifying this method...it should be made synchronized just to avoid concurrency issues. Also update the end date in the copyright header for every file you change.
If you're doing this you need locking. A static initialiser might be simpler.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
We definitely need a solution for these kind of situations where you just need to add more and more elements to the page, right? This solution goes into the lines of not changing the method, which is really nice. The problem is that it distributes the responsibilities on the view model construction. Need to think about it too... right now I would choose to add a new argument to the method, at least as an alternative method, because the distribution of responsibilities is a worse situation IMO. But I would like to know your opinion, mine is still not sure :D
@paulovmr is there a use case for this?
I would replace " " with ' ' since there is only one character.
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
can't we use Util.checkNull(handler, "handler"); simply?
Upon ValueChangeEvent<String> you would want to fire a ValueChangeEvent<T> to represent the change in the T value, so you have to know how to translate from String to T. ListModelListBox does it through GWT's ValueListBox, which translates according to index. You don't have indices, so you would need some sort of Map<String,T>. I would do that by implementing setAcceptableValues() in this base class, and in its implementation construct the map using renderer.render() for the map keys. The renderer for ListModelSuggestBox should just cast. Then when a ValueChangeHandler<T> is passed here, I would add a ValueChangeHandler<String> to the SuggestBox that calls handler(map.get(value)).
log.error("Cannot add subnet to an unmanaged external network provider {}", provider.getName()));
Use _Objects.hashCode(name)_ instead of _(name != null ? name.hashCode() : 0)_ And the same for other similar code
If you change hashcode, how about backward compatibility?
Minor: we usually delegate to Objects.hashCode to simplify these. And Objects.equals for the above. (The guava ones because we support java6).
Please use CanDoActionAssertUtils.
remove 'Assert.' (there's already a static import)
Is toString() required here? I'm not sure, but I think you can remove the toString() call. Maybe the toString() call is cheap and if so, not a problem. But the reason for the check of log.isDebugEnabled() is to not call toString() if debug is disabled. If you have this line as below instead, this problem goes away: log.debug("Notified of timeout on message '{}'", msg); I think this will work since I think log.debug will call msg.toString(), but I'm not sure and I haven't tested it lately.
Don't like catching exception in the constructor. use an init method with @PostConstruct annotation.
Remove log.warn since we already cover in log.trace
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
I would mark it as final. It is not safe to use non-final methods in ctor. Someone could override it and do something foolish.
we don't need to change the Creation classes.
rename cancelAt to cancelAtNs
Multiple threads can call updateAlarm at the same time, so we need to make sure that the usage of the outstandingAlarms map is thread safe.
This should probably be issued after the call to alarmDao#delete. Won't situation.getRelatedAlarms() still contain the given alarm we deleted.
We should use the alarm that was retrieved within the transaction i.e.: suggestion OnmsAcknowledgment ack = new OnmsAcknowledgment(alarmInTrans, DEFAULT_USER, now);
The synchronized block needs to include this read from the map: - Thread 1 reads eventNameToListenerMap, gets null - Thread 2 reads eventNameToListenerMap, gets null - Thread 1 enters critical section, creates new HashSet containing listener 1 and stores in eventNameToListenerMap - Thread 2 enters critical section, creates new HashSet containing listener 2 and stores in eventNameToListenerMap Listener 1 has been lost.
Currently you're parsing the message JSON twice: once in extractDataFrom and once in getMetaData. This could be improved by modifying extractDataFrom to use the output of getMetaData perhaps.
As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency.
is it not empty if for example type is an valid empty string?
please move the isEmpty methods to the scimSchema
This could just be a preconditions check in the constructor, and I would use a different error message that just tells the user that intervals and segmentIds cannot both be set. The current error message I don't think is accurate ("Request payload contains invalid interval[%s] or segmentIds[%s], atmost one valid value must be provided"), since the check is not really for validity of the supplied values but for the presence of both.
what is your opinion about that you convert only the different value and you are using the .name() any other case?
This should just be a field on the enum.
I wouldn't change the default.
there should be only one line between methods.
I would go with if-else as this is NPE vulnerable. But if you want to use a switch-case then please add a null check before it and return if he selectedProtocol is null.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Please remove an excessive space character.
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
public isn't needed
Is this the right thing to do since the flag isn't there anymore? It seems like it should be removed to me, since the behavior without fromPigAvroStorage set was to skip this section, which means that it would likely get picked up by the if (field instanceof List) { .. block below, which does a different transformation.
You shouldn't need to specify it. I guess that Kubernetes API is the default mode.
I don't quite understand why the Keys of this Property Map are localized Strings; if these Properties are meant for being processed programmatically, I would expect Strings that don't change when the UI is localized.
This method was added in java 8. It will fail with java 7. Note that it might compile on Gerrit because we compile with java 8.
Why is it a list of lists, not just a list?
Collections.emptyList()
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Do you think we need sync control on all the map operations here?
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Please add ? and % as well
unnecessary array new: {{true}, {false}} should work here
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
As mentioned previously, the check for the service type does not really belong here. I have created <LINK_0> instead.
... remove the final modifier from the method. It will be easier for future tests.
Compare to == 0 vs equals for version comparison?
Not that it matters so much, but the idiomatic way to "unpack" thing from Optional given a value to return in case of empty is [orElse](<LINK_0> which makes this common pattern i bit less verbose: return parent.orElse(null) But this kind of defeats the purpose of using the Optionals in the first place (to avoid having to return nulls). Otherwise +1 to merge.
Should be Collections.emptyList();
ow, this could be dangerous. We need to bluejeans to discuss.
nope!
This can lead to some long names, why dont we use a uuid or currentTimeMillis ?
invocation is not null as it has been already dereferenced above. So, if you test currentInvocation == invocation, isn't the test currentInvocation != null redundant?
Unnecessary whitespace.
Use constants in airlift SizeOf.
ditto -- use constants in airlift SizeOf.
check for empty criterias?
First of all the size of a queue cannot possibly go below 0. Secondly, this method seems to be called only when chunksToWrite is empty, so the second check is unnecessary.
Here I would also prefer a one-liner with a ternary operator.
Similarly here, exec. should not be necessary.
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
nit: remove else {}, throw exception after if block.
I think it is better to throw exception
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
isn't better to call it dimensions ?
no need for concurrent
Personal preference... use of Collections.emptyList()
You don't need this line because of green 31.
Simple test is also possible to verify result stat. See #971.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
I can't remember, is there some protection to make sure names are unique
Please remove it.
"expection" -> "exception"
Aren't we also prioritizing savepoint barriers here? Or are they guarded by using NO_ALIGNMENT_TIME_OUT on creation?
matter of taste, this could also be return this.profileTypeRegistry != null;
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
The bit is either set or not, so != 0 is a faster test here.
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
According to the current way how those methods are implemented, it should be return false
@benzonico may be it is better to highlight tree which includes the !.
If i'm correct you should end up with only Method and Lambda as subscribed kinds.
@vilchik-elena You could factor the list of kinds into a static field Kind[] kinds = {Kind.EQUAL_TO, Kind.NOT_EQUAL_TO} in the enclosing class.
This will throw redundancy warnings in IntelliJ
Local variable could be declared List instead of ArrayList. Is this worth caching?
Nit - just return Arrays.asList("createSockets", "getInsecure") instead?
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
Probably we can move the logic of obtaining the env vars to @PostConstruct to avoid reading env vars on every call
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
If these values can never be null they should be stored in int not Integer.
A design where this is side effect free would be most desirable.
findbugs will tell you that JenkinsLocationConfiguration.get() can return null
Again, use IOUtils.
Class should extend AbstractPathTestSupport and directory path should only be defined in getPath.
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Return value of the method is never used.
more specifically, it's going to try and use writerFor(JavaType)....but that's just a nit
It shouldn't be an error. We have warn log tracking in many places now, so would pick up if this was frequent.
You can just do Slimefun.getLogger()
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
this line can be removed
Why are you putting the annotation on the same line as the method name. Normally all annotations are on their own line
Would be nice to circumvent the creation of the Text and go straight from String to byte[]. Same applies to the other Step interface methods.
It looks filename is derived from page title. Have you considered just calling the new constructor like this(row, filenameAlgorithm(row.title)
nit, Collections.EMPTY_MAP?
Collections.emptySet() should be all that is required here, no generic.
return Collections.emptyList();
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
Can this be private, or is there another use case for default attribute outside the builder's call?
the default should be made a constant somewhere instead of being defined in multiple places
IMO the caller should do this check, in fact most callers already do.
package-private? Only used by AbstractJmxRegistration
I liked it better as it was before. This is not the proper place to handle domain conflicts. It should be done in AbstractJmxRegistration. Also, the error message, mentioning cache manager name is too specific and not really needed. This is supposedly a generic utility method, used even by remote client.
you don't need this function, you can use constructor directly
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Can't this be further improved to just Arrays.asList(values)?
Optional should be used in interfaces. Use null as internal value.
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
Nitpick: this should be static, because it doesn't depend on any instance fields/methods. Also you wouldn't have to prefix the calls to this method with this. everywhere (I know it's part of your personal style to prefix things with this even thou it's not mandatory in places like these :-)
It's written nowhere, but I'd prefer to have curly brackets even for single line.
let's call it updateCodeMinings() instead.
service id check?
no need to check for null again...
:+1: this is a lot nicer than before
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
This makes me very sad since it brings back bad memories of us trying to make super calls happy. How about we move the diff callback creation to the options builder and let devs overwrite it if needed?
I this refactoring, very nice. Could make this method protected.
Shouldn't options be Immutable?
This is never returned.
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
Use config.getTrimmedStrings() instead?
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
nit: Could be this.conf = requireNonNull(conf);
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
But checking the callsites, I think we need to catch NotSupportedException for getNextPage method in both OrcBatchPageSource and OrcSelectivePageSource. We also need to catch InvalidFunctionArgumentException for OrcBatchPageSource.getNextPage
is this actually what we want? it means we will lose stacktrace information for the suppressed exception, right?
Should this be above "isColorTeamMatch"? For example, on line #755.
Set fileEventHandlerRegistration to null.
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
That's good to know.
What's the point of adding a copy here?
You should be able to use the diamond operator here, i.e. new ArrayList<>()
We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it.
Just in case here I would say 'if (TextUtils.isEmpty(title) || isEmpty(message) || isEmpty(disableButton)) return'
move them in in the ifs below, so that they are used only when needed. Also, Android Studio automatically shows the value of the string, so there is no problem with unclearness
Retry forever is a bit risky. Limit to a fixed number of tries. Also, use a delay between tries?
you should probably cast to a string or call toString also could be shortened to return (String) get( key );
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Don't need this keyword here - the rest of this code only uses this when necessary.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
Can't we just have a whole UnsupportedOperationException as a singleton instance? Or that way we are going to lose a method context for stack trace?
should add some context in the exception message here
final
So the algorithm here is: * if unencoded file exists, return it * if encoded file exists, return it * encode the filename if required * trim the filename and return the file Have I got that right?
Is splitting on '-' in baseName intentional? When baseName does not contain '-' this code will fail.
rename to automationContext
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
isn't this changing the default behavior?
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
Could just have endpoint.asUrl() no? this is the only place asString is called
are you sure this is the best way to handle this exception?
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
List#sort usage.
... this subset here may be empty, which will throw an exception. And it does actually. I tried the full branch on a kernel memory view with trace "bug446190". So either we allow empty sets, which would require min() and max() to be @Nullable, or if the subset is empty, we return a singleton empty condition. What do you think?
while I think it makes sense to check this if we are calling it E from, E to, wouldn't the constructor be a better place to enforce this? In the 2D query patch, Genevieve suggested not enforcing it in the constructor and using min/max instead.
Did you think about using [appendQueryStringToURL](tests/blob/master/src/test/java/com/wikia/webdriver/common/core/url/UrlBuilder.java#L71) method for appending URL params to URL?
please add curly braces here
if you will navigate to page with / you will get <LINK_0> add your parameter to the end of line above
Why use a local variable?
It isn't possible for ctx to ever be null here is it? Also checking whether ctx.patternInitializerList() is null should probably also be done before line 175 as well.
The "includeRequired" parameter (the last boolean before ctx.getStartIndex() should be ctx.getIncludeAll().
Hmm...while at first look this looks ok, I think we should 'harden' it a little bit to prevent cases of leaving compensation context uncleared in the DB. I'd suggest doing the following: boolean clearCompensation = true; try { endSuccessfully(); } catch (Exception e) { clearCompensation = false; } finally { if (clearCompensation) { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } The code can be improved, but this is the direction to go to reduce leaving compensation trace in case of a failure during the end action.
Shouldn't the latch be updated here? The Undertow task thread could stay blocked indefinitely.
It appears that we can incorporate this logic better into CommandBase.endActionInTransactionScope() The finally block of that method is: if (TransactionSupport.current() == null) { try { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } catch (RuntimeException e) { logExceptionAndCompensate(e); } } else { try { if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } else { compensate(); } } catch (SystemException e) { logExceptionAndCompensate(e); } }
Formatting issues. Please fix.
Sorry; missed that
serialization?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Please don't change API visibility. Thanks!
this and m_ is redundant
nit: Suggest renaming iterations and its getter as well here
Maybe we should name this variable entityReferencesDescriptions?
Any reason we r not using StrugUtils from commons.lang3 ? Time to retire some of opennlp StringUtil I guess.
I added a hyperUnique aggregator to my index, and the requested buffer size jumped from 20MB to 535MB. Seems really large, is that expected?
Same here when trying to save the context without specifying the script (or when trying to import the context).
add "assert cfg != null" before because getMarker returns a @CheckForNull and getAllDefinitions want a @Nonnull.
nit: you can merge both lines above as checkNotNull will return the given argument
Why does the report contain a file-name pattern instead of a real file name?
This is not a robust test. The number 24 will change as soon as we change the vocabulary.
And then else if this
@garg-anuj Yeah doing that only.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
This can be removed now.
LOG_WARN should be the first argument
You probably want to pass the exception as the second argument to the logger. If it is in the message all you get is the result of ex.message() but if it is the second argument you get the message and the full stack. Often the message is almost worse than useless and for some exception types it is null
Should not log under warn after testing for isInfoEnabled (or isDebugEnabled). Always log at the same level as if test. simply replace both with a single if (logger.isWarnEnabled() { logger.warn(...., ex); } (See JMS AMLC)
finalize?
nit, Collections.EMPTY_MAP?
Why is it a list of lists, not just a list?
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
let's just use m_inferPartitioning != value.
two arguments is iffy. e.g. if you just want to enable -nestedLoading, you also need to specify 'org.apache.hadoop.mapreduce.input.TextInputForamt'. we can move input format also to arguments (-inputFormat). '-inputFormat' will be rarely used.
A test without any test ? That's unusual
Same here: should be Branding, not ProductBranding
you can use your find method here also
this whole method could be a oneLiner: return find(...) != null
you can simplify that as return getInternal(key) != null
I think this can return null if there is no timeout. From what I see, a null SocketConfig is supported and what occurs normally (if you have no customizations).
This hashCode implementation should include attributes from the PingCommand super class.
Please implement toString() to provide debugging state information for debugging purposes.
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
do not assing parameter! nowhere!
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
The value needs to be encoded/escaped when used as the key.
even though initialize() performs some logging, it would be nice to have a trace logging here to see the decision path.
Couldn't we use a WithinThreadExecutor here? This constructor creates a new single-threaded executor, which would mean one thread is allocated for each cluster listenre.
why this change? private port can never be null. Public port can though
- remove @NotNull - Integer -> int
It's Comparator.naturalOrder()
You can also use IO.close(bb) as IO.close will not throw any exception.
Use Assert.fail() instead
Why are you changing to patient 7 here too?
Seems for me this would be enough:  java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return (String) template.findOne(query, Map.class, collectionName).get("value");
The same is here for that include("value") and Map result
You have missed oldValue in the criteria. See the replace contract in the ConcurrentMap.replace
We decided to get rid of service class version parsing in favor of passing explicit service+version at config time. Don't think we want to add this back.
DEBUG is a bit of a weak signal, don't you think, given that this is almost certainly going to fail?
should it be escaped, just in case if header values contain comma?
is it possible that we don't pass enough arguments to this array?
I think you can use Charsets.UTF_8 or some such and avoid the try catch
This seems defensive also, and it's also just a sample in a test. If the underlying method the handler invocation returns isn't expected to return null, then we shouldn't check for null and we should let the NPE happen.
IMO using a concrete instance of PerformAutomaticLayoutCommand and passing mock objects to its constructor is nicer than mocking the class under test and using doCallRealMethod(...)... but it's only my opinion.
This should be public and have a @Before annotation, not be called explicitly by each test.
No, RunVmCommand is executed before the VM is running, The VM's status should be down
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
github is unnecessary variable
I'd use equalTo() here
please remove else, code will be more readable
You get it right. Per code conventions, I like to see brackets around if and else clauses.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
this used to bail after this call if it wasn't the root, does returning v. not returning from onCreate() in that case affect anything?
If you set wasExternal here then remove it from processFromExternalLaunch
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
We can't use the concrete HashMap.of here because it is an abstract Map test, the base for _all_ Map implementations. Please use the methods empty, of and ofAll which are implemented by all AbstractMapTest implementations.
This could use Collections.singletonList
why osNames have to be in abstract class? override this method where is needed and add it there
Do you mind explaining a bit why this changed necessitated a switch from 1 to 2 for provider id?
In the deserializer, the provider name is uppercased before searching in the map: java String provider = providerNode.asText().toUpperCase(); String providerPlugin = EndpointDiscoveryProviderMapper.getProvider(provider);  Maybe you should do something like this: this.provider = PROVIDERS_PLUGIN_MAPPING.getOrDefault(provider.toUpperCase(), provider.toLowerCase());
Drop this empty block.
Should we have an isAnonymous method that we can call here to make this clearer?
simplify this
I think this should not be executable if the review is not open
System.out.format instead?
Can be simplified as: return Strings.isNullOrEmpty(valueInEnvironment)? getPropertyValue(properties, defaultValue, property) : valueInEnvironment;
Symmetry (throw)?
It's sad we had multiple params per line before. Let's fix it by having one param per line.
should the SortExpressionExtractor be renamed as well?
same, one param per line
move null check back as first action in the method to not change behaviour
move check back as first in the method to not change behaviour if null is passed as unit but we are in the EventLoop thread.
Looking at the docs for Future, I think this should throw TimeoutException if !done.
oo fancy!
In their naming, these are the "Account Id" and "Application Key"
capitalize and change by a text describing what the identity is?
Let's refactor this to cfg.setClientMode(igniteInstanceName.startsWith("client"));
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
Let's merge creating cache configuration and passing it to ignite configuration.
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
same here, why only these two methods?
Should we check for null because we will reference it later - executor.getHost(), executor.getPort()?
don't forget default case
This check is redundant because you check this in handleSelection()
unsubscribe()
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Probably we should check here for the class loader of the exception class, if it's the class loader hosting the test cases it should be GuardianException, otherwise we should transfer the exception using com.hazelcast.test.starter.Utils#transferThrowable.
does this need to catch all exceptions?
use getGuid(rs, "disk_id")
disk.setVm(new VM()); should be inside of this /if/
Since there is an explicit coupling between lines 371 and 373 (if you were to reorder 370 and 371, it would break), can we factor those into a method that just returns the appropriate value?
null check
We generally prefer assertThat(..., is(..)) for better error messages.
What's the reasoning behind periodically refresh every second here rather than just refresh it when an actual change is detected? We also have file based resource groups, which can never be changed. Having this running regardless seems to be unnecessary.
plase fatcor out that hardocded path segment
DEBUG is a bit of a weak signal, don't you think, given that this is almost certainly going to fail?
![MAJOR](<LINK_1> Remove this use of "getBytes" [![rule](<LINK_2>](<LINK_0>
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
Doesn't String.format need a value to be formatted?
Include the bit in the toString(), e.g. maybe 1<<getPosition()
return HConstants.EMPTY_BYTE_ARRAY; ?
need to add more information about dimension/index/length
can pattern be null ?
Remove else statement here. It's unnecessarily
Should we use the DOT variable instead of the constant?
Usually we use i, j or k to iterate through array instead.
UnsupportedOperationException seems reasonable here.
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
suggestion return new CheckConstraint<>(name, mapper.apply(expression), expressionStr);
suggestion return new CheckColumnConstraint<>(name, columnName, mapper.apply(expression), expressionStr);  Please take care of generic warnings. Don't ignore them
same ...
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
not obvious why this bool is flipped...
This block should return the action, rather than fall-through. Otherwise in the case of back-pressure the first time you try to send the reject it will fall-through to onExceptionalMessage() call at the end of the method.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
There's also a getProxyIfAvailable(), returning getProxy() ?: this.
Please don't catch Exception. I removed it and it still compiles fine. If you prevent NPEs this way please replace with if (null.. ) .
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
- [x] Why need this? Please re-consider based #768.
The stacktrace here is pretty boring. Therefore it was left out intentionally (although due to the missing placeholder still wrong). It would have been nice though to let the user know what exactly was the value that wasn't so great: java logger.warn("Could not set new location {}, keeping old one: {}", location, e.getMessage());
suggestion && (((BaArmor) part).getType() == getType());
suggestion return getType().equals(et) && (((AmmoBin) part).getFullShots() == getFullShots());
You should add an additional check: does this outline correspond to the current diagram editor ?
Remove?
Just a nit pick. Shouldn't this be  java } finally { realm.cancelTransaction(); }  ?
Remove else clause.
Make this static.
values.isEmpty() - does it mean I cannot have a claim with an empty object, like this:  "warnings": {}  I don't think it is right then. This is a totally valid claim. Same for empty array claim:  "alternative_identities": []
This seems like a mismatch, maybe you should not include the @Nullable here?
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
please replace this line with: return StringUtils.defaultString(result); or the two lines with: return StringUtils.defaultString(getMessageOrNull(logType));
Seems for me this would be enough:  java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return (String) template.findOne(query, Map.class, collectionName).get("value");
don't need getName() just this.oldSelectedVersion.notEquals(newSelectedVersion)
changes.executeIfNecessary()
As far as I can see, this method is only called at line 244, and the return value is not checked. If the return value is not used, the method should return void.
Ditto formatting.
Ok, but in the future, you might consider constructing these w/ JSONObject or GSON.
@cvrebert This is a little hard to read; let's use JsonObjectBuilder for this one and the rest of this class.
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Isn't this constant and shared across all producers? Then can't it be static?
use createTempFile
Use faster methods, should not use data processors when possible.
Could you at least make this return a non-null value?
Make sure to return a read-only version of the List (not set) here. We don't want people to think this is the method to register interceptors.
same, "error" seems redundant here
inline in ConcurrencyLimiter constructor?
Please extract some values to make this more readable.
While strictly correct, it looks weird to have a size assertion of 2, next to a contains assertion with only one element. A single containsExactly(1,1) would match expectations better
Why do we need to check again?
This function is called in line 432 of Sender as well, should the return value be evaluated there?
The local var is useless, you can remove it.
Rather than instantiating the view here, I think you should just pass it to the [DatasetSourceTarget constructor](<LINK_0> That way we keep the number of places where views are instantiated to a minimum because we always want to push that as late as possible. For example, support for handleExisting will probably push that until when the job is being committed.
Maybe instead of repeating the checks here, we could remove the .size() checks, leaving it to be checked by the following call to the overloaded isEqualCollection.
you have made all the above code with ImmutableList.copyOf() why not here also
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Modifier 'private' is redundant for Enum constructor - needs to be removed.
symbol cannot be null for a method tree.
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
uncessary call to super. No need to visit further.
is there a particular reason that you're setting the value of this node to 0? couldn't it just have no value?
Do you mind explaining a bit more for this. Thanks
I noticed only now this fact: don't we have a rule to forbid the usage of "Assert.xxxx" and force the usage of import static "org.junit.Assert.fail" ?
as above - maybe a closeQuietly method?
You can use getFieldValue(Long.class, getLayout().fieldLen()) here and then null check to be safer.
did you mean to keep this?
is this needed for the test?
since this persist is triggered by the maxRows config, would it make sense to persist the one having the maxSize ? as the oldest one may have very small number of rows.
we should make this into a constant
typo handle -> handled
Can you remove this first case for FileNotFoundException and just let it fall through to the general case.
To avoid confusion, rename the variable to sessionId.
uuid can never be null here because if EntityPlayer.getUUID(player.getGameProfile()) were to return null you'd already get a NPE in line 44. Maybe use something like java UUID uuid = EntityPlayer.getUUID(player.getGameProfile()); if(uuid == null) { uuid = EntityPlayer.getOfflineUUID(player.getName()); } if(uuid == null) { CrafttweakerAPI.logError("Could not get UUID for player " + getName()); return ""; } return uuid.toString().toLowerCase();  Also, since I don't know these vanilla methods that well, can player.getGameProfile return null, and if it can, will getUUID(null) throw an error?
Should check that the environmentTracker is not null
I think the logic is reversed with the name now and it should be !useHyphens here.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Why have you updated this test instead of writing new one?
more than 120.
Comparing with #2845 RSS feed will be with project name but not build status. This is not enough. We need to see project name (for rss with multiple projects, what #2845 broke), build name and build status like it was before.
can be inlined into a single line by using Streams
You should use ThreadContext.putAll() here.
are spaces OK in namespace strings?
as above: are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
This looks like a leftover and it hasn't any usage. Can we remove it?
Please have result variable.
Remove the if check and simply return getFirstElement
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
is it not empty if for example type is an valid empty string?
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
you can just inline this
Missing finals
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
TravisCI has been using gradle check command. The gradle reads the following test settings that configure the time zone. Doesn't the setting work for you? <LINK_0>
Missing day-of-week at the start of the format pattern.
We can get rid of these variables if they are being used in one place.
Same as above for otherNonCodedConceptUuid
Same as above for otherNonCodedConceptUuid
This is very unusual
and returning based on an interface rather than impl class?
I'd rather put a blank line after the assert and remove the one below to group the assignments.
do not assing parameter! nowhere!
User.isActive() should return a boolean instead of Boolean since UserMetadata states that active is required.
remove line
Why do we need to change BlockHeadersMessage?
Please use English.
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
I think the setter would be a more appropriate place for this defensive logic.
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
use constant from Versions instead
why use ellipsis?
Do you mind adding { and } here? It's more robust to refactoring
labelX should be x + ...
This line gives a warnings in Eclipse because implicit boxing between false and Boolean.FALSE is used. Better import import static org.junit.Assert.assertFalse; and use assertFalse(repo.getObjectDatabase().getPreservedDirectory().exists());
If there is nothing to draw, what about just skipping the drawing and return 0?
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
null =
Shall we use the async callback here for the getStyle()?
This is throwing a StackOverflowException if invoked. Should probably be sendNow(event)
What is the purpose of this conditional?
synchronized is not needed we're using a concurrent collection
Extract notification to own method notify...
If you make the outer a proper class, it can implement Disposable and dispose() can call cancel() on the field inner.
return this ?
Should it be logged at the error level?
We're checking event.error != null twice here - but we can actually drop this entire line, since event.isError() above is actually a event.error != null check.
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
Remove final.
We use small d doubles for simple calculations.
I'd inline result variable: DOUBLE.writeDouble(out, strategy == null ? Double.NaN : strategy.calculateEntropy());
explicit real ref?
With #487 this assumption may not be true anymore.
The above cast should be done after the if (entry == null) check to avoid a potential ClassCastException. My mistake.
suggestion if (rowIdx >= rows.size() && requested > 0)
let's cancel upstream only here and do not do it inside end() method
use this.size()
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
Extract variable result.
Why do we need this constructor? It doesn't use the 2nd parameter...
nit: either use this. for both assignments here, or for neither of them. Consistency is good :)
depending on the change above, this could become just getNumberOfValues()
"Clean orphans from PROPERTIES" to be exact ?
This equals implementation should include attributes from the Command super class.
This equals implementation should include attributes from the Command super class.
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
As you edited this line, could you remove extra parenthesis too please ?
This should really not be public.
Integer.toString?
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
This constructor is redundant.
not needed, empty c'tor is just for satisfying gwt. its modifier can be reduced.
SourceImpl?
We should not generate the watermark if the source uses PunctuatedWatermarkGenerator.
You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...
shouldn't this also check the "" case? Consider using Guava Strings.isNullOrEmpty
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
perhaps do this in multiple lines
This doesn't need to be "re", as it's just evaluating stuff once, not twice.
You can remove this statement, because this variable is not used anywhere else.
simplify this
Log the exception and pass the exception into it rather than doing a printStackTrace. Then, are we checking for null after build? Better wrap this into a Runtime exception with a descriptive message.
it would be great to preserve the boolean flag that toggled between new GooglePromptReceiver() and new LocalServerReceiver() somewhere - the java-client needs that one
I would not put this method as an example. This API is just... not possible for me. It looks more an error than an API. Is this used by users @wfink ? If 'not really', for me we should remove it from here IMO This API of creating caches at runtime should be changed and I mentioned in the thread in zulip @tristantarrant @wburns
entity can be just grabbed in the context method not here (other fields probably can too?)
What If I want to set velocity to zero?
HostMapper? Isn't this if branch for StorageDomain? Maybe that map method should be moved to a new "ExternalStatusMapper" class?
Should all the VoltDBL* relations assert the presence of the VoltDBLRel.VOLTDB_LOGICAL in the input trait set like VoltDBCalc does?
Always use create instead of new directly.
Should we be consistent with the assert assert VoltDBLRel.VOLTDB_LOGICAL.equals(getConvention()); vs assert traitSet.contains(VoltDBLRel.VOLTDB_LOGICAL);
I think the underlying registry/restClient will return SchemaRegistryClientException instead of SchemaNotFoundException in this case.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Uh, IllegalStateException?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The string needs to be made translatable in a messages.properties file
This seems to be causing NPEs on shutdown for me.
The page also configure the base id. Replacement proposition: Configure the creation of your Class Diagram skeleton.
Optional should be used in interfaces. Use null as internal value.
nit: you can merge both lines above as checkNotNull will return the given argument
URL instead?
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
return tags;
Use CommonImages.getImage instead of createImage so that we don't have a memory leak.
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
Isn't it the same method as in CustomTaskListDecorationDrawer?
return defaultFilterFactorEnabled ?
Are these methods part of the upgrade?
Maybe just call this endOfInput?
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Why did we switch out the old code back to this?
I'd like still handle the activity context case with java BaseRealm.applicationContext = context.getApplicationContext(); if (BaseRealm.applicationContext == null) { BaseRealm.applicationContext = context; } if (BaseRealm.applicationContext == null) { throw new IllegalArgumentException("The context is null"); }
negative logic
consistency of error message from above multiple changes per node is not supported for parallel traversing
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
add this selector to UI mapping at the beginning
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Doesn't this approach imply that moving to Curator 2.12.x requires you to change the code base to not break backwards compatibility? Shouldn't the default be to be in compatibility mode? Then you can just upgrade to 2.12.x and everything will still work, but you need to change the code base to pick up the fix for CURATOR-275?
ImmutableList.copyOf() creates an independant copy, whereas Collections.unmodifiableCollection() returns a wrapper on a collection which itself may be modified later.
I think this should be replaceFailed = false instead.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
Does this need to be private? Since it is async it does not really matter how much instances you create and use at the same time, does it? Sure Sponge itself only needs one but there is a difference between having one and enforcing a singleton.
move the mull check under the null check for thread to ensure we not change behaviour.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
To always be safe please use context.getApplicationContext()
why not factor out this code ? It's repeated in quite a few places.
And then else if this
I think that this check makes more sense in the "getClusterId" method. Can we move it there?
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
The fact that this worked is actually an indicator that the ApplicationDispatcherBootstrap class is following a quite procedural style. Maybe with the change that it now takes a DispatcherGateway for which we have easy test implementations one might rethink it.
Is this guaranteed to be supported?
boundedElastic
Please use Optional.ofNullable()
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Why don't we make inDegrees to ConcurrentHashMap also?
no need for concurrent
suggestion this.dataStoreMap = new IdentityHashMap<>();
I think inverting this if check would improve readability/flow
final
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
So simple! I like it!
I'd move this to line 83 (within visit(ASTMethodDeclaration node, Object data)), so we ignore all overridden methods and not just setters
We should probably check that the next char after "To" is uppercase
is this being used somewhere?
Could be suggestion return !selectedBaseResources.isEmpty();
if you remove the property, why aren't you removing this method as well?
is this supposed to be result.toArray(...) ?
Why an array? List<String> is just as fine
no need for the additional check if propertyParts.length is ok?
return (e.getScriptStackTrace().isEmpty() ? null : e.getScriptStackTrace();
The 'finally' block is not needed since calling monitor.done() is not required.
If we're using the first stop, why are we using interpolated times? It's illegal for the first stop to not have times specified.
So this would leave the View in an inconsistent state with the Presenter? Should you not show an error in the View that the value was wrong? Or default to a valid value and update the View? etc
Likewise..
Likewise..
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
Add the info log back after this line?
I guess it can be moved into the if statement
should this be synchronized?
If you"ll use generics you won't need this cast.
Might want to use a StringBuilder here and the Original one can be declared as a static final constant.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Do we want to check both getProjectId() and getJobProjectId() here?
the parameterized and test settings are ... what? Also nit: readahead not readhead
nit: Could be this.conf = requireNonNull(conf);
Please remove system.out.println and add assertion
Method should be synchronized probably?
pvk should not be visible. Please remove it.
Why was this removed?
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
Replace by Objects.requireNotNull()
Not sure, why not use @NotNull?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
Won't we land here for expected network errors as well? Should this be in the catch block itself?
call tearDown on laggards operator
Need WebsocketEchoTestBase.tearDownAfterClass(); to clean up resources.
Give each individual test case their own port. This means you'll have to make your database rule startLazily as well.
canConnect( server.address(), clientGroup ) can be extracted to a no-params method
Check so that server != null when tearing down.
why would server be null?
just return "" instead of new String()
you need call addColorSettingsListener on the new instance.
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
Please remove an excessive space character.
Do we want to check both getProjectId() and getJobProjectId() here?
L112 and L114 conflict. And validatedNumaMap doesn't seem to be used anywhere
where did this go?
Why do we need it here?
If the method is static and/or statically imported this will return true. This is a discrepancy between name and implementation.
a checkState that only one side is DeferredSymbolReference?
rename to fileMatcher as it is a File predicate
extract actual.getModifiers() to a local variable.
add () to group && conditions for clarity
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
return operatorsToDeploy.isEmpty() && operatorsToUndeploy.isEmpty();
Replace with: return index >= 0 && index <= this.actions.size(); No need to return a boxed boolean
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
you can create an example test list and assert their values like testListNumbersForPurchase, testListWebhooks etc.
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
why is this method public? why is it static?
suggestion // Align up to 4k final long align = 4 * 1024; return ((arenaBlockSize + align - 1) / align) * align;  Marking the primitive variable as final would make it a constant variable and help the compiler to do optimization, please check [here](<LINK_0> for more details. We could also make it as a class-level static final field, but keeping it here directly maps to the RocksDB code.
string concat can be inefficient. consider sth:  ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES); buffer.putLong(x);
this is a confusing name for a function - why rename?
You create a getColumnNames(table) method later on in this class. This change is unnecessary, as it should just use that other method.
Use map.forEach
since this "SimpleTable" string shows up in a few places, let's extract it to a constant somewhere
Should use the log, maybe a warning.
should be logged.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
this code doesn't seem very safe. If the call to db fails, the class construction might fail, and then it's hard to troubleshoot it, no proper logging, etc. Isn't it better to first get the domain from db, and if it returned OK, pass it to constructor?
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
I would ask to the catalog if the filter_key does not exists on publishing_bundle to proceed
return defaultFilterFactorEnabled ?
"Called only after a call to prepareEntities" Might be worth adding a flag to enforce this; I'm guessing this could be unpleasant to debug if someone tried to manipulate entities before they were ready.
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
Use the narrowest exception required, I think in this case you just need ApiException
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
add this selector to UI mapping at the beginning
Hm, is it allowed that the extended discovery services still use the callback if this component has been deactivated (e.g. because a mandatory reference gets lost)? Shouldn't you unset the callback?
better don't call the setter here since the configuration (from updated()) must not be called already
Why depend on all DiscoveryServices and not require extended services to register specifically under that interface? Ok, this might be breaking, but as ExtendedDiscoveryService does not even extend DiscoveryService, this simply feels wrong here.
suggestion List<Program> malPrograms = pws.getPrograms("MAL");
Why is this necessary?
Expand this a little, verify event request fields
nit: should the last 3 lines be a separate test?
You are only locking and unlocking a single lock, I assume from the name you actually wanted to use multiple. Otherwise, this is a strict subset of the test above.
Is this first line needed?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
This is common enough that there's a util for that and is used extensively: suggestion Utils.closeQuietly(retryWithToleranceOperator, "retry operator");
does this actually work ?
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
We should move the naming of the threads to common configuration as well. It is just easier from debugging point of view and production support can easily make sense as well.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
as this is public API we can not really do this as this is a breaking change :/
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
style nit: we don't use braces around single line blocks
We should just use String concatenation (due to performance difference I very rarely use format)
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
Please merge these two statements with an AND connector.
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Better, but use logger.logAndThrow(new ...)
Looks like the previous line of code should be moved after this if, otherwise we end up with the null key in the map.
Could you add some log message here? It is not good practice to ignore exception
It might be more clear that there is DB-specific logic if we do a switch(databaseType) and have a case SQLSERVER and then the default. WDYT?
Since there is an explicit coupling between lines 371 and 373 (if you were to reorder 370 and 371, it would break), can we factor those into a method that just returns the appropriate value?
Please remove system.out.println and add assertion
pvk should not be visible. Please remove it.
Method should be synchronized probably?
Better to add checkNotNull for the arguments.
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
Can you get just the crn from the database?
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
Constants? Already used and provided by Maven API? E.g. org.apache.maven.archetype.common.Constants
I am curious couldn't we just test this by default given that all schemas need to be present in "schema/" directory. we could just load all of them and based on what schema xml reference test that by default. Overriding is still fine for all corner cases but by default it shouldn't be needed.
Since this is a verification we should probably use any(CacheLoaderWriter.class) to ensure the loader writer is not null.
Since this is a verification we should probably use any(CacheLoaderWriter.class) to ensure the loader writer is not null.
this does not assertion is this wanted?
replace the if with checkIndex(toIndex)
Optional: this could be done without the index variable: for (int i = 0; i < emailPick.getItemCount(); i++) { if (value.equalsIgnoreCase(emailPick.getValue(i))) { return i; } } return -1
I would retain the existing indexOf body to to avoid indirection in the most common case.
factory must close its cursor (which is closeable)
close should invalidate the iterator, but you are reliant on the internal iterator for this. You should have a flag isOpen (or isClosed) that is checked for the various methods. Take a look at htsjdk/samtools/util/CloseableIterator.java You should also (evidently) call close() if hasNext is about to return false.
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIZATION. Please either make sure they are never null or use different objects for synchronization.
Could be suggestion return !selectedBaseResources.isEmpty();
this.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
should this count be parameterized?
A for each loop on the listeners can be used here instead.
Use filePath.startsWith('/') instead of filePath.charAt(0) == '/'.
Should we log this instead of printStackTrace?
while we are doing mkdirs in this method, perhaps we should also mkdirs() this hawkular directory just to be safe?
Fix the prefix, should be impl$.
Host.HOST_VELOCITY_VAR_NAME there is a constant for Host
check NPE and make SITE as a Constant
The icon that is set is the same as the archive menu entry found above. This is only relevant to Android 2 devices, but it is worth choosing something other than ic_menu_upload. Maybe stat_notify_chat ![image](<LINK_0> or something else from <LINK_1>
I'm assuming that the icon for this is being set automatically, since I don't see it in code anywhere. Can we override it? The icon itself is fine, but it's a grayish-black color and it would look nicer if it was white like the rest of our menu icons and text.
Use the pre-existing localized string R.string.multimedia_editor_popup_cloze, and definitely follow up on the "TODO" by using a static constant value instead of a magic number.
listeners are not notified?
Noticed txnIds is passed like List->Iter->NewList->Iter->NewList to several methods. This model have several copies. Instead, can we pass the same list (txnIds) all the way down to build openTxnMessage?
The outside check is for listeners but passed transactionalListeners. Need to check for both and need to notify both.
I wonder if it is better to pass the admin label here in getSystemAdmins()?
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
s/vmId, null, deviceEnabled/vmId, deviceType, null, deviceEnabled
that used to be a way to distinguish VM from the pool that is running for installation purpose and VM that is running and available as part of the pool - how would we do that in case of stateful pools? some time ago I thought about changing this mechanism so VM from pool could be started not as a part of the pool only through run-once (but it breaks API..), maybe we could apply that approach here
Enough: return foundDevice != null
to avoid a crash on orientation change in tablets we should add: if (handler != null && runnable != null) { handler.removeCallbacks(runnable); }
Please move super.onDestroy to the end of the method.
nit: @override in a different line
Please extract variables.
Injection constructors should be package private. Remove the public modifier.
I would write return services.get(url) here
Call setFocus() on the table control.
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
?? why this and the following ones could be left empty?
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
sorry, missed this first time through, I think we want to error if the URI contains the empty string, can we have a check for that somehow?
minor: this v == null check is unnecessary.
this could all be one line i.e: return criteria.list() > 0
You can do criteria.add(Restrictions.eq("experiment.ndExperimentId", experimentId)) I think
Can return uniqueResult instead of checking
suggestion LOG.warn("listOffsets request failed.", e);  Thanks! (minor suggestion to make the log message more typical)
Should we return emptyMap if we are SUSPENDED as well?
Yes that's right, but code-wise if the current restore consumer only contains partitions of standby tasks then the updatedAssignment.removeAll(closedTaskChangelogs); below would be a no-op since the updatedAssignment would not contain any of the closedTaskChangelogs (well, unless we assign the active and the standby of the same task to the same thread, which is even worse).
again, just set the element in the array ?
java this.onPostServerTick(this.getMinecraftServerInstance());
I believe we could set initial nextValueIndex right on attribute declaration, to avoid repeating it in all constructors. What do you think?
Is this a safety check? Whats the case where this would be null?
Make static
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Add a message to checkState so that it's easier to debug if we ever hit it.
Debugging? Remove.
It looks like constant, extract please :)
null or empty list?
why public? at most it should be package-private if this is test-only
Why is it a list of lists, not just a list?
Hm, should we thrown it as InternalProcessingException ?
revert as this code isn't used in this PR
specify charset?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
Since there are already multiple exit points, refactoring as (something like) below would make it much more easy to read:  if (jsonObject != null) { if (jsonObject.has("aggregations")) { return new Aggregation(jsonObject.getAsJsonObject("aggregations")); } else if (jsonObject.has("aggs")) { return new Aggregation(jsonObject.getAsJsonObject("aggs")); } } return new Aggregation(new JsonObject());  Other points: - getAsJsonObject instead of casting - the "aggs" passed to Aggregation seems like a magic value without any function, so I'd suggest creating a single argument constructor for Aggregation where the name is determined in that single point.
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
that class would be better with a builder, though I wouldn't ask changing it now
minor: this not required anywhere.
This should not be on fields as this is custom-role-mapper specific - not related when used as mapped-role-mapper in subsystem.
no need for explicitly using 'this'
Nitpick: space
Why is this no longer necessary?
Instead of doing this here in the transaction - we should do this in populateEntityDictionary.
Do we need this? All it does is assert that the message is equal
new Date() is already have current milliseconds as time
This code will repeat itself in every command test... Can we please have a sensible util to do this?
This function could use some auto-formatting.
for code readability it might be beneficial to provide some boolean accessors on the Assignment class for the various roles. if(mAssignment != null && mAssignment.isBlocked())
Maybe better to use android.R.string.ok, 'proceed' seems a bit formal and also sounds like you're about to take action which might confuse users - I feel 'ok' is more that just you're done reading the explanation.
This is not appropriately thread safe. Whenever you require synchronization you must make sure all atomic operations are performed under the lock. In this case, it would be possible for two threads to race associating the same async pretty printer with the request id and both would report that the key was not already there and then both would attempt to add it. This is solved in one of two ways here: a) use a different locking object and synchronize on it for the entire method body or b) take advantage of the fact that put returns the old value if it was present and throw if it returns non-null.
We shouldn't have to care if the request is done or not, just cancel the future.
I missed at the last review, but could we put this return true in else?
We can use getIntent().getSerializableExtra(EXTRA_COURSE_DATA).
Should change getActivity() to activity?
That is small duplication. If you add extra parameter key then you can replace two methods with one
We should set the collection of UEIs we're interested in, instead of a getting a callback for every single event.
give the thread a name by using Executors.newSingleThreadExecutor(new ExecutorThreadFactory("the name you want"));
This reads as if TenantIndex initializes the BoundedContext.
Ow damn, I broke Partitioned Search without realizing it because we clearly have no test coverage for it.
I prefer shorter method names, when the important information can be said by the argument type - which is the case here. LGTM.
1) Should the distinct happen here? I doubt it: I'd expect the first caller of getFromStreamList() to have to do the distinct too, so there it's a perf loss to do it in between too. 2) Is the distinct worth anything? Do the From's implement equals/hashcode? When in doubt, leave it out and put in a "TODO Should we distinct?".
dont think a setter type function should return the "this"
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Is it *guaranteed* that setDeliveryWorker() will never be called *between* calls to dlvWorkerLock() and dlvWorkerUnlock() so it's not possible to make a call to dlvWorker.unlock() that never had lock() called? Unlikely, but if it ever happens, debugging it will not be fun.
Why not use assertNull and assertNotNull?
coordinates 1000, 1059
coordinates 1000, 1001
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
In general we use == to compare classes (Cf. *AdapterFactory implementations for example)
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
This is needed as otherwise it will go into an infinite loop.
null checks?
Can header name and value be null?
This log message is not correct. The line above dir.mkdirs() actually tries to create the directory. This log message is in the event that you can't create the directory... one such example could be a file permissions issue. please revert this log message as it's incorrect as to what is happening here.
You may also want to verify that the dir is writable.
It's not an issue but I think that it's better to put the both checks on a single line (if (!dir.exists() && !dir.mkdirs()))
Maybe assert that #put() returns null
why not use a ConcurrentHashMap instead of making all these functions synchronized ?
Can the body be extracted together with commit() method to avoid code duplication?
this is odd -- is toSQL returning a string with two single-quote characters?
This change should be made also for DiskListModel
Not needed, part of constructor
nit: it's my personal style preference, but I much prefer instance != null ? instance : result.newModule() rather than the flipped case you have here.
log or throw. Don't do both.
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
Move String values used more then once to a constant.
Use a constant for this path.
Move String values used more then once to a constant.
Please let's use getUploadQueue() here instead - as mQueue could be null and we're using it like this elsewhere in the Service code
Can use curSelectedIndex.orElse(-1) + 1 here.
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Are we sure this is only happening for invalid username password ?
Why not : java try { return PAResourceManagerProperties.RM_UNAVAILABLE_NODES_REMOVAL_FREQUENCY.isSet() && PAResourceManagerProperties.RM_UNAVAILABLE_NODES_MAX_PERIOD.isSet() && PAResourceManagerProperties.RM_UNAVAILABLE_NODES_MAX_PERIOD.getValueAsInt() > 0; } catch (RuntimeException e) { logger.error("Nodes housekeeping properties are not valid. Nodes housekeeping will be deactivated.", e); return false; }
You broke the arguments list convention here :)
putIfAbsent returns the **previous** value associated with the key. Shouldn't we tear down apnsClient instead of client?
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
and here as well. It introduces some hidden trick which may bring problems in the future.
Does this work if transactionCallbacks contains multiple callbacks? If previous code causes recursive call, I would think ConcurrentModificationException would be thrown.
please revert the changes here - it'll cause to issues. the spms should be moved to prepare to maintenance last, so in case that we move to prepare to maintenance few hosts from the same pool the spm role won't be taken by any of those hsms and will start "flipping" between hosts, causing to many unneeded operations, therefore the spm need to change the status last.
Ditto about breaking.
can super be called first?
What did you testing here?
Will need a @since tag.
It's always used with join(), so I wouldn't return CompletionStage here.
space
<LINK_0> handled the case when metadata was null, does that check need to go here also?
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
I think this and the below line can be deleted.
I wonder more how the value gets put into typeNameValueMap as null. I'd rather fix it there.
This is one of the points we should use Zulu Time, but do use the configured default Timezone.
Instead of printing a stack trace to standard error, why not throw a SlimFixtureException with message that date can not be parsed and e as cause?
The codacy issue is because you reassigned this object here. This check ensures that you do not accidentally modify an object in a function. Using a new variable like newDate would fix the issue.
Can just use diamond operator on RHS
The reason of my suggestion to resolve errors using a map was to eliminate possible error caused by accidental lines swapping and to simplify finding the message by code without running the program. Current implementation doesn't allow it.
All lines between beginning of this method (and all others) and this one should become the setup fixture (@Before). Then, for the methods that require a writer or loader, you could just reference the CacheManagerBuilder field, and append .using(...) as needed.
We have a removeConfiguration so let's not allow null value here?
Also called twice here.
space
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Please remove System.out
I think we might want to separate out the concepts of hasIndex and isQueriable. In gatk we have a datasource that has no index but supports random access. I also think supportsRandomAccess might be clearer name. I'm not sure how granular we want to go though, you could potentially imagine a stream with an index that supports fast forward skipping but not rewinding, which wouldn't be easily described here either.
Return a failed future
Hii @ribhavsharma, this extra brace over here is causing the build to fail, kindly correct it :)
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
Do same for this one
This does not match the endpoint in connector :(
@ILikeToNguyen Why the change in visibility here?
from withLabels name, I would assume to use only given labels. However, this adds given labels to existing ones. There is very similar method withAnnotations that behaves differently. What do you think to rename this to somethink like addLabels? Or is there even a reason why to putAll instead of replace everything?
unneeded check
unneeded instanceof check for same reason as above
Stray doublenewline ^ Also the newlines on the individual parts I'm confused why this isn't formatted exactly the same as the EntityDamaged event, which I think is what you were referencing anyway? java return new BukkitScriptEntryData(damager != null && damager.isPlayer() ? damager.getDenizenPlayer() : entity.isPlayer() ? entity.getDenizenPlayer() : null, damager != null && damager.isCitizensNPC() ? damager.getDenizenNPC() : entity.isCitizensNPC() ? entity.getDenizenNPC() : null);
I prefer using String.format, it is true that I come from C, but formatted messages are way more readable than concatenations.
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
Nit: not needed
Same. Return int?
why Integer and not int ?
Unnecessary boxing?
consider saving the value of group 1 and group 2 here rather than the whole matcher
consider being paranoid and prefix with "line.length() > 0"?
> ~~~Thanks for your patience!~~~ No - on the contrary, thank YOU for your patience.
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
It is up to developer how to do it this check, but here we can avoid creating a list by using allMatch.
Hmm, does this work the same? The old one urlencoded the key and value?
this is incorrect (and should fail with my new test. This would mean that if disabled the output is null, which is not what is expected (we expect the list to contain a null value). Though I realize that this is not consistent with the Abi/Language version...
Lists obtained from a message are immutable. No need for extra copying.
could use a more meaningful variable name
you have to add a canDoAction message if you fail canDoAction
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
Missing space after 1.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Should this also handle the suffix 'es'?
Maybe use message "Config job.name is missing" ?
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
Shouldn't jobName and jobId be always available? Would prefer to throw if not instead of defaulting to arbitrary values.
Is it Novoda style to have this Exception in a new line? If not, could be better to have it in the same line.
Should this be in the block below to guarantee this is only called once?
@free4murad Why you put @Override in same line of method everytime :laughing:
Might be better to have dao.exist() and call it, but OK to do that later.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
assertFalse(...);
assertFalse(...);
Please use assertj assertion. In case of fail it gives error message explaining different list sizes. Current implementation will just print assertion error, expected true but was false with no reference to list size.
0 is a legitimate option value for min. selectable choices. Why not -1?
Can this be private, or is there another use case for default attribute outside the builder's call?
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
Assuming this is noting completion of initialization, perhaps "Finished initialization."
this log message is wrong, it doesn't download anymore.. same with the following log message. and there's no validation that "checkFiles" was successful.
Maybe it would be even more clear if createKingdom would take only the race as a parameter and handle the factory making internally?
<LINK_0> handled the case when metadata was null, does that check need to go here also?
Make sure you have a mutable details field here.
use this.mandoc to be consistent with setCtags() ?
Please use LOGGER.debug because this error is kind of expected.
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
How about narrowing it to ClassNotFoundException and fail with other exceptions?
isDirectory()
It would be nice to provide some feedback if this check fails. Like "The file BLABLA doesn't exist in the directory you provided. Please try again..."
Should be !socket.isValid()
Lol! You're going to remove that, right :)
have you thought about using the builder pattern to follow the code line in the other projects?
Create date once and use it twice. That way the acceptance time will be the same for both.
This also regresses in that it no longer works for multiple repositories.
Having an else statement in your poll() method means that your script will always be doing something, even when you don't want it to. What happens if the script gets stuck or none of your methods return the proper values?
only constants are in caps, this is a local variable
groups.isEmpty() is a little better
Undetected error condition where the personAttributesGroupDefinitionDao found multiple group definitions matching the name?
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
I'm not convinced we need this extra complexity. Could we just call logger.error("", runtimeException) without changing level or modifying any of the other code?
If the level is set to "" in the activation key, it will unset the consumers value (from a prior activation key)
I don't think you need to keep this variable, [with level you can know if the app is in the background](<LINK_0>
Hmm I'd suggest logging some kind of error message if ImageIO.read returns null. Otherwise map makers might not realize that an invalid image was attempted to get loaded
is it worth enforcing this locally? We might allow more colors in future.
suggestion final List<String> lines = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8);
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
creator may be null, this needs a check.
I know that checkstyle is disabled for this project (not sure why actually), but the EMF Compare checkstyle config discourages ternary expressions, so I'd replace this with a common if statement here.
This change should be made also for DiskListModel
can be !disks.isEmpty()
rename to delim
You'd better use a logger here to ignore the exception or propagate the exception using Throwables.propagate
An int type can or should never be null, maybe you want to use an Integer type which can be null. On other places you are comparing this with value 0, so maybe only a wrong written condition?
why not public?
use Guava lists for consistency + throughout code
stream & collect
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
maybe a word mistake? it is orc instead of parquet
Better do this as a static variable
see ^ and this is a code duplication
pvk should not be visible. Please remove it.
any reason we are using System.exit(0) do you see a hang without this?
Bad variable name! Variable names should be clear enough. Rename it.
We still need to call to deactivateParticipants()
This causes now editor not to open (sometimes) on BP hit if the debug view is hidden - all in a single window. Open Java perspective, start debugging, close editor, hide view, resume after few times editor is not opened...
Why isnt the reencoding happening immediately like for other messages (amqp standard, core etc) and expected behaviour, e.g. other areas of code and plugins are expecting the message to rencoded by calling this without doing extra work. I can be missing something.
why would this be required again?
Why return null?
Extra newline.
This is bytecode equivalent to using the for-each syntax on an array.
better to return an Empty Map, otherwise callers would need to check
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
There's no validation in here. I'm not sure if there should be, but we can't assume the UI will provide "valid" numbers. My guess is that we should have a min value and a max value, defined as environment.properties values, and ensure that whatever the end user passes in falls within that range, or is constrained to that range by the code, if we want to allow that
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
This is wrong. While yes, the "return true" could be made static, this is inherently meant as an instance method (thats why the TODO). We could either give it an instance field with a fixed value, or suppress the warning here...
if you remove the property, why aren't you removing this method as well?
Isn't encodedLength zero if the thing isn't encoded?
I guess we need a null check as well.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
I think it's ok to return null here, looking at how the GerritTableView is handling the result.
instead of directly accessing tagDisplayName, can we use the getter? This should also allow us to remove the parameter in isTagAlphaNumeric().
@jjl014 User id is optional, unlike client id and session id, which are required for user info
<String, Object> not needed.
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
Can session.getPath() ever be null? If yes, instead of throwing a NPE (which requireNonNull will do) we should do throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "Session path is null");.
Optional
Don't return null. Make it Optional<String>, and return Optional.fromNullable(...)
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
Is there a chance of a NPE? could be getFile() null?
?????
:astonished:
this ought to call verifyNoAsyncErrors(defaultTimeoutMillis())
Is it safe to let the else case fall through? Perhaps the entry display type should be the first thing checked in the method and return immediately if it's not DISPLAY.
If the event doesn't have a style, we should try to use the default style from its entry. This can be used for entries that want a specific style for their gaps.
They are all TimeEvent instances in current implementation so TRANSPARENT can never be returned (it should for filler 'multiple' events)
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
Gson doesn't run on these versions so I don't see any reason to include them.
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Update labels to go with method names. Alternately, call super.toString for super attributes
You might want to not over-complicate it and keep the toString of the Optional perhaps?
Is there a reason for not using the MoreObjects.ToStringHelper instead?
It should test against the list size. Probably more understandable using fCursor.
if this is a sealed segment, is numberOfEntries(mmap) a fixed value? If yes, it's worth keeping it somewhere without calculating multiple times.
should this be buffer.isReadable(size) ?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
again - encapsulation
Are Operation objects immutable? Otherwise you'd have to copy them as well
You could remove "verify that the" from the logging description.
please remove 'this' here and in all other waiting for elements methods
add this selector to UI mapping at the beginning
Not sure this would work. If 2 threads are racing for this code while val is still null, both can read val as null so both will create new instance and 1 count can be lost given the last of them will update the map so possibly using synchronized for cases like this is actually needed.
I'm not a big fan of asserts in production code
Delete this - it was just there during debugging.
Should assert on the message contents to make sure it's the right one that got through.
Formatting issue
Use hamcrest.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
Should use the log, maybe a warning.
Do we want to use the LOGGER as well? There are other usages in this class where we're using both.
That was exactly what I want.
Does it make sense to throw an exception here? It would probably be better to log the fact that there is no exchange and then ignore the response. WDYT?
Do you think if better handle the status code here: <LINK_0>, because that is the method sole responsibility to produce the correct HTTP response and thus you won't need any further logic elsewhere
What's the reason for marking all methods final? If you don't want this whole class to be subclassed, just mark the whole class final instead.
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Is this going to cause a problem upon restart? Should we log something higher than debug?
Absolute or just path?
file might be a directory - message will then be misleading
The code can be simplified to rely on autoboxing.
Don't you need a cast to byte: "byteBuffer.get() == (byte) 0"?
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
See the Headers class.
Can you please add ModelNodeResult#assertSuccess() to be sure that operation adding Elytron subsystem went well?
I'm really not sure about this. All existing Remove* commands in Creaper just do ops.remove, letting the command fail if the resource doesn't exist. Do you have any specific reason for doing ops.removeIfExists?
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
The test would be quicker if it waited on a CountDownLatch instead of sleeping for a fixed time.
not needed; just cut it
why do you have the same test case in two different classes?
Use logger
return 31*super.hashCode() + timeOut;
needs 2 _arguments_, plural
Could be extracted to a private static final constant.
IllegalArgumentException for consistency, needs 2 _arguments_
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
Make this AtomicBoolean
here too, or just log the error
Interface can be used here.
Use a constant.
You can use the getShallowKeys helper method.
nit. faster to write throw new RuntimeException(e); :)
"Initial connection"?
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
Extract a method for this. (You now have two 'ends with ".erl"' checks in your code)
Why do you not rename your extracted method's parameters appropriately?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Cosmetic: Please, change this to lowercase: suggestion logger.error("Before execute failed for [{}]", r, e);
I do not like this... but... I do understand. anyway, please drop the {} it won't get translated.
These might look a bit tidier as static imports
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
This is still wrong for HTTPS. S3Proxy has both a getPort and getSecurePort accessor. You should probably just create this URI once after s3Proxy.build().
Aren't these branches guaranteed to produce the same result?
Shouldn't this message disappear (be hidden at some point) ?
public void fetchTestInfo(final TaskDataDto taskDataDto ... is private case of public void fetchTestInfo(final Collection<TaskDataDto> taskDataDtos i propose to call second function (more general) from first one and avoid duplicating code
We don't use old style RPC calls on new change screen. It should be migrated to REST API.
Upon ValueChangeEvent<String> you would want to fire a ValueChangeEvent<T> to represent the change in the T value, so you have to know how to translate from String to T. ListModelListBox does it through GWT's ValueListBox, which translates according to index. You don't have indices, so you would need some sort of Map<String,T>. I would do that by implementing setAcceptableValues() in this base class, and in its implementation construct the map using renderer.render() for the map keys. The renderer for ListModelSuggestBox should just cast. Then when a ValueChangeHandler<T> is passed here, I would add a ValueChangeHandler<String> to the SuggestBox that calls handler(map.get(value)).
You know what, never mind, it is a matter of personal taste, I don't really mind.
nit: I'd probably include the arrow icon, as seen at the end of the next file name link to catch the eye better, but this makes sense to me too.
"amount of columns was typed: " + columns
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
s/Css/CSS and space after comma
Same here, a constant can be used instead.
do these test methods really require throws Exception?
create?
getRecords() is marked as @NotNull, and then returns null here. Something like throwing an UnsupportedOperationException would be better/clearer too.
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
Use LinkedList instead, as we need to remove its head frequently in endInput.
Local variable could be declared List instead of ArrayList. Is this worth caching?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
null? why not just a () -> {} ?
method name in log message should be enableConnectivityChangeReceiver()
Why not setLocalEditorStatusChangeHandlersEnabled?
we should probably also disable the button, if the selected index is 0 as we can't move it up
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
doc is missing
Same here: should be Branding, not ProductBranding
this seems unrelated to the setEmail call. Can we move this to a more logical place?
chooseHelpshiftLoginTag seems to only return wpcom, Jetpack and self-hosted. For when we are not sure which tag is the correct one, do you think it might make sense to add a 4th tag called "Unknown" or something?
Sounds a bit odd, better use "Expected %1$s to be a valid email".
no need for this.
I think buildBigtable*Settings should just return built settings and you can the InstanceAdmin one return null if the emulator is enabled
why this.writeLock().unlock() is not enough?
What if it's absent? In my account it may be absent, for example
@Happy-Neko We can avoid inline this variable to the first argument in assertThat instead of declaring a variable and using it just once.
While you are here, fix this line to do something sensible:  JsonObject e = new JsonObject(); e.add("keys", getKeyAsJsonElement(keys)); this.allDocsKeys = gson.toJson(e);
Use closeQuietly from Airlift Closeables. It handles null.
Is it really worth checking before setting it?
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Check first that target is not null.
This should also have a check for max of 25 like the constructor above, i.e. Math.min(...).
should be ...object instances can be deleted"
should this be more strict ? i.e. require at least one character inside the parens ?
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
It would be nicer/easier to debug if you extract the numbers with this regex: "^(\\d+)\\.(\\d+)\\.(\\d+)" Then do a comparison separately. java int result = ComparisonChain.start() .compare(1, Integer.parse(matcher.group(1)) .compare(14, Integer.parse(matcher.group(2)) .compare(0, Integer.parse(matcher.group(3)) .result(); assertTrue(result <= 0, "Expected BigtableVersion.getVersion() to be at least 1.14.0")
maybe rename this to show that it's usually a no op (e.g. addSdkLinkIfNecessary?
Why was if (!CameraManager.getInstance().hasCurrentCameraFlash()) not enough?
totalWrites -> writesSinceLastLog
Can you also capture stats on the hit ratio, load time and total weight.
Let's find a better name for _bufferSize
selectorExecutorPoolSize can be removed from this class.
getAttribute returns null - add null check
Why contains instead of equalsIgnoreCase?
toLowerCase
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
This should not be static. The choice of whether to use BMX should be per apache server, not per agent.
This is wrong. While yes, the "return true" could be made static, this is inherently meant as an instance method (thats why the TODO). We could either give it an instance field with a fixed value, or suppress the warning here...
Tip: If you actually didn't change the logic, please avoid formatting the existing code. You could have a separate PR with just reformatting and make it clear that there are no logic changes. It makes reviewing harder and you'll take longer to get it reviewed.
you could pass null instead of ""
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
Use ImmutableDataCachingUtil.getValue(ImmutableSpongeValue.class, Keys.IS_SNEAKING, this.value, false); instead so that the value can be cached.
Use the immutable value cache
Make this a final field - it never changes once the data is created, so there's no point trying to find the data each time.
You don't need the null check, the analyzer method accepts a null without issue.
No need for null check.
No need for null check.
Maybe use the orElseThrow method of the Optional here
More functional variant:  java Class<?>[] interfaces = serviceObject.getClass().getInterfaces(); return Arrays.stream(interfaces) .filter(interfaceClass -> interfaceClass.isAnnotationPresent(Service.class)) .collect(Collectors.toList());
it would be nice to have toImmutableList collector. Airlift/Presto have one. If you have some time you may copy it from them :)
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
return result != null && result.getCoverage(CoverageMetric.LINE) != null;
Unnecessary null check since the variable is Object typed?
nitpick - s doesn't convey much information - in the Spring world we use loooooong variable names :smile:
Why change from the constant to a literal here?
I think we need a docbook and/or schema doc update that "" means no serializer (and String is the default).
On reflection, I suspect that this was done for backwards-compatibility reasons, since overriding and delegating to base would be a behavior change whereas this change is only a performance optimization.
Why this change? Do we have audio streaming too?
if you do this, better put N/A :)
Are we sure a null never reaches this point?
What's the point of the 6 trailing zeros ?
i think we had talked about swapping the order of these so we can short-circuit?
Use Iterators.transform from Guava?
Let's rewrite it with the regular F.iterator F.iterator(dataSupplier.apply(filter), rowFunc::apply, true);?
nit: maybe keep the safe copy part of code?
Then this one could become java return ImOption.apply((Focus) getValue()).map(f -> f.getStringValue()).getOrNull();
Maybe just: java setValue(new Focus(string));
it's better to init customFields with an empty collection to avoid "==null"
It seems like you are expecting a certain exception here. Can it be made more specific than "Exception"?
this is the same as the one above except for the extra. Can we combine them, or have mutually exclusive asserts?
this method deserves a description
move this line before above line, After super.cleanup method couldn't do any of the server requests.
not needed; just cut it
Sorry but I did not find where we call the close method?
The @Override annotation should be on a separate line from the onResume method.
simplify this
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
I'd use warning instead: log.warn("No heartbeat message arrived from host '{}' for {} ms.", getHostname(), incoming);
Nit: would you like to say "flow pause requested by user"? It's not given that it will be paused at this point, right?
Can we make toString a little smarter and print out what's appropriate for weather or camera?
Unsigned types are not used in the current implementation. So, you can omit them.
A flip != 180 rotation
Consider moving to the Enum, also a bit confused on this - is it an "id" used for wicket communication - or is it human readable (in which case it should be translatable).
please remove this statement or enhance it to something more context/meaningful
please decrease log level to trace or better remove statement
please decrease or remove this statement
pvk should not be visible. Please remove it.
use Log instead of System.out
change variable to something more meaningful
The field should be removed as well.
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
This isn't a job. Please rename the object to match what the object actually is.
It doesn't look like you are doing anything with the bucket here. This can be removed.
If you'd like you can go ahead and add the name property to the job options.
This can be defined as Lambda
Similar
I know you were doing automated stuff and this is part 1 of 6, but we could inline function here.
Return value of the method is never used.
Return value of the method is never used.
I think this is up to embed the current index into the message but this will result in a message like where no index is printed. The escaped ' also seem useless.
The Exception is never thrown.
The Exception is never thrown.
Sorry but I did not find where we call the close method?
Don't we need to use .toLowerCase()?, I thought the keys where saved lowercase in the keystore.
you can create a temporal file by using FileUtil.createTemporalFile instead of handling by yourself. If you need to do this way anyhow, you could probably add a delete in a finally sentence
Don't we need to use .toLowerCase()?, I thought the keys where saved lowercase in the keystore.
Should you call analysisReady(false) here?
* shuoldn't we call super? * worth adding some log..
Check for null here: ScheduledFuture<?> f = handle; if (f != null) { handle = null; f.cancel(true); }
This isn't the listener I was worried about. This should be fine, as the main tab model is probably destructed soon after its view. What I worried about was the systemTree listener, because the system tree stays there and will keep trying to send events to the disk main tab view (which will not exist anymore). So basically, I think instead all is required is CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().removeListener(systemTreeChangedEventListener).
Unnecessary newline, and I would just inline (i.e. CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().addListener(systemTreeChangedEventListener)).
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
containsExactly oder isEqualTo verwenden
Can you add message to the assert so that its easy to tell which assert failed? assertEquals("Slot size", 1, slots.size());
test case works good but it is not clear where did I have got the resources for second card. how about splitting a method playPreparationStageAndBuyCardYearOfPlentyAndPassCycle() on several parts? for example: playPreparationStage() .nextRandomDiceValues(asList(1, 1)) // P1, P2, P3: -- .THROW_DICE(1) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) also create separate method passCycleAfterFirstPlayerTrewDice() when needed.
Can't be just assetListConsumer.accept(Collections.emptyList())?
Style issue: @Override shuld be on line above the method declaration
@garg-anuj Yeah doing that only.
Use try-with-resources so you don't need to manually close the session.
You don't need to commit when only reading.
Use try-with-resources so you don't need to manually close the session.
Shouldn't you just push this into the previous if? I don't see a point in setting the text of an empty string and not make it visible.
checkAccess method with a null value should throw an exception. IMO, we do not need to mock this class. This method should be altered to test for a null pointer expected exception.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
I think you're missing getDefaultConfigurationFile() here.
transactions should be enabled
Absolute or just path?
Could use constant in this message
There is an INVALID_NAME type you can use instead of OTHER. (Same for the NAMESPACE validation method).
why do we need to check this? I believe we can directly remove
Missing <>, this is a raw type.
Collections.singletonList
Should use Long.class
These should use the internal vectors instead of these variables. As-is, both sticks return the same values.
You have getters that handle the inversion... use them here.
Should this be getState() > STARTED? It looks like with >=, awaitStarted would be able to proceed to the state check when the state is not yet some kind of START_EXITED_*, and so it might fail when it should have succeeded.
Listener which does nothing, looks weird for me. Is it okay?
Assuming they are all workspace files, this will work.
from the readability point it's better to divide verification by given/when/then sections.
Something like return joinPagesNotNeeded.map(Future::isDone).orElse(true)
Change to just the remove call -- the contains key call is unnecessary (as remove will do that check anyway)
to get variable replacement you need to use the idiom: if (!validate(isClusterSwitchTypeOVS()) && !validate(...)) { return false; } where the predicate methods return a validation result instead of a boolean (which will encapsulate test+result nicely) there are lots of examples in other commands
simplify this to  return getVarArgIndex() > -1;
The board[x][y] approach doesn't seem too bad to me. I'm also OK with the proposed alternative, but then the variable names should be better. For example  for (Square[] row : board) { for (Square square : row) { if (square == null) ...
rename to resource
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Personally I prefer to set all fields using this. in constructors, but you call the shots.
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
This is bytecode equivalent to using the for-each syntax on an array.
s.a.
Should use Long.class
That's good to know.
does this actually work ?
URL Decode would be necessary for parameter name and value
We shall trim at the final values level but not the above layers. What do you think?
We could use assertThat(actualResult).isEmpty() here (and for the ones below) . This might be preferable because if the result is not empty, the error message will display the contents of the array rather than just the length. Sorry I didn't notice this in the first review.
isEmpty()
assertThat(topic).isNotEmpty();
Clean the "public" as well
Remove public. Also let's reformat all the ctor to our latest code style.
before with the other this?
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Thanks, can we also give a test case for Join relational expression ?
What if the storage domain was inactive and you moved it to maintenance and failed.
As we discussed before I would simply add an audit log as been done in line 133
I suggest to just change the current message - currently it is "ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL" = Cannot ${action} ${type}. The relevant Storage Domain is inaccessible.\n\ which is obviously wrong - I suggest to change it to : Cannot ${action} ${type}. The relevant Storage Domain is in status $Status.\n\ and that would make that message readable without adding code here and would "solve" it for all the statuses.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Verify that at least returns one element?
I think that now this is redundant, you already receive a list of disk images, also you can add it directly to the children list
As for the previous tests, the two assetions above can be removed I think. But I'm happy to open a new issue for that if you prefer That applies for all the other tests below as well
consider to use method reference
Lambda could be replaced by the method reference Attribute::getAttributeName
Please reintroduce the trace logging.
possible NPE
What about return VdsmManager.getInstance().getHostByName(serverName); host is not needed.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
event.equals("clear")
nit, brittle test code smell. If we change this string in production code, this test will fail unnecessarily. Recommend extracting the string to a constant, eg:  @VisibleForTesting static String NOT_ALL_UNITS_CAN_MOVE = "Not all units have enough movement";  I wonder a bit too if maybe the string that is displayed should be a downstream concern. For example, if we were to internationalize the strings (not on our radar, but for the sake of argument), then it will be odd to have the dependency on the string value. Perhaps a cleaner API would return an enum result, then the consumer could map that result to a string. That would make this test read more like:  assertThat(result.getValue(), is(SOME_UNITS_CAN_MOVE));  The other two enum values I would presume would be:  ALL_UNITS_CAN_MOVE NO_UNITS_CAN_MOVE  This also avoids a good bit of nullable args. Nullable return types are essentially a SRP violation code-smell, they represent values that have different meanings depending on the value. IE: if null, this variable means one thing (a flag), if not-null, it's a display string for the user. Having enum values would then imply non-null return type, and code that is closer to the front-end could decide about which display string to use.
This change is still incorrect
Arrays.asList?
why Object?
this will be now return Duration.ofMillis(getCapability(AndroidMobileCapabilityType.ADB_EXEC_TIMEOUT))
int ?
this could be done by a stream right? Like types = list.stream().map(e -> e.getName()).Collect(Collectors.toList())?
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
A data provider with a single entry is questionable. I was thinking the versions would be separate test cases in the provider (you'd have to duplicate the test string which is fine, and probably putting the getBytes call into the test method body) .That way, you could eliminate the rtCheck loop, and maybe the whole method.
What do you think of the following: java int EXPONENT_MASK = 0x7f800000; int EXPONENT_SHIFT = 23; int MANTISSA_MASK = 0x007fffff int MANTISSA_SHIFT = 0; // ... private void setTemperatureMeasurementValue(...) { // ... int exponent = (bits & EXPONENT_MASK) >>> EXPONENT_SHIFT; int mantissa = (bits & MANTISSA_MASK) >>> MANTISSA_SHIFT; // ... }
This looks like it can go back to having package visibility now.
may be we should assert on get() > 0
I think driverPool.forEach(d-> d.getDriver().quit()); would look neater :)
same as above, skip public
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
Looks like previously we have had a CorrelationDataWrapper instance independently of the userData, but now you restrict it only if that one is not null. Also I see that you are protected against null in the CorrelationDataWrapper any way. So, what is the motivation to not do that any more?
why not return Result<Exception, List<Index>> instead of throwing runtime exception?
Can use Optional to avoid null checks!
You need to create an event in frameworks/base/core/proto/android/app/settings_enums.proto
This should be getDelegate().getLowestClusterHBaseVersion()
completedPositions
Only here I see that the checking for whether tracking is enabled before logging an event. It isn't clear to me how that checking is handled in other places.
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
At this point I know we can assume mOnLoadMoreListener isn't null, but if this fragment gets used elsewhere we can't guarantee it won't be null. How would you recommend handling that?
Avoid using admin credentials
Shall we mention the exact cause in the assert message. In this case Error in scope creation with duplicate key?
What about just: return response.getStatusCode() >= 500? There's no need to build other objects here.
Why?
Did anything actually change here? If not, maybe we could keep the original version of this method to keep the diff smaller?
return Collections.emptyList();
Add Pagelogging
put method contents into private method with WebElement parameter
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
The local var is useless, you can remove it.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Would be good to move this contstant to this file and name it something like WIDGET_ANSWER_STANDARD_MARGIN_MODIFIER.
We don't want to any of the select widgets as we need the select options to spread from edge to edge. This change should be reverted.
So this will be used for quantity and duration too or you need separate ones?
userRepository and modelMapper invocations are not verified
userRepository invocation is not verified
It worth to check which mocks were executed. Use when(modelMapper).should()....
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Should be 404, not found
I like this approach putting current status in exception message may be useful for debugging if it ever occurs
Should be a SamzaException with a message, not NPE.
Is this call necessary? It is called on line 109.
Also mention that they will be ignored
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
assert.NotNull ?
Not sure, why not use @NotNull?
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
You can use CollectionUtils.toImmutableList
Why is this needed? You are already subclassing a CacheModule. This method body should only contain the lines 30-32
I think this should be in GerritGlobalModule, which requires moving this type to the gerrit-server package. But if we ever support editing permissions over SSH (which git-store enables!) we need to run this logic in a context where the gerrit-http code might not be visible.
This should be declared in GerritGlobalModule.
I think super implementation is correct (size == 0). Nulls are still considered part of the list, they just take no memory in internal structure.
Same here, add deprecation flag.
Looks like there are some spaces missing here.
Shouldn't this be wrapped in a try... finally block?
Please, also verify the call of the chain.
again, this cannot be, there cannot be unconditional chaining... the nego should be able to stop the chaining, please see current implementation of nego.
Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.
A few questions: - Could/should this be only attached if the attribute is of type map? - What happens if there is a composite which modifies two map attributes? I think then only the first map gets stored here?
Both of these are 6288
Would it make sense to add something this.caches.clear() to the stop ?
Add a proper log message.
Add markInitialized() after assertion, in case of "-ea" is disabled ducktape hungs while waiting service.
is it ok by the formatter?
why?
It just make it simpler for the next guy to know that you didn't use package private by mistake.
Let's avoid long code lines. Maybe it's better to use java.lang.String.format method? Also, please double-check that single quotes are not missed.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
not a big deal but you can read in a local variable customCleaner to be sure that is not null while accessing the second time
As a read-only view of an existing buffer, some users might expect to be able to still read past the initial capacity if the source buffer's capacity increases after this was created. This buffer would end up in a kind of weird state where buf.capacity() > buf.maxCapacity()...
why rewind?
Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Don't need to print the stack trace here since its been logged
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
Fix indentation. Note that jclouds uses 3-space indents not tabs.
Instead of doing the string replacement, we could also use suggestion final String randomID = new AbstractID().toString();  this would be a bit simpler.
configuration should be injected, not read from system properties in the constructor.
Remove this. Let the test propagate the exception and fail.
return index == 0;
Why not <code>return ExitStatus.COMPLETED</code>?
merge else if?
(Alt) Can we move the skip condition to the testSetup method just above.
suggest to use truncate or provided another truncate method. The same to all other datatypes.
i think you should be able to pass in config directly
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
are you sure you want to search for translated tags only, don't you think it could be better to search for the tags value and the translated tags ?
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
Do it also work with requestLayout() which is an asynchronous layout call?
This should be object Id, and it would be different from StorageId if it's not root directory. Could you check it for sub-directory case?
requireNonNull
No space after !. And Framework#isBooleanPropertyTrue(DISABLED_ISLATESTVERSION_PROPERTY)?
Should we have a constant for this?
Why don't you just use Boolean#getBoolean()?
I think you want to specify the encoding explicitly here.
You could also use path.endsWith("/")
Prefer [java.nio.Files#createDirectories(Path dir, FileAttribute<?>... attrs)](<LINK_1>,%20java.nio.file.attribute.FileAttribute...%29) (and maybe [java.nio.Files#notExists(Path path, LinkOption... options)](<LINK_0>,%20java.nio.file.LinkOption...%29) on the line above, although this has slightly different semantics)
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
no need to instantiate this hashset (not being used?)
These two lines get called repeatedly in (i.e., 87-88) several of the methods that follow. Would it be worth creating a private method that returns the objAcls?
We only want to take the hit of saving the message in a TL __if the poller is transactional__ - we can easily tell that in the XML parser and via the DSL spec, but not so easily via the @Poller annotation; we may need to add a transactional property to @Poller for that. On the other hand, any "around" advice that can throw an exception may need access to the message if it throws the exception after the proceed. So, I don't mind if we always apply it if the advice chain is > 0 length - that's probably the simplest solution that would work in all cases while only taking the extra unneeded hit if someone configures an advice chain.
the default should be made a constant somewhere instead of being defined in multiple places
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
typo "should", also "In case".
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
Take note for an other CL, I think this test should be move up if CTF accept writing a 0-bits struct (or int). I know, it's stupid. Keep it as a separate commit.
Similar to PUT, perhaps split into separate function?
You need to validate that the workflowVersionId exists.
I find it more intuitive if the @Auth User user is @Auth User authUser and this one is just final User user because the 2nd one can really be any user if the first one is an admin
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
No, we don't want this for the grouped item, it will be overwritten, so ungrouped should not be here.
ss.getCurrentEndTime
FYI, proper English grammar is "must not be null" or "must be non null" (I'm not sure if grammar requires a hyphen in "non-null").
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
@lautarobock Same here, let's declare throws Exception
@lautarobock Here too, let's declare throws Exception.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Wow. This method is much more elegant that it was before :tada:
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
How this else block is possible?
trace
trace
log.trace
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Please use Optional.ofNullable()
you can use  return CollectionUtils.map("inode",contentlet.getInode(),"languageId",contentlet.getLanguageId()+"");
Why not let this method throw IOException and change the caller accordingly?
Should this method be private or protected?
This is strange.
This could be a singleton
Is this an pattern? Weird for create to not create.
Since this is not an exposed interface it is OK to change the signature. But, I'm curious to know that any other project or users depending on the revision number.
conditional could be clearer here.
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
There is already logging for that in the EncryptionUtils.encrypt catch block
Please add an explicit encoding (using 'ISO-8859-1') when converting the string to bytes.
This should be imported.
Small change, but can you swap the check around? First evaluate the ConcurrencyCheck. As this check has a greater chance to short circuit the conditional sooner.
ah, there it is.
nit you can merge these lines
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
this should be called only in endWithFailure()
let's change the order in the ctor - its clearer when the source is before the dest :)
1. this file isn't related to the create snapshot flow. 2. do you persist the placeholder to keep it compatible with the rest of the code?
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
copy paste error here in these 3 lines
minor typo: SEPARATOR
Might be worth having a displayName?
Nice2have: make it localizable
Should this be "Upstream Committers"? Also, it might be good to move this to a Messages.properties file so it can be translated.
Would we want that exception to make it back to the JS caller?
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
Fix logging level here (error)
I'd not thought about putting the logic to determine if it's a soft decline in WorldpayOrderStatusResponse. Good idea. (While I still think this class and its friends conflate being a representation of the actual response and our interpretation of it, this is what we have for now, so putting this new logic in here makes sense).
shouldn't this be done.setValue(true)?
Shouldn't need to recreate this every invocation. Or at the very least, just make it a lambda
In a good implementation, the spatial reference instance should be shared between all instances of geometry coming the same dataset, so usually the esriSR size would not contribute to OGC types, but we don't enforce that on geometry side right now.
How's this possible? there was no byte to transfer (transferableBytes == 0) yet transferredBytes could be > 0
you can use Objects.hashCode()
Why can you not have both a pre-login handler and a pre-register handler? You can when not using id site.
If not null? JavaUtils ?
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
return getForecast() != null ? getForecast().toString() : "FORECAST IS NULL";
Should this method be final?
This should stay final
this is typically done by having a LoadSpec implementation that wires up the json config to the puller (see io.druid.storage.azure.AzureLoadSpec for a good example)
This can be static.
Is there any way to tie this to LoadLocalSpec ? parsing the loadspec and calling getPath seems a little extreme for here, but can "path" be put as a public static final String in the class or something?
We also need to replace childTraits with enumerable convention. also hashjoin.
This is not correct.  select distinct a, b*2, c from (select a, b, c from foo order by a, b, c limit 100) t;
should be assert?
I would always suggest logging the full exception at DEBUG level for troubleshooting.
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
It should throw exception
@paulodamaso the braces and return are not needed here
@fanifieiev the same above.
@super132 I think it is better to use Collections.emptyList() method instead of static field
ARRAY_ELEMENT_DELIMITER is also a single character in CsvValidator.
The community recommend to use List ConfigOption for list values, framework will handle the parsing. This will also change to use ; as the separator, but this is more align with other list options. You can declare a List ConfigOption by : java public static final ConfigOption<List<String>> TOPIC = ConfigOptions .key("topic") .stringType() .asList() .noDefaultValue() .withDescription("...");  Then you can call return tableOptions.getOptional(TOPIC).map(t -> t.size() == 1).orElse(false); here. Sorry for the late reminder.
This would be a good time to change this to fire exception via the log object, i.e. org.infinispan.util.logging.Log.invalidConfigurationIndexingWithInvalidation
Do we want to include input "type" as parameter in exception for debugging?
Could we reuse instances? Perhaps justified if getCoder is frequently called.
we'll never reach break;
RuntimeException?
RuntimeException?
Haha! I found one redundant symbol on this line!
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
0 is a legitimate option value for min. selectable choices. Why not -1?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Even though it's java there is no reason for trailing spaces
Can be done like this: @Test(expected = NotFoundInDbException.class)
" throws Exception " can be removed
You can put the whole ability text here instead of calling the super but if you don't you should add a comma after "steps"
You can just put the whole trigger text here instead of calling the super, it'll keep you from having to use setText on the token effect
Please String.format() this.
An alternative here would be to use a Set instead of a Map and assume that membership in the set means that the corresponding event was detected. Clearing out the set is simply a call to .clear(). If you prefer Map then going with an enum and iterating over the values would be less error prone for additional states.
IIRC, the interpreter name is configurable? eg. spark is spark2 in some config. so likely you shouldn't hard code submarine
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
Maybe, debug would be more appropriate then?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
endless recursion? should it be org.apache.dubbo.common.utils.UrlUtils.parseURLs(address, defaults).stream()?
I would name this method (and the following one) just containsOrderless, i.e. provide 4 overloaded methods with that name.
Given that containsOrderless already does a Util.distinctList(keys), we could skip it here. The same applies to collationsContainKeysOrderless
Yes, I thought not one time that use extra object to just get friendly accessor to the value isn't good idea at all... Let's don't use it in the canAdd() as well ! Anyway why member.getHeaders().get(IntegrationMessageHeaderAccessor.SEQUENCE_NUMBER, Integer.class) doesn't work for you here? Looks like pretty parallel with what you do manually with this if..else
factory must close its cursor (which is closeable)
verifyCannotSignUpOnDesktopAs?
Would be cool to turn these strings into const values and use it, such as is done with i.e. PASSWORD_MATCHING_USERNAME_MSG. But it's not a game changer of course. :)
Not 100% sure if we want to swallow Errors - should this just be Exception?
Catch exception.
Mark as static.
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
Better revert.
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
out of curiosity: what meaningful exception could possibly be thrown here ?
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
Wrong event name and bi value is getting passed here. It should be **VIDEOS_UNIT_DELETE**
remove ;
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
40?
final
keep primitive, it's not used in JSON and can't have null?
Please extract messages to public static final
Since this logic is getting more complex, it probably makes sense to reuse isBindableType here.
See, here the problem is apparent : you are calling this in many cases where it's not needed. I suggest this should be called onStartProvisioning (or onBeforeProvisioning in this case maybe, because it has to be done before provisioning starts ?) and only ever called when provisioning is actually started, not every time this function is called.
This is easier to read as: return type.getClass().isArray() || isList(type);
add a cache
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
Consider extracting this to a method since it's used again in isDiskInterfaceSupported.
At this point I would just return allDomainsHaveSpaceForDisksWithSnapshots.
nit: method name is awkward, maybe better just whenStandardClientStartsTransactionTimes? Also goes for all the subsequent methods
huh? please inject a TimeSource that enables you to simulate time - that sleep needs to go
Done, it looks like the change was not included in patchset1.
protected not needed. Android Studio warns you about that. ![Screenshot 2019-03-13 at 17 28 17](<LINK_0>
is args nullable?
Should be create, not label.
remove double a valid from test & implementation
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
throw exception
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
truck is unused
This check is redundant; the projection in the query is just 10 lines up and there's only one column.
Why is it a list of lists, not just a list?
Use LinkedList instead, as we need to remove its head frequently in endInput.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Maybe just via backspace? I've never really used the case list search functionality on older devices.
feedDisplay is a strange name. I had to look at the xml file to find out what it actually is. How do you feel about feedDisplayContainer? I know it was like that before and the guidelines we have come up with say that it is not necessary. How do you feel about this? Should we update the guidelines?
Shouldn't errorContainer.setVisibility(View.GONE) also takes care of notificationButtonView since it's a child of errorContainer (Not putting this for other use cases, but should get corrected for install and update as well if we do it here)
use .getUuid instead of getArtId, which will go away
use .getUuid instead of getArtId, which will go away
use .getUuid instead of getArtId, which will go away
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
Looks like we have unnecessary parenthesis here.
URL instead?
What's the point of adding a copy here?
This will throw redundancy warnings in IntelliJ
You should be able to use the diamond operator here, i.e. new ArrayList<>()
A for each loop on the listeners can be used here instead.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
Pull this into a static final variable
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
In case self is a BufferedIterator should this return self instead of re-wrapping?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
If fOperator is op_throw, we need to return true :)
If there's an overload the result should be (overload is noexcept) && (arg1 is noexcept) && (arg2 is noexcept).
(overload is noexcept) && (argument is noexcept)
for readability, consider extracting it to a method..
This is done either way now, which looks logical. Just making sure not by mistake.
It's better to return a message upon canDoAction failure, something like "Cannot ${action} ${type}, this operation is supported only for image disks"
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Why don't we set name to empty string here?
Why empty string and not null?
Maybe do a null check.
Please shorten these two config keys.
use a dedicated method hasParameter(tree)
![MINOR](<LINK_1> Replace this if-then-else statement by a single return statement. [![rule](<LINK_2>](<LINK_0>
There could be other cases where STDIN is referenced and an issue should be raised
I think it makes sense to add a generic method for handling an IOException instead of repeat the logic in every method. Something like: java static BadMessageException handleException(String format, IOException e) throws IOException { if (e instanceof ZipException) { return buildBadDataException(format, e); } else if (e instanceof EOFException) { return buildPrematureEofException(format, e); } else { throw e; } }
The two catch clauses with RuntimeException and Error can be replaced by one with Throwable.
Should the log level be error instead of warn?
No shallow copy as it was the case before?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
redundant ";" character
minor: don't need this. qualifiers
channelId => channelName
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
Wouldn't we want to unify these names and pick either onReady or onDataChanged? Other than that, LGTM!
Hmm now I see what happened here. Having init be protected and called by the super class definitely "smells" and makes me think we got something wrong. Seems like the problem is the circular reference between the adapter and the array, even though it goes through the SnapshotParser interface. Any thoughts on how we can make this better?
Does mean there's no signal for "the user typing out a correct entry, not clicking on the entry in the list, and then clicking on the next question" which results in the value being set? Clicking the ">" or swiping would do it, since that triggers a "get answer", but I wonder if, say, losing focus should also attempt to set it?
I'm not sure if we should add this to the interface. Not all implementations need to generate data ids in this method. How about removing this and instead throwing a RuntimeException at the implementations that use DataIdFactory?
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
specify array length (based on codecs.size) to optimize. <LINK_0>
The value returned by isPlaced depends on the mapped flag as well. It would be a lot simpler if this provider had tuples of [seqID, start, mappedFlag, usePositionDeltaEncoding, expectedIsPlaced], with test cases for each possible combination, and the test just created a new record for each case using those values, and verified isPlaced.
@Nadahar Right, text/vtt, i was too fast...my bad.
Perhaps there should be some validation that if the name is the same as the current name, then to reject (ie the new name must be different from the current name).
I think the condition needs top start as fieldName.length() > 1 instead of fieldName.length() > 2 . I think the generated code getters/setters has same rules for fields **aField** and **aF**. Or am I wrong?
Why not Boolean.hashCode(...)? not a big concern here, but larger figures (and primes) would probably be more fair towards hashing structures.
The "encoded" field should remain null. There should be a "byte[] hash" field instead. Also, charset encoding should not be used for hash password types.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Can this be private, or is there another use case for default attribute outside the builder's call?
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Please remove the public modifier
Constructor can be package now.
Can we get some more information on the magic numbers here?
I'm a little confused on the decimal to String conversion, is there any reason we can't use %+02f anymore in the String.format call? Are we looking to get additional units of precision in the decimal part?
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
I didn't know the string "null" would become an actual null!
Niche!
I think we probably want to assert on it not being there with any value.
simplify this to  return getVarArgIndex() > -1;
nit: don't need this return false; line
:bug: Binary compatibility
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
Instead of sleep, what about replacing with CountDownLatch? We can unblock through the code rather than depending on the timing schedule.
:astonished:
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
You can use for-each for arrays too, for (String name : names) { !hasEvent(name)
How about checking numberOfEntries != 0 instead?
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Will you be able to put methods that send broadcasts into your RecentListActionModeUtil?
& let's not forget about this.
Please extract this string
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 006 and 007 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 003 to break dependency from 001 and 002 to be successful
I didn't even realize that we have logic in otj-server that also copies conserved headers to responses, apart from what already happens in otj-conservedheaders. Would the be any way to consolidate this logic in one place?
Method name is missing from log message.
this should go to login I think... 1. redirect to external 2. apache takes over 3. user press escape 4. we reach here 5. we should present login and not redirect to 1 and loop
Did you intend on nesting the code block in a paragraph block? If so the method name should be changed to indicate what this test is about.
redundant
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
Please don't use null here. Just pass "" and make stateKey always concatenate.
nit: Use StringUtil.EMPTY_STRING.
This reads as if TenantIndex initializes the BoundedContext.
The SSLContext should be exposed for configuration so users can set the keystore, truststore, protocol, etc. TLSUtils has some examples for doing that, used by SSLContextProvider for the internal HTTP client
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
same here about the finally having a return statement
Can this be private, or is there another use case for default attribute outside the builder's call?
scheduleTimes --> scheduleTime
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
you removed stats.waitUntilBuilt(). Why?
return the entry id of last entry
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
it would be better to reuse:  <LINK_0>  to construct PagePosition iterator.
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
check if getters1 is null and remove firstTimeStream
I think you mean (d<=0)
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
NB: the logic here is slightly strange, although I think it's probably fine. We potentially spend our entire time budget awaiting for termination on the first non-terminated channel we find. Of course the implementation of awaitTermination doesn't actually do anything either other than just sleeping for the entire allotted time, so again I guess none of this matters, but it's still weird to me. It would read more natural IMO if we just first checked for any non-terminated channels, then if we find any, slept for some increment, checking all of them again, but I imagine this is not worth worrying about.
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
suggestion @Override public void onSaveInstanceState(@NonNull Bundle outState) {  Can we move the @Override annotation to a separate line for code style consistency?
"isSearching" should be a class level string
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
Did you mean to make it a constant?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
So this will be used for quantity and duration too or you need separate ones?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Use File.Separator - not "/"
Are all recipes groups uppercase?
This is not a good default. Some providers might not use the generic state type name (and only use the state type name per entry). Or some providers might use a state type name that clashes with another plug-in's providers, and they would inadvertently share color settings. It should be something that is guaranteed to be unique by default.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
What's the point of adding a copy here?
Shouldn't this be set to true as daemon threads do not prevent the JVM from exiting when the program finishes.
In this case, we may have untraced unremoved folders that litter the system. Should we use non-daemon threads instead?
You might want to shorten the name a bit, as it's going to be quite long. Also I would recommend doing %04d
Collections.EMPTY_LIST
Why don't you send the visible entries to this method in parameter, it would be thread safer
could just return null by default
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
this IF block is repeated multiple times, can you please extract it as method?
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
not needed, empty c'tor is just for satisfying gwt. its modifier can be reduced.
It might be more readable if you have one setter per line.
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
In addition to methods, we could also cover functions and anonymous functions. That's what we do for [JavaScript](<LINK_0>
the tree is necessarily a NewClassTree here, so you already know it's going to be of the good kind. You can drop the if.
bad hashcode.
could this be 8? the size of a char?
Suggested getClass().hashCode() as something "more random"
This is always FALSE. since name is static final
name should also be checked.
Missing hashCode method.
maybe default to ":" like in other cases?
NIT: else Logging or IOException
Not blocker: please put a space after "catch"
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
can you please factor this one step further and make a parseWithGrammar function that takes a CharSequence, a Grammar, and a start symbol? And then factor out the code which generates a grammar from a Definition. In particular, for performance reasons it is going to be necessary that the grammar only be computed once for multiple executions of krun.
The only downside here is that one of these parser will end up existing in each thread. Depending on how much memory is retained by the parser once it loads all configuration, that might be an issue (I just don't know). Right now it looks like we do have 2 instances of those which means 2 instances of parser per thread.
computeIfAbsent
Should getValue() be tested for emptiness as well, due to subsequent .get(0)?
I think you can remove the surrounding if, it's quite safe :]
We'd want to use Collections.unmodifiableList() here also with null check
Load and termination parameters should belong to Load and Termination entities
Hi Tolis, would you mind to move the code below to another class?
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
EndOfStreamException is never thrown in this method, as far as I can see.
It probably makes sense to extract a constant for new ICPPFunction[]{}.
Use same order as the field declarations.
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
Shouldn't we use empty list here ?
Same as above, why not use try with resources?
Can we invert this, so GET and HEAD are allowed, everything else is denied, prevents accidentally opening up anything else?
Can be move into the try block.
If we are returning Mono<Response<T>>, then method name should end with *WithResponse. In this case, getKeyWithResponse.
do add a null check for options before invoking the getter for ifMatch.
@JonathanGiles TextAnalytics uses List as input param for collection while Search uses Iterable. Do you have any guidance on which one should be used?
this is potentially costly, depends on what asMap is doing. Maybe getIfPresent and check for not null result?
I would prefer we do not change the behaviour of this method and keep it as is. Also there are no tests for these changes.
@ivange94 please use hibernates criteria like we do in all other hibernate DAOs.
any difference between this test and the previous one?
can't this be defined as a List<DiskImage> ?
No.
Why this change here?
The date string format should probably be a protected static constant. Also do we need the temporary variable? (This method is called many times a tick.)
Was seconds an intentional omission here?
>byte[] [](start = 11, length = 6) DecryptResult
Sync clients cannot use withContext. You need to explicitly add a Context to the API args. Note that Context is supported only for APIs that return Response<T>.
return HConstants.EMPTY_BYTE_ARRAY; ?
Why need "bytesRead > switchToNextOnlyBytes"? Can do it directly?
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
Use Objects.equals() to handle nulls concisely.
Instead of this, check if the String values are equal.
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
Probably better to use computeIfAbsent() since it computes hash less time.
if c!=NBSP NPE may be thrown
reuse getAcceptableTokens()
try (JarFile jarFile = new JarFile(srcFile)) {...}
if we use address instead of null when creating an ActiveMQDestination, we ensure that the fields are always non-null and this method can just return name.toString()
(non-blocker) under the hood this does Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); for every jar file. Is it possible to simply have a static Matcher, or Pattern? Note that Matcher instances are not thread safe but Pattern is.
-1 just noticed now: forgot about skipExec here. This must also be handled, otherwise it will be ignored now.
Annotation values cannot be null,  @DockerFixture( , dockerfile=" ")  seems like an unlikely user mistake, and comparing to "" is deprecated. This method could just be inlined as  java !f.dockerfile().isEmpty()
shouldn't be the max() between offset and skip to avoid the pos to be previous than offset?
Please take into account that t could be null.
shouldn't be setDaemon(true)
add an import instead of using fully qualified name
Entity#getTags returns the original set. While I don't see any vanilla code that makes use of the fact that the backing set is mutable, mods very well might. It would be stupid for them to do so, but they might. Thankfully, there is a really easy way to sidestep this: make this method return a Collection<String>! While Java doesn't let you vary only by return type, no such restriction exists on the JVM. That way our method and the vanilla Set<String> getTags() method can co-exist peacefully.
log.error("An error occurred while listing active session.", e);
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
the 10000 looks like a wrong digit.
What do you think about: suggestion return Objects.requireNonNullElseGet(apiVersion, APIVersion::latest);
Why does max gauge do the check on set and a regular gauge on measure?
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
You may want to do: <LINK_0> since it also trims the string in case the input value has leading or trailing whitespace.
maybe test first char for empty letter as well to reuse s if possible?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
ChannelClosed needs to be added to (though not strictly necessary)
All above cases can be removed?
This list needs to include soul lantern.
Inconsistent Upper and Lower case in description
Unsigned types are not used in the current implementation. So, you can omit them.
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
I think the old way is correct as these methods are public factories for the class and thus are logically part of the class' public API. Visibility is controlled at the class level. Similarly, if we have a top level package-private class, we'd make the methods public rather than package-private. In addition to being more clear about the public API, it's a one line change if the class later needs to become public (instead of changing / thinking about each method).
Is this testing against only the credentials being null or both credentials and authentication scheme?
Should close kill the memspace? What if someone want to reopen the key?
nit: public static void But public here is irrelevant. Its only as visible as the inner class, which is package access. You can skip the public keyword.
Not very clean in this commit
same as above, skip public
calling super not needed
No need for super()
are these setters used anywhere?
I don't know, but isn't the class also of interest?
Doesn't String.format need a value to be formatted?
Why can't you just return value here?
Not sure if you wanted to leave this hardcoded?
Maybe leave out this newline, note that it also is a notice in the (upcoming) release of the static code analysis.
TO_DATE() will change the date to local date, as a result, we lose the hour/minute/second info. Won't the Time object created here all be 00:00:00?
Should we be checking for null before doing a toString()?
Consider refactoring this to use a StringBuffer for building up the return value. Absolutely not required for this PR.
It seems like the number classes in java 1.8 have BYTES size constants (like Integer.BYTES). We could consider using these here.
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
I don't see the point for a wiki page, if the wiki page did not changed then why could we need to invalidate the cache ?
This lambda can also be eliminated.
You could use a Multimap instead
Collections.EMPTY_LIST;
Overload toMutations if possible so null isn't required here.
For loop?
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
For each?
Generally we don't check for GTK dev versions. GTK3.21 is a development version, so this call should be GTK3.22.
This case statement for SWT.DEL can be moved to already existing switch-case for wParam below.
- Will suggest not to apply Ctrl_BackSpace feature for Passwords Text field, instead return. For this include PASSWORD in above if condition: if ((style & SWT.READ_ONLY) != 0 || (style & SWT.PASSWORD) != 0)
return Promise just to symmetric with start()...
There is one case we may still want to clear db here - when one of the ZooKeeper critical threads (such as * processors, session trackers) fail, ZooKeeper server will shutdown (see runFromConfig) and consequently invoke ZooKeeper#shutdown. In this case, I don't see a particular reason not to clear the db, though not doing it might be fine (as one could argue the server will be dead anyway), but I tend to lean towards the safe side on cleaning the db. One way to conditionally do that is to add a Boolean parameter to ZooKeeper#shutdown so we can have fine grained control over when to clear db in what code path.
After shutting down the Executor, we should explicitly set it to null which is more friendly to the GC.
This should be logged as error, if an exception gets this far it's most likely a bug in the custom menu items.
I think its better to rename the function deleteResultsByID to deleteResultsCollection. It should take Collection<AsyncQuery> as an argument. All of the iterator logic can be then moved to the function implementation. The reason being in our database interpretation we have to delete each row one by one but for a filesystem-based, we can delete multiple at the same time.
catch throwable in activate method
The message here should be: diff - "A delegate item reader is required" + "A delegate item writer is required"
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
why are we doing a bean lookup here?
We can shorten this condition: java (StringUtils.nonEmpty(value) && constraintType == null)  FQN for StringUtils is org.kie.workbench.common.stunner.core.util.StringUtils
Nit: No need for final.
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
Do we want a space here before the brackets?
these should be 2 separate tests
Files.write could be used instead
Change this to PDataType.VARBINARY, as that's what the evaluate method returns.
Why return null?
This return value is incorrect. Please create a new card type to represent this card.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Same feedback as other classes. check equals(), equalTo() methods in the changeset
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Why not just mark the whole method as synchronized?
These methods don't need to be synchronized any more due to the ConcurrentHashMap and the use of atomic operations.
This should simply invoke the new method.
I think this is unnecessary => "profile =" + this.profile is sufficient.
Same as above for toString(): <LINK_0>
Guava has Objects.ToStringHelper() to make it nicer.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
This seems unfortunate. Does the RS spec forbid null values?
we need hostName only to log error. Please call it there.
What if client is null?
The above code is needed because you do this check here. There are more than one notification when we start or stop a vm. We need to be smart when to remove the client from the map.
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
You need also to do configureConsumer(consumer)
You meant a consumer here I guess?
Missing types
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
Missing types
I see that one method above you check instancof ArrayList. Is it ok that you check here instanceof Collection?
Collections.emptyList()
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I think we probably want to validate that userAgent is a valid form
this can actuall be: this.causes = new ArrayList<>();
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Why do you include the size of the binding set as part of the hash code?
run already called tally, so do you need to call it again?
Just curious: why checking 'isClosed' ? Can't we call 'close' multiple times?
the null check is redundant here if you refactor this code to something like below  if (SAFARI.equals(wirApplicationName) && SAFARIBUNDLEIDENTIFER.equals(wirApplicationBundleIdentifier)){ return true; }  since we are now comparing a String constant with a variable contents, null check is automatically taken care of because "".equals(null) is always false
I think we should use leftOperandList.containsOnlyConstantAndParamNodes() here just to be consistent with the right.
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
do we want to assertFieldCountEquals here?
Style-nit: You can just return Collections.unmodifiableList ... here and avoid assignment back to l.
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
Should close kill the memspace? What if someone want to reopen the key?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Very nitpicky, I'm not sure if we gain much by verifying the parameters of this test, we could make this more flexible by just asserting that any arg is passed to connect blocking.
Don't forget to disable the CrashReporter as well :wink:
test will success in old versions
This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery
should this be on top?
Should workbenchLabelProvider.dispose be called as well when non-null?
These magical values (NO_KEYS, NO_SUCH_USER) are going to be trouble. We can't tell them apart the empty list that was stored in the cache because they all serialize out the same way, so they deserialize into an empty list. You probably need to add a field to the SshKeyCacheEntryIterable to tell us what type of entry it is, and get rid of the magical constants NO_KEYS, NO_SUCH_USER and use that field to tell us what magical type it is.
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
!keys.isEmpty()?
!droplets.isEmpty()?
!regions.isEmpty()?
suggestion assertKeyPair(file, null);
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
Class should extend AbstractPathTestSupport and directory path should only be defined in getPath.
please add setSoftLimitInterval() setter and use it.
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
no need to manually get from db, you can just use getVdsGroup()
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
Simpler: ArrayList<T> result = new ArrayList<>(collection);
Please implement equals() method either. This will remove the potential problem when working with collections.
Objects.hash()
The monitors list was added to the hash code here, but not for BasicTimer. I don't think it will change the result in this case, but any reason it isn't consistent for both?
An create on-demand Direct Debit payment request should always have an agreement ID
this.
This should be an Optional<...> on the member by convention instead of wrapping on access. I realize this is against IDEA advice.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
This shouldn't declare throws Exception.
curly braces
curly braces
if statement unnecessary for now.
We should clear the list too, to not keep references to the threads longer than needed (ideally the thread/parser would remove itself once done too).
there's no need to call super.close here
please remove from this patch
EventLoopWorker can implement Action0 and schedule itself to release.
I don't think RxJava uses the Android code style anywhere. We shouldn't adopt it here.
Collections.singleton(subscriptionOwner) is much cheaper.
This code will repeat itself in every command test... Can we please have a sensible util to do this?
Do we need the duplicate verification?
Can't the cTestEvent be made a spy in the constructor. You already wrote this code twice and will probably need the spy more times.
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
magic number
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
delete
Use [Bundle.putInt(String, int)](<LINK_0>,%20int)) instead, no need to serialize a base type.
can be replaced by List.of
Please use Collections.addAll(Collection<? super T>, T...) instead.
use ImmutableList
s/RemoteTable/RemoteReadableTable
Seems that empty elses are generated now (at least in Java)
nit: Make the exception message also cover temp table.
Again, I'd go with asList and a static import.
default is true
don't return null, return an error page
Why only return count for m_wrapper? Don't you need add the count for all the wrap in m_bundles? This also works for class-based importers, (i.e. socket importer), right?
Should be given/calculated
In this case the order should be configurable for each of the event emitting listerners. This can be done via a Spring Boot property i.e. spring.cloud.task.events.<batch event listener>.order=<order#> . For example: spring.cloud.task.events.job-execution.order=<order#>
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why did you catch any RuntimeException based class here? So far as I can see only ClassCastException is official thrown.
Why negated? couldn't you just flip the branches?
Please use braces here
Threshold of value [value][default_currency] for [category_name] has been exceeded. \n Current ammount spent: [current_ammount_spent] [default_currency]
These line is proof you don't need QuotaConsumptionParametersWrapper
if missing storagePool, the flow has errors. return false?
I'd fold this up to the previous line
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
Could have @VisibleForTesting annotation. Also could public be removed?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Should the name of the thread be maxwell-kafka-producer-worker instead?
suggestion this.dataStoreMap = new IdentityHashMap<>();
Which type would be assigned in this case?
I see this method does something similar to execute minus the optional processing with the rowProcessor
suggestion this.dataStoreMap = new IdentityHashMap<>();
again, you should not do this in ctor. what if the user never calls next()? you are still touching the iterable. it's wrong.
Should we use pushInlineDeployments here ?
why not use @Inject ?
Put the cast on the same line
shouldn't these fields be covered by the autogenerated driver.cleanup() method? (Since they are fields and implement HasCleanup interface)
Same thing here. I don't think mProducerContext != null should be a precondition -- setup() may have thrown an exception and we still want to do our best effort to cleanup by allowing super.cleanup(context) to be called.
same question here: shouldn't labelsWidget.cleanup() be included in the generated driver.cleanup()?
A new ArcGISScene already has a Surface, so you can just add the new elevation source to the existing surface.
can be assigned inline in class member definition
I know it's a legacy, but I'd like to kill that kind of unnecessary methods, like we started to do last year setUpBindings, setUpToolbar, setUpDetails
CoreUtilities.noDebugContext
This method needs the same processing that happens in addJavaOption.
Another space after add
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
toString() formatting.
Minor point, for output that will possibly have multiple entries, probably want to have this all on one line.
Better use getters instead of fields directly
If this method is called in client-side, you have to do result = ~~result between each result attribution due to a GWT limitation.
Dont we need entry for brick details as well in hashCode() and equals() method ?
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
We cannot convert to Double for the same reasons motivated below.
cannot convert to double value, same reason
I would just do e.addInfo("At line: " + lineno) as the exception message is already in the exception itself.
Whats the meaning of catching an exception just to rethrow it under a different class?
I think you can simplify this method via replacing  public WorkspaceEdit organizeImports(String path) { return doGetOne(Commands.ORGANIZE_IMPORTS_COMMAND, prefixURI(path), WorkspaceEdit.class); }
Why not declare GLOBAL_ID as a long?
It should be disabled by default
Remember to create a nativeGetFinalizerMethodPtr method too to free native resources. Check OsMongoCollection for inspiration on how to do it.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
change
I don't think we need this catch - this is handled by the boolean return value.
Why are these not returning mAlignmentStart / mAlignmentEnd ?
suggestion return Category.INFO_GATHER;  Is this really 'Information Gathering' or is it 'Injection'?
zero as an error code? better use -1 to avoid confusing with zero-based indexing.
Maybe check if batch update exception has nested SQLTransientConnectionException?
I am thinking if we can move this to caller method and use separate metrics for AccountService and AccountStatsReport. Thus, we have a clear view that how may QPS from AccountService, how many from Account Stats/ Quota Service.
It might suffice to check if e instanceof SQLTransientConnectionException as above. Are there cases that wouldn't handle?
Minor: Formatting is a bit off.  } catch (...  ..should be lined up with try.
nit: Use Guava's Strings.isNullOrEmpty
Is this method necessary? Looks like the default valueOf() method should suffice.
Should check that the environmentTracker is not null
This method can be private.
Don't use RuntimeException for this. IllegalArgumentException is a far better choice.
I would simplify to "return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)"
Same issue with naming as above, compared to isMaskValid().
return flagdown; ?
revert this unrelated formatting change
enclose if and else within { } even if it's a single line
extract to metod?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
whitespace, but prefer if you don't change existing code style
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Should allowedValues be considered for object equality?
please implement toString using ToStringBuilder which simplifies debug.
Same feedback as other classes. check equals(), equalTo() methods in the changeset
Ya this is some thing we can avoid
Changing the region should also invalidate the client like above.
Nit: For defensive programming, I would prefer String.stripToNull(region); Please update for similar invocations.
_verify
_verify
Can you add an additional assertion about the response message
I'd maybe use Map.putAll instead of call putLabel in the loop?
Do not change the access specifiers of the protected methods in this class as they are used by extensions.
@SubJunk are you sure that this is correct? What about if the audio_bitrate_ac3 will be set Automatic the result will be e.g. -ab Automatick -threads 2
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
No lambda param type needed, we use the simple form result -> ...
Collectors.toList()?
I'm sorry, I don't get it, could you explain why when I call getAnalysisRequirements() twice I get two different ArrayLists()
you can use Collections.EMPTY_LIST
That's good to know.
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Is it really worth checking before setting it?
This line is redundant.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Collections.addAll(whiteListPatterns, patterns) can be used here.
ImmutableList.copyOf() creates an independant copy, whereas Collections.unmodifiableCollection() returns a wrapper on a collection which itself may be modified later.
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
we should validate (and the feature support check) it in the validate() method.
Use formatter
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
<T extends EntityAttributes<? extends BaseEntity>>?
Why are you doing it for a list type?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Please change to externalSearch =
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Why U don't want to consider id in equals and hashCode ?
Please remove the unused method.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
logging here is redundant, since we throw the exception
A suggestion: extend the verification class with the error message. Will help API users
Use HttpServletResponse.SC_METHOD_NOT_ALLOWED instead of hardcoding 405 please.
I think this should check that also the non coded value is not blank, we normally user StringUtils.isNotBlank
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
uncessary call to super. No need to visit further.
I think the test on the parent should be improved. The code example on the [ticket](<LINK_0> itself still exhibits a FP because the parent of the compound assignment is a return statement.
Do we need a LOG.info(..) here?
Do we need the LOG.info(...) here?
I wonder if we shouldn't throw some exception?
static (same for isMap).
Could this be replaced with something like: java final T inType = in().firstElement(); if (inType instanceof IntegerType) { final IntegerType<?> copy = (IntegerType<?>) inType.createVariable(); copy.setInteger(Long.MAX_VALUE); return copy.getIntegerLong() == Long.MAX_VALUE; } return false;  This way we don't need all the instanceofs (still one though ). And it would still work if another large IntegerType was added.
Enum should not be handled here, should be left to SerializationContext.canMarshall() because it needs to check that a custom marshaller was defined for the Enum.
Please use Yoda DateTime.now().getMillis() for a timestamp
use StringBuilder and append please
The formatting is a little weird here.
final missing. Same for the other ones.
what about concurrent closure of statement ?
Can we can have a utility method that unwraps the Exception? And as we might different number of levels of Exception wrapping, can we just look down one level at a time till we hit an instance of SQLException?
I would remove the if an always log the number of entries removed, which can be 0
Why can't we just do return number.get();?
It would be good inline the logic of isConcatCall() here and use it to pull apart n into the bits you'll need and early exit if it turns out n isn't a concat call. Then the utility methods that do the work would take the pieces, which you could check the validity of with not-very-bright checkArgument() calls etc. This reduces redundant logic and improves readability. java Node calleeNode = checkNotNull(n.getFirstChild()); if (!calleeNode.isGetProp()) { return n; // not an array.concat() call } Node callTargetNode = calleeNode.getFirstChild(); String methodName = calleeNode.getLastChild().getString(); if (!"concat".equals(methodName) { return n; // not an array.concat() call } // etc.
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
This should return a builder with the current options set.
This method should be static and need not pass this as an argument to the constructor.
I ask myself if SUBSIZED can be omitted here because there is at most one element in a single-valued type. It cannot be splitted anymore. But wait... Java 9 added Optional.stream(). I will ask jshell: java jshell> Optional.of(1).stream().spliterator().characteristics() & Spliterator.SUBSIZED $3 ==> 16384  Ok, we need SUBSIZED :)
assertion .isTrue() missing
use expectAssertionError and check the correct error is built with verify(failures).failure(info, <error factory>);
super.canDoAction() assuming cluster id already set, when checking for up server, so need to overcome this also, please make sure non of the following commands inheriting from this command base doesn't assume the same, specially in getPermissionCheckSubject that is called before canDoAction (this is why usually we initiate params in the ctor)
Please, always use braces, even for one-liners. Could you please change this across your pull?
getVolumeType().isDispersedType() itself should take care of the distributed disperse types. see the imple of isDispersedType(). public boolean isDispersedType() { return value().contains("DISPERSE"); }
also here. if true.remove(element) returns the same instance, we may test with == instead of size and length
This is more obvious code, thank you
please use brackets  java if (elements.length == 0) { return Iterator.empty(); }
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
Why cast dataSize to int? Not possible to be long?
If you are doing this, check for the two types that we support, using a switch-case. Anything else should be a corruption.
I must admit that false to me carries little information. Maybe a constant with READ_ONLY in the name could increase the readability.
it's not ignored anymore
space after =
braces
We don't need this. There is each method in AbstractMatrix class that has the same logic. And we can't do it better than there.
We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Same here... completeLoadRequest(request) ?
This looks like a leftover and it hasn't any usage. Can we remove it?
Why are we creating a new one here instead of having a private final one in the class?
Could we not leverage method overloading here. Instead of toFalse((AtomicBoolean)object) we use close(object) and then have a close(AtomicBoolean) in the CompletionUtils?
remove this
Avoid logic in this class. This is inconsistent with other collection fields. You can't do an update with this field set to null. Also, why a tree set?
Should this be implemented?
This will now recursively process all subdirectories from services. Is this intended? You may just call internalProcessConfigFile here to restore the original behaviour.
check file is not null. AppExceptionUtil.assertNotNull
You may also want to verify that the dir is writable.
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
We need to check offset + length <= arr.length?
do we care to check for the length to be positive here?
Maybe we want to keep something similar to what id was before
The this. in getters are unnecessary too.
Can this be private (or at least package protected)? It's only used by this class.
you can simplify that as return getInternal(key) != null
Did you still want to put this off?
throws NakadiRuntimeException
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Move both to variables for consistency.
I think this will replace a TERMINATED state with a FAILED state. We don't want to do that.
i am wondering what if we cast directly instead of the check because ( return (String)getProperty(RetentionConstants.INPUT_PROPERTY_KEY))if the type is not a string, i think we can find ourself with a non consistent data and this code will returns null and we have the setInput  which will do the insertion correctly
shouldn't this be the default? null instead of "" - even ifthe parameter isn marked as nullable it still might yield null as Value.getString() does filter null - asString would do this?
Possible to log only one debug line here?
Drop this empty block.
Use parameterized logging instead of string concatenation.
I believe the Auth system should remain on in this method.
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
isUnauthorized 403
yes, this is what I mean. LGTM
the logic of excluding the metadataKey is correct, but it should not be done here on each method call. Instead, it should be done only once in the keys list after all the keys have been loaded.
Minor: you can collapse the if blocks, same in CacheRemoveBackupOperation
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, plainOldUserSchemaResource,PlainOldUser.class); avroItemWriter.setEmbedHeader(false);  Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
Why that new close() can't do this for us, too?
Why not throw a NuxeoException here?
assertNull? And the withTx... though I know you've just moved this code from another test.
else if?
Better to extract local variable for URL to avoid noise from Sonar that we defer NPE calling the method several times.
This makes me very sad since it brings back bad memories of us trying to make super calls happy. How about we move the diff callback creation to the options builder and let devs overwrite it if needed?
Missing the variables for replacement?
Why do we return the parents name instead of the name we store a few lines above?
Is this supposed to be <code>return "Bump"</code>?
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
is there an easy of checking whether or not we retried at least once (or twice depending on how you define retries)
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
Also mention that they will be ignored
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. There are specially written queries in one of the DAOs to get only appropriate announcement activity because it was a pain. Anonymous users should be able to see activity for public announcements and logged-in users should be able to see all announcement activity.
getRouteForUnits does not seem to really belong to GameMap, looks like a feature envy code smell. From what I can see, all that is happening is we're calling RouteFinder and passing it a GameMap reference. Any caller to this code, because it is invoking this method through GameMap, will have that reference. Would it make sense to just put this method in RouteFinder? Seems a bit indirect as-is just to pass a 'this' reference. Example, suggesting callers use an API that would look something like:  new RouteFinder(data.getMap()) .findByCost(start, end, units, player, Matches.territoryIs(end).or(cond));
checkArgument? This doesn't seem like a case for IllegalStateException.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
I think you should be able to pass config in directly
This log message is not correct. The line above dir.mkdirs() actually tries to create the directory. This log message is in the event that you can't create the directory... one such example could be a file permissions issue. please revert this log message as it's incorrect as to what is happening here.
File.separator instead of "/"?
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
"Modifier 'private' is redundant for enum constructors"
This cannot work.
Can you call CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, symbol) instead?
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
@CTI777 we need to change this.. here you are an admin already.. so you can do it even if the task is not assigned to the admin.
IMO, there is no need to catch this exception here to rethrow it with a different message. What do you think?
Adding this to a field is good manner.
Adding this to a field is good manner.
Adding this to a field is good manner.
nit, Collections.EMPTY_MAP?
Is this necessary? There isn't anything being passed into the constructor to change the value?
no need for concurrent
This is easier to read as: return type.getClass().isArray() || isList(type);
probably better in this case to use the negation of the "isPrimitive" method : more efficient and closer to the definition of what we are trying to achieve.
How about "Type is not supported"?
you don't need to do new HashMap<>() here
This method has an external annotation now.
can you make this into a builder so it can return a collection emptyset or a singleton, that way if we don't have the context, we don't have the column?
consider changing "alt text" to "link text" in the markup, since "alt text" could easily be confused with HTML "alt" attribute.
as with bold, better to assert html.contains("<p>normal <i> italic text</i> normal</p>") since it's more obvious what we're looking for and whitespace behaviour is included in assert
should reverse order as follows: assertEquals("",html)
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
The super() returns "" on null. Why should we differ?
OperandTypes.VARIADIC indicates a parameter list with varying length. But it looks like JSON_TYPE is designed for processing a single input value. Is OperandTypes.ANY enough for that?
Could it be better to make the precision bigger? For instance, you can use the VARCHAR_2000: <LINK_0>
Let's simplify to ReturnTypes.cascade(ReturnTypes.INTEGER, SqlTypeTransforms.FORCE_NULLABLE).
Enums must always be compared using ==, not .equals()
We have special constant for Maven PType ID: <LINK_0>
We have special constant for Maven PType ID: <LINK_0>
I this this(url,new HashSet<>()); would better. What do you say?
this.url = checkNotNull(url, "url");
you can either remove else or add pair of curly brackets
Where did 31 come from? Why not use *=?
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
Coud you rather use java.util.Objects.hash(_numeratorUnits, _denominatorUnits)?
I think this should be stripe_account_id ? as per PP-4302
No shallow copy as it was the case before?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
do we need to unvoid..?
replace with ReferenceCountUtil.release(msg)
Do you want to lose the copy-once optimization? filterOutboundMessage is called at enqueue time. Hence a heap buffer will only be copied once (maybe preferable if pooling is enabled?). The copy immediately before socket write option will require multiple copies of bytes that cannot be flushed in the first socket write call (extra bytes will be copied again when channel is OP_WRITE again). When I was envisioning some type of change, I was thinking that it is preferable to copy at enqueue time if pooling is enabled. Otherwise copying immediately before write (potentially extra copies, but much less pooling required).
Same here, I think this should be limited to 1 or 2 arguments
isn't it always 1 or 2 arguments?
This can be removed.
wouldn't you rather having the exception tracktrace be logged only on debug mode ?
urrgh, not so nice. catching exceptions in control flow. especially catching general exceptions
is 404 not valid anymore?
Can the constructor be private?
nit: do you need double checking here? if (INSTANCE == null) { synchronized(this) { if(INSTANCE == null) { ... } } }
sync
Why are we configuring drawer in this activity. This activity shouldn't have it.
I know it's a legacy, but I'd like to kill that kind of unnecessary methods, like we started to do last year setUpBindings, setUpToolbar, setUpDetails
Are both of these lines required? I'd have expected we'd only need the attachBaseContext
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
is something missing here?
Per docs when null is returned, a message should be logged. <LINK_0>
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
this.url = checkNotNull(url, "url");
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
nit: line to long (break each parameter in it's own line)
Did you mean to remove this println?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
please update - should we keep this or format to remove ====
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
new String() is redundant.
Could you perhaps try to use similar approach to [this](<LINK_0> The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.
Any idea what this wait is for?
Let's import StaleElementReferenceException and use it directly without its fully qualified name
You could either use a constant for the id name here or use something like: java @FindBy(id = "export-form") private WebElement exportForm;
ID is a unique element in a page and therefore you don't need a chain.
This can be a class variable instead, using the @FindBy annotation; especially since this same element is used in another method.
It feels like this logic should be refactored into a utility function since we have multiple copies of it. I generally also prefer to wrap compound clauses in parentheses to clarify that the second & third components are paired:  java if(ignoreHiddenFiles && (System.getProperty("os.name").contains("Windows") && Files.readAttributes(dir, DosFileAttributes.class).isHidden())){
private static long Sorry, missed that one.
there is a function in DiskReformatter that you can move here maybe.  /** * Deletes {@code location} * @param location the location to delete * @throws IOException if there are any problems deleting {@code location}. */ private void delete(File location) throws IOException { if (location.exists() && !FileUtils.deleteQuietly(location)) { throw new IOException("Could not delete " + location); } }  Would this implementation do the same thing?
No, no. Remove this logic (that checks whether the provider exists).
Use NewOperatorEntity.class
hmm, do you test the rest service for update? What about if you try to update a given provider (without to change the name)?
I'm guessing merge/rebase error. RequestManager method was the correct source for this. Controllers shouldn't require database knowledge (jdbc/table names)
Sacre bleu, what is thees? How on earth could you mees such a sweet little succulent RequestManager holdover? <LINK_0>
no need to have this getter public
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
Why change the name the property? Accident due to mass refactor/rename with IDE?
You could do a contains here like you do with the ACCEPTED_ENTRY_PIDS.
please use AsyncCountDownLatch here. Both handlers slaveConnectionPool, pubSubConnectionPool invoke countDown method and in latch callback we do rest logic.
s/B/b/
filter(includedHeaders)?
capacityDataMap.size() == 0 I think this might actually be a valid thing for users to do, so we shouldn't throw an exception? Are they not allowed to empty out the default capacity map? They should be allowed to for stricter capacity planning, correct? Or we provide a separate method for reset/removeDefaultCapacityMap?
Please put entry.getKey() in a local variable.
DimensionSelector is closer to be an "object" selector, then numeric. So I think this method should just return false. Indeed, it couldn't return null from getLong/Double/Float, but it *could* return null from it's getObject().
Wouldn't it be better to only show iterations OR epsilon?
channelId => channelName
copy.setFromOriginal(this); -- should use this here ?
Selenium already has a org.openqa.selenium.Cookie. There will be lower friction with other parts of the Selenium APIs if we return extant Selenium types. I think it's fine to extend those types to be more meaningful if necessary.
Make sure to return a read-only version of the List (not set) here. We don't want people to think this is the method to register interceptors.
Add a single quote around the metadataAlias?
We need to synchronize this with #322 @simon04 can you keep track of this change in you PR, depending on what we merge first.
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
Is there a reason why you want to do bitwise OR here instead of || Did you want to explicitly avoid short-circuiting?
yes, I'd log failures, the bundle activator has some methods for logging: Activator.logError()
The config object doesn't need to do this much setup aggressively. Set the properties in this object and do this work when you construct the client. Getting an IllegalArgumentException when setting a boolean is _unexpected_ to say the least.
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
just one thing here - please add try {} catch(Exception), with proper logging, as if you will throw any exception from scheduled code, no more jobs will be ever scheduled. just a precaution. otherwise jobs will stop running and we will never know it occurred
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
To prevent code duplication, would it be possible to change the body of this constructor to the following? this(); this.builder = builder;
please keep the buildVmNumaProperties a void method and access the vdsId fron inside
Do you want to rename the fields, too?
wasn't the purpose of DISCOVER_INIT_TOPOLOGY to call startDiscovery from there? DISCOVER_INIT_TOPOLOGY is not a supported event (processEvent)
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
please add activator ID in error message or a description of the conflict
Why is it a list of lists, not just a list?
I suspect this isn't dealing with the ErrorHandler in the usual way? The org.hibernate.search.exception.ErrorContext is able to highlight a single failure our of a group, where the group usually was meant to be "all operations from the current transaction". It's probably not easy to apply the ErrorHandler in the usual way as it normally would handle a failure as something like "out of operations [A, B, C] we failed on B " somehow suggesting that C wasn't executed. In this case the various operations might have been applied out of order so you should collect all success/fail operations to forge a new kind of error state.
This is a very confusing function name ("if no VM contains a boot disk fail". Huh?!).
Any worry about case sensitivity wrt to scopes?
@artem-smotrakov Could this be replaced with regexp matching?
This function is presuming that the method caller is verifying "messages" is not null prior to being called which is ok for these changes as that is happening but if this private method is used elsewhere in this class in the future that may pose an issue.
why sync?
Note that our code style is to final variables where possible...could you please add those where necessary?
You can safely remove the file.exists()(implicitly done by isFile
Suggest you use .add(BashCommands.sudo("yum install -y riak")). If running as the root user, then on some VMs it causes problems to try to execute sudo. The sudo(...) method gets around that by checking if the user is already root. Same applies for other uses of sudo.
One argument per line java aggregation.getArguments() .stream() .map(OriginalExpressionUtils::castToRowExpression) .forEach(context::add); aggregation.getFilter().map(OriginalExpressionUtils::castToRowExpression).ifPresent(context::add); aggregation.getOrderBy() .map(OrderingScheme::getOrderBy) .orElse(ImmutableList.of()) .stream() .map(Symbol::toSymbolReference) .map(OriginalExpressionUtils::castToRowExpression) .forEach(context::add);
Can we const this magic number somewhere? what does this 300 stand for?
This should incorporate the standard clock skew accommodation: <LINK_0>
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
Also too many dots
Why is this throwing Exception? Should usually not throw anything.
Get the service registration reference and unregister within the deactivate method
Fully-qualified class name not needed.
SA == SERVICE_ACCOUNT? avoid abbreviations
google style is to not use final on local variables unless it's required
OperatingSystem.equals(String)?
use a Constant
input is not @Nullable, remove annotation or add null check.
This method as discussed is used in a synchronous() fashion. Not sure if you intend to do this in a separate thread
I know it is not related to your changes but as an enhancement, distances.get(host) and distances.get(host2) could be extracted into variables to avoid calling get twice. Besides, new Long(0) and new Long(Long.MAX_VALUE); could maybe be cached to avoid creating multiple objects? if I am not wrong getDistance could be expensive since it is part of an algorithm whose time complexity is at least quadratic?
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
i18n too
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Cache the call here and above.
We probably could return a shared instance for this as well?
We canerge these 2 if statements, right?
Might affect the performance if we would do frequent DNS requests here. Not sure how frequent they are in fact.
If we do not write options unconditionally, we will not validate them on the server-side. Consider a user who submits IndexConfig{type=HASH, bitmapOptions=<not null object>}. This is an invalid config, but how do we know what was his real intention - to create a hash index or a bitmap index? I would rather read/write the object as is, and throw an exception on invalid config, rather than ignoring invalid state silently.
Now it's not compatible with the write method. Revert this one too.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
I think we should just use a lint rule for this. I assume we can't do it right away as there are probably some switch statements that don't have all the branches, but we could fix them and enable the lint rule afterwards. Even if this is the approach we decide to take, let's not make it a part of an unrelated PR and instead try to add it for each switch statement as a single PR.
If this should never happen throw an IllegalArgumentException instead.
Should not this be checked in the other way around to avoid NPEs ? We can anyway consider it as a best practice.
Should not this be checked in the other way around to avoid NPEs ?
Typo.
move this new private method to the end of the class
Why do you consider that a reconnect strategy implementation handles "close" and "connectionEstablished" the same way? IMHO the reconnect strategy should be closed and leave it to the implementation if they act same on both methods.
Should use the log, maybe a warning.
simplify this
the null check is redundant here if you refactor this code to something like below  if (SAFARI.equals(wirApplicationName) && SAFARIBUNDLEIDENTIFER.equals(wirApplicationBundleIdentifier)){ return true; }  since we are now comparing a String constant with a variable contents, null check is automatically taken care of because "".equals(null) is always false
I still don't see why this can't be checked during static initialization. Note that once an error is raised in a container, it is better to limit logging. In case this is done during static initialization, I would change log level from debug to info as it is one time logging.
I think we can use a pooled bytebuf
Just use bytebuf.writeZero(size); ?
As written currently it's going to go through each listener and execute on the pool for each listener while holding this lock. I don't think there will be many listeners, but I just was not sure why you would want to hold this lock while you do that? Unless there is a reason to lock it, I say move it out. FWIW, there is another ListenerHelper type which will go through the listener loop on another thread, but it's for specialized cases, and I don't think it would be a good fit here.
please use short names as apRequest
methods
change message and status code
Should return type CorsConfigurer<HttpSecurity>
return Collections.emptyList();
Is this allowed to return Collections.emptySet()?
Are these mock objects used?
This is not used anywhere
There are enough mock objects in here that it's worth using @Mock annotations instead.
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
The params should be valid here? (i.e. should have FEEDBACK_QUESTION_TEMPLATE_NUMBER param?)
this should be a ERROR level message
Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?
Simple for-each?
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
is getServerKey() invoked for every request? Is it possible to pre-compute the value and cache the URI? I think new URI uses toString and string parsing underneath which is CPU intensive.
is this better at debug level than info level?
Why do you omit SecurityException e in the caused by chain?
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
Can we use url building here, to avoid problems with / at the end of the server.
I see that address.getHostString() can return null, at least in theory (although it seems to be a pathological case). Do we want to defensively prevent against NPEs here?
same as above... why not use simple if/else here?
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
should also be cleared in a tear down @After (possibly static) - incase the last test to run sets it to true and we reuse surefire for other tests (which is the default and I did not see changed anywhere in the pom - but also when running multiple tests from the IDE). suggestion System.clearProperty("jenkins.model.Jenkins.SHOW_STACK_TRACE");
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
"Account" instead of "Accoun"
Again, not your mistake, but fix this description if possible. There is much better descrption on devel/gui in attributes. Then you can delete '//FIXME'. Thank you.
Please add note to description how correct value look like (syntax).
Can't this be done with a stream call?
the part between lines 1722-1727 should be inside the if clause in line 1729 as well, as otherwise it's not used.
please surround the block with {}
This method is only used in test code?
Use a stream.
Why is there a fromByteArray method? Why not call the constructor directly?
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
you should yield here (return). Operator shouldn't do a ton of work within single call, otherwise a query might be "unkillable"
why public?
This try-catch can be moved to the @Test annotation as well.
I recommend using @Test(expected = EvaluationException.class) for these tests.
Yes, I think it's safe to remove. We're dealing with AppleScript through the interface provided by ScriptEngine, and we're already handling ScriptException. Other errors coming up through that code path will likely be our own (or a JDK bug).
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
Do we really need this? It's implicit
not needed, empty c'tor is just for satisfying gwt. its modifier can be reduced.
In all the other nodes, all the constructors call the most specific constructor to avoid constructor spaghetti. That would mean the this-call gets "null" at the end for example.
I think the indentation is wrong here. Seems like you're using 2 spaces.
What do you think of adding some errorMsg in the page if a user without ADMIN permission tries to access this page?
HTTP_HEADER_CSP
This could be moved to after shouldRaiseAlertGivenJsoMagicBytesAreDetectedInCookieOfRequest to keep related tests closer.
These two checks seem unrelated to the actual check you want to perform.
this query is not necessary as there are SELECT * FROM lineitem_ex queries in other tests
This query returns no data. Is this intentional? If so, perhaps, use assertQueryReturnsEmptyResult.
I expect this query to fail because ship_day_month_nulls column doesn't exist
ins't KEY2STRING_MAPPER missing?
isn't it missing KEY2STRING_MAPPER attribute?
the connection configuration is never serialized.
Remove the redundant null checks.
use same type for instanceof and force casting
For lists not marked @Nullable we should return an empty list instead of null (or mark them @Nullable if appropriate).
<LINK_0> Let me know if you have any issues managing or adding items to the project
this.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
You forgot this!
studentsWhoRespond -> studentsWhoResponded
why not null as value?
You could remove the braces around the first check.
We have a numeric pattern in PatternUtils, would be best to use that here to avoid formatting issues.
Should log that it was interrupted (probably as error) and return false.
use Utils.validateArg?
You can also do  try (FSDataOutputStream stream = fs.create(new Path("s3n://test-bucket/test"))) { assertEquals(CannedAccessControlList.Private, s3.getAcl()); }
Try to register an @ExceptionHandler in this controller to avoid catching exceptions here. The exception handler declared outside the body of this method will handle more situtations.
Please move such code to UI abstraction.
This seems like way too generic of a place to put this validation. What use case are you trying to catch with this.
calling super not needed
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
Why so complicated? Why not LOGGER.debug("Could not process citation", e");?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Can this be private, or is there another use case for default attribute outside the builder's call?
add this selector to UI mapping at the beginning
Run formatter
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
How about using an object array so that we don't accidentally use the LOS for these (though the size is less than the current LOS threshold)?
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
I think this method could be private: suggestion private void init() {
This is a weird place to add a listener.
Sure, you can do something like: throw new ApiException(new JSONException("FIXME: server returned 0 sections with no error."));
unused variable
default ?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Why we want to fall through into the loading dialog in case of error?
LOG.info -> LOG.error
nit: extract simpleGets.get(m.getName()).length == m.getParameterCount() to hasEqualParameterCount.
I believe applyMetaQueryParameters already handles this. Or is this because of something else?
You can also use IO.close(bb) as IO.close will not throw any exception.
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
What do you think about changing the return type here to the enum ArrivalFilter? Seems like a conversion always needs to be done anyway, so we might as well do it here.
nit, Collections.EMPTY_MAP?
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
null? why not just a () -> {} ?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Saving preferences inside a setter is not appropriate. Please follow the pattern used for other preferences.
Probably makes sense to move this up too.
Let's avoid null and rework to empty string
If this is ever true a NullPointerException has already been thrown
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
Do you want to check the compile options before asserting this?
These four lines are roughly the same as the first four lines of the next block, perhaps refactor as a function that takes the restart/restartSimple action as an argument? (I'm currently running through IntelliJ's tooling, and it complains about common code -- also some reviewers ding me for things like this....)
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
isn't it better to use the matrix in VdcActionUtils so the operation will be blocked in the UI as well? then we can validate the status like we do in RunVmValidator#validateVmStatusUsingMatrix
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
Should this be compared with || instead of &&?
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
We could stochastically test it.
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
NAK. I think you should be getting a RefControl for refName and asking refControl.canPerform(PUSH_HEAD, PUSH_HEAD_REPLACE).
While we're at it... Maybe use a negative value in there, too?
Same as for doubles, maybe make one of these negative?
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
who releases the request if an IOException is thrown?
Seems that empty elses are generated now (at least in Java)
Request.State.OPEN
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
warning: The static field AbstractProcessor.logger should be accessed in a static way.
warning: The static field AbstractProcessor.logger should be accessed in a static way.
Recursion should be avoided as much as we can because of obvious reasons. I believe this can easily be converted to a while loop.
We should probably init the cause here too.
Please take into account that t could be null.
For loop?
final
For each?
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
I'm missing the new field in the toString method.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
shouldn't the log message be updated?
Are you missing duplicated bytes here by not instrumenting this method (for deltas) too?
Revert this change please - it was part of our experiment to get the RpcScheduler set on the client-side.
This is not needed, since the constructor already checks it
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
Not good to use Optional for collections, just return empty collection
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
Better assume immutable parameters. Don't modify references to an input variable.
'.'
Same here, you need to check that retireable fields are not null and null after
You need to check that other retireable related fields at are not null and that they were null before i.e dateRetired, retiredBy, retireReason
Minor point, but shouldn't we really be testing here that the accession number is not "12345"?
Is there a subclass? I'd like to see these protected methods be private if possible.
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Why do we return the parents name instead of the name we store a few lines above?
The this. in getters are unnecessary too.
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
nope, return true
also static
LOG.error("Failed to getattr {}: ", path, e)
LOG.error("Failed to unlink {}: ", path, e)
LOG.error("Failed to read {}, size {}, offset {}: ", path, size, offset, e)
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
It looks like we need to modify ContainerAttributesResource to simply take a Map in its constructor. That way it's not only simpler, but it would also mean that all attribute values (including user-provided ones beyond those available OOTB) would be represented by the resource representation.
This logic is different. observers contains entities other than players. The new code doesn't account for that.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
The ID is used to restore old files (from an older release) so this must not be changed!
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if ...)
This is obviously only relevant to Images. So why are we even getting here if we're hadnling a LUN disk?
Again what reason for that line. Lets think: line before we update entry at DB, why I need to update an object which is not updated at DB any more. Why? These is example of dead code. Dead code should not be written
You can use checkArgument here, same as <LINK_0>
Here you could use Guava's [checkArgument](<LINK_0>,%20java.lang.Object%29)
recordCount++; doesn't work?
This code should be:  this.channel.close();
Use SerializerUtils.writeInt()
Would it be an overhead to calculate sizeInBytes() for every call?
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
Let's do return fDetailedLoad; even if it is always null for now
What is two arrays are empty. I think you need to handle this properly.
Neater: String.valueOf(value);
Integer.toString?
![Oh Hell No!](<LINK_0>
"isSearching" should be a class level string
Would you mind making the "tabList" string a constant symbol since it's referenced in multiple places.
generally we like to keep the super as the first call on methods unless there's a need to switch
In the old chaining way with only one input, we have source -> op1 -> op2 in the log and web UI. If I get this formatting correctly, we would have op1 [source1, source2] -> op2 now. I'd naively assume that it's easier for users to read [source1, source2] -> op1 -> op2. WDYT? Ofc, it kinda assumes that chaining is printed with " -> " in JobGraphGenerator, which might be less ideal. Also, how does it look for no source? Would it print op []? I guess we should have a special treatment for non-chained inputs.
Wouldn't it be better to use the transitionMap to group by from state?
I would pass the cut length as param instead of always taking DATE_FORMAT.length
Again, the default value is misused, perhaps do:  if deviceMap.contains(deviceId) { deviceMap.get(deviceId).put(folderId, completionInfo) } else { Map<String, Completion> deviceCompletion = new HashMap<String, Completion>() deviceCompletion.put(folder, completion) deviceMap.put(device, deviceCompeltion) }
This should be a WARN instead of an ERROR.
Instead of calling add and what not, you could do getOrDefault and just potentoally return zeroes early.
desc.orElse / orElseGet would be more idiomatic
Braces required by coding convention.
I think that this logic should not be in htsjdk. getDescription() should return null or blank if there's no decription. the user can choose what to do with that information.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's a formatting issue.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
This & the other switch removals should be reverted, performance tests show that this isn't any more efficient. The change also increases memory usage, making this a net negative change.
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
Formatting
The state should be deep copied if we want to store the state at this time.
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
why not put this all in one if condition? if (input instanceof EditPart && ((EditPart) input).getModel() instanceof ConfigurableObject)
Thoughts on changing this from using withContext and a String constant in Storage Common to making this a helper method in Storage Common?
Name for TextAnalyticsResultCollection is being discussed in the API view tool.
I think this was already released
suggestion edge.getTargetVertexId() + " hence failed to write to byte array");
Consider wrapping this into the constructor, and getting rid off the setter? StreamEdge(isIntermediate)
unnecessary **;**
I think when setting them to deleted individually you were also updating the last modified user. Is that necessary here as well?
Remove statement.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
Listener which does nothing, looks weird for me. Is it okay?
**WebDriverException** is too general here. So, it would be useful to have exact error in logs:  fail("Known permanent failure <LINK_0>", ex);
This should be an Optional<...> on the member by convention instead of wrapping on access. I realize this is against IDEA advice.
this.
An create on-demand Direct Debit payment request should always have an agreement ID
Why is it a list of lists, not just a list?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
This means clockHand will be hot at initialization time. Intended?
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Check first that target is not null.
there is no change, why have you pushed?
Why not just catch "Exception"?
I'm missing the new field in the toString method.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
scheduleTimes --> scheduleTime
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Check if buffer us null.
Check buffer null.
BufferUtils.byteToInt?
I don't think it should be renamed
If opening is true, doesn't it mean it's still opening but not done opening yet?
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
I guess this could blow up...
this seems wrong. now you keep track of the last one and not the first one.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Unsigned types are not used in the current implementation. So, you can omit them.
ChannelClosed needs to be added to (though not strictly necessary)
maybe just replace all these error codes by default block since we are doing nothing for any other error code
Should we put the resource.getInputStream() inside of a try-with-resources block so we don't have to manually close it after copying?
again: removing the explicit initialization: worse, not better
You might want to move this into a shared helper method for other tests which need a temp file with random data.
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
Better to throw NullPointerException?
IllegalArgumentException is an [unchecked exception](<LINK_0> therefore you don't have to declare it in the method signature
A for each loop on the listeners can be used here instead.
I would suggest checking == 0, like for (int i = 0; i < s; i ++) { exitTasks.get(i).run(); // in case previous task cleared the list if (exitTasks.size() == 0) { break; } } Another qq, no tasks would be added when this function is called? I think onExit() might be safe but executeTasksOnWakeup() is a concern.
should this count be parameterized?
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
super(SC_FORBIDDEN) and similarly for other constructors
200 >= instead of <=
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
Proper equals implementation so that it does not leave itself open to class cast exceptions
whitespace/style
supernit: HashMap is [dead](<LINK_0> to me, and it should be dead to you too. LinkedHashMap is the only way to live.
I think this message is a bit much. Can we make them match? > "Expected 1, got 0" > "Expected 0, got 1"
Missing fail()
Has the code formatted properly? As it looks like the indentation is not even.
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
I think we can remove this line.
I would ignore empty notifications and would log warning.
IIRC, I use rawQuery with the same result like yours. Please check rawQuery API to simplify this function call...
This is a test for the userRepository in my opinion and should not be here.
no need for type cast
Per our discussion, we need to delete any removed custom data properties before saving the account and its custom data changes.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
The last element in the data array is never subjected to runEquivalenceChecks.
Should be final.
To avoid old items from killing new ones, lets verify its the same reference coming back in the cache first: ObjectId key = ((LoaderRef) ref).key; if (classLoaderCache.get(key) == ref) { classLoaderCache.remove(key); }
use stripWildcard(refName)
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
It seems to me like the removal of the slash has no effect because its dealt with here no?
Include the file:// as constant.
There's a way to avoid that n+1: doing a query searching for all questions in (:ids) and, after that, using session.load to get the questions in the specified order as you're doing (the hibernate would get the questions from the first level cache once you already selected them before). (yeah, its not pretty, but works)
Why is it a list of lists, not just a list?
Use guava to filter null entries (once again to protect against client code called via extensions)
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
I would add a check here for empty string & also check if the namespace ends with a "." to avoid exception if someone changes the namespace.
studentsWhoRespond -> studentsWhoResponded
Would be nice to check different lengths and empty.
we need more here, at least fd. It would be impossible to match timings to a query without these that. Perhaps logging sql text again will help too
if you don't need the event, the best is to override the function :  java public void f();  you gain a line of code :)
Objects.requireNonNull(buf)
These are more readable if they are inline'd into the assignment. I'm not sure if this worked for Guava Preconditions, but the Java requireNonNull returns the reference, so it does work for that. Example: java this.buffer = Objects.requireNonNull(buf, "buf argument was null");  But, we should stick with whatever minimal change merges to master easiest.
shouldn't you do a defensive copy?
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
A create card payment request should always have a return URL, so I don't think this should return an optional
this.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
This test is yielding false positives. The test pases because the number of invokations you want is correct, but you're not seeing that the instance that is actually modifying this is not the one you wanted. Change this by a Map<Source, Integer> and also assert which instances had how many invokations
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
Same thing than for the agent: no default value.
scheduleTimes --> scheduleTime
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
put lock() before try
Why do we need this change?
Typo: double i
let's apply the format template to the new code
throw exception
remove extra empty line.
style nit: no braces for single line block
Use a LinkedHashSet to get predictable order (useful when the result of this is shown to the user).
rename to pack
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:  return highest.isPresent() ? highest.get() + 1 : 0;  also we might have a test for this method to be sure we don't break it in the future
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
Can this be private, or is there another use case for default attribute outside the builder's call?
This method is used only in one place, so it could be removed, and the logic centralized here.
Again: this else branch doesn't do anything except logging; is this really necessary?
This else branch does not have any code in it. could it be that you just used it for debugging purposes? If you are not doing anything except for logging the fact that the deviceController was null you might as well remove the else completely (not that you get me wrong: this doesn't mean you should remove the null check - unless you have a look into it to find out if you really need it. )
If I understand this right, the state machine cleans itself up after it disconnects?
== should be replaced by .equals(...) Same thing a few lines below.
In case of binary expression we should just check that either lhs or rhs is java.lang.Boolean and boolean respectively, no need to check for null checks.
There is no need to check receiver. It is either left operand or right operand and used at the code generation phase.
return result != null && result.getCoverage(CoverageMetric.LINE) != null;
this is not correct... I would have hoped we have unit tests for this :). This method should return the cause() and not throw it.
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
progress.split(1) ? Interestingly, the counts seem to off quite frequently. Here only 2 of 3 ticks are consumed. I wonder if that was intentional?
Not needed, delete.
May be you do not need another submonitor conversion here?
Should this also handle the suffix 'es'?
I think that the underlying XMLStream reader has a 'getAttributeValue' method. It receives the namespace and the name of the attribute. If you pass 'null' and the name of the attribute it will return the value of the attribute, which is what we need: <LINK_0>
There should be a white space before else Also you could use word.charAt(i) in both the if and else statements (e.g. word.charAt(i) == 'y') instead of using substring, that might make it a bit more obvious what you're doing
No, this. when you call methods.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
@xpdavid is this the right thing to do?
Does this need to be public?
requireNonNull
return this.parent == null ? this : this.parent;
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
This method should get the expected size of each lun, since vdsm reported it in getDeviceList (path capacity). So this should call each host, and report the hosts that do not see the expected size. We don't nee to create map of sizes, but create map of luns to failed hosts.
I don's see a reason for this method, please move it's content into findProxyHost_ChooseByDCWhenNoClusterMatch()
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Boolean expressions are a bit complicated.
Shouldn't this be a switch?
Be careful, this method is probably used by core plugins
We should not return an Optional, as it's not possible to have no default QG
We should add blank behavior here directly. A blank value should be identical to an absent one.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Can this be private, or is there another use case for default attribute outside the builder's call?
@xpdavid is this the right thing to do?
still relevant?
please declare it in #163
Please changed type to PersistentSetupNetworks
I think the return type should be IborFutureTemplate as AbsoluteIborFutureTemplate is package-private.
in this case we can and schould work with the constants!
maybe, if @ Before doesn't work, create a method setUp for this? since the same code lines are in the beginning of each test of this class
What is the nullness contract here? Also missing docs.
this. for all of these
Please call isEmpty() instead and check null for cursor
How expensive do we expect calls to the ExternalResourceDrivers to be? I'm just wondering because here we retrieve the ExternalResourceInfos for every task, independent of whether they need it or not. I think I would prefer that this feature would not add additional costs for tasks which don't want to use it.
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
Please review - are you still using these: statsUpdateFrequencyMs and maxStatsAgeMs as you have code in GlobalCache that deals with this as well.
Should we use one of the core executors here?
I believe the original issue was that in threadName we get the cache configuration, which also requires a security action.
I'm surprised the server doesn't already do this.
This method should be static and need not pass this as an argument to the constructor.
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
please remove empty lines before } lines in this class
Why have you added this line here? This will automatically choose first local address and then switch to remote address if the ping to local address fails. Adding this dissolves the purpose of having Local and Remote mode explicitly.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
add this selector to UI mapping at the beginning
It should be final
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
Same for the above 3 text strings.
Use CommonImages.getImage to prevent memory leak.
Make static
Use CommonImages.getImage instead of createImage so that we don't have a memory leak.
Wow. This method is much more elegant that it was before :tada:
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
Perhaps you don't want to add the listener in the supplier since you will get an additional listener every time reset is called and the new memoized is initialized. Then each listener will further call reset... I think you just need to add the listener in the constructor.
This can be static.
application.size() -> application.isEmpty()
Why is it a list of lists, not just a list?
null can't be returned here
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
Why change the name the property? Accident due to mass refactor/rename with IDE?
Tokens are somewhat sensitive. Don't think we want to print them.
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
nit: I think parenthesis are a little more conventional.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
return !requestType.equals(RequestTypeUpLog);
Really? Don't we need something concrete here?
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.
Sometimes I also try to protect internal collections, but normally it only complicates things later. Can we return it as-is?
If the list of users stays the same, make it unmodifiable in the class constructor.
Can this return a List<JsonPatchOperation> instead?
I would check getQosOverridden().getIsChangeable() instead of (!getIsToSync().getIsChangable() || getIsToSync().getEntity()) but as you wish...
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
When the view is closed you need to stop the build thread
Can you please add the name of the VM to the message, so that message will be more informative...
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging.
vm name is more readable than vm id (see line #552 as an example), but other than that it looks ok to me.
I as well would say it's necessary. If the text has \n\r and the method replaces only the \n, the String could become weird somehow.
Consider performing the hive version check once and keeping reference to a Function instance which does this work for you. The Function impl is chosen based on result of version check.
Peter B. said in different commit <LINK_0> that this exception is not thrown for jdbc.query and you said he is right. So there is probably the same problem in every method with jdbc.query.
can we validate that we actually have UQ tags?
This method sends the JS for any URL under /plugins/{name}/static/. If the plugin requests /static/logo.gif it gets back its JS rather than 404. That is... confusing for the JS developer. I think we should only return the JS for one name under /static/ and 404 for any other.
Can be simplified to BufferedWriter writer = Files.newWriter(srcFile, Charsets.UTF_8);
For DTLSConnector this is configurable. I do not know whether you have given configuration of the TLS connector much thought yet ...
where are the corresponding cleaners for these direct byte buffer allocations?
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
Is this method really needed? It's similar to make init public
this should go to super.reset(), shouldn't it?
Long.MIN_VALUE and Long.MAX_VALUE may work better for these two, since people may use the min/max values reported by metadata for pruning segment lists.
40?
Please add ? and % as well
unnecessary array new: {{true}, {false}} should work here
Why initialize this to a new OkHttpClient instance that is not being used?
Personally I prefer to set all fields using this. in constructors, but you call the shots.
Can you please tell me where this variable is used?
This should have stayed camel case
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
filters.addFirst(filter) ? <LINK_0>
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Could you use one check of CoreUtil.isNullOrEmpty() here?
Please move this check into the null check bellow, since we are already checking if this.key == null.
Not sure why you need this. If you're getting a leak here lets try to work out what's causing and see if there is a better way to solve it!
Should close kill the memspace? What if someone want to reopen the key?
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
Suggestion: Keep it long instead of wrapper counterpart
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
Is this one of those @VisibleForTesting things? Seems unnecessary
Why not declare GLOBAL_ID as a long?
Again, this is where you should clear out your stale events.
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
Why using empty string as first argument?
Is there any specific reason of choosing NoSuchElementException over NPE?
something is wong with the indentation, please fix.
Could you java import static SalesforceLogger.Level.*;  So you could just write java logger.log(ERROR, TAG, ...)  Or should we introduce warn / info / error / debug methods on logger?
This is a reason why I got 2 receivers.. The variant information is added to PushMessageInformation in the MetricCollector#updateExistingMetric: <LINK_0> Since it is already added in the NotificationDispatcher, it re-adds "existing" variant metric. By removing this line it starts to work correctly
GATK standard practice is to always have braces even for simple ifs. I actually prefer one-liners, but we must conform.
Can the processor name be null?
true?
a workspaceitem should be returned
I think this should be pushed higher in patch chain.
I think that empty string is different from null and is a valid value.
This could also use the addAll (same for above cases), as done in getParams().
You can safely remove the file.exists()(implicitly done by isFile
why is this public?
I think you're missing getDefaultConfigurationFile() here.
@fanifieiev the same above.
@fanifieiev the same above.
@fanifieiev the same above.
Use fs for initialization and extract GoogleHadoopFS to local variable here, and below.
isNull()
isNull()?
does this url have to be hardcoded? can't we use the link rendering code we use elsewhere for field links?
Why do we need String.valueOf?
I think we will have to discuss whether or not to include the fromKafka functions in this class.
Shouldn't throw a RuntimeException, but return null instead. The superclass should be handling the case when the returned object is null and handle it accordingly.
We have a utility for it in Pipe  UrlUtils.appendToBaseURL(serverUrl, pipePath);
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Could you mark the constructors @Deprecated instead of deleting them / reducing visibility? It makes it easier to transition between versions if we deprecate first, then delete later.
I think it would be easier to use this instead:  .defaultHeaders(h -> h.setBasicAuth(clientId, clientSecret))  You could then remove basicHeaderValue
combine this with next line
Should be pulled up to AbstractItem.doCheckNewName-it is not specific to Job.
should a "" password be allowed? (I have no idea if that is valid)
Is this really correct? ASCII characters would include all 128 defined ASCII characters, but the actual limits are smaller: <LINK_0> Perhaps this message should just spell out the requirements exactly: A letter or number, followed by letters, numbers, dashes, dots and underscores (underscores are not listed in the whitelist, but anything else is replaced by an underscore, making the underscore implicitly allowed). Maximum length is 63 characters.
You can just call optimize
We shouldn't do an advance() call here. The sequence of operations for a user to get the first record will be start(), advance(), getCurrent(). If we do an advance() call in the start() method users will miss the first record.
code duplication
Put these two assignments in order so it's clearer
use of raw class, should be new ConcurrentHashMap<Long, Boolean>()
Two suggestions here: 1. You lost a linebreak I think. 2. use getOrDefault instead of the ternary.
This is called in the constructor, so consider using a StringBuilder here.
Do we need some escaping mechanism to guard against the possibility that 'table', 'column' names might contain special characters (like "(", ")", "'", etc.)?
This should not be protected but package.
Check error code/description
Why do you use sleep ? It is highly discouraged, wait for an element instead
wait for the elements before interaction
Check first that target is not null.
Cache the call here and above.
This should also have a check for max of 25 like the constructor above, i.e. Math.min(...).
Should the first parameter not be getTaskServerLogsByTag?
Now that you're encoding the ID are you missing decoding it somewhere? I don't see it anywhere
[minor] This public can be removed.
when you implement my suggestions with the DeribitException then it will get thrown here instead methods in *ServiceRaw classes should throw out DeribitException they should be caught and adapted in *Service methods
unsafeSubscribe shouldn't call the ERROR_HANDLER.
Use already existing helper method
log a serious error that shutdown wasn't called, so as not to (inconsistently) cover for mistakes. ...nvm you did this... but why put the log over there...?
Scm api has rules on the placement of annotations for methods
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
Does the output stream need to be closed?
nit: you can merge both lines above as checkNotNull will return the given argument
Too many dots, there should only be 3!
Isn't it enough to declare Exception here? An exception will fail the test, regardless of the specific type.
We normally reserve checkNotNull for argument checking, and use checkState for state-like checks.
Equality/hashCode need to also take into account the attributeName field defined in superclass AbstractPredicate. Since there are quite a few subclasses of the AbstractPredicate superclass, maybe it's a good idea to override equals on the superclass to check attributeName equality in the abstract superclass.
I think this works the way we would like to see the equals work, but take a look if you'd prefer the shorter: return Objects.equals(this.deviceIdentification, device.deviceIdentification); over all the null checking to see if the result is false, followed by returning true.
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
I think the unmodifiableMap should stay in getRoutes().
constant?
Lazy load this instead of injecting in all constructors.
this.id -> id
If you have a translation use that if possible.
This doesn't need to be prefixed.
input is not @Nullable, remove annotation or add null check.
Actually this _isn't_ @Nullable so should either remove the annotation or add a guard that returns false.
I'd have said Objects.equal(contender.getParent(), ancestor) here, to make it a proper descendant check.
To always be safe please use context.getApplicationContext()
You could just leave this part off. suggestion
Why do we need this change?
Sync clients cannot use withContext. You need to explicitly add a Context to the API args. Note that Context is supported only for APIs that return Response<T>.
>byte[] [](start = 11, length = 6) DecryptResult
@greenaddress  and this?
Exposing PojoProperties (an internal class) to API
This is likely unnecessary. The set of qualifiers is expected to contain all elements. See also org.jboss.weld.bootstrap.WeldStartup.createContexts(ServiceRegistry) and other places where this constructor is used.
Should we use the previous path variable instead of a hardcoded one?? If not we can delete line 28
java LOGGER.info("Groovy console stopping...");
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
needs filling in :)
This is getting long, wrap wrap the arguments
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
can it be package private?
else throw an exception with a descriptive message about whats wrong.
System.err -> LOG.trace?
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
null check is not needed, instanceof will return false if the left operand is null.
You have changed the return type to Double but below you act like you are still returning double. For example, when the value is Double, you are getting its doubleValue() instead of just returning the object cast to Double.
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
Mappers can be stored in static final variables instead of rebuilding these each time.
I am not following here - why do we want this in sync block?
please remove empty lines before } lines in this class
Minor: move init to the beginning after the constructor
Get the size directly don't use getAllEvents()
Replace contains + get with get and check if the return value is null
redundant else
this feels like it violates the fluent workflow, is there a way to make this work inline with the fluent query runner?
"Subscribe sample context" seems like a weird hardcoded value.
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
looks like a hack. We overwrite the subscribe over and over again
this.
You can use CollectionUtils.toImmutableList
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
We could the variable declaration and just use return decoratorClass.getConstructor().newInstance();
Add the original exception as cause.
Add the original ClassNotFoundException as cause.
this should be catch (Throwable t)
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
throw exception
Don't need this keyword here - the rest of this code only uses this when necessary.
public
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Use readAsString(...) instead
Use readAsString(...) instead
Use readAsString(...) instead
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
studentsWhoRespond -> studentsWhoResponded
Based on how it's used, it's more like a listener not callback.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Why not IllegalArgumentException?
Just noticed, you should have an @Overrides annotation here.
Doesn't seem as something which should be public, I would say, it should be rather private. If it is required by cancelAndDismissReloadRequiredWindow, it should be most likely improved in order for this method not being required public
Again since the validation is done in the UI, I think you can go directly to writing the GB response
what's the intent of this change?
Do we need this else?
Is payeeIdL a typo or intentional?
minor: don't need this. qualifiers
Patametrrized logging please
check directly on viewOperations map.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
you can make the same optimizations here as you did with the other ones: Meter meter = (Meter) checkCache(classSimpleName, fullMetricName).orElse(_metricRegistry.meter(fullMetricName)); and then remove the "if (meter == null)" check
Could the attribute be null here?
Could throw IllegalArgumentException instead.
Shouldn't this be transactional?
Please also nullify the time stamp on {{BuddyAnonymized}}. With that, we prevent identity matching (the purpose of this ticket) and we can see how far we are with the migration.
Replace these 4 lines with assert ~originalUserEntity.isCreatedOnBuddyRequest().
need to calculate logprob directly.
No need for super()
are these setters used anywhere?
You don't need to start the execution plan for parameter validation scenarios
No need to start and stop in parameter validation testcases. Please remove all instances.
Please keep the line length under 120 chars (in other files too)
I don't think that is necessary.
This is already implemented by AbstractDebugTargetView
if super() is already storing the viewer, do you need to store your own copy?
Why don't you store the pattern in a final static (instead of only the String and compiling each time)?
Implementation of this and other similar methods is highly inefficient. Better to use Character.isJavaIdentifierStart.
fileExtension doesn't actually seem to be used?
mark this method private as this is only used in this class.
nit: please remove the redundant else
extract to metod?
Returning the first chunk of the stream before "\A" [implementation] and returning the entire stream contents [interface] don't seem to be in sync.
use try-with-resource instead: try (Scanner scanner = new Scanner() { }
May want to add a failure message to this assertion that includes the expected value. Otherwise the failure message will just say that it was false when it was expected to be true and we'll have no idea which value it failed at.
What's the purpose of this line? I don't see any difference if the url is correct or incorrect. It just clicks on the Verify button and then continues with clicking on OK. It would be nice to preserve the verification result. For example you can return it as String result.
add wait condition for shell
I think the annotations should be on separate lines
null? why not just a () -> {} ?
Add this qualifier: this.logicalNodes
Style issue: @Override shuld be on line above the method declaration
Change string to "EmailAddress{" + value + "}"?
Simplify toString
Neater: String.valueOf(value);
Concern: These changes to the filters-related methods are definitely breaking changes, and seem like they're actually pretty likely to break existing code. (Unless I'm missing something, which is very possible.)
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
no need to have this getter public
I think you should also have if (c == null || c.length < 7) return; or else we'll hav an NPE
What's "c"? Can we unabbreviate it?
unnecessary array new: {{true}, {false}} should work here
Please keep the getter and setter closer.
is this class going to be created by the user?
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
Please, use the logger format of: [CLASS_NAME]\t[Additional Note if applicable]\t<"Message"> In other words add: [PLAYER]\t to the front of the String. <naming,organisation
I prefer ", not "+(l == null ? null : l.getClass()));
do we want to assertFieldCountEquals here?
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
I think that the lock should be acquired for each image disk, vdsm call might take few minutes so we will provide better user experience.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
Highly suggest isEmpty
final List<T> sorted = ...
remove
No, RunVmCommand is executed before the VM is running, The VM's status should be down
Please refactor to different methods
I don't see any change that is related to elapsed-time, why is this change needed?
fixen (in branch gammodes is the starting position een decorator)
Why you don't use wrappedHandler?
Why is this not singleton?
Should this return the AzureTable?
is there a reason why this method isn't implemented?
throws TaskException is part of the interface, did you mean to remove it?
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
one param per line; leave the first line empty
Can you throw ElasticProfileNotFoundException() if existing profile is null? the remove function below can be successfully run when null is passed to it, but the user won't know that nothing has changed.
get the preprocessedEnvironmentConfig and pass that along instead of finding it in all three functions.
plugin configuration should not be allowed to change. We do not allow that from the UI
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
You should statically define those colors, instead of a new Color each time
What's the point of the 6 trailing zeros ?
It might improve readability a little bit if the expected score was a variable instead
Missing codes.
This method could be protected.
Better be cooperative-sticky? cooperative is too general I think.
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
Suggest you use .add(BashCommands.sudo("yum install -y riak")). If running as the root user, then on some VMs it causes problems to try to execute sudo. The sudo(...) method gets around that by checking if the user is already root. Same applies for other uses of sudo.
It would be better if this class would have an internal reference for the registry instead of referring directly to the central repository inside the refresh method, as that would loosen the coupling between the query group and the registry itself (even if for now only the single central registry instance is stored there).
Integer amount = 1 + amountOfCardsDrawnThisTurn.getOrDefault(playerId, 0); amountOfCardsDrawnThisTurn.put(playerId, amount); if (amount == 1) { // do stuff }
Use fire(event); for all EventHandler based events
We're checking event.error != null twice here - but we can actually drop this entire line, since event.isError() above is actually a event.error != null check.
Create new lists rather than assigning them.
assert.NotNull ?
Can we use a immutable Vavr map instead?
When the result of Math.pow is 15.9999999999999999, numberBuckets will become 15.
The sublist could use a vraible for readability and line length
warning: The static field AbstractProcessor.logger should be accessed in a static way.
Log the exception to error.
NAK. I think you should be getting a RefControl for refName and asking refControl.canPerform(PUSH_HEAD, PUSH_HEAD_REPLACE).
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
suggestion renderStatRow(3, resourceLevel, new StringTextComponent("" + (int)(Math.ceil((float)(data.getResourceEfficiencyLevel() + 1) / (HunterMinionEntity.HunterMinionData.MAX_LEVEL_RESOURCES + 1) * 100)) + "%")), data.getResourceEfficiencyLevel() + 1, HunterMinionEntity.HunterMinionData.MAX_LEVEL_RESOURCES + 1);
true?
Test should verify the DDB query. Also, we should probably return something "real" from the DDB query and pass it into the batchLoad() to verify that the data flow is working correctly.
Is it worth creating a test with multiple studies (and multiple links per study) to make sure this correctly accumulates links across multiple studies? (For both this and the Apple version.)
the steps 35, 36 and 38 are not neccesary
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Don't you need a super.setUp() call here?
super.init() method never throw an exception.
Should be added the Override annotation.
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
AFAIK env vars injected using this way don't support not set env vars. Have you tried it?
Same here: should be Branding, not ProductBranding
I think we should log this, at least at INFO level
Why is not the check of presence of certificate with given alias left for the next processing, like in case (principal instanceof NamePrincipal) == true?
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
wow don't fail the test here! Unfortunately,JUnit has no 'inconclusive' state, as in C#, so just log a message and return
please verify response on remove()
This seems redundant to me as we are logging in as the current user in the base class.
Minor: you can be safe and make sure there is [already a folder. ](<LINK_0>
By default, do we expose an HTTP port that allows for any client to shut down a process? What exactly does this do? System.exit? Do we anticipate (at a minimum) requiring some sort of authentication in the future?
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
terminated = true ?
I don't understand why this is being done here and not inside the conditional block below where it already calls unsubscribe on line 352/403. We shouldn't call unsubscribe before emitting onCompleted.
This is wrong usage of addToSlot(). I wonder if we should fire a NullPointerException when child == null and fire an IllegalArgumentException when child.slot == slot && child.parent == this.
Can you reduce the nesting depth here?
The pattern is to have the init before the try: AdminClient client = AdminClient.create(getDefaultAdminProperties()); try { ... } finally { client.close(); // no need to check for null if the factory never returns null } But if AdminClient is AutoCloseable you can just use try-with-resources.
Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your newBuilder() desire.
Should return false if !super.supportsRefreshing()
Should return true if super.hasIncomingChanges (the parent section may contain attribute editors directly, e.g. the bugzilla attribute section has attribute editors and also a subsection called Flags).
it could be simpler return this == LOCAL
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
log() here and after
This can be done more efficiently (and without using jsoup) by returning fromHtml(text).toString().
Don't expose the whole list. Either a single getter getLocation(int), or an Iterable, or both if needed. And even when using Iterable, you also have to be careful for concurrent accesses. But in this case, elements are added to the array in loadXml(), which is called by the constructor. Which means that once this method becomes accessible (after the constructor has run), it should not be modifier afterwards. In fact, you know what would be clean? Putting the loadXml() stuff right in the constructor, and saving the fields themselves as unmodifiableList/Map's. Then you can expose an Iterable view, but don't have to worry about locking anywhere. Also, you often use List, when in fact the only operation to do is to iterate on them. If the order is not important you should use Set/HashSet (or TreeSet if you store Integers/Longs), it would be more performant.
you can use Collections.EMPTY_LIST
I think that we can also return keys direct;ly I do not yet see the added value of the current solution: java Set<Object> orderedKeys() { return keys; }
This can be relaxed to Type<T> instead of RealType<T>, no?
Why we don't use the delegatedSender synchronous API ? (I remember you already try to explain me that but I probably miss-understood)
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
we can remove the status variable by calling "return deleteEndpoint(endpointName);"
120 character limit seems to be violated.
Why we are starting and ending tenant flow in all the test cases? Shall we move the start tenant flow to @BeforeTest method and shall we end tenant flow in the tear down ?
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
As discussed offline, let's consider the calls to shutdownBlobStore and removeStore in VCR replication
Dtto.
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
This block is rather confusing to follow, because you're doing successive gets and puts, please could you consider restructuring with nesting of conditionals so it's clear where the flow of execution will go?
I think we need to find a better place to fit these attribute names as constants (the skipper.application.name and skipper.release.version). Currently, they are declared in the controller package but not in scope of the REST resources.
If instance is null it means that Jenkins is either initializing or on its way down and if that is the case we cant do that much so throw an IllegalStateException.
If you're doing this you need locking. A static initialiser might be simpler.
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
Insert another comma: enrichers, {} catalog items here
why not directly return connector.eContainer() instanceof Pool; ?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Why we want to fall through into the loading dialog in case of error?
why exit here ?
Instead of defaultWriteObject, just handle it all yourself: oos.writeInt(hash); T object = this.object; byte[] buf = this.buf; if (object == null) { oos.writeInt(buf.length); oos.write(buf); } else { oos.writeInt(codec.sizeof(object)); CodedOutputStream cos = CodedOutputStream.newInstance(out); codec.encode(object, cos); cos.flush(); }
Please don't store the buffer in the object, it doubles our memory footprint.
If we can't get a model-set, will anything work? Perhaps this should throw an appropriate exception in that case.
seems like this variable should be called json because it 'aint yaml...
Don't you want to test PUT and expect OK here?
where is this used?
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1166)
Nitpicking: we can use a pattern and String.format() to make it more readable instead of concatenating it like that. What do you think about it?
Also, why we need this change on every call to the intentChooser?
It seems like we should use the wrapper returned by getPathWrapper() as the default for both the bam and its index, instead of just the bam?
use ConcurrencyUtils#withLock
Any reason, why the plain endpoint is create in "onCreate" and the secure in "onStartCommand"? Did you read the android docu for the "on???" ?
just out of interest how does this look multithreaded?
10000000 is a timeout I think? I saw in PubSubIntegrationTest the 10000000 was assigned to a constant of REDIS_CLIENT_TIMEOUT which would make it a little clearer without diving into the constructor (thought Intellij tells me what the parameter is so not too worried about it)
should be called resources
should we do this assert on other list endpoints (I don't think I've seen it yet) also why do we expect 1 when we're not even passing a limit?
should be called resources
should this count be parameterized?
Maybe add some counter inside the handler just to be 100% sure the compiler doesn't throw this away.
Pull this into a static final variable
We don't align on columns.
Can we use the variable name "employee" in such cases? (Same for a above constraints) lamdba's don't have an explicit type written down. (It says "e", not "Employee e"), so for readability (most users start from one of these examples), let's use a full variable name. In general, in optaplanner-core only the following short var names are used: int i, Object o, Exception e.
Use SimpleLongScore.ONE
Why do we return the parents name instead of the name we store a few lines above?
This would be safer if rewrite it in the following style: java return getMetadata() == null ? null : getMetadata().getName();
suggestion return "Worldcat Fetcher";
would this be called often, and would the list copy be expensive?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Collections.emptyList()
Please rename this layout file as well removing _new_api.
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Utils.validateArg(lowerBound < upperBound. . .)
This doesn't have to start on a new line.
I know this is just test class, but this is what Optinal.empty() is for - avoiding necessity to sometimes use null ;-)
filters method argument should be passed to isMessageInLogFile as an argument
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Does order matter here?
I think we should make this default value as -1, util we have benchmarks show 500 is in general good for most of applications.
It should be disabled by default
signedness does not matter for 64-bits
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
Can we revert this constructor argument change for classes that don't implement ResultBearing?
exactly one sort key is required for RANGE units
let's add a valid :abc parameter in here too, not only invalid bait
As above: eliminate magic literals.
Should we log this instead of printStackTrace?
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
please add line above to separate 'block'
Looks like approach proposed in line 92 would help here too. The less code duplication, the better :)
Why asserting this?
@kujtimiihoxha Why not just "X-Netbout-Alias: %s" ?
@antonini Let's use Collections.addAll instead of having a loop.
this and m_ is redundant
since we're going to remove the vm anyway, this can be replaced with: if (startingVms.remove(vmId) && log.isDebugEnabled()) right?
do we really need this in 'info' level? we have the log of run-vm..
Let's have the if in the positive branch
Remove this (ORDER_MAP_ENTRIES_BY_KEYS).
mapper is usually set to env.service(ObjectMapper.class), so without copying it, the statements below will change the configuration of our shared ObjectMapper instance.
The first argument can be random.
This is where i think the connection would come into play: this.connection.getSenderSession()
There is no need using synchronized here and in the stop method.
I think we should add this datum to the frame and confirm that the session also successfully moves on (just to ensure the end-to-end is also still working)
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Remove entire wrapper finally block
Remove entire wrapper finally block
Shouldn't this message be changed to "Should be 500"?
Pull this up to the constructor
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
Not sure this is the best place for these generic checks.
warning: The static field AbstractProcessor.logger should be accessed in a static way.
Why are we configuring drawer in this activity. This activity shouldn't have it.
I don't think you need to do all this. Just add a method public void init(T data) { render(data); } Are there places where you need to call this Dialog where you don't have this data available i.e. you need to call init without any parameters and it needs to reuse the data that it was initialized with? If not, then the init(T data) approach should work just fine.
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
I do not understand why is this template, I expect: public void put(VdcParameter param, Object value)
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
why is this return null??
Possible candidate for bind() if that method is created.
Possible candidate for bind() if that method is created.
Could you make this method protected? This will allow override it when needed
same issue
replicaList is not null so I would have just used replicaList.hashCode(). This might allocate a wrapper array for varargs. Objects.hashCode() is the single arg version that won't allocate.
What is the reason for not including preferredHeight and preferredFps here? Looking at BitrateController#setVideoConstraints, I think it might fail to call update if the only thing that changed is the preferred height or FPS. Or is this on purpose?
You can clean the BlobStore via: java BlobStore blobStore = blobStoreContext.getBlobStore(); for (StorageMetadata metadata : blobStore.list()) { blobStore.deleteContainer(metadata.getName()); } blobStoreContext.close();
This will suppress the warning for update site and category mojos, where I think the warning is justified.
Should we use a deamon thread here so that we don't block JVM shutdown?
I think this has to go to the finally block, already after this.received = in;. Otherwise race condition.
It's a pre-existing issue but I'd rather like that we use readOptionalWriteable for symmetry with writeTo, which uses writeOptionalWriteable. Or change the write logic to write booleans.
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
It seems that wt10g and gov2 are pretty clean on tuna - there are no readme file or other unwanted folders. So we probably do not need these filters?
Arrays.singleton()?
It should be fixed. Component can't support all products if it supports only DI engine.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Won't fix.
no need to use this. outside the constructor. Here and below
In another case, you tested hasNext. I think it's better if you do that and throw a NoSuchElementException rather than passing null.
why do we want to correlate cinder and managed block storage?
ooh! I ...Connector, here!
if at all possible let's try to avoid introducing more mess:)
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
JUnit has [ExpectedException](<LINK_0> which I think works better than try catch statements. There are some examples in the Geode code base if you want some inspiration
Make it a static method in ExecutionExceptions or similar class?
@lautarobock what this is for? there is no super class
This is a breaking change and we might want to add some checks here later. Can we leave exceptions here for now?
@gianm >emitted by default only if the user has authentication configured? What did you have in mind for the "has authentication configured" check?
This if is redundant. Question for you, @nezihyigitbasi: Do you see IntelliJ "warning"s for this? If not, you should turn those on.
Either use this.usedBytes or usedBytes, but do it consistently in a method.
Initialize this in the field declaration
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
...and change this to getAnnotatedFields(Class<? extends Annotation> annotation)
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Missing randomDiscard param.
Must be Outcome.Benefit to keep good card
This could be set in the constructor instead of checking this on every request.
suggestion
To remove?
Remove the redundant null checks.
I'd try to build config once in the constructor, save it in a field and use here.
done for patch3.
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
create a member for ClusterServiceModel
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
The problem with image. It is a local variable which is returned to the caller, but you still use it in parallel as a container for image data. Situation to consider - user e.g. draw image on some panel, but in parallel the image is updated with a data from camera. Possible side effect - half of image is from old image and half is from the new one. This is because there is no synchronization between operation on image data.
Not needed given the new way of interacting with eventThreadLocal
I would remove the else and just return.
- log warning that option is not supported by SNMP
Seems no other callers, make it private? In that case, no need to make it unmodifiableMap
Based on how it's used, it's more like a listener not callback.
same suggestion about static comparator
And this should be able to use the static comparator to be a little less full of (((())))(
and using comparator here
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
Can be replaced with this.constructLockKey()
suggestion return getClass().getSimpleName() + '@' + this.id + '#' + this.version + ' ' + toJson();  IntelliJ thinks this is better
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
Missing @Override annotations?
OPTIONS could be more suitable here, since we don't want to transport the whole value
what is the new behaviour now that you don't setSucceeded to true ?
minor: move the else up on line, together with the "}"
Not sure if vm can be null, it is already locked.
Use Iterators.transform from Guava?
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
The innerIterator is not thread-safe, meaning if two threads access next() in parallel, they may get junk. By synchronizing the wrapper, only one thread at a time gets through to the inner interator, other threads are blocked in the wrapper until the thread inside is done. That way, this method returns a thread-safe iterator.
This is the only place that add entry to the pool, is it the only way to fill the pool?
there is no change, why have you pushed?
getParent() can return null
remove extra line
footer is used once, cast it directly
inline please
An exception without any messages or stack traces.
Might be out of scope of this PR. If it is, please feel free to ignore - but we are doing nothing on exception here. A message or stack trace?
formatting
Do you want to make the check that portFields is of size 2?
move inside of for loop.
Null pointer...
Why WARN for FAIR and INFO for other unknown entities?
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
Does this now call stop asynchronously, rather than previously doing a blocking call? Should we do a .getUnchecked() as well? Or return the task?
String.valueOf()
You could add an empty line between function declaration and content if content is more than one line, much like SDN (where I like it a lot)
Since you return in each branch, you don't need the elses.
Coding conventions: Let's have the @Override on its own line please
Same for detach
Did this stop being optional? If so how does it not break older hosts?
same... do the reserveMemoryFucntion.apply() first.
Can bytes be negative?
Declared exception from update method can be removed as well as this try-catch block.
public constructor in private class should be package level constructor.
Loading background image every time map size changes e.g. on every unfold operation does not look like sensible, does it?
Code style: Curly braces after if and around else statements.
This should not be done here. Use StudentFeedbackSubmitPageUiTest to test this.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
We could stochastically test it.
You are not using getExceptionListener here.. is the test really duplicating the issue?
nit: new line
Reuse the runnable to reduce the noise of GC if possible
You could kill offset and pass 0
You could kill offset and pass 0
Does this need to be public? It seems to me this would only be useful to call from subclasses, so it could be protected. Shouldn't we make it final in a 1st iteration or do you have use-cases that need to override it?
do not remove checkClosed()
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
The version check should come before the call to loadTemplates().
Sorry, being picky: return StringUtils.isNotBlank(version) && version.contains("SNAPSHOT");
This println can probably be removed.
Have this just return an Iterator<String> because a List is a bit too specific and forces extra memory to be used even if not required.
I think Local.ROOT is probably a better choice.
constant? nitpicky I know, sorry
blocking calls inside the SDK are not good. they can cause deadlock, perf hit, etc. We are not doing blocking calls anywhere else.
where are we doing the initialization blocking call now? If the global endpoint manager is not fully initialized with first databaseAccount fetch could this return null?
I'm missing the new field in the toString method.
Consider a case where user entered a single quote ' in streamName, then the sql query can give a syntax error and the app will crash. I think it'd be better if we use ? in sql query and provide [arguments](<LINK_0>,%20java.lang.String...)) in queryRaw.
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
Usage of StringBuilder would be more readable IMO
Remove extra empty line
remove
shouldn't you also set the fields to null here?
You could also use path.endsWith("/")
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
use existing constant
virtualColumns and descending go in different order elsewhere in this class
There are no backward compatibility concerns in toString(), please change the key.
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
I'm not sure, would this have an effect if the shell is maximized or minimized? Do we need to make sure it's not?
It's better to use i18n
Although this won't make a difference right now (because memory: URIs are not translated) this should be return delegate.createRepository(translate(location), name, type, properties); for consistency.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
I think the annotations should be on separate lines
You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?
You use this exact log message in the AuditLogger class, do we need a statement both places? If we do, can you make the message here (or in AuditLogger) more specific?
Any logging that is just "begin" and "end" statements should really just be trace. Apply to all subsequent uses in pr.
just return "" instead of new String()
Preferably have one call the other?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
This is redundant in Mockito 2
This is redundant AFAIK - it should be Mockito's default behavior. If it isn't, use Collections.emptyList(), not the raw EMPTY_LIST.
I see this code is same as the one in earlier test, so it can be extracted for easier read, with just return value as parameter.
ObjectUtils.objectsEqual(a, b) may help here.
This validation is not required. You can expect the brick name returned by glusterfs (and consequently vdsm) to be of the correct format.
How long can be the brick list? What happens if server crashes in the middle? You might have a partial list in db. These things should be done somehow in single transaction.
currentTimeMillis() instead of creating a new DateTime() object
Should 60 be 60.0 to avoid rounding?
72 is a constant in Constants class
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
We could probably use getItem() method here, for consistency.
Please create a new function dedicated to stopping shimmer for better code readability.
nit: can be simplified to return counter++;
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
This code is a bug, should fix like following: return randn(length, 1);
This change is still incorrect
empty line
Please add a static import for containsString.
Don't think the "Tenor" in the toString adds any value now. Merge toFormattedString into toString.
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
My checkstyle is exploding with "magic numbers" here. You could easily use the constants from the Items themselves here I think. And if not, please make these numbers constant fields in the test. <review,testing,logic
Exception propagation. No need for subsequent return null
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
Make this as a log.error statement. And needs to have space after the ","
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
this assigment is not needed, since its default value is false
return filterSet.getActionFilterOrder() != null
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
Actually looks like you can make this method protected and call it from the OpenshiftClientFactory to avoid duplicated code. WDYT?
Set the httpclient in pipeline instead.
Why do you use the qualified name here and not a standard import ? You could also call Path.fromOSString(path)
Please put spaces around :
Why don't you pass the message in the annotation?
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
unnecessary array new: {{true}, {false}} should work here
rename to nonJava
Why the change? This does the same thing as the original code.
I believe the return value of System.getProperty("os.name") should be normalized first using:  private static String normalize(String value) { if (value == null) { return ""; } return value.toLowerCase(Locale.US).replaceAll("[^a-z0-9]+", ""); }
if you want to make this code more efficient, you can go for something like  private static final boolean IS_WINDOWS = System.getProperty("os.name").startsWith("Windows"); public static final boolean isWindows() { return IS_WINDOWS; }  That way the check happens only once at class loading and initialization time. Since we do not assume that we change the OS underneath a running JVM, it should be fine ;-)
suggestion assertEquals(1, IOExceptionOnOnlineListener.onOnlineCount);  I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
There are more new methods in Duration than are being tested here (e.g. toUnitRoundingToZero)
Use isZKLogAvailable() instead
Please use more specific JSON type names.
I dont think you need the RocketMQ version number in the name here.
This is not commonly used in Druid, can the subtype registration be kept as per prior? If you want to keep names and class registration together you can use com.fasterxml.jackson.databind.jsontype.NamedType.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Please catch specific exception(InterruptedException) not generic.
Why do we need this method? Wouldn't be better to merge this one with getLatency()?
?????
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
nullity check here too :)
nullity check here too :)
Should this comparison be !Objects.equals(guestCpuType, value) ?
This should probably return WorkspaceChatSettings object
Was this detected by findbugs?
tiny nitpick. Change to: return Response.status(Response.Status.BAD_REQUEST).entity(new ErrorResponse(Response.Status.BAD_REQUEST.getStatusCode(), "path /{userID} required")).build() This is here and in other places too.
Will this work if I am trying to put a jar in the place of a non-empty directory? Which is the case when an exploded bundle is partially copied into storage I believe.
Files.move(from, to, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE); I would pass both parameters for the first try.
Are these cases all needed? Or what all of this just copied from categories?
Maybe wrap in an immutable map.
isPresent() is expected to be used here.
I think JPA requires this to return a Long
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
never use system.out.println() in this project
Actually, I'd recommend initializing principals using Collections.singletonList(SimplePrincipal.newInstance(username)). The resulting list is immutable and an efficient implementation.
return HConstants.EMPTY_BYTE_ARRAY; ?
need to add more information about dimension/index/length
Can you change to static variable ?
This is wrong. We still need to use the folder name for equality checks.
This isn't a valid implementation of equals. You can have non-equal things have the same hash via a hash collision.
sound?
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
Iterate the return value, no variable needed.
artifactId is not enough... groupId and packaging must match too
Do we have any threading concerns here?
isTraceEnabled is not necessary here ?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
again, just set the element in the array ?
java this.onPostServerTick(this.getMinecraftServerInstance());
I believe we could set initial nextValueIndex right on attribute declaration, to avoid repeating it in all constructors. What do you think?
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
should the interface not the implementation suggestion public List<String> getTopics() {
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
redundant method("POST")
I don't see any change that is related to elapsed-time, why is this change needed?
Why not just simply "command.setVM(vm)"?
super.getVm() will do dao call...
result -> results
public isn't needed
is this key unique enough if there are multiple fields with the same type, either in the same class or in class parents?
need to add more information about dimension/index/length
@greenaddress  and this?
return a copy of the data to keep DataExtension immutable.
these setters should not be public
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Missing StringUtils.isNotNullOrEmpty() check
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
it will not throw InterruptedException any more. Should also check the other places.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Same nit as above.
Adding to Megumi's nit: Consider initializing the value to true, and possibly collapsing these two methods down to one with an argument
You can also do  try (FSDataOutputStream stream = fs.create(new Path("s3n://test-bucket/test"))) { assertEquals(CannedAccessControlList.Private, s3.getAcl()); }
Might be good to extract "Unknown" into a constant in this class
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
I would suggest reverting the isSytemLibrary field back
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
IMO we should still throw an Exception here after logging the error - failing the deployment seems OK to me, as long as the user can find out _why_ the failure occurred. (If these values aren't specified, **the function itself won't work.**)
Why fakeThread
Also this should be Log.d
This seems in appropriate to log at info level. What do you think?
Please revert if possible
This line could throw NullPointerException because id type is Integer, not an int. NPE is not expected to be thrownfrom hashCode. Please, fix this method to deal with null IDs correctly.
Use Guava hashCode function
once again, equals/hashcode - does it make sense? please revisit in all value types you created
Is this meant to compare the item stacks beyond object equality, given ItemStack does not override equals *or* hashCode
Is it intended to not compare the size of the stack here? (FluidStack doesn't take size into account normally for equals, though it does for hashCode)
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
If partition awareness is disabled and a new node is joined it's fine to work with the current node until failure (we don't need to find new nodes unless we disconnected from the current).
Hmm, is this better than a switch?:  switch (ch) { case ' ': ... }
ch is always >= 0 :-)
remove this line
also this one seems unnecessary
It seems this given statement is not necessary anymore.
org.eclipse.papyrus.infra.ui.util.EditorHelper.getCurrentEditor() 1. do it for you 2. check no NPE calling it.
This method does not seem to be used. If it is used, please rename it avoiding the get prefix. Assuming there is a method which ensures there is a storage (i.e. storage()), we can have hasStorage() if we really need to query its presence.
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
it is possible that getItemAtPosition returns null -> sure NPE here
If we seek backward should sequential count always be set to 0?
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
It would be good to use constants instead of hard coded property names. Maybe you could use KFSPropertyConstants.BUILDING_NAME constant instead of "buildingName" or add new constants to CuCamsConstants.java
What volume of vendor numbers are you expecting this method to receive? For smaller volumes, the current setup here should be fine. For larger volumes, though, it may be more efficient to build a query like the following (but in OJB Criteria form instead): (VNDR_DTL_ASND_ID = VAL1 AND VNDR_HDR_GNRTD_ID IN (VAL1A, VAL1B, ...)) OR (VNDR_DTL_ASND_ID = VAL2 AND VNDR_HDR_GNRTD_ID IN (VAL2A, VAL2B, ...)) OR ....
Have this just return an Iterator<String> because a List is a bit too specific and forces extra memory to be used even if not required.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
that would be name I think
Peter B. said in different commit <LINK_0> that this exception is not thrown for jdbc.query and you said he is right. So there is probably the same problem in every method with jdbc.query.
let's change this to look like try { return objectMapper.readValue(jsonString, type); } catch(JsonParseException | JsonMappingException | IOException e) { throw new RestMappingException("Error maping jsonString to " + type + ". jsonString = " + jsonString, e); } that way we pass the exception to the RestMappingException constructor and get information about what kind of exception occurred.
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
Unnecessary cast.
CI build shows 90+ failing tests, and they all appear to be caused by this change. Perhaps some of the other converters are lossy as well, and some of the failures appear to be for objects which do not have hashCode and equals methods defined, so the comparison fails because we have distinct references before and after deserialization:  junit.framework.AssertionFailedError: <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> vs. <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> expected:<com.thoughtworks.acceptance.AttributeTest$Camera@50d640dd> but was:<com.thoughtworks.acceptance.AttributeTest$Camera@447bf09d>  Also one small nit, I would change the spacing to make the failure messages a bit easier to read: suggestion assertEquals(xstream.toXML(expected) + "\n vs.\n" + xstream.toXML(actual), expected, actual);
simplify this
I don't see why is isConnectionSetup() necessary. Shared in SharedPubSubWebSocket client means it is shareable and must support concurrency. It should be the responsibility of SharedPubSubWebSocket to ensure that its state is properly managed and if setup() can't be called concurrently, enforce it.
no public
This should probably throw if the value is null.
java.lang only required here
like line 63 but this is setFeature, so should be removed?
ditto on readability here:  int result = name == null ? 0 : name.hashCode();
permissions can't be null, otherwise the constructor would throw a NPE.
Can we please do something like this: return Objects.hash(enabled, triggerPackages, pollInterval) instead
declare throws please
declare throws please
for me it's too long. Maybe Result.wrap() ?
Not needed, delete.
How about doCheckout ? 2 : 10
please invert the conditional operator to get rid of the negation
instead of e -> e there is a Functions.identity()
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
I'd split the map() here into two separate phases. First mapping the Entry to an Integer, then sorting the Stream<Integer> and only then mapping the years to IdNamePairs, e.g.  .stream() .filter(e -> e.getValue() > 1) .map(e -> e.getKey()) .sorted() .map(year -> new IdNamePair(String.valueOf(year), null)) .collect(Collectors.toList())
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
this should be true when index == 0 to allow optimizations for this particular case.
Geometry is comparable?
IMO it should be synchronized as well
Seriously dude, don't reformat code for no reason.
does not need to be public in non-public class
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
truck is unused
Looks like setting RECORD_CURSOR_TRACES to false will increase the overhead of recording cursor traces, since the traces are captured regardless, and then stored in a cache shared among all threads, and the cache has to evict on all but the first put.
check for READ_ONLY style is missing?
Update the error message to say "taskLockHelper" instead of "segmentLockHelper"
static import?
Replace by Objects.requireNotNull()
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
How does UTF-8 become null here? I am missing it.
This doesn't seem correct, you need to fetch all the active drug order and of the patient, loop through them to find all drug other orders and compare their none coded value to this drug's none coded value
s/no not/not/
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
See previous remark regarding explicit _Fail_ call
Used to be fileSystem.deleteFileOrThrow underneath.
I think you will want to use Mockito here instead of depending on a random third party web site -- random from Apache's POV ;-)
Please copy on construction for primitive arrays.
A much faster way to do this (because Java streams are expensive to construct and the JVM doesn't yet recognize a simple map operation) is final double[] gaussIntegrationWeights = new IndexRange(0, numPoints).mapToDouble(integrator::getWeight).
Typo "...comman**d**..."
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Bad code. Remove try - catch.
Could it show Default or System default so users are not too confused with an empty value?
use an overridable getOperationTimeout() method instead
why removed these two lines
static?
Instead of the Guava Objects.hashCode, use Objects.hash instead. It is available since Java 7, and reduces our dependencies to Guava (furthermore, this method is not available in Guava 21 :) ).
Similarly use the Java 7 template
Probably enough to have Longs.hashCode(pointer) which should be a little faster.
Let's avoid null and rework to empty string
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
unnestChannelInputBlock -> newInputBlock
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
Collections.emptyMap() would be better for performances (not actually created a new object).
can't this be an ObjectArgument.of?
Why is it a list of lists, not just a list?
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
why do we need a Collections.singletonList(cmd) here?
If this never changes you can also make this a constant and then return it (see Text API for some examples)
How does the deadline in Context set by user? It seems to be harder to track where the deadline is coming from.
is it not empty if for example type is an valid empty string?
verify is probably more trendy
Why returning an unmodifiable map? The returned map is a new instance generated in this method. There should be no other reference to it except for what returned from this method. Returning a modifiable map would also save us from converting back to a modifiable map in getTaskManagerLabels and getConfigMapLabels.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
Remove
do we need to return the whole stack as the result? that seems a bit much to the user. how about just the message as before and log the exception?
The property name does not match the one in SystemEnvironment, may be you could use SystemEnvironment.GO_WEBSOCKET_MAX_MESSAGE_SIZE.propertyName()
why is this return null??
Hm, maybe this should return bitmapResultFactory.wrapAllTrue(Filters.allTrue(selector)); and return true for supportsBitmapIndex. As-is, TrueFilter shouldn't be returning true for supportsSelectivityEstimation since it doesn't support bitmap indexes, but not supporting bitmap indexes would potentially interfere with use of bitmap indexes for other subfilters when an And/Or filter contains a TrueFilter (See makeCursors() in QueryableIndexStorageAdapter and getExecutionPlan() in AutoStrategy).
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
extra line
This println can probably be removed.
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
Could simplify to assertArrayEquals(new int[]{0, 1, 2, 3}, array)
How about assertArrayEquals(new long[] { 2, 2 }, values); ?
Consider returning a constant
We should name this special value so it's clear what calling with -1 does.
Consider a constant symbol for -1 to indicate an error value.
may be we should assert on get() > 0
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Please use the generics-supporting Collections.emptyList()
if those lists are intended to be empty list (and not be modified by the client) the always return Collections.emptyList()
you can drop the new ArrayList<>(...) surroundings. It's sufficient to return just the singletonList.
This method seems weird, especially in a context of ValidAggregate. Let's discuss it.
This should return the list of resources under it, see FileResource impl for more details
Could change the return type on method to Collection
Is there a way to do that waiting for an event to happen instead of fixed time interval?
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
there is no need to execute initElements method, when you're extending BasePageObject
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
I really don't know why currentHostThread is returned (or the previous entry)... Only the critical path module needs anything. You could remove this line while updating this file.
This code here should be inside the if, because we don't need to do anything if the parameter request is not PARAM_WORKER
I would use getTreeItem you have defined below to access treeItem, since you implemented it. Instead of direct access.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is this change related to updating apache velocity?
That would create a warning. The only safe way to do that is casting from the caller.
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
From the wiki: Its fuse lasts 40 redstone ticks (4 seconds/80 game ticks) if activated by redstone or fire, or a random number between 10 to 30 game ticks (.5 to 1.5 seconds) if it's destroyed by an explosion. In other words, right here the number of ticks needs to somehow be passed down to the explosion objects (setFuseTicks). My recommendation is to add an overloaded method to explodeBlock that accepts a boolean: blownUp (name is just a suggestion). If that boolean is true, this 'random' tick count is applied, otherwise the standard is used. I would almost go as far to say that the boolean should further propagate to the explosion object that holds the fuse ticks so that magic numbers aren't all over the place.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
please just put it in the proxy instead, that's cleaner and easier to find then
This is a race condition. done() releases slot, which can be written to right after done() and right before RetryHolder is retried. This can lead to unpredictable results. RetryHolder needs to be copied off before releasing queue slot
This will slow down the down the app, since you are executing an additional SQL query for every note. Currently, I have about 200 notes and showing them on the main Activity requires a single SQL query. With this change, 201 SQL queries are executed. This is a "no go"! There are two alternatives to fix this issue: 1. build a "cache" in memory for categories, i.e. load all categories of the current account to a HashMap on creation of e.g. NotesDatabase and query this cache in getTitleByCategoryId(...) (and related methods). But on every change of categories (insertion, deletion, edit), you must update this cache. 2. change the SQL query in getNotesCustom(...) and add a JOIN on the categories table. Hint: you can reduce the need for changing code if you change the column names of the categories table: If they differ from column names in the notes table, you may not have to prepend the table name (e.g. CATEGORIES.TITLE, because TITLE exists in both tables CATEGORIES and NOTES). I vote for the second approach. You can remove the method getTitleByCategoryId(...), then.
This check is redundant; the projection in the query is just 10 lines up and there's only one column.
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
I this refactoring, very nice. Could make this method protected.
No need to create local variables for this.
should these all be this.variable instead of just variable?
It can be null?
names
Why not reuse existing? public static Type valueOfIgnoreCase(String name) { if (name != null) { return valueOf(name.toUpperCase()); } throw new IllegalArgumentException("Invalid value null"); }
We do not consider the whole resource, but only the selected elements (and their descendants). It should read "The selected elements do not contain".
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
Rename e as ignored if not used.
"%setup -q -n %{name}-%{version}" is the same as "%setup -q"
Reuse result of StringBuffer.append instead of using buffer local variable.
But now these 4 lines above can be deleted.
Why is this file changing? I'm concerned that changing domain objects will have far-reaching effects. As well, there's no id that this.id can be set to in this method
This constructor seems redundant with the one above. Do we have any special need for it, aside from not having to specify survey? I'm concerned that if we update this class, we'd have to update 2 constructors instead of one. At the very least, we should make this constructor call this(label, activityType, ref, null) to avoid duplicate instantiation code.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
events.isEmpty()
Probably going to want to watch the endpoints() rather than events(). Endpoints will give you ready + not ready hosts/ports with the metadata attached, which should be all we need for this case. Events will likely be way more data than we actually need
extra ; at end of line
Can we use !mResponses .isEmpty()?
this.
Could be suggestion return !selectedBaseResources.isEmpty();
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
@droneboost use the activity parameter instead of calling the getActivity() method.
Activity state util check before starting any of this, maybe?
No tabs please.
you don't need a try-catch here. You can simply use @Test(expected=NullPointerException.class)
In the wonderful world of JUnit4 ;) you can use @Test(expected=IllegalArgumentException.class) public void testCallsiteCopy2() { new TmfCallsite(null); }
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I'm missing the new field in the toString method.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Should this link to the course?
Return the zone id here instead of returning an empty string.
Consider limiting the number of characters to 32, since there are no HTML entities with more characters than that and it would help to avoid false-positive matches. <LINK_0>
save data?
Maybe you could do this with only 1 remote call?
minor: you can return Collections.emptyList() instead
Remove this by returning null above.
Duplicate map keys (%s) are not allowed ?
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
I don't think this should trim the result. That's not what I'd expect from the wording getRemainderOfLineAfter. Let the caller trim instead, if it wants to.
This null check should not be required anymore
Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though.
should we enhance the statement to log the given message (and userid)? Did you omit these details on purpose?
Why is this on its own line?
we can use **testUser.getAuthToken()** here, can't we?
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
It's redundant if makeRequest is used to send request.
I think we need putObject(Routing.EDGE_BASED, Helper.toObject(edgeBasedParam)) here (previously this code relied on the string being converted to boolean... This is a bit ugly code, and will be gone in #1958 :)
input is not @Nullable, remove annotation or add null check.
You can write it directly notNull(subscriber).isApplicable(project); (Same with other places, with static imports)
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Make null-safe: if (m_decimalFormat == null) { return null; }
Should be public
Maybe it's better to use Collections.emptyList() instead
....and then you don't need to call it on every other method
copy.setFromOriginal(this); -- should use this here ?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
If the only parameter is the id, do you need to send it in JSON? Maybe just use an url-parameter and get it with params.getRequiredParamInt("id") so you don't have to worry about if it's not sent or if its not a number etc. Also remove the param getting out of the try-block so you don't wrap the possibly thrown ActionParamsException to a new ActionException spamming the logs.
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
You can use CollectionUtils.toImmutableList
@GaneshSPatil with this check, in cases where multiple ConfigRepo plugins are used none of the repos will be parsed if a single plugin is missing. Guess this was not intended.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
synchronized can be removed.
we should not print the errors to standard output. use StatusHandler.log(new Status(IStatus.ERROR, GerritCorePlugin.PLUGIN_ID, e.getMessage(), e));
Change the second part of || to an assert (verify).
Don't think items can be null, and ArrayList (as well as List and Collection) has an isEmpty() method itself...
Add parentheses, helps readability: return (fQueueSize.get() == 0);
I know this is not part of your patch, but I think we should do this only if initVirtResources() had succeeded (in gluster+virt mode). So, what I suggest here is, if (getSucceeded() && vdsGroup.supportsGlusterService()) { setSucceeded(initGlusterHost()); }
You could simply use getVdsGroup() if you extend VdsCommand
Reminds me of containsKey() :smile:
Do we really need this check? I think it's redundant.
personally I find the combination of of() and put() weird. new MapBuilder().put(...).put(...) does not leave readers to wonder.
Redundant 'else' clause.
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
Can we confine this change to just the calculation of the MD5 itself?
minor: no need for final?
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
The super() returns "" on null. Why should we differ?
if we implement that offset we mentioned, we could even map negative elements here with a negative offset :)
why is this public now?
shouldn't we make this private. I mean, move AccountBuilder to this file and make this constructor private so that no one else can construct an Account instance apart from builder
redundant ";" character
Should this return the AzureTable?
is there a reason why this method isn't implemented?
throws TaskException is part of the interface, did you mean to remove it?
it appears that this change can be reverted.
Do we need to log the exception here? I would expect the calling code to handle it.
"no longer supported" -> "not supported for immutable description instances" ?
This method as discussed is used in a synchronous() fashion. Not sure if you intend to do this in a separate thread
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
Will this work with touch?
post-content__title
Needs to be localizable.
You can do a chain.isEmpty. Then StreamSupport.stream(chain.spliterator(), false).limit(chain.length() -1) possibly. We can then leave that for later for collecting to then create the chain is sad... We should have a Util.getChain(Stream stream).
Agreed. Maybe an Optional<VarRefNode>?
Please throw exception if ! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If ! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative, the code in the hot loop could be optimized, idForNull could be assigned as soon as selector.lookupName(index) returns null for the first time.
I'm missing the new field in the toString method.
why uniqueKey, be consistent call it keyField
assert.NotNull ?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
return defaultFilterFactorEnabled ?
no, this.running must there anyway. Or we can rely on the this.contextStopped variable...
Geometry is comparable?
shouldn't the last part be (getVm().getCustomCompatibilityVersion() == null && !newVersion.equals(getVm().getCompatibilityVersion())) ?
so maybe I'm missing something then.. we're handling the case that the compatibility version of the cluster the VM is defined in is changed. if there is some custom compatibility version for the VM, then the cluster's compatibility version is irrelevant - the VM will always run with the custom compatibility. therefore, if the custom compatibility version is set, the method should return false. only if there is no custom compatibility version set then the VM is affected by the compatibility version of the cluster and then we should check if the new compatibility version of the cluster is different than the one the cluster that the VM resides in had before. no?
is it not empty if for example type is an valid empty string?
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
You should change this sort of check to "github".equals(source) as this inversion will always avoid an NPE in case source is null.
There's no real benefit to doing this check, so you can get rid of it and just do this.comparator = comparator directly).
The control-flow is somehow 'overlapping' because the if-else-block cannot be substituted with a function call. Please use this more 'straight-forward' version: java if (this instanceof PriorityQueue) { return (PriorityQueue<T>) this; } else { final Comparator<T> comparator = (this instanceof Comparator) ? ((Comparator<T>) this) : (Comparator<T> & Serializable) (o1, o2) -> ((Comparable<T>) o1).compareTo(o2); return toPriorityQueue(comparator); }
Style inconsistency: space after if
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
Why not throw IOException and let caller handle and log etc.
throw UncheckedIOException(e)?
Please do a format of all files before committing (ALT+SHIFT+F).
If you're doing this you need locking. A static initialiser might be simpler.
given that you re modifying this method...it should be made synchronized just to avoid concurrency issues. Also update the end date in the copyright header for every file you change.
getGeometry call here is redundant, because OGCGeometry.createFromEsriGeometry(new Point(x, y), null) can't return anything other than point. Perhaps, remove it.
Maybe an overkill: the empty HLL may have "unknown" bucket count. The bucket count remains unknown when merging with an unknown-bucket HLL or coalesced with the other one's bucket count. But given the complication, I don't have strong opinion having this.
I would static import quantileBoundsToArray.
if at all possible let's try to avoid introducing more mess:)
why do we want to correlate cinder and managed block storage?
Don't qualify with HostJobStatus: return this == running || this == pending
We may also want to cancel our subscription.
please remove from this patch
socket might be null if an exception was thrown in sendToSocket catch clause.
keep requireNonNull
requireNonNull
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
I think you're missing getDefaultConfigurationFile() here.
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
I don't think the process deploy should fail in the case of temp file deletion fail
These "duplicate" entries should no longer be required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
Use Allele.SPAN_DEL once it's public.
gitlab extension might not be needed here?
you should have here setSucceeded(true) IIRC.
Will need a @since tag.
No parameter in setter method?
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
I think this is up to embed the current index into the message but this will result in a message like where no index is printed. The escaped ' also seem useless.
I believe these 3 lines should be moved to BMT, it's his logic
This part of the patch looks fine and can be merged, with the small correction mentioned below.
I took a look and you simply iterate over this. No need to expose the interface List. Return a Iterable<String> Consider renaming as well to something like getReviewUrls since that's what is really happening. You use the "URL" semantics everywhere else in this class.
null? why not just a () -> {} ?
The constructors should be package private
we still want to remove the object here and not let that be up to the observable to do so
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
Is there any longer a need for the VM ID ?
are you sure that this should be logged with audit log and not regular log printing? imagine a system with 1000 VMs were most of them are running (production environment) and you want to import just 2 VMs that are down - we'll get too many audit messages..
Call I18N.getString(String) (there are no parameters in the resource messages).
Call getString(String).
Can be static.
why would this be required again?
This should check the endorsedBy field I guess, since that is what is displayed in endorsed responses.
:x: this belongs in the BuildConfig --> create a field in the base.properties file and read it in BuildProperties#configure. See what we do for the other fields in there as a reference.
this is potentially costly, depends on what asMap is doing. Maybe getIfPresent and check for not null result?
Style fix suggestion public long getIgnoredPlayerTimeout(UUID uuid) {
This is not going to compile. You can't return an object in a void method.
@aunyks you should make expected a Set to begin with so you don't have to convert the return value of the describe method to an array
Why an array? List<String> is just as fine
Fedora uses 4 levels of hashed containers for identifiers, does it just use 3 for file storage?
I'm not doing so much Java lately, but no flapMap available?
Let's keep the old code here or let's try to move this method in the IndirectClient?
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
should we have an early exit if the trace is the same? I am asking, I don't know
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
Why are we marking ourselves dirty after deleting a ref? No new objects were introduced.
Why not String.format("%s -> %s", argument, result)?
Code style elsewhere is braces {} even for one-liners.
Hardcoded "\n".
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
This should delegate to the attribute mapper.
Maybe add regexp check about isNullOrEmpty() too
This conflicts with the commit message - either Uninitiazlied is OK, in which case the commit message should reflect it, or it isn't, in which case the check should be removed.
missing check that vm exists.. (getVm() != null)
We should also check the servers which we want to update the hook content is in UP state.
nit: I prefer the other ordering for <= or ==, it's easier for me to read "n is greater than or equal to 0" than it is "0 is less than or equal to n".
This should use the new checkPosLength(int) method as well.
I dont think that this check is needed here (otherwise it will throw an index out of bounds exception, which says the same). <LINK_0>
lun disks removal can't fail actually in the execute part, as it's a simple removal from the db..but i don't mind having it for the future in case we'll add ops that might fail.
From the user point of view the action that failed was restarting the Host. That's true that we are implementing Restart as stop-wait-start-wait but this should be transparent to the user IMO and the log should say that the restart operation had failed I see that the log of the NonRespondingTreatmentCommand does exactly that so IMO this block should remain without any change : @Override public AuditLogType getAuditLogTypeValue() { return getSucceeded() ? AuditLogType.USER_VDS_STOP : AuditLogType.USER_FAILED_VDS_STOP;
different audit message for the case only the key was updated is needed
The dispose() could be called from a finally block, to ensure it is always called even if an exception occurs during the getText() (which is possible given that it may call user-specified code outside of our control).
nit: do you need double checking here? if (INSTANCE == null) { synchronized(this) { if(INSTANCE == null) { ... } } }
sync
Same as above LOG statement.
Make final
Missing codes.
tracef
tracef
trace
You can use the string overload when TypeCriteria is exact match.
We could also consider these 2 methods for the check:  org.apache.http.message.AbstractHttpMessage#addHeader(String,String) java.net.URLConnection#addRequestProperty(String,String)  Eventually, this constructor as well new org.apache.http.message.BasicHeader("Authorization", "Basic abc")
@m-g-sonar you can add parameters constraint as you require to have two parameters in line 66.
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
I am wondering if we need separate versions for this step method with and without parameters. It looks like the defaults from the version without parameters would be applied if parameter values are missing in the step data.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Use LinkedList instead, as we need to remove its head frequently in endInput.
List<Integer> iterationOrder = ImmutableList.copyOf(numbersIterable); List<Integer> secondIterationOrder = ImmutableList.copyOf(numbersIterable);
try/catch
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
The field state should be read into a local variable outside the loop.
Let's just catch relevant exceptions and at least log those
true?
I think you can write this method as: int s = str.indexOf('*'); if (s < 1) return true; if (str.indexOf('*', s + 1) > s) return false; if (str.charAt(s - 1) != '/') return false; if (s == str.length() - 1) return true; return str.charAt(s + 1) == '/'; although that version does fail to check for the // case, but we didn't check for that before either.
just a nit, perhaps move 42 to a DUMMY_VALUE constant? add a link to <LINK_0>
Does the code that caches the endpoint state (lines 258 through 259 above) execute in the next() case or only in the output consumer case?
We could keep track of the input watermark and emit the maximum at the end.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
instead of reading first, then adding, can we just call add directly? The result of add will be true if it successfully add the new item, and false if it already exists. Then, if it didn't exist, we can "update" the metric value itself but setting it or incrementing it. I think if we make these changes, we can even remove the synchronized block from the put methods above.
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
nonEmpty
those operations needs to performed be in the same transaction
seems to be like this should be before the vm is unlocked in super.endVmCommand();
This should go
needs to be negated, right?
Is it possible to have an empty row group without any records in it? In this case, a binary column also has null statistics values, and isAllNulls/hasNulls both return true, which is at least semantically wrong.
This is not equivalent
The attribute type needs to be exact here. suggestion public <T> AttributeRenderer<? super T> getAttributeRenderer(Class<T> attributeType) {
Consider making good use of Optional#map if you are going to use Optional.
That's good to know.
getter
setConfig too?
You'll want this inside the lock
Wrong test: the critetion to test is not whether the page was ever visible, but wether the user entered an explicit file name.
Since we're now using bus events, do we need this anymore? (The whole idea was to send events to individual cards, and avoid having to rebuild the whole view hierarchy of the RecyclerView.)
can this be a method reference?
nit, deeply nested functional chain. Consider decomposing this a bit with helper methods. EG:  return battleState.getUnits(EnumSet.of(side)).stream() .anyMatch(unitIsActive(BattleState.side.OFFENSE));  I believe you can also get rid of the intermediate variable as well and just return the result directly as well.
nit, would 'bombarindUnits' be a more descriptive name here? Perhaps even consider inlining it to avoid the intermediate variable?
suggestion return new ArrayList<>(List.of(units));  I assume the list must be mutable?
np: s/LocalApplicationRunner/RemoteApplicationRunner
if deviceStatusListeners was a Set, you wouldn't need to check this here (see above)
I believe the expectation is that listeners will be configured before the job starts. That is, the resultsSoFar would almost always be zero. If so, it wouldn't be beneficial to check against the maximum in this method. Also, fluent method should never return null because chained calls such as withBatchSize() in this example .onUrisReady(...) .withBatchSize(...) would be guaranteed to produce a null pointer exception.
Which method throw exception? why change assertThatCode -> assertThatThrownBy?
Need to verify no interactions with log
Too lax imho, should be .equals("org.apache.commons.logging.impl.Jdk14Logger")
Can we inject this feature directly ?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
Update labels to go with method names. Alternately, call super.toString for super attributes
@fuss86 Sorry for disturbing, but don't you think that this is "tight coupling" here to check this optional every time?
This could be moved to VampirePlayer#onEntityAttacked. But I guess it is fine here too
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
The test is OK whereas it shoulf fail as the code fix is not merged
Shouldn't this code run even if mHasWifi is false?
remove this?
Can you make all of the accessors final?
Nit: unnecessary this.
Is this the intended message?
Undertow handlers should never block. This can cause the server to hang. Instead the requests have to be queued somehow and replayed once the server finishes starting. Also I'm not really sure that a 404 is the right response if the server takes too long to start.
This is causing a compile error. The REMOTE_USER cannot be found.
This should be !exchange.isResponseStarted(), the response content length does not really tell you anything, a lot of requests use chunked encoding which will not set it.
If this should never happen throw an IllegalArgumentException instead.
ChannelClosed needs to be added to (though not strictly necessary)
Unsupported type:
0?
This may be better as a CODE_ERROR_SERVICE_UNAVAILABLE code because we may have not set up the RcsManager yet.
huh this is creative, I've never thought to use an executor like this before
The WFLY-1069 stuff should tie into this.
Use ServiceRegistry.getRequiredService(...) here, as it is impossible that the service does not exist.
ArrayList should be constructed with fixed capacity.
use { } around if body
nit:  while (position - offset < length && bytesRead != -1) {
Should we only validate if there is a cache hit?
Maybe you could split this assertion int two?
Are muting/unmuting video here?
What do you think about renaming this method to simple close?
This should be an IllegalStateException.
Style-nit: We avoid curly braces on single statements.
most -> must
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
weight is missing from toString()
Add .omitNullValues() before the toString() call
@ILikeToNguyen Why the change in visibility here?
Overriding is quiet hard now that the method is private ;-)
Why debug? if i run the app not in debug mode, it's ok i don't see anything in this case?
I suggest to drop this conditional, type cannot be null (unless I'm wrong :-)
I think this should be reverted, so it would still take into account additions from pre-TransientActionFactory implementations.
what about changing TypeExtractor to be a CDI managed bean? so it could be specialized -- extensible
This doesn't look right. Should be:  result = services.get(result.getId(), k -> this.serviceRegistry.findServiceById(id, clazz));  Also, don't forget to check the result to make sure it's has the correct type based on clazz
Another way to do this:  @Nullable final Task result = Iterables.getFirst(_queue); if (result == null) { throw new IllegalStateException("Some useful message here"); }
selectedElement for better readability
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
To me it is not clear, what exception can be propagated to this try catch. Jira says open invalid content == open some non empty content. So when I check transform implementation, I guess we speak about DMNClientDiagramServiceImpl.doTransformation where we have one try catch block wrapping all the code and handling all errors via, callback. Am I missing something?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
This shouldn't declare throws Exception.
Is this correct?
This needs to be changed to return the long value.
Use Guava hashCode function
Move to update please. < layout
code style: "0.0" instead of "0d"
Please only use asyncAdmin for async operations, like createTableAsync. All synchronous operations should remain as they were before.
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
Method could be compacted to one-liner using computeIfAbsent.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
why not [0..length)
We're on Java 8, so: IntStream.range(start, start+length).toArray()
I'm not convinced by all these _URN suffix. An urn is basically a string. And any IDE can tell you its type if really necessary. I'd remove them all.
Careful. This imply face culling must be enabled. We need an additional state change in this list.
This is really really nice!
Here, you must return getRetryAnalyzer().getClass()
Could you at least make this return a non-null value?
There's no concatDeep, I guess..? ;-)
suggestion LOGGER.warning("DNS multicast capability has been removed from Jenkins.");
suggestion this.install.classList.remove(DISABLED_CLASS);
is there a reason why this method isn't implemented?
Since this block is used twice, perhaps pull it into a private method?
it is not obvious. thx
It should be just an info, since end-user difinatelly can decide to disable asyncExecutor
I don't think it is right to return always return true for two different AuthorizationContext instances.
Why not just do this instead: return obj instanceof DueDateAmountMap && innerMap.equals(obj);
Why U don't want to consider id in equals and hashCode ?
Should this be in line with YEdit's spaces-per-tab preference?
How should this handle when a streamName or partitionId does not exist in the manager?
@tfesenko Does your "1" hear assume that the line delimiter will be LF? I'll test a CRLF scenario in QA.
no need to break lines here?
This also Postgres data type. Let's refer to this doc (<LINK_0> for Clickhouse.
Minor: There's a null check for schedule, but not for criteria.
Don't we have to say that this is uniqueId JDBC?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
If you have to cast here then you probably should have casted when reading the value from the data array.
This needs to be changed to return the long value.
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
seems like synchonized is not needed here, given increment/decrement already protect
I think lowercase l should also be considered
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
Let's withhold this change. Both Ignite.active() and IgniteCluster.active() are deprecated. So it's OK for one to map to the former. If there's a warning inside IgniteCluster.active(), it's even better that way.
Why we should change behavior for the deprecated method?
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
What do you mean remove is overridden? I was fairly sure the following would work: java public void remove(K key) { heads.writeLock().lock(); try { heads.remove(key).close(); } finally { heads.writeLock().unlock(); } }
We shouldn't have any LDAP-specific code outside of the LdapGroupBackend.
It's better to use #isLegal because that sends an IllegalArgumentException. Also, it is more elegant to first check the argument and then execute the code. That gets rid of the 'if'.
Consider ordering this up one method to group public methods.
Should null check, anytime you encounter a boxed value you always have to null check.
Several things here... First, the condition you're using is slightly wrong: a big decimal may not be normalized, in which case its "unscaled value" may end with zeros, in which case it might not require rounding after all. For example 12.34 may be represented as 123400 with scale 4. With a decimalScale of 2, value.scale() > decimalScale, which would trigger the warning despite the fact the resulting number after applying the scale, 1234.00, does not require any rounding. You really want to use value.stripTrailingZeros().scale() > decimalScale. Second, I don't think you should issue a warning when rounding. At best a trace, but only if you really want to (and please guard the computation with if ( log.isTrace() )). Rounding big decimals is really not a problem; it's even a valid use case. The user may want very high precision in the database, but he might not care as much in the index. Third, there's another problem, much more important in my opinion: values that are too precise to fit in a long after scaling will not be rounded, they will just be completely wrong. I don't know how Elasticsearch behaves, but I think that, if it doesn't fail, we should throw an exception on our side when that happen. For example try to index new BigDecimal(String.valueOf( Long.MAX_VALUE ) + "345") with a decimalScale of 0, or even -2, and watch all hell break loose.
let's just use m_inferPartitioning != value.
+static
Would we want to set locFound = false in the endElement() method, for we get </loc>? Maybe it doesn't matter...
I guess it would be nicer to just return the single instances that we know from FunctionType.MIN, FunctionType.COUNT here etc...
It is weird that getCurrentHttpClient() does not return a client actually.
Type casting should be avoided and seems indicative of a problem with the model. Why are you not passing the configuration via the constructor?.
If user have used our listener in most common way (ethereum.addListener(new EthereumListenerAdapter(){})) he will get strange exception here, I guess.
The chance of creating a row is high, why don't we just create the builder at the beginning? if (lastResponseProcessed) { // illegal state exception ??? } RowMerger builder = new RowMerger();
Why don't you instantiate the builder here?
>.replace(" ", "") [](start = 133, length = 17) Why do you need this? That's a constant defined in the code. Why are you trying to remove spaces? Just remove spaces, if any, from the declared constant value.
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
cleal ?
- [x] Why need this? Please re-consider based #768.
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The idea being that perhaps the superclass would be able to do something useful (for example, look for a suitable reference and try again). So, let's remove this null check and see how that works.
What is about the null's here?
Is this error message only supposed to be added for ACBs? I could definitely be missing some larger context here but it looks like it might give an error for all users.
you don't need use replaceAll, because above you used normalizeJson
Please extrace the generated url into a variable before calling HttpUtil.executeUrl(), this makes debugging much easier.
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
method reference here as well -> anywhere we are calling a static method can be replaced by a method reference
nit, Collections.EMPTY_MAP?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Why is this method parameterized?
I think this whole method could be replaced with Guava Iterables.size()
use Java8 stream anyMatch() instead of this loop.
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Another place where the name should probably be updated
I think it would be better to put the result of partitionsFor in a variable, rather than asking for it twice
s/listPartitionsInfo/streamToPartitionInfoMapping
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
Should this be onReplicationPutRecord?
Should we add: Objects.requireNonNull(record)?
You don't need to have this condition as there's just a loop doing nothing if filters is empty.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Please add curly bracers here. Also please check other places, because I saw it also on more other places. You could use IDEA formatting highlights for that.
Add a new line after the @Override please :)
Should this method be public?
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
It'd be informative to mention how long we will wait in the log message.
Please use interfaces where possible.
return Collections.emptyList();
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
@xupyprmv are you sure that we should use anything related to ec2?
@cvrebert let's avoid composite names: call this var evts.
I think we should remove this for cycle or use some logger.
Second condition is unnecessary (checked in while loop below)
Don't use addFileUrls, just add to your urlList
linked hash set in case same classloader there multiple times?
Should getDataProvider() only be called once in the method? And should itemIdentifier.equals() be used because it can't be null?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
A for each loop on the listeners can be used here instead.
rename to iu
I think it would be good to change the settings method name to 'hasOAuthAuthorization' to clarify the broader scope.
thanks for being so thorough!
Static import
The result of this call is unused. I don't think it should be here.
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
Could just use Arrays.fill(max_byte_arr, (byte) 0xff); here
You use underscore in numeric constant above, but not here. Let's be consistent!
Could you explain the contract here in a docstring? If two arrays are different lengths why are they equal if they have the same content up to the length of the smaller array?
This if is useless, if you remove it you will get the exact same behaviour.
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
somehow that message is now deleted. New link - <LINK_0>!topic/druid-user/bd9dXKcJ8tg
why not list.stream().forEach?
I think it makes sense to use builder and return ImmutableSet...
This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value lio essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call this.unsubscribe() on L101.
as with the others, need to "remember" the first via, not the last.
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Can this be private, or is there another use case for default attribute outside the builder's call?
Don't also print stack trace, log.error will already print it. Also other instances below.
Can we log chargeId/ChargeEventId ?
Why propagate and not simply Thread.currentThread().interrupt()
all these methods can be private
Here we should return Polygon or MultiPolygon or create two implementations?
It also seems to affect the mail sharing option, when I try to open the ZIP in my mail client (Thunderbird) it opens it with a text editor rather than the archive tool. Looking at the mail source shows a type of application/xml for the ZIP attachment:  ------NBUC58F9SIXAUMV2UF11EAMGBWUN0X Content-Type: application/xml; name="2017-07-16_11-40-37.zip" Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename="2017-07-16_11-40-37.zip"; size=-1 UEsDBBQACAgIACFd8EoAAAAAAAAAAAAAAAAXAAAAMjAxNy0wNy0xNl8xMS00MC0zNy5ncHi91ttu 2yAYAODr9imY723AxqfIcVVt2m5arVIzqVpVTcyhDosDEaaLH2BPskfbkwzsTq2d5tBK81UI/vn5 wBycnTWrCvxkquZSTB3sIQcwUcg5F+XU+TL76CYOOMtPs3LdABMq6qmz0Ho9gXCz2XharmWp6D1v ...
dbf.getEntityManager().merge(ref);
This also changes the logic not only readability??
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
Can be rewritten as Assertions.assertThat(utilities.getValueList(column)).isEmpty()
Maybe also here we could use MessageFormat as we pass twice column.getBoundName()
I recommend using ITypeConstraint instead of TypeConstraint here. The latter is only for enumerable type constaints (I know, super misleading legacy name), and does not include TypeFilterConstraints that correspond to non-enumerable IInputKeys (such as java Class type filters or unscoped EClass type filters).
Use Logger.
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
duplicate regex as above, can we reuse it?
Please follow the style guide in CONTRIBUTING.md to add this to field access. You can turn on > save action .
Shouldn't we rather throw UnsupportedOperationException() in this case? Or rather create interface without the support and extend it with interface with these methods?
This is not really a deprecation, right? We're changing the behavior (ignoring the setting and advising them to use the requires-reply). I think I'm ok with that, but maybe we should log a WARN and refer them to the migration guide???
do we need any content in this constructor at all?
Why not use badges = getBadges(userId); here? I think that's more clear than a call to a void method where you have to read through the whole method to understand the side effects.
@jjl014 User id is optional, unlike client id and session id, which are required for user info
Are we sure newValue is always non null?
Use Essentials' user.isAuthorized for permissions lookups - this uses EssentialsX's perms handling code.
This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item.
it will have a bad result if the cronTaskConfigurations == null and someone will do getCronTaskConfigurations().add(configuration). probably it will be better to do it like this:  return cronTaskConfigurations != null ? cronTaskConfigurations : cronTaskConfigurations = new LinkedHashSet<>();
Avoid logic in this class. This is inconsistent with other collection fields. You can't do an update with this field set to null. Also, why a tree set?
Make sure to return a read-only version of the List (not set) here. We don't want people to think this is the method to register interceptors.
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
Can this be private, or is there another use case for default attribute outside the builder's call?
Do we have to serialize the state in Operator? I think the caller class would be a better place to serialize it.
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
Change to StringUtils.isBlank?
same as for AddAddress here
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
I think in this class it is possible.
This block is common to all tests in this class and could be extracted to a private method, parameterizing the name of the process
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
I would add more detailed information about the sample here:  if (ioSample != null) { parameters.put("Number of samples", HexUtils.prettyHexString(HexUtils.integerToHexString(1, 1))); // There is always 1 sample. parameters.put("Digital channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getDigitalMask(), 2))); parameters.put("Analog channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogMask(), 2))); for (int i = 0; i < 16; i++) { if (ioSample.hasDigitalValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " digital value", ioSample.getDigitalValue(IOLine.getDIO(i)).getName()); } for (int i = 0; i < 6; i++) { if (ioSample.hasAnalogValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " analog value", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogValue(IOLine.getDIO(i)), 2))); } } else if (rfData != null) parameters.put("RF data", HexUtils.prettyHexString(HexUtils.byteArrayToHexString(rfData)));
I would call them attributes because that's how they are referred to in the XML / HTML world.
nit: space after 'if'
Maybe make this a static final List now that is is used two places? (here and line 123).
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
Might give this a shot, if the type parser is indeed fixed?
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
reuse method I proposed to introduce above
also not used I guess
There should be an else clause which adds an error to the bindingResult, so that afterwards in the setServerSettings method we don't overwrite things with null (or get NPE).
Why do we need this? How is this different from "lastImportedFormId"?
This must be wrong... :P
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Shall initialise using newArrayList(txnId) instead of 2 statements.
nit: name = tableName or this.name = name
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
super() can be spared here.
No need to call super() since it currently doesn't extend anything.
Same here. See above
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
you could just do setConfirmWindow(null); like above method
Same concern as above.
I'm a bit concerned about this change in behaviour. We have two possible cases here: 1. the parent is null; I agree in this case that we could avoid copying the Set, still, the copy was preventing illegal changes on the collection once it's given to the invoker. How about returning an UnmodifiableSet instance? 2. the parent is not null: this is possible in case the ResteasyProviderFactoryImpl is created with an explicit parent and local = false. To be on the safe side, I believe we should keep on merging the two collections. Alternatively, we need to either investigate and exclude the scenario or think about a more complex optimization. WDYT?
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
nit: don't need this return false; line
switch statement missing default case
please add populate() call before addLinks()
These checks should happen within the build function when delegated to the object they are building, not a builder's set function. Don't duplicate the logic.
Is there right message? Because this one is same like for UserSyncFailed.java event.
I think Local.ROOT is probably a better choice.
docPossibleAncestors and revPossibleAncestors?
containsKey?
@fanifieiev RequestOf is a better name than RqOf.
@dalifreire making a static method is a workaround not a solution. Here you could store the stream as a field and create Channel in requests method and pass the created variable to copy and make.
@westonized the task says: "Evict cache entry if If-Modified-Since request responded with HTTP_OK code and no Last-Modified header". This would suggest that we should have if with these two conditions somewhere... Where it is?
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
Just due to previous version, thinking if this is more effective: java if (hasExpression.isClearSupported()) { return Collections.singletonList(ListSelectorTextItem .build(translationService.format(DMNEditorConstants.ExpressionEditor_Clear), true, () -> { cellEditorControls.hide(); clearExpressionType(); })); } return Collections.emptyList();  let me know what do you think please.
we can replace that with findAny/findFirst as we don't really need to know those vms
but there's no reason to change this method now, no?
Please add here this(vds, null); and move rest of the code into 2nd constructor. Using this approach we can get rid of FindBugs error.
Should this include all the other fields a well?
This implementation does not seem useful, as there may be dozens of those. I would print the number of events and that's it.
Could we use a simple string concat here instead? this avoids unnecessary goggle common dependencies.
nit <LINK_0> (which I think we use unless I'm mistaken) has 100char line wraps. It is easier to read when we don't wrap so often
This method can be static, as all the methods it calls.
Should this check Collection as that is the super type for List and will capture Set, Queue, etc.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
use ShellIsAvailable
use ShellIsAvailable
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Remove "()", (input) ==> input
these arrays could be static finals. That would save allocating new ones all the time.
why is this necessary?
Shall we change this to "Unable to resolve the hostname of the ....". there are few other places as well with same error message.
Is there any purpose to remove temporary workspaces on shutdown if you do it on boostrap? It looks like they should removed either on shutdown or on bootstrap.
Either catch NPE only or add Exceptions.propagateIfFatal.
This should not use the --metadata parameter since that is used for object metadata. We should probably use a different parameter like, --datapolicy-id or something like that.
Use a guard method here
So we are limiting them to specifying a single object?
return Collections.emptyList();
you can use Collections.EMPTY_LIST
Use unmodifiableSet() instead?
Please add ? and % as well
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
Isn't it also important that adType was async and method was top?
trivial: you can remove the isDebugEnabled wrapper
As for me, brokerConfig variable name would be simpler here
nit: you can merge both lines above as checkNotNull will return the given argument
We probably should log and rethrow this exception, correct?
Seems like a Map<String, String>would do so we do not need to do the casting
We should probably not swallow this exception. We can log and rethrow.
When does this happen?
The column order is correct, when Gerrit site was created before 2.6. We could always perform dry-run mode of PrimaryKeyFix step, detect if the site suffers from wrong PK column order problem, list the tables for which the PKs must be fixed and run in non dry-run mode or just silently exit otherwise, e. g.: Collection<String> wrongPKColumnOrderTables = fix.dryRun(); if (!wrongPKColumnOrderTables.isEmpty()) { if (ui.yesno(true, "Fix primary keys column order for tables: " + wrongPKColumnOrderTables)) { fix.run(); } } This way we would avoid unnecessary noice.
Maybe the method could be named in a way that doesn't mention implementation details, like startRename or something?
I think we should use expireAfterWrite instead of expireAfterAccess here to ensure that we don't cache these objects for any longer than the configured time - the node details may change.
Why do you not rename your extracted method's parameters appropriately?
This is convenient API, but I worry that this obscures the configuration properties outside of code... like if one is manually editing the config file or using the shell to set properties... the code doesn't match the literal property names people use elsewhere. I think a better implementation is to stop requiring properties to be prefixed with "general.custom" and allowing them to have any arbitrary property name in our config. Then, we just let SPI implementations do whatever they want for their property names.
LZ4FastDecompressor requires the size of the uncompressed data as the last argument to decompress, vs. LZ4SafeDecompressor requires the maximum size of the output as the last argument, so we should only use lz4Fast if we know the size of the uncompressed data, which is not the case in this method.
Is it fine with logging instead of rethrowing?
First of all, thanks for the PR ! I only have one issue I would like to address. This results in consuming the entire InputStream which could be large and chunked. This would be a problem if someone was using Unriest to download a large payload. What would be better would be to leverage available() on the original InputStream. this method: > Returns an estimate of the number of bytes that can be read (or skipped over) from this input stream without blocking, which may be 0, or 0 when end of stream is detected.
There's a Map-specific assertion class:  assertThat(results.get(0)).containsEntry("name", "eric");
Why does this need @SuppressWarnings?
Could also assert that it is the solr alert here.
Doesn't this duplicate the nonNull check?
Doesn't this duplicate the nonNull check?
Doesn't this duplicate the nonNull check?
Typo here. should be service_type
This is the only relevant one:)
I'd replace Of with For
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
Rather than returning null, return the props object just without the properties populated. I realize you probably didn't write this, but it would be a good change to make regardless.
can try with resources be used here?
inline please
don't use expectedConditions. Instead use waits from BasePageObject
there is no need to wait here?
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Collections.emptySet() should be all that is required here, no generic.
Looks ugly and potentially a source of future NPEs.
Again, I'd go with asList and a static import.
default is true
just return m_closed.
Probably it should just return false
Nitpicking this change here - isn't this antipattern?
can we also have a test that validates the case when we have a none-string field in span_ctx? (Validation should fail in this case)
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
You can remove these 2 lines, and use createBuilder(new CalendarSerializer())
?????
Should use the log, maybe a warning.
:astonished:
add block
+1 for clear cache... especially since that does proper synchronization
minor: do you need the super qualifier here?
I'm not sure we want to expose this. With Joey's work to add types to datasets, I thought we'd get rid of the type passing and do all of this internally.
Does this sound good? 'Create a new aggregating set expression using a backing TreeSet using the given comparator'
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Can we point users to some kind of regex about how to specify these options, or what the valid values are? I don't entirely understand the format based on the docs and usage string here.
please use StringFormat and %n instead of \n, so we're less platform dependent.
You don't need to insert into create_time and update_time. They'll be populated with default values.
No need for super()
calling super not needed
Use clone or Arrays.copyOf.
Again, use IOUtils.
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
can we use BeforeClass annotation?
Collections.singletonList
Collections.singletonList
Collections.singletonList
Nipick: can we follow Java conventions of beginning variable names with a lower case? We also don't typically prefix variables with type information, though I guess that's not a big deal if you want to leave it as is.
I would delete this synchronized block. Values cannot be modified while we're reading it since we already saw state as 2. It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that.
This assumes portNumbers is not null but other parts of the code do that check prior to use.
!showButtons
java this.onPostServerTick(this.getMinecraftServerInstance());
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
would this be called often, and would the list copy be expensive?
File
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Just "groupName".
Looking at other HandlerUtil.getVariable() calls, the usual logic is to look for an instance of what you were looking for (in this case Boolean) and to treat any other situation as if null was provided. This would remove the need to check for Boolean in checkForCompositeRename and having code to issue an error log message which should never occur.
How about return getSelectedNodes(event).stream() .map(e -> e.getRepository().getDirectory()) .collect(Collectors.toList());
refreshJob field should also be set to null on dispose.
we should probably call EcoreHelper.unregisterEcore on dispose, shouldn't we?
You'd probably dispose your stuff, and call super.dispose() at the end.
Can you use azkaban.utils.Props#getUri(java.lang.String, java.net.URI) directly? e.g. getUri(AZKABAN_STORAGE_ORIGIN_DEPENDENCY_ROOT_URI, null)
I wonder if the default could just be stored as a constant inside of RouterConfig, instead of having to construct properties objects in all of these places.
Should the string be "Password" with capital letter "P" ?
Do you get any compiler or pmd error if you remove the line that throws the exception? I get wanting to make the default constructor private, but it would be cleaner if the method were simply empty.
Why the change to AssertionError?
Typical message here is just "No instances."
I think that deathdateEstimated was only added in 1.11.x, it should not be known in the context of 1.10.x compatibility.
Aren't the name and description properties already added by the super class?
id is not creatable
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
directly say return FileSystem.get(configuration);
Can we use try-with-resources here?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
@xpdavid is this the right thing to do?
Can this be private, or is there another use case for default attribute outside the builder's call?
why would that throw a storage exception? It's not trying to store anythign.
Null is "expected" here, so suggested to check for it explicitly, rather than operate via exception handling, that is an antipattern in java
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
this.
one more method where it can take file location of properties would be good.
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
use the constant defined earlier (moreover, aren't jdo connection options available from some sort of options class)
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Can this be private, or is there another use case for default attribute outside the builder's call?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
I wouldn't fix this in the same PR. Probably a separate PR for this fix would be better. It's not related to this change.
Do same for this one
other than the previous implementation in subclasses this doesn't create the directory anymore.
Check for the existence of the file to delete?
return true? no need to inform the user he sent wrong vm (vm doesnt exist), or other issues?
Why is stopScan() required here? The call to scanLeDevice(false) will call it.
if credentials is null should not execute mocked push
This else branch does not have any code in it. could it be that you just used it for debugging purposes? If you are not doing anything except for logging the fact that the deviceController was null you might as well remove the else completely (not that you get me wrong: this doesn't mean you should remove the null check - unless you have a look into it to find out if you really need it. )
not working for null input
remove unnecessary checks
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
Make this job delete or disable it self after it has completed running. I believe its a one time Job
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Can header name and value be null?
This constructor should call the more general one with a default value (3 in this case)
add non null validation
This logic is not correct since it would stop at the first '\r' in "// blah \r blah \r\n".
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
nextLong could return a negative, right?
what about !selection.isEmpty() instead of selection.size() >= 1?
Could you at least make this return a non-null value?
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
I would also include [CollectionUtils.isNotEmpty()](<LINK_0>, as it's also a null-safe check, with following method yields in case of false result : - result is false, arg0 is null; - result is false, arg0 is not-null ( and empty ) - result is true, arg0 is not-null (and not-empty)
Does this not always return false since this is called from a div node not a style node?
inspection is the only client of this method, move the method to inspection
Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)
I think you should evaluate the response after the exchange has exited the route, that happens when the callback function is called. If you call it soon after pushing the message, the exchange may not be completed.
This should be !exchange.isResponseStarted(), the response content length does not really tell you anything, a lot of requests use chunked encoding which will not set it.
Type : stroes instead of stores.
I would prefer that you use an explicit encoding rather than null which is the platform default. Even ASCII would be a better choice than null.
please remove unsed code
Let's avoid changes in the classes not directly targeted by this pull request.
You can use StringUtils from the commons.lang3?
How about "Type is not supported"?
It looks like these two exceptions can be combined into one. I don't believe that you need to call out the specific exception since it will print the stack trace for the exception.
changing "final ... result = .... ; return result" code to just "return ..." isn't a change I'm keen on as it then makes debugging harder - you can't set a breakpoint and see what the returned result will be.
Could you check for null or empty? Via StringUtils.isBlank
Please remove redundant type information in another follow up commit
Would be a tad simpler to do: for (List<ITmfEvent> list : tbl.values()) { count += list.size(); }
This if statement is not necessary as the while loop below would handle the negative case.
public
Maybe it would be better if you add enum value SourceCode.CONSTITUTIONAL_TRIBUNAL and use it in here.
J) the same suggestion about using filter concept
Why leave the burden of capturing the exception to the user?
context.getEntityType().equals(EntityType.FEED.name()) should do.
just use context as sync obj.
Can we use BinaryUtils#resolveClass instead of making this method public?
I think, it's better to transfer a method parameters and keep a name at a previous position.
Using newIllegalStateException() which can format a string would make the above code more compact.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
This thing does check the value for not being null. So the previous expression is redundant.
This was already a problem with this in the old code, but the parameter name strings and values are mismatched here.
Can we please add limit to the exception message? So it will be much easier to see the problem!
You may want to say something like "Items per page limit cannot be..."
Can remove the first clause if you change maxWriteSize to Integer.MAX_VALUE
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
If quality is an int, we don't need the check.
I don't like the word "command" in "where the WES command should run". If anything, you're sort of running the (client) command on your local box. How about The URL of the WES server, e.g., ..... Also, I think you should say URL, just to be consistent with --wes-url; right now it's a mixture of url and URI.
This should have been:  this.out.close();
Perhaps add further information to this exception
For easier maintainability in the future, I suggest having curly braces for this if condition.
final
boolean is never null. Please find a user where it is true.
Please use a 2-space indent and braces around the throws block.
I think it would be more readeable if you would return here DbUser instead of setting the private user attribute, in method which has "get" prefix. Could be confusing. Then pass the DBUser to userDbIsSet method.
missed one
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
Remove the InterruptedException from the signature.
please keep the buildVmNumaProperties a void method and access the vdsId fron inside
Did you intend on nesting the code block in a paragraph block? If so the method name should be changed to indicate what this test is about.
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
I think this should be > 0 since a value list item of 1=One does not work.
This will produce a Number Constructor FindBugs warning. Please use Integer.valueOf(0)
"else if" maybe?
Change log level to debug
Change log level to debug
Shouldn't we include just the SSLDs? Otherwise, if there are Kaifa smart meters in a system, we would be contacting those for their events as well.
keep this the same
Same here, but check the max cook time instead.
No, you're not supposed to change the flying state, only whether they can toggle flight.
JDBC
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
Check for overriding is uncessary.
You shouldn't create struct literal at this place. Because method name is getData and it's called in isAviable
element can be invalid at this point. Also you don't check what element it is. E.g. in case of batch inspection mode that was run on injected text, you'll get a file here as an element, I don't think you want to replace file with ""
You could maybe use enclosingClass to save a few hops...
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Can you add getId() and mark id() as deprecated?
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Now that you're encoding the ID are you missing decoding it somewhere? I don't see it anywhere
Please use MantaClient.SEPERATOR and do not hardcode slashes.
Why is this wrapped in an ArrayList? same in the one below.
Small thing - I think it's better to do: List<String> result = new ArrayList<String>(allLocales); because with original code: List<String> result = allLocales; any modification of "result" will also modify "allLocales" input parameter. In other words, are we OK with modifying method input parameters? (I'd rather avoid this.)
This method causes several build warning.
Can have a isRef(Expression) and isLit(Expr)
JDBC
do the comparison the other way around
please decrease severity to "debug"
minor: since this one is not under a lock, could you use AtomicBoolean and compareAndSet()?
your other PR made a change to this function (to account for stopped replicas too) - does this change in the if still hold? (I think it should)
Can we add a throws declaration to an existing public API, even if it's deprecated? We just reverted a change [1] because adding throws broke backwards compatibility. [1] <LINK_0>
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
avoid using \n, I remember windows contributors having tests failing because of such usage.
minor: can be final
Yes, or unbox a NonFatalException in the default toCompletableFuture impl. Unboxing it is perfectly ok because there is no public API that allows a call-site to construct a NonFatalException outside of a Try. Please find the suggested impl above...
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
For loop?
int[] props would make everyone including the style checker much happier
one param per line; leave the first line empty
Can we log the debug message in one line? Those multiline messages could be interleaved with multiple processes.
You might want to not over-complicate it and keep the toString of the Optional perhaps?
ArrayList (and HashSet for example) have a constructor taking a collection. You could just write return new ArrayList<>(LOMBOK_ANNOTATIONS);
Small style nit: We don't use braces around simple statements.
You probably could directly do  Collection<RuleTemplate> toReturn = new LinkedList<RuleTemplate>(values);
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Why not create the taskExecutionDAoFactoryBean in the ctor?
@xpdavid is this the right thing to do?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Can this be private, or is there another use case for default attribute outside the builder's call?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
Please make the constructor private (see Invalid).
are these setters used anywhere?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
You should grab and store the terminationReason in a local variable, since in general a volatile field could change from one read to another.
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
I like this approach putting current status in exception message may be useful for debugging if it ever occurs
Tests should never suppress exception but rather propagate them or use an ExpectedException rule.
this method could be private
Now that this is not a part of the original method anymore, it makes even more sense to not unwrap the original exception in order to not lose the whole trace leading not only to the executor thread but also to this finishAllThreads method. I think my original attempt to make the stack trace shorter has the potential of reducing clarity rather than improving it (in other words, I did a stupid thing originally).
The constructor should be made protected so that users can easily make a wrapper for it.
Should we check if the Kiji table actually exists at this point, so that users don't have to wait until a job launches to discover they specified a non-existent table?
Why protected if the class is final?
public?
I'm missing the new field in the toString method.
Can this be private, or is there another use case for default attribute outside the builder's call?
I really think we should go to the bottom of this and understand why this does not resolve in the first place
imageio-daemon cannot be configured to use http, so I don't think we need this option. We can add later http support if we have a requirement.
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
You don't need a transaction here
I think its better to if (isCopyPerms()) { execInTX -> save quota copy perms } else { save quota } and remove the check for isCopy... in copyQuota method
Why a new transaction is needed here?
This is super silly. Never do this and read about java string pool. Just hit java string pool in google and you will see a lot of articles.
should be static - please fix when you rebase
please don't rely on InternalObjectNode for the new tests. we want to move away the end users to use ObjectNode instead and these tests may get used as samples. Please either use a pojo or use ObjectNode.
delete() should be executed from within the future so it doesn't through right away.
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
You are missing some variables here. I wonder if we should make a common method for configuring these so if we add any more 'with' methods that they can just invoke the proper method instead of adding each of these lines.
Why not call put in this class for atomacy?
Should only be for the provided keys?
Use one pattern consistently: Either model all sync calls as asyncCall.get() or Model all aysnc-calls as sync call + CompletableFuture.completedFuture(null) I'd prefer making async the more general API and expressing the sync-variant in terms of the async one
The local var is useless, you can remove it.
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
nit: create static variable for this empty set and return that static variable
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
Add the original ClassNotFoundException as cause.
("could not instantiate \""+className+"\" from conf property "+CLASS_CONF_KEY, e)
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
delegate=true style would be just fine.
nit: I think parenthesis are a little more conventional.
And this change should be reverted as well.
Uses the varargs version
What is the reason for not including preferredHeight and preferredFps here? Looking at BitrateController#setVideoConstraints, I think it might fail to call update if the only thing that changed is the preferred height or FPS. Or is this on purpose?
You could probably use the same URL as in getResultById here.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
Ummmm, my memory does not check out this time :\
Program to interface, not to implementation - please change return type to Map<String, Object>
return getView();
Technically it's the connector (jr://file vs. jr://file-csv) that differentiates between the two. I think this is ok, though.
You could remove the braces around the first check.
How about narrowing it to ClassNotFoundException and fail with other exceptions?
You should do return true at the end of the method.
wonder if it would not be more interesting to have false here to see that we are correctly jumping into the catch.
else if?
Why not throw an exception here if we didn't get the right cache?
Why not throw a NuxeoException here?
You can move all of this into getRadioGroupPanel, and return the FlowPanel. Or you can also do what I explained in the DiskContentRadioGroup and extend FlowPanel and simplify a bunch of this stuff.
This color resource leaks. It should be disposed when the dialog is disposed. You could add a dispose listener on the label.
Hmm, I know we do not have anything better, but how hard would it be to create a bulk update call?
Same as above, why not use try with resources?
Can we invert this, so GET and HEAD are allowed, everything else is denied, prevents accidentally opening up anything else?
suggestion
This is strange.
Should this method be private or protected?
Just as an alternative path using a mock:  MqttConnectionObserver connectionObserver = mock(MqttConnectionObserver.class); a.addConnectionObserver(connectionObserver); verify(connectionObserver).setConnected(false);  wdyt?
Use the solution in the large Overall/Manage PR instead, please.
Use getRequiredPermission, for ease of change if a specific permission is later added.
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
Use create instead.
Don't use intern. Use create instead. Intern pins the string in memory forever. If its a constant declared in code, that is fine. However for dynamic data like a branch name that would be bad, as the memory would almost never get released.
How about adding "java = undefined; javax = undefined; Java = undefined; load = undefined; redpenToBeBound = undefined;"); to this section, instead of introducing appllySandbox method and UnconfinedScript?
@dalifreire let's get rid once time used variable
We shouldn't ignore an invalid enum value.
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
perhaps, verify that node is a ValuesNode  verify(node instanceof ValuesNode, "Unexpected node type: " + node.getClass().getSimpleName());
The reason setProperties is called whether or not the the node entity is in the mapping context is because when you reload the entity from the graph, we always update properties. This fix indicates that it will no longer be the case. Unfortunately we appear to be missing a test for this, will push one shortly to demo the issue
Instead of convert it back/forth, probably just update canonicalizeSetOperationVariableMap to return Map<VariableReferenceExpression, List<VariableReferenceExpression>>?
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
why do you need to clear sortedSessionSet and add chsenSessions again ?
Maybe it would be better to throw org.eclipse.che.inject.ConfigurationException here
Needs some sort of assert to show it succeeded
@cyberone no need for Mockito.times(1)
Empty catch again? :) AssertJ or suppress will work better for us I think.
I'm not sure silent catch is good as after that url is null and it will create exceptions
Let's indicate to user that it's OpenShift project not Che: Deleting OpenShift project... or "Deleting project [project name]..."
use ternary operator
just for consistency, can we use final int?
Shouldn't you reset the interrupt flag after catching this?
Might give this a shot, if the type parser is indeed fixed?
this cast could be avoided thanks to the changes on generics on MultiIterator
Met List:  @Override public boolean inputIsConnected(int index) { return index < inputs.size() && inputs.get(index).isFullyConnected(); }
shouldn't it be- (index +1) % numberOfMacsInRange ?
the status in the message is now wrong (as you check more statuses), let's put the domain status.
please replace those lines with call to the method you added..
please put the correct status.
Use Objects.equals() to handle nulls concisely.
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
throws
throws
nit: throws for consistency and clarity.
rename to advice or brandingAdvice
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
could this lock prevent a node being shutdown or take longer to be shutdown?
Can we log the debug message in one line? Those multiline messages could be interleaved with multiple processes.
blank line
no need to check, simply set it to OFFLINE
Maybe check for if name ends with ':' so we don't do a double one?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
what else? any warning or exception should be there?
This method is useful in some cases, but I don't think that we should make this public API. Without proper lock, this method does not guarantee anything.
Can this still pass if the file is empty or corrupted?
here the implementation is strange cause this will return true (meaning the resource exists) after a call to delete, cause the isDeleted will be true ???? Why not do ? return resource.exists();
This is check in the overriden enqueue method. I think this check is extra here.
This check is extra
nit: I would reorder these methods. registerLifespanCompletionCallback -> setNoMorePagesForLifespan -> isFinishedForLifespan. (here in all other classes) setNoMorePagesForLifespan -> isFinishedForLifespan happens one after the other, so it is easier to read if they are together. And registerLifespanCompletionCallback happens before this two, and even before enqueue. So maybe it even makes sense to move registerLifespanCompletionCallback before the enqueue.
perhaps if not has permission?
The stacktrace here is pretty boring. Therefore it was left out intentionally (although due to the missing placeholder still wrong). It would have been nice though to let the user know what exactly was the value that wasn't so great: java logger.warn("Could not set new location {}, keeping old one: {}", location, e.getMessage());
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
This looks like a copy/paste typo maybe?
Should we keep a reference to the Bundle here?
"isSearching" should be a class level string
indentation is a bit off here
Re-use temp file
Use String format
Might as well add a comma
missing @Override declaration.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Please use lowercase as it refers to the argument: disposables is null.
disposables is null
disposable is null
I don't know if we should set a default key. We might want to require the user to generate something unique to their service.
probably best to use getIntInRange() here too to avoid negatives (I think I didn't know that the function existed when I first wrote this).
Write 20971520 as 20_1024_1024. Ideally, Default annotation would support this approach too, but I know we don't have that yet.
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
Perhaps try-with-resources? Needs care with the disposePassword.
Perhaps try-with-resources? I need to understand suppressed exceptions ...
should this have a ,  to match the rest of the pattern?
VertexInfo vs NodeTopologyEntity.
Oh yuck. ;)
To avoid old items from killing new ones, lets verify its the same reference coming back in the cache first: ObjectId key = ((LoaderRef) ref).key; if (classLoaderCache.get(key) == ref) { classLoaderCache.remove(key); }
Introduce local field for entityManager.getEventSystem()
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
entryId is not used, please remove
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
just remove the fileSize from here... and that's the only change you will need.
no need for explicitly using 'this'
minor: this not required anywhere.
there is no need to set the value for the object id
please move the isEmpty methods to the scimSchema
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
Mann knnte das auch ohne "username" machen:  java if(...) return authentication.getName(); return "...";
Might be worth having a displayName?
Nice2have: make it localizable
Should this be "Upstream Committers"? Also, it might be good to move this to a Messages.properties file so it can be translated.
I think this should be stripe_account_id ? as per PP-4302
Let's change the signature to ImmutableMap as well, please.
If it is not indended to use from the outer world then make it private or protected.
please use baseActivityTestRule.launchActivity() (without the "null")
Should be added the Override annotation.
errors can keep final, and instead of attribute emptyList here, you can call List.clear() method.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
When you bind here, you can hold a reference to the service so that this can be non-static. Also I'm not sure all the static access to the service is needed (regarding MigrationDownloadServiceBinder), you can check how is done here <LINK_0>
suggestion return getChannel(context) != null;
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
I'll check later, but should this be doesUserHaveCollectionAccess?
in what case they are not equal ?
I think we can reuse GWTDateConverter java static String format(final Date value) { return GWTDateConverter.getInstance().format(value); }
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's a formatting issue.
Unneeded change. This only used in RegexPathPredicateTest, that is in the same package.
Let's use seleniumWebDriverHelper here
It's better to rewrite the code to use SeleniumWebDriverHelper class.
It's better to rewrite the code to use SeleniumWebDriverHelper class.
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void bitreserveClientWithTokenShouldSetTokenAndRestAdapter
Why uppercase _INSTANCE_? Is there a convention for this?
Use isZKLogAvailable() instead
@chaviw you can skip the check for null. If fragment is null then the instanceof check will also fail.
please move list initialization to where it is used.
There maybe no need for this variable here. And this may be more readable since it's a builder: java new AlertDialog.Builder(fragment.getContext()) .setTitle(R.string.unsynced_notes) .setMessage(R.string.unsynced_notes_message) .setPositiveButton(R.string.delete_notes, fragment.signOutClickListener) .setNeutralButton(R.string.visit_web_app, fragment.loadWebAppClickListener) .setNegativeButton(R.string.cancel, null) .show();  or java AlertDialog.Builder builder = new AlertDialog.Builder(fragment.getContext()) .setTitle(R.string.unsynced_notes) .setMessage(R.string.unsynced_notes_message) .setPositiveButton(R.string.delete_notes, fragment.signOutClickListener) .setNeutralButton(R.string.visit_web_app, fragment.loadWebAppClickListener) .setNegativeButton(R.string.cancel, null); builder.show();
public static? Is that keyword ordering important in this codebase?
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a final variable?
final
please, also check at least elements count
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
looks like wrong indentation, maybe you forgot to run build with qulice profile enabled?
Maybe: if (!Guid.isNullOrEmpty(imageId)) { return validateImageTransfer(imageId); } else if (getParameters().getTransferType() != TransferType.Download) { return validateCreateImage(); } return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
why this was changed here and not in the master?
please use VmTemplateHandler.BlankVmTemplateId (i guess this is what you meant..)
Ya this is some thing we can avoid
Changing the region should also invalidate the client like above.
getNonEntityNonCollectionRegions creates a copy of all the collections, let's lookup the other maps...
this can actuall be: this.causes = new ArrayList<>();
inline to its declaration.
If I understand correctly the code, as this.statsDSender = client.statsDSender; this.statsDSender is submitted to client.executor and not this.executor. <LINK_0> So <LINK_1> may not shutdown statsDSender.
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
maybe singletonMap?
return Collections.singletonMap( "serbian_stemmer", SerbianStemmerTokenFilterFactory::new );
I would prefer IllegalStateExceptions in such cases.
"your _thing handler_" doesn't make sense then, right?
This has nothing to do here. You're invoking blocking code during plugin activation and wasting this instance
Same here, helps to debug.
The logic of this is unclear, it seems redundant
This test should also verify that we save the token to Redis. (Incidentally, this makes me realize that I neglected to do the same for email verification.)
You'd still want to tear it down. How about using a straight-forward if-else ?
This if is always true and the else is a dead code because you'll get here only if getParameters().isRetryOperation(). Maybe the whole thing should be: if (context.entity.getImagedTicketId() != null) { if (getParameters().isRetryOperation()) { boolean stopSucceeded = stopImageTransferSession(context.entity); if (!stopSucceeded) { log.warn("Failed to remove transfer ticket for {}", getTransferDescription()); getParameters().setRetryOperation(false); } } else { getParameters().setRetryOperation(true); } } But this implementation will cause the stopImageTransferSession() to be called once in 20 seconds since there's no state change here. Is that what we wanted to do? Maybe the right thing is to set it to false here and set it back to true somewhere else?
This is a duplication of lines 823-833, we can extract it to a method and prevent this dup.
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
why not private? it is only used by the private method synchCTFState. I would place the new method below synchCTFState. I don't get really why the findElements() method does not what you need here. Both do a recursive search for MPartStack in areaModel. Maybe EModelServiceFindTest could be extended to check your use case?
consider making getProjectDetails return List <ProjectDetailsX>, and keeping lines 361-365 of the original file in this method. This way, we'll avoid code duplication
contains(null) case?
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
If we can't collapse a.b, the we should have a.b$c (or a.b.c) in this example, not a$b$c ?
Better throw a SkipException to see the reason why this is not executed in the test output. this will also serve as a reminder for us that this needs to be implemented.
it seems to me that if I add some operations, and then clear, the end results is to clear the map and after that apply the same operations, which would not get me the expected results. I.e.: map.put() map.clear() should give me the same result as map.clear() Shouldn't this clear() method also need a "currentState.clear(); " ? This would affect also the isEmpty() calculation.
Why isnt the reencoding happening immediately like for other messages (amqp standard, core etc) and expected behaviour, e.g. other areas of code and plugins are expecting the message to rencoded by calling this without doing extra work. I can be missing something.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
hm, how about "...".equals(intent.getAction()) or TextUtils.equals(intent.getAction(), "...")? [fyi, commit amend + force push are fine]
Since it's present in all configurations, consider moving this object creation to the top of the method to occur unconditionally.
won't there be an NPE if upServer is null?
should be : this( clusterId, volumenId, false);
Should'nt the getter name be getClusteId if the field name is clusterId?
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
please instantiate the list right above the check where it is used.
only constants are in caps, this is a local variable
please move list initialization to where it is used.
Core.ID
Personally I'd like it if these two operations were broken down into two lines for readability.  List<Metacard> metacards = Collections.singletonList(metacard); return xlsxMetacardUtility.buildSpreadSheet(metacards);
return !metacard.getTags().isEmpty();
@ge0ffrey This is not factorial, this is base ^ base
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
You could use BigInteger.ONE instead.
Overdid: if null, return null :smile: From other side it can't be null. See ctor:  Assert.notNull(inputChannel, "inputChannel must not be null");
This code block is repeated over and over (lookup, register and log...) maybe make it a static method in Disposer?
Please keep this.cell near the related fields (previousFamily & cell count) below
Also you missed similar fix in the lockInterruptibly() and tryLock()
Is this a reason to have separate if statement instead of while (!shutdown)?
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
you should account form previous page too
Add a message to checkState so that it's easier to debug if we ever hit it.
Debugging? Remove.
If I correct, we could replace this by if (cfg.isClientMode()) and remove 'client' field at all.
let's make atomicityMode() method that return TRANSACTIONAL to make life easier for the one who wants to extend this test.
why this change?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
Why was this removed?
What if type is not Class type?
weird indent (and some others @Overrides and throws)
Why did you change the modifier? If you want to change the list of bondingOptions, isn't is enough to do- 'getBondingOptions().setItems(newBondingOptions)'?
simplify this to  return getVarArgIndex() > -1;
Hmm, this seems like it would write a lot. Could we move this up a level after the multiple calls to performDexOpt?
You can just call optimize
I would consider eliminating this intermediate variable, validationResult, and just returning the result of the checkAccountingString() call directly.
Since multiple converters might resolve duplicate instances of SimpleGrantedAuthority, please change the RHS to LinkedHashSet.
rename to vmNumaList
should we swap method parametrr orders above?
static import of createRootScope, and requireActivityScope below?
Could this relatively general code be reused in the needsOrderBy method?
You can use StringUtils from the commons.lang3?
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
This method can be static, as all the methods it calls.
"Initial connection"?
unsafeSubscribe shouldn't call the ERROR_HANDLER.
nit. faster to write throw new RuntimeException(e); :)
Please add at least of project in order to check that the result is empty because it return an empty list
I would do a static import of ComponentTesting to improve readability
What about dumping the missing indices into a file ? The purpose should be creating an upgrade script - that would ease the process for the developer.
Why do you need the non primitive class check?
Do you want this to be the same RAF (no, that's not the Royal Air Force) that will be used to read events? It could be a separate, local one (which you pass as parameter to parseHeader), and then you close it before opening the "real" one that will be used for events.
we probably can use myClazz directly here, without JavaType conversion.
Doesn't this variable actually represent surroundingChunksNotLoaded ?
What do you think about simplifying this method to: java while (true) { final SoftReference<Chunk> chunkRef = chunksCache.pollLast(); if (chunkRef == null) { return new Chunk(defaultChunkSize); } final Chunk chunk = chunkRef.get(); if (chunk != null) { chunk.cursor = 0; chunk.startIndex = 0; chunk.chunkSize = chunk.keys.length; return chunk; } }
Google's Java style requires methods to be lower-camel-case. e.g. convertChunkSourcesToModules() This looks like Python code to me. :)
Can't be just assetListConsumer.accept(Collections.emptyList())?
Why is it a list of lists, not just a list?
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
maybe test first char for empty letter as well to reuse s if possible?
Do you mean s.length() > len?
"This method is not actually very useful and will likely be deprecated in the future."
> 0
Unchecked.consumer(plugin::customizeJdbi).accept(this); is the right mantra :)
Use of NLS.bind is not appropriate here. Use String.format if you prefer printf-like syntax or just concatenate strings using + operator
what is this supposed to do?
It sounded better before
assertTrue() without a message is evil
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
I still think you should throw an exception if name is null
this is redundant
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
Why have you updated this test instead of writing new one?
Should throw at construction time instead.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I'm missing the new field in the toString method.
Same here: should be Branding, not ProductBranding
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I'm missing the new field in the toString method.
This assertion should remain - when caching just Channels, there is only one connection (default). I suppose we can allow it to be set as long as they set it to 1. Will change during merge.
set up and hence should be done in constructor
Is there a reason this is package private? On a fluent builder this feels odd...
You might want to put the double-check-locking mechanism into a private getter of myAddrs to consolidate the logic in these 2 getters.
I'm missing the new field in the toString method.
Can this be private, or is there another use case for default attribute outside the builder's call?
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
combine with assignment this.outputType = requireNonNull(type, "type is required");
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
The doc needs to specify what the keys of the map are used for. From a quicklook I think it's the type of user but I'm not sure.
this doesn't look like it needs to be public
return ImmutableSet.of();
Error message "workspace" parameter seems to have been lost in translation
Can use Objects.equals here
To avoid issues with leading, intermediate or trailing spaces, use trim() and regex into split: suggestion return Arrays.asList(name.trim().split("\\s*,\\s*"));
try to use LOG.warn("Unable to access property: {} {}", NhincConstants.KEEP_ALIVE_PROP, ex.getLocalizedMessage(),ex);
Please use LOG.warn("Unable to access property: {}", NhincConstants.KEEP_ALIVE_PROP, ex.getLocalizedMessage) to reduce stack trace
Fix logging level here (error)
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
Exception again
analyzer should be extracted into a separate method
Since NoteSQLiteOpenHelper is currently a singleton, it's dangerous to close the database from here. Theoretically, it's possible that another objects still wants to use the database. Hence, I suggest to remove this.
Either of the events should be raised I think.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
This method is a good idea! I know I'm nitpicking, but may I suggest to skip the contains() call and just do a get() and if null, then return defaultValue? This will skip at least one MultiMap call.
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
what if my value is " " ? should use trim
The call to super() is unnecessary.
can be delegated as: putBytesProperty(key(key), value)
Here we should use new ArrayList<>();
Is this change related?
Looks like approach proposed in line 92 would help here too. The less code duplication, the better :)
store variable
I still think you should throw an exception if name is null
Isn't this the default max width? In any case I would prefer to see these definitions in the css files.
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
remove tabs
It's the fPartListener/2 that is null. I don't think the site and page can be null at this point.
could probably inline, won't be null
why sampling logger? do we expect a lot of openFile?
Should we check the result of status.isFolder and status.isCompleted here?
delete this part.
This line is redundant.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Won't fix.
Add the original ClassNotFoundException as cause.
Why _transformer_?
Let's make sure error messages are consistent.
The original job does not seem to extend UniqueByEntityJob, or implement the isSchedulable/scheduleJob methods, so there is no need for constraints on this job.
The constraint here should be on the consumer key, since on the old job the TARGET_TYPE is a consumer, and TARGET_ID the consumer uuid.
I'm missing the new field in the toString method.
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
are we guaranteed that this mapping is the only thing stored in the metadatastore?
nit, Collections.EMPTY_MAP?
A data provider with a single entry is questionable. I was thinking the versions would be separate test cases in the provider (you'd have to duplicate the test string which is fine, and probably putting the getBytes call into the test method body) .That way, you could eliminate the rtCheck loop, and maybe the whole method.
Please add ? and % as well
why both DataProviders have the same article's names inside?
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
remove public
I do not like tests that throw IOExceptions. I would argue that you should catch the IOException in the test and use:  java try { //.....snip.... } catch (final IOException ioe) { Assert.fail("Could not run test due to problems with a file", ioe); }
Do we need to valid that delete was successful?
rename to automationContext
I believe this can be package protected. If so, please make it package protected.
Don't we need to do the caching here?
Same thing than for the agent: no default value.
Let's only use DsfDebugOptions... as mentioned above
Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.
Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
Shouldn't we add the Transmit options field here?
Wrong key name (unused new rewrite key name getting flagged by intellij inspection job)
I'd rather pass down the auth information to the QueryLifecycle. There's no harm in checking it twice, if it's good enough for Santa Claus then it's good enough for us. Checking it twice should also allow us to get rid of the no-auth path in QueryLifecycle, which would be good. Perhaps a good place to stuff the auth token is the PlannerContext.
nit: line too long. final not required -- a static method cannot be overwritten anyway
extract method
extract method
Simply: "return builder.parse(id);"
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
return undoCommand.undo(action, result, callback);
return Collections.emptyList();
should it be error level?
use the logger instead of printing stack.
This check is unnecessary. context can never be null for a properly constructed object.
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
We could compute this only once in the constructor right after setting mRootDirectory.  mRootDirectory = rootDirectory; mIsExternal = isExternal(rootDirectory);   private static boolean isExternal(File directory) { ... }
The reason for the NPE in doStopJobExecution(org.springframework.xd.shell.command.JobCommandTests) comes from here:  final String startTimeAsString = this.configuration.getLocalTime(jobExecutionInfoResource.getJobExecution().getStartTime());  The JobExecution startTime can be null.
I think the return type should be IborFutureTemplate as AbsoluteIborFutureTemplate is package-private.
Was seconds an intentional omission here?
s/policies/policy
You could change line 188 to final boolean[] success = {false};, success set on line 194 with success[0] = true; and return success[0];. This pattern is often used in similar situations. It leads to an allocation, but if the MOE is smart enough, it could optimize it out. And if not - flush is a slow operation anyway, so it doesn't matter that much.
Use FileUtils.mkdirs
+ desc
Missing NLS
Maybe remove references to versions here? You could change this to: "Migrates pom.xml files to format compatible with KIE Maven build." @porcelli WDYT?
you import ByteBuffer, no need to use the full package path
We should probably keep setUp for @Before and make another method "init". The assumeTrue should probably stay in the setUp
EVERY one of the tests do this. How about a @Before instead? I assume those traces should get closed/disposed too?
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
oh, this comes form apache. Maybe jsut ust "" even if it is not that readable.
Map.get(key) already returns null if he key is not contained in the map.
You may also want a test case for a search value that is non-blank but invalid.
please just define on the next row.
missing: a test for an empty ("") description and a null description.
use createTempFile
This code style might give formatting error. Even if one line statement it should be within curly braces.
the same condition is checked twice
Where is the progress started?
Use config.getTrimmedStrings() instead?
Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?
nit: return conf.toMap().getOrDefault(key, defaultValue);
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  $ file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
Empty catch again? :) AssertJ or suppress will work better for us I think.
This is not used anywhere
Missing call to super implementation of onResumeFragments()
I think package private scope is enough for tests
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Same here: should be Branding, not ProductBranding
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I'm missing the new field in the toString method.
This method might be the one in public.
should this be valid &= ?
Tiny style thing, can we put brackets round boolean expressions like this e.g. boolean valid = (files != null);
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
infinitest.filters, i see that you are using only one time now, that's a good thing. What do you think to extract it in a constant? something like INFINITEST_FILTER_FILE_NAME
The names CONFIG_PATH and configFile in the context of a SchedulerConfiguration are a little confusing. I read them as referring to the Scheduler configuration (as opposed to information about workflows), so when I saw the hard-coded slidingWindowHours value I was scratching my head wondering why you hadn't just added it to the existing configuration.
use an overridable getOperationTimeout() method instead
why removed these two lines
static?
Optional
I agree that my proposal was awkward phrasing...I like your proposal better than mine.
Noooooo!!!! this needs to be configurable. At least the admin password needs to come from the pom, or any installation of Quadriga will always have an admin account admin/admin. SECURITY (to channel Abhijith...) ;)
better use a local variable for the return value instead of modifying the argument
check that charAt(1) is a . ? (and is also at least length 2)
Hi @kkrugler, I had forgotten about forbiddenapis but that shows that the automated checks with PRs are very useful. I'll have a closer look at the PR on Tuesday. Are you happy with me releasing 0.9 before merging it? we could release 0.9.1 shortly after that
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
can these parameters be grouped into smaller and more meaningful objects?
I know we have an inconsistence here with all the controllers, but I would still remove public from the constructor and make it a final class as it should be.
getClients(this, null, null)
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
filteredProgrammes is a bad name for this, and as far as I can tell, these should be Episodes, not Programmes by now.
Oh, so the number of retries actually includes the first try as well.
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
You can use distinct
context.isExtractStatistics()
nit: as above for external, and entity here and below
Cleanup: Remove all **throws MiddlewareQueryException** clauses
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
do you need to add CRC here?
You could also use -> Objects.toStringHelper() from guava
Could you please explain this? Why should this hold everywhere?
this is confusing, it is called router but actually it is routerUrl.
Since you now have ConcurrentHashMap, you could cimply do return patternDateTimeFormatterCache.computeIfAbsent(pattern, DateTimeFormat::forPattern)
Replaceable with Iterators.transform()
Looks the same as Predicates.equalTo(0)
this noopSubscription seems used in many places, create a single one and reuse?
I would use List here
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
I'd go for: return ImmutableList.of("node", "show", "-l", nodeName, "--format", "json")
move check back as first in the method to not change behaviour if null is passed as unit but we are in the EventLoop thread.
This is a breaking change.
move null check back as first action in the method to not change behaviour
Maybe those two should be extracted to constants since they are used in two tests.
can this just be private?
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
exception does not need to be caught.
exception doesn't need to be caught.
is this needed?
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
InterruptedIOException
You can call MessagePacker.flush.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
We normally put private methods at the end
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
labUrl needs to be taken out as well, and added in to SampleAdditionalInfoDto
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);
This seems reversed to me: we have a local affinity on the local system, we want to send it to the peer, so the affinity we send to the peer should refer back to me (which is what "nodeAffinity" is equal to). With this change, the affinity refers to the peer, so they will receive a node affinity pointing to themselves.
Log the Exception
Deprecation was added in [1] but the commit message does not have detail. [1] <LINK_0>;a=commitdiff;h=18bcdf797dfba5e462413a6ccce9dd6d3da2025b
What if fSelectionProvider is null? NPE will be thrown.
why not just req?
I think we can avoid this .INSTANCE. business by putting the fromV1APIJson method inside a companion object.
@dmzaytsev let's inline this
Why we don't call onDestroy() method of playerSkinLayoutController as early?
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Should be a SamzaException with a message, not NPE.
Not sure, why not use @NotNull?
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
Lets use isRebalanceEnabled from kernal
In separate line ?
nit: redundant
What if we don't want to set it? How does the UI know that this has happened?
This will always return the theme.properties file
Prefer [java.nio.Files#createDirectories(Path dir, FileAttribute<?>... attrs)](<LINK_1>,%20java.nio.file.attribute.FileAttribute...%29) (and maybe [java.nio.Files#notExists(Path path, LinkOption... options)](<LINK_0>,%20java.nio.file.LinkOption...%29) on the line above, although this has slightly different semantics)
Does not make much sense to create a new instance of MentionsData to return a static.
You can use .forEach on a List directly: fSeries.forEach(consumer -> consumer.accept(obj)); Both work, not much difference, but the functional syntax would fit well with the rest imo.
Something wrong is here: ![wrong_object_to_remove](<LINK_0> this.inUseConsumerChannels.remove(consumer.getChannel()); ?
these setters should not be public
Should we check if the connectionId actually belongs to this <host, port> pair? There could be possibly error cases that connections to <host1, port1> are checked into <host2, port2>.
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
suggestion this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace, "'fullyQualifiedNamespace' cannot be null.");
Will this inject all instances of Task on the classpath?
Clarify doc. Returns a proxy not a real result set, and throws NPE if not initialized.
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
Wondering if we shouldn't fire event in the way we do in CanvasLayoutUtils.fireElementSelectedEvent
I don't see where we handle HibernernateException.
if mockTime was incremented by exactly the time required to trigger the operation timed out error, why would we need a loop?
perhaps this function and class could be named differently since they do more than just check the error code - in some sense, they execute the test.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
The constructor should be made protected so that users can easily make a wrapper for it.
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
if you compare against the ID of the view rather than the instance you don't need to maintain the fields
@Nullable but actually, why allow null here?
If wonder if it should be:  lp.x = left; lp.y = top; requestLayout();  At least with this change I no longer have markers coming back to their initial position at scale change. Although I notice that given the code we have in the demo to test marker move, the markers should be moved to the first position (which is not happening, and I couldn't find out why). I suspect this has to do with the measuring/layout logic, because I triple checked the code in the demo, its fine.
do these test methods really require throws Exception?
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
It know it's part of the original code but it's better to clean it up. Remove these two lines, just let the Exception be thrown, it'll give clearer test error messages if there's a failure.
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds ?
I see what you meant but that's a very confusing name since the collection holds VdsmVms
how about reportsOnExistingVmsInDb?
You can use ExpressionUtils.methodName(mit) for that.
Remove final modifier.
Why switching the order of the short circuit ?
I think you want observeOn here... although the effect is the same.
nit: @override in a different line
Scm api has rules on the placement of annotations for methods
how about renaming this as newPage()?
It's kind of funny that this just has 1 record. Better than no records though!
This is bytecode equivalent to using the for-each syntax on an array.
should we have Objects.requireNonNull in these?
Seeing that the 'Edit Button' patch is already in master, I'd suggest rebasing this patch on top of master to avoid any possible merge conflicts.
Always enclose if (and other conditional) bodies in curly braces.
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
"formats" is an ImmutableList, you don't need to synchronize on it directly to iterate. Here you probably want to make sure only one thread is modifying the time zones at a time though. I'd suggest putting the method itself synchronized instead, or using another lock at TimeGraphScale's level.
If we move the logic to the builder factories, this would not be needed.
There isn't ServiceBusProperties in SB API
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
Still getting the compile error in Eclipse and code is still littered with type warnings.
Nitpick: windowId > Stateless.WindowId
Why not use assertNull and assertNotNull?
looks like duplicate code, can it be refactored so it's not in multiple places?
this should never be null, it should be validated in the configurePipeline() method.
shouldnt this return null?
This function no longer needs to be protected. It should be private.
This is strange.
Should this method be private or protected?
I am not sure if 503 is correct it this case. It indicates that something is wrong with server. In my opinion 403 will be better.
Shouldn't this be wrapped in a try... finally block?
let's promote these to variables so we don't have to always cast them
I think ServiceDiscoveryManager should be a field of this class.
I don't think we want to automatically announce support for spoiler messages. The XEP is pretty clear that if a spoiler message is received the content must only be displayed upon user's request. But this can not, or only with to much effort, be guranteed on the library level. I think we should remove the automatic announcement of spoiler messages and instead provide a method the user explicitly has to invoke in order to announce support for spoiler messages. As beneficial result, the whole automatic manager initialization boilerplate code can go away
Can the body be extracted together with commit() method to avoid code duplication?
@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>
this and m_ is redundant
maybe it's better to tag them with the status so that we can break them up that way?
As discussed f2f, please see if the async flag used by the REST is a known bug or is there some other way to monitor async commands in the REST. Any how, this code will seem to monitor the tasks twice, once by the ExportVmCommand and also by the child command
the validate() method should be updated to support that case, for example, space on the target domain shouldn't be checked (we might fail on it)
Please consider to refactor this into a separate method
replace with: Mono.when()
Scheduling a message isn't part of the scenario. Do that as part of your // Arrange.
What about sending a non-session message to a session entity?
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
Injection constructors should be package private. Remove the public modifier.
There should be a null check here if it doesn't accept null values
this should probably fail on receiving interrupt
please compare to what you had in the past before you removed this class. log.error("Failed to import certificate: {}", e.getMessage());
Thoughts on putting log messages in a Utils class?
Should this be put in the try block so that the exceptions it throws are wrapped?
This call has the side-effect of actually changing the position of the pointer in the stream which may be unexpected by callers. You should save the current position, get the latest sequence number, and then restore the current position after.
Same as getLatestSequenceNumber - save the current position and restore after
Could remove the else
This is cleaner: return (student != null) && (student.googleId != null) && (!student.googleId.isEmpty())
Be careful when copy-pasting...
suggestion + "The requested operation is not available while the JobManager is initializing.");
could you catch exceptions in the following call to be robust on deserialization errors (upgrade of proactive scheduler)
Beware that by doing jobsMap.put(), the job will be kept in memory without housekeeping
Is this one of those @VisibleForTesting things? Seems unnecessary
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
A ternary statement is fine here.
Yes, we should. Don't we have a helper method to automatically do this?
add null information
suggestion if (unit.getId() == null) { unit.setId(UUID.randomUUID()); } units.put(unit.getId(), unit);
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
Update labels to go with method names. Alternately, call super.toString for super attributes
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
This is a change of behavior. Some tests might not require all nodes to be up and trying to enforce that here seems like a stricter check. The earlier check createKVS can succeed if we have quorum too. We can perhaps have a classRule in the test classes to disableAutoCompaction if thats the first thing to do? Does this nodetool command require the node to be up first?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
this code snippet is the same in all of these tests. Have you thought about just making a new CassandraContainers rule which wraps the Containers rule and just contains a CassandraKeyValueServiceImpl?
static import readIntLittleEndianOnOneByte.
We can use try-with-resources now. I know this is only a refactoring but we can take this opportunity to clean up code
That is true but you aren't storing or using the blobOutput here right? So why do the getBlobOutput() call?
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Should close kill the memspace? What if someone want to reopen the key?
Let's avoid null and rework to empty string
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
I think that the underlying XMLStream reader has a 'getAttributeValue' method. It receives the namespace and the name of the attribute. If you pass 'null' and the name of the attribute it will return the value of the attribute, which is what we need: <LINK_0>
This is a pretty cool solution :) I think we'd need to excavate something out (or bake something into a plugin) to make sure tests run with -ea, because I just tried putting assert false in a test and it still passed!
shouldn't be a CacheConfigurationException?
Minor nitpicking, as I've recently being removing the use of "unnecessary helpers": when you know already that "value" is not null, there is no reason to use the StringHelper. Just go with ((String) value).isEmpty() ?
Please add ? and % as well
Isn't it also important that adType was async and method was top?
unnecessary array new: {{true}, {false}} should work here
How about this one? I think there'd be a standard error code for this.
I don't see how connection can be null when commit or rollback is called.
Should this and following throws include the unsupported method name? (see line 1194)
hey, I'm not super comfortable with "%n" and "%p" as delimeters (It's totally reasonable to imagine that people might have "%n" in their text). Are those directly in markdown? If not, we should talk about how to do this differently
you need to first trim input otherwise this doesn't match if input starts with whitespace
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
since you are awaiting termination otherwise, seems like this should either be an isTerminated() check or you should do an awaitTermination() anyway in the else. Let me know if my understanding about the ExecutorService interface is wrong.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
As a nit, should have a null guard here.
Missing StringUtils.isNotNullOrEmpty() check
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
these setters should not be public
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
just return "" instead of new String()
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
This should really not be public.
do we need this check? You can argue such statements in all other methods.
drop unnecessary else.  private SecretKey verifyKeyNotDestroyed() { SecretKey key = this.key; if (key == null || key.isDestroyed()) { throw new PrestoException(GENERIC_INTERNAL_ERROR, "Spill cipher already destroyed"); } return key; }
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
Does this action exist in material_select? It should, but need to make sure.
"Initial connection"?
Great tests. I'd suggest using nio (Files.copy and Paths), rather than bringing in the dependency in the org.codehaus.plexus util, that is available now, but is not listed explicitly in the project dependencies. For simple things like these it's almost always better to use standard java library stuff in tests.
this is just a setter, why we need to update it?
Not doing getClass().getClassLoader() and just leaving it null would default to TCCL. Not sure which one is best.
Calling a public method from a constructor is error-prone, could you extract the default implementation of refresh() to a private method?.
I prefer to leave this as package-private to avoid a synthetic accessor.
likewise: can make package-private to avoid a synthetic accessor
this needs to be wrapped in an if (timestamp != null) check
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
Where did 31 come from? Why not use *=?
Maybe wrap in an immutable map.
this cast could be avoided thanks to the changes on generics on MultiIterator
isPresent() is expected to be used here.
could you rename this to storelogimages?
I tested it and it didn't work. I believe the * 1000 * 600 is not needed here and will bring alarmIn too much into the future.
there is Long.hashCode(long value) method.
missing a final
That's a lot of nested ifs, can we simplify?
final
If you want to remove not null validation from constructor, it should be added here
Remove all "null" cases. There is a default case for that.
avoid using super
You'd probably dispose your stuff, and call super.dispose() at the end.
we should probably call EcoreHelper.unregisterEcore on dispose, shouldn't we?
rename to operation
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
it seems a little worse than that, I see that the constructor of DefaultNodeUpdater also tries to do the following:  ChannelPool pool = context.poolManager().getPools().get(node);
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
I think "debug" is better here -- this kind of diagnostic is a bit too loud for logging by default.
We should use other method, this ends up creating an AccessControlScannerThread unnecessarily.
printing contextId in the message will be helpful for debugging.
Since v is not used/needed, could use thenRun here like .thenRun(() -> cd
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
a do-while will avoid checking 2 conditions (the while true and the CAS)
These arrays could be defined statically in this class, as to not create a new array every time this method is called.
Consider returning a constant
Please, fix these kind of smells with an explicit array size. Thanks
Please use object instanceof ResourceAtt...
Please use object instanceof Dangling...
Please have result variable.
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Doesn't String.format need a value to be formatted?
Also this should be Log.d
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Please make a copy of the attributes and make it an immutable copy.
can you pull this from a static string?
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
nit, Collections.EMPTY_MAP?
You change some methods signatures/arguments into _*NameCount*_ but these methods still containing _Segments_ wording
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
thrown.expecteMessage(). minor thing, i am fine with this.
do these test methods really require throws Exception?
The try-catch surounding this can be replaced with JUnits [ExpectedException](<LINK_0> rule. It reads a bit nicer.
We should still render as before, change the text size of the button based on the text_size attribute if present
This is redundant, auto-boxing will work just fine and IIRC unlike JGit we don't warn on auto-boxing in Gerrit.
null =
For proper testability, should these also be listed in hasService()? ...or have we just been passing this test because we run it on the right kinds of devices?
I'd prefer Assertions.assertThat(connectionPoolFactory).isInstanceOf(OkHttpClientConnectionPoolFactory.class). That way, if it fails, we have a decent message :-)
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
I think this should be "Setup Trigger". Shouldn't that be externalised to strings.xml though?
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
Use [Bundle.putInt(String, int)](<LINK_0>,%20int)) instead, no need to serialize a base type.
we should change this - and the other two getters to @Nullable public Long and return objects instead of primitives
Why not declare GLOBAL_ID as a long?
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
Same thing as above, let's split out a config for this.
getAttribute returns null - add null check
add sandbox
White space.
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
Is this meant to compare the item stacks beyond object equality, given ItemStack does not override equals *or* hashCode
Index could return a List<Question> instead of List<Long>, right? The less logic we have on the controller, better
Can Java 8-ify this method and replace the body with a streams/map/collect one-liner: return names.stream().map(name -> new ColumnId(tableId, name)).collect(Collectors.toList());
this method may reset the configuration 3 times, which seems very strange. I think we shouldn't be ivalidating our configuration cache for no reason. Instead of overwriting the configuration each time why not just udpate the map to have the best information? This way if any other part of the code has a reference to the configuration it is kept up to date. ie. instead of setting the configuration clear and putAll on the configuration's map. This applies to most anywhere in this class which is calling setConfiguration.
pvk should not be visible. Please remove it.
any reason we are using System.exit(0) do you see a hang without this?
This should probably go to System.err, as goes e.printStackTrace()
Actually, the target of the test is the function onShutdown. I would like to test it to be sure that if something changes in the future, it has a test to verify it.
Is this needed? For future use?
Personally, I prefer to separate modules. This module could work without the parser one, so I'd prefer to remove this line and add the GlacierParserModule to the list of the default modules in the ApiMetadata.
We always use brackets, even if the if only has one statement. Same goes for the else clause below.
Do you know why we are making this change?
value is never null?
This class is still beta--I would be OK just making this method non-static and using the registry
This is standard procedure in our existing registries. :+1:
Alternatively: Qualified.class::isInstance
Could this be protected as well?
define a local variable for ED
Could you make this method protected? This will allow override it when needed
Can use validatePrimaryLanguage here and below.
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
If we write "language", the switch-case no longer passes.
Can you handle parse error here?
Make these Locatable.
You can use ValidationUtils.nonNull for this.
Why not public access?
Optional should be used in interfaces. Use null as internal value.
Nitpick: this should be static, because it doesn't depend on any instance fields/methods. Also you wouldn't have to prefix the calls to this method with this. everywhere (I know it's part of your personal style to prefix things with this even thou it's not mandatory in places like these :-)
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I this refactoring, very nice. Could make this method protected.
Find / replace mistake
please fix the whitespace. You just need to return the options here.
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Collections.emptyList()
Should not it be [less than 20](<LINK_0> ?
This represents a poor API. If you are not going to provide a working implementation for all versions, the newInstance method should be marked @Nullable and you should actually return null. This way callers explicitly have to write:  java if (mHighlighter != null) { mHighlighter.highlight(...) }  An alternative strategy is to add an isSupported method that NullHighlighter (prefer NoopHighlighter as well since null has no semantic context here) implements and returns false, then throws on all other methods, forcing callers to write:  java if (mHighlighter.isSupported()) { mHighlighter.highlight(...); }  The reason for being explicit is so that readers of the highlighting code can see plainly that it might not be supported and that would explain why it's not working for them on a naive/quick read of the source code. Forcing folks to dig all the way down into the implementation to see that possibility is frustrating.
static.
Same question as above
nit: you can merge both lines above as checkNotNull will return the given argument
Please use the form given before
Maybe make it protected instead?
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
suggestion return new Config<T>(Objects.requireNonNull(klass, "recordClass cannot be null"), this.filterPredicate, this.deprecatedProjectionString, this.strictProjectionString);
Would prefer to store the quark as a member of this class and keep the getThreadQuark method.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
Probably returned value can be long.
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool. suggestion String dialogContent = getString(R.string.confirm_deletion_message, " \"" + listName + "\");
Threshold of value [value][default_currency] for [category_name] has been exceeded. \n Current ammount spent: [current_ammount_spent] [default_currency]
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Since this doesn't change functionality, we probably don't want to change this just to update to modern syntax. The more changes we make like this, the harder it is to backport other fixes that might overlap with this diff, and ideally we backport fixes aggressively (and in fact, this could be an example where we might want to backport to a version that supports jdk7).
redundant ";" character
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, (0xff & (hostAddress >> 8)), ... }; try { inetAddress = InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
Printing the query as keys will look something like: ... keys=[IndexQuery.ExistsPredicate[propertyKeyId=0]]. I think it is worth extracting the actual keys from the queries and only print those.
Can't you modify the autogenerated method that uses toStringHelper?
i think it's slightly better to add one more argument in AzkabanFlow constructor called type, and let builder handle the default parameter passing.
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
we never use NULL, it is a bad practice in general.
After having a look at the entire class, all tests require this to be present. Throw a SkipException here to automatically skip all tests in this class, showing the reason?
Is there value in testing with more than one setting here? I agree this is the highest priority since it is the default, but the extremes of 0 and 9 are also worth checking.
In the deserializer, the provider name is uppercased before searching in the map: java String provider = providerNode.asText().toUpperCase(); String providerPlugin = EndpointDiscoveryProviderMapper.getProvider(provider);  Maybe you should do something like this: this.provider = PROVIDERS_PLUGIN_MAPPING.getOrDefault(provider.toUpperCase(), provider.toLowerCase());
The same as with previous - make it final, don't check for null (reduce amount of lines)
Curious: Looks like this variable is only used once. Can we inline it ?
I was thinking if is there any chance of an error causing this connection to remain open. Do you think we should wrap this statement in a finally clause?
nit: remove else {}, throw exception after if block.
there are no null values to omit
StringPool.EMPTY instead
following the change above, i'd expect this one to look as: assertTrue(validate.isEmpty())
This same as next test in terms of logic, since you're not actually testing the "default" min range is used since a min range is set on the annotation.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
RetryState rs = null; while(!success) { rs = state.get(); ....
It should be success=%b
It should be success=%b
Is it possible to use a title here? I think PageTitle wants the normalized title. I know that in this case card.filename() uses the title internally but now there's a weird PageTitle dependency on filenames if it ever changes. For example, I could imagine it becoming file://foo and now PageTitle interprets it as the File page for //foo.
You don't need to return anything here, as it's unused.
The title should respect the card's language. Please see #1585
Make use of the [lazy holder pattern](<LINK_0> to prevent the conditional at each call.
please add sync protection, see EngineLocalConfig.
given that you re modifying this method...it should be made synchronized just to avoid concurrency issues. Also update the end date in the copyright header for every file you change.
Once we move to a simple, declarative boolean passing model, we won't need this line.
embedcode2 - please name it according to the purpose of usage
Strange parentheses here ( selected), maybe this was a cast before?
clone should not use duplicate... duplicate should be an alias of clone. hmmm... you created infinite loop? clone->duplicate->clone? this entire logic is incorrect... should be, something line: CommandContext cloned = (CommandContext)super.clone(); cloned.setFromContext(this); return cloned;
'time' should be cloned instead of timeLiteral.
warning or error?
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed. An this would just be one of them.
I'd use getPathAsString instead of getName to provide unambiguous info.
This is no longer needed if MVs dont support indexes.
Please put entry.getKey() in a local variable.
Move getColumnNames() out of the loop
did you test this? this looks like it could be an ConcurrentModificationException
I guess it can be moved into the if statement
Maybe? suggestion log.debug("Error when closing datadog client: ", e);
i think the line below should be replaced with log.trace(addPrefixToLogMessage(arg0)); in order to justify the log.isTraceEnabled(). (as should have been added originally when addPrefixToLogMessage() was introduced in this file)
or just java public static Object[] data() { return TestPlatform.values(); }
Collections#addAll
Please parenthesise nested ternaries.
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
Why do we have different checks in these two tag methods ?
I think this would be better off being @Intrinsic and calling through to the original method so it doesn't interfere with other vanilla calls.  @Intrinsic public boolean entity$addTag(final String tag) { Objects.requireNonNull(tag, "tag"); return this.shadow$addTag(tag); }  The difference between this method and that one is that you return the result of Set#add, vanilla just returns true - is it a problem if addTag just reports whether the entry is in the set, which it will be if it reports true, regardless?
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
Should we keep a reference to the Bundle here?
Would you mind making the "tabList" string a constant symbol since it's referenced in multiple places.
please fix the whitespace. You just need to return the options here.
Please initialize this with setMaxInflightRpcs(BIGTABLE_MAX_INFLIGHT_RPCS_PER_CHANNEL_DEFAULT * BIGTABLE_DATA_CHANNEL_COUNT_DEFAULT)
This doesn't seem to work internally, FYI. :-)
If the list of users stays the same, make it unmodifiable in the class constructor.
We might use a NavigableSet instead if a TreeSet is used, I assume.
Sometimes I also try to protect internal collections, but normally it only complicates things later. Can we return it as-is?
The return value of this method has switched. getAndSet is going to return the previous value, which is true if it already was under backpressure and false if it was not. This is the opposite of  * @return true if an update was recorded, false if taskId is already under BP  This is used to control when the server sends messages to the client about backpressure, and could make it happen not frequently enough and the beginning and then way too frequently after that.
@erdemedeiros we should stick to only tasks that we as an authenticated users can see. That is what the default findAllByWebQuerydsl() should do. We should add the check in the getTaskById() method to make sure that the user making the request is allowed to see the task. Does it make sense?
I think the below is better to avoid an extra lookup on the map.  taskAppenderatorMap.computeIfAbsent(taskId, myTaskId -> new ArrayList<>()).add(appenderator);
Load and termination parameters should belong to Load and Termination entities
private, should only be called from the builder.
Please remove this empty line.
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
Why don't you simply create a byte array of one element and call into the byte based read() method instead of creating such a channel?
Should probably remove all synchronization from this class.
This code is correct, but it could be implemented in a more succinct manner that is a bit easier to read: public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrManagedConnectionFactory ) return this == other; return false; }
suggestion return Objects.equals(address, other.toString());
suggestion return Objects.equals(messageId, other.toString());
KernelMemoryAnalysisModule
assertTrue
legacy extensions might not use abstractSegmentStatisticsAnalysis
Extracting the results of the getHeaderParameter() calls to local variables should make this easier to read.
consider merging both lines
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
I'm not 100% sure but I think this should be the other way around. feeds.size() seems to be the expected value. This problem is also present in other tests. Before, a failing test just showed something about a failed assertion. Now it shows actual value and expected value, so it is misleading if they are exchanged.
This doesn't compile for me? Did you mean urls.get(0).toString()?
Awesome! Do cache (and invalidate) this resulting String though
why the braces removed?
1. testedWiki is still muppets here 2. use wikiCommunityURL or better: 3. remove wikiCommunityURL and create new variable in IntraWikiSearch() constructor instead
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
The null check should be done by the caller (if at all). Currently, a null will trigger the else() branch of the if()
rlly nit-picky: would turn that around from: is our location precise and do we actually have one to do we have a location and is it precise
no public
nit: use SUBJECT
We try to use the arrange, act, assert pattern with one empty line between each block. In this case there's no "arrange" necessary. But we still want to separate "act" from "assert".
Since the mapping string has no meaning, consider using a random generated one.
This can be simplified to return this.cmd.hasOption(optionName));
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
I think you want isPossiblyOkHttpTimeoutBug(cause) otherwise it will SO.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
This will most likely blow up when running within Wildfly since Wildfly does not use DefaulCacheManager implementation directly AFAIK. They implement a delegating cache manager AFAIK. I really don't see the need for a removeCacheLocally method at all. Can't you create a private method in this command, get the component registry from the cache manager, which can be injected, and in the private method do everything you do in removeCacheLocally? If the method needs to be accessible from multiple places, add it to a util class as static method passing in all the parameters needed?
suggestion throw new UnsupportedOperationException();
From the point of async store, it is not necessary to have the *function* serializable but the resulting entry. So the check does not belong here. The same holds for compute commands.
why not use super? like: return String.format("%s, volumeId=%s", super.toString(), diskImage.getId())
I don't think you need this new String
Better to return "";.
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
Possible ClassCastException, since there is no check that the loaded resource is a view.
why not check for null?
An exception doesn't necessarily mean datastream not found, right? Why not check the http status?
For me, It's strange to see that if exception during parsing of jwttoken failed - then authentication should be skipped. Is it supposed that this token will be validated by the next authentication filter?
This log level should not be "error", beacuse we use this method when deleting instances and, in this case, we expect this exception. We have to create new US to review all log levels.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
it appears that this change can be reverted.
I really don't like the user of instanceof. Why not overload the method to recive VDSExceptionBase? In both places this function is used, you already have that information.
Remove log.warn since we already cover in log.trace
Use switch - case - default instead of if - else if - else if - else?
I guessed this is by intention to double test null, right?
This method can be static, as all the methods it calls.
better to have fail(); in the onSuccess()?
better to have fail(); in the onSuccess()?
better to have fail(); in the onSuccess()?
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
do these test methods really require throws Exception?
Redundant assertion
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
If an implemented class uses this default group method, does it work with returned null or it has to override with some implementation?
You can make use of early returns here to reduce nesting, e.g. java if (userInfo.isAdmin) { return; } if (!userInfo.isInstructor) { throw new UnauthorizedAccessException(...); } // everything else
Should this be getNonNullRequestParamValue?
The null check can be omitted as it is checked inside verifyAccessible
Should make a differentiation of the name and id.
The this. in getters are unnecessary too.
If you have a translation use that if possible.
Cache this value.
Why absent?
There's a simpler way: java return Optional.ofNullable(counters.get(key));
This should return T.
it is possible that getItemAtPosition returns null -> sure NPE here
This should probably check for > maxInt and throw in that case. Unlikely with an index file... but you never know...
-1 as this should never happen, and the message highlights something fishy
This looks dangerous, should the interface method return an Optional instead?
shouldn't the values be fill with null? (to help GC)
Missing super() call?
public?
I'm missing the new field in the toString method.
you have to add a canDoAction message if you fail canDoAction
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
perhaps do this in multiple lines
I don't think we need to observe on any particular thread
we no longer need this null check as we don't use placeholders
else throw an error about invalid class.
You're not checking the mediatype here. At this point, do we just have to assume that jax-rs has called the above method and is giving us something sensible?
How about using GSON.toJson(o, new OutputStreamWriter(entityStream))? We should also make sure to flush the writer before leaving?
Not sure if I'm a fan of using this exception, as it looks like it forces the use of another exception mapper. Have you tried doing just a WebApplicationException with the Response.noContent().build()?
remote this
Why not flip this around, have the constructor with the sessionId call the constructor without the parameter? That way you don't have to pass null into the constructor. Functionally it makes no difference, just reads a little nicer IMO.
Isn't the isSessionExists condition enough?
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
This is a bit weak when it comes to IPv6 addresses, as it assumes "hostname" is properly enclosed in [ ].
no need to use String.format as there is no parameter. Either provide directly throw new IllegalArgumentException("Port must be greater than 0"); or maybe improve message with somethign like: throw new IllegalArgumentException(String.format("Port must be greater than 0 (provided {0})", port));
bad hashcode.
Why use only w2? Why the right shift? Likely it doesn't really matter.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Why we want to fall through into the loading dialog in case of error?
we'll never reach break;
Just return the result from parseInt from here, no need for the count variable.
could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?
Should be defined as a DEFAULT_PREFETCH_COUNT constant, and should be sharing a constant with Meta.
Remove the public modifier.
This should be obtained from the i18n file in case there's a language specific reference.
This should be obtained from the i18n file in case there is a language specific reference. The solution should actually provide some guidance, this CS could be added to the references.
Use java.util.Objects.equals().
This should be both .class and .this, because this should allow us to get all debugger events dispatched jobs or only for the current dispatched.
Ya this is some thing we can avoid
can we change the deprecated (since java 9) call .newInstance() to .getDeclaredConstructor().newInstance() (and extend catch clause)?
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
Consider creating the Exception on the dumpapp thread and just sneakyThrowing it here. Then any strange errors are visible to the command. Also, then the state of the class can just be the Exception and you can be more explicit about the parameterless getDeclaredConstructor() being a fallback that intentionally leaks NoSuchMethodException.
equals!
Please mock PhysicsWorld if possible
this can be replaced by textToDisplay.isEmpty()
This log will be shown pretty often..
emptyLabel seems to be violating SRP. Specifically it serves two purposes: 1) Not-null means we should display it when there are no components 2) The value itself is the display component So we are using both the display element as both the display element and the flag whether to show the display element. It's also a bit notable too that it is mutable with 'setEmptyLabel'. Do you agree with this issue @asvitkine and have you had any thoughts about it? Looking at the diff, as a suggestion, I think you can solve this by adding a constructor overload that accepts a new parameter, an enum "EmptyLabelDisplayMode". The existing constructor would invoke that new parameter EG:  public SimpleUnitPanel(final UiContext uiContext, final boolean useSmallIconWrapLayout) { this(uiContext, useSmallIconWrapLayout, EmptyLabelDisplayMode.DO_NOT_DISPLAY); } public SimpleUnitPanel(final UiContext uiContext, final boolean useSmallIconWrapLayout, EmptyLabelDisplayMode emptyLabelDisplayMode) { : : }  I also think you can then have 'SimpleUnitPanel' own the 'empty' label and not have it be injected. Then this add method would be:  private void addEmptyLabelIfNeeded() { if(emptyLabelDisplayMode == DISPLAY_ON_EMPTY_PURCHASE && getComponentCount() == 0) { add(new JLabel("(None)"); } }
This might be pre-mature optimization, but I worry about how this data structure is being used. One option would be to view the list as a revolving buffer and essentially maintain an index of the oldest "valid" item. You can replace and increment that on add and start your search from there wrapping back around.
null? why not just a () -> {} ?
ImmutableList.copyOf each of them?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
we never use NULL, it is a bad practice in general.
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
Typically we use Map on the left hand side rather than HashMap
I think this will not be enough, because you must wait until there are no currently running tasks
How is this expression different from "this"?
Small change, but can you swap the check around? First evaluate the ConcurrencyCheck. As this check has a greater chance to short circuit the conditional sooner.
This exposes the unicode workaround to the public.
new ArrayList<>(causes);
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
nit, Collections.EMPTY_MAP?
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
nit: can be chained onto previous line's assertion
this.context = context;
for the boolean parameter could be useful to use enums, so that it is more clear what it means
test case works good but it is not clear where did I have got the resources for second card. how about splitting a method playPreparationStageAndBuyCardYearOfPlentyAndPassCycle() on several parts? for example: playPreparationStage() .nextRandomDiceValues(asList(1, 1)) // P1, P2, P3: -- .THROW_DICE(1) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) .giveResourcesForDevCardToFirstPlayerAndBuyIt(YEAR_OF_PLENTY) also create separate method passCycleAfterFirstPlayerTrewDice() when needed.
We generally prefer assertThat(..., is(..)) for better error messages.
nit: method name is awkward, maybe better just whenStandardClientStartsTransactionTimes? Also goes for all the subsequent methods
Please move to a separate "Polishing" PR.
Can't we make it final as well? What if we try to rewrite the Mockito tests? I am asking to tweak the tests for several reasons: * it should be final by design; * we could avoid <p>Use the {@code Bus} class abstract methods to modify the behavior of posting and <p>This method defines the general posting flow and should not be overridden..
Please add curly brackets for the for-loop.
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
why not keep this as an abstract method?
UnsupportedOperationException seems like a better fit to me.
I would try to avoid forcing crate the temporary folder at current path if possible. We can omit the constructor argument, and set executableFile.getAbsolutePath() to the configuration.
Class should extend AbstractPathTestSupport and directory path should only be defined in getPath.
can we use BeforeClass annotation?
Maybe make this "Initializing monitor for..." to distinguish between the init() and configure() method below.
Please remember this ctor changed.
Package protected instead of public.
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
I think it is common to return the written value.
Might be nicer to return file?
Might be nicer to return the file?
StringBuilder
Please, use stringbuilder.
Add a message to the exception describing what's wrong.
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
\>= ?
can you surround with parenthesis the two expressions right and left of && to make it more clear ?
Could the instance var metricValues be dispensed with and the following done instead? java @Override protected void prepareMetrics() { long now = System.currentTimeMillis(); if ((lastUpdate + minimumRefreshDelay) < now) { recordValues(updateFromZookeeper()); lastUpdate = now; } }
These two assertions should probably be their own tests, testNullPath and testNullPathWithRoot respectively.
isNull()
isNull()?
Shouldn't this test keep initial @Deployment annotation here, so it keeps using the same process definition as before?
If it's suppose to throw an exception you need to call fail method or migrate to catchThrowable.
No tabs please.
should the SortExpressionExtractor be renamed as well?
It's sad we had multiple params per line before. Let's fix it by having one param per line.
Would you also add an IS_NULL filter here?
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
Why is this needed?
Please group mr, ms, and mrs together
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
better do the close in a finally block.
- Are you sure this is enough? Containers, which are started by scheduler, are not part of the cluster. Therefore they are not stopped. If I recall correctly, the scheduler gets killed by destroy(), but schedulers remain running - CLUSTER is annotated by @ClassRule, therefore stop() will be call through MesosCluster.after()
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
try/catch block in a constructor with e.printStackTrace()? Shouldn't this be something like SqlDatabase.createReadOnly(config); or something?
Imagine we have 2 KIE Servers. None of them are up and running when we do the first round of client creation. So they both fall back to async creation. First KIE Server client creation then succeeds and it then forbids the scheduling of next possible tasks for other KIE Servers. I think we should just cancel the periodic task just for the KIE Server which we were able to connect to. So we should hold all tasks in a separate collection. Moreover, after the last task is removed, we can shut down the executor service.
I am guessing your builder needs to have isShared and isAudited set to default values (false) here. Also based on this: <LINK_0> Please add the corresponding docs for the properties here and in other places as applicable.
This should return a builder with the current options set.
This method should be static and need not pass this as an argument to the constructor.
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
Put a new line in after every \n to make this readable. Or alternatively put the blueprint in a file in src/test/resources/path/to/file.yaml and load it with new ResourceUtils(this).getResourceAsString("classpath://path/to/file.yaml").
@dmzaytsev try to use org.apache.commons.lang3.StringUtils#join() here. It could be more visual
I think protected might be more appropriate
I think the annotations should be on separate lines
Better to return "";.
"Error while moving file from ..."
would be nicer if you'd use a block dispatch node here instead of doing it manually, and unoptimized.
I think it could be useful to see an original error message as well, like it can show 403 which indicates token absence and can help a user to understand a cause. WDYT?
nit: space between if and (
nit: space between if and (
nit: space between if and (
This could use Objects.equals().
is it expected that we are ignoring requestExpiry, statusCode and timestamp when comparing? Same for other classes.
same as above, if you always use Object.equals(a,b) you don't have to take care of different types
You can call this.setTimestamp(timestamp) from here.
Unrelated to this patch. Again this is a good change, but it adds diff noise.
These ones too.
Is this necessary? If I remove the update line everything seems still to work.
startListening is overridable and calls into other code that this class has no control over. It should be the last thing in this method to prevent any possibility of other code calling back into this object while it's in an invalid intermediate state.
When I test it (in Linux) I don't see any SWT.MouseDown or SWT.MouseUp events being sent? Do you? I see them if I click on the empty space of the ExpandBar, but not if I click on an ExpandItem to expand or collapse it.
It should probably return ISegmentStoreProvider
This almost looks like code I wrote!
KernelMemoryAnalysisModule
Use Collections.emptySet() for initialization.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Why do we throw IOException here and IllegalStateException in getIndexFile()? Can we at least throw the same type consistently?
Where did 31 come from? Why not use *=?
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
please change this to simply return Objects.hash(...) to keep the boilerplate/LOC down
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
Maybe switch this around to use Logger?
Please remove system.out.println and add assertion
pvk should not be visible. Please remove it.
Why is it a list of lists, not just a list?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
can be !isDisabled()
not useful, you are not using this method outside of the AbstractEEFLifecycleManager
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
here you can get the token from the 'querystring' and issue an initial HELO message
if only passing the message of the exception, please log the stacktrace here.
nit: can you put "File connector started" instead?
The this. is not needed now I guess :wink:
Is there a rationale for exposing a public method to increment the count?
remove mRoles
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
getFullName()
Typo "...position comman**d** failed..."
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
still think that we should log when there is a not found mapping
I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?
This is working Ok.
Please only log at debug or trace
the literal translation from Kotlin throws a NPE here (because the ResourceWebscript has a @NotNull constructor argument and the calles uses the !! postfix) throwing a null-pointer-exception here is not ideal
To avoid confusion, rename the variable to sessionId.
This function **always** returns null. It appears to be an error.
Use equals - there is no guarantee that it's the same Guid instance.
Please consider to extract to a different method (like isInternalManagedDisk)
IIUC, this will return the compat version from the export domain, that by definition will be 0.10. Wouldn't we want to force the proper compat version based on the target domain?
You can replace the screen position click with TestUtils.toggleNavigationDrawer().
why is this necessary? why onTouch? please do not use espresso onView or onData operations in setUp.
this "closeSoftKeyboard()" is not doing anything, because you are using the wrong import. you are using android.support.test.espresso.action.ViewActions.closeSoftKeyboard, which is a ViewAction, so it has to be done in a perform. if you just state it outside, you create a new ViewAction object and not doing anything with it. the correct one for this would be: android.support.test.espresso.Espresso.closeSoftKeyboard, which is a standalone action like "pressBack()". so either: import static android.support.test.espresso.action.ViewActions.closeSoftKeyboard; ... .perform(replaceText(validName), closeSoftKeyboard()); or: import static android.support.test.espresso.Espresso.closeSoftKeyboard; ... closeSoftKeyboard();
We don't need another ImmutableList.copyOf. You are doing this when parsing.
null? why not just a () -> {} ?
Throw an unsupported operation exception here.
You don't have to test if the hive is in the nether, because the nether hive is from binnie and not from forestry.
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
TrackType parameter not needed.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
throw UncheckedIOException(e)?
factor out
please make sure you are rebased. this method was renamed on Feb 11.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
i think something is wrong here, when host moves to up this command is called, status shouldnt be non operational, also the reason, so this always returns true?
The operator should be && not ||
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
format should default to "tar.gz" is null or empty and not throw an exception.
You should remove that empty line.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
You've declared this method as nullable, but only use it as not null - why not make it not-null instead?
I think we will have to discuss whether or not to include the fromKafka functions in this class.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
these 3 methods are public do you really need them?
can these parameters be grouped into smaller and more meaningful objects?
never null
How about passing an already positioned and limited input stream? (doing inputStream.seek(readStart); and ByteStreams#limit outside)? If you do that then most likely you won't even need this class.
Should this constructor one just delegate to the new one with Function.identity()?
nit, Collections.EMPTY_MAP?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
do not assing parameter! nowhere!
Same issue here, double delete user.
getById
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
I think you mean (d<=0)
Upstream is already thread-safe, so this isn't needed.
Okay this is better where it can self-heal and reconnect. Fix checkstyle issue however!
I would log warn here and not rethrow unchecked exception, especially since closed will never be executed (could be wrapped in finally block).
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
We can use bit-operators here to test for the bits in the permission bitmask :) Executable is 0b001 = 1 Writable is 0b010 = 2 Readable is 0b100 = 4 So we can replace this with: java return permission & 4;
// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off
It could return 0, but should be 1 at least... no ?
reduce to debug
can not -> cannot
Use PercentType instead of DecimalType and you do not need to divide by 100.
Don't we have to say that this is uniqueId JDBC?
we should not modify the original properties. I would just return properties; here
Please use Optional.ofNullable()
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Don't we have to say that this is uniqueId JDBC?
like line 63 but this is setFeature, so should be removed?
Please fix the alignment.
This is redundant. Another ctor does exactly that:  public DefaultPointcutAdvisor(Advice advice) { this(Pointcut.TRUE, advice); }
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
This would close the connection when a service exception like TransactionNotInProgressException is thrown, or some other exception gets thrown during wrap/unwrap, right?
Unnecessary.
ChannelClosed needs to be added to (though not strictly necessary)
Unsigned types are not used in the current implementation. So, you can omit them.
Decimal is unsigned?
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
Collections.emptySet() makes more sense since it is immutable.
Apply try catch to this line only
Is this error handling enough? What are the risks of getting here?
is try catch block necessary here?
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
let's check that the object classes are also equal.
What happened to this line?
Does it make sense to do a containsKey(uniqueId) instead, or are there cases where we would have a null service instance?
That method is a bit hard to follow, could we simplify it e.g.  java public synchronized void setOkHttpClient(OkHttpClient okHttpClient) { if (OK_CLIENTS == null) { OK_CLIENTS = new HashMap<>(); } final String uniqueId = this.oAuthRefreshInterceptor.clientInfo.buildUniqueId(); if (uniqueId == null) { return; // what now? } // Valid client passed in, cache it if (okHttpClient != null) { OK_CLIENTS.put(uniqueId, okHttpClient); } // Null client passed in, create and cache one if we don't have one cached else if (!OK_CLIENTS.containsKey(uniqueId)) { OK_CLIENTS.put(uniqueId, getOkHttpClientBuilder().build()); } // Use cached client this.okHttpClient = OK_CLIENTS.get(uniqueId); }
You've declared it to be an string in the schema so why the need to convert it back to an int?
Hm, you got java doc on the next method, but not here?
Shouldn't we propogate this exception?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Should use the log, maybe a warning.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
This can simply return NON_APPLICATION and isApplicationType() can be removed. The methods will always return false.
isSensitiveAction() and isSensitiveResource() will always return false, so the calls can be dropped.
Instead of checking for action!= null, i'd suggest to simply change the order of equals, e.g. return ACTION_PROVISION_MANAGED_PROFILE.equals(action) || ACTION_PROVISION_MANAGED_USER.equals(action);
Don't you need a super.setUp() call here?
Should be added the Override annotation.
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
run already called tally, so do you need to call it again?
Why do you include the size of the binding set as part of the hash code?
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
please use parameterized logging here :)
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
It is the same in this line, leave a blanck space before "+"
More user-friendly to say "', only Switch, Number, Dimmer, Rollershutter and String items are allowed - please check your *.items configuration"
Because of the changes to supported item types, this throw message should probably be updated to something like "Items of type {} are not supported."
Restore to original. Also apply to the other similar throws.
The magic constant 2 is a smell here, can what's happening here be clarified a bit?
maybe getReturningItems, the clause suffix is not really informative.
ditto, s/i/identifier/
attr.length() doesn't do anything here, you can remove it.
This is unsafe, since attributeType is protected and can be set to null, but the contract is to return supplier only on non null values. This must be rewritten to check for the null value first.
Use "GID namespace" instead.
you can just inline this
Don't need to return the Arguments.
This should probably go to System.err, as goes e.printStackTrace()
These should get saved in a data structure so that repeated calls with the same name return the same map.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Missing types
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
unnecessary parenthesis?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
you need call addColorSettingsListener on the new instance.
initialize num to 1 and get rid of else.
you can express this in a more concise way but still readable:  return namespace.isEmpty()? name : namespace + SEPARATOR + name;
Collections.emptyList()
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
change
change
Should we use .getMessage() as in the remove() or .getLocalizedMessage() as is done here?
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
So that is getting a thread that is local so as to get the classloader?
for this purpose better use a handler and postDelayed function
looks like we're only updating the timer metric if it's a writeAround cache. I'm not sure if we should do that - metrics should be updated regardless since you're measuring the time it took for the "delete" operation right?
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
No need for super()
calling super not needed
CalDavConfig just "implements" BindingConfig. Do we need a super() here?
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
this method should be implementable
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
shouldn't this also check the "" case? Consider using Guava Strings.isNullOrEmpty
Does this method need to be public?
Isn't it worth a error level trace statement. We should be able to recognize that on a certain system that basic operation leads to a IOException
We can get rid of the above variable
suggestion List<Program> malPrograms = pws.getPrograms("MAL");
Was this implemented like so in the emrapi module?
currentRemoteHostId ?
/s/else/elseif
either if (!storageDevicesListCalls.isEmpty()) or storageDevices != null below
Why not a for each loop?
Missing @ Override
Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?
This commit appears to duplicate changes from the #430. Is this intentional? Which branch do these changes belong on? They should only be on one or the other. Please amend one of the branches to fix this.
We didn't use the custom action bar before. No need to use it now.
There must be a reason why we are hiding translation spinner here (in fact, there is a separate method for updating actionbar spinner).
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
shouldn't this also check the "" case? Consider using Guava Strings.isNullOrEmpty
This should be verify() since it's not a condition of the input
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
I am not sure it is in sync with the vdsm verb's output structure here <LINK_0>
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
Ideally, this test wouldn't require any change to pass. The aggregateType wasn't used in the past, and unless polymorphism is used, the type shouldn't really matter.
Can we use empty map instead ?
your Preconditions.checkArgument is way better than good-old asserts, now we have introduced the JAR dependency. Use it (or other checks) to replace these assertions.
So we roll back to the previous behavior that only QUEUED queries has resource group info?
I think it would be better to use a new CP subsystem specific executor, instead of ASYNC_EXECUTOR.
It looks that this should never happen. Would you elaborate more on when this can happen?
And get in the end to check that there is nothing in the collection on the matter.
I think here must be store.get(file1) to be sure that the replace hasn't affected the collection.
Use junit5 instead we are thinking about removing Junit4. There is a way in junit5 to write nested tests <LINK_0>
do we need to unvoid..?
imho it should just be write(...)....
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
The test error seems to be due to redefining the table in a transaction while the client has cached data. Consider using a new table instead of redefining an existing table.
recordCount++; doesn't work?
grammar nit: 1, not one, and no :
Can be private, I think
Do we need this?
// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
style nit: we don't use braces around single line blocks
throws IOException can be removed
closer.register(executor::shutdown);
Shouldn't we change memory reservation here?
return !sniDomains.isEmpty();
This also regresses in that it no longer works for multiple repositories.
use isNotEmpty
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
ditto. Doing nothing here is bad
This is always true. You cannot throw the null object.
I would guess we can make the rule usage more expressive with chaining calls to this method instead of passing the classes in the constructor.
@mswiderski if you want you could prevent a NPE by creating a new Set in case you're passed a null one. Also I think that it could be a good idea to declare the Set classes final.
I think this snippet is crying for some java 8 love :smile:, but I understand if you'd like to keep as is for eventual new backports
You could add a check(String sqlQuery, java.util.List<Row> expectedResult) to FileSystemITCaseBase.
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Won't this test fail on a production build because the expected exception was not thrown?
Name doesn't look right
Wondering if we want to included more information about the locks, say the size of the maps, the size of the reaper queue, maybe the versionIds. This now just logs out your configs which should be immutable representations of what is on disk. If you're going to update this, may also want to consider not returning a Builder, feels off.
The default toString on the List doesn't do the same thing?
This empty is unnecessary, I believe :)
Isn't it also important that adType was async and method was top?
Also, a test with an aligned with original OA to test the default overwrite will be nice here. Also with unmapped reads with OA tag because the current code won't overwrite them (and I guess it should).
What is the reason for appending 1 to the variable name?
This needs to tests returning multiple cash points for a single location.
can you please exchange the number with TOTAL_NUMBER_OF_RADIOLOGY_ORDERS
should hashCode really depend either on taskName, or description, or hashCode?
Simplify using Objects.hash.
Please implement toString() to provide debugging state information for debugging purposes.
Please add an explicit encoding (using 'ISO-8859-1') when converting the string to bytes.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
unnecessary parenthesis?
"Initial connection"?
Catching an Exception and just rethrowing it as-is is equivalent to not catching it at all. So the implementation of this method should be just target.stop();, with no exception management at all (much simpler!).
unsafeSubscribe shouldn't call the ERROR_HANDLER.
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
can these parameters be grouped into smaller and more meaningful objects?
Symmetry (throw)?
I would suggest create method for computing that selector and instead of replacing strings we can use string concatenation like: String.format("div.autocomplete div[title=\"%s\"]", toolName); Or we can use that inline here.
We could change the first parameter passed to PageObjectLogging.log() from "wikiDiff" to "showChangesModal".
1. make the line shorter, 2. as methods name changed, change parameter from Verify to verify
I'm not sure if we should add this to the interface. Not all implementations need to generate data ids in this method. How about removing this and instead throwing a RuntimeException at the implementations that use DataIdFactory?
Should you set the iis to null here so that it is immediately known that this is closed if you try to re-use it? I'm just concerend about someone using one of these and not realizing that it wasn't being used correctly.
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
Which type would be assigned in this case?
suggestion this.dataStoreMap = new IdentityHashMap<>();
Why don't we make inDegrees to ConcurrentHashMap also?
Any particular reason that you published an EventStatus instead of publishing an EventOutput directly? Remember that pumpEvent exists.
Every single channel has the same zero point?
Are we using dots or dashes? Either way, we should make sure that this is consistent.
Making only this message a constant only makes it less readable, and is essentially meaningless. It's a good idea to undo the fix or standardize the argument checking.
This can be static
Unneeded extra semicolon.
Check for equality of error code
Check for equality of error code
Check for equality of error code
As with Fields, this should be immutable.
Can we make this a list since it should be sorted.
Can use unmodifiableCollection()
the write call might throw an exception which results in close not being called.
We need to close the reader here, right?
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
Optional
It would be good to make it configurable whether or not the email gets masked. It's not a must for now but I'm willing to bet that someone will create an issue for it in the future.
Maybe make this a static final List now that is is used two places? (here and line 123).
No, this. when you call methods.
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
add this selector to UI mapping at the beginning
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
please also add the GUID which is important.
These 3 methods should be private, or if useful outside of this controller, they should be in a utilities class
before accessing it's property, wait for element
Do we need the toString() here?
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
Should we check that the value is either positive or equal to UNKNOWN?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Please just use a mod here...
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
add this selector to UI mapping at the beginning
so this String.replace will be String.format(blah, blah) as per the above
please avoid the string replace
I don't think you need this new String
Is order important here? Should the 2 collections correlate each to another?
finalize?
maybe, would not be keeping the map null better, to ensure uninitialized mapper will not be used accidentally? (even NPE is better then complex debugging why roles are not mapped...)
If possible, generally please make all values final. It is one of the main rules to achieve functional programs.
(minor) I would test the positive condition isEmpty() and swap the cases. It is less information for the human brain to process and ! can be overseen
Can we compute this lazily only once hashCode is called, then cache it in an instance field?
finalize?
nit, Collections.EMPTY_MAP?
Is order important here? Should the 2 collections correlate each to another?
Needs to consider the new custom fields.
What about hashcode and equals, should they need to be regenerated with the new boolean
this can be simplified by using Objects.hashCode(commandId)
lowercase for package names.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
Remove throws Exception
Lists obtained from a message are immutable. No need for extra copying.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Lists obtained from a message are immutable. No need for extra copying.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
if test is in same package, then visibility can be default
synchronizing on an object that changes in sync blocks is not good
return Collections.emptyList();
I don't see the api for CosmosContianer (sync version). could you please add that too.
You don't need this line because of green 31.
What about if there's an error? Make sure that done gets set back to true. Or at least report something.
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
not so readable. looks like good candidates for parametrization
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
Well, if we know the Exception so its not really "unknown" :-)
Why this debug log is removed? Not sure, if it's there for any security issues.
Is this a reason to have separate if statement instead of while (!shutdown)?
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
This looks like it's just for card payments so don't think we should add these her.e
java String desanitizedCourseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(obj1.course.getName()); String desanitizedCourseName2 = SanitizationHelper.desanitizeIfHtmlSanitized(obj2.course.getName()); return desanitizedCourseName1.compareTo(desanitizedCourseName2);
If there is only a single comparator (i.e. no .reversed, no .thenComparing), you can omit the type since the block can benefit from type inference. java courses.sort(Comparator.comparing(obj -> obj.course.getId()));  Applies to many other parts of this PR.
Be careful, this is reversed.
We may want to log a warning when files are _not_ applicable, since that would indicate that some kind of junk had been uploaded.
there is Long.hashCode(long value) method.
minor return (typeID & FLAG_UNKNOWN_SIZE) == 0; instead?
May be it is better to cast meta to BinaryTypeImpl right here?
Reference is supposed to be URL, I don't really understand why reference instead of Publisher and Name is returned here. Could you elaborate more?
An error during reading a bloom filter should not block the reading of the data. For example if the bloom filter is corrupt somehow the you throw a RuntimeException which would blocks the user to read the data. If it is a low level I/O problem then it will fail with an IOException at reading the data anyway. I would suggest logging the issue and return null instead of throwing an exception.
consider renaming this to detectLanguageBatchWithResponse to be consistent
"0"?
This method always throws an exception, however, it's not clear from this code that the method ends here. I was assuming that it would still continue to return SimpleResponse before looking at toTextAnalyticsException() method. Instead, return the exception from toTextAnalyticsException() and change this to throw toTextAnalyticsException().
it doesn't work for multi reference + complete tests please.
Inverse order.
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
Preferably have one call the other?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
could use matcher.matches here I believe
Is there a chance of a NPE? could be getFile() null?
You could maybe use enclosingClass to save a few hops...
Collections.emptyList()
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
this will already return the permission subject on the target cluster so no need to modify this method, right?
add if (o == this) return true;
- you're not checking for equal identity - passed object could be null
won't this throw a runtime exception if the other object isn't a Page?
take a look at how the output schema is generated from the inputSchema, <LINK_0>, if it is not in the mapping list, it is identity, if it is, it gets mapped to some other value.
This is similar to Compressor
This is similar to Decryptor
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
Should be DRYer to extract a method to update the texts of all 3 stats text nodes, as they should be updated together (either all or none). So I think it's not a good idea to just update the totalIssueText like in the if branch.
String.valueOf() shouldn't be used to display integers since it doesn't consider the user's locale. Use i18n.number() instead.
Can't we do this once at the start, since we always enable(true)?
The config should not be explicitly saved (it already is when ZAP shuts down).
I think isDisposed should also be checked here, right?
Method doesn't appear to be used. Can't use day-of-year here anyways, as leap-day would make it behave strangely.
You should be returning the values returned in getCalculatedProlepticMonth() here instead (ie, that leap-day is accounted with the 7th month, and year-day with 13th). Ditch the other method.
suggestion // Align up to 4k final long align = 4 * 1024; return ((arenaBlockSize + align - 1) / align) * align;  Marking the primitive variable as final would make it a constant variable and help the compiler to do optimization, please check [here](<LINK_0> for more details. We could also make it as a class-level static final field, but keeping it here directly maps to the RocksDB code.
nit: can you put "File connector started" instead?
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
RuntimeException would be sufficient
Another getBytes(StandardCharsets.UTF_8) opportunity
Should we put the check here too?
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
This method name does not reflect what the method does. Maybe call it "applyBuildersValues(conf)" or something.
Do we want to check both getProjectId() and getJobProjectId() here?
If Mongo DB Name and Rya Instance Name are always the same, why not just have one of those fields?
I don't think copy is required here. Even if we did this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
remove this too
Nit: merge this with the if above.
Please define resultcode before using it. int resultCode = intent != null ? intent.getIntExtra("result", 0) : 0;
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
Given it's for a test, I don't really care but... I much prefer using higher-level synchronization utils from java.util.concurrent whenever possible, rather than synchronize. An object.wait() can wake up prematurely, which is why one should always wrap it in a while block rather than an if block.
new method in basis will replace this
Please implement toString() to provide debugging state information for debugging purposes.
Does the operand really can be null?
generate hashcode again, it doesnt account for caseSensitive.
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
If there is a rich-text change, then insertedLength or removedLength is non-zero already. You probably want to first map and then filter out plain-text changes where removed.equals(inserted).
Is this still true in the latest Ehcache version? Based on that error messages it sounded like we should be doing instead just: c.setEternal(true);
![MAJOR](<LINK_1> Remove those useless parentheses. [![rule](<LINK_2>](<LINK_0>
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
> new Date(mExpiresOn.getTime()) [](start = 15, length = 30) why are we returning a new object? #Closed
I think we have to make as BlockingQueue and use its poll(timeout) to block the testing thread for the message from the async internals. There is no guarantee that all tests are going to be direct and sync. WDYT?
You don't need this internal method at all. The overload on top can call this method with transaction context as null.
I don't see the api for CosmosContianer (sync version). could you please add that too.
make this constructor private since all the methods in the class are static.
Just curious, why do we need to change the access qualifier to protected?
package private? @SuppressWarnings("WeakerAccess") /* synthetic access */
int[] props would make everyone including the style checker much happier
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
use arrays.copy? or system.copy?
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
In this impl, JobCoordinator is responsible for the life cycle of containerController. If we add awaitStart(0 inside JC, then there is no reason why StreamProcessor needs to know about containerController anymore. Can we make this cleaner?
Can this be private, or is there another use case for default attribute outside the builder's call?
You can use assertTrue and assertFalse instead of assertEquals for these tests :)
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
Braces on following line
suggestion Objects.equals(value, other.value);
Objects.equals
Objects.equals
you can do something like CategoryField.class:: isInstance
Please change this to  java return new ArrayList<>(failures);
Have you tried Collections.sort(fields, (o1, o2) -> {})? It'll save you from having to turn this from a list to a stream, then back into a list.
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
Should be 'contains'
@pstorch can we describe mismatch better here?
Another minor note, any reason not to merge this into a single check? if(values == null || values.isEmpty()) return true ;
I'm assuming the JVM will figure out not to make a new string here every time...
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
I would suggest making this method synchronized
there should be a break after this line. we don't want to fetch everything, just one element is enough
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
The ListenerList implementation already takes care of this. Remove the "contains" test.
No use checking if the list contains() before remove(), let's avoid double iterations.
The synchronized block needs to include this read from the map: - Thread 1 reads eventNameToListenerMap, gets null - Thread 2 reads eventNameToListenerMap, gets null - Thread 1 enters critical section, creates new HashSet containing listener 1 and stores in eventNameToListenerMap - Thread 2 enters critical section, creates new HashSet containing listener 2 and stores in eventNameToListenerMap Listener 1 has been lost.
canConnect( server.address(), clientGroup ) can be extracted to a no-params method
Shouldn't this apply to more code above? (the try block) Too bad we can't use java 7 constructs.
I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter.
negative logic
negative logic
Why did we switch out the old code back to this?
Why not declare GLOBAL_ID as a long?
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
could we use a descriptive value instead of empty string to denote the header was null?
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
I think JPA requires this to return a Long
Should use Long.class
More functional variant:  java Class<?>[] interfaces = serviceObject.getClass().getInterfaces(); return Arrays.stream(interfaces) .filter(interfaceClass -> interfaceClass.isAnnotationPresent(Service.class)) .collect(Collectors.toList());
null != settings
I don't really like using a null check to signal failure. Maybe have a isFailed method instead, with a markAsFailed(String) helper as well?
This could be confusing here. How the user know the all fields?
should this be splitted into several try/catch blocks because now the httpPoolingClient might not be touched if httpClient.close() throws an exception.
What's the purpose of this change
Should this be in the try-finally block? Right now, if out.close() or out.flush() throws an exception, we'll not null out and, if close() is called more than once (albeit unnecessarily) then we'd call close or flush another time. It's probably simpler to just ensure we null out in the finally block.
What is this for? Feels like some unintended checked in code?
Did you just forget to remove the above printStackTrace? :)
Should use the log, maybe a warning.
What is the boolean here used for?
perhaps if not has permission?
What's the point of the 6 trailing zeros ?
note when rebasing that i added the following here to handle missing data:  if (data.numHetsInSegment(segmentIndex) == 0) { return Double.NaN; }
nit: you can merge both lines above as checkNotNull will return the given argument
It seems that the only advantage of breaking apart the AlleleFractionState is that we can avoid the issue of shallow copies referring to the same AlleleFractionState.MinorFractions list when making proposal states?
Should be outside the if
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
I think that this check makes more sense in the "getClusterId" method. Can we move it there?
This can just be catch Exception.
This is a bad idea, it will still make JCasC to fail in unpredictable way. I would rather expect an explicit failure to happen. If it is not possible, better to log a warning to the system log
consider catch(Exception e) { throw Throwables.propagate(e) }
How about a test for an override in a nested class?
this method should probably be final. Also it is missing the @Override annotation AFAICT
@Nadahar Right, text/vtt, i was too fast...my bad.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
unnecessary parenthesis?
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
Here we could try to store the ObjectMapper in a static field - preferably in a package protected helper class. This way we would avoid that we recreate it again and again. And as far as I can see this should be thread safe too. What do you think about it?
We should at least resolve the Type at construction, so that exceptions are thrown as early as possible. The qualifier lookup can still happen in the build method though, and satisfy the purpose of this refactor.
Maintenance of the map will be simpler than that of the list
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
add this selector to UI mapping at the beginning
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
It is confusing to have unrelated asserts in one test method, please split those into separate tests.
@dmzaytsev Now we can incorporate this into the string above - no need for Matchers.allOf  java Matchers.containsString( "Set-Cookie: foo=urn%3Atest%3A99;Path=/;HttpsOnly" )
@fanifieiev the same above.
Why not check result.isEmpty?
Why not check isEmpty()?
Can you use isEmpty()?
This could be replaced by Folder::new.
@dmzaytsev We should be able to inline user, alias, and inbox, since they are just one-use variables.
@erimerturk use MatcherAssert.assertThat
@pefernan here the message should be: logger.warn("Unable to parse value of " + KieServerConstants.KIE_SERVER_MODE + " = " + modeParam + "; supported values are 'DEVELOPMENT' or 'PRODUCTION'. Falling back to 'DEVELOPMENT' mode.");
when calling jgit fetch --recurse-submodules origin without a value for --recurse-submodules (which is accepted by native git) this fails here with the error "fatal: Invalid recurse submodules mode: origin". Maybe that's a limitation of args4j. when I reverse the order jgit fetch origin --recurse-submodules I get "fatal: Option "--recurse-submodules" takes an operand" jgit fetch --recurse-submodules yes origin yields "fatal: Invalid recurse submodules mode: yes" The only working format seems to be the following: jgit fetch --recurse-submodules YES origin so it seems the detection needs to be made case insensitive. BranchRebaseMode has the same case-sensitivity problem. would be true, false also valid option values ?
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Since this is an opaque entry, then you know for fact that the arguments array is an array of byte[]. So you don't need to allocate a buffer and do the copy just to calculate the size. java int size = 0; for (byte[] buf : arguments) size += buf.length; size += (SMRMethod.length() * Character.BYTES); size += Integer.BYTES; return size;
The problem with this approach is that there can't be any cross-thread pipelining because one thread won't progress unless the other thread does 1 thing. A better approach would be to request in bigger batches and re-request after a certain proportion of the batch has been received.
nit: you can merge both lines above as checkNotNull will return the given argument
is this complete or startSnapshotApply? it seems the semantic of that method changed, we should also revisit the messages that are within that method.
return void
seems like a string that should be stored as a constant and defined only at the side who returns this message to prevent breaking this assumption - unless it isn't doable
same here (using getNode)
This doesn't seem like a very detailed test unless we have one that is more complex than this. Can we have a test with more then 1 AST to show we stick with only the first one even if there is more.
In every other test, you name variables ast, ast2, etc. and you put them in order of variable names. This is the only one that breaks that pattern. Can we make the layout here similar?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
This was already a problem with this in the old code, but the parameter name strings and values are mismatched here.
When can the name be null? If not possible, then add an assertion.
I'm guessing merge/rebase error. RequestManager method was the correct source for this. Controllers shouldn't require database knowledge (jdbc/table names)
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Return an [ImmutableMap](<LINK_0> or create an ImmutableMap with [ImmutableMap.Builder](<LINK_1> when loading the services?
size is calculated here. Do you want to change sizeCached to true?
4 spaces
4 spaces
The last assert is different from the first 2
I guess null check is also will be nice to see here. Like java assertNotEquals(a, null); b.setDefinition(null); assertNotEquals(a, b); assertNotEquals(b, a);
Also, null check will be cool there.
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
Set fileEventHandlerRegistration to null.
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
nit, Collections.EMPTY_MAP?
usually data objects never return null where collections is met
Coding best practices: Interface i = new Implementation();
Can just use diamond operator on RHS
unnecessary new line
maybe we could make shortcut for: FeatureSelection.all().without(ENGINE_ONLY).build()?
Does this mean HTTP is not tested in this class any more?
import EventsBuilder
@fchauveau there is no null handling of source, is this intended ?
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
Looks like even the brackets around i == j is not useful?
Is there a reason you chose _system_name environment variable instead of the os.name system property as described in the [Java properties](<LINK_0> tutorial?
The log should rather say "Destroyed all file based persistence context" instead of "Destroying..." as the logging happens after deletion was done.
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
I believe it would be more understandable to do the following:  // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Change back to urlEncode(filePath) after fix to AbstractApi.urlEncode(String s)
This method is defined twice causing a compile failure.
Override
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Better: '|'
Should this try to create a URI with the old logic when it's null for retro compatibility ?
It's wasteful to be calling getRequest() in these methods. Consider taking in the original Request and storing it in a field alongside the mutable result of newBuilder()
Should be setAppend()
This is effectively your synchronization barrier? After fetch(...) returns, you are guaranteed that the value will be populated in the cache, assuming the writer is utilizing the same cache. Am I understanding this correctly?
Putting fetch inside get() might not be good. If this api blocks writer, writer can starve because fetch can really take a long time due to hole fills. If this api doesn't block writer, then the NoRollBackException issue will still occur quite often as this reader may override the writer's value with no undo record.
same as for AddAddress here
Why is the EMF specific RP is the default? Should this method (and the class) be abstract to indicate that a specific result provider implementation shall be selected?
calling geteAttributesByTypeForEClass on a generic LS backend should throw an IllegalStateException.
Here one could advertise the existing Hints.GEOMETRY_CLIP, so that the StreamingRenderer instantiates the clipping collection only when needed.
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
are these setters used anywhere?
Please make the constructor private (see Invalid).
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
new HashMap<>() will do
better to return an Empty Map, otherwise callers would need to check
please apply formatting
No quotes at all? This won't work with drillthrough operations, where the column alias might be two words. Not quoting them will create invalid SQL.
No key for encryption? ;-)
s/Kills/Kill
File
(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
We need to also support platform 2.1.*
What do you use refRep for?
Don't you want to do different things depending on whether it is the default or full representation as we do for other resources?
revert as this code isn't used in this PR
Hm, should we thrown it as InternalProcessingException ?
This should be imported.
Should be a space after ,.
Assert.areNull
assertNotNull ?
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
What if the key is negative?
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Nitpicky stuff: This method performs the key lookup twice when you could do the same operation with only one: JsonNode node = json.get(key); return node != null ? node.textValue() : null;
Maybe it's better to use Collections.emptyList() instead
Person id seems to be read as an optional field from the json. Is it really? If yes, then parseLong will fail with an Unchecked exception force-closing the app. If person id is indeed optional then we need to handle this. OTOH, if the person id is not optional in the json/api then the more expressive getString() better be used. That one will also force us to handle the potential error in the json. All in all, we need to handle any potential error here since personID is part of the DB table's key and better be trustworthy. Cheers!
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "key". [![rule](<LINK_0>](<LINK_2>
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
This is a great optimization. Should this point to first character in the ASCII table ? Also lets verify that this for UTF-8 encoding as well.
remove the explicit initialization?
contents may be a better name
Use Scanner instead so that large files are not loaded into memory at once: CSVParser csvFileParser = CSVParser.parse(new File("filePath"), csvFileFormat); for (CSVRecord csvRecord : csvFileParser) { ... // qualify the csvRecord; output qualified row to new file and flush as needed. }
I think this check can be stronger. Rather than checking the comparator's equality, why not check the underlying type? This check would allow merging stats for binary and binary/UTF8 types, but I don't think that's right.
Usually we use: if (owner.isUsedForPartitionedRegionBucket()) { instead.
This seems unnecessary. On the other hand, this is the default value when it's unset, so I'm fine with leaving this.
Extract this try-catch block to a method to avoid code duplication
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
I suggest including the uri in the exception message
Shouldn't that be Class<?>
suggestion return Collections.unmodifiableMap(tags == null ? new HashMap<>() : tags)
for the boolean parameter could be useful to use enums, so that it is more clear what it means
you turned around T & I here, it should be declared as:  protected <T, I extends T> @Nullable I getService(Class<T> clazz, Class<I> implementationClass)
CanonicalizingHashSet is an internal class. It should not be visible in the public API. I think this part should stay as Set
Would Collections.unmodifiableList(submodels) be better in this case?
omit using return in void methods, it is less readable and it is hard to debugging
Activity state util check before starting any of this, maybe?
Remove this check? It will throw NullPointerException if it's null, which should never happen.
Interface is one word, so no camel casing here
I think the older version checked empty string and this change removes that check on the username?
Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Shouldn't you add a inQueue = 0; here?
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
HashUtil.combineHashCodes
Revert this. referenceExpression is non-null AFAICS
Would it make sense to rewrite equals to avoid #toString since this is a rather expensive equality check. That would allow for a more efficient #hashCode, too
return only if the provider is an AnalysisModule?
rename smth like getOrCreate?
I think this should be handled like the TimestampRangePredicate. Make a RegexPredicate extend IndexPredicate and have RegexFilePredicate extend RegexPredicate. Here use RegexPredicate inside of the EXACT field type to handle regex.
So there's a bit of a elegant hack to doing this: You can redirect to do the same as the original method, and then override this injection method in VillagerEntityMixin to do all this logic that otherwise you'd be doing. I do this with WorldMixin_Tracker and ServerWorldMixin_Tracker to do extra logic only on server worlds for injections that are in the subclass.
Should just be world, ToStringHelper automatically formats and uppercase keys look odd.
Should just be dimensionId, ToStringHelper automatically formats and uppercase keys look odd.
please use vmDisksSource here as well
perhaps change to if (disksNotExistInDb.isEmpty()) { return true; } as the lines are bit long here, it'll take the whole code an indentation left.
How about Collections.emptySet() ?
Should we return immutable list here?
This should return the list of resources under it, see FileResource impl for more details
please remove else, code will be more readable
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
Consolidate this method with its coordinateStringsFromQuery implementation method.
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Work is generic, so add <?> at least
Make sure to return a read-only version of the List (not set) here. We don't want people to think this is the method to register interceptors.
Could you at least make this return a non-null value?
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
Use fileContent.trim().length() == 0
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
If this is on the write side, keep in mind that texts can be reused.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
I believe the Sanitizer call is not needed here.
The this. in getters are unnecessary too.
Maybe we want to keep something similar to what id was before
Might be worth having a displayName?
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
This line is redundant.
Is it really worth checking before setting it?
This method should be private in visibility.
Looks good, but it will work only once. If I run it twice, the second execution will fail, because a repository with this name (test-repo) already exists. There are two options: 1) generate a unique name on every test run, using RandomStringUtils, for example, 2) delete the repository after test execution in finally block. I would recommend to use both options.
why not just repo?
No, this. when you call methods.
@xpdavid is this the right thing to do?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
nit: just a personal preference, but getting one less internal reference to a public function all makes the code usage check easier, like features.get(feature).
What is purpose of this method?
what is the point of disallowing cheap (eOpposite-based) inverse navigation? How about checking this switch only in case we have to rely on the index to navigate backards
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
I'd suggest logging the exception here, might be useful for debugging. Probably include a message indicating the consequences (the punch table may not be updated until the first user transaction).
can this be readSafely instead of readBuffer so that read uses readSafely
suggestion bannedColumns.add(COL_ID_ACTIONS);
Nit - just return Arrays.asList("createSockets", "getInsecure") instead?
why is it adding null?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
again, you need to print the state if you want this to be debuggable
Have we got room to always use 3dp
This is another behavioral change that I don't want to see in an unrelated PR.
I think we get an IndexOutOfBoundException here. You probably want to check something lke this:  List<String> values = settings.getTagValue(tag); return values.isEmpty() ? defaultValue : values.get(0);
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
I'm missing the new field in the toString method.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return false and let's drop the first looking into file...
throw new RuntimeException(ex); so that we will just wrap the original exception and it's message and stacktrace is visible.
It might be confusing to say 'Overwriting' at all times. If the file doesn't exist, which is the norm, isn't exactly 'overwriting'. Is it a burden to check if the file already exists and make the log message indicate that? Not sure if it is really needed, but it might be nice to see how often this happens.
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
I think it should return Array here.
I think it should return Array here.
Do we really need to check anything here? Surely the enterprise edition supports all constraints?
The implementation of this method will never return a null element. I think the annotation is an overweight of the method. IMHO it is better to update java doc to said the method returns not null value instead of adding a runtime check on every method call.
Instead of check(Rule... and check(Context... (which may be enriched with others in the future, simply have a DefinitionTransformer pass that does nothing but this check, or use the AbstractReflectiveVisitor.
<String, Object> not needed.
I think it's better to replace this(type, data, new ArrayList<ColumnDef.TYPE>().
not public
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
Will * <LINK_0> * <LINK_1> work as well?
return Collections.emptyList();
is there no common place (at the broker level) we can add the unioning query runner?
You don't need this line because of green 31.
You can use && instead of nested if
I would suggest exposing the max length from the validator and using it here so we ensure they do not vary independently
why can the operation name simply cange here? (see the setter). In addition I think a simple direct string might be the option easier to read?
extra space.
You should assert the error message is correct and points to the right line.
weird indent. put is(... on the next line to be more readable
singular
I would prefer not to use null ... just a empty set and then assert that its not null
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
docIds.size() > 0 -> !docIds.isEmpty()
Can we have values in both m_left and m_args? If not, is there a debug assert somewhere?
Can you rename the requestIdList variable to something a little more generic?
Throw an unsupported operation exception here.
an empty ArrayList is better than a null
How would you feel about making this passed as a json property in HashedPartitionsSpec and add it to the docs, so that people can use it ?
this field name is confusing since the parameter passed to the constructor is a File but this is a PackFileName, maybe better packFileName
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
There is no need to call super explicitly. Same applies to other constructors.
Why did you make this change? Seems unrelated.
- shorten to assertJtsEnvelope("MULTIPOLYGON EMPTY", new Envelope()); - ditto other tests
What a reason to have a public class without any public methods, with one package private method? Consider making class package private or method public.
recipeFileContentProvider param is missing in java doc. DevfileRecipeFormatException is not desribed in @throws section
There's a factory method FileContentProvider.cached() that's maybe slightly more readable
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
How about make "filter" to a constant(KEY_FILTER) in NotificationListFragment, since it's an argument key and many place need to use it. typo it may cause bug in other place.
Use mDialog here if we're going to null check in the if.
This test checks topic creation. Why do you call replyTopicStubs?
Duplicates in createTopicStubs
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
@pynicolas Can't we just compare hash codes instead?
not null safe
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
Maybe we should also deny requests while recovering after a shutdown
Was this detected by findbugs?
To avoid the magic number, let's use HttpStatus.TOO_MANY_REQUESTS_429 here.
This also regresses in that it no longer works for multiple repositories.
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
I think <code>@nocollapse</code> should only have an effect on the declaration site of a name, not on any random assignment to the name.
unused?
I'd say "block end cannot be before block start"
+/- 1 confusion: suggestion this.startDistance = start;  that was the last one.
PG_TYPE_TO_NAME should be an array (dense)
use containsKey method
use sparse array
Did you take a look at this? <LINK_0>
Did you take a look at this? <LINK_0>
Did you take a look at this? <LINK_0>
Please remove this empty line.
Maybe  message.toLowerCase(Locale.ENGLISH) .contains(Const.ACTION_RESULT_FAILURE.toLowerCase(Locale.ENGLISH))) {  instead:)?
please add curly braces here
missing @since 4.5 for new API method
How would you feel about making this passed as a json property in HashedPartitionsSpec and add it to the docs, so that people can use it ?
an empty ArrayList is better than a null
@dmzaytsev let's extract this into a private final String variable.
@exper0 same here it can be inline
@d-molotchko reference the static variable with the full path
Need to check the hint is not null.
It's not correct to check SWT.NO_MOVE with equals, instead use bitwise operation (style is a bitwise OR of one or more SWT style constants). I think we can use the below code in Decorations.checkStyle() on all platforms. if ((style & SWT.NO_TRIM) != 0) { ... } else { if ((style & SWT.NO_MOVE) != 0) { style |= SWT.TITLE; } }
If it doesn't have the right coordinates it's probably not useful ;)
You can make this method private
Wait, this is worse than the previous version. What happened to the assertEquals()?
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
what is the reason of this change ? I think you should revert to "this" instead of null
Good thing to call that. However it should go in a separate @After method
I don't think you need this new String
this is confusing, it is called router but actually it is routerUrl.
check this
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
why we need to check if peerLeaderReplicasByPartition contains partitionName? I feel it's unnecessary.
why should add lock here?
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
Feels like this could be less complicated. How about return ((getLabel() == null) ? 0 : getLabel().hashCode()); figuring that Favorites without labels are all equal and where they do have labels String's hashCode() implementation is just fine as-is?
How about return Objects.hashCode(message, Integer.valueOf(desiredCaretPosition)); ?
We have a removeConfiguration so let's not allow null value here?
There's a simpler way: java return Optional.ofNullable(counters.get(key));
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
lowercase for package names.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
speces before and after "+" :)
Debug has to be detected first otherwise we'll always take the INFO branch.
Looks like epoch and reset logic should be pushed to pool as generic solution. Isn't it ?
channelId => channelName
How about Collections.emptySet() ?
And if this sub-stream were extracted into its own well-named static method, the code would now be perfectly readable and self-explanatory.
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
Move this validation to PluginProfileService.
Move this validation to PluginProfileService.
run already called tally, so do you need to call it again?
What is the purpose of catching this exception. If this thread is interrupted it sounds more like an IllegalState somehow?
Should we add logging to indicate this condition?
Should we add logging to indicate this condition?
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
typo: you have two "f"s To avoid such typos, please copy from the config directly. These are quite hard to catch and we are not always looking for them.
Write 20971520 as 20_1024_1024. Ideally, Default annotation would support this approach too, but I know we don't have that yet.
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
Ah - guessing that we are using static Bugsnag everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?
Is it going to return null in case the request is not authenticated?
What do you think about Comparator.naturalOrder() instead of null ?
java this(parent, batchSize, supplier, excludedKeys, topologyId); this.currentTarget = Objects.requireNonNull(specificTarget);
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
remove.
That's not exactly true. Instead you should have separate array for columns and get column directly bu x/z coords
Style-nit: We don't use curly braces around simple loops.
Should we make special code for null (maybe by comparing size of this vs. size of hash map).
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
This is a bug IIUC. This must be an &&, or any GitHubPushCause instance will be seen as equal?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Why wasn't this left as-is? I'm fine with it, but it just didn't follow the pattern of the rest of the PR.
this place need to judge if it's a IdleStateEvent
replace with ReferenceCountUtil.release(msg)
Add default to the switch
tab starts this line, we use spaces to indent code
why exit here ?
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
There is no basePath null check but let's use basePath param optional. By default, download endpoint can let download the recording in downloads directly. If customer wants to specify path then they can give basePath variable. What do you think? We can make this change because there is no specific constraint on developer doc.
If component is null, this will have NPE'd by this point if typeMapping does not happen to be a type that allows null keys (most don't)
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
please move calculateScope(ast) inside expression to speedup a little bit performance, scope calculation is not always required.
This can be easily replaced with a loop. How deep this recursion can be?
Why do we ignore annotations under ANNOTATION_DEF?
Please move this method and patternIsEnabled to the end of the class, similar to PassCodeManager class
what do you think to write it return module.length > 1 && all.length == 1 && all[0] instanceof IModuleFile;
This shows you don't know about optimization at all.
times(1)
Is this test passing? I would expect 'false' here
Static import SECONDS. I usually set the initial delay to the same value for services like this.
I'd prefer to have a createAndSetUpSlotPoolWithoutResourceManager() to replace createAndSetUpSlotPool(false).
I prefer "Error while waiting for the task to be started.", the exception should inform if it's a timeout, etc.
We should check the future for exception here also. Also we aren't logging any kind of message for a failure any longer, we should make sure those are logged as well.
Consider returning a constant
@Nadahar Right, text/vtt, i was too fast...my bad.
Should maybe other countries be added here?
return onCancelled()?
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
nit you can merge these lines
must be immutable :  if (null == this.map) { this.map = .. } else { throw new KasperException(..); }  if you can add this also on the CollectionQueryResult it would be really appreciated :)
new ArrayList<>();
Please use ConcurrentHashMap, the implementation behind Maps.newConcurrentMap() has higher overhead and is less scalable.
Would effectively revert [JENKINS-60088](<LINK_0> Exposed labels in Kubernetes have no effect on the Jenkins labels. I would recommend reverting this hunk.
I am not sure the changes here improve the situation. It would probably be best to change this into a String.format(...) call... or at least to format the code to remove the many line breaks.
This is no longer needed if MVs dont support indexes.
By composition, do we need this?
If an exception is expected, should we fail if the exception is not thrown?
I think there's also hasMessageStartingWith. AssertJ is crazy...
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
This should not use hard coded host names, as it will fail with IPv6
Don't do this because it will result errors in system which don't have this. I have a GPDB demo vm's and its gpload is:  $ cat /usr/local/greenplum-db/bin/gpload #!/bin/sh if [ ! -z "$GPHOME" ]; then . $GPHOME/greenplum_path.sh fi if [ ! -z "$GPHOME_LOADERS" ]; then . $GPHOME_LOADERS/greenplum_loaders_path.sh fi if [ uname -s = "AIX" -a ! -z "$GP_LIBPATH_FOR_PYTHON" ]; then LIBPATH=$GP_LIBPATH_FOR_PYTHON:$LIBPATH export LIBPATH fi  Don't have greenplum_loaders_path.sh and job then fails with:  2015-04-08 03:29:14,432 1.2.0.SNAP ERROR task-scheduler-3 gpload.GploadTasklet - gpload job finished with exit code: 1 2015-04-08 03:29:14,434 1.2.0.SNAP ERROR task-scheduler-3 gpload.GploadTasklet - gpload err: /usr/local/greenplum-db/bin/gpload: line 6: /usr/local/greenplum-db/greenplum_loaders_path.sh: No such file or directory
BlockPos.ORIGIN
A little wasteful when all you need to do is just set the fields and return this...
What's the point of the 6 trailing zeros ?
Any reason to use an unmodifiable list as the list is already a newly created one?
Closed channels are automatically removed from a channel group. This line can be removed
should this use Objects.equals JIC null safety is required?
avoid using \n, I remember windows contributors having tests failing because of such usage.
Spacing is off here, do you have the code templates installed?
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
any special characters to block in webhook name?
you should probably check Item.Configure here
You may want to assign labels to this node; it's marked to only run jobs that are exclusively tied to itself or a label.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
could be made static
Is it guaranteed that requestObject is a SmartMeteringDeviceDto !?
what is wrong with this implementation is that it will fail only once, on the first class. and in order to catch the next one you should run JUnit again. Instead, would be much better to do:  java MatcherAssert.assertThat( Iterables.filter( classpath.allTypes(), new Predicate<Class<?>>() { // filter it out if it's one of the types we want to exclude } ), Matchers.everyItem( new CustomMatcher<Class<?>>("annotated type") { // .. } ) );
It's a good idea to run your tests before submitting them to Gerrit.
maybe test first char for empty letter as well to reuse s if possible?
Just an FYI for future - You can use this method for this: <LINK_0>
Why : is in brackets? Why you only check capitals, you sure drive letter cannot be lowercase? I think windows case insensitive so it could be if user typed lowercase.
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
It turns that we need Tx validator sets managed by Spring config and instantiated there for each specific case. This would make BlockMiner and PendingStateImpl clearer
Use if here instead. We don't nest LazyBlocks
Tiny style thing, can we put brackets round boolean expressions like this e.g. boolean valid = (files != null);
should this be valid &= ?
This method might be the one in public.
The constructors should be package private
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
Missing StringUtils.isNotNullOrEmpty() check
Actually the underlying objectExpr could have free variables.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
I think this could be logged as just debug.
merge ifs?
could this block be simplified?  java public MerlinBuilder withRxCallbacks() { rxCallbacksManager = new RxCallbacksManager(); if (connectableRegisterer == null) { withConnectableCallbacks(); } if (disconnectableRegisterer == null) { withDisconnectableCallbacks(); } return this; }
@bdragan transformed variable is redundant, it can be inline
this and m_ is redundant
Using Builder pattern is preferred since the structure can be easily changed.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
This line gives a warnings in Eclipse because implicit boxing between false and Boolean.FALSE is used. Better import import static org.junit.Assert.assertFalse; and use assertFalse(repo.getObjectDatabase().getPreservedDirectory().exists());
If there is nothing to draw, what about just skipping the drawing and return 0?
labelX should be x + ...
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
IDE hints to replace source.map(x -> entityConverter.convert(x)).filter(x -> x != null) with source.map(entityConverter::convert).filter(Objects::nonNull)
I think we already fetch a full list of slaves somewhere before this. Each of these would be a zk call currently. So, we should either: - Add slaveManager stuff to leader cache so this is all in memory or - Pass through a list of slave data we have already read from zk for use here
This piece of code really would be easier to read:  haxe ResultHolder typeResult = getType(null); ResultHolder resolved = resolver.resolve(typeResult.getType().toStringWithoutConstant());  The way my mind works, I read getType(null) to call a local function, and the following getType() I also presumed to be the local function -- which didn't make sense. It took at least a minute just to figure out what was going on in that line; basically that the return value of getType(null) was not the same type as 'this'.
This line is redundant.
I think it's nicer to call the AnnotationCommandTargetResolver constructor here, with, as suggested earlier, this as the sole parameter, so that the AnnotationCommandTargetResolver constructor can pull the identifierAnnotation and versionAnnotation from it.
Can call the method directly, instead of using reflection. return FieldValidator.getPopulatedEmptyStringErrorMessage(...);
I think the annotations should be on separate lines
I think we will have to discuss whether or not to include the fromKafka functions in this class.
you added synchronized to the method here, wanted?
If there is nothing to draw, what about just skipping the drawing and return 0?
labelX should be x + ...
Use isZKLogAvailable() instead
use waitResponse()
Assert.assertTrue(jq("$innerLabel").exists()); Assert.assertEquals(jq("$innerLabel").text(), "someValue");
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
456L
Where does the 5 come from? I feel like we should just throw an exception here.
I wonder if it might be possible to format the matrices here in a more intuitive way? Something like the following (last row example): java @Parameterized.Parameters(name = "{index}: checking first row of matrix constructed with string \"{0}\".") public static Collection<Object[]> data() { return Arrays.asList(new Object[][]{ {"0", new int[] {0}}, {"0 1", new int[] {0, 1}}, {"0\n1", new int[] {0}}, {"0 1\n2 3", new int[] {0, 1}}, { "0 1 2\n" + "3 4 5\n" + "6 7 8", new int[] {0, 1, 2}} }); }  I find it a little easier to draw the connection between the input and the expected output with that formatting, but others might disagree...?
Do these strings all need to include the escaped newline? Everything seemed to work ok for me if I replaced all occurrences of \\n with a simple \n? On a related note, would that change make the matrixAsString.replaceAll("\\\\n", "\n") lines removable too?
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
public?
Doesn't List as a Collection have a defined method to check whether it's empty or not?
This is the same as the condition above... is this correct? Actually, I think this is why your last song would never play.
The common idiom would be: suggestion assertEquals(1, variantWithSamplesAndAnnotations.size());
I'm not sure we need this. II would prefer to let the logic of collecting exceptions hidden in the visitor. Why not directly handling this case in the MethodInvocationVisitor then? You can perfectly give the symbol of the current methodTree as parameter of the MethodInvocationVisitor constructor, so you don't lose the info from where you are calling. At the end of the visit, you could then simply add thrown exception from the default super constructor, if super has not been called and it's really a constructor.
can / should this be Optional<Class<E>>?
I'm not sure we want this to work with Type directly or instead use Class here.
I know the other methods are using asserts, however we are trying to move over affected code to org.testng.AssertJUnit.\* methods instead if you could. Thanks.
What's the point of the 6 trailing zeros ?
You should statically define those colors, instead of a new Color each time
Hm, should we thrown it as InternalProcessingException ?
Please use a [StringBuilder](<LINK_0> instead.
revert as this code isn't used in this PR
Nit: if the call doesn't throw an exception, then this should print a "success" message.
should be logged.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
Please consider to add a log here (maybe warning) someting like : "connection " + connectionId + " has been removed from DB, no hosts were disconnected" Could be worth some scrubbing time
why do we need to check !containsMacro("timeSuffix")? Why isn't it sufficient to check !Strings.isNullOrEmpty(timeSufix)
Let's have the if in the positive branch
can we add a message to the result if it is stale request something like result.stale()
change
Can you throw ElasticProfileNotFoundException() if existing profile is null? the remove function below can be successfully run when null is passed to it, but the user won't know that nothing has changed.
Pankti, do we have any test?
Pass the FeedbackQuestionAttributes inside the UI template class and use.  feedbackQuestion.getQuestionDetails().getQuestionSpecificEditFormHtml(qnNumber);  > ---- Polymorphism :D
"RANK_OPTIONS".equals(getQuestionType(qnNumber)) should be extracted out.
Please make the constructor private (see Invalid).
default method visibility OK?
are these setters used anywhere?
We already have a i18n runtime base class, could be used here instead
Should return a more meaningful exception
SI will not send null payload
Use StringBuilder instead. Also, you can use ToStringHelper in guava.
You could write less code and use google's joiner  java Joiner.on(',').appendTo(sb, args);
Please use StringBuilder instead.
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
shouldn't this also check the "" case? Consider using Guava Strings.isNullOrEmpty
wouldn't it be enough that one of these is null?
What's the point of adding a copy here?
It looks like what you really want is to say, "I'm blocked" until both of these conditions are satisfied. If so, you can simple replace the original method with: java return Futures.allAsList(operator.isBlocked(), operator.getOperatorContext().isWaitingForMemory());
cant see tests for this
Minor: you can collapse the if blocks, same in CacheRemoveBackupOperation
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
what's the intent of this change?
I hope we can move the verifyManifestPermission to the end of the check. If the signature of the broker even doesn't match, then does it make sense to throw an error and tell the calling app that some permissions are missing?
Let's try sticking to the current style add final and use it as return value
If opening is true, doesn't it mean it's still opening but not done opening yet?
This method and similar could use CacheKeyBuilder instead
it'd be more robust to explicitly build the cache key, rather than embedding the toString of a List.
Could you put the CACHE_TYPE_ID first?
Why?
I don't think args can ever be null, can it?
We will probably run this from maven, and will use it to write to a "target/generated-metadata" directory, which won't initially exist, so please create the directory here if it doesn't exist: File outputDir = new File(args[0]); if (!outputDir.exists()) { outputDir.mkdirs(); }
Use Guava Streams.stream(myStream) instead of StreamSupport.stream(myStream.spliterator(), false)
Try to use "response.getWriter()".
InsertOrUpdateObject?
why not entity?
nit: extra line after if
Can we not call this, if isInitiator() returns null here.
emptyTextView can be made View.GONE?
Any reasons for creating a local parameter instead of using the method directly when setVisibility?
Shouldn't errorContainer.setVisibility(View.GONE) also takes care of notificationButtonView since it's a child of errorContainer (Not putting this for other use cases, but should get corrected for install and update as well if we do it here)
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
lowercase for package names.
Remove throws Exception
Why this change here?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
timezone shouldn't be set to EST because a different date format is specified
There is indeed a behavioral change, the previous code was trying to lookup the files using the resource loader even if the string representation had no scheme, this one does not. The following change fixes the specific build failure. suggestion return uri.getScheme() == null || "file".equalsIgnoreCase(uri.getScheme());  I've verified this change makes for a successful build (with all extensions included, -Prelease):  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 06:12 min (Wall Clock) [INFO] Finished at: 2020-05-06T15:36:28+02:00 [INFO] ------------------------------------------------------------------------
if only passing the message of the exception, please log the stacktrace here.
is getServerKey() invoked for every request? Is it possible to pre-compute the value and cache the URI? I think new URI uses toString and string parsing underneath which is CPU intensive.
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
Also whitelist C
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
please decrease severity to "debug"
please decrease or remove this statement
Delegate to isNonCodedDrug() when making the check.
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
Typo: should be LICENSE
NIT suggestion throw new IOException("Failed to await LockPool evictor termination", e);
should this be in a finally block to release in the case where an exception occurs?
ms <= 0? Thread.sleep(0) may or may not be a scheduling yield. Its undefined in the platform docs.
Maybe I am confused, but this is changing from number of children to number of siblings? ast.getParent().getNumberOfChildren() != 1 to ast.hasNextSibling() || ast.getParent().getFirstChild() != ast I am not grasping the equality of this.
This can be easily replaced with a loop. How deep this recursion can be?
Consider using AnnotationUtil.getAnnotation(...)
[Checkstyle] INFO: '200' is a magic number.
Great test, use withHeader and Basic authorisation header in this stub, just like in Stash test
Use assertJ please
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
we can also get rid of the parenthesis by the way.
wouldn't it be enough that one of these is null?
Can be replaced with streams java List<CharSequence> titles = titleList.stream() .filter(titleProp -> fieldApprover.approve(titleProp.getDataInfo())) .map(StructuredProperty::getValue) .collect(Collectors.toList());
Use LinkedList instead, as we need to remove its head frequently in endInput.
Why is it a list of lists, not just a list?
Use ExtensionsRegistry instead
You don't need this check because if whitelistedMetacardTypes is empty then there will be nothing to filter out and it will ultimately return the same thing
ontology.listClasses().toList() always returns a list of size 0
(Alt) Can we move the skip condition to the testSetup method just above.
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
why uniqueKey, be consistent call it keyField
pvk should not be visible. Please remove it.
change variable to something more meaningful
Bad variable name! Variable names should be clear enough. Rename it.
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
These "Beginning" and "Finished" log statements will be redundant in a test report. That is, most test reports will list the test classes, and whether they passed or not. (And if the test assertion failed, there is usually a stack trace that will also pretty clearly indicate where the problem lies.)
hm, I believe you should check atomicInteger value here to verify actual number of action retries
Replace "5000" with a constant integer value at the top of the class.
Should we have the monitor test here as well?
can this return emptyMap? and just be another clause of the if below?
This almost looks like code I wrote!
Please update the exception message to say KieModule too?
So this will be used for quantity and duration too or you need separate ones?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
not needed, empty c'tor is just for satisfying gwt. its modifier can be reduced.
Redundant, remove.
it has to be otherway round
should this not be "Unsupported operation for Admin service"?
why do we need to close the connection here?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
All these vars are used just once. Maybe just use the method call directly? i.e.  "<LINK_0>" + mUser.getAccountToken() + ....
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
Can we make the type of this field ProblemFactChange instead of Object?
This constructor is redundant.
note that we should always take the cluster's compatibility version in that case, even if the vm is set with custom one and the cluster's compatibility version is cached in VmManager so we can take it from there instead of using this costly query
Instead of Integer.valueOf(int).toString(), just use String.valueOf(int)
Instead of using Boolean.valueOf(boolean).toString(), just use String.valueOf(boolean)
Why is this removed?
we need to reset this property in a @Before block
The fields set in setUp() should be reset in tearDown().
Do you care that this doesn't account for: <LINK_0> Is "Other Info" included in the docs?
The types could be removed.
Please stick to convention of always providing braces around blocks
In separate line ?
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
Annotations on different line
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
dont think a setter type function should return the "this"
this cast seems dangerous: why is an optional stored in there?
@dmzaytsev let's inline this
no need to assign this to a variable
Never rely on the ToString() method of a type. What if it change in implementation class for debugging purpose? Use thrown.name() instead.
else is redundant
Why does the message refer to Logged store here?
If this is local host, why do we need it as a vaialble?
duplicated?
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
You are missing the logic.isValid() check.
I'd suggest looking at the block below this as well, since it drops the entity two blocks down.
Need to consider if this is the best place, since it won't expand it on update actions, right?
this.awsRegions.toString() will do it for you, but please check awsRegions for null first
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Using Collections.singletonList() is slightly more efficient as long as the result doesn't need to be modified, which is true here and and for getDescription()
Arrays.singleton()?
It should be fixed. Component can't support all products if it supports only DI engine.
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
Collections.emptyList?
size > 0 not enforced anywhere
I have seen pcapNg files with a different extension. They don't work because the code expects pcap magic number...
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
Maybe we could use message consuming constructor: java throw new DMNIncludeModelCouldNotBeCreatedException("Can not be used in kogito");
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
A little wasteful when all you need to do is just set the fields and return this...
could you also verify the results of these operations?
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
It seems a little different b/c the other one is marked with @Override, but I don't feel strongly
isn't this the same bug that you had before, that headset wasn't working while app was minimized ?
missing onDestroy suggestion @Override protected void onDestroy() { super.onDestroy(); mMapView.dispose(); }
Can you clarify why this is necessary? Also, the rest of the Activity uses getFragmentManager() but this is using getSupportFragmentManager(). Any specific reason?
Avoid deeply nested control flow statements.
nit, would 'bombarindUnits' be a more descriptive name here? Perhaps even consider inlining it to avoid the intermediate variable?
nit, good place for a ternary here. Any thoughts or objections to that?
catching Exception looks an antipattern. It would catch OutOfMemoryException and any other RuntimeException and the job might continue but in such a bad state that it would probably be a waste of resources
Does this need implementing
TException is throwable, too, and treated the same -- combine the catch clauses?
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
Could be inlined here by using test()
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
why not using the reset methods?
return setExecution ...
although the runBllAction was introduced in earlier patch, i fill the sequence of this method is not clear: you perform runBllAction() and somehow the current command status is updated. I think referring the return value of the command here will be clearer to understand.
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Better, but use logger.logAndThrow(new ...)
why do we need to make this method final and none of the others?
Can this be private, or is there another use case for default attribute outside the builder's call?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
i'd like to talk about different strategies for putting this in the app
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
Why do we have different checks in these two tag methods ?
IDEA says that using toArray(new String[collection.size()]) has no performance improvement over toArray(new String[0]) so the second call is encouraged.
This method can be static, as all the methods it calls.
I suggest to drop this conditional, type cannot be null (unless I'm wrong :-)
You can use StringUtils from the commons.lang3?
Don't make this public, instead. use. TableDefinition.id().
If you add setHasSubtypes(true) then different types of wires won't stack
You could probably use the same URL as in getResultById here.
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just list
if one of them is null, the result is true? This means that they overlap?
I don't know if it's necessary to log this message for each host, since for other unmet conditions we don't log anything. If it looks necessary to you then at least VDS ID would be helpful to know (assuming VM ID is already printed elsewehere).
return StringUtils.isNotBlank(value) && value.equals("true");
return !requestType.equals(RequestTypeUpLog);
The logic here could be structured like this:  java if (driver == null) { // chromedriver process killed } // driver != null from here on else if (driver.getCurrentUrl() == null /* extra null check */ || driver.getCurrentUrl().isEmpty()) { // unable to read url from browser }  Also, is it possible that getCurrentUrl() may throw WebDriverException? I looked at the docs and there was no mention of it, but then WebDriverException is unchecked, so...
Why protected if the class is final?
Should we check if the Kiji table actually exists at this point, so that users don't have to wait until a job launches to discover they specified a non-existent table?
The constructor should be made protected so that users can easily make a wrapper for it.
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
Setting variables to their default value on construction is a no-op semantically but still mean instructions executed which causes the construction of the object to take longer.
I see this method does something similar to execute minus the optional processing with the rowProcessor
Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
does not need to be public in non-public class
I think that we should add some randomized part to thread name because we can end up with stale consumer that we cannot differentiate from newly created process. Or perhaps we should rename stale process with some suffix.
"Service to get values from a Dictionary". Or something more meaningful too.
I'd prefer to avoid using magic names, like "attributes", instead of that I'd like to have an annotation to mark this method. Currently we have the "Required" and "Allowed" annotations, that were intended for something similar, but never actually used. Can we remove those annotations and introduce a new "Constraint" annotation for this purpose? I mean something like this: @Constraint default void anyNameYouLike() { mandatory(...); ... } We can initially ignore the name of the method.
can you please reformat this test file to have something a bit more compact and coherent in term of style? You can also remove empty lines.
These lines are very similar to the ones you copied, it seems like this could be refactored to consolidate the logic and not have copied lines.
Is there any chance for the three conditions, some of these them are true and others are false?
assertNull
assertNull
use new Guid(String) - this literal can't be null
Don't leave System.out calls in the code after you're done. Other use LOG.debug' or delete them.
Maybe it's better to use Collections.emptyList() instead
nit: Perhaps you should show the user how to parse the JSON?
Why do we have to reset it here? Is it because the standard, GZIP compression is not supported? How hard is it to simply support it?
Why do we compute the partitioning over the probe table instead of build table?
This should be "test-client-id", and is simpler anyway when I eliminate ClientIdentification.
uncessary call to super. No need to visit further.
are there unary operators which don't write? e.g. -?
I am really doubting about this call to super: What about something like :  return new Foo() { //some stuff closing };  The new ClassTree will be checked twice, once with the override of visitNewClass (via the call to super) and once with the checkUsageOfCloseable of the expression of the return statement.
Just "Kafka".
Would be better to return "JDBC:" + dialectName.
Better to return "";.
i don't think redeclaring the type on the right side is needed.
Why 0,8 if all we are setting is 7?
if no config, should this return false?
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
It might be slightly less effective, but it's better to delegate to PartitionIdSet.remove here, so ImmutablePartitionIdSet iterator will be immutable as well.
nit: UnsupportedOperationException (java.lang) is more descriptive.
Use P.lazy.
You should use the annotations field here too, not the wrapped reference.
I see 3 proposals: A) Leave as is (bad idea, fromUniquePair(..., Joiners.filtering(...)) doesn't work for CS-D and CS-B) B) Put lessThan() before filtering() - Is it a regression for Bavet? does this break any of the existing Bavet working examples? C) Like B), but add Bavet syntactic sugar to support filtering() to avoid any regressions of B.
Nice, included the row.
what if input.length is a multiple of 256? wont this add an extra 256 bytes?
missing checkValidPosition(positionCount, position); below?
i would use a LinkedList here instead. i can't find anything saying ArrayLists sort faster and then you do not need to specify an initial size.
the formatting is off here, not matching the rest of the project (disable "Align when multiline" for "Method call arguments" in your editor code style). Also the same in other parts of this PR
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
I think "$exists operator requires operand to be either true or false" a better error message.
Should be 404, not found
instead of null pointer exception ClassNotFoundException will make more sense I think
Hi @ashrko619 What about For(List.range(startYear, endYear + 1), List.range(1, 13))? :)
In general, I would directly return the match result. No need to introduce a variable, it has the same name as the method.
Style-nit: This method can be static.
Why is COLUMN_SORT_TYPE text? Shouldn't it be integer?
This is working Ok.
> I feel like site_id here makes more sense just because the only use of it is for the network calls. If it's used for network calls, it's not "local". Local_id was used for blogs/sites because we can have a mixture of self hosted and wordpress.com sites, so we can't use the id provided by a network response. Will this be used for wpcom sites only?
Should we use a checked exception here?
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Can't we leverage Java 8 constructs for these?
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
In a development only environment that's _not_ localhost, they'd still have the situation where the account cookie would not be set. Maybe take that one sentence out?
be backwards compatible
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
Probably we can move the logic of obtaining the env vars to @PostConstruct to avoid reading env vars on every call
If you just retain the below line, the API contract for createInstance can be regular:  UserDTO user = userEntity == null ? null : UserDTO.createInstance(userEntity);
nit: can be simplified with runIdGenerator::ifPresent(RunIdGenerator::close); same for coordinationUtils
You use actingUser as a parameter, while the other subclasses of BuddyMessageDTO use UserDTO.createInstanceIfNotNull(messageEntity.getUser()). Could you please make these uniform? (See BuddyConnectRequestMessageDTO.createInstance, BuddyConnectResponseMessageDTO.createInstance, BuddyDisconnectMessageDTO.createInstance.) If the user is deleted, does actingUser not become null? The message factory may construct these messages (by an inbox request) after the related user has been deleted.
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
It is not necessary to test REPLICATE region in this test.
size could be set to 2.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
This trace message sticks out a bit. Thinking we should either remove or add logs to all the rest at some point.
ps command does not recognize j a x flags on aix and solaris
API breakage errors. You should declare another method and mark for deprecation this one.
I would suggest calling the new getGDBCommandLineArray and making a string out of it. That will make things more future-proof. Something like: String cmdArray[] = getGDBCommandArray(); StringBuffer gdbCommandLine = new StringBuffer(); for (String cmd : cmdArray) { gdbCommandLine.append(cmd).append(' '); } return gdbCommandLine.deleteCharAt(gdbCommandLine.length()-1).toString();
The default value of fail-on-missing-field is false, should set it to true.
I feel the isNotEmpty() check is not needed here. The for loop will take care of this case.
This function appears like duplicate of whenAnyComplete in airlift MoreFutures. What about using that instead?
What about making it protected instead and mock a sub-class? CreateTopicsResults is part of the public API and we might not want to make them public (would this be a public API change?)
Generally, we haven't used java asserts anywhere before. So I would be a bit hesitant about doing it here? What is the reason for adding them?
The HandlerController is associated to a Realm instance, which means that it's local to a thread. So why do we need to keep checking if the realm has been closed?
return Collections.emptyList();
Would it be appropriate to add some logger.warn() statements to these two IFs, to make more explicit what's happening, both here in the code and at runtime?
return index == 0;
Please change this variable name too..
I think including taskStart.getId() would make the log message more informative.
I think including taskStop.getId() would make the log message more informative.
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Avoid the intermediate variable and directly assign selfID.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
this.
This adds 5 seconds per class, at 311 ITs that's 25 more minutes of runtime. Maybe we should disable this by default and only enable it if VacuumIT is failing to debug?
Should be removed if empty
needs filling in :)
let's not do anything smart here - the provider should be able to decide how to map "default"
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Shouldn't options be Immutable?
import or create (considering we may not use the imported configuration)? there was a good patch by Liron [1] where he called that handleVmLease. not that important though [1] <LINK_0>
Should you call analysisReady(false) here?
Maybe you should try to check the notifier before to force a refresh.
Lazy load this to a field.
Same here: should be Branding, not ProductBranding
We don't use this. on methods...only members.
On macOS users may never hit DEFAULT_DNS_SERVER_ADDRESS_STREAM_PROVIDER. Therefore, we may defer initialization until necessary, if we move this constant to another class.
change please :(
[2019-10-01T07:16:01.665Z] /home/catroid/jenkins_slave/workspace/Catroid_PR-3353/catroid/src/main/java/org/catrobat/catroid/ProjectManager.java:98: error: cannot find symbol [2019-10-01T07:16:01.665Z] return INSTANCE; [2019-10-01T07:16:01.665Z] ^ [2019-10-01T07:16:01.665Z] symbol: variable INSTANCE [2019-10-01T07:16:01.665Z] location: class ProjectManager
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
Any specific reason we are handling 2 tables in a single file? This might throw off some people. Also, if we are making the separation, wouldn't it be better to do it in FluxC? I haven't thought about this too much, so I am actually asking and not suggesting :)
Shall just assert db != null.
The philosophy of simple-mode is to work soundly on most code, with very minimal restrictions (using around reflection). We shouldn't be using type-based optimizations in simple mode.
Should be moved with other not treated cases
could you instead change the flag from nextOp.afterDelete to nextOp.checkDeleted. Then, we wouldn't need to have check the GetOptions type here.
Debugging? Remove.
Add a message to checkState so that it's easier to debug if we ever hit it.
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
isn't this condition always true?
nit: the exception is no longer thrown.
SG.
return a boolean esp. given the semantics of the update operation if there is an existing node of the same name that is not the provided node instance
On the previous code there was a check for null on n. Why don't we need it anymore?
These two lines can be return values.getOrDefault( v, n );
Doesn't Datanucleus advise against using id in hash?
And this change should be reverted as well.
also host/port instead of socket address
Why not just simply "command.setVM(vm)"?
shouldn't you return templates?
I think this could be private.
Make this AtomicBoolean
It would probably be better to have a clear separation between the call to getSolrUrl() and the creation of a log.
This doesn't look like it does what a stopGracefully should do. Maybe we should rename that method to something like suspend (not in this PR though). But, what it's supposed to do is suspend a task quickly so the jvm can be shut down and then restarted. Specifically it shouldn't be trying to publish or anything like that - just persist to disk and then stop.
nit: you can merge both lines above as checkNotNull will return the given argument
Does this also require a null check similar to setcontentType() ?
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
same question
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Met List:  @Override public boolean inputIsConnected(int index) { return index < inputs.size() && inputs.get(index).isFullyConnected(); }
putIfAbsent or use synchronized block
What if dataGeneratorListMap.get(topic) returns null? (It could be null because of unsubscribing)
Why do we need this constructor? It doesn't use the 2nd parameter...
Those two should be equals (and even ==) rather than going through FQN
minor : no need for the else with the returns...
I guess we could make it more concise as: java if (!parameter.isAnnotationPresent(Auth.class)) { return null; } else if (principalClass == parameter.getRawType()) { return new PrincipalContainerRequestValueFactory(); } else { final boolean isOptionalPrincipal = parameter.getRawType() == Optional.class && ParameterizedType.class.isAssignableFrom(parameter.getType().getClass()) && principalClass == ((ParameterizedType) parameter.getType()).getActualTypeArguments()[0]; return isOptionalPrincipal ? new OptionalPrincipalContainerRequestValueFactory() : null; }
Why need to catch to simply rethrow?
Again, use try-with-resources.
These catches aren't necessary.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
reference would be concatenated w/o a separator. Is this intended?
I think we could shorten the code if we store these aggregator characters directly in BuiltinAggregator enum.
The method actually determines if the given processorNode is a duplicate of any of the existing nodes. The action we take on duplicate is stopping the processors. Can you please update the doc?
What's going on here? Why load the data into memory and then send it back as a stream? This should just return the InputStream returned by requests.get(attachmentURI). If you're having problems getting your test to pass with this way of doing things, we can look at what is going wrong.
Just return data.
Where do these numbers come from?
Is this correct?
If you have to cast here then you probably should have casted when reading the value from the data array.
@overquota Should not #close do #closeConnection and #shutdown do #shutdownConnection?
Why you don't use wrappedHandler?
better throw a runtimeex. here with some message like "not implemented yet"
Shouldn't this be refactored to something like this? entries.append( "- " + entry.getName() + " - " + entry.getMissingPluginId() + "\n"); if ( missingEntries.indexOf( entry ) == missingEntries.size() - 1 ) { entries.append("\n"); }
please externalize this message
This should be trace level?
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
:astonished:
?????
same opinion here :) (though break logic here seems correct)
This should be impossible now, no? e.g. 5 rules, all match, 5/5 == 1.0. I appreciate the gate, but I'm worried it may be masking potential insidious bugs. A score of >1 should be an error yeah?
Shouldn't this done only if meta-volume exists?
this method should be changed to private
(nit) no need to make a copy of the array (save the garbage). We don't usually guard the callers from modifying the list as it is internal code.
File
revert this string
suggestion "} else {\n\n" +
the example can probably be taken from the source panel, as it's the code the user tested his rule on
Don't shade names like this on purpose... Also instance variables on Block is not a good idea..... Threads kill it...
I think you can avoid the ternary statement here by checking if (this.world == null) instead, and returning this.world.get() at the end.
Alternatively consider a java.util.concurrent Queue for EventHandler.requestedBlockUpdates, so callers need not worry about synchronized().
can't you use constants.empty() here as well?
Is that intentional to remove check for dhg.getDomainName() is null. We would have null string appended to dhost name.
If host was removed in the meantime, then vds can be null, so NPE will be thrown when getting hostName. So we probably need something like: private boolean isActiveVds() { VDS vds = vdsDao.get(getParameters().getId()); if (vds == null) { getQueryReturnValue().setExceptionString( "Cannot fetch storage devices, host doesn't exist anymore."); } else if (vds.getStatus() != VDSStatus.Up) { getQueryReturnValue().setExceptionString(String.format( "Cannot fetch storage devices, host %s is not UP.", vds.getHostName())); } else { return true; } getQueryReturnValue().setSucceeded(false); return false; }
A design where this is side effect free would be most desirable.
This line is redundant.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
This could be set in the constructor instead of checking this on every request.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Did you run your test? Does it work with Github account? I don't think it does, since you're creating one gist and deleting another one.
This assertion may fail if there is more than one public key on the repo you are testing on. I don't think that's a safe assumption. Better to use Matchers.hasItem() here I think.
what this line is for?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
dont think a setter type function should return the "this"
how about merging those 2 ifs ?
Can throw exception when created with no args constructor
Sorry forgot to mention to change the read to access here too
I lost track of changes :D. Adjust as needed depending on whether the setUpDefaultPanel has to lose the arg or not.
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Why we want to fall through into the loading dialog in case of error?
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
Please check also left content, in order to be sure that left model has not been modified.Please verify all other tests that present the same problem.
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
Isn't there some standard way to dump a stack trace?
This can create an invalid AST that contains the error token. Instead of hasChildren, you need to check that the last child is an operator that can be converted to an assignment operator, eg, using a helper method like this:  js static boolean hasCorrespondingAssignmentOp(Node n) { switch (n.getType()) { case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MUL: case Token.DIV: case Token.MOD: return true; default: return false; } }
second or last? Do we even have guarantees GETPROP has only two children? This AST is atrocious :)
Can you add the curly brackets to the if calls.
You can simplify the if-else block to Java if (path == null) { return other.path == null; } else { return path.equals(other.path); }
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
beginBlock should close the paragraph that was created in assertOpenBlock(), if there is one currently open. Note that it should not close *all* paragraph blocks, only the one that was implicitly created.
should assertOpenBlock(); here, and have a test that fails without it
This method can be static, as all the methods it calls.
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
What's the point of String.valueOf("0") ? Why not just "0" ?
Since it's now shown to the user in Progress view, should we use getTitle() (view name) instead of getName() (view id)?
Oh yuck. ;)
Update labels to go with method names. Alternately, call super.toString for super attributes
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
This is the only place that add entry to the pool, is it the only way to fill the pool?
s/B/b/
This test would be useless if the map had been initialized in the class.
Should we do an Assert.assertTrue on the return value of verify()?
Can you share why we need to unsubscribe all here?
Should we skip doing this if scrollIntoViewPending_ is already true so there's no way for requests to stack up?
Can't be just assetListConsumer.accept(Collections.emptyList())?
@garg-anuj Yeah doing that only.
Style issue: @Override shuld be on line above the method declaration
Can be simplified to AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());
remove "?true:false". It is unnecessary
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
just one thing here - please add try {} catch(Exception), with proper logging, as if you will throw any exception from scheduled code, no more jobs will be ever scheduled. just a precaution. otherwise jobs will stop running and we will never know it occurred
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
How would you feel about making this passed as a json property in HashedPartitionsSpec and add it to the docs, so that people can use it ?
Throw an unsupported operation exception here.
an empty ArrayList is better than a null
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
can this throw an specific exception.
omit: Initialing...
Please kill this new line
the return type should be M
should rather be  Java Objects.requireNonNull(throwableSupplier, "throwableSupplier is null");
Hmm, I wonder if we perhaps would be better off if this method delegates to the existing innerJoin() method, and we start optimising these joins in a different task...
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
Could we please use <LINK_0> ?
I am not following here - why do we want this in sync block?
SyncNetworkParametersBuilder contains those logic in labelAdded() & labelChanged() perhaps it could be reused ?
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
Would a bc reviewer be able to view the supervisor signature? The "reviewDue" status should be treated the same as "employeeReviewDue" as far as the supervisor signature is concerned.
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
does not need to be public in non-public class
Seriously dude, don't reformat code for no reason.
Take the limit (50) as a parameter, this will be useful for later
@hellais do we want to run more tests here?
I'd like still handle the activity context case with java BaseRealm.applicationContext = context.getApplicationContext(); if (BaseRealm.applicationContext == null) { BaseRealm.applicationContext = context; } if (BaseRealm.applicationContext == null) { throw new IllegalArgumentException("The context is null"); }
These two lines probably can be combined into one.
return tags;
suggestion return Collections.unmodifiableMap(tags);
I'd rename this variable to memberValue.
Why did you use ConcurrentHashMap here?
Looks like you're returning an empty TreeSet, but don't register that as the value of handlers (as would be the case in computeIfAbsent). If you just want to return an empty stream, it's better to use getOrDefault(type, emptySet()).
This displays the internal account identifier (unified_inbox and all_messages) instead of the display name.
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
Since we get access to the Site here, it seems wasteful to throw it away, and then have to re-expose it through FeedCoordinatorBase. In all the other cards so far, the Site gets passed all the way through to the server request from here. Perhaps the same can be done for Random?
For short: return o -> checkNotNull(fSegmentStats.get(o)).getMin();
for short, you can just do return o -> o;
Check if credential and registryUrl are null before creating the Deserializer.
public?
I'm missing the new field in the toString method.
Use Objects.equals() to handle nulls concisely.
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
should we consider label as well?
Are these cases all needed? Or what all of this just copied from categories?
Please add a check that from <= to
Why are you removing the setIDs here?
return Collections.emptyList();
This AnnotatedType implementation needs to also override the following method: getAnnotation(Class<T> annotationType); Otherwise there is a mismatch between what isAnnotationPresent() and getAnnotation() returns.
I wouldn't detect processSynthethicBeanObserved at all (we don't detect ProcessSyntheticAnnotatedType neither). Instead, just check the extension param: if (extension != null) {
Have you considered Activity.RESULT_OK instead?
You can remove this to simplify it to getActivity().finish();
Maybe call finish() after startActivity()?
Retry forever is a bit risky. Limit to a fixed number of tries. Also, use a delay between tries?
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
suggestion return format("metadata[%s]", key);
do we need to unvoid..?
A regular integer will do fine. The connection handler is single threaded.
imho it should just be write(...)....
should be "*notconfigured-it.war" Double check the folder because not sure how this passed.
I'd prefer the use of unicode escapes here instead of the actual characters
Why are we forcing the creation of the directory? Surely it should be writeable?
Could throw IllegalArgumentException instead.
I think I prefer "Invalid key" as exception message
change "get(key)" to "redisSet"
Not sure whether failing on plugin level is OK. If it would be in test plugin and not an abstraction for manipulation with docker I would consider it ok. But on plugin level I would not do it. @rhopp thougts?
can you please also add method ok(TimePeriod waitForJobs). TimePeriod.LONG may not be enough for all cases
remove semicolon
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I see no reason for the setters to be public.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
You need to check for null after the first get as the query may have finished before you call this to kill it.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
Can this be private, or is there another use case for default attribute outside the builder's call?
Please revert all changes to this file
Let's find a better name for _bufferSize
Don't also print stack trace, log.error will already print it. Also other instances below.
This can be wrapped into another function for clarity purposes.
:-1: ;p
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
I don't think you need the condition here.
public isn't needed
is this key unique enough if there are multiple fields with the same type, either in the same class or in class parents?
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
float?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Well, with the squash GH doesn't see changes and don't notify via email. I have missed this change therefore :cry:
!getCustomTopicNames().isEmpty()
Can we name this something other than it? Even i would be better to me than it.
why is it Collection of Strings (instead of String)?
Ah no, I didn't think. It's of course possible because we're removing the same instance and equals therefore works...
no static
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
Need to pass xmlEnvironment as second argument to XmlStringBuilder.
Just to be sure that there are no NPEs, consider switching getNamespace() and NAMESPACE
I think you can simply xml.append(affixElements). If I am not mistaken, then there is a matching method in XmlStringBuilder.
As this if became quite complex, I did small exercise and tried to refactor <LINK_0>, please let me know what do you think about changes I propose.
And ATMOS ?
isSecure() return true if "coaps is used and false if "coap" is used. The naming is not so good with the OSCORE addition (so maybe we need to rename it but later.) So in this case isOSCORE should not impact isSecure()
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
It seems weird to me for the ConvictionPolicy to dictate when to reconnect. I think it would be much easier to manage if it was only responsible for whether or not to mark the connection down, especially if we ever intend to expose this.
should the interface not the implementation suggestion public List<String> getTopics() {
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
redundant method("POST")
@vilchik-elena Minor performance improvement: we currently always evaluate all 3 boolean expressions, but we could avoid that.
make it final. You don't want classes extending it to override this, as it's driving the analysis.
![MAJOR](<LINK_1> Change this comparison to use the equals method. [![rule](<LINK_2>](<LINK_0>
You should be able to use the diamond operator here, i.e. new ArrayList<>()
Simpler: ArrayList<T> result = new ArrayList<>(collection);
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE);
should it be an error condition or log something if both the invoice number and the customer payment number are both blank?
I think it's about time we move this frequently copied-n-pasted code to a core utility.
What about using String.format instead:  String.format("Injectable type: Invoker, accessor: %s, method name: %s, invokes method: %s", methodLocation.name, methodName, mName);  Seems more readable to me
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
No full stop at end of error message
Unrelated change.
return dto
List<BankDto> bankModelList = isBank ? bankService.findBankList(null, null) : bankService.findUmpBankList(null, null)
userMembershipModel != null
what's the intent of this change?
please fix whitespace
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
You can push this directly to the frame so you don't have to pop it manually.
Multiline this annotation, it's too long now.
Make this a method already..... skip the casting....
does this need to catch all exceptions?
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
You are opening a stream but closing it inside a other method. Is this a good way? Would it not be proper way to open and close a stream inside the same method?
No need for getInstance(), the container can be passed
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
scheduleTimes --> scheduleTime
why is this noncompliant?
boolean
UnsupportedOperationException is more accurate. Pair is not immutable though. Both private fields are potentially mutable, taken from the user in the constructor, and provided back to the user by getters.
add this selector to UI mapping at the beginning
Can this be private, or is there another use case for default attribute outside the builder's call?
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
You might want to remove this one :-)
Lets maintain the original ordering of fields: defaultNamespace, sharedTriggers, namespace. Same for constructors etc. to keep the diff smaller for generated schemas.
Should the InterruptedException here be treated as a cancellation?
Use readAsString(...) instead
Use readAsString(...) instead
Use readAsString(...) instead
This converter does not have any effect
Not sure if it matter much, but the 'better' way of getting an empty list is: return Collections.emptyList(); In this case however we need to specify the type: return Collections.<CertificateInfo>emptyList(); As the compiler cannot infer the proper return type.
Change the VdcQueryType to the correct one, this one doesn't exist and thus fails compilation
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
vds.getStatus() == VDSStatus.Up
this can be a single line with allForCluster.stream().forEach(glusterCommandHelper::initGlusterHost)
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
I still think you should throw an exception if name is null
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Would it make sense to add this method to ResourceManager interface ?
if you feel this would help in metrics, I could think of getAvailableConnectionsCountPerHostPortPair also would be helpful. Isn't?
You can use Boolean.parseBoolean(st.m_exportingRole) which is essentially this under the covers
IMHO better "HashSet". I don't see that you use the iteration features of "LinkedHashSet".
this.
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
This should default to true to preserve the previous behaviour.
This should call config.useKafkaTimestamp()
Could you alter this to be consistent with most pre-existing Essentials settings, only reading from the config once and returning the stored value until the config is reloaded?
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
nit: add e as a debugging parameter
I don't think you need this new String
No key for encryption? ;-)
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
It only goes in this else if (!this.isSprinting()), so how can this work? o.O
I wonder why do we care about this. We are just have her self-containing AcknowledgmentImpl with the client it has been created. If that client becomes invalid at the moment of acknowledge() we have nothing to do anyway. What am I missing?
This variable is useless. Please just use return in your if/  branches.
Superfluous empty line.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This case is not covered.
this is effectively a noop
One branch not covered.
the workspaceitem needs to be deleted
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
Why Exception instead of Throwable like we did for before()?
nit: Just write entry -> ...
suggestion .flatMap((entry) -> StringUtils.truncatePrefix(entry.getKey(), MetaTagConfiguration.CONFIG_PREFIX_FOR_TAGS) .map(Stream::of) .orElseGet(Stream::empty)) .collect(Collectors.toMap((entry) -> entry.getKey(), (entry) -> entry.getValue()));
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
You could also use path.endsWith("/")
does it need to consider Windows?
Usually tryLock shall return a boolean instead of throwing exceptions.
public?
scheduleTimes --> scheduleTime
I'm missing the new field in the toString method.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
Perhaps it is not necessary to execute the program to find if it is present. How about just checking for the executable file using java.io.File.canExecute()?
this method deserves a description
Could you include the invocation-future toString in the exception message?
Same here, better to wrap the classloader creation inside a method.
Any reason you're using this over getClass().getClassLoader()?
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
better to cast to string instead of using toString()
better to cast to string instead of using toString() .
This should have a static logger method with a code
Why not in combination with above do this: setValue(value, false);
I suggest to use here following refactoring <LINK_0> We can distinguish exceptional and normal branches here. Exceptional branch here is value == null It is recommended to put all exceptional branches at the beginning of the method (guard clause, which guard method from exceptional argument/condition):  if (value == null) { return null; }  Normal branches here are: 1. matching mode is keep_all 2. matching mode is keep_last or keep_first Normal branches go after all guard clauses. We may use if-else for normal branches, if there are only 2 choices and they are both normal conditions. For 3 and more options better to use switch-case or several if statements. I suggest to change this method in following way. Note, method clarity should be on the first place:  if (matchingMode == MATCHING_MODE.KEEP_ALL) { allList.add(value); return value; } if (matchingMode == MATCHING_MODE.KEEP_LAST) { firstOrLastHash.put(value, value); return value; } if (matchingMode == MATCHING_MODE.KEEP_FIRST && !firstOrLastHash.containsKey(value) ) { firstOrLastHash.put(value, value); return value; } // value wan't stored in cache return null;  "Guard clauses" will remove nested conditions (nested conditions complicates code clarity). Also I suggest to break keep_last and keep_first options into 2 branches despite code is the same. It is to highlight that these are different options.
Symmetry (throw)?
Do we want to have null maps here? Can't we follow the same pattern and default to empty ones?
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
You can import OPTIONAL, BINARY, UTF8.
Instead of creating a new instance of this type every time, could you create a single one that you reuse every time? (Same for all other Statistics classes.)
Using printedTable might make these assertions a bit more readable.
lets include e.getMessage() to be consistent with other plugins.
Do we need to validate the config once in configurePipeline() and again here?
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
i'm surprised this passes checkstyle
matchedEmail?
I disagree with changing the behaviour in this method, and it also is no longer consistent with the container year scorer
Racy. Maybe just chuck a synchronized on.
I would ignore empty notifications and would log warning.
We need to avoid waiting until encrypt time to determine that the public key passed at initialization is incorrect.
-1. This means input does not get read.
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
I think we might want to separate out the concepts of hasIndex and isQueriable. In gatk we have a datasource that has no index but supports random access. I also think supportsRandomAccess might be clearer name. I'm not sure how granular we want to go though, you could potentially imagine a stream with an index that supports fast forward skipping but not rewinding, which wouldn't be easily described here either.
return if already destroyed
Maybe clear all three fields here.
Won't fix.
Why is it still public final?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
We may want to make the start/start stage, etc.. method names match up better.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
The path can be moved to constants since it is used in FeatureInstaller.java
Missing @Override
why do we use this. on getters but not on alpha? I would skip this. all together here and use getAlpha()
These will all break if A or B is null. Recommend using the autogenerated intellij equals + hashcode unless you have a good reason not to
I was initially confused on why this wasn't being handled inside the onGoogleSignupError callback but after looking at UnifiedLoginTracker.trackFailure() I'm assuming it's to preserve the current flow and step. If that's the case, I think we need a way to communicate this behavior more clearly. UnifiedLoginTracker is currently not a part of the login library, so other library clients will only be able to look at LoginAnalyticsListener.trackFailure() to get more context on how this is supposed to work, which doesn't make it obvious. Let me know what you think.
normally we use italic text for info icons like this: numaInfoIcon.setText(applicationTemplates.italicText(message));
I think it would be suitable if some kind of padding is applied between messages, such as a newline
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
Please add a cast to Object[] here.
You can just use the @UiThreadTest annotation on your test method.
space
This should be "else if" to avoid redundant checks. It can't be both, so if the first check passes there's no point doing the second.
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
I don't think this check is relevant
Injection constructors should be package private. Remove the public modifier.
There should be a null check here if it doesn't accept null values
This is just a doubt. I think that most of the time the input list is fine. Do we really need to instantiate another object here?
it's unnecessary to declare this method public, if it's package visible the test can still use it since it's in the same package
Is order important here? Should the 2 collections correlate each to another?
Not necessary to call super(). There is an implicit call to super() with no arguments for all classes that have a parent
super() can be spared here.
Can we make the type of this field ProblemFactChange instead of Object?
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
you should probably check Item.Configure here
That's good to know.
return Collections.emptyList();
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
final?
Could we log it?
Isn't the isSessionExists condition enough?
Shouldn't that be just root.retrieve() as we are setting the method on the create() method?
nit: Only plan parameter is used. I don't think you need to check anything but plan with the requireNonNull.
require non-null
would this work? (also removing the import) suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice);
ValidationPackage is not diagram specifci any more. This should be added in DialectUIManagerImpl and not here.
like line 63 but this is setFeature, so should be removed?
In practice this will never happen :) I'd suggest to remove this check, or throw a runtime exception instead of logging the error.
why null?
This is starting to look like something we might want to move to a separate list with the "overflow options". If the index is greater than getSize() - 4, we just get OVERFLOW_MENU[getSize() - OVERFLOW_MENU.length] This way we could maybe also get rid of a few hardcoded numbers.
you need call addColorSettingsListener on the new instance.
String.valueOf()?
String.valueOf()?
No need to include this in these calls but it is a minor detail.
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Can this be private, or is there another use case for default attribute outside the builder's call?
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
? Why the change. Its internal field and allows access by field reference7
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
Please remove the unused method.
equals & hashCode can be generated in eclipse
Why U don't want to consider id in equals and hashCode ?
This does not actually verify it's only registered once - I suggest you use .containsExactly(monitor.callback)
Becarefull with those assert. They will not fail if jvm is not launched with specific argument (-ea). You may use a Preconditions.checkState() instead.
![MAJOR](<LINK_0> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "true" [![rule](<LINK_1>](<LINK_2>
Is it possible for two objects to test equal but have different hashcodes?
...so don't pass the "intial hashcode" into location.hashCode(...) but instead mix the various hash codes yourself here. Guava Objects.hashCode() can help.
Would it make sense to rewrite equals to avoid #toString since this is a rather expensive equality check. That would allow for a more efficient #hashCode, too
A percentage is between 0 and 100
Maybe it is better to say _"Provider for DTO type ..."_ ?
Should be "!= 0" instead of "> 0"
Per our discussion, we need to delete any removed custom data properties before saving the account and its custom data changes.
Is there a reason you can't use the strings.xml file for this?
We should log this error by using our Log.e method.
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
nit: I see the point here to use a delegation call to xxHash64. But given it's a simple function, maybe just inline it as return XxHash64.hash(value). Thoughts? @haozhun
The input has to be a valid ipprefix so you don't need to validate it.
bracket should be on the previous line
I mean such changes, this is special @jglick coding style.
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
In the exception message, including the issue id is strange. Please put some brief descriptions in the message.
why not an empty map?
Since a SAML Attribute map can have multiple values, the type here should be Map<String, List<Object>>.
Argument name
Argument name
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
Shouldn't it be "<LINK_1>"? I did not test it in the app, though.
unsubscribe()
This string needs updating.
Collectors.toList()?
remoteTimeout() is the correct one
I think the call to .nullsAsNull() is useless here as it's already called in the range method you've called.
Pass the whole geppettoManagerConfiguration
url.endsWith("/") would be easier to comprehend. String comparison should be done with equals, not == or !=.
this.url = checkNotNull(url, "url");
You can use ZoneOffset.UTC instead of ZoneId.of("UTC")
you could just do setConfirmWindow(null); like above method
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Please check the result here and break if false , since all values are with AND , there is no point to continue if we got false
we should check only the vm the active volume is attached to and not vms that a snapshot of the disk is attached to. in case that the disk snapshot is attached to other vm that is down, we shouldn't care if that vm is in preview (for example).
there is no async part for stop VM right? so why do you need to use the command-coordinator here?
?????
:astonished:
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
reportservice
Possible ClassCastException, since there is no check that the loaded resource is a view.
We must never remove resources from the resource set that are not unloaded, as I would expect adapters attached to them or their contents (such as the UML CacheAdapter) to leak memory. Any references to objects in these resources from resources that aren't being removed must be changed into proxies by unloading. I don't see any unload() calls.
This was renamed to PARTITIONED
Why do we compute the partitioning over the probe table instead of build table?
Why not use null instead of ""?
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
Do we need this else block?
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
unnecessary change
The default should be updated to return 8 parameters to the test
Item dropped should be a hopper
Why not: java if (val instanceof Double && Math.abs((Double) val) <= 1.0e-131) { return ZERO; } return val;
For Lists this should be applied to each element of the list. Please also include unit tests for stuff like {"toomany":[1234567890000000000000]} and {"funkyCoding":["foo\uD900"]}.
Is there a reason to make it static? And why isn't it declared as private method?
Maybe use the getStorageId method here?
You are (presumably) removing this null check since you believe that it is no longer possible for an image to not have a sequence at this point. To be fair, you are largely correct. However, this might not always be the case (getSequence is not final, and can thus be overridden). Either make getSequence final _or_ leave this null check. (I would prefer the latter).
Can we just do a post() here, and not keep track of whether imageHasLoaded?
please put each parameter in separate line :)
Should we do three separate queries, one for each filter?
It's easier to read if expected values are provided.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
unnecessary parenthesis?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
No, this. when you call methods.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Please don't use null here. Just pass "" and make stateKey always concatenate.
nit: Use StringUtil.EMPTY_STRING.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
count argument of repeat function must be less than or equal to MAX_LENGTH
@vilchik-elena How about adding a dot at the end of "incl", that is "incl." ?
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
there are 4 instances of "store manager" being used like this. Can you replace with storage manager
Why is this throwing Exception? Should usually not throw anything.
Why delete this line?
Delete try/catches. An exception always fails the test case.
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
@cvrebert Same here, better to pass it directly to withDescription as a literal.
Maybe try using message.status() instead? I'm running docker 1.7.1 and that's where it was for me.
I'd suggest calling this init method from the context file instead
As noted above, just put the init code in init() unless there is a reason not to.
super.init() method never throw an exception.
using command line user can provide a wrong id (say, by mistake), so its better to check for getVdsGroup() == null here as well
missing check that vm exists.. (getVm() != null)
Do you mind to write it to utilize the ValidationResult API?
public?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I'm missing the new field in the toString method.
What if this path actually exists on the user's workstation?
"Path validation" instead of "Request validation"
will it actually trigger the watchers if you set the same value as it had before?
I guess I'm out voted on using this. :-(
So what's buggy about the CopyOnWriteArraySet?
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
As a nit, should have a null guard here.
not relevant for localization.
I would prefer a bit more OO way, something like: new KeyValue(key, value). append(new KeyValue(key2, val2)) ... .toString Than the KeyValue would be an inner class which looks like this: class KeyValue { private String html; public KeyValue(String key, String value) { html = "<b>" + key + "</b>" + value; } public KeyValue append(KeyValue other) { html += "<br />" + other.toString(); return this; } public String toString() { return html; } } BTW there is no real need to worry about StringBuilder vs "+" in the GWT since it anyway compiles to JS and it is hard to tell which way is faster (in some versions of some browser the StringBuilder, in some the "+" but the difference in this small amount of concats is not significant...)
Remove this line so that you fail on assertion.
Please use MantaClient.SEPERATOR and do not hardcode slashes.
Do we need to store this as a field, can't we just return that in the getIpinterfaceId() method?
Should this mention Dockstore? I could see it other way; as other fields mention it. Depends if this describes the API or the implementation.
I can't see any reason to throw CoreException here.
They are mutually exclusive? Or is that a micro optimization?
you can express this in a more concise way but still readable:  return namespace.isEmpty()? name : namespace + SEPARATOR + name;
I would drop that since it is false by default
You added this to the ctor's signature, but forgot to save it in a data member.
It seems cleaner to me to just store the string here and keep this a simple-stupid POJO, and have the optional "logic" where it's used.
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
How about checking numberOfEntries != 0 instead?
spacing here looks off
rename to allUnresolved and then just use unresolved in the foreach loop variable
rename to hostCandidate
rename toRefresh
I think we should keep this synchronized.
We should not force all of the refreshes
Format
Is there any reason to remove 'private' access modifier?
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
Same here, would be better to leave it on the previous line
Have you intentionally omitted index check?
before accessing it's property, wait for element
This condition seems to be backwards. I think it should be index < array.length
This should also have a check for max of 25 like the constructor above, i.e. Math.min(...).
Check first that target is not null.
shouldn't it logged not printed?
missing curly brackets.
Wouldn't it be better to only show iterations OR epsilon?
channelId => channelName
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
You need also to do configureConsumer(consumer)
You meant a consumer here I guess?
Can't we create many arrays with this change if there are high partition counts? Maybe we should calculate the size upfront.
toList() should return only JSON object. I understand that getObject(i) can return CBL Array() or CBL Dictionary() ?
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
I think you mean (d<=0)
Could the instance var metricValues be dispensed with and the following done instead? java @Override protected void prepareMetrics() { long now = System.currentTimeMillis(); if ((lastUpdate + minimumRefreshDelay) < now) { recordValues(updateFromZookeeper()); lastUpdate = now; } }
Update labels to go with method names. Alternately, call super.toString for super attributes
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Oh yuck. ;)
Use fire(event); for all EventHandler based events
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
This class has no superclass, so I'm not sure we need to call super() here.
lambda
@komaz autoboxing will be used here, but maybe let's make it visible? .intValue() or equals()
I think it would be more useful to return the SWTBotShell of the dialog that is opened by this method.
The number should be canonicalized before retrieving the contact, using Utils.canonicalizeNumber(number, username)
List<NameValuePair> would be cleaner here, I think.
Is this still true in the latest Ehcache version? Based on that error messages it sounded like we should be doing instead just: c.setEternal(true);
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
Failed to produce *AdvancedInsightResponse* from json
It looks like we create new mappers very frequently. Is that supposed to be the typical use pattern for Jackson? Does creating these have any kind of cost? Can they be re-used?
Shouldn't we avoid to have U+0000 or any other chars not valid for table name in the name? I think we should update TestHelper.getRandomString(int) to exclude U+0000 at least.
Doesn't look like you need a contains check here, "mike".split("\\.") ==> [mike]
this method should probably be final. Also it is missing the @Override annotation AFAICT
Might consider using a [SimpleConfig](<LINK_0> here. Won't make a huge difference with the class as-is, but will make it easier to make changes in the future if we ever want to expand on the configurability of this predicate.
Preferably have one call the other?
Typo. And I think we mainly use the arg name in this situation, i.e. checkNotNull(mbean, "mbean")?
Static import
Static import
Static import
can be omitted
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
suggestion corruptionNotifiers.forEach(this::reportCorruptionToRemote);
redundant. 'super()' is called anyway if you don't call other ctor explicitly.
Style-nit: Should be after this.accountCache = accountCache.
suggestion this.dataStoreMap = new IdentityHashMap<>();
to remove, just use new ArrayList<>() in the constructor, two lines below
addAll
Use Collections.singletonList() instead
new Double is redundant here
not public
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Remove useless assert
There's a formatting issue.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
The switch in the createPermissions function is now obsolete, it is never called with anything else than AUTHORITY_ENTITY_PREFIX
this snippet feels like it should be a static method that you factor out and can use here and in the above method, like private static Set<LeasedLockToken> leasedTokens(Set<LockToken> tokens)
Do we need to preserver the ordering? If yes we probably need to do Collectors.toCollection( LinkedHashSet::new )
use same type for instanceof and force casting
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Could you use one check of CoreUtil.isNullOrEmpty() here?
Won't it better to through the exception in case of an error?
No key for encryption? ;-)
You could probably use the same URL as in getResultById here.
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
null? why not just a () -> {} ?
why do you need to clear sortedSessionSet and add chsenSessions again ?
Again, this is too much specific logic that this component does not need to know about. It should only depend on Prefs.showEditMenuOptionIndicator().
This is too much specific logic that is spilling over into a very general function. The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does.
Just a tiny thing, I guess we can move the condition to an assign statement, it could be easier to read since the conditional expression is quite complex now. int mutePreviewOverlayVisibility = showMuteOverlayOnVideoCall() && muteButton.isChecked() && !isInGreenScreenMode ? View.VISIBLE : View.GONE; mutePreviewOverlay.setVisibility(mutePreviewOverlayVisibility);
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
Mann knnte das auch ohne "username" machen:  java if(...) return authentication.getName(); return "...";
This isErrorOnBehalfOf flag is really odd to me & doesn't seem to be necessary. It seems like you should be able to refactor this code to no longer use it....ideally you should return immediately after any call to response.sendError() (to avoid anything else trying to add to the response). So, maybe this method could be refactored to simply check for the header here, and call getOnBehalfOfAuthentication. If that method throws an error, catch it and call sendError(). Otherwise, proceed as normal.
same here. we don't need to set explicitly for blob not found cases.
shouldn't this be "ServerErrorCode.Blob_Expired"
how is this test any different from the one above where the parallelism is set to 9?
Shouldn't GetterTypedIdentifierAggregate be used for this test instead of TypedIdentifierAggregate?
Should we really throw an exception here, instead of simply returning empty?
Let's import nullRef() statically.
Why would this make sense? Just because of the order?
Not null, not empty, no blanks? There should be a pattern for a valid Java method name.
This test against methodName seems to come too late. For efficiency, it could occur after the assignment and before the reassignment. More importantly, can methodName ever be "<init>"? If the method is <init>, wouldn't node have to be a ConstructorInvocationNode? Also, the reassignment could occur within the receiver != null test.
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
as is in 718
Catch exception.
Try using StringUtils.isTruthy(this.path)? <LINK_0>
add this selector to UI mapping at the beginning
rename to className
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
!reason.isEmpty() can be used
return null to make this more explicit ?
in case closing one grouper throws ex, we would still want to close the remaining ?
Don't know if FixedChannelPool#close is idempotent or not, but it would be better if we could make closed an AtomicBoolean and call super.close() only if it wasn't called before, via closed.compareAndSet(false, true)?
This shouldn't be closing the underlying store since it may be shared with other 'NamespaceAwareCoordinatorStreamStore' instances.
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
No if check needed, just always set the reference to null.
What we are waiting here on?
But we have already clicked the button in the command before, haven't it?
Are we really need to wait 2 seconds if we are waiting on web element anyway later?
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
Please use TestException so we don't mistake them with any other RuntimeException failures.
I'd increment a counter and assert its 1.
qry -> query
Store magic number in private static final?
qry -> query
Do update all the places where you can now just use typicalBundle, instead of getting it again.
Why is this line needed here but not in all the other tests touched in this PR?
Why not use the verifyUnaccessibleForStudentsOfOtherCourses in the parent class?
consider moving those functions to TwitterWidgetPageObject and name the method:  createPageWithWidget
remove OnWiki
casting looks baaaad
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
Maybe the simpler:  return Objects.hash(podSpec, podMeta);  or maybe not, because that involves an instantiation of an array under the hood. On the other hand, it leaves less room for error. :smile:
Where did 31 come from? Why not use *=?
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
I think we should return a dto here and do the marshalling of the response in the IL as we do with other responses.
![MAJOR](<LINK_0> Remove the unused method parameter(s) "request". [![rule](<LINK_1>](<LINK_2>
Setting the clock configuration is not about replacing keys.
Is it really necessary to set prototype scope for EVERY Provider ? I do believe it can kill some logic if some bean of Provider.class should have singleton scope (in custom code for example).
Can you use getBeanNamesForType ? Then maybe you don't need to do any type checking
Why is the StepScope newed here? Why are we not just passing in the existing one (assuming you could pull the instance from the beanFactory...)?
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
If component is null, this will have NPE'd by this point if typeMapping does not happen to be a type that allows null keys (most don't)
Can this throw in getCachePopulator instead of in the callable? that way there's a failure immediately.
When you will use I18n.marktr with ON_VERTEX you will have to use:  java JRadioButton bVertex = new JRadioButton(I18N.tr(ON_VERTEX));
The 18N parser is not able to recognize static properties, then you should not set the concatenation of string and const as a translation key.
I18N.tr("Add WMS layer") ?
You've declared it to be an string in the schema so why the need to convert it back to an int?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
This code is correct, but it could be implemented in a more succinct manner that is a bit easier to read: public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrManagedConnectionFactory ) return this == other; return false; }
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
This method has an external annotation now.
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
This does not need to be public. Instead, just pass the builder to the private constructor. See what we do in HtmlRenderer.
FYI, proper English grammar is "must not be null" or "must be non null" (I'm not sure if grammar requires a hyphen in "non-null").
Okay this is better where it can self-heal and reconnect. Fix checkstyle issue however!
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :)
You can change this to catch ComparisonFailure instead (in which case, it's perfectly fine to call fail() in the try block)
My checkstyle is exploding with "magic numbers" here. You could easily use the constants from the Items themselves here I think. And if not, please make these numbers constant fields in the test. <review,testing,logic
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
Improper way to handle interruptions. They need to be propagated up by re-interrupting the current thread
log should say store is not initialized.
Too many dots, there should only be 3!
this looks like a memory leak, should this be remove?
Shouldn't you add a inQueue = 0; here?
should call clear() on timeStamps and values ... this will cause null pointer exceptions when calling add after clear
Should close kill the memspace? What if someone want to reopen the key?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
The producer is create using try-with-resource clause thus, the producer should be flushed on the implicit close() anyway? Thus, I don't think explicit flushing would help?
I remember it from a conversation but just wanted to make sure. This code was not working as expected and the brokers IPs were not refreshing. Right?
Why is it a list of lists, not just a list?
Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
Better revert.
diagramEditor = null; --> to avoid potential memory leak
toExpand/toCollapse & co. should be reset to null, or they will leak model elements and SWT/JFace widgets.
Can we combine 'pathPrefix' and 'stripPathPrefix' and only strip when 'pathPrefix' isn't null?
Does any of these have to be protected?
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Why is it a list of lists, not just a list?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
i remember that month number should be 11
Consider invoking gc.stop(true) in finally block to ensure gc is always stopped. Also, be sure to handle potential concurrent blobKey removal between this.getBlobKeys() and gc.mark().
This line gives a warnings in Eclipse because implicit boxing between false and Boolean.FALSE is used. Better import import static org.junit.Assert.assertFalse; and use assertFalse(repo.getObjectDatabase().getPreservedDirectory().exists());
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
Since there is a @FindBy defined for courseid, I think actually can just refer to that
Same as above: I think it is clear enough without the id variable same for below too
It would be really nice if event updater will get some kind of criteria that will determine how often you do this instead. That will provide an ability to test it in an easy way and to make refresh interval configurable
i think we should log those errors instead of printing them
Should use the log, maybe a warning.
It may be worth expanding this to include say: + "who also have 'Push' rights on " + GitRepositoryManager.REF_CONFIG
Is this change related to supporting commit validation by plugins?
This is now comparing to the value from cmd.getRefName but before it was ctl.getRefName.
This will get logged twice and pollutes the log. Can we add this info to the Exception which will get logged.
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
enclose if and else within { } even if it's a single line
mark this method private as this is only used in this class.
Minor - we can do fb: and fbkey: as static final strings instead of hard-coding them here?
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
Last nit: static
I would use a less "negative" name, e.g. "eclipse.show.wrapByDefaultPreference".
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
I'm missing the new field in the toString method.
> Alternatively, as we're concerned about usage of the image in a Wiki article, I think it makes sense to copy the wikicode for the "thumbnail" image rather than the wikicode for the full image. I agree with the thumbnail approach, pictures are almost always displayed as thumbnails in wiki articles AFAIK.
I'd rather toLowerCase() is applied after substring(), not before.
You could remove the braces around the first check.
This is not necessary.
@xpdavid is this the right thing to do?
Please keep this.cell near the related fields (previousFamily & cell count) below
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
I think this should check that also the non coded value is not blank, we normally user StringUtils.isNotBlank
Please no, let's not have compactedChain being null legal. What is it buying us exactly?
Same here, return ImmutableSet.of(this.modelResultStream, this.rootResultStream);
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
As noted above, just put the init code in init() unless there is a reason not to.
should this be wrapped in a try-catch, so that we can do ServiceStateLogic.setExpectedState(this, Lifecycle.ON_FIRE);? For example, see DynamicClusterImpl.stop() and AbstractApplication.stop().
Why does it resolve controller home? is it better to name it with HomeDir? It's because this class not only called from controller but agent.
Can be made package local
Seems like a reasonable change. Can you extract formatter.withZoneUTC() into another constant to avoid additional overhead each time?
We must find a solution that works in all languages.
Formatting - elses should be on the same line.
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
This check is useless as the customParams can never be null.
assertFalse(...);
assertFalse(...);
How about a String consisting of entirely spaces? Like this: java String empty = " ";
Are we sure that bricksForTask will never be empty? otherwise builder.length -2 would cause error
return builder.toString();
I would prefer "refresh" and "filtered" without the ?
you forgot to inline into one liner method as moti suggested on patch #1 .. :-) other than that - looks good to me.
s/A submitted/The submitted/ s/task/event/ Also, is it possible to add some info here? perhaps the event's type or something like that?
Missing types
"data" is already a plural noun.
Ok, that's true, up to you then if you want to change it.
I understand that it's better that this method is defined here as an utility method. > Since there are already two types of implementation (using existDatabase or try ... catch as you mentioned) to do the same thing. The meaning of those 2 methods is same but 1st one needs to call API calls twice. Exception handling cost is cheaper than 1 API call. And createDatabase method sometimes throws 409 because the request ~~should~~ is sometimes retried within our API components. So, ConflictException handling is necessary. Please consider about the above things.
Wondering if we shouldn't fire event in the way we do in CanvasLayoutUtils.fireElementSelectedEvent
Can you move this variable assignment into handleGetDatum since it depends only on session?
I don't see where we handle HibernernateException.
@dalifreire let's get rid once time used variable
we can remove this validation since it's done encodeAltSequences now
Can you replace IDs with names in this log message?
is the Env.isMacOs() needed? as you pointed out to me. it would anyhow as raised it will just throw a NCDFE. Either that or we add Env.isLinux to epoll also. I agree i totally was wrong earlier. so i don't think the Env.IsMacOs is needed like you originally said.
Unnecessary logging - there should be enough logging from the call to stopAndRemoveContainer that we don't need to log anything extra here (also, a full stracktrace from TerminationException doesn't tell us much that's useful).
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
Same here with length() == 0 -> isEmpty(). I'll stop mentioning for the rest of these :)
mining -> mining != null should be replaced by Objects::nonNull
Why are you alternating between generationPipeline.isLastStage and comparing directly to LIVE?
That is small duplication. If you add extra parameter key then you can replace two methods with one
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
Should be private, could also be static.
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
That will throw NullPointerException if event.optJSONObject("metadata") is null. Better use Optional.ofNullable.
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
you need to first trim input otherwise this doesn't match if input starts with whitespace
this else seems redundant
Given that we check in the called overload, this method could skip the check on lines 119 - 121 The same concern applies to some overloads in other splitters.
Why propagate and not simply Thread.currentThread().interrupt()
Can we log chargeId/ChargeEventId ?
isTraceEnabled is not necessary here ?
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
debug/trace/remove?
Need to check that the event is for this context.
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.findEventLoop?
Need to add an overload which also takes keyOps
According to [the spec](<LINK_0>, the scope parameter is optional. It is already present in the ClientSecret object and we're configuring it in the Azure OAuth module. Is there any reason why it is not being sent in the request?
Would be cleaner to call cancelAll() here. My expectation is that we would clear state and start afresh during a new session
Why not use slf4j format standard? log.info("Heartbeat exceeded for host '{}', last response arrived {} ms ago.", getHostname(), getHeartbeatTime();
use markers like {}
uncessary call to super. No need to visit further.
In addition to methods, we could also cover functions and anonymous functions. That's what we do for [JavaScript](<LINK_0>
Duplicated use of tree.simpleName().name(). Please introduce a variable
Why does it need any change?
@fanifieiev RequestOf is a better name than RqOf.
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
This has to diverged internally. Mady, can you incorporate this?
Maybe worth removing the call to Objects.equals() here too, as both child and parent can not be null.
I think INDEX_TEMPLATE is right if the underlying form has jr:template set and DEFAULT_MULTIPLICITY is right if the underlying form doesn't have it. So it depends on which you want to match. I expect both would give the same results, though. Is that not the case? I think using a constant would be better than the raw value.
I marked this in #951 already.
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this anonymous inner class a lambda [![rule](<LINK_1>](<LINK_2>
If I got it right, this is the only place where you use ZKAuditLogFormatter. Why don't you just use String.format() instead of a custom formatter?
Have you considered skipping the line above by having something like Queue<ControllerAction> result = new ArrayDeque(queuedActions);
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
ohh.. actually we should default to 443 if https!
casting isn't necessary here, is it?
A better builder instantiation pattern would be having the Builder constructor private and have a static builder() method in the outer class. The usage pattern is like:  java RestStreamClient.builder(host, port).create();
So does this mean that pumpkins are easily duplicated?
Formatting (extra {})
use info if it's not an error
How about applying this method inside convertColor to avoid duplication and to make sure the same input sanitation is applied? Looks like in all cases color.trim() is desired before calling convertColor anyway.
Please add a check here that would simply return if the color being set is the same as the current foreground color (linkColor).
remove this.
(nit) suggestion .computeIfAbsent(partitionId, k -> new PartitionUpsertMetadataManager(_tableName, k, _serverMetrics));
suggestion Objects.requireNonNull(partitionId, "'partitionId' cannot be null.");
same here, can be package private
The value here is null right? If so why we try to print the value? I think it should say Empty userID. Also, can we use StringUtils?
Does it?
I think you're removing the wrong parenthesis ;)
typo: perfrom -> perform
We can validate only if validation is running?
Would it be better to hold this a member variable or maybe even break it out and put the resonsbility on the client?
This method as discussed is used in a synchronous() fashion. Not sure if you intend to do this in a separate thread
I don't think it should be renamed
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
I'm not understanding the logic here. If isHTTPSForwardedProtoResolver returns true, why would we want SecureForwardedProtoAwareResolver to return false?
@v-stepanov isn't it changing the behavior? Before this change we used to log 102 but now it's not clear if the status in the response is going to be 102. I think this is a special log for calls to consumption API where we only know the real response status code afterwards.
Remove braces
getAccountRequestCount.addAndGet(1)
Same as above, get the caller user/account from current context.
I think I saw DateTime.now().withZone(DateTimeZone.UTC) in some lines above. Should we always make timezone explicit? DateTime.now(DateTimeZone.UTC) is the shortform iirc
let's call it updateCodeMinings() instead.
This doesn't work if the editor has a file open that is not in the workspace. Don't we have something somewhere (SelectionUtils?) that would make this work also in that case?
Don't we need an index-based AST?
I don't think this should be public; or even be a method.
configure is user-overridable method, and also there is no need to trigger it here
please use a capital 'U' in 'Touse' to make it more readable :)
This method causes several build warning.
File
null? why not just a () -> {} ?
It is possible for this to return null if no matching Activity is found, e.g. if one has no browsers install or no browsers set as default (not sure if this will happen). In such case we should do a null check and return null. Also can you put a space after ,? Thanks!
queryIntentServices() might return null
Travis is failing due to this empty line. Removing it will fix the checkstyle.xml exception.
@antonini please name it user
@antonini please name it user, and initialize it with Opt.Empty
@ekondrashev move this assignment to line 103 above.
The writes in this method should be done under a lock, right? But I'm not sure that all execution paths do acquire this lock. Should we add synchronized (buffers) or checkState(Thread.holdsLock)?
Why going for semantic here ??
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
I'd use << 3 to match MemoryAddressHash
no need for the "this"
For String, you could probably use equals instead of compareTo() == 0: > compareTo returns 0 exactly when the equals(Object) method would return true.
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
We should throw an exception here too, saying the cluster is invalid.
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
If component is null, this will have NPE'd by this point if typeMapping does not happen to be a type that allows null keys (most don't)
wrap with Collections.unmodifiableMap() ?
Should we add a utility method that calls MetricRegistry.name() to make fully qualified metric name that includes datastream.module?
nit, Collections.EMPTY_MAP?
Why it's "EXTERNALVIEW"?
I think protected might be more appropriate
probably better to call the panic(...)below
Do these methods actually get used? If not, then maybe throw UnsupportedOperationException instead. Then, if someone tries to use them, there will quickly be an exception thrown.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
nit, Collections.EMPTY_MAP?
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
can not -> cannot Maybe Chid name instead of Property name?
!reason.isEmpty() can be used
why not put this all in one if condition? if (input instanceof EditPart && ((EditPart) input).getModel() instanceof ConfigurableObject)
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
This seems to guarantee an ClassCastException, given the input might only be a string, url or uri at this point. Maybe in this if there should be some sort of default configuration based on system properties, that would make it choose the caching or not caching path?
is there a version with more parameter than 3? If not i would use == 3 rather than >=.
I would rework the flow to avoid the duplication of this condition:  if (isSetCookie(tree)) { if (tree.arguments().size() > HTTP_ONLY_PARAMETER_INDEX) { ExpressionTree httpOnlyArgument = tree.arguments().get(HTTP_ONLY_PARAMETER_INDEX); if (httpOnlyArgument.is(Kind.BOOLEAN_LITERAL) && CheckUtils.isFalseValue(httpOnlyArgument)) { context().newIssue(this, tree.callee(), MESSAGE).secondary(tree.arguments().get(HTTP_ONLY_PARAMETER_INDEX), null); } } else if (tree.arguments().size() != 3) { context().newIssue(this, tree.callee(), MESSAGE); } }
There is also an assertEquals(float expected, float actual, float delta) method which only used float and has a delta. It won't be caught by this.
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
c --> clazz (google style is no abbreviations)
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
In tests we can just declare that these methods and the test methods "throw IOException" rather than catching and wrapping them, and just get rid of the catch clause.
You're not closing DataOutputStream. Check SparseVectorCodec too.
All these operations that copy between byteArrayOutputStreams are doing a lot of unnecessary array copies which might be worth looking into as performance problems in future profiling.
Have you intentionally omitted index check?
Is this correct?
minor return (typeID & FLAG_UNKNOWN_SIZE) == 0; instead?
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Please use PathUtils.validatePath to make sure that the path is valid before accepting it.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
Not atomic. Two threads can reach line 100.
Not thread-safe, despite use of a wrapped ConcurrentHashMap. registered.contains() and registered.add() are not collectively atomic.
I'm kinda ok with 1. although fully share your dislike it introducing APIs About 2. I guess I get where it's heading, but not fully understand it yet, so cannot be sure
do not expose the list directly
Collections.EMPTY_LIST;
Can be made package local
Please merge those two nested if statements. It can be just one.
java && SCMTriggerItems.asSCMTriggerItem(job) != null && job instanceof ParameterizedJobMixIn.ParameterizedJob  :bug:
Use !...isEmpty() or assertFalse(...isEmpty()?
latest from today's discussion: return URL
This should return a URL
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
you can't get here with vm == null, so it should be removed from here.
why not to compare with the standard java way for enum comparison (== VMStatus.Suspended) ? and don't you need to check whether it is different than Suspended?
return status != null && status.equals("ON"); is correct and sufficient
this is obsolete
copy-paste error, you want that to be sysErrFilePath :-)
I wouldn't do that, instead I might throw a RuntimeException and/or use our logging mechanism to log the exception. IIRC printStackTrace writes to stderr which could be not inline with our logging framework.
Do we want to use the LOGGER as well? There are other usages in this class where we're using both.
a workspaceitem should be returned
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
Move to a separate commit
Timestamps have no unit ?
Can we put this function after all the other field declarations? This looks a little messy.
assertThat(c.getParentCount()).is(2);
Remove these lines, you don't ned them. There is submit() method that does this standard thing.
These might look a bit tidier as static imports
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris ? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers 'motif' also as Linux, along with 'gtk'. It seems SWT supports motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
I am not following here - why do we want this in sync block?
You should have moved it here.
This should be a composite error with the original error followed by the handler crash. Example: <LINK_0>
This does eventually emit the CompositeException. Is this consciously wanting to handle each error individually instead of only via the composite?
no need for an ArrayList
Thanks for checking, have you considered the trade-off of toggling the timeout to be something very short, like 5ms?
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
0 is a legitimate option value for min. selectable choices. Why not -1?
dont think a setter type function should return the "this"
I'm missing the new field in the toString method.
We have to close the Cluster instance here as well, otherwise the process keeps running forever after completing. Also this should be in a finally block to make sure we close it even in case of an error
why are we changing the visibility of these methods?
I don't see where we handle HibernernateException.
I would prefer constant there.
The correct name is 'IPAddresses' with upper case for IP part.
Again, not your mistake, but fix this description if possible. There is much better descrption on devel/gui in attributes. Then you can delete '//FIXME'. Thank you.
The DateTime.now().plusDays(4).toLocalDate() seems like a "magic number" that isn't really clear where it comes from. It would be better to set a value to the expiration date inside the testBoletoExpirationDate method to explicit it or compare it to some constant
I believe this should be true ?
suggestion Log.i("INFO", "Starting onClick on fab from FragmentDiets");
negative logic
negative logic
Why did we switch out the old code back to this?
@amihaiemil should be length()
use this.size()
Use threadlocal random
This exposes the unicode workaround to the public.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
we should return immutable list. You only expect caller to do read operations, right? #Closed
assertThat(map).doesNotContainKey(new Object());
Optional: more compact write possible Map<String,Object> map = new HashMap<>();
this should be able to reused. it can be a static field
Shouldn't we instead go to the TabLayout activity here iff we have a selected instance (i.e. you didn't get here from the InstanceSwitcherActivity)?
when autoconfiguration fail, the app should not continue with demo user, you must do nothing, you will be in no-login mode
According to my own tests, using values-night allows you to omit this (in multiple places)
HttpServletResponse.SC_NOT_FOUND
Please make sure the word class is not added to the message before the class name.
remove this redundant method
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
As I think a DTO needs to be returned; we should implement this method.
no need to check for null again...
I remember this method in one of Anmol's patch as well. Can we move this to some common location, as it would be useful for others as well?
I think it is not only the platform name. W3C defines a bunch of keys, which must be supplied without prefixes and Selenium has this list somewhere in constants
Use map.entrySet() to avoid the unnecessary lookups
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":\"string\"}"
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":{\"bar\":0}}}"
"CS-RSTR" to a final variable?
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
This is using scheduleAtFixedRate but task DirectoryScannerThread never terminates.
Could use this::updatePartionInfo
How about making these constants as static variables?
It seems like this happens even if there is no filter. Is that right?
return type is double so -1.0D ?
I'd add an always-printed log message here too to make sure it's remembered.
IOException is enough same as in mapToJson
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
Do we need this?
nit: if {} else {log.trace()}.
can we use sysprop or something for url?
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
I suppose we could use CollectionUtils.isNotEmpty() here but I'm not sure that buys us much.
should be first in the line, so that it returns if isEmpty, without trying to parse
Fix method name with prefix..
Should the constructor just take firingGroup? Then, you can eliminate some of the other params.
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
ParkingPositionLayer - delete
Probably just cast to MediaOverviewActivity here, instead of multiple casts on the next few lines. To be fair, I feel as though this should all be part of a single callback/listener call.
omit using return in void methods, it is less readable and it is hard to debugging
return a copy of the data to keep DataExtension immutable.
Just return data.
not public
let's call it updateCodeMinings() instead.
almost forgot... i have warnings here. Do you have them? could them be fixed?
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
The incore merger works in memory without a working tree. Does he need attribute handling?
should we use camel case here ? s/expectedrepositoryAttribute/expectedRepositoryAttribute/
Any specific reason we are handling 2 tables in a single file? This might throw off some people. Also, if we are making the separation, wouldn't it be better to do it in FluxC? I haven't thought about this too much, so I am actually asking and not suggesting :)
Do we want a space here before the brackets?
we don't assert anywhere that on success cli exits with 0.
I this refactoring, very nice. Could make this method protected.
You'd probably dispose your stuff, and call super.dispose() at the end.
we should probably call EcoreHelper.unregisterEcore on dispose, shouldn't we?
timed --> direct
>=
You can still put the assert if you want. assert (p > m_LoadMeterTimerPeriodMin); It will warn the designer that something is wrong, but the code below will recover when in production.
do we want to assertFieldCountEquals here?
Can be simplified to java return itemMaterial == null ? 0 : itemMaterial.getMaxDamage();
Why did you leave changes for this method out? This method looks like the other changed methods.
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
There is a lot going on this one line.
Hrmm, should this be needed? I wonder if this is a sign of something else being wrong.
We should have an alias getSource() and deprecate source().
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
Should use ToStringBuilder.
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
Coding best practices: Interface i = new Implementation();
toList() should return only JSON object. I understand that getObject(i) can return CBL Array() or CBL Dictionary() ?
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
@exper0 no need for the extra indentation here
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
empty function? also no qualifier (public,private)?
Should be removed if empty
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
reopen -> open
should be logged.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
A miss?
Can't response be null? ex. if there's something completely different listening and answering?
I hate this line - I see it everywhere.
Something minor: You could use ConfigValues.class.getSimpleName() instead of hard-coded class name.
Yes, unless there's something I'm missing the constructor could be private.
If your're storing the meta-data in the view as attributes do we also need to maintain kieAssets in KieAssetsDropdown (that appears to be used to be able to retrieve an instance of KieAssetsDropdownItem based on the value selected in the drop-down). Personally I think it might be better not to store the meta-data in the view however I just raise this point.. you can decide how best you think it should be addressed (if at all!!!)
Consider using streams,: return node.getActions().stream() .filter(action -> action.toLowerCase().equals(path)) .findFirst() .orElse(null);
Please add curly brackets to the if statement
Add If task repositories then version = "" and currentRepository =null
If this logic is need, please find a way to reduce the code duplication. see azkaban.test.Utils#initServiceProvider
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
Why is this change necessary?
This println can probably be removed.
this is 3.3 feature, not 3.2
This should be as it used to be, no need to convert to lower case as that should already be part of the "value()" implementation of SELinuxMode.
Oops, (start + end) / 2
This shouldn't be changed, instead you need to change getAllCount() to return VisitService.getAllVisits().size()
java return bytes >> 20;
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
Please remove an excessive space character.
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
Won't fix.
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
Is this not needed anymore?
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
Let's implement this in pre listener. Also need to implement doPreSetUserClaimValue()
Is there reason for throws Exception in signature?
No need for super()
calling super not needed
Please make the constructor private (see Invalid).
Are we not closing file handles now? :)
[ is missed
static?
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
a workspaceitem should be returned
Same here? It is always number or null?
Nitpick: you can save yourself a couple lines of code if you write this method like:  if (dynamicTemplateData == null) { dynamicTemplateData = new HashMap<String,Object>(); } dynamicTemplateData.put(key, value);
We have a removeConfiguration so let's not allow null value here?
Use InvalidArgumentException instead
Enum.values() creates an array each time it is invoked, it should be better to cache it statically and iterate over index to avoid the garbage created by the iterator.
Please remove an extra empty line.
It looks like the second check (_params.size() > 0_) can be removed. If the params is not null, params.get() will not fail. After that, we have two cases. If params contain "fullDetails", we will have only two checks instead of three (params.size() is removed). If params does not contain "fullDetails", we will have also only two checks (as in the current implementation, with .size() in place), only that we replaced .size() with .get().
debug.
Can we check that all params are declared as classes in a single place? Now, we have to copy this check for each signature.
I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on. However, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.
I would like more specific catch clauses. catch'm'all is a bit crude (and it will also happen on the ApiServlet level.
Should this link to the course?
public?
I'm missing the new field in the toString method.
java this.fileSystem = requireNonNull(environment, "requireNonNull is null").getFileSystem(EMPTY_CONTEXT, baseLocation);
can't the response be null? if null as return value is legit for non existing snapshot, move the initialize of the VM into the condition.
That should be toHtmlForAnthology. You mixed those two up.
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
static.
Please convert baseDir to absolute path too. Otherwise, jadx skips all resources if run on file without full path like: jadx some.apk.
I think you're missing getDefaultConfigurationFile() here.
It would be great to cover the util method with tests.
str == null cannot be true here as this was already checked upfront by <LINK_0> (it also correctly results in null there). We could also move this empty string or 0 length up under that check as it would be same for both functions.
nit: style wants newline
Should use a constant instead of a raw String
Use Set or SortedSet as variable type.
The sublist could use a vraible for readability and line length
enabled first
it may be better to put enabled to the top of the list.
Add shared state
events.isEmpty()
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
I worry that the the name is potentially confusing; size could be interpreted as the size of the batch, in bytes, or the number of events in the batch. My brain went to the first and had trouble reconciling with the code. Maybe consider something like numberOfEvents or countOfEvents?
I would prefer to use full words. For example directoryAllow.
Why don't we 'stick' with the previous String version, that is directly the type that we want?
I am thinking if not better to get init parameter of form: schemes.* instead of split... do getInitParameters() and enumerate extract what is prefix schemes.x sorted. not critical, but will allow comma within name...
nitpick. Suggest to use a init factor " new ArrayList<>(batchSize)"
Do you need any null checks here?
you can directly declare batches as ArrayList<Collection<T>>, so no need to do further casting again. And same to batch.
maybe use single quotes to avoid having to escape the enclosed double quotes (applies to the rest too)
I think can just use the @FindBy defined at the top instead of findElement() againt
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
As noted above, just put the init code in init() unless there is a reason not to.
I'd suggest calling this init method from the context file instead
This reads as if TenantIndex initializes the BoundedContext.
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
How about making use of a try-with-resources block to simplify things a bit? java @Override public Object getSparkObject() throws StandardException { try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) { ObjectOutput out = new ObjectOutputStream(bos); out.writeObject(value); out.flush(); return bos.toByteArray(); } catch (IOException e) { throw new RuntimeException(e); } }  Also, why are you throwing RuntimeException instead of StandardException?
whole block indented one extra
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
One more static import here?
Debug leftovers? ;-)
we never use NULL, it is a bad practice in general.
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Do we want to have null maps here? Can't we follow the same pattern and default to empty ones?
Isn't this very inefficient? It seems that this loop might easily be executed 100 million times in a typical run. Can't we just increase the size in one step?
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
Maybe it would be good to be consistent with MigrationResource and return the deleted entity in a response here as well.
spacing *sigh*
Missing StringUtils.isNotNullOrEmpty() check
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
A log message is better than printing the stack trace.
These parameters are too complicated and redundant: baseURL and baseURL + id
Why we want to fall through into the loading dialog in case of error?
1. The code that tracks memSize needs to not run when the resource profiling is not enabled. 2. You don't seem to handle mutation of the strings. What happens when the string is replaced?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
I think this is a typo -> this.high < this.high -> should be -> this.high < other.high ??
Is the reversed order on calendarName intentional, or should the comparison be made the other way around?
Original line: return this.version.compareTo(other.version) this does not match?
@pynicolas Unlike the other getters, this getter does not return a copy (ImmutableSet.copyOf).
Collections.unmodifiableSet(optedInHistoryTypes)?
This is an breaking public API change -- we can't allow this.
here we need to go through Optional.ofNullable(Plaform.getProduct())
Even if you do it in AvdCreationDialog, would you mind adding the SWT.SWAP and the force-relayout thing? A call like getShell().layout(true, true)) when changing the text should force it to wrap properly, as you'd expect the label to behave in the first place.
Move the message to NLS bundle. And not sure about the text... Can you discuss it with @maxandersen?
suggestName?
method can be protected now (private if not isolated in tests).
Remove these extra variables that aren't used except in a setter.
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
Just log the exception as a warning here, since this happens because of user calls RealmAsyncTask.cancel(). It is not an unexpected error.
It'd be informative to mention how long we will wait in the log message.
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
public?
I'm missing the new field in the toString method.
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This would add IGNORE_RETURN_VALUES to the provided explicitFlags set if it was not empty, which we can't do. Maybe instead we just create an EnumSet that starts with IGNORE_RETURN_VALUES and add explicitFlags to it and use the resulting EnumSet.
can't you use thenApplyMakeStage() here?
Thinking we should put a IGNORE_RETURN_VALUES flag always for this. We don't return the previous values to the caller, so it should be much more performant.
It is here that runtime.matchesFilters(pickle) should be used to select the pickles to run.
Item dropped should be a hopper
Consider returning a constant
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
id is not part of identifier. For example testing with urn:nbn:de:bsz:14-qucosa-22579 results in wrong urn:nbn:de:bsz:14-qucosa-id225798. Correct value must be urn:nbn:de:bsz:14-qucosa-225799. I can provide some more examples if you need them.
suggestion if (values.size() > 1) { return IconTheme.JabRefIcons.MULTIPLE_LINKS.getGraphicNode(); } else if (values.size() == 1) { return IconTheme.JabRefIcons.LINK.getGraphicNode(); } else { return null; }  We talked in JabCon2020 a bit about this and we think that it would be better to directly load the icons here instead of introducing a new field URLS in StandardFields in the model package for a ui feature.
final List<T> sorted = ...
Here, size is the number of currencies.
Should be final.
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
I'm still having a hard time groking end > start. The typical pattern is to say start < end, its easier to visualize. I think we can also drop out a subtraction instruction from the inner loop here if we are a bit smarter about how we handle the bounds: int ptr = end - 1; while (start <= ptr && isWhitespace(raw[ptr])) ptr--; return ptr + 1;
Also, this whole method could be shortened to a single line: return (INTERVALS != null) ? filter.getFilteredRecords() : filter.getFilteredBases(); Oh, and another thing: protocol in this codebase is to put spaces after the 'if' and before the braces. Otherwise, you risk incurring the wrath of @nh13.
should we set it true by default ?
I think there is some findbugs issue with not using {} not sure.
I missed this one before, but if (!eventString.isEmpty())
why the newArrayList? Iterables.filter already returns an iterable.
Iterables.filter(Iterables.concat(bob), isAssignabe)). use iterables methods on iterables?
Is it one because getAttributes(tu) returns the attribute specifiers, not the attributes themselves?
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
missed one
Use an immutable list builder here? Or does result _need_ to be mutable?
I think InstanceGroupType.GATEWAY == type is equivalent with InstanceGroupType.GATEWAY.equals(type) and as I seen we are mostly using == in case of enum comparison
No need for a builder and a list here. Something like the following is more concise and easier to read?  java immutableEnvRunList.put(e.getKey(), ImmutableList.copyOf(e.getValue()));  Or use the more functional approach:  java immutableEnv = Maps.transformValues(envRunList, new Function<List<String>, List<String>>() { @Override public List<String> apply(List<String> input) { return ImmutableList.copyOf(input); } });
I feel that we normally don't do this in Presto but explicitly create a new object with old parameters.
- Why is this needed? - replace it with a clone()  private UnweightedDoubleReservoirSample(int maxSamples, long count, double[] elements) { this.maxSamples = maxSamples; this.count = count; this.elements = elements; } public UnweightedDoubleReservoirSample clone() { double[] elementsCopy = new double[elements.length]; System.arraycopy(elements, 0, elementsCopy, 0, elements.length); return new UnweightedDoubleReservoirSample(this.maxSamples, this.count, elementsCopy); }
this is redundant; this method should assume that other is a valid instance
Why didn't you cache the value?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
(ListView)  can be removed
Can you please also refactor file with name layout_list_item_with_menu.
unsubscribe()
Use the activePlayer object instead of retrieving it again
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Are you sure what that event must fire before real resolve, not after? It's named as RESOLVED_ABILITY (e.g. for event that has already happened).
Do you think it would be useful to log (warn) if this evaluates to false?
Shall we mark this as deprecated?
This seems redundant to me as we are logging in as the current user in the base class.
In my opinion, we do not need this log. WDYT?
suggestion final String idProperty = resolveIdProperty(entityType, rawIdType); return new ImmutableRepositoryMetadata(rawIdType, entityType, repositoryInterface, idProperty);
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
This change could break people.
nit: you can merge both lines above as checkNotNull will return the given argument
can we remove: declare-response, useless-assign and just return the object from the method-call?
the same is true for targets, this could also be null and would cause a null point exception. suggestion if (targets != null && !targets.isEmpty()) {
It seems doubtful that without the Jenkins singleton, we have enough working that ending up in retrieveAuthFromCookie will ultimately be successful (User#getById?). Just return null when jenkins == null, and return?
Minor readability suggestion suggestion model.addPropertyChangeListener("scriptStatus", ignored->{
Please throw unsupported operation exception instead, this dao is not used. We're going to get rid of it.
Are locks needed in Build and Merge Aggregators alike?
Can this method remain private?
Formatting of ( DirectCompilerResult... sets ), should be (DirectCompilerResult... sets).
suggestion Set<String> result = new HashSet<>(); if (groupId != null) result.addAll(groupId.getRequiredParameterNames());
Do not make input file names cryptic. Please rename the file to clearly state its purpose.
I think there should be one violation.
Why we declare full path when you created the method getResourcePath to make this simple? Lets change this to use the new method.
should do some validation too. For example, if the input schema is non-null, make sure the fieldToClassify exists and is of type String, and the predictionField exists and is of type double
* shuoldn't we call super? * worth adding some log..
If you do the logic of adding the spacing on and how to behave different for maximised/minimised in here you won't have to do it everywhere else where the text is changed
Notice how the constructor is unable to advertise what is going on. We should avoid doing work in constructors.
Should add the new rule to the config file? (Parse could put directly to ruleConfigs in that case,)
You can use an instance of spring's MockHttpServletRequest here
constant?
Are we comparing InputEdge vs SourceInputConfig here?
Is there any particular reason to call getMuteReason instead of just checking the value of muteReason directly?
I know this isn't supposed to be invoked and I am nitpicking, but should that ever accidentally happen, I'd prefer to either see dummy string returned or an exception with explanation.
This should all be on one line :)
suggestion throw new UnsupportedOperationException("Setting a UidHash is not supported for SinkTransformation.");
RemoveSnapshot may fail on the validate() methoid - so perhaps we should iterate over the disks and free only those who are in LOCKED status.
probably a good idea to catch an EngineException (thrown by runVdsCommand) here, and log.
During the RemoveSnapshot execution the images may become illegal, that'll return them to OK - we should skip that part if we are on that phase.
Please use a bigger max value. We were limited to small integers for VCS for historical reasons, but there's no such limit here.
why not using the super constructor? super(nodeId, nodeLabel)?
same....I'm just going to stop and wait to see if this actually gets caught
Should this be onReplicationPutRecord?
It doesn't look like accessRecord works well under the concurrent access, there is a lot of non-volatile and non-atomic operations inside it. I assume it's an intentional compromise and that's good enough for stats, right?
I don't like mixing static and non-static methods in the same class, especially when they have so similar names, so I'd rather move these to a separate class, e.g. Eventually. Or, if you don't want to affect the core tests, you could just replace your TestingUtil with an AbstractStatisticsTest extending AbstractInfinispanTest.
I wouldn't change the default.
Another case of a suspect null return. Does it make sense to return null? If this means we fail on the next few lines, better throw some sort of a configuration exception or IllegalStateException here
Wouldn't it be more appropriate to raise a configuration exception here? This will lead to null pointer exception as far as i can tell
You can also return true here and return false at the end of method
same here, you can directly return true
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
trace
Every statement has a return, so just use different ifs after another and you don't need the last else nesting at all. Can be apllied many times in your PR. Makes it easier (at least I think so), as we have less deep nesting.
I would either inline this method, or give it a more precise name, like initializeContextPath
What does this change do?
changing fBackgroundRGB should also change the fDimmedForegroundColor since it's a blend of fBackgroundRGB and fForegroundRGB
Please simply make this method synchronized
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Do the traits have to be ordered? Could you use a hashset instead?
Not needed.
Why aren't we passing in the fatalErrorHandler or Dispatcher::onFatalError?
Catch exception.
Dianne will tell you to remove this. This is logspam.
matter of taste, this could also be return this.profileTypeRegistry != null;
Wrong grammar. The log line should ideally be "su command is enabled"
I think this method should check only case 'b' and have proper method to explain the problem. All the other case are covered by 'nicActuallyExistsOrReferencesNewBond(..)'.
We should not get into firewallType being null, it should always be set for cluster add/update. If it's null, then proper error should be raised
if you use de-morgan on the second half of the predicate you get: iscompat() && getNetwork() != null && !isAttachedtoExternal() but isAttachedToExternal() checks for null network so you can abbreviate to: iscompat() && !isAttachedtoExternal() :)
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
make it protected. It was my fault to make all API constructors private. I fixed that. In master branch all API constructors are protected, so anyone can extend API in their code if they want. But couldn't instantiate directly, forcing them to use singleton
Formatting issues. Please fix.
I'm not a fan of adding a getSlice method to block. Is there any other way to do this?
Recently someone told me that booleans are hard to maintain because you don't immediately see what the true /false really means. You could use Order.ASCENDING and Order.DESCENDING here instead.
No need to fill a newly created array. What do you think a out the following?  if (filterResults == null || filterResults.length < positionCount) { filterResults = new byte[positionCount] } else { Arrays.fill(filterResults, (byte) 0); }
Throws AIOOB exception when called with index = line count.
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
index < arguments.size() ?
Was this detected by findbugs?
please implement asLong() method instead of Long.valueOf(id), see asGuid(id) for details.
please throw UnsupportedOperationException isntead
Should these have some kind of validation, e.g., non-negative, from less than to?
Doesn't look like conditions are same.
Are these cases all needed? Or what all of this just copied from categories?
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
This logic is not correct since it would stop at the first '\r' in "// blah \r blah \r\n".
Is this still true in the latest Ehcache version? Based on that error messages it sounded like we should be doing instead just: c.setEternal(true);
same thing  java return container != null ? container.accept(this, expressionDefinitionId) : null;
See the ! in while (!( container could be null, an NPE will occur in container = container.eContainer()
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
this is confusing, it is called router but actually it is routerUrl.
I see this is used just in kie-wb-common as log message, however maybe could contain also fact/field, or some more details.
maybe sth like content.avro.deserialization? so in the future we might add content.json.* metrics, it would be weird to have .json as root metric
Here dirName should never be null, and delegate should always be null.
So you removed final, but keep it immutable * Returns an empty list (immutable). This list is serializable.
Please don't use null here. Just pass "" and make stateKey always concatenate.
racey single check
What about items and label?
hashCode and equals are inconsistent.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
I think you want isPossiblyOkHttpTimeoutBug(cause) otherwise it will SO.
This can be simplified java if (throwable instanceof AmqpException) { return new ServiceBusReceiverException((AmqpException) throwable, errorSource); } return throwable;
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
getNonEntityNonCollectionRegions creates a copy of all the collections, let's lookup the other maps...
Should the scanner be closed after the call ?
static
This isn't doing anything special (such as transform) before calling forEach, so write it as a normal for-each loop
If we're using a stream here, we could probably do the whole thing with it. Something like: suggestion containers.parallelStream() .map(cont -> Pair.of(cont, ImmutableSetMultimap.copyOf(Multimaps.filterValues(globalAnnotationData, new ModContainerPredicate(cont))))) .collect(ImmutableMap.toImmutableMap(pair -> pair.getKey(), pair -> pair.getValue()))
Integer.toString(length) or String.valueOf(length) seems a little more clear to me.
I think this should be > 0 since a value list item of 1=One does not work.
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
Is shutdownNow more appropriate (which would interrupt running tasks)?
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
see in Volt how to properly shutdown an executor service
Is this still needed after removing the download stuff?
what if my value is " " ? should use trim
I think this should be > 0 since a value list item of 1=One does not work.
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
Never rely on the ToString() method of a type. What if it change in implementation class for debugging purpose? Use thrown.name() instead.
concat empty str ?
Do we want to keep the method names like this or give it a more general name?
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Everywhere in this file please use getAncestor() instead of getFirstAncestorOrNull() where possible. getFirstAncestorOrNull() is designed for multiple values types.
Redundant brackets suggestion return tryActivateAndGet(e, stack.getItem()) != null;
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
why do we have a ; here?
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value.
other methods like this put name first, then id. switch for consistency
Can we use url building here, to avoid problems with / at the end of the server.
You could also use -> Objects.toStringHelper() from guava
What about using String.format instead:  String.format("Injectable type: Invoker, accessor: %s, method name: %s, invokes method: %s", methodLocation.name, methodName, mName);  Seems more readable to me
Why removing failure? It is the failure reason.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Constructor can be package now.
not needed
lowercase for package names.
Remove throws Exception
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
recordCount++; doesn't work?
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
You may want to also validate |sec|. Since it's only @SystemApi maybe it doesn't matter too much though.
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(smartpayTemplateData::setStateOrProvince);
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
Why not make this create simple string and then invoke the setAddress(simplestring) , there by not needing the two new methods and logic encapsulated in the setAddress(simplestring)
why did you remove this ?
Silly nit: space around expression.
nit: space between if and (
logger says "Unsubscribing"
Add final keyword.
This formatting looks off
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
should we use "this" on line to make more evident what we are doing
This should return T.
Implement this
suggestion return getInstance();
Here we should return Polygon or MultiPolygon or create two implementations?
This should be private unless there are plans to use it outside the class.
What do you think: java if (!context.getDestinationType().isInterface()) return context.getMappingEngine().createDestination(context); if (SortedMap.class.isAssignableFrom(context.getDestinationType())) return new TreeMap<Object, Object>(); return new HashMap<Object, Object>();  to reduce the deeply nested if statement. And we prefer no curly braces if there is only one statement in the if/else as our coding stye.
Why is the copy here necessary?
Make the fileInfo map immutable.
Immutable fileinfo
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This is the trouble with cond commands we've talked about...
Looks like the client and the member proxy implementations diverge if the maxIdleUnit is null. Client interprets maxIdle as milliseconds in this case, while MapProxySupport throws NPE. Same with ttlUnit btw. This needs null timeUnits to be passed on the interface methods though. Is this expected?
similarly here, if this is general, I've lost updates...
nitpick ... this should be renamed to simply gammaId, it's not necessarily new.
Suggest using a return variable and returning that once thus eliminating the two return statements.
Add instanceof check
Include message saying what was wrong if check fails? e.g. including the original ref argument passed in.
Unneeded parenthesis. You probably can one-line this method anyway :)
It is completely implausible that compile returns null if it didn't in testPattern01. So this check is redundant and should be omitted.
assertFalse(...);
assertFalse(...);
How about a String consisting of entirely spaces? Like this: java String empty = " ";
It feels like there's a lot of context and state that's being managed here that would be much cleaner to delegate to a composed cacheState object (which would also make it easier to change this later more safely without requiring safely updating 5-6 implementaitons
This is already read above?
Now it's not compatible with the write method. Revert this one too.
unnecessary array new: {{true}, {false}} should work here
unnecessary new Object[], and there shouldn't be a space around the contents of an array initializer, e.g.  public Object[][] getLinearIndexFactoryTypes(){ return new Object[][] { {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed")}, {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed.gz")} }; }
Please add ? and % as well
Totally optional: we could tighten up the code a bit by getting the boolean value for !DeviceUtil.isOnline() and then passing it in as a new param to conditionallyAddPendingClient: void conditionallyAddPendingClient(FeedClient c, boolean cond) { if (cond) pendingClients.add(c); }
Is it really needed to create a new instance of WikiSite or couldn't you just use the one passed to this method?
This kind of breaks the really clean streak of "new Client()" calls with no arguments. Could we make it adhere to this pattern?
@lvydra Please remove 'parameterName.equals(NAME) 'from this. My apologies; I should not have listed 'name' as an invalid key in the JIRA description. I've corrected the JIRA description.
should be memory (you have mem_usage twice)
create an issue and add a TODO to review this situation with other components (try and scatter-gather pop into my mind right now.)
java this.onPostServerTick(this.getMinecraftServerInstance());
Get the size directly don't use getAllEvents()
personRepository.count()
nit, Collections.EMPTY_MAP?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Don't we have to say that this is uniqueId JDBC?
It's better to use shift operators here. Instead of java value += (int) Math.pow(2.0, (double) i);  it's better to have java value += 1 << i;  The left-shift operator is equivalent to 2 to the n-th power (2 ^ i == 1 << i), and has the advantage of not requiring conversions to floating-point and back, and also avoids any expensive operations that happen inside Math.pow. The left-shift operator is a single assembly instruction :)
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
braces
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
Another place where the name should probably be updated
Just some concern for security: should we output user/pass here?
move this line before above line, After super.cleanup method couldn't do any of the server requests.
better do the close in a finally block.
Fix the log statement. There are no executors in this class
Please consider map.computeIfAbsent
Here it's OK: it really may returns an instance of anonimus implementation of ARPMH
Why ISE instead of IAE? This is a setter. Assert.isTrue() ?
Modifying generated code is risky. We should extend the EditParts (with a CustomDurationConstraintLinkEditPart), and instantiate these custom parts in org.eclipse.papyrus.uml.diagram.sequence.providers.CustomEditPartProvider Also, DurationObservationLinkEditPart should be modified in the same way
I know we tend to always do remove/install in our code, but this is actually not needed: org.eclipse.gef.editparts.AbstractEditPart.installEditPolicy(Object, EditPolicy) will remove (and deactivate) any pre-existing policy in the role we want to install the new one.
does superclass installs one? or is it only to remove the one added in the line 110?
this could easily be done when creating the repository as well.
Add If task repositories then version = "" and currentRepository =null
Wouldn't you want to always reset loc, regardless of whether localName is loc or sitemap?
Can you move the System.getProperty calls to methods on RoboSettings? We're trying to make that a central place to hold all system properties.
Debugging code?
nit: combine with assignment this.strategy = requireNonNull(strategy, "strategy is null");
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
studentsWhoRespond -> studentsWhoResponded
where are the exclusive locks, that should prevent taking these locks in case of live storage migration, are taken? neither LiveMigrateDiskCommand nor MoveOrCopyDiskCommand are annotated with @LockIdNameAttribute
port is a primitive, so this null check is redundant
nit: ordering is different.
nit name is null or empty
You can condense this to DISPLAY.asyncExec(() -> progressBar.setVisible(visible));
loadDrivers should really throw an exception if something fails. On first start this will fail the start of rancher server. But on reload (addCallback) the exception should be caught and ignored.
What about the previous mImageReader instance ? It should be closed when detached .
Lists.newArrayList(entity.operatorIDs))  What does operatorIDs represents?
Maybe some not-null check should be added here.
@mkuligowski can you please revert this empty lines?
> HTTP_API_VERSION [](start = 51, length = 16) also what does the http_api_version mean? :) #Pending
Does this also require a null check similar to setcontentType() ?
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
why is this not private?
update metrics as before.
No log?
Should we include the label too?
I can see what you are doing here, attempting to avoid an NPE if fbo is still null. However, an instance of this class doesn't need knowledge of the width and height of the fbo except when it generates the task or updates it. So, I'd remove this IF block and I'd remove the printout of fbo.width() and fbo.height(). Those can stay in the task. Also, I'd remove the private fbo variable: we can instantiate one briefly when we need to gets its width and height, in generateTask() and update().
Another thing I was thinking in this context is that if have pairs of state changes such as DisableDepthWriting and EnableDepthWriting we would no longer need to use getStatus at all in this line, as the class name would be enough.
In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
Please check if this method really should be public in a private static final class. The parent method is protected.
Copy-paste bug - should be "getDeviceListWithoutStatusSupported"
allOn4_1 does not really correspond to version.onOrAfter(Version.V_4_2_0) which means versions >= 4.2.0
Expected value should be first.
why is this true, shouldn't it be false since neither of the attributes have a kind?
The pattern we've adopted is to use ImmutableList.of. In this case you can use ImmutableSet of and then you don't need to create a LinkedHashSet.
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
suggestion private void addAppsTable(SQLiteDatabase db) {
Any specific reason we are handling 2 tables in a single file? This might throw off some people. Also, if we are making the separation, wouldn't it be better to do it in FluxC? I haven't thought about this too much, so I am actually asking and not suggesting :)
I would use something more random here, like RandomStringUtils.randomAlpha(Tv.TEN), for example
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
What are your thoughts on using an AndroidPreferences instead of a raw SharedPrefs?
I don't get the idea of using an array here...
I wonder if it might be possible to format the matrices here in a more intuitive way? Something like the following (last row example): java @Parameterized.Parameters(name = "{index}: checking first row of matrix constructed with string \"{0}\".") public static Collection<Object[]> data() { return Arrays.asList(new Object[][]{ {"0", new int[] {0}}, {"0 1", new int[] {0, 1}}, {"0\n1", new int[] {0}}, {"0 1\n2 3", new int[] {0, 1}}, { "0 1 2\n" + "3 4 5\n" + "6 7 8", new int[] {0, 1, 2}} }); }  I find it a little easier to draw the connection between the input and the expected output with that formatting, but others might disagree...?
Do these strings all need to include the escaped newline? Everything seemed to work ok for me if I replaced all occurrences of \\n with a simple \n? On a related note, would that change make the matrixAsString.replaceAll("\\\\n", "\n") lines removable too?
add requireNonNull for bytes
As Kai already stated the mime type should not be optional.
This involves a look up of the character encoding type table. Use MessagePack.UTF8
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
You should remove that empty line.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
- this.ephemeralCount = new HashMap<>();
It's also not good to change runtime code for tests. The justification is not good enough IMO.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
This not called from anywhere? Besides this one liner can sit at the host severities for now IMHO
Should be 404, not found
Shouldn't this be HttpCustomHeaderClient , not HttpClient?
It'll be better to keep this action too in the Constants file.
Are you sure it's necessary to use the Bus for this? Why not simply obtain a reference to SearchArticlesFragment, and call the startSearch function?
What's the advantage of this vs. adding it to RecurringTasksExecutor and why is this an instance variable?
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
Maybe specify the names in the constructor (SKIP("skip")) so that someone modifying toString() by accident won't break the parsing.
You should use toLowerCase(Locale.ROOT) as using using "toLowerCase" by itself will use the default locale (which may lowercase incorrectly depending on the language)
Please replace with Objects.equals
Suppose makes sense to convert value to lower case before comparing.
Maybe type.value.equalsIgnoreCase vs. just lowercasing ?
The range of valid Long is wider than Integer
Declare this abstract or with a default implementation, then override in subclasses. VarDeclaration always contains a resource; ValDeclaration contains one depending on it's type; TypeDeclaration never contains a resource.
This will need a null check done to make sure the default is returned if the field isn't set (i.e. is null). See getEscapeUnderscores for an example although obviously the default return will be different :)
I don't like how this method has to use the duplicated string. I'm not sure the check is needed but at a minimum it should probably use the isPasswordHashed() method.
This should be implemented as return createUser(email, password, null);
I agree with trimming, but I don't understand why we need to lower-case it.
code format
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
given that specificity of this SV is exception type I would add the exceptionType in this.
Please use prefered declarative approach - attribute in *.ui.xml
No need for ( ) on a single parameter. frame.addLoadHandler(e -> resizeFrame()); will work
I would add: setAlertType(AlertType.INFO); So you have a default of INFO for messages that don't specify.
does not need to be public in non-public class
Seriously dude, don't reformat code for no reason.
IMO it should be synchronized as well
You forgot to add the address to the toString() as you did in the patch on the master branch
@override and function declaration must be at same line.
Can you put here "storagePoolId" instead of "spUUID".
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
In case self is a BufferedIterator should this return self instead of re-wrapping?
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
For non-public methods checkWidget() is not required.
Formatting
Why do you need to enable and then disable? In theory you can just call disable and then it should work (provided you have no direct GL11 calls anywhere)
return filterSet.getActionFilterOrder() != null
I would recommend an else if here to avoid comparing against a string unnecessarily.
You can also return true here and return false at the end of method
context.getClassLoader() can return null
Suppose makes sense to convert value to lower case before comparing.
No, you're turning it back into a string and then recompiling it again! return isNotBlank(value) && TWENTY_FOUR_LOWER_CASE_HEXADECIMAL_CHARACTERS.matcher(value).matches();
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the database.
It's better use org.postgresql.util.PSQLState enum values, however I TOO_MANY_RESULTS sounds strange for that case indeed
Use the narrowest exception required, I think in this case you just need ApiException
We discussed this already, but please remind me: update() is executed, for example, when the user resize the window. Why not to avoid any form of memory allocation in those circumstances, even if it's admittedly small in this case?
Let's remove that TODO: we'll get to renaming things anyway.
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
Should you call analysisReady(false) here?
I don't think that is necessary.
Is this related, or should this done in a separate commit?
You don't need to override this, every Spark 2.x distributions support kafka on kerberos regardless of the value returned by this method.
why not protected, use only extended
Are these methods part of the upgrade?
Thinking we should verify that there are actually 10 active iterations before stopping the client. Same with the reaper timeout below.
that class would be better with a builder, though I wouldn't ask changing it now
Should this use RANDOM_PORT_INDICATOR instead of 0?
Nit: replace the three lines with: assertThat(newValue, is(anyOf(lessThan(previousMaxCellTsPairsToExamine), equalTo(1)))); Same for the other two batch config value asserts.
We try to avoid hardcoding any styles. So basically, we never call setStyle(). Instead, have a look at titleTextField.pseudoClassStateChanged(). Assuming we call the pseudo class invalid, it can then be styled like so: css .game-title-input:invalid { -fx-background-color: -bad; }  ... even though I think that a red background will look nasty :-) So I'd rather go with -fx-border-color: -bad
Are we sure newValue is always non null?
Please no System.out.* calls. Thank you!
Please remove system.out.println and add assertion
Method should be synchronized probably?
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
Where is selector.close(). It is not in NonBlockingConnectionManager::close() (which is where I think it should be).
warn
couldn't / shouldn't getTenantAsString return the uniqueName instead? As we use it everywhere in the TenantUserManager
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
typo in exception message
use parquet.Ints.checkedCast or you could get a negative value out of this cast. <LINK_0>
here too can drop the this for parquetWriteProtoCol and configuration.
Can you use azkaban.utils.Props#getUri(java.lang.String, java.net.URI) directly? e.g. getUri(AZKABAN_STORAGE_ORIGIN_DEPENDENCY_ROOT_URI, null)
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
Unnecessary (and incompatible); revert.
Typically we use Map on the left hand side rather than HashMap
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
Add message to new RuntimeException
also missing brackets
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Is this really needed? I mean I believe the idea here was that getProperties returns an unmodifiable map, while getMutableProperies returns the actual mutable map. Is there a problem with this?
usually data objects never return null where collections is met
you have an empty code line here - just something to remove before you merge.
I would drop that since it is false by default
License header is missing
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method. Update: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Should the third parameter be an empty list rather than null (I think otherwise we may hit an NPE)?
null? why not just a () -> {} ?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
please compare to what you had in the past before you removed this class. log.error("Failed to import certificate: {}", e.getMessage());
Don't use variable names that are abbreviations or misspellings... optimize for readability rather than writability
"expection" -> "exception"
s/install/enable/ (since there is an install command)
remote plugin administration
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
This appears in RawByteBitwiseOperationsCheck.isSecuringByte method, could you move both to a common method in LiteralUtils?
uncessary parenthesis and it is usually not a nice practice to reassign a parameter. Please declare a local var to work with.
Please remove usage of .class, for the same reason as above.
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
I think this should not be executable if the review is not open
exiting, so STDERR
again, since next call is System.exit(), write to STDERR.
exiting, so STDERR
should atleast check o being non-null and instanceof IdentityExtractionFn .
style nit: remove curly brackets
drop the + 1 here, and use < instead of <= ?
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
hashcode can be equal even if the objects aren't - this test is not correct and may lead to spurious failures
I don't think this equals test is necessary
done for patch3.
Please keep this.cell near the related fields (previousFamily & cell count) below
The null argument will lead to a NPE below in notify. Leaving it as this(null) should work.
In fact this test is not useful, the framework will fail to start if the injection can't be processed.
Is it really worth checking before setting it?
You should check for null just in case
Same- catch NPE.
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
should the message include "command _with options_:" + this.options ?
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
these arrays could be static finals. That would save allocating new ones all the time.
use final
Please revert this formatting changes
NetworkStackClient alreay dump ConnectivityModuleConnector. Do we really need to dump it again? <LINK_0>"ConnectivityModuleConnector.getInstance().dump"&sq=package:aosp-master&g=0&l=331
flush and close are done automagically when you get out from the try with resource block
Same here and above.
Same here and above.
Same here and above.
this function can be private
minor typo: SEPARATOR
this function can be private
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
I think in this case we want to revoke (not lose) the partitions no longer in subscription?
simplify this
the null check is redundant here if you refactor this code to something like below  if (SAFARI.equals(wirApplicationName) && SAFARIBUNDLEIDENTIFER.equals(wirApplicationBundleIdentifier)){ return true; }  since we are now comparing a String constant with a variable contents, null check is automatically taken care of because "".equals(null) is always false
How about returning right here and then needing the else cause?
Use HttpServletResponse.SC_METHOD_NOT_ALLOWED instead of hardcoding 405 please.
logging here is redundant, since we throw the exception
Why do we need String.valueOf?
This is still referring to DebugFeatures, I'm surprised it was working?
This shouldn't get thrown.
nit: it seems like we prefer to not put else after return elsewhere in the codebase
remove
Any reason why not to add this as const as well?
uncessary parenthesis and it is usually not a nice practice to reassign a parameter. Please declare a local var to work with.
That triggers a java.lang.NumberFormatException for dsa.generate_private_key(key_size=2048L).
If the method is static and/or statically imported this will return true. This is a discrepancy between name and implementation.
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Don't we have to say that this is uniqueId JDBC?
Use ImmutableList.copyOf when lists are not null.
The status should never be null, instead it should either throw generic exception (including NotFound if that is what the response from the coordinator indicated).
Does this also require a null check similar to setcontentType() ?
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
Maybe use the getStorageId method here?
Just a nit pick: what do you think about having a method that does this if? It's the same logic on line 41.
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
Should just be world, ToStringHelper automatically formats and uppercase keys look odd.
Change toString method to include both
s/offset_start_ts/startOffsetTimestamp/g generally, we do not put underscore in toString
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
return Collections.emptyList();
throws
throws
throws
It could be - can you create a short script to show the issue and open an issue against the repo that contains it?
Great - should this be deleted at some point as these tests run many times / day?
Include message saying what was wrong if check fails? e.g. including the original ref argument passed in.
To better simulate a failure with incomplete content I would rather do jg.writeFieldName("justfieldname"); jg.flush() so that we're sure the result is invalid.
NAME -> HIGHLIGHT_CTX_DATA
Not sure, but maybe it can be injected instead of being looked up? (Same for other services in this class.)
this and m_ is redundant
Using Builder pattern is preferred since the structure can be easily changed.
Why return a value if you don't use it when you call the method?
There are enough mock objects in here that it's worth using @Mock annotations instead.
It might be worth including tests to confirm that initMessage() correctly sets the processorId and doesn't call enableSevereAlertProcessing() on the ReplyProcessor if the processor is null, a test to confirm that send() throws an exception if putOutgoing(this) returns a non-null set, a test to confirm that operateOnPartitionedRegion() calls sendReply() with the correct arguments if a ForceReattemptException is thrown during doLocalClear(), a test to confirm that we call endPartitionMessagesProcessing() in sendReply() when appropriate and a test to confirm that we only call replyProcessor.process() in ClearReplyMessage.process() when the replyProcessor is not null.
Is there any way we can make this stubbing more specific? Right now, once the service has the gateway account, it could be making basically any request.
simplify this
no public
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
s.a.
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
Just an FYI, we have a fairly robust date parser included in EndpointUtil because of variability we've encountered in the past <LINK_0>
We have quite a few isSimpleType( ) calls. Do we want to consolidate these into methods?
why make these public and part of the API? I was thinking of these methods as implementation. If we make them part of API then we have to support them.
can you add to Builder as well
@erimerturk let's add info on who subscribed to the bout
I don't get this method name.
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
this.
In order to reduce the overhead of creating additional objects, we prefer to use null checks instead of Optional.ofNullable. For more information see gh-7155.
you're testing for silence, but detect method returns true? shouldn't return false?
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
This call will lead to an NPE if no thing type is found for the thing.
anything speaking against using storage.containsKey(...)?
Isn't this already done at <LINK_0>, so here it would be a duplicate call?
Revert this line?
change to List
well, I would prefer list.toArray(new String[list.size()]) - you save one instance :)
Package private should always be enough for testing. Use the same package for tests.
Why : is in brackets? Why you only check capitals, you sure drive letter cannot be lowercase? I think windows case insensitive so it could be if user typed lowercase.
can this use the MMX StringUtils functions?
Use the enum Dark...
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
this for is exactly the same in all the array tests, let's move it to a private method
DRY: would use this(username, password, null) instead
remove
Minor: Ideally we should avoid doing work in the constructor. Pas apiRooUrl and Client to the constructor, and provide a factory method receiving apiRootUrl, username and password and creating the constructor dependencies.
The range of valid Long is wider than Integer
This will need a null check done to make sure the default is returned if the field isn't set (i.e. is null). See getEscapeUnderscores for an example although obviously the default return will be different :)
You check for null in EventListener so I guess you need to check for it here as well.
bad hashcode.
This needs to be changed to return the long value.
Use Guava hashCode function
I wonder if new DataMigrationForSanitizedDataInAdminEmailAttributes().doOperationRemotely() is enough.
Isn't it enough to declare Exception here? An exception will fail the test, regardless of the specific type.
We will probably run this from maven, and will use it to write to a "target/generated-metadata" directory, which won't initially exist, so please create the directory here if it doesn't exist: File outputDir = new File(args[0]); if (!outputDir.exists()) { outputDir.mkdirs(); }
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
this should probably fail on receiving interrupt
"expection" -> "exception"
please move the check to be after canDetachDomain() which validates that the domain exists. We'll need to move also canDetachStorageDomainWithVmsAndDisks() in a separate patch.
it's already checked that the vm is up/paused/down in line 45..so you will never reach here with the vm locked.
Why set the messages only when the cluster supports gluster? This looks like a generic "Move Host" command, and setting corresponding messages (VAR__ACTION__MOVE and VAR__TYPE__HOST) should be ok irrespective of whether the cluster supports gluster or not.
Should use the log, maybe a warning.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
this ought to call verifyNoAsyncErrors(defaultTimeoutMillis())
Return the zone id here instead of returning an empty string.
Should this link to the course?
The ID is used to restore old files (from an older release) so this must not be changed!
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Missing StringUtils.isNotNullOrEmpty() check
It is still public. Why?
it's better to init customFields with an empty collection to avoid "==null"
What if the specified custom bond mode has more than one digit? You should read the whole number till the next space after the "mode=".
Maybe just return map.computeIfAbsent(x->create())?
trailing /?
This is calculating the character count in each iteration. Would it be better to calculate the required size in advance?
studentsWhoRespond -> studentsWhoResponded
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Should this line be: subscription += ", product = " + getProduct().getId();
Did you use our code formatter? <LINK_0>
Even though it is technically correct to have no braces for a single line statement inside, it is better if you can add braces for clarity.
Should be "this" because the theme is different. If we use application context, the pop menu is black while activity them is white, inconsistent behavior. Could you modify the code and perform verification?
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
Shouldn't the test have some validation step?
I think here you can also check the cache actually returned correct event type (first time and second time)
Yes, I understand the double convert is a sort of necessary evil at this point. Can we make use of Path.normalize() to get rid of the last "/"?  groovy> java.nio.file.Paths.get("/home/jlocker/").normalize() Result: /home/jlocker  What I'd really like to see is a unit test with a couple of input/output sample values for the getSolverConfigResource() method. That we can safely experiment with different approaches and be sure that the use cases still work.
task.get() will throw a NoSuchElementException if the task doesn't exist. is that what you want? wouldn't it be better to return an empty string?
Why not return Optional.of(ImmutableMap.of()), like we do in FileHiveMetastore? It's expected that statistics might not be available for tables.
I'd add an always-printed log message here too to make sure it's remembered.
s/long/int  public int getMaxSamples() { return maxSamples; }
Why not declare GLOBAL_ID as a long?
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
Again this would all be cleaner if you didnt have that intermediate IMicroblockContainerTile and just used caps.
simplify this
These effects need their text changed as well
This needs to be removed
suggestion RaidCondition.instance,
wouldn't it be better to first register the observers and then trigger the action? - in this case up till now I guess not an issue, but I think it also doesn't harm to do it anyways, does it?
This is not necessary.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
Is this stray? Or do you actually set it to test?
is there a reason why this method isn't implemented?
do not assing parameter! nowhere!
You can use getDbFacadeMockInstance() instead of mocking it yourself
Should be added the Override annotation.
The test is OK whereas it shoulf fail as the code fix is not merged
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
A miss?
SpeedController not CustomSpeedController
Maybe IOException since it's supported here?
this test will be filled?
why ignore the group specified by user
Should just return properties.get(), the containsKey() call is redundant.
Is this call necessary? It is called on line 109.
looks like the variable name also needs an update in some of these methods
Or, assertThat(category.getAttributeList(), hasItem(Core.TITLE)) (this will print a more useful message when the test fails).
The name of the MetacardType could also be null in this case.
can super be called first?
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
This is returning a mutable collection but SpongeRootCommandNode is returning an immutable one. Is it intended ?
I don't think you need this new String
While we're removing validators that just return true, consider fixing validEmail
There is also StringUtils.removeStart for that
Lazy load this to a field.
We don't use this. on methods...only members.
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
Please make a null-ptr check.
Null-ptr check, please.
You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)
Explicit type argument can be replaced with <>.
public
IntelliJ IDEA tolds me to remove this unnecessary boxing.
@Override
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
Should add the rule to config file?
<LINK_0> handled the case when metadata was null, does that check need to go here also?
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
Another area where Boolean unboxing may not be needed.
Is payeeIdL a typo or intentional?
Why do we need the scheduler address? It should come from the Hadoop configuration.
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
not so readable. looks like good candidates for parametrization
Could you please make this an extra bit more specific like -SNAPSHOT? Thanks! :)
It is not enough to judge empty. You should also judge the value > 2.7.0
StringUtils.equalsIgnoreCase() should already be null-safe, so you shouldn't need a non-blank check here.
Generic type not used, remove.
Why can't this take the display from the instantiating class, the CPD? You can't use Display.getDefault() in the workbench, it doesn't always return the correct value.
More accurate error message
The operator should be && not ||
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
A little wasteful when all you need to do is just set the fields and return this...
BlockPos.ORIGIN
What's the point of the 6 trailing zeros ?
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
We can get rid of the above variable
Can you add message to the assert so that its easy to tell which assert failed? assertEquals("Slot size", 1, slots.size());
I used to do this a lot, but now i don't think it is right to unwrap. <LINK_0>
Args need to be included in operation.
@mariofts we don't need to throw CacheException here? I didn't get this change.
this should throw, shouldn't it?
In this case the order should be configurable for each of the event emitting listerners. This can be done via a Spring Boot property i.e. spring.cloud.task.events.<batch event listener>.order=<order#> . For example: spring.cloud.task.events.job-execution.order=<order#>
@fanifieiev it isn't the correct way to calculate hashCode. Please, look the others Cactoos classes to know how can do it.
Please add a note why this cant be implemented right now
this method should be implementable
![INFO](<LINK_1> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_2>](<LINK_0>
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
bad selector
Missing opening "(" before getDescription().
does this need to catch all exceptions?
fieldNames
Any pointers why don't we just throw recreate() exceptions as is? Looks like all other places don't care about exception wrapping
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
remove line
The value here is null right? If so why we try to print the value? I think it should say Empty userID. Also, can we use StringUtils?
do not assing parameter! nowhere!
Pull this into a static final variable
should this count be parameterized?
PlayerBackpack is redundant here, no need to specify the class you are already in.
no more need for public, I guess
maybe not necessary, but protocol is case-insensitive - maybe should be equalsIgnoreCase used?
Nested strip invocation seems unnecessary. But maybe I am missing something?
The warning message and the other one is very detailed and more related to transmission of activities. I do not know if it is helpful to mention a sender in the message as these are utility methods. Furthermore even if you see the message in the log file it is not very helpful at all as it does not include the path and you also do not know in what context it did happen (I guess it is the XStream Marshaller when converting activities)
If sharding key is /abcde, are these paths expected to pass this check and supposed to use this zkclient: - /abcde_0/xxx - /abcde/abcde-0/xxx
Don't forget _innerSharedZkClient. otherwise stack overflow.
Shouldn't this be >= and not <=?
See ByteByReference.java
See ByteByReference.java
why hardcode?
this should happen in the host mapper
this should be in the doPopulate() not in deprecatedPopulate()
I would propose to move the code to separate method of **SeleniumWebDriverHelper** class similar to **waitVisibilityAndGetValue**.
Might to replace on the exist _waitAndClick(By elementLocator)_
Doesn't String.format need a value to be formatted?
Should only be for the provided keys?
Use one pattern consistently: Either model all sync calls as asyncCall.get() or Model all aysnc-calls as sync call + CompletableFuture.completedFuture(null) I'd prefer making async the more general API and expressing the sync-variant in terms of the async one
An alternative to materializing a list of StoreKeys for every CompositeBlobInfo is to return a "view" of chunkMetadataList: java public List<StoreKey> getKeys() { return new AbstractList<StoreKey>() { @Override public StoreKey get(int index) { return chunkMetadataList.get(index).getStoreKey(); } @Override public int size() { return chunkMetadataList.size(); } }; }  It seems like this would suffice for the two use cases that need the getKeys() method, the getChunkIdsOnly option in the router and BlobIdTransformer, as both of them are just interested in iterating through all of the keys and not mutating the list.
Use type ChargeDTO in return responseEntity instead of ?
This is the method that could take the inputStream and apply the logic you had in HttpCommand to read as a String
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
This is another behavioral change that I don't want to see in an unrelated PR.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
Why can't you just return value here?
delegate=true style would be just fine.
It's common to throw AssertionError() for these cases, since they should legitimately be impossible.
You can use MoreObjects::toStringHelper().
use a dedicated method hasParameter(tree)
You can probably stop at METHOD level as well. If you reach a CLASS or a METHOD, before an ASSIGNMENT or a VARIABLE, it can not be stored in a static final field. Now, you may also want to group the KINDs you target by category for consistency (CLASS and METHOD are failing stop conditions, ASSIGNMENT and VARIABLE allows you to investigate further)
I would make explicit tests for every kind (or switch) and have overloaded method for those. That will make classCast less likely to happen. Here there is a lot of implicit going on. Let's make thing explicit. checkIfUnknown(MethodInvocationTree ) checkIfUnknown(NewClasstree )
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
I think this should return a Class<? extends Map>.
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
No need for else if you return in the previous if
rename start to startNs
Seems that empty elses are generated now (at least in Java)
Instead say: synchronized (this) { wait(100); } This way you don't have to wait 100ms during shutdown.
?????
Log as _error_ or _warn_?
nitpick: should be bindingAdapter
please fix formatting
Code can be reduced. I think there is no need to make these functions (they are only being reference here) :)
I would ignore empty notifications and would log warning.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Missing StringUtils.isNotNullOrEmpty() check
Why did you only do this for HealthReportBroadcastService? AnnouncementsBroadcastService uses a similar paradigm.
You can reduce this whole thing to:  if (Intent.ACTION_VIEW.equals(getIntent().getAction())) { //initialize }
Add { and }.
return flagdown; ?
return defaultFilterFactorEnabled ?
Returning isAuthRequired by default sounds gold to me.
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
what's the intent of this change?
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
For loop?
Instead of binding to an instance here, you can create the eventBus instance via an @ Provides and @ Named evenBus instance for injection into GuavaApplicationEventPublisher.
This should be declared in another location, e.g. WebModule. We always need this set declared but not every server binds PluginModule. In particular the server that powers gerit-review doesn't bind PluginModule. :-)
This should be declared in GerritGlobalModule.
You should change the error message here to be about AWS rather than GCR.
Minor: Can you inline this, since getStreamConfigs is private anyways?
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
final
Exceptions.propagateIfFatal() Could we be stricter about what exception we're catching here?
return (input) -> ... is more readable
true?
rename to resource
Can be done like this: @Test(expected = NotFoundInDbException.class)
You should probably test with both pessimistic and optimistic transactions, and pessimistic with both RC and RR isolation levels. Also multi-node tests can reveal more issues than single-node ones, I think (testing both owner and non-owner variant).
What happened to near-real-time and the error handler? Regarding the latter, many tests use it currently
cacheContainer().statistics(exposeGlobalJmx)?
I think it would be suitable if some kind of padding is applied between messages, such as a newline
suggestion getPlayer().spigot().sendMessage(ComponentSerializer.parse(message));
Why do we need this constructor? It doesn't use the 2nd parameter...
@v-stepanov isn't it changing the behavior? Before this change we used to log 102 but now it's not clear if the status in the response is going to be 102. I think this is a special log for calls to consumption API where we only know the real response status code afterwards.
if rolesAllowed is null, doesn't that make denyAll effectively true?
Don't use TABs in your code. Please replace all of them with 4 spaces.
you can put as a second argument default property like "not found". so it would be: return properties.getProperty(VERSION_ATTRIBUTE_NAME, "not found");
You could use StringUtils.endsWith(str, suffix), since it's null safe.  java return StringUtils.endsWith(version, SNAPSHOT);
It is not enough to judge empty. You should also judge the value > 2.7.0
please put each parameter in separate line :)
Should we do three separate queries, one for each filter?
It's easier to read if expected values are provided.
Hm, you got java doc on the next method, but not here?
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
should be logged.
This can be refactored to m_isTable = "true".equalsIgnoreCase(table)
minor: this not required anywhere.
Checking for Not null is sufficient here. We don't need to check !auditRecordList.isEmpty() as we are clearing the list.
should be returnValue && vmDevice == null
If returnValue == false, why we need to run that code? Also same question regards diskAlis, which u also inserted here
why this change and not just specify which disks are locked which would provide more info to the user?
Why not make al these Calculate classes private to the method? Creating new ones everytime is a bit useless
The language server definition is not taken into account in the following getLSWrapper method, but this method is not deprecated. In case we need a way to retrieve a specific language server (which could make sense), we would need an implementation for that, or otherwise remove that parameter from the method signature - I would say.
similarly to the LanguageServerWrapper constructor, this should be private.
Can this be null?
move this to tearDown
We should add a check to disable this (and also log an error) after Oreo, since we don't know if this will be removed in the future.
Please make this constructor private to force users to use the builder, thus forcing the validations
doc is missing
maybe create builder - number of constuructor arguments is too big.
Generally with these kinds of constructors you'll end up calling the other constructor directory, passing in null for the ignored param.
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
nit: Suggest renaming iterations and its getter as well here
Should be protected. Knowledge of link text belongs in Page model classes. A Page class should expose an addDilution() method rather than clickLinkButtonAndGetUrl("Add").
I don't think this is tested. Is this classic thing of some use anyway?
I think we should avoid returning WebElements as we want to minimize interaction outside of the page object.
I think you need to call setSize instead, which does things like updating the bounding box.
So... is this right? When vanish is false, the entity in question should unquestionably be collidable. I'm a little worried that we're getting into a spiderweb here where we have a bridge method named one thing and the key named the other. One school of thought is setting VANISH_IGNORES_COLLISION and VANISH_PREVENTS_TARGETING to true should not be cleared by setting VANISH to false. That feels largely expected and I err on the side of agreeing with that. I'm thus not against this change myself, but we need to make other changes to insulate ourselves against other issues. However, I know this is in impl, but bridge$setUncollideable and bridge$setUntargetable should really be named better to indicate that they are on vanish only. Their representive is methods should then be renamed similarly AND include a vanish check within their bodies. I'd rather check one method for collisions, rather than tacking on a vanish check everywhere too because it's not obvious that's what needs to happen. If we want/need separate non-vanish uncollidable/targetting states then we need to think about that more, because we now need to think about how this will work with the vanish based states.
Extract the string to NbtDataUtil please.
tableScanSchedulingOrder
:+1: I prefer just using this form over the other string().toString(). Do you plan to do that with the other Domain classes as well?
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
minor: could be a function reference instead?
Can we use the earlier isEmpty here ?
this seems like it's going to be incredibly verbose. Can we nix tihs?
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
If your initial value is Double.MAX_VALUE, then this reset must be the same
A little wasteful when all you need to do is just set the fields and return this...
Change to: include = true; (@jessehatfield, @meiercaleb) Or should we have a config option for each restriction? (i.e. conf.isInferHasSelf()) It appears that some visitors do have a unique config option while some don't.
nit: Could be this.conf = requireNonNull(conf);
Do we need the conf here? I don't think it's even being used.
you could just do setConfirmWindow(null); like above method
suggestion Span span = tracer.buildSpan("JenkinsBuild").withTag(DDTags.SERVICE_NAME, "jenkins").start(); // Add span to cache in order to retrieve it in the endTrace method. DatadogUtilities.severe(logger, null, "startTrace - Cache key: " + buildData.getBuildId(null)); DatadogTraceCache.cache.put(buildData.getBuildId(null), span);  You don't need the scope here since the interesting work is happening after this method returns. You may consider adding the build or job id as a tag to the span.
This could be confusing here. How the user know the all fields?
Let's do just one more tweak here. I understand that you need this check in order for anyMatcher to work correctly, however the current solution will break this scenario: java .anyMatcher() .requestMatchers(AnyRequestMatcher.INSTANCE)  While it would be odd for a user to do this, we want to be consistent in our behavior. Since java .anyMatcher() .anyMatcher()  is disallowed, so should the earlier one also be disallowed. It would also break here: java .anyMatcher() .requestMatchers(AnyRequestMatcher.INSTANCE, new UrlPathRequestMatcher("/path"))  I believe the answer lies in adjusting the anyRequest method implementation. If we don't set anyRequestConfigured until it is actually configured, then I believe the extra if check here is unnecessary: java public C anyRequest() { Assert.state(!this.anyRequestConfigured, "Can't configure anyRequest after itself"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; }
We should mention this default value in the getter and setter
useSSL and sslPropertiesLocation must be propagated from here.
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
in some cases lhs/rhs could be null, pls do the null checks appropriately
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
You can't just remove a public method. Someone, somewhere is using this.
This needs to choose the target when the ability triggers, not when it resolves. I'd use adjustTargets to do this.
Must be ANY, not YOU (At the beginning of each end step)
this doesn't need to have the ability and effect both be optional, just the ability is fine.
hell no
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Map<String, Map<String, String>> properties = descriptor.isDeprecated() ? deprecatedProperties : removedProperties
Can you mark this @Nullable please?
align the null treatment in all three methods
use new Guid(String) - this literal can't be null
shouldn't you convert the logType.getDuplicateEventsIntervalV value to millis?
can you please also change logType.getDuplicateEventsIntervalValue() to duplicateEventsIntrvalValue
Please add current memory amount. Also, before checking '>' please check getCurrentMemory is not zero or null.
This should check the environment variable before returning true.
Check env variable before returning true.
Check the env variable before returning true.
Catch exception.
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
Might be good to create a custom subclass of RuntimeException for use here, especially as it would allow for the code that catches the exception to handle it differently from other RTExceptions.
Do you have a test that peeks the next sequence number?
Instead of asserting the number of events, I would try to assert that the messages I expect came back. (ie. message 1 and message 2)
Might as well be a static?
this.
Use LinkedList instead, as we need to remove its head frequently in endInput.
Why is it a list of lists, not just a list?
This is not equivalent to the old code (was size >1, now it's size >0)
:bug: Binary compatibility
Same here, add deprecation flag.
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some collection is being emptied. actually looking at the code in the clearAttachments, you are computing the attachments to remove. this makes sense, and is also consistent with the row above 'bondsToRemove.add' but is obscured by the name of clearAttachments. secondly, the last line in the clearAttachments() method is not dependent on the id that is being passed to it. so this line should not be there. it should be here below line 60. then you can rename clearAttachments to calcDestAttachmentsToRemove. this would make the flow symetric, consistent, readable.
I'm not sure if we can do this in this way. I did few refactorings in NetworkImplementationDetails but that's not my code I and cannot guarantee it's validity. Looking at it now I cannot see that implementation details with 'managed' field to be false being created anywhere. So I'd guess, this field is wrong. If so, we can use alternative way ~ UnmanagedNetworksHelper. In my abandoned patch you can peek at how it's used if necessary in class named 'UnmanagedNetworks' and at usages of this class, but it should be easy enough.
please check if not duplicate with the method in quota helper
does makeFilters need to be called again here? can you just use filters from previously?
I am just wondering: what happens if this sql command does not complete and throws an exception? The system will be in an inconsistent state of having submitted the flow, but not having it registered in the DB (and not be in the RunningFlows map, etc). Should we handle this scenario?
Should we add logging to indicate this condition?
is it necessary to encode duration iso standard?
Move the jsonGenerator.startObject() method call here, so the subclasses aren't responsible for creating this. It is confusing this way.
The [Akka docs on serialization](<LINK_0> suggest using Serialization.serializedActorPath(theActorRef). Not sure in which cases that yields a different result from this code here.
let's update all the includeTextDetails references to includeTextContent
validateBlankPdfResultData() is this method is only specific to Receipt result lets update it to validateBlankReceiptResult() ?
if recognize from url, shouldn't content-type be application/json?
Oh please, no! Don't ship a null object! :cry:
Simpler as ImmutableMap.<String,String>of().
Don't initialize to empty when null.
I had copied the following functionality from the MessageListFragment.java: public boolean isAccountExpungeCapable() { try { return (mAccount != null && mAccount.getRemoteStore().isExpungeCapable()); } catch (Exception e) { return false; } }
Maybe we can just return this since we are not doing anything else in the if statement anymore.
wonder if it would not be more interesting to have false here to see that we are correctly jumping into the catch.
lambda
I don't think you need this condition. TranslatorUtils.toDBObjectList will return an emptylist if the key isn't set, which should then be fine.
Need to ensure ordering, per our conversation re. hashcodes :)
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
I think we might need to ask the Metamodel for whether this is a managed type at all. Could be a class unknown to the persistence context.
You'd want something like this:  if (!isCoercibleTo(targetType)) { return false; } // Loop through each element in value and call thisElementType.isCoercibleTo(targetElementType, element)
hashCode and equals are inconsistent.
regenerate equals and hashcode to add maxSplitSize ?
same here use HashUtil.combineHashCodes
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 118-119. Do the same for the others.
Change to use Iterables.partition and return an Iterable
Can we remove this?
not re-using these could have a performance impact -- is it not possible to keep reusing them?
This can lock and then throw. Should it be inside the try so the finally block can unlock?
could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
Tip: we can use StringUtils.stringToInt() here and in getWidthInt().
Rather than return a new arraylist - just return an empty iterable, e.g. return Collections.emptyList();
I'm not sure what this indirection with the t -> business buys us
receiptAnalyzeActivationOperation and receiptStreamActivationOperation are identical. Consider reducing these into a single method.
Should this return the AzureTable?
is there a reason why this method isn't implemented?
no need to extract this out to private method if it's only being used here. same for onClusterRemoved
Check if there is an appropriate constant for "no metakeys" mask.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
this is not correct... I would have hoped we have unit tests for this :). This method should return the cause() and not throw it.
values.isEmpty() - does it mean I cannot have a claim with an empty object, like this:  "warnings": {}  I don't think it is right then. This is a totally valid claim. Same for empty array claim:  "alternative_identities": []
Unnecessary null check since the variable is Object typed?
Don't you check for array size >=1
I this refactoring, very nice. Could make this method protected.
Awesome! Do cache (and invalidate) this resulting String though
filterRowKey should only filter based on the rowkey, here you are looking at specific values. This is most likely called only once per row. I'm guessing the current implementation wouldn't work on SPLICE_TXN, since we'd inspect the latest written cell (COMMITTED or ROLLEDBACK), see that it's not the ACTIVE state and filter it out, which would filter out the whole row.
nit: can replace both checks with CellUtil.matchingColumn
Use key.getLength() everywhere here (instead of key.getSize())
no-else-return rule: this can be simplified to java if (condition) { return a; } return b;
could we print the types here?
I don't understand what this line is trying to do.
To always be safe please use context.getApplicationContext()
Constructor can be package now.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Maybe instead java /** The filename without any compression extension, or the original filename. * It tests for compression types handled by {@link #openFileEx}. */ static public String filenameNoCompression(String filename) { if ( FilenameUtils.isExtension(filename, extensions) ) { return FilenameUtils.removeExtension(filename); } return filename; }  I believe we have commons-io already in the dependencies list. There's some extra check for null bytes in the extension check... but that's not so important. Just simpler I think.
This method kind of represents my point from before. It doesn't need to know or care that the backing data-structure is a database. if(!downloadFiles.fileNames().contains(fileName)))
It may be over thinking this but I got some errors when I tried to make a form name with spaces around the "/" e.g Form with / back slash where as Form with/back slash worked on the device. So maybe we can add another replaceAll() after the first one to replace any patterns like Form_with___back_slash?
Are you specifically allowing air itemstacks to be created now? There is a way to validate that the ItemStack itself is empty (hint, look at the fields in this class).
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
I would suggest making this method synchronized
Not doing getClass().getClassLoader() and just leaving it null would default to TCCL. Not sure which one is best.
this is just a setter, why we need to update it?
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
Is this really needed here and in the next state-change methods?
We don't need this, the ConfigSaved would handle this already.
Remove this
remove this
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
You'll probably want to do the other closes even if the prior closes throw IOException
Also called twice here.
We have a removeConfiguration so let's not allow null value here?
Could throw IllegalArgumentException instead.
Missing a unit test to ensure maintainability.
Can this happen ?
I end up by choosing _myClass.class_ syntaxe (@troger) to be consistency with the different implementations of getAdapter method and in the same think i change to use adapter.cast(this) syntaxe instead by _(T) this_ although it will be end by a double check :) (Class#cast is already check before doing the cast to avoid the classCastException)
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
NIT: move these to separate lines?
Extra newline.
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
The 'when' can be dropped from the log statement.
new String() is redundant.
Does not compile, but not really important.
Shall use dbDir instead of dbDirs[0] array.
Would be good if there is a error message as well, Something like invalid number of arguments...
Does this work if transactionCallbacks contains multiple callbacks? If previous code causes recursive call, I would think ConcurrentModificationException would be thrown.
einfacher: for(Team t : teams){...
I notice that it does not remove all the equivalent solutions, but only a single instance (== is used, not .equals(solution)). Only if the same instance is used several times, then yes it is removed several times. Thus, I would suggest to use equals instead of ==, just in case a different instance happens to be used. It would be an additional fix. However, it highlights another point: is it normal to have several times the same instance in this container? If not, then the current issue might come from a wrong use, although the break fix improves at least the performance.
"= 0" seems sufficient?
avoid having local variable names that have the same name as class variables
null? why not just a () -> {} ?
This could just be: return isFeatureEnabled(context, namespace, name, false); which makes it clearer that the 2 methods do the same thing with just a potential difference in the default.
Get it from the model now that we have one?
Since we get access to the Site here, it seems wasteful to throw it away, and then have to re-expose it through FeedCoordinatorBase. In all the other cards so far, the Site gets passed all the way through to the server request from here. Perhaps the same can be done for Random?
please fix whitespace
Why local fetcher connect to remote server?
return settings == null || settings.isChatColours()?
Why this change?
this is confusing, it is called router but actually it is routerUrl.
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
This can be static.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
is this class going to be created by the user?
Please keep the getter and setter closer.
remove? this looks left over from manual testing.
Why did you remove this call?
Same as the other write methods, it's safer to create a new ArrayList that modify it.
same thing, while you are cleaning, other thread could store other key.
Avoid the intermediate variable and directly assign selfID.
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
these setters should not be public
Null-ptr check, please.
Please make a null-ptr check.
Should use the log, maybe a warning.
can be !isDisabled()
Last nit: static
Can the value returned by Java this.browser.syncRun(String.format("return %s.length > 0;", selector.getStatement()))  be null? If this is the case, you need a nullcheck before returning the value as the implicit unboxing needed to convert the returned Boolean into a boolean (which is the actual return type of the method) will throw a NPE if the value is null.
Should we alert the user that an error occurred here?
Should there be a return here after the error toast is shown?
Is this callback even hit in the context of this PR? If not, can we remove it from this PR and add it to the PR that it's used for the first time? Thanks!
use this.size()
Returning 0 or 1 is not exactly a good way to estimate the progress of the algorithm. Can you come up with a better way?
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
check for not null
Add check that non-null
This constructor can just invoke this(new JdbcTemplate(dataSource), lookupStrategy)
please move the isEmpty methods to the scimSchema
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
is it not empty if for example type is an valid empty string?
I know it's a legacy, but I'd like to kill that kind of unnecessary methods, like we started to do last year setUpBindings, setUpToolbar, setUpDetails
Extract this into a method, given that it's called twice
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
Use org.apache.commons.collections.CollectionUtils.isEmpty(Collection) - it also returns true for nulls
I think this already appeared before - maybe move the trenary if logic inside coco.getCommandEntity(guid) ?
if the taskListInDB is empty, no need to go down
Use server from server_context.xml
this is confusing, it is called router but actually it is routerUrl.
0 and 100
Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
Note: There are *two* updateDatabase() methods (with different params) in this class, and it seems you only removed the synchronized from one of them. Is that on purpose?
You can use getDbFacadeMockInstance() instead of mocking it yourself
Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in ClusterManagerCallback.
Slight preference for the lambda variable to be rcc for ReadCountCollection.
use MoreCollectors to get an immutable collection?
Is this case possible? bootArgs not empty and oldMacSequence or newMacSequence empty If so, would not it be better to return at line 2131 the variable bootArgs?
This method can give an incorrect result if the last buffer is moved from the inner queue (which is then empty) to the output buffer (which was previously empty) in between those two calls.
final?
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Why not just CCorePlugin.getOptions()? It returns a HashMap<String, String>.
remove sink semantic option.
Include message saying what was wrong if check fails? e.g. including the original ref argument passed in.
I think there is a static Method on the CompletableFuture class that does exactly that
Pattern.compile should be done only once.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Typically we use Map on the left hand side rather than HashMap
nit: line to long (break each parameter in it's own line)
we never use NULL, it is a bad practice in general.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
I think this stops admins from installing at for example /code/review/ on their server.
isAbsolute is determined by if it has a scheme or not correct? Maybe use this instead? import com.google.gwt.safehtml.shared.UriUtils; boolean isAbsolute = UriUtils.extractScheme(url) != null;
calling super not needed
No need for super()
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
return Collections.emptyList();
Actually do we need the return type to be Seq, than just a Map? It seems we do not need to rely on any keyset ordering at all in the remaining handling logic.
I know you were doing automated stuff and this is part 1 of 6, but we could inline function here.
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
Did you use our code formatter? <LINK_0>
I'd probably move these under the block scope of the jsonNode != null check.
Wrong method name in the error message.
nit: getAdmin method -> getAdmin() method ?
ah, I forgot that the primary key components are part of system.schema_columnfamilies, not columns, so that wasn't a problem.
I believe the expectation is that listeners will be configured before the job starts. That is, the resultsSoFar would almost always be zero. If so, it wouldn't be beneficial to check against the maximum in this method. Also, fluent method should never return null because chained calls such as withBatchSize() in this example .onUrisReady(...) .withBatchSize(...) would be guaranteed to produce a null pointer exception.
if deviceStatusListeners was a Set, you wouldn't need to check this here (see above)
what happens when multiple servers starting...is it guaranteed these are not going to overlap ?
I would prefer not to use null ... just a empty set and then assert that its not null
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
Why public and not protected?
checkNotNull(value, "value")
No need for a checknontnull, the superclass does that for you.
Same here, but check the max cook time instead.
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Maybe we can just return this since we are not doing anything else in the if statement anymore.
Style inconsistency: space after if
Style inconsistency: space after if
I generally don't have an issue wit bitshifts when they are actually useful but here it only obfuscates the code for people who don't know much about them
nitpick : final Throwable t
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
Might be good to create a custom subclass of RuntimeException for use here, especially as it would allow for the code that catches the exception to handle it differently from other RTExceptions.
I would recommend an else if here to avoid comparing against a string unnecessarily.
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
this is not ok to schedule tasks using only delay from received header: - we should validate if value is within reasonable boundries (0, maxMessageBackoff) - we should discard message if retry-after is after message TTL to respect TTL policy
Nit: the else is redundant since the if block above returns unconditionally
Nit: parenthesis are not needed for lambda parameter The method is long, so name the parameter table
It could be nice to ensure only one delegate has it...  delegates.stream() .map(delegate -> delegate.getSystemTable(session, tableName)) .filter(Optional::isPresent) .map(Optional::get) .collect(toOptional())  ?
The log should rather say "Destroyed all file based persistence context" instead of "Destroying..." as the logging happens after deletion was done.
I'd use a algorithmMap.containsKey(alg); instead.
:question: do you need to do line 187 (final SolrClient c = client;)?
Just a suggestion: Objects#requireNonNull(Object, String)
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
lowercase for package names.
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
I know it's not part of this diff, but why isn't this function static?
It's not an issue but I think that it's better to put the both checks on a single line (if (!dir.exists() && !dir.mkdirs()))
no need to specify type on RHS
Local variable could be declared List instead of ArrayList. Is this worth caching?
Why is it a list of lists, not just a list?
nit, Collections.EMPTY_MAP?
Same question here: no start and end, means only one continuous, never ending pane?
nit: I saw this lambda been duplicated multiple times. It seems useful just define a inner function class and refer to the lambda?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
Why not making e part of an error logging: logger.error("MetricPusherCreator creation failed.", e) instead of printing the stacktrace out of the logging scope?
If the category filter doesn't implement ICategoryFilter you will get ClassCastException here. You should check it before casting.
I don't see where we handle HibernernateException.
please use curly braces even though this is a Oneliner
ditto. (see below)
Should we add an empty() check for ignore.value() as well, before doing this concatenation because if the user didn't specify any value for value(), then we will end up setting a description which looks like  : my regression which kind of looks odd. So I think we should add an empty check for value before we decide to use it to set descriptions.
You don't have to check it twice since isAnnotationPresent ensures that the annotation is present.
Not needed.
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
not consistent with equals, also the use of ID should be avoided
Do you want to hash allowedOrigins.hashCode or just allowedOrigin? The latter is more consistent.
replace with return this == other;
This isn't a valid implementation of equals. You can have non-equal things have the same hash via a hash collision.
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
Why is this needed?
Please group mr, ms, and mrs together
Why does the newline have three backslashes in front of it, but the other control characters only two?
Should be ObjectId, as the mapping cannot be mutable.
nit, Collections.EMPTY_MAP?
Why is it a list of lists, not just a list?
I'd split the map() here into two separate phases. First mapping the Entry to an Integer, then sorting the Stream<Integer> and only then mapping the years to IdNamePairs, e.g.  .stream() .filter(e -> e.getValue() > 1) .map(e -> e.getKey()) .sorted() .map(year -> new IdNamePair(String.valueOf(year), null)) .collect(Collectors.toList())
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
This has to be cleaned up.
There must be a more succinct way of doing this using streams.
Don't we have to say that this is uniqueId JDBC?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
super.init() method never throw an exception.
remaining time only makes sense if the state is down. In the up case downUntil could be in the past and this could print a negative, misleading value.
Shouldn't we return immediately to save some unnecessary cycles? Or at least break out of the for loop.
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
there was a NOT ('!') before the check.. i think still relevant, no?
you can use return failCanDoAction
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
It's a good update
debug/trace/remove?
I would say that we don't need to have one more method here, we probably can just move  ArchetypeOutput archetypeOutput = DtoFactory.newDto(ArchetypeOutput.class); archetypeOutput.setOutput(event.getOutput()); archetypeOutput.setState(event.getState()); endpointIds.forEach(it -> transmitter.newRequest() .endpointId(it) .methodName(MAVEN_ARCHETYPE_CHANEL_OUTPUT) .paramsAsDto(archetypeOutput) .sendAndSkipResult());  here or did I miss the reason that stands by this decision?
Add the info log back after this line?
Unnecessary.
Let's put a meaningful message on our exception. Something like "Exception thrown while trying to find unmap method on MappedByteBuffer, this method must exist on your VM in order for this to work."
@Override
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
This should be imported.
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
i think it's slightly better to add one more argument in AzkabanFlow constructor called type, and let builder handle the default parameter passing.
this and m_ is redundant
This probably needs to be .asEagerSingleton() as otherwise it may be pruned (nobody will depend on it, it's a leaf)
This binding is redundant if the AutoscaleParserModule already adds it. Remove it from here?
Hm, we could do the same thing as suggested in UserPortal's SystemModule.java for consistency.
Not needed?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
To remove?
Please use LOGGER.debug because this error is kind of expected.
Hm, you got java doc on the next method, but not here?
Instead of writing this to a log file (or perhaps, in addition to writing it to a log file), it would be good to make an error message pop up. Most users don't look at the log file, and will not know that something went wrong.
Please keep this.cell near the related fields (previousFamily & cell count) below
done for patch3.
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
I believe Role.SERVICEUSER would allow any service user to call this. Regarding rest of our API, you should check for FACILITYADMIN role and you should filter resulting list of facilities to return only those, where user is facility manager. Or to be more correct you should check, if user has READ right on attribute he search by on that facility. If not, do not return the facility.
Missing policy name.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
no need to specify type on RHS
null? why not just a () -> {} ?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
nit: Please include e
can you pull this from a static string?
check if getters1 is null and remove firstTimeStream
you import ByteBuffer, no need to use the full package path
Take note for an other CL, I think this test should be move up if CTF accept writing a 0-bits struct (or int). I know, it's stupid. Keep it as a separate commit.
do we care to check the length to be positive here?
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
Send this exception to the log.
Please include a translation text here indicating that attribute value cannot be null.
A question: Omitting the map.isEmpty() check is intended? Overrided default method does the check but here only a null check is done.
Please no, let's not have compactedChain being null legal. What is it buying us exactly?
So we can't know it's really an alias until it's wired , or runing, or ?
Seems like this configuration is being created and not used. Does this test pass?
getAppDataSummary can be removed here as its contents are included in getAppData (same for device metadata)
@isDeleted is somehow a "strange" constant; please keep all constants in an constant file
having these getters here means they would be included as json fields. Since they are easily calculated, and not used anywhere else in the code maybe exclude these? (think two extra fields x 3000+ requests all in one json blob)
you shouldn't need to cast to double here
do we want to have actual percents? not rates as everything else is in Picard?
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
Hmm, why did we do this? I thought we'd have a try/catch block.
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Please format here. And maybe use method reference to simplify: indexToChunkIds.values().stream().map(Pair::getFirst).collect(Collectors.toList())
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Collections#unmodifiableList could be better there.
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Can we define credDir as public static final String CRED_DIR so that it can be reused in tearDown and testResolveAlias? Thanks!
why sync?
Do we think that overByAmount will actually be a useful/actionable piece of information for users? As opposed to just saying it's too big to upload without specifying by how much?
Absolute or just path?
inline message
Replace all 0f with 0 please.
(int) -> toIntExact (from Math)
nit: should be && rather than &?
shut down one word; i.e. shutdown
why "+ CpuFlagsManagerHandler.class.getSimpleName() "? if you do leave it..space is missing between "dictionaries" and it.
I think if serviceMatcher == null we need to preserve existing behavior and do the refresh? Maybe still log the warning. What do you think?
braces style and this expression may be improved:  if (!config.isHigherFitnessValueFitter()) orderDirection = "asc";
Use TreeMap to keep the order.
what is this supposed to do ? Is it supposed to provide a list of just the highest checkpoint ?
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Why use only w2? Why the right shift? Likely it doesn't really matter.
bad hashcode.
Use Guava hashCode function
Maybe this should use makeUnknown instead of getUnknown. I think the difference is that makeUnknown will create a new one, and the new one will have its own insert date and user. I think getUnknown will cause all placeholders to have the same insert date and user.
Maybe some not-null check should be added here.
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
We don't need that here, null is OK if pretty name was not specified.
Is this correct then?
Is the default value "./" already unneeded for new specification? I think this logic should be simple.  return _workDir; // null allowed
You can use StringUtils from the commons.lang3?
StringUtils.isEmptry(XXX) if possible
In alignment with valueOf, perhaps name this valueOfType or fromType?
failCanDoAction?
The isDiscardable method can be simplified to this:  java private boolean isDiscardable() { return !PostUtils.isPublishable(mPost) && isNewPost(); }
you replace this code with return validate(getStorageDomainValidator().isDomainExistAndActive()).
static import
Unchecked.consumer(plugin::customizeJdbi).accept(this); is the right mantra :)
I don't know if there is a good way to merge plugins with the same prefix:artifactId but different names, but why did you choose to use new name instead of the original one?
The parameter needs to be 1 since the backup model node is one level below the cache
Couldn't you just to do: setXyz(0)? Like many other config classes? Also if you just want to initialize the value to 0, wouldn't you simply default the field value to 0 instead?
The optical microscope will have at least one inventory slot (for the item to be examined), possible two (second one for a light filter or some sort of attachment). For now just change this to 1.
'+' ? use && or ||
I don't think this needs to be public.
Any reason this can't always be used?
We don't know for sure that there is such a field in that specific event. Should use ITmfLostEvent.getNbLostEvents().
and doing the instanceof check here instead (trace instanceof TmfExperiment)?
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
I'd use getPathAsString instead of getName to provide unambiguous info.
Can we please make this less than 80 characters wide?
Does HQL have an "EXISTS"? If so, using EXISTS rather than IN may produce a faster query, and you will not need the DISTINCT fi.ingestion.
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
For a list the labelData is null
instead of e -> e there is a Functions.identity()
nit: you can merge both lines above as checkNotNull will return the given argument
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
not public
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
Lol! You're going to remove that, right :)
Rename error
nit: No need to print out organizationDiscoveryIntervalMillis.
Static import SECONDS. I usually set the initial delay to the same value for services like this.
Are we sure we want to thread interrupt if a FederationAdminException is thrown?
why is this public?
Please delete the right project.
what is the testcase trying to do or what verifications are expected
mResponses.size() > 0 ?
Shouldn't this be <= 0? The decrementBombs doesn't have a 0 check.
why not cursor > 0 ?
log exception
You don't block here until the server finishes by calling server.join() ? <LINK_0> BTW: nice work Cedric, you have made the code of Kasper a lot cleaner & well tested, I am impressed :)
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
No need for this.
Simpler as ImmutableMap.<String,String>of().
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
wrong error text
Does this need to be a left join or would JOIN FETCH be sufficient? I don't think there would be an entry in this table if the association wasn't there.
"FROM" - we should make sure we are consistent when capitalizing HQL keyword.
why delegating
why delegating
as is in 718
I would delegate to the new method directly
I wonder if the more elegant Objects.requireNonNull(delegate) will also do the trick
No need to change this; just an FYI. We put in quite a few of these early in AS7 days, but they can be just an assert delegate != null; If this is null it's a programming error, not a mistake in user input.
Local variable could be declared List instead of ArrayList. Is this worth caching?
Use Collections.singletonList() instead?
Arrays.stream(stripes).map(stripe -> stripe.substring(stripe.indexOf(":") + 1)).mapToInt(Integer::parseInt).collector(Collectors::toList());
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
why is this public?
Style-nit: No reason to add final.
nit, Collections.EMPTY_MAP?
Generics on the right side are redundant since Java7
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
In my personal experience, I've found that it's idiomatic to write this sort of code as either: java // Imperative option Map<String, Object> map = new HashMap<>(); for (int i = 0; i < accessor.size(); i++) { map.put(Integer.toString(i), accessor.get(i)); } return map;  or: java // More functional option return IntStream.range(0, accessor.size()) .collect( toMap( i -> Integer.toString(i), i -> accessor.get(i)));  But as I'm unclear on what the JUnit 5 team think of creating maps the way you've already done it, I'd wait for feedback before changing anything. :)
Will this be safe if currentMilestoneIndex is empty? Maybe cover it with a test as well.
Good! Let's switch the conditions, too: Option.when(i >= 0 && i < length(), ...). Then we omit the length() call if i < 0.
could we log this exception? also should providing invalid config prevent the app from starting rather than defaulting? e.g. setting it to 100) instead of 1000 and having it default to 20 could cause nasty problems?
This should be Status.NOT_FOUND.
->RuntimeIOException
See ByteByReference.java
See ByteByReference.java
See DoubleByReference
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
I think this should be > 0 since a value list item of 1=One does not work.
Is this still needed after removing the download stuff?
@RobberPhex If you make the input a Collection, then you can take a Set as input. You should also consider using a List internally instead of an array. It might make the above simpler.
Cache primaryKeyColumns.size() into a local variable
bulk get ftw
i think we had talked about swapping the order of these so we can short-circuit?
Are we sure a null never reaches this point?
Should add the new rule to the config file? (Parse could put directly to ruleConfigs in that case,)
#close() could probably be called instead of this if statement
This shouldn't be needed as StatementClient.close() should be idempotent
Use a compareAndSet here. Do we need synchronization on the flush method at all?
add: import org.ovirt.engine.core.common.utils.Pair;
We already declare diskValidator in line 115
please replace tab with spaces
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
Is this access modification potentially problematic at all? Could other things just start randomly removing screens, by chance or on purpose, or is it badly needed for something?
Shouldn't the FBOs be disposed here as well, when they are created here?
Given the plugin is called service-user, you might be OK just calling the screen create. Then the URL is "/#/x/service-user/create".
Can check isBlank()
log and throw anti patttern
log tenantDomain and idp name if possible
nit: Root groups cannot be fetched from the database
The logic using succinctNanos is easier to read.
Put these three blocks into a helper maybe.
Why not return getAnnotation(annotationType) != null?
I do like this shortcut
My guess would be to keep the previous behaviour, but allow users to set a different UnresolvedRoutingKeyPolicy, Reason behind that is to not introduce unexpected behaviour for users which will move up a version.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Nitpick: "filename:" and "type:" rather than "filename" and "type"
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
simplify this
This line should be: if (platformName != null && !library.getPlatformName().equals(platformName**.getKey()**)) return false;
This line may get logged a lot of times in a production system when s3 select is enabled, no? (when I trace it, it gets called from HiveSplitManager.getSplits()).
This shouldn't declare throws Exception.
Should be removed if empty
remove empty line
style: unnecessary blank line
Why "Whatever" here, is this a left over, or final?
threadCount <= 0?
fail should also not be required anymore.
Maybe IOException since it's supported here?
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
I am not following here - why do we want this in sync block?
You can now use [RegistryHelper](<LINK_0> here
Use Structure.getField(StructField) here instead of f.field.get(this); it does the appropriate exception handling already.
os.write(command.getBytes()); ?
CHANGE it to TypeConstants.JAVA_LANG_RECORD
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
It could return 0, but should be 1 at least... no ?
Could you use roundedDpToPx instead of casting to an int?
Should do the division prior to casting to an int.
@dmzaytsev let's inline this
Simpler as ImmutableMap.<String,String>of().
For code clarity we can move this end date to in setup, as its common in all test cases.
Why to call finish?
Hey @oguzkocer, these Account settings update calls feel strange be initiated here. I think the helper methods here in ActivityLauncher.java should only launch the activities without too much business logic. May I suggest moving the update calls either closer to the caller or in the Activities themselves? Cheers!
ParkingPositionLayer - delete
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I still don't see why we need the 'if..else' here? both cases are the same
I think C* 4.0 will be the first version without thrift. It will still be present in 3.10, but not in trunk.
Shouldnt this be <= ? Is it possible you haven't pulled latest changes? I think this was changed to < 2_12_0 but <= 2_11_0 would be equivalent (and maintain the appropriate value of MAXIMUM_SUPPORTED_VERSION)
We can't filter by closing time?
Also for the next few methods, just return (List<CourseStudent>) q.execute(...); directly.
could be static
Should we include organization here too?
I think this is probably the last item. Add organization to all the relevant log statements.
Should we just add the entire organization to the debug statement?
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
When the view is closed you need to stop the build thread
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
Simple for-each?
Note that all references to CoreRegistry.get(class) need to be replaced with either @In annotations (best idea) or context.get(class) codes (find-and-replace). You'll probably need an @In annotation to pull in a context.
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
If we're moving this logic from the DAO to HibernateAccount, we should also move the tests from the DAO to HibernateAccount. Similarly for getSharingScope() and getNotifyByEmail().
Can the connection or the context be null at this point?
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
Since there are two places using "tree-item", consider replacing it by a constant just like you did on the other classes.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
why not with stream API? will be cleaner
Is setting null here OK?
can replace sync by false
not necessary, a boolean is false by default.
Why is it a list of lists, not just a list?
Is this really needed? What can you do with this that you cannot do with get(int id) ? If your answer is: "Well you can iterate on them, dingus!", then I'll say you should return an Iterable here instead, and not expose the underlying data structure (this will allow you to change the underlying implementation to TreeMap etc. without breaking this API).
Collections.addAll(this.features, features) can be used instead of for loop
Should we even both installing features in different subsystems if this is true? It might be better to just install all features in the root subsystem instead.
Should we throw a MojoExecutionException here instead of just logging it? If something went wrong when installing features then we can't expect dev mode to continue working properly.
Line seems to be having more than 120 characters.
Why are we throwing generic exceptions? Please only add the relevant exceptions, that will be thrown
Will this always be this value?
This is only used with the ComputeService implementation. Please remove it.
Shouldn't this come from the builder?
This binding is redundant if the AutoscaleParserModule already adds it. Remove it from here?
Does this now call stop asynchronously, rather than previously doing a blocking call? Should we do a .getUnchecked() as well? Or return the task?
Capitalize Thrift (or remove the word)
"Exception raised by remote Thrift server: " + e.getMessage() would be more concise?
Table per namespace, interesting.
this is confusing, it is called router but actually it is routerUrl.
I think this broke the sonar build: <LINK_0> If this source change was intended, can you take a look at the Jekins configuration?
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
Please keep this.cell near the related fields (previousFamily & cell count) below
done for patch3.
';' (character; single quotes; otherwise you'll need a NON-NLS again.
Why is it a list of lists, not just a list?
invokeAll on an empty list returns null. So you may want to handle that
The implementation of getMeasurements() makes sure the list is only exposed as unmodifiable list. The code invoking the constructor can still have a modifiable reference to the measurements. Creating a new list containing the measurement values provided would prevent this.
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
lists shouldn't be copied, best copy them; java this.targetContent = new ArrayList<>(targetContent);  as if anyone still holds access to the parameter list, it can modify it
?????
LoggerUtils.logErrorWithStackTrace(LOG, e.getMessage(), e) ?
this ought to call verifyNoAsyncErrors(defaultTimeoutMillis())
this is already called in BasePageObject so you don't have to call it
there is no need to execute initElements method, when you're extending BasePageObject
you can remove this
It could use StringBuilder instead.
reference would be concatenated w/o a separator. Is this intended?
Use StringBuilder instead. Also, you can use ToStringHelper in guava.
Please use else if. However, I am wondering if the result is always false when o is an instance of DenseMatrix. I've tested this in scala console with a DenseMatrix and a CSCMatrix both of which have the same elements. Can you check this?
Help me understand the change below more. The one on the left seems simple.
could be simplified as return (o instanceof LFUEvictionPolicyComparator);
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
I think you should be able to pass config in directly
extract getVmDao to getter
can you please add a helper method for performing it? this code is repeating itself in all of this patch edited classes.
you erased a lot of logic, can you please explain why ? secondly, IIRC getParameters().getRunAsStateless() is Boolean and we had a bug in the REST it's null, please check for null
not need for 'this'
Why? Just case tempObj
I would suggest naming this variable as 'serversArr' instead of 'temp'
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
could read the method from the response, eliminating the need to call withRequestMethod method
Please keep this.cell near the related fields (previousFamily & cell count) below
done for patch3.
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
There's no concatDeep, I guess..? ;-)
Do we need the ...Function suffix in the method name?
Why empty? It supports ALL streams!
Duplicate in throws clause - [fixed in master](<LINK_0>
I see, that's the reason why getBuildContext() is in the AbstractDockerMojo. However, I'm not sure if we would better move checkImageWithAutoPull() out of the BuildService. Doesn't sound very "build-y" and there is probably a better place for it, so that the StartMojo and the BuildMojo could both use it ?
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
This is not really a deprecation, right? We're changing the behavior (ignoring the setting and advising them to use the requires-reply). I think I'm ok with that, but maybe we should log a WARN and refer them to the migration guide???
Shouldn't we rather throw UnsupportedOperationException() in this case? Or rather create interface without the support and extend it with interface with these methods?
Should this be in the errors.properties file?
final?
Let's take this time to also fix the validation logic: recommendedLength should always be more than 0, because recommendedLength = 0 doesn't make sense.
If .close() returns silently on repeated operations, we can drop this check. Otherwise, I would argue moving the debug statement to within this block so we don't output a message when we're actually going to no-op.
Is this important? Should we throw instead? Or just make this a debug message if it's not important? (same for seek)
String.valueOf
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
nit, Collections.EMPTY_MAP?
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
we shouldn't need the ?test param any more
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
can we make this one configurable?
whitespace, but prefer if you don't change existing code style
strictly speaking, this is not always ONE_TO_ONE e.g. what happens if my format string is "just-a-fixed-string" ?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
I meant this constructor should be private. You made constructor of LdapObjectDefinition private. Actually both should be.
Avoid the intermediate variable and directly assign selfID.
We don't need this, the ConfigSaved would handle this already.
I disagree that this is the right place for it, it's hiding this logic in an unrelated place, I think this call needs to be done explicitly where the remove is called (as is the case for statistics)
Remove this
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
final
You get it right. Per code conventions, I like to see brackets around if and else clauses.
Collections.unmodifableList()?
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
Should there be a second catch for ClassCastException? is art checked somewhere to verify that it is always a teamWorkFlowArtifact?
Can't we use Collections.emptyList() just asking, do not knwo if can cause troubles as return no-modifiable list.
break out if you find the user?
this code doesn't seem very safe. If the call to db fails, the class construction might fail, and then it's hard to troubleshoot it, no proper logging, etc. Isn't it better to first get the domain from db, and if it returned OK, pass it to constructor?
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
s/B/b/
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
please don't put any synchronous call in asynchronous method.
it is a weird pattern on how do we handle callback and completablefuture: we are using context object for passing completable future. isn't it clear just pass a completable future or having a completable future inside the SyncReadCallback? when the callback is triggered, the completable future is set. the transformation from Enumeration to Iterable can be done within SyncReadCallback, without attach a new apply function. also, counter should be renamed to ctx at least. the name were left before introducing CompletableFuture.
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
This must be implemented.
Use Collections.singletonList() instead
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
Should be final.
I think Math or mojangs MathHelper might have utils for log2
Inline this
Why not  java logging.setLevel(loggerName, Level.valueOf(newLevel.toUpperCase(Locale.US)));
Better to add checkNotNull for the arguments.
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
We have a removeConfiguration so let's not allow null value here?
can be simplified with return value!=null? value : defaultValue?
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
Please keep the getter and setter closer.
is this class going to be created by the user?
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
Please call here just the other constructor:  this(name, new ResourceLoader(), clazz, language);  No need to duplicated the code here.
just return "" instead of new String()
while you're at it, you can remove the thises.
Should these have some kind of validation, e.g., non-negative, from less than to?
Doesn't look like conditions are same.
how about  java return method.isTestMethod() || method.getTestMethod().isAfterClassConfiguration();
If we change the accessibility of the method we need to reset it after invokation. For this reason I would remove this line 409 here and instead change the invokation logic at line 405. It has to look something like this: java AccessController.doPrivileged((PrivilegedAction)() -> { boolean wasAccessible = initMethod.isAccessible(); try { return initMethod.invoke(viewModel); } catch (InvocationTargetException | IllegalAccessException e) { throw ... } finally { initMethod.setAccessible(wasAccessible); } });  For Fields we have convinient helper methods for this usecase in ReflectionUtils. For our usecase the method public static <T> T accessField(final Field field, final Callable<T> callable, String errorMessage) at line 109 in ReflectionUtils would be suitable. However, at the moment this method is targeted only for Fields and not for Methods. But actually we could change the Type of the first parameter to java.lang.reflect.AccessibleObject which includes both Field and Method and has everything we need. I don't know if you are familiar with the reflection API and are able to do this refactoring? If not, no problem, then I would take over this task.
please extract key as constant
Can you add @NonNull @CheckResult @WorkerThread to these two methods as well?
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
that class would be better with a builder, though I wouldn't ask changing it now
These look wrong - the end times are being set precisely - so shouldn't the updated value be 1500000?
No need for second level of brackets.
Have this just return an Iterator<String> because a List is a bit too specific and forces extra memory to be used even if not required.
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
Should close kill the memspace? What if someone want to reopen the key?
Assert.areNull
Maybe we can call this markAllUploadingMediaAsFailed() like the EditorFragment so it's clear this has to do with media?
Again, why nullToEmpty?
Have you checked if this line is really necessary? The superclass already calls setVmMapper. I suppose it's required to make this subclass use the overridden defaultVmMapper.
I removed this change ... Use should not place any files in repo, we can come back to this if become very annoying.
When pressing the remove button, the directory is not removed. In my case it was the last directory.
".DS_Store" what is this file?
having these getters here means they would be included as json fields. Since they are easily calculated, and not used anywhere else in the code maybe exclude these? (think two extra fields x 3000+ requests all in one json blob)
you shouldn't need to cast to double here
Mistyped config path, should be Properties.Fire.BlueFire.RangeFactor
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
similarly
Have you considered skipping the line above by having something like Queue<ControllerAction> result = new ArrayDeque(queuedActions);
instead of addAll(), you could just return the free vars from the definition. Same in VarDeclaration
Actually the name of the definition is not bound in the body --- at the level of the Core IL, recursive calls must be of the form "this.mymethod(...)" not just "mymethod(...)" [there is a sugar that makes this work at the source level but it goes away in translation to the core]
the methodName is not a free variable--it is conceptually more like a field
single quote '/' and remove //$NON-NLS-1$
doc is missing
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
In alignment with valueOf, perhaps name this valueOfType or fromType?
We might need is[Type] methods for each avro type. What do you think about it?
How about "Type is not supported"?
Move the strings into constants.
We can strip this down quite a bit to just java this.eventReceivers.forEach(EventReceiver::close);
Looks like a bad merge here? I think you accidentally removed this code when merging with master
this.lockVerbs (like below)
I think the SystemReader should server this cache instance. With two static instances, there is a brief interval in which this cache instance will be the old one while the SystemReader instance will already be the new one. Might be simpler if the two methods getSystemConfig() and getUserConfig() were on SystemReader, without this separate class.
Why wrap OSUtils.isHuaweiDeviceType(); when we can just use it directly?
"You do not have any tapes"
Use a null guard here instead
taoe should be tape
same thing, while you are cleaning, other thread could store other key.
Doesn't look like clean API. What's the use case of this?
No, this isn't good. With this way we lose all the customization provided via the common shared config for EvaluationContext. I'm that won't hurt to evaluate just to Object and check it to the supported String and BasicQuery types. And of course convert String appropriately. That's how we will still pursue the backward compatibility and flexibility. Thank you for the update any way! Will take a look tomorrow closely. Right, that looks pretty much possible to backport the feature to 4.3.x
I suggest encoding the above 4 assertions in a single call: assertEquals(ImmutableMap.of("1", "hazelcast", "2", "phonehome"), map);. In general it is a good practice to check the expected output in one assertion, instead of checking its pieces separately. Also, in these assertEquals() calls the expected and the actual values are mixed up. First should come the expected, then second the actual. Of course it works this way too, but if the assertion fails, then the output becomes confusing if the expected and actual are swapped, so it is useful to always put them in the correct order.
consider using Collections.singletonList().
return Collections.singletonMap( "serbian_stemmer", SerbianStemmerTokenFilterFactory::new );
This case should no longer occur, right? In that case I think it should be removed.
Can we use return new CallNotPermittedException(message, writableStackTraceEnabled); instead?
We tried to avoid creating too many Instant classes to measure timings in order to reduce GC pressure.
You must cancel request on both 2 senders because, for the same registration you could have pending request in queuemode and not queuemode (as binding mode can change) (I agree this Far-fetched but I see no problem to just call cancelPendingRequests on both sender)
Okay this is better where it can self-heal and reconnect. Fix checkstyle issue however!
This should be synchronized
Missing types
Missing types
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
does this have to be a list or can it be an iterable?
parseFields should return values instead of keys.
Argument should only contain _incomingTimeColumn?
as is in 718
It's all histograms from now on, and IMO the per-site statistics should be in core, not extended-statistics (for sync backups too).
Possible NPE here in case of default constructor. Let's mark the 'log' field as 'final' and initialize it in default constructor.
SecurityException?
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
Nit: Can we just return a TimeRangeFilter here (which is null) when missing instead of always having to do .orElse(null).
log()
you can add log() method here for easier debugging
add PageObjectLogging log method
IMO we should still throw an Exception here after logging the error - failing the deployment seems OK to me, as long as the user can find out _why_ the failure occurred. (If these values aren't specified, **the function itself won't work.**)
Maybe missing something between name and the errorMessage, such as space or some separator
Whether the argument is a string or not, it should be convertable to JSON - why not just always run it through the JSON parser?
Use getSimpleName instead?
Do we want the toString()= in here ?
It is better to add timestamp, date, decimal too.
Better to return "";.
@dalifreire is this enough? What e.g about class name?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Will you expose this in JDBC too? ( <LINK_0> )
Add checks for the warnings properties: checkWarning(...) Then we are sure, that the regexp works correctly.
no need to specify type on RHS
the whole goal of new values API was to remove casts as much as possible from all the equality methods, this change does not follow that paradigm (this place and all other updated equals methods) is there is any way we can avoid that?
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
other != null is redundant with other instanceof Module, which already returns false when other is null.
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
add this selector to UI mapping at the beginning
Not sure is worth doing this change.
Please remove an excessive space character.
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
"not" function is already available in StandardFunctionResolution. But I don't mind having it here given it's a test.
We could make this as static method.
Your find by ID method should be doing the same logic. SERVICE_SHORTNAME is the old way of registering a transformer and SERVICE_ID is the new way. You should be able to remove the find by filter after doing this.
WithTasksContext
would be nice for the 4 to be a constant for readability
StringBuilder is better here, it avoids synchronizations that you don't need in a local variable like this one.
This should be doable with Allele::basesMatch without converting the allele and the transition base to Strings.
can these parameters be grouped into smaller and more meaningful objects?
As far as I understand, message should be the contrary: "A boundary event must have no conditional transitions". no?
You could instead annotate a method with @ExceptionHandler(NotFoundException.class) and @ResponseStatus(HttpStatus.NOT_FOUND) to return the error page, and then throw a NotFoundException to trigger it, which would result in the proper HTTP status too. This method could go in a separate class annotated with @ControllerAdvice to apply to all controllers, though you'll want to exclude the REST controllers
Out of curiosity, why is the return type of this setter not void?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
if credentials is null should not execute mocked push
Dianne will tell you to remove this. This is logspam.
Remove .toString()
are you sure we need to use OSString ?
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
any particular reason why this method doesn't require an IJavaProject ?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
I would use log.infoFormat since it is the standard way. Also, I think logging this at info level is too verbose, this sounds more like a debug to me (and if someone wants to monitor this query specifically he can lower it's log level)
just use getDiskDao(), getVmDao(), etc.
same here, make a query after check
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
Don't need this keyword here - the rest of this code only uses this when necessary.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
bad hashcode.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
This should probably check for > maxInt and throw in that case. Unlikely with an index file... but you never know...
Are we disallowing zoom controls for a reason? I'm noticing a lot of these calls being made. We should probably standardize on a common function that will set all the settings for maps. Or do we have a common mode of operation?
If we are throwing runtime exception anyway when map is null isn't it better to just let it throw NullPointerException?
If we are throwing runtime exception anyway when map is null isn't it better to just let it throw NullPointerException?
**USB**
**USB**
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
We could omit the second Integer.
Does it need to be package private? Can't we make it just private?
toList() should return only JSON object. I understand that getObject(i) can return CBL Array() or CBL Dictionary() ?
I don't see where we handle HibernernateException.
Wondering if we shouldn't fire event in the way we do in CanvasLayoutUtils.fireElementSelectedEvent
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
For each?
All of this can be replaced with an ExecutorService
For loop?
finalize?
nit, Collections.EMPTY_MAP?
Rename to getSortedPermittedLabels()
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
The try-catch block is redundant here, since the appropriate exceptions are caught and logged in the startDicomOrderFiller method
1. Change Exception to exact exception you get 2. throw the exception after log or don't catch it here
Add PageLogging
The "{" should be have a space before
you can add log() method here for easier debugging
@dalifreire join this with the previous line
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
This could be set in the constructor instead of checking this on every request.
Windup/Discover/Java ?
To always be safe please use context.getApplicationContext()
No need to override the data type system here.
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
should this count be parameterized?
Remove throws Exception
Something per-method needs to assign null to lifeCycleManager.
is this tear down necessary? the next setup overwrites anyway, doesn't it?
E.g. here we could compare this to Webrequest.REFERRER_UNKNOWN rather than hardcoding the string.
nit: Can be simplified to assertSame
assertThat(a.val()).isEqualTo("foo");
style nit: no braces around single line blocks
if we don't end up here we already know that the result must be -1 footers must be in the last paragraph hence we need to stop searching as soon as we find the first blank line
I think we should not trim here since this leads to strange effects when amending a commit message with indented Change-Id in the footer, e.g. test Change-ID: Ic4bfb17d790c1250b7bfc22589bfe473d1509151 in the staging view amending such a commit deletes the Change-Id which looks wrong
I think it would be suitable if some kind of padding is applied between messages, such as a newline
To keep same format, could we use Timber.e(message) ?
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
Magic number -> symbolic constant.
I think configurable makes sense
I don't think you need this check. Just return size * 1024 ?
please use curly braces even though this is a Oneliner
HibernateUtilFactory.getAsyncMsgsHibernateUtil() call twice and it impact performance since we look up the bean again applicationcontext. Recommend to assign variable if sonar doesn't mark violation.
The session can be removed between the two calls to sessionRef.get(). Session session = sessionRef != null ? sessionRef.get() : null; if(session == null)
replacing this with helper method would be great
OPTIONS could be more suitable here, since we don't want to transport the whole value
Is the contract that if the status DNE, then the children list DNE for that path? It is unclear what the relationship is between the 2 maps.
Messages._Warnings_Armcc_ParserName and so on...
If you remove the true, then the method isLineInteresting is **not** invoked anymore!
false is default
why gone?
this is identity projection, can you use something more complicated like a +1?
format this as:  a -> a .globalGrouping() ...
Given that this method is already dedicated to the audience claim, this change is redundant. Please rollback
null and empty API key should throw
Have we got room to always use 3dp
foreach
Which type would be assigned in this case?
line-break
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
This should actually return something, no? :)
this method deserves a description
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
can we stick to hamcrest please? Using hamcrest all the time results in consistent test failure reporting. Also, when there's a failure you get something more than just "wanted true, got false" -- it will report what the list actually contained and not just what was being looked for.  json assertThat(getEntries(is), hasItem("register.json"))
We can use the try-with-resources pattern here, which means we wouldn't need the stopContainer method (we use it for other tests). No big deal, though.
can we remove this method and simply have the poolsOfString.take() where this method is called?
We may want to use [BlockingQueue.drainTo](<LINK_0> in this call
I've seen other list models doing setWindow(null) as well. Not sure if we need to do it here too, though.
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
After refactoring ACTIVITIES. for(Page page : PAGES) { executePreformanceTest(page.action, page.title, page.displayName); }
why 4. make private static int
Don't we have to say that this is uniqueId JDBC?
Nit: could be called e1.
- log warning that option is not supported by SNMP
the put will remove the previous mapping
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
do we care to check the length to be positive here?
No need for the double (( and ))
We'll get NPE here if socket is null, right?
use constants for the path.
log exception
unneeded ;
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Why empty string and not null?
Is there any case when we don't have config?
Please shorten these two config keys.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Unrelated to this PR but does it make more sense to break or to throw?
Does this also log the information from the Exception?
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
likewise, this one can be static
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
Shouldn't it be [null, null]?
Minor, but looks like this was for debugging and should be removed.
You can just use sql(xxx).withConformance(SqlConformanceEnum.BIG_QUERY).ok()
VoltFile?
The cast is not needed
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
Why is it a list of lists, not just a list?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Seems like just sending an empty Map here would avoid all the null and isPresent checks later. Thoughts?
Not good to use Optional for collections, just return empty collection
It still needs some kind of fingerprint identifier in the message, e.g. just its ID/hash
Should this be in the try? For consistency, have the LOGGER messages in the same place for the start and stop functions.
redundant thisqualfier.
Using StringUtils here looks like overkill - since you're comparing to a constant, just use "TYPE".equals(fieldName)
... if you replace this with "TYPE".equals(fieldName) as discussed in <LINK_0>
it is not obvious. thx
this.url = checkNotNull(url, "url");
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
Stringbuffer would be more memory efficient. Since there is lots of URL construction it may be worth being efficient to avoid later garbage collections.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
We could stochastically test it.
*ws* is being removed automatically at the pre-destroy step. Instead, of that, we need to try removal of workspaces with name **MIN_WORKSPACE_NAME** and **MAX_WORKSPACE_NAME** which could probably remain after the test execution in case of failure.
This cannot be null. Guice won't allow the constructor to be called if the reCache arguement is null, as the argument is not marked with @Nullable. Or is this null because of unit tests? If that is the case I would prefer to define a mock cache in the unit test since at runtime we always have the cache.
why not use a constant for that?
wouldn't this fail if pattern was null?
replace with fType.add(DescriptorType.STRING); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
Add a FIXME somewhere, to make the consumers more generic so that it does not accept Object but some <?> so that we wouldn't need this cast here.
Shouldn't this method do something?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Even though it's java there is no reason for trailing spaces
return tid instanceof Number;?
This can be simplified to return localFilterInfo == null;
Shouldn't this close the iterator before returning the list?
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
This search returns also base itself, which can't be deleted. Either use different search() method with specified SearchScope or simply check returned Name on orignal dn param and skip it in the cycle below.
why was this call webResource.init deleted?
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
Use WebUtils instead of casting this yourself.
Which type would be assigned in this case?
finalize?
What do you think about Comparator.naturalOrder() instead of null ?
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
You can remove this code and replace it with org.eclim.util.IOUtils.copy(in, out).
IMHO we want to return the StringBuilder there... Odds are we will never use the raw string
If this constructor is to be called only by the builder, remove the public modifier
Any particular reason for the this. here? Just asking as it's use has been mixed but it seems the majority of cases don't included it.
should we have Objects.requireNonNull in these?
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
Ccan we default to a more modern version?
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
we could extract extra method for all of this.classes.addAll here instead of repeating this 4 times
not sure but iirc we use static import for generationSuffix in other classes
final
It would be easier to instantly see whats going on if there was a method deleteLayersForProvider() and removeProviderFromLayers() which would be called based on the boolean. After the conditional statements you could call deleteDataProvider() that would return the removed provider. Then you could write the response based on that in handleDelete.
Refactor getRoles() and getPermissionTypes() to return the array and construct the response object here since methods don't really need the root as param.
This file would read better if you have handleAction before getGroupJSON() since handleAction is the access point that uses getGroupJSON().
Remove wakeup flag from settings, added new state type wait, if parent is in wait state wake it up when child finishes
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
These local fields could be declared final. <layout,review
EINVAL is expected for FileDescriptor.out / FileDescriptor.in. This is only expected to work for descriptors to "regular" files, and won't work if in / out are pipes or sockets (which they are, in some configs. The man-page uses weasel words to say this "EINVAL... or an mmap(2)-like operation is not available for in_fd,".
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
Remove this now that it's on 1.4? suggestion }
You should be able to use the diamond operator here, i.e. new ArrayList<>()
IMHO it'll be cleaner to just add specs for Filter and Map operators instead of trying to make StreamOperatorSpec very general purpose. The overhead of the two extra classes is trivial and it helps readability.
Are these type annotations required?
Add the info log back after this line?
Is there any purpose to remove temporary workspaces on shutdown if you do it on boostrap? It looks like they should removed either on shutdown or on bootstrap.
Should probably log the exception itself here
Minor: use AssertJ org.assertj.core.util.List.list and static import for readability.
This last line is not necessary. Happens automatically at the end of the assertSoftly() call.
use standard assertions (no need of soft ones)
Use nullOrBlank() function or test for all - null, empty and space strings.
If this was at the PaymentOutcome level it would use  Set<ConstraintViolation<PaymentOutcome>> constraintViolations = validator.validate(telephonePaymentRequest);  and then it could be passesValidationForNullPaymentOutcome and the assertion would be  assertThat(constraintViolations.isEmpty(), is(true));  , but it's not so it should test what the actual constraint violation is (applies to all validation tests). For other validator tests - they're not at the deepest validator level (which in some cases seem either impossible or difficult to do), and there is no general test for CreateTelephonePaymentRequest, so checking for the actual not null violation should be a part of them.
following the change above, i'd expect this one to look as: assertTrue(validate.isEmpty())
I'm still scared something stupid not using result = ~~result in your hashCode implementations.. but if you're happy.. then.... you'll be the one scratching your head _if_ the JIRAs start rolling in about V&V going crazy after a while..
this can be all replaced with Objects.hashcode(mSourceFile, mBuildToolsRevision);
Could use Objects.hash()
This can be replaced with  java return newName.isEmpty();
"return DefaultSessionEditorPage.PAGE_ID.equals(pageId)"?
"return DebugPage.PAGE_ID.equals(pageId)" ?
BufferUtils.byteToInt?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
1) /s/executing/Executing 2) I think it will be better to add this log in the buildStoragePoolDomainsMap method so it can be also used for reconstruct and we can get more information about other storage domains statuses.
please format using the Eclipse Formatter (CTRL+SHFT+O)
If response contains result (which it should contain) then you are creating new HashMap instance for no reason. Wouldn't following code be better: Map<String, List<String>> namespacesMap = (Map<String, List<String>>) SSOOAuthServiceUtils.getAvailableNamespaces( getSessionDataContainer().getSsoAccessToken(getParameters().getSessionId())).get("result); if (namespacesMap != null) { namespacesMap = (Map<String, List<String>>) response.get("result"); for (List<String> entry : namespacesMap.values()) { Collections.sort(entry); } } else { namespaceMap = new HashMap<>(); } setReturnValue(namespacesMap); Also if namespaceMap is read only, then even better would be to use Collections.emptyMap();
Oh, right, that was me. Sorry!
nit: s/result/fileList/
In success response you return json, but when fail - trying to return plain-text. It is not an good idea
Why not check the total number of images returned? What's the benefit of this filtering?
Why do you need the filtering here?
The way I understand the RSPEC is that as long as there are more than 1 nav/aside tag, each one should have an aria label. The way it currently works, if there are several nav tags but only 1 without the label, it will not raise the issue
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Inline
I'm not sure what exactly append here :wink:, but it seems to me possible to generate the same synthetic name both if we call this function two times in the same millisecond. Why not use an increment based on Context like with closure and decorators synthetic names?
Why is this displayed to the user?
nit: typo UNKNOWN_VM_VENDOR ?
Should it be background?
I don't know if you'll take this as good or bad news, but there is no longer need for these uncertainty ranges -- every selection and window range times are now always exactly the expected nanosecond. The method validateRanges() could now take four longs as expected input. For example at line 479, old window was [30,70], we drag 30ns to the left, new window is [60,100].
With Pin&Clone, you can press 'Z' in a view that shows trace1 but the active trace is trace2. There should probably be a method in the interface, and let the view implement it.
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
Multiline for statement should be wrapped with braces.
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
Only this check might be enough?
Suppose makes sense to convert value to lower case before comparing.
=
It seems that we are missing the resolved name for the getter case. I was thinking that we would need similar property as for the field to store the resolved name or am I missing something?
I saw the property names would be converted to lower cases, that means e.g. controller.upload.onlineToOfflineTimeout will become controller.upload.onlinetoofflinetimeout. Is that intentional?
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "enforceNotNullNorEmpty" a "static" method. [![rule](<LINK_2>](<LINK_0>
Qualify with this. Same goes everywhere.
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
This seems unused.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
SearchFormsManageCommand.class
Should this be implemented?
If the BigDecimal multiplier values were static final class variables, you wouldn't have to "new" them with each conversion, which might be more efficient.
Same question about losing all precision here instead of during formatting %.1f
this should be ConfigException.BugOrBroken probably, though I think a lot of the library doesn't bother to check null
Why not extract assertThat... into separate methods: assertRoutingKeyResolver for example. If the requirement is not fulfilled, a message could be provided to be used for an AxonConfigurationException (I would argue that we could use the same message for both purposes: invoking the build method and validate method).
Extraction to a separate method.
getFormatFieldTypes
@cristianoperez thanks! it really sounds better as a default value. I'd only keep a fallback strategy for users that for some reason want a new session to be created. for example:  request.getSession(createNewSession()) //... protected boolean createNewSession(){ return false; }  what do you think?
computeIfAbsent?
We have a removeConfiguration so let's not allow null value here?
throws RestApiException not necessary.
neat
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
Please change to externalSearch =
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
remove
We can possibly collate this with the following if statement?
if that previews is showing cleaned-up code, why is this one still here?
Style-nit: Our toString style looks more like DiffEntry[ADD newName] DiffEntry[COPY oldName -> newName score] DiffEntry[DELETE oldName] etc... Please match it here. Of course this is a bit easier, you can do buf.append(type) to get the type part and not have to duplicate the name in both the case label and the string text.
I think I prefer spaces before "leap-day" and "year-day", but not too important. Wikipedia has all words capitalized (and no hyphen before "Day", either), so you may want to check some of the original references.
I think it's better to return an empty string here, to indicate, that the contact is unknown
To be more precise, shouldn't it be "atLeastOneIsQuantity"?
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
not so readable. looks like good candidates for parametrization
casting to Integer is redundant. IDE shows warning
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
In case self is a BufferedIterator should this return self instead of re-wrapping?
I think you want to call the new method which gives servers based on glusterPeerStatus
Better to log the host_name instead of vds_name
Since vdsList contains only UP servers, there is no need to check the status here.
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
Wouldn't this have to be the location of the left sibling of ctx.codeBlock?
The ctx variable is unused anymore.
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
I agree with your point. Good catch. I want Ravi to review as well.
if we already called clearAsyncTask(), wouldn't we want to remove it from the list regardless of vdsmTaskId?
grammar nit: 1, not one, and no :
Here you could use Guava's [checkArgument](<LINK_0>,%20java.lang.Object%29)
You can use checkArgument here, same as <LINK_0>
Just use something like ZoneId.of("+08:00")? convertToZoneId should be removed eventually.
Isn't this UnsupportedOperationException now?
could you make the same change for DecryptCallbackResultInfo that you made in GetBlobInfoOperation
shouldn't actual <--> expected be replaced here as well ?
args is not passed. You may want to change it to:  cmd.execute(new ArrayList<>(Arrays.asList(args)));
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
suggestion assertKeyPair(file, null);
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
Don't use the default charset. This is platform dependent and changes between different machines.
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
NIT: support**s**QuickRecursiveListing
Can we weaken the signature to throws Exception?
Maybe this will already be immutable. And a list.
if the copy is done at the constructor and the field is an immutable list, you can expose the list directly here.
you should do the ImmutableList.copyOf() at the constructor, and here just return the list directly. This will ensure that the constrcutor's caller cannot modify the list stored in this class.
setErrorMessage
I think that every database object should be checked.
I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty. And when you have that fixed, go ahead and merge at will. :smiley:
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
The builder has a method: <LINK_0> that will copy the whole contents of a multimap, you shouldn't have to manually perform the copy.
suggestion throw new UnsupportedOperationException("FileStoreAttributeViews aren't supported.");  Indicating currently isn't needed, let's be more blunt on the exception message.
These should all throw NotAvailableFromExchangeException
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
you should have here setSucceeded(true) IIRC.
Will need a @since tag.
No parameter in setter method?
Can we throw the explicit exception not generic?
Don't you need a super.setUp() call here?
I think it would be much better to pass Locale.US to the methods that require them instead of making it the global default. That way, other tests which expect a different default locale would be less likely to fail.
throws APIManagementException
Formatting issue
caching an Exception?
dare to extract a constant which increases visibility for this hard-coded value?
why is this public?
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
Right now, you are only setting the window to the screen's dimensions. This is not a "truly maximized" window. You may try setting maximized after setting the window's dimensions.
How do you control drawing the debug lines? It should be conditioned by a global variable that sets the editor in debug (pass as command line argument).
Not sure if this can happen, but perhaps you only want to load everything on the switch of the property to true.
Not necessary to call super(). There is an implicit call to super() with no arguments for all classes that have a parent
super() can be spared here.
Can we make the type of this field ProblemFactChange instead of Object?
why not have the formatting method in UserAgent?
This syntax seems way more clunky
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
Can we make this method final?
Do we need || configuration.hasErrors() ?
I assume the list is never null. right?
return onCancelled()?
This could just be a preconditions check in the constructor, and I would use a different error message that just tells the user that intervals and segmentIds cannot both be set. The current error message I don't think is accurate ("Request payload contains invalid interval[%s] or segmentIds[%s], atmost one valid value must be provided"), since the check is not really for validity of the supplied values but for the presence of both.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
suggestion + "'><label id='labelId' someattribute property-binding='[[foo]]' "
Please create a separate subclass for test mode if it is really needed.
What if there are duplicates in this stream?
Don't need (TopicPartition e) here, just 'e' should be sufficient
no need to instantiate this hashset (not being used?)
Owner metadata is not being set here
This should instead be this.setJobMetadata(LoggingFilter.OWNER_KEY, owner.getKey()), since the owner is never actually used as an argument in the execute method, and is only used as part of the metadata.
I suggest utilizing <LINK_0> to handle i18n of error message.
Java does not contain the keyword null.
why not put this all in one if condition? if (input instanceof EditPart && ((EditPart) input).getModel() instanceof ConfigurableObject)
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
I don't like this arbitrary limit of 400. Instead, I would check whether the index of the last visible line is lineCount. How about: public static boolean isShowingEntireContents(StyledText widget) { if (widget.getTopPixel() != 0) // more efficient shortcut return false; int lastVisiblePixel= computeLastVisiblePixel(widget); int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineCount()) { // There's definitely more lines below return false; } // Check whether the last line is fully visible int bottomTopPixel= getLinePixel(widget, bottom); int bottomHeight= computeLineHeight(widget, bottom); return bottomTopPixel + bottomHeight <= lastVisiblePixel; } That should also be much faster since it would at worst compute line heights for the actually visible lines, and it doesn't need any arbitrary magic number.
If we turned initWidget into the constructor for version 2.0 would that not work better?
why not use the style object like this: widget.addStyle(style.obrandDialogHeaderTitleElement()); And add it to the style interface above. This works right now due to the fact that that obrand_ should be external, but if that ever changes this will break. If you use style.xx it won't regardless of if the style is external or not.
grammar nit: 1, not one, and no :
recordCount++; doesn't work?
peices -> pieces?
I recommend using Collections.emptyMap() instead
@Override should be on line above. Checkstyle/formatter config?
Unnecessary boxing?
nit: can you put "File connector started" instead?
Don't use logger in shutdown thread, as the call sequence of shutdown is unknown, hence the logger can be stopped already, using the logger after it stops might throw exception.
Can we add in a configuration param for whether or not this poller is enabled and short circuit here if needed? Will make it much easier to turn off the functionality in case something ever goes wrong with it. (vs rolling back builds/etc)
Same as above, please move this line under the SetViewport line and add an empty line after it.
Please move...
I'd move this above the shader-related lines, as it is related to the FBO instead.
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
I think I expect here: if (!persistentAuth) { if (FiltersHelper.isAuthenticated(req)) { so the else will apply only if persistent auth... no? I also would have switch the conditions so you have the positive first.
Please reformat, line exceeds 120 chars
It seems that we are no longer required to pass the session Id to the event?
Please extract a method for sync.
I'd catch still Exception here.
Thanks for adding this!
correct, this API is now added in master.
return Collections.emptyList();
nit: make this final
Please keep these exceptions in the signature. We might want to complete the logic here by throwing the right exceptions moving forward.
Can get rid of this kind of thing and error prone null checks
It would be great to have braces around.
minor: consider using startTimeNs as you did in another method.
nit: readData -> copyFromSegment readIntoBuffer -> copyIntoBuffer / copyFromSegmentIntoBuffer readIntoFile -> copyIntoFile / copyFromSegmentIntoFile ? It wasn't obvious to me what's the direction and purpose of the plain "readData". (Inside readData it was already obvious)
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
In a development only environment that's _not_ localhost, they'd still have the situation where the account cookie would not be set. Maybe take that one sentence out?
Same as above for toString(): <LINK_0>
@paulodamaso the braces and return are not needed here
@komaz autoboxing will be used here, but maybe let's make it visible? .intValue() or equals()
probably this is an exceptional situation
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
use existing constant
move it to be aside of deleteFolder
This fragment is similar to the one used in generateFeedbackSessionEmailBaseForInstructors so it would be good if you can extract a method to generate this fragment or use some sort of html template to generate this string to reduce the repetition.
Revert the changes here.
Local variable could be declared List instead of ArrayList. Is this worth caching?
This restriction only applies to the event name and parameter name. Parameter values can be any string, long, or double.
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
If sharding key is /abcde, are these paths expected to pass this check and supposed to use this zkclient: - /abcde_0/xxx - /abcde/abcde-0/xxx
I was expectign that we were going to get here the address of the sender not as a string, but as a 64b address. Also, I was expecting that the app was going to display the data in hex and ascii format. Something like this... 0013A200:40AA33C6 -> 89 fa 76 43 23 23 43 56 76 54 34 23 23 34 | hello world! 0013A200:40AA2434 -> bb cc dd ee ff aa 11 22 33 | hi guys ... With the output properly tab and formated
This probably doesn't need to be wrapped any more. Also, when it's unwrapped the nls suppression can be inlined?
See earlier question.
In general I think its probably safer to replace these sorts of @BeforeMethod calls with direct calls to a function that just returns a new interval tree and call that explicitly in each test.
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
Double slash after .org part, is it correct? Looks like not.
The extension itself is added as annotated type? Should this be the interceptor type instead?
remove line
format as final String[] array. Rename to errorMessage if possible
you can call runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, false);
Please remove, it is no longer needed.
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
it is not really needed, we can simplify the code here
This is a very interesting way of handling this. I'm not quite sure how to feel about it yet, so let's leave it as is and see if it establishes a pattern for general output processing of the Java rules output. If so, keep them all; otherwise I would argue this is probably an expensive way of doing a null check.
requireNonNull?
Let's not revert this code. The whole "release as an object" thing needs to go away, not be compounded. If this is causing difficulties in your code, let's discuss them and figure out a way to work around them such that we're cleaning this section up rather than doubling-down on the wrapped version string paradigm.
The constructor should be made protected so that users can easily make a wrapper for it.
Should we check if the Kiji table actually exists at this point, so that users don't have to wait until a job launches to discover they specified a non-existent table?
Why protected if the class is final?
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Closed channels are automatically removed from a channel group. This line can be removed
Can't this NPE as they're Booleans (i.e. objects not primitives)
Why use a full-name import here? I don't see any conflicts.
Typo: s/setPartiotion/setPartition/.
@cvrebert this.now()
to STDERR
Maybe add some counter inside the handler just to be 100% sure the compiler doesn't throw this away.
Pull this into a static final variable
Ok, but in the future, you might consider constructing these w/ JSONObject or GSON.
Ditto formatting.
Do a fetch following the delete to ensure that it was actually deleted.
we could factor out a private getBinderForChannel() method given how many times these 2 lines are duplicated:  String transport = this.channelBindingServiceProperties.getBinder(channelName); Binder<MessageChannel> binder = binderFactory.getBinder(transport);
Same here: should be Branding, not ProductBranding
doc is missing
+ desc
Then we can use the name here to get a better description
l10n
Hi @rezita, I think this should be isSHREnabled
I think this is broken, the navdrawer is openning everytime I open the app.
GPS should be caps
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
I think including taskStop.getId() would make the log message more informative.
I think including taskStart.getId() would make the log message more informative.
Similarly, EqualsUtil might be of help here.
@timler I think that we should use do a class comparison using getClass() here instead of doing an "instance of" check so that different subclasses can't be considered equal e.g. a Donor and a Donation with the same id.
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
Add there an example of valid value res:RESOURCE[:CHILD-RESOURCE1][:CHILD-RESOURCE2]...[:act:ACTION[,ACTION]...]
This syntax is quite confusing.
Please make it if (attribute.getValue() == null) return;. I'm not sure, that matcher.matches() would work on null value, also for cycle would fail on NullPointerException. Also, we do not usually catch ClassCastException, it's up to you.
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
What exception is possibly thrown from this close(false) call?
Ditto here, if we have swallowed all possible exception inside close, then it is unnecessary to have another swallow here.
Use the API method and pass all given ids as ListInstancesOptions.
This will generate a call to inspect _every_ container, when you're only asking for a subset. Remove this and directly call inspectContainer on the provided ids.
...and _again_... ;-)
Would be preferable for this constructor should reuse the new one (i.e. this(name, durableWrites, replication, false)). Should also mark this constructor as deprecated as it looks like existing uses of it were updated to use the new one.
public?
I'm missing the new field in the toString method.
As a matter of symmetry I would expect a getter to return something of the same type as accepted by the corresponding setter, which in this case would be a Map<String, String>. In general I think difficulties in retrieving the correct results and putting them in an easy to use format should be handled by the API client and not by all callers of its methods.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
I've found that waitIfExceedingStalenessBound() throws InterruptedException when an interrupt occurs. However, we can wait further unless the staleness condition is met, if the interrupt was unexpected and does not need to be handled explicitly. Let's discuss it tomorrow if it's not clear enough.
Should we put the check here too?
what if input.length is a multiple of 256? wont this add an extra 256 bytes?
I would prefer the original exception to be thrown instead of wrapping the exception with another IOException.
Since the menu item click has been handled, return true instead here.
Instead of finish(), you can just set the parent of the activity in the manifest to MITMainActivity, that way it'll navigate properly to the home activity
This needs to be an if statement, only because when these app modules are converted to library modules in the sample viewer it throws this error: <LINK_0>
Best practice: Handle RuntimeExceptions coming from implementations, suppress and log them. Otherwise one plugin can break all other instances && node replacement flow
that seems reasonable. id might not be null in future, maybe better to filter based on INITIALIZING state (or either, i.e. that or id==null triggers exclusion)
Maybe better to return null
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
again I think you can use the diamond operator
You can build new KillbillPlatformConfigSource(configSource) once.
Just a style suggestion for these methods: java Set<T> set = Stream.of(e1, e2, e3, e4, e5).collect(Collectors.toSet());
these can be constants right? or do we need new instances of them for some reason?
I thought the compaction mark would be determined by the log unit on actual compaction? does this mean the compaction mark is set on garbage marking?
this one is intended to use the follow backpointers implementation, so it should be set to true.
Why is this behavior changed? It used to be NOT waitForWrite, but now it waits instead. Is that true?
rename to p, prop, currProperty
new ArrayList<>();
The default value of fail-on-missing-field is false, should set it to true.
why this change? private port can never be null. Public port can though
Same. No need to autobox?
It's Comparator.naturalOrder()
same as above with the actionBarWrapper
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
create a buildServingTrucks method or something similar in the TruckEntry class instead of doing it here
As an aside, you can pass a boolean here. Also in content values. They get converted correctly. No need to change it though
How about reverting negation?
mmm, i think this whole method should just always true. an I/O problem and all the other things are different from not being able to handle the request.
nitpick: try to avoid using var++ if you aren't then going to use the var being updated in multiple places. In this case var + 1 suffices and tells the reader that you don't care about var being incremented anywhere else. Also, I always get confused by the difference of var++ and ++var. The semantics of var + 1 don't make me have to think at all :)
this could be data.config instead.
delay is already completed.
check if delay is completed?
BiasedEntryWrappingInterceptor is checking if the delay == null. Is it missing here?
Would be great if we can check if the envelope.getOffset() is not null.
nanoTime != epoch millis in nanos.
Minor: "partition %s with offset %s to queue" for consistency.
Pull this into a static final variable
nit: add a new line before and after the constructor
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Brace next to class definition please.
requireNonNull
Translate this RuntimeException message in English please
I wonder why do we care about this. We are just have her self-containing AcknowledgmentImpl with the client it has been created. If that client becomes invalid at the moment of acknowledge() we have nothing to do anyway. What am I missing?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
throw exception
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
throw UncheckedIOException(e)?
ctx.close()
I think it should use Context#executeFromIO and also test handler is not null.
can you wrap this with if (log.isTraceEnable)
optional: consider returning this from setters to support chaining configuration.
static
can you please use {} for if block. I know the old code doesn't use this always, but in the new code we can do better.
UnsupportedOperationException might be more appropriate here.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
Missing StringUtils.isNotNullOrEmpty() check
Please move to a separate "Polishing" PR.
Can't we make it final as well? What if we try to rewrite the Mockito tests? I am asking to tweak the tests for several reasons: * it should be final by design; * we could avoid <p>Use the {@code Bus} class abstract methods to modify the behavior of posting and <p>This method defines the general posting flow and should not be overridden..
Please add curly brackets for the for-loop.
try block.
This call is unnecessary for the test - the exception gets thrown in the previous stmt.
It looks like all of the calls to createFakeHeader pass in the same empty metadata and additional columns lists, and fake seq dictionary, so this can be much simplified by just removing those and returning the fake header.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
not needed
No need to override the data type system here.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Need to implement
Pretty sure this is a Nonnull field. Just make it a Chest or Empty.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Should remove, and use similar functionality in CoreAuthenticationTestUtils
Same goes for this file.
Are these mock objects used?
Why not rely on Optional, rather than introducing another method which could lead to NPEs?
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
you have lost the cause e
Shouldn't this exception been thrown too?
It's not a good design pattern to close resource-parameters in methods. There are the following converntions (which may violated in certain cases) - If you pass in a resource, the caller is responsible to close it - If you wrap a stream (e.g. new BufferedInputStream(is)), closing the outer stream will close also the inner. You should fix that resource leak at the caller side, there is only one in io.ebean.config.properties.Loader: java void loadYaml(String resourcePath, Source source) { if (yamlLoader != null) { try (InputStream is = resource(resourcePath, source)) { yamlLoader.load(is); } catch (Exception e) { log.warn("Failed to read yml from:" + resourcePath, e); } } }
This same as next test in terms of logic, since you're not actually testing the "default" min range is used since a min range is set on the annotation.
modify to static import ?
following the change above, i'd expect this one to look as: assertTrue(validate.isEmpty())
where did this go?
Can we throw an exception instead?
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
Should we keep a reference to the Bundle here?
Would you mind making the "tabList" string a constant symbol since it's referenced in multiple places.
"isSearching" should be a class level string
requireNonNull
keep requireNonNull
@Nami this is still mutable na, only not by us. It doesn't guarantee that the original input map will not change.
please validate ledger id
close should be implemented with asyncClose()
change counter?
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
I suggest to keep the order consistent for easier reading/comparison: * field declarations in StashNotifier (maybe) * setters/getters in StashNotifier (maybe) * default values (lines 751-758) in StashNotifier::configure * assertThat calls (lines 27-33) in ConfigAsCodeTest::should_support_jcasc_from_yaml * setter calls (lines 40-47) in ConfigAsCodeTest::should_support_jcasc_to_yaml
Can this be private, or is there another use case for default attribute outside the builder's call?
No idea why, but the loaded_template entry on quality gate has not been removed on my box
select return a SqlStatement on which you can call setLong to safely set the size to compare to
why select the id? It's not used
If ClientCnxn.clientConfig is final then you can replace this by clientConfig.isSaslClientEnabled()
is this part necessary?
return flagdown; ?
You can use [String.format](<LINK_0>,%20java.lang.Object...)) to make the code more concise.
Worth checking the length in case invalid format was supplied with more information exception message.
Guessing that -10 should really be TreeReference.INDEX_REPEAT_JUNCTURE?
This check is useless as the customParams can never be null.
This drops all rs and collapses all ns to  .
return null to make this more explicit ?
Is it possible that this could ever return anything other than UNKNOWN_STATS or usecom.facebook.presto.cost.FilterStatsCalculator#UNKNOWN_FILTER_COEFFICIENT here? I don't expect FilterStatsCalculator can estimate anything useful for spatial join. Are you OK with this? This basically means that CBO will generate more-or-less random plan for queries with spatial join.
We shouldn't rely on a random client, even if we don't return it here.
not good hardcode git here
X and Y are primitives, so should the %s be %d here?
I don't know, but isn't the class also of interest?
Should have a period on the end of the string for consistency.
Something is weird here. The only place where something is added to activeServices is the registerService method, which itself is called in this loop. So my assumption would be that this set is always empty when we get here, resp. the registerServicemethod had already been called for the service in question. What am I missing?
add java doc what does it return?
Its nitpicking and mostly personal taste, but I find it difficult to follow the boolean changes in the code, and more error prone. How about removing it, and having multiple method-exit points (return). eg. return multiMapValue.getCollection(false).add(value);
Why not java static Builder builder() {  ?
I am guessing your builder needs to have isShared and isAudited set to default values (false) here. Also based on this: <LINK_0> Please add the corresponding docs for the properties here and in other places as applicable.
This method should be static and need not pass this as an argument to the constructor.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Looks like it will have next format  SystemServiceItemStoppedEvent{item='1', ....} class org.eclipse.che.api.system.shared.event.service.SystemServiceItemStoppedEvent {evenType='someType',...}  I'd rewrite it with using getters from super class
log.trace
log.trace if at all
Make this job delete or disable it self after it has completed running. I believe its a one time Job
This plays the current, not the next station.
suggestion if (this.currentTask != null) checkAndRethrow();
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
Again, I'd default to false - I think 'nothing' makes more sense as false...
instead of looking this artifact up by name, can we create a token instead? i believe that's how this artifact is referenced elsewhere.
this one? ;)
Can this be private, or is there another use case for default attribute outside the builder's call?
public?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Can this be private, or is there another use case for default attribute outside the builder's call?
Should we handle the case where assignMessageId returns Message.NONE ?
I feel that isM is not mandatory too. But in other hand, the translation of early negotiation in the spec is M=0,NUM=0: _" To influence the block size used in a response, the requester MAY also use the Block2 Option on the initial request, giving the desired size, a block number of zero and an M bit of zero."_
The whole if (request.getToken() != null) block should be removed because this check is now done in InMemoryMessageExchangeStore.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
This catch clause can be eliminated, since it just re-throws the exception without change.
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
This can be done through one call to obtainMessage(what, arg1, arg2, obj)
This can be done through one call to obtainMessage(what, arg1, arg2, obj)
we need the modulo here, right?
Just use !secondaryIndexes.isEmpty()?
Missing types
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
This can never be null given the code in setData above?
how could contributions be null? Create it at the field level if you want. It should also be final. There are minor style violations in this file, no spaces around operators
you can use Objects.hashCode()
This line is probably not needed at this point.
No if block required here either.
Is this callback even hit in the context of this PR? If not, can we remove it from this PR and add it to the PR that it's used for the first time? Thanks!
Multi return is forbidden.
This should be done in DNodeListElementEditPart
nit about getHost again.
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
hey, I'm not super comfortable with "%n" and "%p" as delimeters (It's totally reasonable to imagine that people might have "%n" in their text). Are those directly in markdown? If not, we should talk about how to do this differently
you need to first trim input otherwise this doesn't match if input starts with whitespace
the toString() isn't needed here as the AgreementType enum will automatically serialise to a string
Since this is only used in tests, is there any reason why we can't just have this exception bubble up all the way to the top?
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
you should have here setSucceeded(true) IIRC.
Will need a @since tag.
No parameter in setter method?
This method should be implemented.
This line could merge with the next line, making the next line return new UID(requireNonNull(v));
the 10000 looks like a wrong digit.
The local var is useless, you can remove it.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
for the boolean parameter could be useful to use enums, so that it is more clear what it means
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
Minor: same as in other number check, WDYT about checking for the decimal point?
What if the string doesn't end with a " or '? You'll strip the last character.
the ArrayList of languages to translated could be cleared.
Would it make sense to add something this.caches.clear() to the stop ?
factory must close its cursor (which is closeable)
This is using scheduleAtFixedRate but task DirectoryScannerThread never terminates.
Use runSansThrow wrapper as before.
what if this ensure fails on one of the clients?
Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)
@maria-farooq with the current implementation the requestee will always be null. Shouldn't we protect the code for this?
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
add this selector to UI mapping at the beginning
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
Do a fetch following the delete to ensure that it was actually deleted.
Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
great if we got rod of the magic flag :+1:
suggestion this.authentication = new AuthenticationContext(username, password.toCharArray(), null);
checkNotNull
Would be better to validate the seconds here again, because this is a public API, users may directly use it in JdbcSink.
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptyTop.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptySubprocessEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
The equals check is brittle, I think it'd be better to do a check against a query context key. Or alternatively, do something like groupBy does, and use mergeResults to modify the query to remove the post-aggregators. Then, everything downstream of mergeResults on the outermost node (typically the broker) will ignore the post-aggregators. That could be done by overriding doRun in the ResultMergeQueryRunner.
I think that to be consistent the result of apply fn.apply(name) should also be checked using Preconditions.checkNotNull but maybe it is not needed?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
Using Collections.singletonList() is slightly more efficient as long as the result doesn't need to be modified, which is true here and and for getDescription()
no docs, and can you make a list from columnLabelIndices.keySet() so you don't need a new member?
I'm afraid this could spam the logs. I made bad experiences with logging when developing the DOIConsumer. Please reduce the log level to debug.
Do we need to remove the reservations here if the member is no longer the replica after rollback, same as for record stores?
You can use if (event.getDMContext() instanceof IContainerDMContext) to know if you are dealing with a container or a thread.
To prevent code duplication, would it be possible to change the body of this constructor to the following? this(); this.builder = builder;
Load and termination parameters should belong to Load and Termination entities
Hi Tolis, would you mind to move the code below to another class?
isErrorIfHostDoesntExist => isNewHost
please extract to a separate method
I don't like the following constructor, during creation of class we are trying to perform a queries to DB, if for some reason they will failed , the exception will be something like that java.lang.ReflectionException or InvocationException, which will not provide us with any clue for reason of failure.
Should emit list of values, using setDimension(String, String[]). Also the dimension is called "dataSourcesAndDurations", but only data source names are emitted. Also if this change is done, getMetricName() method name will become confusing.
Boolean vanished?
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
count(*) is more canonical than count(1).
What is the general consensus around repositories with YELLOW health? Can those still be read?
Add active filter and return only the ID and CONCEPT_ID fields.
Is this used anywhere?
What happens when someone is reusing the same instance, would tableId be overwritten? Can we add a check to avoid this?
remove this. The formatted strings are the same, you can write a method to do the formatting.
It's all histograms from now on, and IMO the per-site statistics should be in core, not extended-statistics (for sync backups too).
Minor, Optional.empty() would be the thing you are looking for :)
Remove / update this log line.
final URI uri
what is the reason of having this method static?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
the storage pool should be set from the quota object, i don't see a reason to send it separately, apply also for update and remove
why this is in vmCommand? should be in stopBase command
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
use this.size()
Is there any chance for the three conditions, some of these them are true and others are false?
Same: static import lightGray from Color?
I think we can remove this line.
Is this not redundant? AFAICT the method it delegates to does the same thing.
for the boolean parameter could be useful to use enums, so that it is more clear what it means
final or inline into the call to assertEquals
I think this should be replaceFailed = false instead.
bad hashcode.
Use same order as the field declarations.
Both lines dealing with the provider should be moved together, following the usual pattern: if (x != null) { x.dispose(); } x = null;
Shouldn't we use empty list here ?
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
Mmm actually I spoke too fast, it still fails on the command line...
wrap INSTANCE = new IndexClient() in another if (INSTANCE == null) { check - this is known as the double locking technique
In the page, projects are sorted by a comparator, so that projects.get(0) may look as a randomly chosen project. The same problem was solved in NewApplicationWizardModel.getDefaultProject() by applying the comparator.
sync
Oh please, no! Don't ship a null object! :cry:
Don't initialize to empty when null.
we never use NULL, it is a bad practice in general.
This should stay final
Should this method be final?
why not use super? like: return String.format("%s, volumeId=%s", super.toString(), diskImage.getId())
Optional.ofNullable could be used?
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
What was the problem with logging the condition?
hope it will works here as well for this class
I think it worth adding a field on the template to indicate it is sealed
replace this with a provider: import javax.enterprise.inject.Instance @Inject private Instance<ConcurrentChildCommandsExecutionCallback> callbackProvider; ... callBackProvider.get()
remove printlns before this is merged
change variable to something more meaningful
Bad variable name! Variable names should be clear enough. Rename it.
this whole tests needs some cleaning up before we merge it back. i'll look into it
missing @Override declaration.
Can you change these strings to xml tags <user> ?
Please change to 0f and 0.000001f. Otherwise assertEquals(double, double, double) will be called.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
Is there any chance for the three conditions, some of these them are true and others are false?
This error message is kind of confusing. Perhaps replace it with, "Error in accessing DB.".
Log?
Did you still want to put this off?
maybe log an error message here if numConnections ever goes less than zero
This could be a bit more readable using a lambda. Just a thought.
ctx.close()
Looks like you are making double slashes here...
@dalifreire is this enough? What e.g about class name?
I don't think you need this new String
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
Maybe invoke shutdownNow()?
Would be cleaner to call cancelAll() here. My expectation is that we would clear state and start afresh during a new session
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
There's a formatting issue.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
I don't think this is atomic.
Is it just me who prefers string.isEmpty() over string.length() > 0 ?
use this.size()
So this will be used for quantity and duration too or you need separate ones?
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
avoid this containsKey
use info if it's not an error
It might be better to use Collections.emptyMap() instead of new HashMap()
Is there a reason why this. is used for calling the setter in all the constructors?
Why not get rid of configurableByScan entirely? suggestion if(StringUtils.isNotBlank(rawUrl)) {
Maybe have an overload that doesn't require this since it isn't used.
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Rather than creating just an ad-hoc instance of NetworkCallTask, is there any possibility for us to use a TaskPool (Implemented using commons-pool, etc) and control instantiating the aforesaid objects?
Nitpicking: should just declare Exception
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
should reverse order as follows: assertEquals("",html)
consider using assertEquals instead, since it's much easier to maintain here, above and below
this statement can be removed. No need to set any OutputFormat on the job itself. We'll use the OutputFormat for the specific output (being defined on the next line).
This should probably be i18n log
Instead, let's try to register a dispatcher of a different type which handles the same command.
uriHost is already a String. No need to call toString() on it.
filename should not be null according to interface (or do we want to allow it?)
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Inline please.
Please inline to match style
this is the default value so could be omitted
The original is not removed, so either there will be duplicates, or the hashcodes will match and trying to add the managed version will do nothing
simplify this
do we need this check ?
again - encapsulation
This method is used only in another method, why did you make this encapsulation?
Would advice using waitForValueToBePresentInElementsAttributeByElement(searchInputInGlobalNav, "value", query) after the sendKeys just because there are cases that Chrome tries to type a long message, the next line would execute before everything is typed in the field.
Move this private method below the public analyze* methods?
getparentDiagram() will be null.. you have to set the container before calling the method.
I think we should use FEELParser.isVariableNameValid(source) as it is implemented exactly as our DMNValidationServiceImpl.isVariableNameValid(source)
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
please also add the GUID which is important.
throw exception or log some error message here to indicate the error
Consider returning a constant
These arrays could be defined statically in this class, as to not create a new array every time this method is called.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
Initial size can be ownConfig.size() rather than +inheritedConfig.size(). And could create copy with with return Collections.unmodifiableMap(Maps.newLinkedHashMap(ownConfig))
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
you might want to make 10_000_000 a constant
This test data is a bit suspicious. createRecord alternately creates mapped and unmapped records, which means some of the records created here will wind up as "mapped/half-unplaced" and others will wind up as "unmapped/half-placed", due to having an alignment start but no reference index. Those are weird states for test data, and its not at all clear from looking at this method whether its intentional. Not that we don't want to test the "aberrant" cases, but we need a cleaner separation between valid test data and invalid.
This is bytecode equivalent to using the for-each syntax on an array.
@evacchi I'd vote for creating the output set only when there are outputs. Here the outputSet is always created no matte if there are outputs or not. This will produce an empty <bpmn2:dataOutput> tag in cases were the catching event don't have outputs (there are some of them that doesn't have) or in cases where the process has been saved and the user don't yet completed the event definition. Same happens for the start events that uses the CatchEventPropertyWriter, events like StartConditionalEvent doesn't have outputs. And I believe same reasoning makes sense for the ThrowEventPropertyWriter, there are events like EndNoneEvent or EndTerminateEvent that doesn't have inputs.
I am not following here - why do we want this in sync block?
Use fire(event); for all EventHandler based events
typo. 2nd one should be V2
Since the data set is the same for JobRecoveryTest (and because it is interesting to always test both JobRecoveryTest and NodeRecoveryTest on the same data set), maybe we could share this data set through a dedicated class, for example RecoveryDataSet?
nit: The keys should probably be constants, for consistency with the other tests? Alternative is changing everything to this style, but I think the later tests which use these as keys into a maps should have them as constants
log the exception ?
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
Hm, you got java doc on the next method, but not here?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
int[] props would make everyone including the style checker much happier
For loop?
please remove this empty line.
why the leading { ? typo ?
you could send the cluster object instead of just the id, so you wouldn't need to get it again from the db just for the name
Why?
Does this Iterator do an eager page load of the kind we were trying to avoid in OracleCellTsPageLoader.PageIterator?
Did anything actually change here? If not, maybe we could keep the original version of this method to keep the diff smaller?
This should probably be java if (CliLogger.ROOT_LOGGER.isTraceEnabled()) { if(satisfied) { CliLogger.ROOT_LOGGER.accessRequirementSatisfied(toString()); } else { CliLogger.ROOT_LOGGER.accessRequirementNotSatisfied(toString()); } }  The toString() may be expensive.
Why tryLock()? Is it possible, that services won't be undeployed after deactivation?
main thing is to keep our Prometheus stable so folks using grafana dont wake up to have their graphs broken. I will look carefully though
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low. I will add a small high watermark buffer, then.
I think this can also be  java applyCollection(CharSeq::of);
Why not? Or it just doesn't support it _yet_ since there's no need?
Isn't pattern should be /user(/password|/)?$ ? (add extra $ a the end)
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
Lets keep these methods internal for now (package accessible).
Don't swallow exception here
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
if getSessionTags print warning - this one should also do so
Add reasonable toString() method, returning null doesn't seem as proper way.
somehow that message is now deleted. New link - <LINK_0>!topic/druid-user/bd9dXKcJ8tg
It's not wrong, but it would be very nice if you could use the logger messages embedded in the _Log_ interface? So here you would have:  log.redisStopping();  Which allows the internationalization team to translate it or redefine the logging level.
Useless statement.
'itens' looks like a typo, want to fix this while you are modifying the file?
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
Again, needs a context.restoreAuthSystemState();
Again, needs a context.restoreAuthSystemState();
Be careful when copy paste :). You are printing "bundle started" when stopping also. Another thing is when you have no string manipulations in debug messages, you don't need to check isDebugEnabled(). It is an extra if.
We do not need to check if debug is enabled since there is no string concatenation. The check will be done internally.
This is not time zone?
Actually, I'd recommend initializing principals using Collections.singletonList(SimplePrincipal.newInstance(username)). The resulting list is immutable and an efficient implementation.
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
WithTasksContext
would be nice for the 4 to be a constant for readability
s/ret/partitionKeyStr maybe?
One of our helper classes must/should have a utility method to get a time relative to current time. If not, add one?
Same here. No need to cast.
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
Shouldn't that be Class<?>
I'd change that code to one variable declaration per line. And I would avoid inline assignment too (the first newGenerator is not needed before the if). Those too may confuse most readers.
for consistency with other classes, use Objects.hash()
We could make these less verbose by using Guava's Objects.equal and Objects.hashCode utility methods.
You could implement hashCode in Scale
This should be part of the try-with-resources block.
May want to add a failure message to this assertion that includes the expected value. Otherwise the failure message will just say that it was false when it was expected to be true and we'll have no idea which value it failed at.
I think this isn't safe, as it will also remove spaces from values of tags and attributes. For example, if I send this: <vm> <description>My VM</description> </vm> It will be replaced by this: <vm><description>MyVM</description></vm> So the description will be wrong. Maybe replace ">\\s+" with "><", but that can also generate wrong data, but not likely in or tests.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
What do you mean remove is overridden? I was fairly sure the following would work: java public void remove(K key) { heads.writeLock().lock(); try { heads.remove(key).close(); } finally { heads.writeLock().unlock(); } }
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
should this be 3.5?
any reason for the double 'max' ?
what if 4*vmBase.getMemSizeMb() > maxOfMaxMemorySize ?
pls. use Collections.emptyMap() instead.
forEach is designed for side effect, a chained stream seems better to me.
You should be able to use the diamond operator here, i.e. new ArrayList<>()
entryId is not used, please remove
Here and below, now that the input can be an arbitrary object, we should call format on them to make sure they are escaped properly for output.
String.format might make this a little neater and easier to read.
should the second arg be true here?
Putting a cleanup here may result in weird behavior, since the interpreter.exec(pythonFunction) will no longer be called at each processElement
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
This can be static.
This could be null, we should probably handle this if the JIRA api changes again
i'd add "perform"
getMessage() and debug trace?
s/Mac pool/MAC addresses pool
Don't like catching exception in the constructor. use an init method with @PostConstruct annotation.
Validate spelled wrong. "ValidateChainOfTrust"
I am OK with just using ex.getErrorMessage() than getLocalizedMessage(), but I do agree that we should try to stick with one method in our code for loggers.
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
This method is odd: It doesn't really fit to markCheckpointStart (markAlignmentEnd() does). Maybe it should simply be called setAlignmentDuration?
unused variable
typo in exception message
you could just do setConfirmWindow(null); like above method
While you are at it, maybe you could also change the .equals("") to .isEmpty()?
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
annotate with nullable.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/ .... maybe make the test do foreach(String zk : new String[]{"localhost", "localhost/", etc}
what about case clearTable = true and clearZK = false
Do we need to validate the config once in configurePipeline() and again here?
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
Same here, with respect to bad exception handling.
Does this need to be a singleton?
Why don't we just set the memory usage with the setGeometry call? It's easy to miss setting the memory usage after setting the geometry.
nit: you can return in the if block and get rid of this else.
nit: I don't see other places using () around the values in the output message. Remove the brackets.
why not directly constraints.domains().count() == 1 ?
Change the getter so you don't need the cast
flatMap that stuff
Having users of the method forced to wrap the parameter into Collections.singletonList, I am thinking, why isn't there an overloaded method with , ... BibEntry entry added, which alles Collections.singletonList internally? -- Reasoning: There are more callers than callees, thus make it easy for the callers.
The old entry needs to be removed, right?
please make this method to work based on the locationUri instead of some operation on Database
if (TransportMode.HTTP.equals(getTransportMode())
I've changed the type of exception to NotImplementedException as we _don't have a plan to use it for now_, which does NOT imply _we'll never support this feature_.
I do not get the meaning of the message. Also this could be moved to #8263 and merged sooner. Also maybe we should get rid of default implementation of close() in SpillContext interface. If you decide to do so also add it to #8263
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
One line ...
Does this do anything outside of test mode?
Can simplify by dealing with the exceptional case first: if (!allowPushOptions) { // Reading push options without a prior setAllowPushOptions(true) // call doesn't make sense. throw new IllegalStateException(); } if (enabledCapabilities == null) { // Push options are not available until receive() has been called. throw new RequestNotYetReadException(); } if (pushOptions == null) { // The client doesn't support push options. Return null to distinguish // this from the case where the client declared support for push // options and sent an empty list of them. return null; } return Collections.unmodifiableList(pushOptions);
Remove the redundant null checks.
In general, we should probably be moving away from client-side validation where possible.
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
maybe test first char for empty letter as well to reuse s if possible?
Qualify this.uri
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
The 'if' check isn't needed here, right? replaceAll will only match if these are true?
could we print the types here?
This would probably better be inverted if (protocol != null) { switch (protocol) { ... } } throw new IllegalArgumentException(...)
Please do so.
have you thought about using the builder pattern to follow the code line in the other projects?
Is it really necessary to add this check here? Doesn't the AuthenticationProcessor prevent the login request from reaching this point?
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
Assertion seems to be missing?
I must admit that false to me carries little information. Maybe a constant with READ_ONLY in the name could increase the readability.
I assume it's false because you expect the Permission schema to be populated?
What's the point of adding a copy here?
Maybe wrap in an immutable map.
Should use Long.class
How about the following to simplify the string construction below: java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME);
Shall we reuse the constant here instead of "api"?
I think if serviceMatcher == null we need to preserve existing behavior and do the refresh? Maybe still log the warning. What do you think?
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
default method visibility OK?
what is the purpose of this line?
I believe this method should be private
Let's use waitForElementVisibility instead as waitForElementPresence only checks if element is present in DOM, regardless of whether it is visible or not.
No. Remember what I said about anonymous classes?
Maintenance of the map will be simpler than that of the list
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
Shouldn't appId and SecurityToken values be URL-encoded (or any URL parameters that could potentially contain illegal characters elsewhere in this source file)? I see the default app ID has / and + in them, for example. The appId might be only accidentally working at present.
I guess we need thread safety here. wouldn't it be simpler to eagerly set the api? and OvirtClient should become a singleton. even a @Singleton
Why is this two lines?
Move check storage == null inside areSubscribersBehindByMax(). Can you pass a number of blocks that the publisher is ahead of subscribers as a parameter? Currently, it reuses max number of blocks, that in general should include all allocated blocks. In future, back pressure should provide a separate parameter that tells by how many blocks publisher can be ahead. Please also consider renaming areSubscribersBehind to isPublisherAhead.
This also regresses in that it no longer works for multiple repositories.
Small change, but can you swap the check around? First evaluate the ConcurrencyCheck. As this check has a greater chance to short circuit the conditional sooner.
Shouldn't this be == ?
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
I would prefer not to use null ... just a empty set and then assert that its not null
Is there a reason for this toBuilder().build()? The following compiles fine:  final Component component = TextComponent.empty(); TextComponent.builder().style(component.style()).build();  I haven't run it though - if there is a problem that you've worked around, we need to report it to Adventure.
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
A possible problem with this is that it relies on the zoom thread, and you might have an implementation that does not use any zoom list or thread (could override createZoomThread() to return null). Also, it's not clear what value the flag should have if you have completed the zoom with an empty entry list, or if the entries are all filtered out. Does it work if the build thread has done a first iteration and called refresh() but hasn't discovered any entries yet?
shouldn't that be return retriesOnFailure.decrementAndGet() >= 0;? It returns the updated value, so retriesOnFailure = 1 would lead to no retries
I'd say this will not work in for example this case: - You have a VM on a cluster and pinned to some host - Open the edit VM dialog and change the cluster - The pin to host will stay on the original since the "firstRun" has been called during inicialization phase I'd say a simpler solution would be just to check, if the host you want to be pinned to is present in the list of hosts on this cluster (getModel().getDefaultHosts()). If it is, than continue in this logic. If it is not, set auto assign to true and set the selected item to null.
What about SavingState and RestoringState?
please add similar note as to missing numa scheduling policy. All we need to allow it for all VMs is to have a (better) cpu flags policy
requireNonNull
Why do you wrap here unconditionally, why there is no isValueNode() as in other place?
Can you add a CommonHelper.assertNotNull("delegate", delegate); check?
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorZkBasePath from config? Do we need to add it back again?
Where is this list updated?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
this should be true when index == 0 to allow optimizations for this particular case.
Geometry is comparable?
missing @Override declaration.
**Intellij warning:** Initializing this variable is redundant, the same result can be done with: return "<?xml version=\"1.0\" encoding=\"UTF-8\"?><repositories>" ...
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
This is another behavioral change that I don't want to see in an unrelated PR.
what if my value is " " ? should use trim
We have a removeConfiguration so let's not allow null value here?
To improve, I think .warn is better.
Possible candidate for explicit IllegalArgumentException if invocation is null.
Possible candidate for bind() if that method is created.
Do not contacte file paths. Use HomeDir.toFile().toPath() and resolve from it.
any special characters to block in webhook name?
@Restricted(DoNotUse.class) wouldn't be a bad idea.
Sam as in the production code, matching on comp=blocklist seems redundant when matching comp=block?
Why static?
In that case, let's put a SettableFuture here and initialize it in enqueue as discussed offline
Copy-paste error? Shouldn't this be "new MergeExample"?
May be you do not need another submonitor conversion here?
Minor: s/invokeApplicationRunner/invoke Minor: s/orgConfig/originalConfig
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
Let's avoid null and rework to empty string
where are the exclusive locks, that should prevent taking these locks in case of live storage migration, are taken? neither LiveMigrateDiskCommand nor MoveOrCopyDiskCommand are annotated with @LockIdNameAttribute
why do you change this?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
You need to remove the client.close() below too since this test class is using @AfterClass for closing client
Aren't we doing this in the superclass?
@szczepiq Would you mind using the ExpectedException rule, this would improve the readability and avoid try/fail/catch blocks which distracts the reader from the test case IMO.
Feel free to ignore: Do we really want these this there?
how about to move line 439-441 to be before line 435 - not because of performance but to make it more clear that in this case we don't need the cluster version
super.getVm() will do dao call...
Raw type?
Raw type?
This should be ofNullable, right?
this method can be made static
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
I don't think this equals test is necessary
Is there a chance of a NPE? could be getFile() null?
Maybe we should add element.toString to the error
You could maybe use enclosingClass to save a few hops...
I'm surprised to see this here - it was already removed a while ago. Maybe you're not editing the latest version from develop?
Don't use intern. Use create instead. Intern pins the string in memory forever. If its a constant declared in code, that is fine. However for dynamic data like a branch name that would be bad, as the memory would almost never get released.
Use create instead.
i'd add "perform"
getMessage() and debug trace?
maybe proceeding with an inconsistent snapshot
you can use tasksByPriority.entrySet() here
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
You don't need a capture group here. Only use capture group if you want to capture more than one thing.
You can use for-each for arrays too, for (String name : names) { !hasEvent(name)
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
For loop?
Is ... depends from onTheFly parameter?
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
inline getInsertIndex and putAtIndex  ++count; int index; if (elements.length < maxSamples) { index = elements.length; } else { index = ThreadLocalRandom.current().nextInt(0, (int) count); } if (index < elements.length) { if (elements.length < maxSamples) { double[] newElements = new double[elements.length + 1]; System.arraycopy(elements, 0, newElements, 0, elements.length); elements = newElements; } elements[index] = element; }
Possible NPE with calling contains on artifact.getName() ? Better checking for nullity before calling .contains
Possible NPE with calling contains on artifact.getName() ? Better checking for nullity before calling .contains
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
that class would be better with a builder, though I wouldn't ask changing it now
this whole method could be a oneLiner: return find(...) != null
I wonder if this does not already do the job done in the following for block ?
Did you mean to reset the interrupt flag via Thread.currentThread().interrupt() instead? This is optional, but I think it is reasonable for a method named wait... to throw InterruptedException to allow the caller to decide what to do if the wait is interrupted.
Same as above: .getAllOfTypes(new VDSType[] { null });
Verify that at least returns one element?
This test might fail if the returned list differs in order than the expected list but contains the same elements. I would use a loop over the expected results to see if they are contained somewhere in the returned collection.
This looks like a separate fix for some issue (vs. what's in the CHANGES.txt entry), yes? What was the guid check for previously?
I guess it would be nicer to just return the single instances that we know from FunctionType.MIN, FunctionType.COUNT here etc...
Please add a new message to CommonApplicationMessages, instead of creating the message in code.
What's "c"? Can we unabbreviate it?
I still don't think you need to call consume() here. To my understanding, each iteration in L143 reads at most what's left in the current page, and will never cross the page boundary and read the next page. The left here is the smaller value of the number of values left in the current page, or the number of remaining values need to be read in the current batch. Thought?
Seems subarray also does copying. Can we avoid that?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
these trace statements should be removed
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
by default the preference are flushed in the preference store when closing eclipse. I is done automatically for UIPlugin through AbstractUIPlugin class. You have to do it for non UI plugin
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
nit, Collections.EMPTY_MAP?
/s/else/elseif
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
Instead of just checking if it's Windows we should probably do something like: FileSystems.getDefault().supportedFileAttributeViews().contains("posix")
remove else
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
typo in exception message
Can this be private, or is there another use case for default attribute outside the builder's call?
public?
I'm missing the new field in the toString method.
Why using a temporary file for reading the test dataset?
indentation is a bit off here
is this 10000000000l or 100000000001? Use upper case 'L' a lower case 'L' should not be used for Longs or variable names.
This seems like a good use of ordinal since it's lifetime is expected to match app session.
It seems that dialog.setArguments(args); is missing here.
You're using putSerializable() here, but then you used putInt(ordinal) in the previous patch. Can we make this consistent?
provider -> buildProvider(provider) -> this::buildProvider
changing selector type may produce unwanted side effects in some legacy browsers (which used a lot for some enterprise web apps). So please move change from xpath to css to separate PR
This should be List or Strings
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
this is a little strange. the macro validations for all other params happens inside config.validate. Why not move the check for port inside that method too?
s3n is an older, but still supported scheme. should allow it too.
"Invalid port number." Same thing below.
Why did you need to implemente these getSyncObjType and getSyncObjId? Could you explain this a little bit further?
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
I think that the underlying XMLStream reader has a 'getAttributeValue' method. It receives the namespace and the name of the attribute. If you pass 'null' and the name of the attribute it will return the value of the attribute, which is what we need: <LINK_0>
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
Could be optimized: do not create StringBuilder if no replaces are needed. See com.intellij.openapi.util.text.StringUtil#replaceChar(java.lang.String, char, char) implementation
Since you're already using Guava, consider using [throw Throwables.propagate(ex)](<LINK_0> here instead.
Should we handle the case where assignMessageId returns Message.NONE ?
this duplicates code with RequestUtils and RequestMetadataInterceptor , we could extract this out by creating some method that takes HttpServletRequest as a parameter, returns a Map, then add the info where it is required
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
I see no reason for the setters to be public.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
That's good to know.
There's no concatDeep, I guess..? ;-)
I think this should be Coder<Mutation>
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
It would be better to delegate to the codec's makeSourceFromStream method here.
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
debug = Boolean.getBoolean("run.flaky.tests.debug"); does the same thing as what you have here.
Here we can either get rid of the DEBUG variable altogether or use LOGGER.isDebugEnabled(). The best solution is not having DEBUG at all and using the LOGGER.debug statements directly.
Add a proper log message.
The blogsEntry != null check is missing, isn't it?
U.closeQuiet?
This won't work. We won't know if the Forge client is outdated at this point.
Guava has Objects.ToStringHelper() to make it nicer.
channelId => channelName
minor: don't need this. qualifiers
Let's just fix the OS by default. The default location should be configured by the jclouds *Implicit Location Supplier*. The default hardware is, by default, the smallest one.
Ccan we default to a more modern version?
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Isn't this missing an implementation?
Becarefull with those assert. They will not fail if jvm is not launched with specific argument (-ea). You may use a Preconditions.checkState() instead.
this.monitor to avoid confusion with the parameter of the same name optional: this whole block could be a ternary: this.monitor = monitor != null ? monitor : NullProgressMonitor.INSTANCE;
"RuntimeException" I guess this is leftover of copy-pasting from other issue. Please correct here and below.
Indentation looks wrong compared to other test.
Why does test2 come before test1? Please swap their order.
synchronized block is not needed
Is this method really needed? It's similar to make init public
We need a better name for this method.
default method visibility OK?
This can in theory throw a NumberFormatException. This is caught in similar case in ListBoxByteSingletonDOMElementFactory, might be good to catch it here too.
This seems like way too generic of a place to put this validation. What use case are you trying to catch with this.
We're removing the getActivity() != null check. Is it possible it might cause a problem?
"==" to "="
Noticed that the builder should be sent into the NotificationPresenter.showNotification().
Do you have a test that peeks the next sequence number?
Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.
suggestion when(motionEvent.getDownTime()).thenReturn((long) 0);
Maybe invoke shutdownNow()?
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
Null check for leaderElectorListener
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
I would call them attributes because that's how they are referred to in the XML / HTML world.
If parameters are configured in property files, they end up as Strings in this map - so make sure that you do not run into CCEs here.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
factor out
please create a more specific exception that extends this one.
use {} pattern for LOG statements. for example LOG.info("Starting PYAPEX with {}", StringUtils.join(args,' '));
remove red
I think we have an instanceMainWithExit Oops, that's in picard-public - but perhaps it should be in htsjdk?
style nit: we don't use braces around single line blocks
Calling super.init(); is unnecessary, since ActionHandlers implementation is empty.
could checkNotNull(getConfig(OWNER), "owner") here, to fail fast?
Ok if already stopped? idempotent?
Should be in a finally block?
Also too many dots
Good note. I think USER_PORTRAIT would be better so it works upside down too
Why are we configuring drawer in this activity. This activity shouldn't have it.
The actual bug-fix: Use a style that inherits from AppCompat
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
Unnecessary cast.
This is in a test and we know what we argument we pass (never null) so if (expected.isEmpty()) is enough.
I suggest including the uri in the exception message
is 404 not valid anymore?
This code has a race condition. Its possible that another thread creates a table between exists() and create(). The following avoids the race condition. java try{ create(tableName, ntc);  return true; } catch (TableExistsException e) { return false }
As mentioned above, why don't we making it a non-static method?
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
final float sleepDuration = (int) ((double)  feels odd.
No need for super()
calling super not needed
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
nit: can you put "File connector started" instead?
Minor: This message would sound alarming in logs. Possible to add more context here about what might be wrong?
Don't use logger in shutdown thread, as the call sequence of shutdown is unknown, hence the logger can be stopped already, using the logger after it stops might throw exception.
spaces on empty line
Do it simpler:  java bind(OkHttpClientSupplier.class).to(DockerOkHttpClientSupplier.class);
As you added AzureComputeService you need to bind it in the ContextModule with something like  bind(ComputeService.class).to(AzureComputeService.class);
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
Maybe we can compare the whole object instead of just checksum?
consider to get the qos and verify that it's the correct profile.
this.id -> id
This doesn't need to be prefixed.
You can still implement the interface here.
Don't really like the return null - maybe throw an exception if no main is defined? Or pretend we have a no-op main method?
If nextIs() would have an boolean return value, we could write this as: return nextIs(Opcodes.Return) Could also be used in other existing filters.
Can be simplified to just return XPathFuncExpr.toBoolean(relevance.eval(ec))
<LINK_0>
I continue to think that **aifc** should to be here...
Can use the already defined Constants
So... what's the purpose of this...?
@fuss86 it seems that previous implementation not assumed to return null, is there any reasons to do it now?
please throw at least a runtime exception here
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Which type would be assigned in this case?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
Can you synchronized all public methods (to make this class thread safe)
Maybe just throw unsupported since this isn't used.
do we need negative mark here?
these arrays could be static finals. That would save allocating new ones all the time.
This method doesn't need to return anything. When completed, the connection should be considered 'closed'.
Are these methods part of the upgrade?
I think the cloudera navigator is not integrated to the distribution. If this is the case, please change this boolean to false.
Inside finally?
Since I already have implemented allOf in CfUtils, it had better to use it:  return allOf(futures).thenApply(x -> futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()));
Don't need separate handling since this isn't adding any extra information. Should also try/catch around ehClient closes.
no public
StringUtils.hasText(name) && StringUtils.hasText(groupType) ?
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
Exception is never thrown
Exception is never thrown
keep requireNonNull
typo: of -> or
ow, this could be dangerous. We need to bluejeans to discuss.
The two last instruction should be in the abstract class as the two fields belong to it. Here we must have super(set, parent, selection); only.
return (splitTime < fTime + fDuration ? new TimeEvent(fEntry, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) : null);
Passing messages would be helpful to understand
Same it's 1 field.
A sanity check like the one in isFullMajorCompaction() that checks if scope is majc would be nice.
this should be true when index == 0 to allow optimizations for this particular case.
Geometry is comparable?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
can we split this into multiple lines and add tab support?
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
dont think a setter type function should return the "this"
completedPositions
oldValue should never be null; otherwise the merge function wouldn't be called. So, just use a putIfAbsent?
Not sure whether this will work, If it does, do you think it makes sense to just clear out the offsets for the partitions that got reassigned, This way we will still have checkpoint state for the partitions that didn't get reassigned?
what it calls on partition seems questionable
method reference
nit: you could add .map(Math::toIntExact) instead :)
Do you need IntStream here? It looks like you could use Stream.of() as do you for the string data.
ChannelClosed needs to be added to (though not strictly necessary)
Unsigned types are not used in the current implementation. So, you can omit them.
This list needs to include soul lantern.
Perhaps a CloudDataNode should have the same support for http2 that AmbryDataNode does, since it corresponds to a VCR which will eventually support http2 transport.
could this be 8? the size of a char?
Suggested getClass().hashCode() as something "more random"
No need to call super() since it currently doesn't extend anything.
no need to call super explicitly. Any construction implicitly always starts with a super() call (unless it's a this() call to another construction).
Do we really need this? It's implicit
I'd rather pass down the auth information to the QueryLifecycle. There's no harm in checking it twice, if it's good enough for Santa Claus then it's good enough for us. Checking it twice should also allow us to get rid of the no-auth path in QueryLifecycle, which would be good. Perhaps a good place to stuff the auth token is the PlannerContext.
Should this be implemented?
why is this return null??
I don't think we ever use this method again
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
This line may get logged a lot of times in a production system when s3 select is enabled, no? (when I trace it, it gets called from HiveSplitManager.getSplits()).
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Why do we print a secret systemUserPassword here?
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
This is not really a deprecation, right? We're changing the behavior (ignoring the setting and advising them to use the requires-reply). I think I'm ok with that, but maybe we should log a WARN and refer them to the migration guide???
Shouldn't we rather throw UnsupportedOperationException() in this case? Or rather create interface without the support and extend it with interface with these methods?
I'd add a static import for all those UIManager methods to reduce code verbosity.
there is no other (more elegant) way of getting article name
Is there a need to have both asserts? The reason I'd prefer only one is that I don't want the user to get one error, fix it, and then get another. Since nonNull is implied by hasText, we can give the user only one error message that will repair both problems.
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
should be mItem
that class would be better with a builder, though I wouldn't ask changing it now
You could use shortcircuit evaluation to avoid if-else block here:  return node.getChildren().stream().anyMatch(TableWithoutHeaderCheck::isTableHeader) || node.getChildren().stream().filter(child -> !isTable(child)).anyMatch(TableWithoutHeaderCheck::hasHeader);
per [html spec](<LINK_0> caption can only be first child of <table> element. We don't need to recurse through all children. (you can also update RSPEC of the rule with this)
Return from method Details at object that you found , and in place check for not null
nit: can we use a Executors.newSingleThreadScheduledExecutor() and .scheduleWithFixedDelay(...) instead? Feel free to ignore, not sure what's the idiomatic way to achieve this.
As mentioned above: do not introduce unreadable variable names.
Oh dear, I'm sorry, there's a change in it that I made for testing. Could you please undo it?
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
Consolidate this method with its coordinateStringsFromQuery implementation method.
nit, Collections.EMPTY_MAP?
if clusterAdminHost is null, this will get ugly. It should throw not supported exception if clusterAdminHost is not set.
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
@dalifreire this doesn't throw IOException anymore now, you're just creating a stream on a Strings bytes :)
I seem to recall this is not safe. Don't you need to use an iterator to modify the collection while iterating through it?
Best practice: Handle RuntimeExceptions coming from implementations, suppress and log them. Otherwise one plugin can break all other instances && node replacement flow
that seems reasonable. id might not be null in future, maybe better to filter based on INITIALIZING state (or either, i.e. that or id==null triggers exclusion)
Can you please remove the non-vm networks from networks? Maybe removeIf would be nice.
As I understand the code, this method ('initNetworkList') should be invoked only in case the selected 'dc' was changed. In this case it makes sense to re-initialize the network list (and seems your code is breaking this logic). I don't know what causes the bug, but you have to discover why this method is called after the 'dc' and the 'network' were selected (and I guess no new change to the dc was done).
this call can be removed. simply remove line 51-54 and 62-63
not null check would be nice here
You are not using getExceptionListener here.. is the test really duplicating the issue?
We needn't pass in null here, we could call the no args constructor.
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
Read into T v
java T v = defaultValue; if (v != null) { actual.onSuccess(v); } else {
I think we could have a better abstraction here for the list of possible values for a variable. We could consider this improvement for the next iteration.
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
Is it guaranteed that the first entry in the list will be the latest?
This is not the same error message. Frankly, I prefer this one (NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK) since it's more verbose.
Add here validation of isBackupDomain which you added in the storageDomainValidator
it will be more consistent and better conceptually if this whole test would be a single call to something like: validator.physicalNetworkProviderIsValid()
Return from method Details at object that you found , and in place check for not null
Would the code be cleaner with  DetailAST node = lambda; do { node = node.getLastChild(); } while (node.getLastChild() != null);  ?
There is a map.containsKey method to check existence. What if a value is null for a specific key?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Use Camel's ObjectHelper - org.apache.camel.util.ObjectHelper#isNotEmpty
Please change to externalSearch =
Missing an isEmpty check
Missing codes.
do we want to have actual percents? not rates as everything else is in Picard?
Really?
you shouldn't need to cast to double here
public ByteBuffer reset(ByteBuffer input)?
@essobedo use InetAddress.getLoopbackAddress() and remove throws IOException
minor: this not required
Better not call toList(). That will copy all elements into a list, losing the benefits of lazy loading each page. Not a big deal in the tests, but let's use pagination properly (this also serves as example for users).
The jclouds fallback always returns a list (or an empty one). Should we better add some assertion to verify that the list has the expected elements?
Should also be some assertion to check the "contents" of the returned set?
response = instead of return?
response = instead of return?
response = instead of return?
This adds the caps a second time.
This whitespace change looks incorrect.
I think Local.ROOT is probably a better choice.
Coding conventions: Let's have the @Override on its own line please
is volumeName optional parameter?
Since Platform doesn't provide a YAML deserializer, I'm okay with this test being a little looser, but it should still fail if, for example, this returns JSON instead of YAML. Do some sort of spot check, like TestWadlResource.testGetWadl() does.
Why exception handling removed ?
As far as I can see, namingContext is never assigned, so this check is pointless.
can't be null?
defensive copy?
Would prefer to store the quark as a member of this class and keep a getQuark method.
This is good, but it is not a true defensive copy. If I give you entryIDs then change values, you're in a world of annoying debug.
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalInstance?
I generally like to have singletons to be synchronized. ClientPrefs is only instantiated in one place anyway, and that's single threaded, so this is more of a nit.
I guess _getDataSetQueryHelper_ is duplicated here?
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Tests should never suppress exception but rather propagate them or use an ExpectedException rule.
Lets maintain the original ordering of fields: defaultNamespace, sharedTriggers, namespace. Same for constructors etc. to keep the diff smaller for generated schemas.
Ok, I see why you want to pass in null. But instead would be better to have a super constructor that takes just class, so if someone calls the other constructor with a null entity instance we can fail fast.
it's better to do this(clazz.getName()) here and get rid of this DEFAULT_LEVEL constant, being used only once
this(clazz, Collections.EMPTY_LIST)
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web socket service component is available"
Is it necessary to make this an info log?
Assuming this is noting completion of initialization, perhaps "Finished initialization."
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
Very optional but consider: viewPager.setCurrentItem(Math.min(viewPager.getCurrentItem() + 1, viewPager.getAdapter().getCount() - 1), true);
Move this common line to setUp.
why not use a constant for that?
Since split returns an array, it shouldn't be necessary to manually assign elements? Just assign the whole array since it will always have length 2 here? java splitArray = layerName.split(":", 2);
Missing codes.
The constructors should be package private
we still want to remove the object here and not let that be up to the observable to do so
Ah no, I didn't think. It's of course possible because we're removing the same instance and equals therefore works...
That is not necessary anymore as your other PR got merged already.
That is not necessary anymore as your other PR got merged already.
Probably better to use .getText().isEmpty()
can we add a message to the result if it is stale request something like result.stale()
change
Create an overloaded method isAdministrator(username.getUsername) and refactor the existing method to call that for string based parameters (other methods in GoConfigService follow this pattern method(CaseInsensitiveString))
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I would suggest using ConverstionPatterns.MAP_REPEATED_NAME here as well.
computeIfAbsent
Why don't you instantiate the builder here?
That can't compile anymore.
I'm surprised the server doesn't already do this.
Shouldn't the cache name be the same as in the standalone.xml (spanChildren)? It may not matter for local cache, but if we decide to change the cache configurations, then it may be necessary to match up with the config in the standalone.xml.
to be consistent we should introduce constant for kmodule.xml
spurious change?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
why is it necessary super here?
collect toImmutableSet then there is no need to use ImmutableSet.copyOf, static import. Add new line before .map and .collect.
doc
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Please change this to VAR__ACTION__DISABLE
Since the "TYPE" describes the target of the action, the "ACTION" should just describe the action being performed i.e. I think a better name for this enum is VAR__ACTION__START_PROFILE (excluding _VOLUME_)
It seems that the HotPlugUnplugVmNic Command is being used for both Plug ("Activate") and UnPlug ("Deactivate") actions. Therefore, I think that the ActionMessageParameters should be set according to the "Action" property within the HotPlugUnplugVmNicParameters class: If getAction() is PlugAction.PLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__ACTIVATE" message ("activate"). If getAction() is PlugAction.UNPLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__DEACTIVATE" message ("deactivate"). [worth consulting with an engine-core maintainer about this]
specify array length (based on codecs.size) to optimize. <LINK_0>
Consider returning a constant
this method should probably be final. Also it is missing the @Override annotation AFAICT
style nit: we don't use braces around single line blocks
can this be a method reference?
Since we're now using bus events, do we need this anymore? (The whole idea was to send events to individual cards, and avoid having to rebuild the whole view hierarchy of the RecyclerView.)
Restore to original. Also apply to the other similar throws.
typo
More user-friendly to say "', only Switch, Number, Dimmer, Rollershutter and String items are allowed - please check your *.items configuration"
It is generally bad form in Java land to modify the fields of another class directly. You should do this via getters and setters. While this introduces boilerplate, it makes for more extensible code: maybe you want to synchronize your setters across threads, maybe you want to cache computations and invalidate them when a setter is called, etc. Most importantly, this is convention: readers of code will not expect for class field mutations to occur outside of that class, and not look for it when they are trying to understand the code.
Is this change intended? Also, avoid using magic numbers.
@datang1992 another thought, just do 0 to x (where p(x) is close to zero).
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
Log the exception to error.
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
You can remove braces.
add "domain = null;" to avoid problem at super.tearDown()
See if you can change things like this to just return "Invalid response";
It would be good to change this to private
![MINOR](<LINK_1> Make "trimPropertyName" a "static" method. [![rule](<LINK_2>](<LINK_0>
public?
I'm missing the new field in the toString method.
add this selector to UI mapping at the beginning
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
looks like directory separator is missing here
It is a good practice in Java to avoid combining many function calls on one line - if an exception is thrown (e.g., a NullPointerException or IOException), the Java runtime will tell you the line number, but you won't know if the exception was thrown by logger.info() or by execShellCommand() or by mzMLFile.getAbsolutePath(). It is much better to split this into separate code lines, each line performing one function. Again, it also improves code readability.
Should check that the environmentTracker is not null
uuid can never be null here because if EntityPlayer.getUUID(player.getGameProfile()) were to return null you'd already get a NPE in line 44. Maybe use something like java UUID uuid = EntityPlayer.getUUID(player.getGameProfile()); if(uuid == null) { uuid = EntityPlayer.getOfflineUUID(player.getName()); } if(uuid == null) { CrafttweakerAPI.logError("Could not get UUID for player " + getName()); return ""; } return uuid.toString().toLowerCase();  Also, since I don't know these vanilla methods that well, can player.getGameProfile return null, and if it can, will getUUID(null) throw an error?
rename to contribution
Remove timer.
minor: you can use == here since it's an enum (or change the == RestMethod.DELETE to .equals(RestMethod.DELETE) for consistency)
make line 112 an else if?
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
suggestion HttpServletRequest req = (HttpServletRequest) request; String lengthHeader = req.getHeader("Content-Length"); if(lengthHeader != null && !isSizeWithinBoundaries(lengthHeader)) { throw new MaxUploadSizeExceededException(multipartConfigElement.getMaxFileSize()); } chain.doFilter(request, response);
again, this cannot be, there cannot be unconditional chaining... the nego should be able to stop the chaining, please see current implementation of nego.
Make this private and implement a builder?
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
needs filling in :)
I would suggest to let this test failed with some unimplemented exception. Or at least ignore it. Otherwise it will provide the false assumption that it is implemented and working.
Should be removed if empty
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
suggestion return (map != null) ? HashMultimap.create(map) : HashMultimap.create();
Don't we have to say that this is uniqueId JDBC?
can be simplified to  java EnvInjectPluginConfiguration.all().get(EnvInjectPluginConfiguration.class)
local var is no longer needed
I think the default should be there is aggregation. Same as in runMultipleAction.
Here as well, I think the two calls to this method can supply an element id.
It is a good idea to add all releases in a finally block, so that we never lose permits.
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Any pointers why don't we just throw recreate() exceptions as is? Looks like all other places don't care about exception wrapping
This could be combined with the previous line.
setErrorMessage
we probably don't want return true here, also log message is misleading and maybe we should distinct scenario with stale message from no topic info
Synchronisation could be avoided in this method using computeIfAbsent and AtomicInteger, but not sure if it is worth changing at this point because I don't know the performance impact that full synchronisation is having.
That is always false. You should check if start + count - 1 flips to negative.
suggestion this.dataStoreMap = new IdentityHashMap<>();
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
how about:  if (Types.getRawType(type).equals(Optional.class)) { if (response.status() == 204) { return Optional.absent(); } else { return Optional.of(delegate.decode(response, getInnerType(type))); } } else { return delegate.decode(response, type); }
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
Maybe this should be getOrDefault to avoid null returns.
Should we log the potential error?
same as others: log should have Exception as arg
We should at least log those exceptions.
Please place a space b/t if and (. if (variable == null) Please check others as well.
return Optional.empty instead of null
For assignment statements, as I understand it we shouldn't raise on class attributes:  class MyClass: max = 42 # OK  I'd suggest looking at the first ancestor of the assignment which is either a FUNCDEF or a CLASS and avoid raising an issue in the case it's a class.
getparentDiagram() will be null.. you have to set the container before calling the method.
Symmetry (throw)?
Multiline this annotation, it's too long now.
Shouldn't the return type be int?
spacing, code style
and the array would be of size 3 if it did...suggest to use a bytebuffer
Please remove the protected keyword because this class will never be subclassed.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
The one-argument constructor can just be called here instead: this(true)
no need for explicitly using 'this'
minor: this not required anywhere.
I am not following here - why do we want this in sync block?
We're checking event.error != null twice here - but we can actually drop this entire line, since event.isError() above is actually a event.error != null check.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
Just remove the try/catch. An exception will fail the test.
nit, add as for each assert please, can be as simple as java assertThat(supplier.get()) .as("TARGETED_SWEEP_ENABLED, BACKGROUND_SWEEP_UNSET") .isFalse();  etc.
assertThat(info.files).hasSize(2);
Can you move this out of the method and make it private static final char ZIP_SEPARATOR = '/'?
Here return getName + '=' + formatNumber(getValue(), base); // trailing space it would be nicer.
Is there a reason this format call was wrapped in a StringBuilder instead of adding baseUrl and context in the original format string?
There's no reason to use a mocked File here. If you want to create a file for test and not worry about clean up etc you can use [createTempFile](<LINK_0>,%20java.lang.String,%20java.io.File)).
That could be null ;-). Also note, that Text uses compact assignment.
Should this exit after finding the first visible widget that can be focused?
Can I suggest the following to be more consistent with the other code in this file? It's more or less equivalent to what you have: java return File.createTempFile("swarm-client", ".pid", temporaryFolder.getRoot());  Since this uses a different name each time it's invoked, we'd need to pull it out into a local variable within each test, to be passed to each Swarm client we create.
Perhaps rename the temporary directory as well
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
This directory should probably be defined in a common place so if we want to move it to another location it is a single update
use FileUtils.createNewFile() instead in order to check return value
This is wrong. Even if filename ends in .zip, you will end up with something like this:  $ jrunscript -e 'println(java.io.File.createTempFile("foo.zip", ""))' /tmp/foo.zip6023275810588304403
delete
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
let's do it using lambda approach
let's do it using lambda approach
let's do it using lambda approach
use existing constant
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
path.endsWith('/')
I don't see where we handle HibernernateException.
Session shouldn't be null
possible NPE here if getSessionsForCluster() returns null
This can lead to NPE, better to swap the check.
Similarly, EqualsUtil might be of help here.
Generally, I let eclipse generate this kind of code for me. My version of "old" version of eclipse use this pattern : java if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false;  Is there any reason to change the code like this ? (I'm just curious and I have no objection to change it)
How about removing the whole cluster deleteRecursively("/CLUSTER_NAME")?
Can you share why we need to unsubscribe all here?
This toString() is used when printing the query plan. We probably don't want to include the partition values.
We should return true here to ensure the menu is displayed.
this line doesn't do anything
Variable not used; please, remove this line.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
Frank, how about we change this to "throw new CoreExcpetion(convertHtmlErrorToStatus())" and extracted a method out of parseHtmlError that returned a status.Then we wouldn't need the extra CoreException (which should never be thrown).
Camel can do this automatic in the setProperties(configuration, parameters) you do further below. If you want to set default values then set them on the configuration class instead
This shouldn't be done, we just need to setProperties on the endpoint, so the second one should be sufficient, take a look at the other components.
I think would be better to follow other components on how to set configurations, meaning that to configuration properties mutable and let Camel do the job of binding the parameters via setProperties(configuration, parameters);.
Make this protected (and in the @Overriden)
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
similar issue here. remove validation in client
we should not validate the hashtoken on client since we don't know the system password.
Make message more clear
that seems a wrong junit exception usage. test shouldn't suppress exceptions, it need only configure exception (that is Rule).
This shouldn't declare throws Exception.
needs filling in :)
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
I think you should check that this is non-owner connection, don't you?
Extract notification to own method notify...
Extract notification to own method notify...
we probably better to make another MavenArtifactUtils method for this.
Docs here to please. I understand what you're doing here but given that they are public static methods it looks like "api" stuff
Don't use + string concatenation if you already have a StringBuilder! Do append("reference=").append(reference) instead.
You are using Toaster everywhere in this class except for this message. For the sake of consistency, use the same class here as well.
change to charge_created_successfully
We have ToastUtils class which we use for displaying toast so we should use it here as well.
Ah, OK, that would be clearer.
Would it make sense to org.jmxtrans.agent.util.io.IoUtils#closeQuietly(java.net.URLConnection) and ensure that the connection is returned to the http connection pool?
The error message doesn't match the actual behaviour.
I think the most likely case is that fboName is not the default frame buffer. But it's a very minor issue, so let's leave it as it is.
Doesn't this generate an error? fboName is private. Maybe this is a quirk of java I don't know. In any case I'd implement a getter so that we can write: return this.fboName.equals(((SetViewportSizeOf) stateChange).getFboName());
fboConfig I presume - without the s
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
why is this unsuccessful ?
this should be true when index == 0 to allow optimizations for this particular case.
These checks would work better in PartitionHandlingConfigurationBuilder.validate(), logging warnings if the merge policy is ignored. Although I'm not sure the numOwners > 1 check is really needed...
I'm missing the new field in the toString method.
Can this be private, or is there another use case for default attribute outside the builder's call?
latest from today's discussion: return URL
this.url = checkNotNull(url, "url");
if you're gonna rebase this patch, please consider dropping those this. prefixes from getters.
I would recommend an else if here to avoid comparing against a string unnecessarily.
I think lowercase l should also be considered
I am lost a meaning of private AbstractNode[] attributes; you place ident or value in this collection but in the same time keep them separate in special fields. What is a reason ?
You could maybe use enclosingClass to save a few hops...
PLease invert operande
element != null is useless
Oh yuck. ;)
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
You might want to not over-complicate it and keep the toString of the Optional perhaps?
you could have this all in one line
openArticleByName is accesible from article object
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
this should be catch (Throwable t)
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
One more empty catch(){}.
Note that this array will be bound by Integer.MAX_VALUE. Or maybe it will crash, I'm not sure.
outlineInfo.textEditor can be null so should be checked
Perhaps a CloudDataNode should have the same support for http2 that AmbryDataNode does, since it corresponds to a VCR which will eventually support http2 transport.
This seems like it will cause problems for BamReader.queryUnmapped()
PDOMCPPFieldTemplates should store their field position just like PDOMCPPFields.
is this toConfigurer needed as a variable?
personally I find the combination of of() and put() weird. new MapBuilder().put(...).put(...) does not leave readers to wonder.
this might be too brittle in the future; probably fine for now though
Would it be better if we add a logic to check whether the actionMode is null or not to prevent resetting the state of toggled items? if (actionMode == null) { beginRemoveLanguageMode(); }
it is possible that getItemAtPosition returns null -> sure NPE here
This should return T.
Minor nit : Can we have uniform naming for similar methods? This one should be updateExportedFeedInstance...
I get that standbys should never really be in RESTORING state, but it still doesn't seem like it's philosophically any more illegal to suspend from RESTORING than it is from RUNNING. I'd vote to legalize RESTORING here. It does seem like a useful sanity check for CLOSED to be illegal, though.
nit: no need to hyphenate unrecognized.
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
If the arg isn't modified, you can use Collections.emptyList() to avoid an allocation here suggestion writeReport(output, Collections.emptyList());
byteOutput.emit(tuple.getBytes()) ?
I don't quite understand why this call is needed. If LazyBlocks are not loaded, the data is not read, hence no stats to update.
should this be synchronized?
Again, more useful error message please.
I think the SystemReader should server this cache instance. With two static instances, there is a brief interval in which this cache instance will be the old one while the SystemReader instance will already be the new one. Might be simpler if the two methods getSystemConfig() and getUserConfig() were on SystemReader, without this separate class.
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
How about exposing this as part of Metrics?
This needs to return a completable future, not null
This won't evict the cache since the call isn't made through a spring bean proxy but directly within the class. To make this work, the service needs to have itself injected by @Autowired and use that reference instead
Dtto.
I think its better to if (isCopyPerms()) { execInTX -> save quota copy perms } else { save quota } and remove the check for isCopy... in copyQuota method
how can this be null? isn't there a check in the canDoAction to block this from being null?
Why don't you use other method - the one without compensation?
new AcceptAllValidator<String>()
Here should be NOT_INCLUDE_DEFAULTS
I'm not sure how much value there is in distinguishing these two cases. It may be simpler to just have a single function, assertEvaluationIsError(), which checks for either.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
please decrease log level to trace or better remove statement
remove
please decrease or remove this statement
Add message to new RuntimeException
wdyt about IllegalState + descriptive msg?
consider catch(Exception e) { throw Throwables.propagate(e) }
SymbolReference is an issue
Map<...>
put this to the first line.
"This method is not actually very useful and will likely be deprecated in the future."
can this use the MMX StringUtils functions?
maybe test first char for empty letter as well to reuse s if possible?
put method contents into private method with WebElement parameter
- [x] Why need this? Please re-consider based #768.
cleal ?
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
Should maybe other countries be added here?
@Nadahar Right, text/vtt, i was too fast...my bad.
This one needs to have context so you will need to have a method that takes an Integer object and a Character object.
In this sample the use of brackets is not consistent. Maybe use always brackets?
Wondering if we want to included more information about the locks, say the size of the maps, the size of the reaper queue, maybe the versionIds. This now just logs out your configs which should be immutable representations of what is on disk. If you're going to update this, may also want to consider not returning a Builder, feels off.
why do you call this? It will be called anyway by default.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
do we need to return the whole stack as the result? that seems a bit much to the user. how about just the message as before and log the exception?
Maybe we can compare the 2 images to check that this is the correct one?
better use Strings.isNullOrEmpty(item.getLargeImageUrl())
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
It seems strange to deactivat errorCatch here ...
Please use a better name (primaryKeys, primaryKeyColumns).
Can throw Exception from tests.
Instead of removing "bbbb" which is the longest element so won't have trailing spaces, try removing "a" or "c" as it's a better test.
line more than 100 chars, plz follow the code conventions FYI: <LINK_0>
Which one?
I continue to think that **aifc** should to be here...
Can use the already defined Constants
Should maybe other countries be added here?
do we need to synchronize on 'this' or can we have a lock?
Is this really needed? There is a chance that there are two HTML elements with the same id in the DOM.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
requireNonNull
Why do you wrap here unconditionally, why there is no isValueNode() as in other place?
Can you add a CommonHelper.assertNotNull("delegate", delegate); check?
If we catch all exception here we should at least log something otherwise it will be hard to find the issue if there is a bug.
I don't know if this is the correct operator, what if there are multiple instants? .single() would throw an exception if there were more than one element.
Remove log message
Why do we return the parents name instead of the name we store a few lines above?
please also add the GUID which is important.
Let's please avoid code duplication:  public String toString(boolean shortenTypes) { String type = getType(); if (shortenTypes) { type = shorten(type); } return getName() + ": " + type + " = " + getValue(); } @Override public String toString() { return toString(false); }
Should this be Block?
This could also be chained.
Why do we have different checks in these two tag methods ?
suggestion if (DEBUG) Log.d(TAG, "savePlaybackState() called");
this log seems useless, remove it
shouldn't we protect forkJoinPool accesses as it is static and shared between all ProActiveFileObject?
nit: either use this. for both assignments here, or for neither of them. Consistency is good :)
you could just do setConfirmWindow(null); like above method
style nit: we don't use braces around single line blocks
(purity alert) This two can be written inline
I would not put this method as an example. This API is just... not possible for me. It looks more an error than an API. Is this used by users @wfink ? If 'not really', for me we should remove it from here IMO This API of creating caches at runtime should be changed and I mentioned in the thread in zulip @tristantarrant @wburns
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
remove mRoles
name can be null, causing compareTo to NPE if its on the wrong side. In these cases maybe treat the name as though it was "".
None of this stuff is atomic.
No need of this..
Shouldn't you add a inQueue = 0; here?
Can summarise to two lines: java WebElement sessionRow = waitForElementPresence(By.id("session" + getEvaluationRowId(courseId, evalName))); verifyElementContainsElement(sessionRow, By.className("session-resend-published-email-for-test"));
Can summarise to two lines: java WebElement sessionRow = waitForElementPresence(By.id("session" + getEvaluationRowId(courseId, evalName))); verifyElementDoesNotContainElement(sessionRow, By.className("session-resend-published-email-for-test"));
Should be modal instead of in?
It doesn't feel right. Why it is required?
Should dispose/clear the PageRegistry and set the field to null.
Might be also in finally?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The result variable should named as result
Extracting the results of the getHeaderParameter() calls to local variables should make this easier to read.
"may" -> "must" "may" means that it's allowed to be empty.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
possible NPE
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
I think your change works. Great. But there are optimisations I would suggest. If you have the array files in hand you have already all information in hand to detect orphans. No need to do again the expensive filesystem calls (the .exists() calls) in the isOrphan method. I would: - I would use the DirectoryStream with a filter for .pack,.index,.bitmap files as Matthias suggested - I would sort the stream to ensure packs come directly before corresponding bitmap/index files. Then it is easy to detect orphan index,bitmap files (if they don't follow directly a corresponding .pack file)
child
Would file.getName().endsWith(".java") work OK? And I guess if the case is a concern, maybe file.getName().toLowercase().endsWith(.java).
Same argument as with the DeadlineJob.
I think it is possible to simplify parsing by using date format "yyyy-MM-dd'T'HH:mm:ssX" and not replacing anything.
I think we should remove thread synchronization from here and let the client code handle it.
That's not very clear: if doResolve does return null, it most likely means that the CodeMining doesn't require resolution, so isResolved should be true. The implementation seems erroneous here. This may be caused by resolveFuture == null which can mean 2 different things: either the future wasn't requested yet, or the future was requested and null was returned (ie no resolution required). I believe you need some more details or another state variable in the class to distinguish both cases.
Collections.addAll saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.
can be replaced with: TokenUtil.findFirstTokenByPredicate(...). I think this could be simplified. java node -> { int modifierType = modifier.getType(); return INVALID_FINAL_COMBINATION.contains(modifierType) || (TokenTypes.ANNOTATION == modifierType && INVALID_FINAL_ANNOTATIONS.contains(modifier.findFirstToken(TokenTypes.IDENT).getText())); }
Can we change this line to this(0) and remove the if (port == -1) in the other constructor?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
give the thread a name by using Executors.newSingleThreadExecutor(new ExecutorThreadFactory("the name you want"));
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
The "includeRequired" parameter (the last boolean before ctx.getStartIndex() should be ctx.getIncludeAll().
Assignment not needed, immediate return from constructor is enough.
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
Get it from the model now that we have one?
Shouldn't have to specify the <SymbolProviderFactoryWrapper> here, copyOf() is smart with those things.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
@since (can just use TODO as the version string as a placeholder to remind the merger)
Why do we need this change?
Not sure if you noticed, but you can use a different notation here: suggestion return Optional.of(path).filter(Files::exists);
You could reuse the method in FileUtil here and above  List<Path> fileDirectories = database.getFileDirectoriesAsPaths(preferences.getFilePreferences()); return FileUtil.relativize(filePath, fileDirectories).toString();
I would create a private static checkArgument method for these checks
This test probably doesn't do what you think it does, because it verifies that EXT_ID matches with itself. (Same with several of the subsequent tests.)
nit: instead of the boolean here, would be better to use an enum (would make the test clearer) or two methods runSslConnectionTestWithoutClientAuth, etc.
What about the following cases? * External ID validation required, but not specified? * External ID specified, but validation not required?
you could just do setConfirmWindow(null); like above method
Is it really worth checking before setting it?
This function seems like a good candidate to return an Optional
Make this java fail("expected exception");
throw exception
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
java if (mapperReference.isUsed() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) }
You can use the size of the fields as an initial size for the list
Use LinkedList instead, as we need to remove its head frequently in endInput.
What is the need to make issueArticles nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference.
Issue.java  public Optional<String> getProduct() { return Optional.ofNullable(product); }  _issue.getProduct() != null_ is unnecessary, it returns at least an empty Optional if _product_ is null.
This should be rewritten to just change the key depending of filterAnyRule.
... && tableName.getTableName().length() > PARTITIONS_TABLE_SUFFIX.length() ?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
Spelling
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
LOST doesn't mean session lost. It only means that the retry policy has given up. Is this your intent?
return HConstants.EMPTY_BYTE_ARRAY; ?
Can you change to static variable ?
need to add more information about dimension/index/length
You don't need this line because of green 31.
You can use Layout.INVALID_CLUSTER_ID
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
are these setters used anywhere?
Please make the constructor private (see Invalid).
Why not in combination with above do this: setValue(value, false);
Can you elaborate when long type can be nullable?
Please throw unsupported operation exception instead, this dao is not used. We're going to get rid of it.
use Long.class as second argument in .createNamedQuery method, and please remove the cast
This method could be static since it does not depend on any local state. Same for hasCoordinatorMoved.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
Should we have isRefreshTokenInvalid() return true for any 400 regardless of what response.error is?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
you can use method getUrlForWiki (so you don't need to add empty string for article path)
When we will run this test on www.wowwiki.com it will fail. There is wgServer variable which we can use in this case, then append Special:Promote path to URL
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
Why do we need an explicit boolean primitive? .... using i.getRepeatable() does the trick
Use Seq now?
We can remove the unnecessary AnalyticsTracker qualification from AnalyticsTracker.Stat.QUICK_START_REQUEST_NEGATIVE_TAPPED to produce AnalyticsTracker.track(Stat.QUICK_START_REQUEST_NEGATIVE_TAPPED); for simplicity.
Why we want to fall through into the loading dialog in case of error?
I might have asked this already, but I forgot the explanation, sorry. Is it okay that we track EDITOR_POST_PUBLISH_TAPPED for all the actions (not just "publish")?
Filters are processed in the order of the filter-mapping definitions. I gave this a try and moved the new filter-mapping to be the last one:  HTTP/1.1 200 OK Date: Mon, 09 Sep 2019 17:23:30 GMT X-Frame-Options: SAMEORIGIN Content-Type: text/html;charset=utf-8 Set-Cookie: JSESSIONID=node0w4cziqnkjair1gkn4ojtsquwi78.node0;Path=/opennms Expires: Thu, 01 Jan 1970 00:00:00 GMT Cache-Control: no-cache Content-Length: 5519 Server: Jetty(9.4.18.v20190429)
why can't the schemes be hash from starters?
Why not just: java for (String msg : msgs.toArray(new String[0]))  ? No need to make a new ArrayList. Just the array.
This array must be calculated one time only
Add a check that the length of inner array of context#getKeys() should be 1.
Use cast(... as jsonb) syntax instead to avoid issues with subqueries that happen in older hibernate versions.
Use isZKLogAvailable() instead
why fully qualified name here?
Why delete this line?
iirc it's initialized in the ctor, check that it's not empty .
you already know that it is IMAGE, don't you?
no need for the if..diskimage is diskimage :)
Same - icsCode >= 1
I think you might want "icsCode >= 1". ICS means "Inherited Certification Status" (i think?) and it is not a boolean but a count of the number of times something has been inherited... so it can be larger than 1.
Any reason for using toString instead of getId these two lines? I prefer getId as it's more explicit.
lambda: () -> {}
While you're touching this... could be lambda-fied. Braces and newlines as you see fit:  source_.withSaveFilesBeforeCommand(() -> { withDevtoolsLoadAllPath(loadAllPath -> { sendLoadCommandToConsole("devtools::load_all(\"" + loadAllPath + "\")"); }); }, () -> {}, "Build");
createCache simply
This will throw redundancy warnings in IntelliJ
@ILikeToNguyen Why the change in visibility here?
why not null as value?
Use fluent interface in here
Maybe use a logger ?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Why we update our code with AND while the test case sql is with OR, i kind of confused.
Is this needed?
IMHO, what you propose is only a workaround. Users might encounter this error if he wants to merge the project in RelBuilder. Instead of changing RelBuilder#shouldMergeProject to false, I am wondering if we can find the root cause and fix it.
checkNotNull(value, "value")
And here. needs some validation.
If you're anticipating non-sponge implemented variants, you should throw an exception for a bad data transaction.
Can you call CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, symbol) instead?
return symbol != null ? symbol.qualifiedName() : "";
It is useless to test before marking as ignored, as only the symbol which are already known could be marked. Note that to be known the symbol have to pass the "isSymbolRelevant" test, which is equivalent.
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
should go to stdout, well, I would have put the stdin/stdout/stderr in context by core, but not that important for now. and again, all this can be acquire from the parser, so if we add new fields it will be available to all. all you need to do is print parser.getUsage().replace().replace().replace()...
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
feedback session's course ID -> feedback question?
JDBC
do the comparison the other way around
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
==
Is it not actually called a thread id in LTTng 2.0? Is it the same number when it is stored in context._pid ?
store the spanId in hexa in the ss, it will be less work and safer for other classes to get the matching open tracing span
Should this be represented as a Duration?
for the boolean parameter could be useful to use enums, so that it is more clear what it means
I think we can remove this line.
Will need to unregister()
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Should be in a finally block?
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
please remove this
A flip != 180 rotation
I think we should just use a lint rule for this. I assume we can't do it right away as there are probably some switch statements that don't have all the branches, but we could fix them and enable the lint rule afterwards. Even if this is the approach we decide to take, let's not make it a part of an unrelated PR and instead try to add it for each switch statement as a single PR.
Unsupported type:
I believe this should be typeList.size() != 1, isn't it?
this.
Could be suggestion return !selectedBaseResources.isEmpty();
Replace imgur.com
Replace imgur.com
Replace imgur.com with buttsmithy.com
Do we want the toString()= in here ?
update labels, add additional fields
labUrl needs to be taken out as well, and added in to SampleAdditionalInfoDto
An empty message is OK.
if (signed) is enough. We try not to compare boolean variables to boolean constants.
Is this really an internal exception? If the caller gave us a tag name that we won't accept as a reference name that is rather different than us encountering a form of repository corruption they cannot recover from easily. The caller just needs to correct their input. I'm thinking about the EGit UI case here. If the UI just passes through the tag name entered by the user, runs call(), we need to throw something that tells the UI it should backup and let the user correct their input. But if we got a valid tag name and crash because something goes wrong deep inside of the ObjectInserter, that's a totally different kind of error for the EGit UI to present to the human.
This constructor should call the more general one with a default value (3 in this case)
Can header name and value be null?
This cast will fail on any primitive array. e.g.,  java new int[] { 1, 2, 3 };
I would suggest to use the vector's getter methods to get the entryX and the entryY properties.
this should have a bounds check that throws if you try to set it to be < 0 or > bufferSize
It seems like the number classes in java 1.8 have BYTES size constants (like Integer.BYTES). We could consider using these here.
You need to check in the set\* methods that the custom attribute name doesn't clash with a common attribute name to prevent users from producing invalid XML. Throw an IllegalArgumentException if so.
Return the zone id here instead of returning an empty string.
Should this link to the course?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
It doesn't feel right. Why it is required?
Could this and the next logger statement be reduced to debug?
You should externalize the string
Should this link to the course?
Return the zone id here instead of returning an empty string.
Here it's used only once so it doesn't really matter, but you could have static defines for those, like private static final double NANOSECONDS_IN_SECONDS = ... would also prevent easy mistakes like one zero too many
having these getters here means they would be included as json fields. Since they are easily calculated, and not used anywhere else in the code maybe exclude these? (think two extra fields x 3000+ requests all in one json blob)
you shouldn't need to cast to double here
Use EnumDyeColor.byDyeDamage(stack.getMetadata()) - that's what ItemDye uses. This should fix what @Aaron1011 mentioned
Yeah.... this is functionally ok, but it's very wasteful. Just use traditional if (color != null) logic. It reads better.
You can use OptBool here.
Enforce immutability
we never use NULL, it is a bad practice in general.
Seems like it would be better either throw an exception or to let the user know that the bindingSetString was only being built using a subset of the variables in varOrder in the event that the variables in varOrder aren't the same as the variables in the BindingSet.
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
We should avoid this build check, can use support library functions where possible.
@chaviw check for extFile being null.
No, this. when you call methods.
IMO this should move to the presenter in the first place.. i.e. where you call view.init( this ) add the next line that calls if(this.canUpdateProject()) { view.enableAddAssetButton( false ); }
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
I'm missing the new field in the toString method.
I would change the text to say "The encryption algorithm is not strong enough."
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
@ILikeToNguyen Why the change in visibility here?
Looks good to me. Can we do something to identify other occurrences of this issue?
please add setSoftLimitInterval() setter and use it.
setSucceeded?
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Please use Optional.ofNullable()
why static?
This should be synchronized
Shouldn't it be "Source repo must be specified" when running go-build?
If I understand correctly, the purpose of the patch is to fix a specific problem - failure of migration because of 'refreshCaps' failure to take a lock. It is enough to take a waiting lock inside the ActivateDeactivateVmIntefaceCommand before calling the refresh, instead of locking the host for the whole migration period. You can pass 'lockProperties.withScope(Scope.Execution).withWait(true)' as the 'lockProperties' of the parameters you pass to 'RefreshHost' (the 'RefreshHost' should pass it the 'RefreshCaps').
Return value of the method is never used.
The isDiscardable method can be simplified to this:  java private boolean isDiscardable() { return !PostUtils.isPublishable(mPost) && isNewPost(); }
ah, I forgot that the primary key components are part of system.schema_columnfamilies, not columns, so that wasn't a problem.
what is the purpose of this test? Maybe renaming the test makes it clear
nit: as above for external, and entity here and below
How can this test succeed since ACCOUNT_METADATA_PREFIX has mixed-case characters?
I think the annotations should be on separate lines
I think we will have to discuss whether or not to include the fromKafka functions in this class.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
you should have here setSucceeded(true) IIRC.
Will need a @since tag.
No parameter in setter method?
Use the set in the class variable directly.
Type can be a stub, so it's definitely not a good idea to use getText.
I'm not sure you need to remove all of these static modifiers. Some of them are probably still valid (this one notably)
Won't fix.
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
do we need to use static on this private method? Please update javac doc
Looks like we don't need NotAliveException, AuthorizationException
if name is " " would execute the else clause suggestion if (String.isEmpty(name)) {
suggestion assertThat(got).contains("Description");
This line is not needed
Should the 3 contains be replaced by isEqualTo ?
FutureUtils.assertNoException missing
delete() should be executed from within the future so it doesn't through right away.
This should happen within the future
These asserts are not testing anything related to the webservices.rest module, they're just calling Obs.getGroupMembers(). You should be doing resource.getGroupMembers(resource.getByUniqueId("..."))
We can get rid of the above variable
Expand this a little, verify event request fields
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
I am wondering if we need to also log the hash of the refresh token. Technically, it is possible that the returned refresh token was bad and if this happens, we want to find the correlation id of the request that led to such bad refresh token. What do you think?
avoid having local variable names that have the same name as class variables
Shouldn't this be assertGreaterThanZero?
We normally add the static import when using matchers.
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
oh yea. A spy :)
Indentation should be deeper. These are easier on the eye (the break is less jarring)  java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {   java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {
As you already need to touch this file, I think this empty line could be removed.
As you already need to touch this file, I think this empty line could be removed.
You should handle volume only if you process the stream. So I will suggest to move your "volume" stuff inside the if just below.
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
order by clause must be added.
Please change to return (String) pair.getValue().getEntity() instead if reusing 'res' (it is more readable).
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
the topologyId is written/read in the ReplicableCommandExternalizer. no need to write/read it again.
uuuf... each of the Class instance is probably serialized to a FQCN-long representation, that's easily 50 bytes. With 2 classes and 2 wrappers, this is 200 bytes per command. Isn't there a better way?
inline permissions and then remove redundant this
Can the filteredHeaderNames be put into a case insensitive TreeSet? Then this nested loop could be converted to a contains.
In Sunrise we follow the rule that unless a parameter is annotated with @Nullable, it can't be null. Therefore this line of code is unnecessary.
Please add a check here that would simply return if the color being set is the same as the current foreground color (linkColor).
I would prefer to add a finally block to the try/catch, and close the cursor there. This would involve moving the declaration of the Cursor object outside of the try/catch, but is a much clearer model. Same for the other file. Also, please prepare the PR against the dev branch rather than master.
What do you think about changing the return type here to the enum ArrivalFilter? Seems like a conversion always needs to be done anyway, so we might as well do it here.
Similar to the other tests, assert that a feedback response with ID "randomNonExistId" doesn't exist.
Unnecessary line move
suggestion ______TS("Instructor attempts to edit student's response, but without appropriate permission, "
same thing, while you are cleaning, other thread could store other key.
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Doesn't look like clean API. What's the use case of this?
As far as I understand, we can get rid of explicit type parameters is such calls
Use LinkedList instead, as we need to remove its head frequently in endInput.
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
I am not following here - why do we want this in sync block?
The same DEBUG concern is here, too, for otherwise
Assuming we return an empty set at least twice, consider having a private static method (e.g. nobody()) that would help finding such cases across this class.
Given we're removing the only reference to the presenter.moveDown and the presenter.moveUp, it's important to remove these methods in the presenter as well and the related to code, to finish the clean up.
Fix the prefix, should be impl$.
this and m_ is redundant
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
is there a reason why this method isn't implemented?
So this will be used for quantity and duration too or you need separate ones?
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
shouldn't we perform cold reboot for volatile runs?
should be !archSupportSnapshot, right?
Please, reuse your extracted method for checking if a file is an Erlang source file.
nit, Collections.EMPTY_MAP?
This will throw redundancy warnings in IntelliJ
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
Not good to use Optional for collections, just return empty collection
Based on how it's used, it's more like a listener not callback.
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
Use TreeMap to keep the order.
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
My bad, I meant to say: "to be able to **change** the page source". I will improve this exception message.
public?
Can this be private, or is there another use case for default attribute outside the builder's call?
@idelcano What is going on here? Take a look at these lines. Too crazy to merge it :)
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
This new line doesn't make any sense, should be removed.
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
Is order important here? Should the 2 collections correlate each to another?
I think Local.ROOT is probably a better choice.
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
You may want to add assert size - toRemove.size() >= 0; (my genIntellijRuns task enables assertions by default)
I believe this should be typeList.size() != 1, isn't it?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
They are mutually exclusive? Or is that a micro optimization?
The 'if' check isn't needed here, right? replaceAll will only match if these are true?
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To save changes you need 'Push' rights on " + REF_CONFIG"."
"Timeout waiting for the validation of keys: " sounds a little better to me.
is this necessary?
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Maybe 'cluster.hasRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
what if cluster is null?
why do you need/force "dataCenter.name|id" parameter? you already in context of DC.
Please remove " to access OpenHab"
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
studentsWhoRespond -> studentsWhoResponded
return tags;
Why can't you just return this.workingDirectory ?
shouldn't it interceptSrc and remainingPath follow same pattern to intercept as they both split from src path only? Whats the issue if I use same interceptSource method? Do we have some concerns? Could you explain me if I miss something here?
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
Null check for leaderElectorListener
I think what the old code was trying to do was ensure this future gets removed from the list after a refresh if it was canceled. I think this might achieve the same result in a clearer way: boolean result = super.cancel(mayInterruptIfRunning); if (result) { refreshListeners.remove(this); } return result; In particular, if it was successfully canceled, then the set(null) call within afterRefresh is a no-op.
Check error code/description
Probably worth to extract constant as you did with: java private static final String TEXT_MUTED = "text-muted";
wait for the elements before interaction
What's the point of adding a copy here?
nit, Collections.EMPTY_MAP?
Instead of null can this pass in a simple Supplier of some simple ExecutorService? That's out of scope for this really but it will help clean up test noise.
setErrorMessage
This could be combined with the previous line.
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
catch IOException and rethrow to avoid wrapping an IOException with an IOException
Use Logger or remove try-catch and throw IOException
This catch clause can be eliminated, since it just re-throws the exception without change.
you are calling stream.addLivePacketListener on the onStreamCreate but not removing it on onStremDestroy.
Need to implement
declaredOuputStreams is too verbose. the variable/method can be outputStreams/addOutputStream.
StringUtils.isBlank() ? Maybe it is an edge case, but the existing logic is not specific about what can be passed to this field (null, bogus blank strings, etc.). So being more protective would not hurt
There is also StringUtils.removeStart for that
do we care to check the length to be positive here?
This implementation is not transitive. null elements should either be ordered first or last.
Seems like a reasonable change. Can you extract formatter.withZoneUTC() into another constant to avoid additional overhead each time?
This still isn't transitive. Just use CoreUtil.compare() which implements this correctly.
why do you want to whitelist it at the end?
<LINK_0>
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
Since the project already introduced the ValidationResultMatchers class for validity assertion, wouldn't the following will be preferred ? assertThat(result, isValid());
and here: assertThat(result, failsWith(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_ADD_BRICK_FORCE_NOT_SUPPORTED));
please use for the positive tests the following convention: assertThat(validator.shouldVdsBeFenced(), isValid());
And this one is good, too.
This a bit awkward, but I guess we don't have choice since PublisherCallbackChannelImpl is not ChannelProxy instance. I mean we we might not be able just to use this there in the processAck(). Correct ?
unneeded if clause
Maybe legacy version of SetDigest can not be cast to HyperLogLog
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Add Preconditions.checkArgument checks to verify that the passed buffer is not null and that sessionProposedCapacity is greater than zero.
Nit: "Creating ephemeral nodes..."
nit: getAdmin method -> getAdmin() method ?
This check is necessary here, but there is a way to make this much simpler by refactoring the block that throws the exception into the check() function. This was done in the following PR: <LINK_0> Could you please review this PR and make the changes to cut down on duplicate code/logic? Thank you!
Indeed, that is better than my suggestion. Let's do this.
Does it really?
Please mark requestRouteToHost as deprecated and have it create a InetAddress for the given hostAddress and use mService.requestRouteToHostAddress. requestRouteToHostAddress does not need to distinguish between v4 and v6. Drop the addressType stuff.
Don't you think there's a need to add a constructor with final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
Symmetry (throw)?
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
Also, when you do that, you'll be able to return directly from the try block, reducing the size of the method by nearly a third.
I find it a bad idea to add a dependency from sw360-portlet to a backend service implementation just so you can access some resource. Please move the resource elsewhere and remove the dependency.
Remove the public modifier.
In general, all injection constructors should be package private.
Remove the publicmodifier if this parser class remains.
wait.forElementClickable() should be used before
wait.forElementClickable() should be used before
public PostsListPage and return this for chaining purpose
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
"return position;" maybe?
is there a specific reason for returning null? can you return an empty Email object instead?
Why not setLocalEditorStatusChangeHandlersEnabled?
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
method name in log message should be enableConnectivityChangeReceiver()
@ivandalbosco No need to change order if we don't rely on visitor for finding "try"
I am really doubting about this call to super: What about something like :  return new Foo() { //some stuff closing };  The new ClassTree will be checked twice, once with the override of visitNewClass (via the call to super) and once with the checkUsageOfCloseable of the expression of the return statement.
make it final. You don't want classes extending it to override this, as it's driving the analysis.
Remove this
optional: can call writeWithoutMarker
RestTemplate throws Exception (vs Runtime and an IOException)?
Debug leftovers? ;-)
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
Is this parameters really mandatory? I thought its default was false.
Keep this sorted alphabetically, same as in the validators declaration.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
Restore visibility of methods in this class to package level when unit tests are moved to jaggr-core
Likewise: can this be static? That said, I think it might be simpler to do inline at the call site: objIds.stream().map(ObjectId::name).collect(toList()); Or maybe we can make a custom matcher, something like hasObjectIds("4624442d68ee402a94364191085b77137618633e", "f900c8326a43303685c46b279b9f70411bff1a4b")
I know this is not from you, but can you change to use arrayList, there is no good usage of linked list.
If possible import the model type and use the fully qualified name of the backend type.
This is a status field. It should not be mapped from REST-API to Backend. The way that the user changes this status is by running activate/deactivate action. So please remove this mapping. The mapping in the other direction is ok (REST-API should show the status, so the status should be mapped from Backend --> REST)
this setter is no longer relevant, recompile the project so will be generated new setters/getters according to schema change
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
Looks like you didn't use the plugin to generate these test methods
The streams created are T1 and T3, but the ones added here are T1 and T2. Something is not right?
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
lists shouldn't be copied, best copy them; java this.targetContent = new ArrayList<>(targetContent);  as if anyone still holds access to the parameter list, it can modify it
do this check earlier to avoid allocating a map that's not used, e.g.  if (tempAttributes != null) { this.attributes = new HashMap<>(tempAttributes); } else { this.attributes = new HashMap<>(); }
Add Preconditions.checkArgument checks to verify that the passed buffer is not null and that sessionProposedCapacity is greater than zero.
Use buffer.remaining() when allocating the copy buffer. Set bb.position(0) and don't touch bb.limit().
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFor... or getManagerFrom...
- Can we inject the EventHubWrapperFactory into the EventHubSystemProducer, EventHubSystemConsumer and EventHubSystemAdmin instead of class-loading them via config? It'd be much cleaner with types that way. Use-cases at LinkedIn that require tunneling can inject their tunnel-aware versions of the EventHubClientWrapper.
Minor: extract field for consistency.
Since you log the whole object you can change ending to deleted for {}., since attributes toString() is like Attribute:[content].
All attributes s values were -> All attributes values were
Limit is not correct for ORACLE DB.
No, this. when you call methods.
add this selector to UI mapping at the beginning
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
Integer.parseInt
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
Good plan.
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
I would prefer to add a finally block to the try/catch, and close the cursor there. This would involve moving the declaration of the Cursor object outside of the try/catch, but is a much clearer model. Same for the other file. Also, please prepare the PR against the dev branch rather than master.
instead of e -> e there is a Functions.identity()
measuresByTrade = measures.stream().collect(toImmutableMap(CalibrationMeasure::getTradeType, m -> m));
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
If we return inside the case clause, we can get rid of the res temporary variable, the breaks and the last return line. switch(format) { case LEGACY: return renderLegacySize(size.longValue()); ... default: throw ... }
Should be : sizeInGiB
@yesamer I think it would be clearer to and an "else" statement, or to create two different methods. Wdyt?
Is it possible, that the context is null?
Please read up on the correct usage of WeakReference. get() returns a regular reference, true, but unless you save this returned value somewhere, the WeakReference you hold does not prevent the garbage collector from collecting the context your weak reference points to. So you have to introduce a new local var, write the result of contextWeakReference.get() to it and use this regular reference for the remainder of this method. Otherwise you risk running into a NPE
You could have a placeholder in localization instead of concatenating strings here
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
Officially, we should ask this to the controller... Or rather the controller should already substitute the URL with an ID in the goal DTO when executing the POST.
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
Do you think this is non-useful? I figured there would be cases where people would want to test code that behaves differently if the SDK claims to be something really old that we'll never fully emulate.
Per our coding standards, all if blocks must wrapped in curly braces.
I don't think you need this since state ids are supposed to be unique.
can it be made in one line?
Please use for the paths  "src/test/..."  instead of  "src\\test\\....."
Why is this needed?
I'm not sure it's safe to change between fake and non-fake sequences. I'm having trouble working through it in my mind.
Why are you removing the setIDs here?
Would be good to add as a LimsUtils method if mixing date types is going to become more common
java this.onPostServerTick(this.getMinecraftServerInstance());
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
Consider using == maybe?
do we need traceId to identify the object? i think the previous implementation was fine
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
I have the feeling that we should be careful and also check for interfaces and annotations (Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, as both of them are ClassTrees). It would however be pure defensive programming, because I can not manage to write a compiling example.
@vilchik-elena You could factor the list of kinds into a static field Kind[] kinds = {Kind.EQUAL_TO, Kind.NOT_EQUAL_TO} in the enclosing class.
If i'm correct you should end up with only Method and Lambda as subscribed kinds.
This also regresses in that it no longer works for multiple repositories.
It's unlikely, but product could be null here.
Debug stacktrace leftover?
it cannot be a constant: it needs to be a variable (like timeout) so that it can be changed per test / per class and eventually adapted for EE
This doesn't look right. Should be:  result = services.get(result.getId(), k -> this.serviceRegistry.findServiceById(id, clazz));  Also, don't forget to check the result to make sure it's has the correct type based on clazz
This should use the API mod ID since this is an API feature.
@fanifieiev the same above.
@fanifieiev the same above.
@fanifieiev the same above.
Any reason this can't always be used?
Activity state util check before starting any of this, maybe?
Probably just cast to MediaOverviewActivity here, instead of multiple casts on the next few lines. To be fair, I feel as though this should all be part of a single callback/listener call.
Is this intentional? You are forcing the value to 'true' Maybe a simple assignment is clearer
Slightly more efficient: CPPASTAttributeSpecifier copy = copy(new CPPASTAttributeSpecifier(), style); copy.attributes = ArrayUtil.trim(attributes); for (int i = 0; i < copy.attributes.length; i++) { copy.attributes[i] = copy.attributes[i].copy(style); } return copy;
I think you can return this
java.lang only required here
Please fix the alignment.
Should we log something here?
should this count be parameterized?
Pull this into a static final variable
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
Sorry wrong patch, will fix these
pvk should not be visible. Please remove it.
Bad variable name! Variable names should be clear enough. Rename it.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
This method should get the expected size of each lun, since vdsm reported it in getDeviceList (path capacity). So this should call each host, and report the hosts that do not see the expected size. We don't nee to create map of sizes, but create map of luns to failed hosts.
Logging.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This drops the packet. This shouldn't happen just because it doesn't have the extension. I'd expect the wrapper to handle this logic.
Why change it?
Do we really need to catch every checked Exception, too? Can't we catch the exceptions that are really thrown only (and perhaps every uncatched / runtime exception)?
Are you trying to print the set of ids or just the size of the set? (The header doesn't match.)
Extra ", "
Actually trying to get rid of this in replica metadata request too. The logs are already too large
Can this be private, or is there another use case for default attribute outside the builder's call?
public?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
This will return all revisions for a single ID, use RevisionSearcher.search(...) instead of the raw searcher. Also you can use the already opened RevisionSearcher instance via context.service(RevisionSearcher.class).
Could be final?
would it be easier if model.getHostStatus(host) returned an Optional<String> instead? seems like every place that calls that method has to perform the null check, so might be nice to address that with the type system itself
raiseDiskEvent sounds like an exception. should be something else (the name)
who uses it now?
You can remove the one line above and rely on the below one.
scaledData, thread safety and all
suggestion public Long offset() {
How about using % with args instead of +? Same below.
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
Use same order as the field declarations.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
what's the intent of this change?
Why checking overlayPosition for null twice in this line?
please fix whitespace
in some cases lhs/rhs could be null, pls do the null checks appropriately
this(...,..., LogLevel.INFO);  apply the same pattern to other constructors.
I saw the property names would be converted to lower cases, that means e.g. controller.upload.onlineToOfflineTimeout will become controller.upload.onlinetoofflinetimeout. Is that intentional?
Move to constructor? We already do a defensive copy might as well front-load this work instead.
but this should probably use that mechanism, too?
I assume that no-environment may be not supported by some infrastructure. environmentFactories can be configured in Infrastructure module but there is no ability to deny no-environment. Do you think it must be supported by all infrastructures? Maybe it makes sense to provide an ability for Infrastructure to bind NoEnvEnvFactory implementation. And if it absent - then it is not supported. WDYT?
Was this detected by findbugs?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
other places use "error" lower case
scheduleTimes --> scheduleTime
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Can this be private, or is there another use case for default attribute outside the builder's call?
rename tempVar
Please format the parentheses throughout the file, as you would have requested me to do.
Maybe inline this local variable?
Shouldn't we rather throw UnsupportedOperationException() in this case? Or rather create interface without the support and extend it with interface with these methods?
Is this not needed anymore?
This is not really a deprecation, right? We're changing the behavior (ignoring the setting and advising them to use the requires-reply). I think I'm ok with that, but maybe we should log a WARN and refer them to the migration guide???
Extra trailing comma.
What is SNP_COUNTS_FILE in this context?
Samples
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
Should this actually be line 1? Maybe it's not important.
On reflection, I suspect that this was done for backwards-compatibility reasons, since overriding and delegating to base would be a behavior change whereas this change is only a performance optimization.
cat > \"" + filepath + "\" ... would be preferable to handle paths with spaces.
Do we need some escaping mechanism to guard against the possibility that 'table', 'column' names might contain special characters (like "(", ")", "'", etc.)?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
this removes the entire failure path of the test: The assertion that appending to a nonexistent file raises an error. Why did you make this change?
again, test is no longer a test of the behavior of any filesystem
"Initial connection"?
Don't check these in.
duplicate line...
Can we move this to the XML?
This method looks horrible to me (and to whoever is a sane engineer, I should think).
should make a static final.
null-check
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
Should this be a brpop with a short delay? (just thinking in terms of consistency with the RabbitMQ version)
suggestion return Integer.compare(this.score, o.score);
Are there any const that can be used instead of duplicating strings like this?
Move to update please. < layout
consider saving the value of group 1 and group 2 here rather than the whole matcher
shouldn't we replace spaces also in case the pattern is not what we expect? just to be on the safe side..
no need for final here
Try using StringUtils.isTruthy(this.path)? <LINK_0>
Same here: should be Branding, not ProductBranding
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
The value is not assigned to json?
Hm, should we thrown it as InternalProcessingException ?
Same as above for toString(): <LINK_0>
Oh yuck. ;)
Missing opening "(" before getDescription().
Please use the full test class name for the controller thread, it's better for log filtering. Also, some local variables would help keep the code to the left.
Can you add:  java newBoundedThreadPool(int minThreads, int maxThreads, ThreadFactory threadFactory) newBoundedThreadPool(int minThreads, int maxThreads, ThreadFactory threadFactory, Duration keepAlive)
Use threadFactory in ThreadPoolExecutor construction Also there was CallerRunsPolicy before. Keep it, please.
Move to run() method.
let's call it updateCodeMinings() instead.
I think the exception message here is not good.
Why do we not use  java final Object[] array = new Object[length];  ?
return array == null || array.length == 0
A bit shift would be faster ? Also we don't check for integer overflow issues.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
isEmpty()?
This sounds like something we want to do in a @BeforeClass annotated method.
Here you use Double.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
value.toString() vs. factory.convert(..) a bit lower, line 63
value.toString() vs. factory.convert(..) a bit lower, line 63, again
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
Mb it is better to use common format for toString method? <LINK_0>
This toString() is used when printing the query plan. We probably don't want to include the partition values.
add block
does this method need to be public?
add block
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
if implementations is empty, this method will eventually return an empty (immutable) collection. We should throw an UnavailableImplementationException instead to indicate an invalid state or spi class.
Perfect! :+1: Just a few things. I'm a little picky here :grimacing: No need to extends Object. Please use Map as declaration type. java return new ArrayList<>(uniqueMap.values());  The method is a perfect text-book example for tests. :wink:
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
Wouldn't it be better to wrap and throw as a RuntimeException instead of suppressing with a log message?
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
Use guard conditions to deal with the low hanging fruit first. It reduces the complexity of the execution paths.  java if (!confirmNewBoardCreation()) { logger.info("New board creation cancelled"); return; } panels.closeAllPanels(); onBoardSaveAs();
Sorry! I meant we don't need to pass the options in!
Do we wanna return ImmutableList.of(address) or this is intensionally?
Delete and pass on m.
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
Don't you have a ConstrainedProperty.forGetter()?
Should use NLS.bind() to construct message.
Null pointer...
move inside of for loop.
Why does this just return blank strings?
Could change the return type on method to Collection
Do we need a list in this case? If we just want a collection, you can do Collections.unmodifiableCollection(containerIdToContainerMap.values()) and prevent an extra copy. However, this would mean that any changes to the map could cause issues when iterating through the containers.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
Can we set a charset? Like ASCII or UTF8?
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
use constants
Doesn't String.format need a value to be formatted?
Let's implement this in pre listener. Also need to implement doPreSetUserClaimValue()
why public? Are we planning to use it outside of this class?
This method can (and should be) private
check for null here
I think we should putAll() the defaults - a common java developer error is to use get() instead of getProperty() on a Properties object. Only getProperty() looks for the defaults if not found.
Is this really something we want people to be able to override?
Same here for doing empty check instead of non null check.
Again, logging of passwords might not be what we want
Suggestion: extract a util method SingletonUtil.getValue(this.senderCopyMessageList).orElse(null)
This if/else seems confusing, why not have some code like AuthorityInfo info = getInfo(authority); this.host = info.host; // or getter if you wish this.port = info.port; // or getter if you wish this.valid = validatePort(); together with private static class AuthorityInfo { private final String host; private final String port; private UriAuthorityInfo(String host, String port) { this.host = host; this.port = port; } } and with private AuthorityInfo getInfo(String authority) { MatchResult matcher = AUTHORITY_REGEXP.exec(authority == null ? EMPTY_STRING : authority); String host, port; if (matcher != null) { // extract host and port } return new AuthorityInfo(host, port); } basically have the constructor as simple as possible.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
What are we doing with e.toString()? Should this be logged?
I would not put this method as an example. This API is just... not possible for me. It looks more an error than an API. Is this used by users @wfink ? If 'not really', for me we should remove it from here IMO This API of creating caches at runtime should be changed and I mentioned in the thread in zulip @tristantarrant @wburns
should be "submitting"
Not sure there are cases where we want this, but having this overloaded constructor prevents one from using a single argument that would contain spaces. Given the use that is done of this class, I would drop this constructor
instead of changing visibility of constructor maybe you can make the static factory method SerializationUtil#createSerializerAdapter public and client code on Jet side can work on SerializerAdapter interface?
Could we make this constructor private and have clients use the load() method instead? This would provide a single, common way of creating this class and would allow us to remove these null checks here.
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
Is there any reason to do that here rather than encapsulate the logic in the constructor of NewExternalSubnetModel? Especially when as far as I can see, it has to be called whenever the dialog is instantiated.
consider a ternary statement instead...
Shouldn't be a separate config, there's already a fetchThreshold Samza config.
return Collections.emptyList();
ahh, here it is
Multiple method(*) methods
Multiple method(*) methods
Maybe remove the method("POST") as we are setting method("PATCH") almost right after it
The field should be removed as well.
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
FYI, proper English grammar is "must not be null" or "must be non null" (I'm not sure if grammar requires a hyphen in "non-null").
Very helpful
24 hours should be a value in the properties file
!getWebApp().getConfiguration().isTimerKeepAlive() || !keepAlive isTimerKeepAlive = true, session will not be invalidated
please use a static import for assertNull
is this tear down necessary? the next setup overwrites anyway, doesn't it?
Not necessary. See quality rule : MITRE, CWE-397 - Declaration of Throws for Generic Exception
nit: could you please perform the release calls in a finally block so the ByteBufs get released even if the assert fails?
The problem with this approach is that there can't be any cross-thread pipelining because one thread won't progress unless the other thread does 1 thing. A better approach would be to request in bigger batches and re-request after a certain proportion of the batch has been received.
Is this a race or corruption happens all the time? Change looks fine, but I did not understand the actual issue with the current code on why corruption happening.
I think you need to do separate request to the db to retrieve all cars of this person
This will slow down the down the app, since you are executing an additional SQL query for every note. Currently, I have about 200 notes and showing them on the main Activity requires a single SQL query. With this change, 201 SQL queries are executed. This is a "no go"! There are two alternatives to fix this issue: 1. build a "cache" in memory for categories, i.e. load all categories of the current account to a HashMap on creation of e.g. NotesDatabase and query this cache in getTitleByCategoryId(...) (and related methods). But on every change of categories (insertion, deletion, edit), you must update this cache. 2. change the SQL query in getNotesCustom(...) and add a JOIN on the categories table. Hint: you can reduce the need for changing code if you change the column names of the categories table: If they differ from column names in the notes table, you may not have to prepend the table name (e.g. CATEGORIES.TITLE, because TITLE exists in both tables CATEGORIES and NOTES). I vote for the second approach. You can remove the method getTitleByCategoryId(...), then.
truck is unused
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
backupCacheInstances != null ? backupCacheInstances.length + 1 : 1 would make more sense
In a good implementation, the spatial reference instance should be shared between all instances of geometry coming the same dataset, so usually the esriSR size would not contribute to OGC types, but we don't enforce that on geometry side right now.
this should match with the place token
I'm not sure this is used for anything, I need to verify.
You could just do setAvailableInModes(ApplicationMode.VirtOnly); Refer VmListModel.java
None of this stuff is atomic.
Could set null to the values field too
Won't fix.
The super() returns "" on null. Why should we differ?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
Is there a chance of a NPE? could be getFile() null?
Why not using entity manager factory to get the metamodel?
why do we have to use threadlocal for that ? if need, why not stored the entity manager as a member ?
this is the exact context of the AbstractJpaDao.em() - shouldn't it be only the responsibility of the interceptor to set the entity manager to the dao ?
Formatting issue
Should assert on the message contents to make sure it's the right one that got through.
Use hamcrest.
Please externalize these strings.
If it doesn't have the right coordinates it's probably not useful ;)
I would remove all these events after the SWT.MouseUp. They aren't normally sent when you only select an item.
No need to use ConcurrentMap.
It seems that UndefinedDatabaseException can also occur.
Please align the lines
These 2 conditions can be merged into 1 condition
You don't need to check for null because the Task which triggers this callback should have been canceled anyway. If the problem still exists, Crashlytics will tell us.
Shouldn't this line be in an else clause? Wdyt?
You should be able to use the diamond operator here, i.e. new ArrayList<>()
it would be nice to have toImmutableList collector. Airlift/Presto have one. If you have some time you may copy it from them :)
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
please create a more specific exception that extends this one.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
closeQuietly or whatever its called?
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
@inverno let's have same grammar rule here and for single parameter version
There is a double ? sign here
It looks that the scheme is sometime _ChatScript_ and sometime _chatscript_. I would always use _chatscript_ in lower case as the scheme in annotations, examples, services...
I'm not sure it's safe to change between fake and non-fake sequences. I'm having trouble working through it in my mind.
Can be the className null? If not I would maybe rewrite as [1], what do you think? My point is to not nesting expression into try catch, if an exception can not be thrown. [1] java if (ScenarioSimulationSharedUtils.isMap(className)) { return new HashMap(); } else if (SIMPLE_TYPES_LIST.contains(className)) { return null; } else { try { return classLoader.loadClass(className).newInstance(); } catch (Exception e) { throw new IllegalArgumentException("Impossible to instantiate " + className, e); } }
I think Optional is just a bit more readable in situations like these: java return Optional.ofNullable(ObjectConverters.listStringConverter().convert(claimValue)) .orElseThrow(() -> new IllegalArgumentException...
Please change to: > ... operator cannot be used in a GIVEN clause.
Please, add { and } to the if statement. if (dialog.open() == Window.OK) { ICommand cmd = wizard.getCommand(); //command execution ? } Modifiy the inheritance of the action and add the command execution
Command cmd = getPatternCreationCommand(editingDomain.getResourcSet(), selectedViewpoint Eventually, the Wizard could have a getSelectedPattern (and configured of course) and then here you could write: IPatternProvider selectedPattern = wizard.getSelectedPattern(); editingDomain.getCommandStack().execute(selectedPattern.getCreationCommand(resourceSet, selectedViewpoint));
As already said, you cannot execute the command like this. In the previsou patch set I put some ref to existing code which execute the command on the command staticc of the current editing domain (to support undo/redo, ...) You should at least try ecitingDomain.getCommandStack().execute(cmd); And check the undo/redo works.
You need to add an Assert.fail() after your catch. Doing nothing here is the wrong thing. When you do that, inside the Illegal argument catch block, put a return statement there so you don't accidentally trigger failure
You can also use IO.close(bb) as IO.close will not throw any exception.
I already made several fixes to the unit tests cases and XBeeDevice class that are already committed in master. We will sweat blood to make the merge...
I think in this case we need to init the repo with a url with a slash on the end.
equalTo("/home/mule/bin/mule") -> equalTo(MUE_HOME +"/bin/mule")
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
How about introducing EventClass.emptySet() so that it's easier to find places where return empty sets?
Please consider using constant from WorkspaceServiceTermination here
return ImmutableSet.of();
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
there are two options here: a. (the better one) if value is not in cache - call addToCach(value) b. return a boolean value - was the value cached or not.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
default method visibility OK?
This can in theory throw a NumberFormatException. This is caught in similar case in ListBoxByteSingletonDOMElementFactory, might be good to catch it here too.
We should consider extracting the functionality of the stringValueOf(...) to some helper/utility class, as we may use the same functionality elsewhere? :cake:
Consider to replace with "an allowed command".
How about a message telling the programmer WHAT action type he shouldn't have used?
I understand this code was moved from DiskValidator and you want to keep this patch as small as possible, but a followup patch should probably convert this boiler-plate to a more elegant stream: String disksNotExistInDbIds = diskGuids.stream() .filter(d -> !isDiskExists(d)) .map(Object::toString) .collect(Collectors.joining(", "));
Missing call to super implementation of onResumeFragments()
configure is user-overridable method, and also there is no need to trigger it here
* shuoldn't we call super? * worth adding some log..
I don't think you want to use RealSystem() here; doesn't that really call System.exit()?
Use constants
Fix the method name here please.
this is a query metric I think the metric should be "query/jetty/numOpenConnections"
emit() still shouldn't be concurrent. It should allow emitting only from the owner thread.
This method has an external annotation now.
Why the NetworkAttachmentRowMapper has to be created new, instead of using the old one?
Why a "new" object? qosDaoRetriever is final.
This is the only relevant one:)
return asyncHttpClientMap.remove(name) != null
Please add { to follow Spring Security's code conventions
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
Not sure if you wanted to leave this hardcoded?
See below; there is no reason for this that I can see.
if we always throw an exception then the function will never return false only true.
@fchauveau there is no null handling of source, is this intended ?
Can it be that this.lookupSourcePositions > 0 but other.lookupSourcePositions < 0?
This is bound to reduce severely performance when starts, counts, and blocks are not used. You'll need to make sure there are no performance degradation in that case.
Isn't this check done by JNI?
columnIndex < getPrimaryKey() -> columnIndex <= getPrimaryKey()? If the column is the primary key, the cached index should be cleared.
use containsKey method
I see you"ve moved 'reportsWebappDeployed' but what about 'retryCount > MAX_RETRY_COUNTS'?
IMO, urlInitialized check here is redundant. I"m not sure how can you get to this point with urlInitialized=false. (And if it is false- don't you want to return?)
Constant
Shouldn't this be wrapped in a try... finally block?
this should go to login I think... 1. redirect to external 2. apache takes over 3. user press escape 4. we reach here 5. we should present login and not redirect to 1 and loop
It seems like a client with the intent to use JWT that sends an expired token will end up with a kerberos challenge here. I can imagine argument for both sides of this but I think that we probably want to allow the JWT validation failure be reflected in the response rather than falling back to kerberos.
Let's have constructors one near another
super() can be spared here.
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
Need to add spaces after if, before and after < and after ). Please follow existing code style.
What is the nullness contract here? Also missing docs.
style nit: no braces around single line blocks
rm
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Doesn't String.format need a value to be formatted?
Based on the invocations this method seems to represent a memory footprint related to the column chunk. So, bloom filters should not be counted here either.
I am not sure if we want to count the bloom filter in. The statistics is not counted either.
should you guard against needed < 0 here?
I am curious couldn't we just test this by default given that all schemas need to be present in "schema/" directory. we could just load all of them and based on what schema xml reference test that by default. Overriding is still fine for all corner cases but by default it shouldn't be needed.
I don't get this method name.
I'm a bit concerned about this call as well, and what might invoke doResult Is this invoked on every vote? There's some file ops in parseRawResult which concern me here
I think we need file with version 1.4. inside.
the first three lines are duplicated code - consider restoring them to the setUp() method above.
I find it safer to assert the exact output and not whether the output contains some strings. It's not like the input string is that long. It's also easier to see the difference between the expected and the actual value when the test fails.
Please remove
Please change it to a normal null check and throw a IllegalArgumentException. This is more meaningful than throwing an NPE here.
Please change it to a normal null check and throw a IllegalArgumentException. This is more meaningful than throwing an NPE here.
Can't this NPE as they're Booleans (i.e. objects not primitives)
could the URI ever have a trailing '/' or similar cruft?
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
If we always return 0 or 1 element, would Optional<String> be a better return API? In that case there would not be any confusion that we can have more than one element and it'd be clear we'd have either zero or one.
Why contains instead of equalsIgnoreCase?
This allocates a new immutable list every time it's invoke, please cache the list in the initial creating and if it already exists return it
This line is 128 chars long... this is not compliant to our coding conventions.
Why assign to a variable just for the sake of returning?
This pattern can be created only one time at constructor level
this doesn't seem to survive a workspace restart. I'm prompted to allow certificates after I restart eclipse.
you're going to get "... Cfdefs CfDefs(...)" which may a look a bit odd - can updated after the major issue is resolved though.
If you wanted to simplify this logic further, you could perform a collect() operation on the stream and use Collectors.joining() to concatenate the elements, so that you don't need to use StringBuilder explicitly.
should check results here, not just size
I expect out to be empty here, yes?
This might be considered a programming error -- should we really assume null is empty list instead of a coding error?
This should be ofNullable, right?
should be ofNullable
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
Should this also handle the suffix 'es'?
Name is no longer used
String name = StringUtils.EMPTY;
replacing this with helper method would be great
replacing this with helper method would be great
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Again, use IOUtils.
You can do this with IOUtils.write(), too.
there is no case in which httpClient become null, right ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I get a NPE here, processModel.tradeManager is null.
The product present value take into account all the coupons in the future down to today. The present value of the trade should include only the coupons that are after the settlement date/ ex-coupon date. An adjustment for those coupons is required in the present value.
Isn't the trade "quantity" missing?
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
And we can avoid new prefix then, it reads good: Given.eventBus()
Why is this better than using org.junit.Assert.assertEquals? If we use assertEquals, we don't need to add assertj to the project.
Same here. Add clarifying parenthesis
if format string is non-empty then String.format(..) can not be empty, so Strings.emptyToNull(..) is probably not doing anything. did you want to do following instead?  String.format(format, Strings.emptyToNull(value));
use ... between 0 and 100., it's more user friendly
i'd mention the actual action used for that.
this is not correct, it's about removing template's disk, not the template from SD, i.e DELETE /api/templates/xxx/disks/yyy <action> <storage_domain id=zzz/> </action>
I think Michael meant adding something like: "...using 'migrate' and 'stopmigration' actions..." (Michael said: "I'd mention the actual action used for that")
Could specific exception be used here?
let's remove this try catch because it would prevent the annotation to get the exception and do the rollback
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
I guess we no longer need store to be of ConcurrentHashMap implementation if we are fully locking it.
Don't need (TopicPartition e) here, just 'e' should be sufficient
Should this maybe be .map(e -> e == null ? "null" : e)?
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Won't work on windows
IMO better using atLeastOnce()
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
default method visibility OK?
No need for super()
Missing earlyMessageRejectionPeriod
minor: could you add disabledReplicas as well?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
Should this be in the try? For consistency, have the LOGGER messages in the same place for the start and stop functions.
Do we really want to move this from trace to debug?
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to make this explicit.
Same note here as for the previous caches.
Same note here as for the previous caches.
it should be cleanup, no ?
Shouldn't block for more than task shutdown ms, ideally much less. Should call shutdownNow() if timeout expires.
Should this be a exception?
Nit: not needed
minor: don't need this. qualifiers
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
Should be size != -1 since -1 is an explicit value. If someone passes a negative value then the behavior is undefined (which is fine).
simplify to return idx == -1 ? null : handlers.get(idx)? (same for other similar places)
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
We might want to add a null check on getActivity() here since the clients of displayNewPage have no idea about Fragment lifecycles.
Do we want to do database IO on the main thread?
Set fileEventHandlerRegistration to null.
minor: some of the variables that use this are long and some are Long. I think long will be good everywhere? (since this cannot be null)
Use more talkative temp variable name.
or long ?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Can't this be further improved to just Arrays.asList(values)?
Don't we have to say that this is uniqueId JDBC?
May as well just return the result of resourceFactory.getResource(..), no?
you shouldn't need it as UnknownUserException extends LoginException
Let's include the group name and say it's getting the ids that failed.
If we change the default value of getValueAsString we should change this one too.
Maybe return an empty list here instead of null?
this should be a warn
Is this signum call really needed here? compareTo should already return the correct value.
Have you tried Collections.sort(fields, (o1, o2) -> {})? It'll save you from having to turn this from a list to a stream, then back into a list.
java list.sort(Comparator.comparingDouble(ForgeTimings::getAverageTimings).reversed());
Preconditions.checkArgument() would be better form.
Is "percentage" necessarily the right interface? It's more natural from the implementation perspective to take a float between 0 and 1, and if the target audience is scientists, it may be more natural for them as well (just as, say, p-values are expressed as real number fractions, not percentages). Additionally, a "percentage" parameter leaves it ambiguous whether only integer values are acceptable (though the float type makes that obvious, but the type isn't visible in JSON query plans). Anyway, just being devil's advocate here, not saying you made the wrong choice.
Same thing than for the agent: no default value.
This method can be static, as all the methods it calls.
you could have merged the expression of this if with the previous one.
I suggest to drop this conditional, type cannot be null (unless I'm wrong :-)
You can use StringUtils from the commons.lang3?
Why do you need the non primitive class check?
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Restore the spaces.
Don't need last else
Why an array? List<String> is just as fine
this could be Lists.newArrayList(deviceId);
final And you're not checking dates aren't null
that's not exactly what we want. We want the map converted to a KeyStoreRecord or whatever object we have.
why not delegate.getSystemMemoryUsage()?
Remember to create a nativeGetFinalizerMethodPtr method too to free native resources. Check OsMongoCollection for inspiration on how to do it.
Should this be 1 if content size is 1?
I would suggest calling getAmqpPort() here (and in other get*Url methods) to avoid a duplication of this code
Should we localize this?
Translate this?
Same question
this logic seems duplicated from lines 403
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
I think try with resources should be used.
Should this return Flux.error instead of throwing?
With GZip, it's actually easy to validate whether a byte[] contains zipped information: the first two bytes should be 0x1f8b. If they aren't, data is probably already decompressed (or never compressed). The wrapper could then just return the original byte[].
nit: this should be "f"
Insert checkNotNull(position, "position"); before this line.
This means clockHand will be hot at initialization time. Intended?
No need to catch the exception here, it was already done in the overload.
No need to catch the exception here, it was already done in the overload.
Do we need to duplicate catching the RuntimeException in every overload?
rename to breakpointRequest
rename to breakpointRequest
this can be a single line with allForCluster.stream().forEach(glusterCommandHelper::initGlusterHost)
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
The ctx variable is unused anymore.
The debug logging can be removed
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
What about l < Integer.MIN_VALUE?
Hm. I guess it would be a weird case (some variants with names, others without in the master playlist), but it would be strange if we ended up exposing some tracks with indices for names and other tracks with actual names. How would you feel about: No name: Integer.toString(index) With name: Integer.toString(index) + ':' + name The same will apply for the TODO in the WebmExtractor, where I would guess some tracks having names and others not having them may be more likely.
I lost track of changes :D. Adjust as needed depending on whether the setUpDefaultPanel has to lose the arg or not.
I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.
Do we know that it was a standby before participate was called?
Wrong log message stating about geronimo which is removed in this PR.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
PG_TYPE_TO_NAME should be an array (dense)
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
You could probably use the same URL as in getResultById here.
I just wonder how it may work, because you don't specify the username when you trigger the build... If the check below works, then something is wrong with the matcher
:pencil2: Since the plugin adds some extra stuff to the message when it's an AMQP message, it would probably be a good idea to check for it here.
Could put this in the @Before method.
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
We can make things faster by not instantiating the row every single time.
what about the null case?
other than the previous implementation in subclasses this doesn't create the directory anymore.
I'd recommend using <LINK_0>
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
Just log in debug the cause of this error. Just in case. I guess it could contribute to the sysadmin.
an expensive way to check if it exists ... if there's no other way, then this will probably do
true?
Fix aliases = aliases = ...
Can we name this something other than it? Even i would be better to me than it.
I'd add an always-printed log message here too to make sure it's remembered.
use getAllCount() instead of 5
Should what you expect be the first or second parameter?
Aren't you supposed to compare with the actual expected value instead of just length?
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
Can we use Java 8 Stream#findFirst() to make this code more expressive?
style nit: no braces
What if this path actually exists on the user's workstation?
LOG.error("Failed to unlink {}: ", path, e)
please reconsider this log message s_logger.error(String.format("Unable to create directory %s for template %s: %s%n", path, getTemplate().getUrl(), e.toString())) especially the %s%n part of it, logging an exception as string with newline semms not what we want. I would like a stack trace or a message, or both.
Take care! arg.get().toString(). Otherwise you're passing the Optional object.
Remove the toString or give it a more descriptive result?
You could better use the instanceOf method from the Predicates class for a more safe approach.
Asserting inside the sub-thread won't fail the test. Should probably refactor.
Use the narrowest exception required, I think in this case you just need ApiException
Assert.areNull
this method deserves a description
I think I prefer "Invalid key" as exception message
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
could we solve this better by overriding send() in the TracingActor? I'd like if all this trace and replay code would be in that class.
From discussion above, would probably be good to imply VmSettings.ACTOR_TRACING being true if MESSAGE_TIMESTAMPS is set. That could simplify the check here to just MESSAGE_TIMESTAMPS. (same below)
Avoid logging an error if there's already a throw.
Avoid "System.out.println" and replace by a logger if needed
nit: you can merge both lines above as checkNotNull will return the given argument
Optional should be used in interfaces. Use null as internal value.
Should this be "shouldReturnEmptyString" instead? If so, there are also a few more occurrences of "shouldBeEmptyString" that will need to be edited.
Typo: initCardModeButtons()
can we remove this method and simply have the poolsOfString.take() where this method is called?
Hehe, this is exactly the pitfall I pointed out :D If currentTimeMillis + timeout is actuall greater than Long.MAX_VALUE, you will get a overflow and the sum will become negative. Instead you should probably test, if Long.MAX_VALUE - currentTimeMillis() < timeout and if so, throw an error.
I'm afraid there is a code logic problem here. If you call setReadTimeout then setConnectTimeout the read timeout is going to be override because a new client is built with only the connect timeout set.
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
The ID is used to restore old files (from an older release) so this must not be changed!
The ID is used to restore old files (from an older release) so this must not be changed!
This will break existing installations. Revert the name.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
What does it mean when we return null?
Use a list to access at index
getResult() unnecessary creates the empty list. I'd suggest writing if(result != null) { return result.stream().findFirst(); } return Optional.empty();
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
len is unnecessary variable name
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Doesn't List as a Collection have a defined method to check whether it's empty or not?
Not really a fan of the null-oriented programming here. Would prefer caller check hasNext and we throw an exception here. However, I'm not sure what would be better.
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
Fine with me (although it does slightly detract from the opt-out possibility). WDYT about adding a retry backoff though? I'm a bit concerned we might just end up stuck in a loop of useless rebalancing, and waiting the full probing.rebalance.interval doesn't feel right either
use keyword "this" in these methods before member names.
The @Override should be on this line.
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
if I understand correctly, this will be evaluated first, but if networkIsSet is not valid, it won't be reported. Because of that, I'd rename 'validateRemoveExternalNetwork' so that it provides information that this is provider validation, and then inline this variable. That way this will be evaluated only when preceding validations #115-#119 succeeded.
Why useDefaultNetworkFilterId is always false here?
This validation prevents any updates to the management network. User should be able to change the network management configuration except its name. Please preserve previous validation.
generated -> generate
This is the only place that add entry to the pool, is it the only way to fill the pool?
Why not just catch "Exception"?
There's no concatDeep, I guess..? ;-)
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Do we need the ...Function suffix in the method name?
let's use LinkedHashMap
Please use Optional.ofNullable()
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
I think it's more neater to not write extra lifespan/maxIdle parameters, but instead to write them where you write lifespan/maxIdle already and just add the possibility to send a new option which defines the granularity of lifespan/maxIdle. Your current solution feels akward since you're adding two new fields and the existing ones are not used. IOW, just add one more flag to the flags parameter here and you're done on the client :)
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
I am not as familiar with the serialization process in hotrod, but couldn't you just pass the string either way? The only error case is if it is null, right?
I don't know, but isn't the class also of interest?
Should have a period on the end of the string for consistency.
So I'm a bit afraid that there is a code out there in the while that relies on this giving the old output. Could you also add a method toFastQString() that also calls through to encode so that's there's an obvious way to do what this used to do? I think toString should probably call through to that and produce the same output as it used to just to avoid giving people surprise headaches.
Can this return a List<JsonPatchOperation> instead?
Sometimes I also try to protect internal collections, but normally it only complicates things later. Can we return it as-is?
If the list of users stays the same, make it unmodifiable in the class constructor.
@sebing please put spaces around :
@dmzaytsev let's inline this
What if the original incoming request already has an If-Modified-Since header? Perhaps it should bypass the cache?
do we want eventually to have a writeTo(ByteBuffer) ?
The @Override should be on this line.
Is there a concern that we are at no point providing back pressure here?
this class doesn't have tests?
this class doesn't have tests?
is the value of bytes written actually used? since we only return -1 or 2 i'm wondering if a boolean indicating success or failure would be better?
no need for if as 1 - 1 gives 0 to add to cpuCost
node.getDistributionType() == SpatialJoinNode.DistributionType.REPLICATED
I think you should use MISSING_ATTRIBUTE
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Please keep this.cell near the related fields (previousFamily & cell count) below
we can do away with the local variable here @rishabh-997
Why is this line added?
Can be simplified, use assertNull instead.
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
Can this be private, or is there another use case for default attribute outside the builder's call?
format: remove extra space
Risk of duplicate transactionId. Resolution of currentTimeMillis is very low.
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
delete() should be executed from within the future so it doesn't through right away.
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
done for patch3.
Could you add some spaces, please? I recommend to use the auto formatting in Eclipse.
this will generate a lot of log messages if printed every 5ms. We should increase sleep time to a few hundred ms and maybe move this to trace / debug level?
I think the granularity should be 1 seconds instead of 5 seconds here.
switch these to back nanoTime for doing elapsed time (monotonic clock)
false is the default so you don't have to set it explictly
check if u can use 'getTaskIdList'
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest.
This would also allow removing Enum from this list. Object class isn't Serializable, why is this here?
For execution with security manager, something like the following is necessary: .addAsManifestResource(createPermissionsXmlAsset(new ElytronPermission("getSecurityDomain")), "permissions.xml")
static
Pull this into a static final variable
A for each loop on the listeners can be used here instead.
Log the full exception
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
new String() is redundant.
Don't put this, it's a "real" warning atm, until we get rid of it ;)
If this module doesn't belong to the active trace of this view, it will never be consumed.
That would probably fix for EAP 7.1 but for 7.0 as the OpenShift profile is probably not set you will not get the proper module name. Can you test with EAP 7.0 ?
do we want eventually to have a writeTo(ByteBuffer) ?
This should have been:  this.out.close();
No need to implement these?
@AlexDBlack is this normal for transforms? Have we changed anything in the data vec transforms you can think of?
Use interface instead of concrete class. Either List<String> or more general Collection<String> as return type
I would not put this method as an example. This API is just... not possible for me. It looks more an error than an API. Is this used by users @wfink ? If 'not really', for me we should remove it from here IMO This API of creating caches at runtime should be changed and I mentioned in the thread in zulip @tristantarrant @wburns
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
Cosmetic: Our loggers across the codebase are lowercase. Could you please change this? Thanks! :)
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
set is a really unhelpful name
Simpler: return new ArrayList<>(new HashSet<>(typeMatches));
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
lets include e.getMessage() to be consistent with other plugins.
This is a clear programming error, right? If so, suggest throwing NPE instead.
do we need to use static on this private method? Please update javac doc
What is this defaultClient for? It doesn't seem related to the resource changes...
Replace 0 with filters.size().
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
It's not a test class that logs; rather, it's a predicate that logs the test class. So please rename to loggingPotentialJUnit4TestClassPredicate or similar.
nit: simpler way: use noneMatch instead of ! + anyMatch. btw, it's better we can also update the matches method of PushFilterIntoTableSourceScanRule
what if a table contain a field named filter ? use str.startWith("filter=[")
It's better we can put sort.copy(sort.getTraitSet(), Collections.singletonList(newScan)) in a single line, which could make debugging more easy.
is everything in this block (inside this if) not the same as the superclass' behavior? If so please replace with super. getSuiteFilter(klass)
I think we don't need to catch the Exception and return null. We should just throw the IllegalStateException and let the caller to handle the exception.
This should go in a finally block in case an exception is thrown, right?
It is shadow copy technically, but all fields are immutable (so there won't be any issue to directly use these fields).
You should leave gender here.
To me, this line seems redundant. Why not pass withStudentProfileAttributes(this.studentProfile.getCopy()) in the building process
don't think we need to put the pair in the message twice, right after each other. Invalid syntax for key-value pair: %s. It is expected to be...
Don't log and throw
Ah, this is also a good example of what would be broken by your change. We should not be requiring that a user be privileged to read the Accumulo services' configuration files.
onLowMemory is public, not protected
Hi @rezita, I think this should be isSHREnabled
why increment both before the check and inside the if block?
Static import the assertTrue?
why this assertion is necessary?
inline please
Please throw exception if ! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If ! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative, the code in the hot loop could be optimized, idForNull could be assigned as soon as selector.lookupName(index) returns null for the first time.
May as well rename this to keep future confusion at a minimum.
Agreed. Maybe an Optional<VarRefNode>?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Should be moved with other not treated cases
Unsigned types are not used in the current implementation. So, you can omit them.
| size > 0?
datalake -> Data Lake
Null check!
This cannot be null. Guice won't allow the constructor to be called if the reCache arguement is null, as the argument is not marked with @Nullable. Or is this null because of unit tests? If that is the case I would prefer to define a mock cache in the unit test since at runtime we always have the cache.
style-nit; no braces for simple single-statement constrcuts
why not use a constant for that?
Rebase error - should be used Helper.getCurrentUser.
Why is it a list of lists, not just a list?
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
Would we want to preserve the previous selection (before archive radio was selected)?
This displays the sender name instead of the account name.
last argument needs to be ImmutableSpongeFlyingData.class.
Make the constructor public
No need for super()
I would suggest answer.toLowerCase() to make secret answer validation case insensitive.
This is not necessary as it is null by default.
What's the identifier for this profile? We may use the username even if that doesn't change anything actually.
If the configuration has been set to false and this configuration is removed again, the default value should be used. The current implementation uses the default / true on restart but not if it gets modified. If I am correct you should perhaps use: <code>autoLinks = value == null || !value.toString().equals("false");</code>
Remove throws Exception
Something per-method needs to assign null to lifeCycleManager.
Take a look at <LINK_0>
fix namespace
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
return StatUtils. sum(toDoubleArray(colName)) directly?
you shouldn't need to cast to double here
do we want to have actual percents? not rates as everything else is in Picard?
delegate can be null. I'd copy the pattern of the code in the other methods like isOverutilized
No extra synchronization needed here because rowCount is already AtomicLong. Unless the intent is to not let shouldStop, rowCount, isRunning get modified concurrently since you are guarding accesses to them by doing synchronizing on "this" .
For Max + Min Size, I think synchronized should be removed from the setter methods and just make the variables volatile instead.
Shouldn't be more like return getConfig(STACK_DEFINITION_URLS); ? this is always different than null as you call this method, and getConfig(STACK_DEFINITION_URLS) is set with a default empty list.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
instead of building loadService in the constructor just a create MutableSupplier (see code in the ltr plugin). Make your QueryBuilders accepts Supplier<LoadService> and call the set method in createComponents when you have everything needed to build your service class. That's not particularly better but it allows to keep dependent services final in your class.
null != settings
you should catch EbodacLookupException too
once again, equals/hashcode - does it make sense? please revisit in all value types you created
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
checkstyle
As Ryan mentioned, you may not want to implement locks like this on static methods. I'm guessing he is checking mappers for null in order to instantiate them only once, as well as set their SimpleDateFormat. Someone else can chime in, but one easy and simple way, while keeping the methods static, is to implement the default constructor with no arguments, then call a new static void method from the constructor called something like setMappers(). Inside setMappers() is where you would instantiate the mapper1 and mapper2 ObjectMapper instances. Then you can get rid of the null checks on the mappers, and instead just return them from their respective static get() methods.
Remove this (ORDER_MAP_ENTRIES_BY_KEYS).
you could potentially avoid unboxing the Optional from the findFirst and reusing it
This section of code has <LINK_0> bug. Which is fixed as part of environments API v2 <LINK_1> PR.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
on IOException|RuntimeException you could add a binary annotation of "error" -> message, as that will turn the thing red in zipkin's UI
You can inline this variable.
this.
Why is it a list of lists, not just a list?
should the message include "command _with options_:" + this.options ?
_sigh_
Can this be private, or is there another use case for default attribute outside the builder's call?
is it better to use name instead of null?
is it better to use name instead of null?
can be simplified with Collections.singletonList(1000)
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
wouldn't it be enough that one of these is null?
This could just be a preconditions check in the constructor, and I would use a different error message that just tells the user that intervals and segmentIds cannot both be set. The current error message I don't think is accurate ("Request payload contains invalid interval[%s] or segmentIds[%s], atmost one valid value must be provided"), since the check is not really for validity of the supplied values but for the presence of both.
Is it safe to set limit for buffer here? I'm not sure. Suggest to get a read-only buffer.
Does EMPTY_SKETCH.toByteArray() result in an empty array? Currently there is a discrepancy between fromByteBuffer() and toBytes() that looks suspicious when just reading the code.
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
Why can't the implementation of this method be pulled up here?
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
suggestion throw new UnsupportedOperationException("Setting a UidHash is not supported for SinkTransformation.");
Make the spHandle human-readable.
Why do you have to check for null here?
We should use StringBuilder here.
Nit: use ImmutableMap.Builder, it's easier to read and modify, as there is no special case for the last item. I only use of() if there is one item. Same goes for the rest of this class (except the usages with exactly one item).
Safer: new HashMap<>(super.getAdditionalContextSensitiveKeywords());
I wonder if we should change this command to receive the device id to unplug - so from the ui the user will pick the device to remove in the vm-devices subtab and UpdateVm will look for the actual device to remove. Because then we could simply lock the device to prevent multiple simultaneous unplug operations with the same device
if you want to make this threadsafe synchronize this copy on fValues. synchronized(fValues){return new ArrayList<>(fValues.keySet());}
This exposes the unicode workaround to the public.
new ArrayList<>(causes);
What do you think about Comparator.naturalOrder() instead of null ?
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
What's the point of adding a copy here?
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
Please add ? and % as well
A data provider with a single entry is questionable. I was thinking the versions would be separate test cases in the provider (you'd have to duplicate the test string which is fine, and probably putting the getBytes call into the test method body) .That way, you could eliminate the rtCheck loop, and maybe the whole method.
Could you please use TextUtils#isBlank here instead of "".equals(s)?
Do you mean s.length() > len?
maybe test first char for empty letter as well to reuse s if possible?
Please make this package protected, to avoid the expensive synthetic accessor.
same question here: shouldn't labelsWidget.cleanup() be included in the generated driver.cleanup()?
This method is removed in the latest codebase
Preferably have one call the other?
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
I think it would be more correct to mock the DAO to return null.
Since the mapping string has no meaning, consider using a random generated one.
the spy is redundant here
this will throw timeout if infobox is not visible. use wait.forElementPresent() instead, but you will have to create By variable from that selector
Right now it will never return false - in case votedMessage is not visible, this method will throw exception after reaching timeout. So please: - make sure to catch this exception and cast it appropriately to bool - decide whether you want to call it and expect false - in this case we probably don't want to wait 30 seconds (or whatever default timeout is)
"Category members container"
I don't think it should be renamed
Unnecessary braces for single statement block (there are bunch of these in this file).
Making a new List, which contains the IWorkbenchWindows and getting its Iterator is not necessary here. I would propose to write: for(IWorkbenchWindow testWindow : testWindows){ testWindow.close(); }
It doesn't right to me to always set a specific result when leaving the PreferencesActivity. This could happen in the UserInterfacePreferences fragment when the font size itself changes. You can call set result on a Fragment's host Activity by calling getActivity(). It would also be nice to write a test for the Fragement (probably using Robolectric) to check that it sets the result on it's parent Activity.
hm, how about "...".equals(intent.getAction()) or TextUtils.equals(intent.getAction(), "...")? [fyi, commit amend + force push are fine]
Please extract this string
Could you please clarify the reason of this change?
Can you make the query (adding some filter) slightly more complicated to show the effect of more rules. For instance "select \"store_name\" from \"foodmart\".\"store\"\n" + "where \"store_name\" = 'Store 1'\n" + "union all\n" + "select ename from SCOTT.emp where sal > 0"
no need to break long strings... check-style has an exception for lines that are just strings
same here, remove TooManyLinesInFunctionCheck
You can probably remove TooManyLinesInFileCheck
Please use static import where-ever possible
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
Is that safe to call when not holding it?
this should be like other errors.. create EngineError key and a corresponding message in vdsmerrors.{java/properties} files then throw a EngineException with this key
This method is not being used anywhere. This class has findbugs failures as well
Why remove the timeouts?
A for each loop on the listeners can be used here instead.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
These might look a bit tidier as static imports
Could you load requested into a local variable here as well?
Math.pow does long to double conversation, which is inaccurate, try (double) 9007199254740993L <LINK_0> then just to convert it back to long (again, inaccurate) Lets simply do r.getDrivingTimeFromPreviousStandstill() * r.getDrivingTimeFromPreviousStandstill() ?
The methods in here will need to use client.couchDbClient.get(...) etc otherwise these will break when it merges to master because of #133
Null return should be avoided. Pair also should be avoided. For such a cases classes are better. In that case you could return class with empty collection of strings.
Use Collections.singletonList() instead?
remove this as this is already done in base class
This shouldn't declare throws Exception.
Should be removed if empty
Can you please use the key aMHOf2rfzUt3fuKkb7DXX8pkBv1AmcBWwwoSfwpt8CMhdUdxXscB4ESOmBPs4NlmYJmFtcSZ3Q5kMxzb. This is a sandbox key that should work (for the build server and for local testing)
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
don't forget to shutdown your executors
I'm a bit perplexed: "dynamicStrict" does not match any field name... I wonder why this works. Anyway... Maybe there should be two different bridges here? It feels a bit strange that the name parameter in configureFieldMetadata is ignored. Same as before: I agree it can work as is, but it's more in case someone copy/pastes this code.
It would be nice if we can also check the error message of the Throwable.
possible NPE?
save an iterator by using index loop?
why not list.stream().forEach?
we probably want to return the set itself in this case even if it's not the same behavior on List.
Exception Message like logs shouldn't be internationalize just use // NLS....
It would be good to pass the exception as a parameter to the HadoopSecurityManagerException constructor.
Nit please alphabetise.
This could be a bit tighter as I think it should be called with account-id and the mockSecurityContext could be made to return known values for the api key and method that could be checked too? That might help assure that the correct values are being taken from the security context?
Please use the generics-supporting Collections.emptyList()
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
No biggie, but I guess best practice would be to do this(Arrays.asList(columnNames));
use ImmutableList
can be replaced by List.of
This should be in.readBundle(getClass().getClassLoader()) to make the build pass. Since we're just passing in strings right now we don't actually need this, but it'll ensure we're future proof (and make lint happy).
Should we add null check?
new fields should be added here, right?
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Missing StringUtils.isNotNullOrEmpty() check
these setters should not be public
Please use getCurrencyBaseLowerCase() and getCurrencyCounterLowerCase() on checkerInfo
Replace URL_TICKER with URL
I would just use pairId here and remove second arguments from URL.
Should use Long.class
I think JPA requires this to return a Long
More functional variant:  java Class<?>[] interfaces = serviceObject.getClass().getInterfaces(); return Arrays.stream(interfaces) .filter(interfaceClass -> interfaceClass.isAnnotationPresent(Service.class)) .collect(Collectors.toList());
ImmutableList.of()
If possible, generally please make all values final. It is one of the main rules to achieve functional programs.
This can be static
it wasn't handled before, but I would also add something like: if(lastColon == -1) { throw new IllegalArgumentException('Invalid endpoint format. Required format is<ip>:<port>.') }
We don't want hostnames\IP's in the labels. So need to cut URL either until any IP or first dot in case of custom DNS.
be backwards compatible
repeated twice
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
I think you can swap the order of the conjuncts because name.equals(other.name) is less expensive.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
You can also use IO.close(bb) as IO.close will not throw any exception.
@Iprogrammerr Please use IsEquals from hamcrest in these two assertions
@Happy-Neko Better to mock InputStream with Mockito here, since it's the only behavior we're testing.
Could you explain why you don't use just true ?
dont think a setter type function should return the "this"
0 is a legitimate option value for min. selectable choices. Why not -1?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
@m-g-sonar if the folder creation fails the test will pass.
Again, use IOUtils.
does this method need to be public?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?
You can put the text that's apart of the first append statement into the constructor of the StringBuilder.
Item dropped should be a hopper
please verify response on remove()
please verify response on remove()
is it sufficient to have this c'tor package private?
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
Collections.unmodifableList()?
ArrayList is non thread safe. We should use a CopyOnWriteArrayList
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
variable named abstractFile does not exist, which prevents pr from building
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Is this stream getting closed? Add it to try block just in case: try(InputStream s = minioClient.getObject(m.group("bucket"), m.group("path"))) {
extract to metod?
mark this method private as this is only used in this class.
Better use Double.isNaN(double) here. Reads better, IMHO.
use ... between 0 and 100., it's more user friendly
Please throw NullPointerException instead (also, use braces for the if statement)
It should be new TajoRuntimeException(new InvalidCastException(...).
It should be new TajoRuntimeException(new InvalidCastException(...).
add the type?
Fwiw, this "checkNotNull" isn't really testing the validity of the value, just that it's non-null.
Typo! You C&Pd this didn't you? cheater! :P
I wonder if adding a bit more information to these messages might not be nicer. Like, "doubleSum" and perhaps the values of name/fieldName just in case something is in one of them to help identify which object has the issue.
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
stream isn't closed
Can we make a SoftEndOfStreamException as an UncheckedIOException to avoid this wrapping? i don't mind for other branches, but at least for the master. Thanks
Use Assert.assertEquals
Don't forget to also check the message itself when there are parameters passed in the message.
The test isn't full. It doesn't prove that async is applied. I'm sure the test will pass even without that async = "true". Please, develop the test-case to reflect the expectations.
Why removing failure? It is the failure reason.
do you need to add CRC here?
The default toString on the List doesn't do the same thing?
Same: performance will tank. Need a small reusable byte[] as instance field. This should be OK, since these methods are already not thread-safe.
Style-nit: We avoid { on if/for/while/etc. when there is only one statement in the body.
I bet our sizeHint is mostly accurate. So lets use that to avoid copying. But fall back into a copying behavior when its wrong: byte[] out = new byte[sizeHint]; int pos = 0; while (pos < out.length) { int read = in.read(out, pos, out.length - pos); if (read < 0) { byte[] res = new byte[pos]; System.arraycopy(out, 0, res, 0, pos); return res; } pos += read; } int last = in.read(); if (last < 0) return out; TemporaryBuffer.Heap tmp = new TemporaryBuffer.Heap(Integer.MAX_VALUE); tmp.write(out); tmp.write(last); tmp.copy(in); return tmp.toByteArray();
These will all break if A or B is null. Recommend using the autogenerated intellij equals + hashcode unless you have a good reason not to
I believe that this is the same as Objects.hash(readName, pairStatus);
If you find your analysis panel starts going a bit loopy (IIRC you said it does), you might want to check your hashCode implementations - you should try to use result = ~~result type construct.. I can dig out the original email if you like?
Preconditions.checkArgument() on all non-null arguments to prevent bad config
I really thought there was a more centralized location to do this addition in the code these days, is that not true? (I might have also only done that with a cli change that isn't merged yet)
This is another behavioral change that I don't want to see in an unrelated PR.
Call setFocus() on the table control.
No parameter in setter method?
This doesn't need to be public it can be protected.
Typo: initCardModeButtons()
Should this be "shouldReturnEmptyString" instead? If so, there are also a few more occurrences of "shouldBeEmptyString" that will need to be edited.
can we remove this method and simply have the poolsOfString.take() where this method is called?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
move it to be aside of deleteFolder
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Fix indentation. Note that jclouds uses 3-space indents not tabs.
Why is there no messageDate here? Was this not generated by yoyodyne?
I guess you mean to pass kryo, not to create another Kryo.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Missing types
This is wrong. getFullPath returns the workspace path (e.g. /org.eclipse.egit.ui/plugin.xml). It should use getLocation(), which returns the file system path.
style nit: no braces around single line
module instead of sarosProject ?
trace
Please change this to "Port XXX is disabled due to conflict".
can't be null?
This will throw MigrationNotFoundException so no need to check it for null.
Include the value or its type in the message?
There needs to be be some action taken at this point to prevent concurrent expiration while an invocation is in process, in particular, when the bean is schedule to be expired by a different member than the one currently performing the invocation.
getServicePolicy shouldn't ever return null. Based on how the Python SDK functions we return a policy object every time. In the case that it is in fact empty ({"factors": [], "minimum_requirements": []}), we return a policy with all the minimum_factors set to false or 0.
I'm afraid this is equivalent to policy != null, it doesn't return false if policy == NONE. I suggest if (policy == NONE) return false; else return policy != null.
Shouldn't be protected as this method is used only in tests + shouldn't be something editable no ?
But existing rows use null not "" for the parentUuid.
suggestion final int layerId = params.getRequiredParamInt(PARAM_LAYER_ID)
You should take srs name from properties. There's something like oskari.native.srs that's used elsewhere in the codebase.
Use isZKLogAvailable() instead
Do we need to swap expected and actual here (and also for the next two as well)?
What is the use of expectedException?
Do we want to use the LOGGER as well? There are other usages in this class where we're using both.
Could return result of getCurrentJson to avoid repeating this line (same for descendRepeatToJson)
wdyt about IllegalState + descriptive msg?
Again, probably out of scope for this PR, but I don't think these andReturn() statements are needed.
Typo: Ant**P**atchersPathVariablesCa**mm**elCaseVariables should be Ant**M**atchersPathVariablesCa**m**elCaseVariables
Both here and in equals I don't think it is necessary to insert getDeviceIdentification().
I am not sure, but we tend to use the returning values of such methods as plain Lists and then eventually wrap them into ImmutableLists over and over again. So if we can declare the ImmutableList as a type of the returning value, I would do so.
Should be in AssertionsForClassTypes.assertThat(actual); the current code being moved to AssertionsForClassTypes (as done for assertThat(String actual))
Should be in AssertionsForClassTypes.assertThat(actual); the current code being moved to AssertionsForClassTypes (as done for assertThat(String actual))
Global listener catch each click. You don't need to log it.
You are logging already logged click.
this is already called in BasePageObject so you don't have to call it
I want to method accessor to be package private :eyes:
Activity state util check before starting any of this, maybe?
Using an Observable in all these callbacks is wasteful in both allocation and performance. I don't see any advantage over  java if (activity == activityToMonitor) { subscriber.onNext(LifecycleEvent.CREATE); }  which is allocation-free.
Can you add the curly brackets to the if calls.
Please use curly braces for conditionals
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Why we want to fall through into the loading dialog in case of error?
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
I would recommend an else if here to avoid comparing against a string unnecessarily.
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
uuuf... each of the Class instance is probably serialized to a FQCN-long representation, that's easily 50 bytes. With 2 classes and 2 wrappers, this is 200 bytes per command. Isn't there a better way?
the topologyId is written/read in the ReplicableCommandExternalizer. no need to write/read it again.
Maybe [] instead of null in order to avoid NPE or check?
Let's do return fDetailedLoad; even if it is always null for now
Please add ? and % as well
Same question about unit conversion as earlier.
But for this case, it will lose numbers under a decimal point.
No, this one was correct... We want to convert the internal delay (expressed in milliseconds) to whatever unit the client asked.
I don't think you want this default. This default setting basically says "If debug mode is enabled (IE: You're on a dev machine), the default for the superuser flag is 'on'". You probably want it to just default to "no"
@phillipm this should be properties.getString(ANIMATE_FORM_SUBMIT_BUTTON, CommCarePreferences.NO) in order to make it default to off
You're already getting a boolean result from this check, so adding a ternary operation of "? true : false" is redundant.
can be omitted
This could be replaced by a orElseThrow call : <LINK_0> But I wonder about the added value of using optional instead of a simple null check in this context as you only wrap into an optional to unwrap it on the very next call.
How does replacing a NPE with an AssertionException help ? I'd rather try to annotate the method's parameter with @NonNull and watch out for "Null type safety" warnings in Eclipse and fix them.
The parameter can bee removed
context.dbName and tableName can be null if REPL LOAD command doesn't take them as arguments. So, need to validate it for null/empty and else use dbName and tableName from OpenTxnMessage.
Need to set it only if !context.isDbNameEmpty().
again, CoreUtilities.noDebugContext
again, CoreUtilities.noDebugContext
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
I think this should be ss.findAllRepositories(streamName)
Please add logging in here for us to have an idea of what is going on.
Why is it a list of lists, not just a list?
can we remove this method and simply have the poolsOfString.take() where this method is called?
This is not time zone?
I've seen other list models doing setWindow(null) as well. Not sure if we need to do it here too, though.
You can refer resources keys directly from the HTML via <wicket:label key="tooManyUsers"/>. The class for the label can be a simple WebMarkupContainer.
do you know what is the diff between this call and LeaderStandbySMD.build()
Avoid using admin credentials
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
here we need to go through Optional.ofNullable(Plaform.getProduct())
Even if you do it in AvdCreationDialog, would you mind adding the SWT.SWAP and the force-relayout thing? A call like getShell().layout(true, true)) when changing the text should force it to wrap properly, as you'd expect the label to behave in the first place.
Please have test for null result.
We could call: java checkNotNull("command", command);  :-)
See below.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
is it not empty if for example type is an valid empty string?
If we're moving this logic from the DAO to HibernateAccount, we should also move the tests from the DAO to HibernateAccount. Similarly for getSharingScope() and getNotifyByEmail().
please move the isEmpty methods to the scimSchema
let's call it updateCodeMinings() instead.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
concat empty str ?
Honestly, I haven't seen TIMESTAMP(0) in BigQuery
where is this used?
given/ execute/ assert
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
IMO better using atLeastOnce()
Optional: can be written in a more compact way: Map<String,String> map = new HashMap<>();
What if obj.toString() throws an exception, for example, an obj has a field set to null that obj.toString() does not expect to be null.
Optional: more compact write possible Map<String,Object> map = new HashMap<>();
This can be replaced with return mDrawerToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);
change string name with drop_client_pin.
Instead of finish(), you can just set the parent of the activity in the manifest to MITMainActivity, that way it'll navigate properly to the home activity
return SUPPORTED_INPUT_FORMATS.contains(inputFormat);
return SUPPORTED_SERDES.contains(serdeName);
MetaModelHelper already does the name check and lowercasing, so no need to repeat it. (Errr, nevermind the lowercasing, that was the old code, but the name null-checking is still redundant)
Should just store the String[] and for open() and getFileName() you return the first item in the array.
This should be moved to: ProcessDownVmCommand
why we need to check for getVm().isInitialized() ?
The exception also needs to be modified a bit.
Based on <LINK_0>, we should name groupName as "flowTrigger", and jobName to be "project_name+flow_name".
why job1?
nit:Can you use _pollDurationMs directly and make _enablePollDurationMillisMetric local?
Can you doc what source and key are supposed to be?
I don't have a strong opinion on the matter but unregisterMetric no-ops if the metric hasn't been registered. This may spare you having to maintain and check _kafkaConsumerMetricsRegistered.
I wonder why we didn't check the class type of obj here. Feel like we are supposed to check as follows:  if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } RemoteReplicaInfo info = (RemoteReplicaInfo) obj; return compareTo(info) == 0;
+static
filename should not be null according to interface (or do we want to allow it?)
No need to catch the exception here, it was already done in the overload.
No need to catch the exception here, it was already done in the overload.
Do we need to duplicate catching the RuntimeException in every overload?
unnecessary change
unnecessary change
unnecessary change
Should this return 0 or -1?
"return position;" maybe?
Seems a bit harsh, I'm guessing the TIFF reader never does a single byte read call?
The code might be more compact. and the while logic not depending on the initial value of "ret". For example: int n; while ( (n = read(oneByteBuf, 0, 1)) == 0); return (n == -1) ? -1 : oneByteBuf[0] & 0xff;
fEndTime maybe? It's "start" as the noun, the start of the trace, not the verb. So the opposite of start is end in this case.
What do you think of the following: java int EXPONENT_MASK = 0x7f800000; int EXPONENT_SHIFT = 23; int MANTISSA_MASK = 0x007fffff int MANTISSA_SHIFT = 0; // ... private void setTemperatureMeasurementValue(...) { // ... int exponent = (bits & EXPONENT_MASK) >>> EXPONENT_SHIFT; int mantissa = (bits & MANTISSA_MASK) >>> MANTISSA_SHIFT; // ... }
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.
Use map.forEach
instanceof check is enough, no need for null checks in this case
if from one run to the next, you cannot find the TIDAnalysisModule, you still won't be able to reproduce the analysis results. you should probably used TmfAnalysisManager.getAnalysisModules instead of trace.get... and throw and IllegalStateException if you cannot find it.
here, to avoid first assignation, you could (trace != null) ? trace.getEventLayout : ILttngUst....
getKey can be called only once. No need to call it for both parameters of getAsync.
not required for the upgrade. Please use separate JIRA and PR.
getKey can be called only once. No need to call it for both parameters of getAsync. Add a line note
How big is the overhead to do this check on every log?
use return ... ? ... : ...?
use constant for UTF-8
Optional
Maybe make this a static final List now that is is used two places? (here and line 123).
Could you remove this please, may be use a logger.
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
I generally don't like publicly exposing new exception types especially as it encourages people to lock to instrumentation code types. Secondarily, the only effect desired is to add an error tag and allocating exceptions isn't cheap. If we think cancel is an error, which is debatable, please delete the exception and just add a tag("error", "canceled"); if there is an existing practice in webflux calling canceled things as exceptions, we could revisit this as well.
Can we improve on this message?
Same here - please move filter and jobType to the sample
Issue is at #5057 .
Check if an entry with the given key (name) already exists and throw in that case an exception.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
Great idea! Can we use Locale.ROOT instead, though?
close already done in Util.read(..)
![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Could you please rename this to listFilenames?
Maybe we're going at this the wrong way, and trying too hard. If you call ProjectJoinTransposeRule on a MergeJoin (which requires sorted input), and the Project does not, after being pushed down, give sorted output, then maybe the rule should just abort. Just a thought.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
same here:  this.left = checkNotNull(left, "left");
Method body should be: return moduleName.replace('.', '/'); without ending slash, because later this path is used in combination with "/module.xml" string.
Could use '/' and ']' to avoid the need for extra NON-NLS
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
There seems to be different order than it should be. Please check it with old message.
It's not good idea. Group 'Registered users' contain over 40k users which will be retrieved from DB. You could better write a hql query to retrieve a limited list of users from given group.
You should pass here message not group converted to string.
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Same typo
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
Any worry about case sensitivity wrt to scopes?
Is there reason for throws Exception in signature?
Why not rather package private visibility? Protected visibility seems to recommend subclassing of DeploymentsOperations. Was it your intention? Why?
we should use URI instead of URL here to be consistent with the other methods. URL also does DNS lookups which can be problematic.
why did you change to final here? should be outside of the scope of the patch.
nit: still Sever here :)
Probably we can move the logic of obtaining the env vars to @PostConstruct to avoid reading env vars on every call
Don't we have to check for the system property first too?
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
should be using the <> here?
any reason you can't just iterate through the values? schemaTableMapping.values().foreach(v -> v.invalidateAll()); schemaTableMapping.clear();
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Member variables should be prefixed with this -> this.databaseClient
I think we should externalize the mapping (reading/writing) of the data into one of Spring's strategies. Then user's can inject their own strategies.
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
Aren't these static strings held and reused? We shouldn't have to charge for the weight of the merge strategy string. Actual memory used per entry is pointer sized not string length.
Should we not use createContentString also in getVersion() (instead of toString()) now that we have it?
I might have been confused, but shouldn't we have a new handleNewSession method that takes a session Id as parameter?
Here and elsewhere, the Fragment probably shouldn't force the host to do things by getting its internals and changing them. The dependency on a toolbar is clear because of the callback pattern but exposing the toolbar directly allows any Fragment to change it. It's ok to defer but consider pushing onSearchOpen() into the host and allow it to hide / show the toolbar.
Optional, but this null could be better. How about defining a SESSION_NOT_SET constant and use it here?
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
[trivial] You can write !stop instead here
failCanDoAction?
Might be worth having a displayName?
Nice2have: make it localizable
Should this be "Upstream Committers"? Also, it might be good to move this to a Messages.properties file so it can be translated.
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Maybe in case newName is null, it'd be better to pass an emptyMap as commandParameters. What do you think?
Collections.emptyMap() will save a few bytes of RAM over a new empty map.
Could you prepend ^ and append $ to pattern to achieve the same whole-string match?
Unneeded parenthesis. You probably can one-line this method anyway :)
static?
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
1. Please export lines 82+83 to a method 'selecetLabelChanged'. 2. Please call the method also before add the listener.
nice catch, I just recently wondered about our handling of singleTop
Please extract this string
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
omit?
The only downside here is that one of these parser will end up existing in each thread. Depending on how much memory is retained by the parser once it loads all configuration, that might be an issue (I just don't know). Right now it looks like we do have 2 instances of those which means 2 instances of parser per thread.
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
nit: can be chained onto previous line's assertion
Could probably replace these hasSize+contains calls with containsExactly, but nbd, this is what the existing code had.
Inline hunter. return BH.fR(..).hunt()
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
just write return stage != null ? stage.getStageId() : null; spare some lines : )
Nitpick, but if you made this have an else block you can remove the thenCompose lambda allocation.
You can use ValidationUtils.nonNull for this.
java new GenerateEvent(interval)
The metatype file says this value has a minimum value of 1. Should we be enforcing that here?
this.currentLocation.get() this may fail, as the currentLocation is not always guaranteed to be set. Check for presence
If a test is going to disable the table (or do things that would interfere with other tests), I'd prefer a new one were created. Though, I am aware of wanting to limit table creation.
could this be static?
remove exists variable and just return !tuples.isEmpty();
@vilchik-elena Why not "firstPart"?
File
We should announce support here, as per XEP-0231  3.
I don't think we want to automatically announce support for spoiler messages. The XEP is pretty clear that if a spoiler message is received the content must only be displayed upon user's request. But this can not, or only with to much effort, be guranteed on the library level. I think we should remove the automatic announcement of spoiler messages and instead provide a method the user explicitly has to invoke in order to announce support for spoiler messages. As beneficial result, the whole automatic manager initialization boilerplate code can go away
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
use parameterised logging
use parameterised logging
use parameterised logging
java this.onPostServerTick(this.getMinecraftServerInstance());
All your injections can and should be private ;)
There is no need to make this injector public.
Could you move the channel creation outside, maybe in getNotification(), right after we call getNotificationChannel() ? If someone overrides this method, the creation won't happen
I think the description string is wrong. Should be the new one for auto download Could you please use the same formatting as the rest of the file, so that it looks more even?
I would suggest putting a more sensible name for the channel name like "Review reminder", the name will show up in settings for people to toggle.
File.separator
do I detect a TAB character here?
file.exists() can throw SecurityException, too. Why the check in the first place? Won't file.delete() fail gracefully anyway?
s/B/b/
this code doesn't seem very safe. If the call to db fails, the class construction might fail, and then it's hard to troubleshoot it, no proper logging, etc. Isn't it better to first get the domain from db, and if it returned OK, pass it to constructor?
This test would be useless if the map had been initialized in the class.
Do you have any reasons of execute SQLs directly instead of executing queries from files as in other tests?
Both old an new logic expect cachedCompare to be within the range [1, size] for cached path. The previous logic generated the cachedCompare like Java cachedCompare = res < 0 ? ~res : res + 1;  Here the Java cachedCompare = res < 0 ? ~res : res - 1;  is used. When entry isn't found ~res produces values within the range [0, size], this range is wider than the expected range, so the fallback to default may be unexpectedly used by both old and new code. When an entry is found, old res + 1 produced values within the range [1, size], it was correct. This range is expected and cachedCompare - 1 is actually used, so res + 1 - 1 = res (previous entry) was used as the starting point. When an entry is found, new res - 1 produces the values within the range [-1, size - 2], it looks like off-by-two error. So one of two paths was buggy and now both paths are buggy (suboptimal). Maybe I'm missing something, please re-check. (~something == -something - 1)
What about skipping parenthesis, so that we still raise issue for the following: conn.setRequestProperty("Authorization", ("Basic " + encoding + encoding))
Do we not have access to the version of junit that supports @Test(expected=Exception) ?
is this tear down necessary? the next setup overwrites anyway, doesn't it?
default is true
Missing 'of'
no need for messages on these exceptions (detail will be available from the stack trace, and these throw statements will have to be removed as part of this review chain anyways)
Please fix your copy/pasta.
@exper0 full path HmRsHeader.VALUES_STR
@pstorch can we describe mismatch better here?
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
delegate to the new method
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
should be ClassCastException e
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
use createTempFile
nit: import toSet static for consistency with toList (see L46).
please make list of strings that will contain internal modules, please place this module in that new list
It is possible we will have other checks join this list. Please move it to a field.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
In case self is a BufferedIterator should this return self instead of re-wrapping?
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
We'd use { and } here or just fold the conditional into a single return statement.
{ }
make this constructor private since all the methods in the class are static.
so if you make this private that would prevent subclasses other than Some, right?
I think this can be private PrestoVerifier() {}
A bit late now, but these should really be KafkaHeaders constants with prefixes (kafka_*).
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
Consider to do this only once in the onInit(). Even if it is void method call, it is still a CPU tick on every single incoming message.
This is a partial workaround, but I think it can be made into a more complete solution: Earlier in this file (in the PageTitle constructor), we split the title string and try to detect the namespace of the title. At that point, we can check whether the namespace is really a language code, and then override the "wiki" member of the PageTitle with a new WikiSite that corresponds to the new language. That way, we can truly *support* language prefixes in links. And one more hint: Android provides a function called Locale.getISOLanguages() which returns a list of all possible ISO codes.
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Should we not use createContentString also in getVersion() (instead of toString()) now that we have it?
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
Let's keep it as it is for the being.
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
This can be relaxed to Type<T> instead of RealType<T>, no?
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
Optional should be used in interfaces. Use null as internal value.
Add reasonable toString() method, returning null doesn't seem as proper way.
the static modifier could go away
Using Collections.singletonList() is slightly more efficient as long as the result doesn't need to be modified, which is true here and and for getDescription()
To avoid issues with leading, intermediate or trailing spaces, use trim() and regex into split: suggestion return Arrays.asList(name.trim().split("\\s*,\\s*"));
Just a heads up - I tried using this in the server and found some dependency problems. You will need to create an integration test, with some suitable source span data, to try this mechanism out running in the server, just to be sure.
Is this being used by the tests? Or used at all? If this code is not being used, and there's no intention to use it, wouldn't be better to throw an UnsupportedOperationException?
Index could return a List<Question> instead of List<Long>, right? The less logic we have on the controller, better
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
Every time we change a JSON test using JSONPath a cute kitten is born.
I believe the Auth system should remain on in this method.
Lines 1068-1088 are redundant.
Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).
This is wrong. getFullPath returns the workspace path (e.g. /org.eclipse.egit.ui/plugin.xml). It should use getLocation(), which returns the file system path.
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
This test data is a bit suspicious. createRecord alternately creates mapped and unmapped records, which means some of the records created here will wind up as "mapped/half-unplaced" and others will wind up as "unmapped/half-placed", due to having an alignment start but no reference index. Those are weird states for test data, and its not at all clear from looking at this method whether its intentional. Not that we don't want to test the "aberrant" cases, but we need a cleaner separation between valid test data and invalid.
Same here. Shouldn't getIds() throw IdGenerationException if the counter value exceeds the range of integer(2^32)? Creating more than 2^32 ids will cause conflicts with ids created by other IdFactory.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
there's no need to call super.close here
You'll probably want to do the other closes even if the prior closes throw IOException
Not ImageJ style.
I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.
ex.getMessage() VS "Feature is disabled"
ex.getMessage() VS "Feature is disabled"
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
Lots of unnecessary this. qualifiers.
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
Please fix indents and use assertNotNull
that seems reasonable. id might not be null in future, maybe better to filter based on INITIALIZING state (or either, i.e. that or id==null triggers exclusion)
static import
all these methods can be private
nit: name = tableName or this.name = name
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Here you can change to Matchers.contains as I said previously.
Same as before. It is pointless to "improve performance" by using code that decreases it. Please revert changes on this file.
Please use Collections.singletonList()
filteredProgrammes is a bad name for this, and as far as I can tell, these should be Episodes, not Programmes by now.
Change to use Iterables.partition and return an Iterable
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
no public
rlly nit-picky: would turn that around from: is our location precise and do we actually have one to do we have a location and is it precise
Should this be compared with || instead of &&?
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
How about "Type is not supported"?
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
Lambda?
You can condense this to DISPLAY.asyncExec(() -> progressBar.setVisible(visible));
Why we should change behavior for the deprecated method?
equals() is not usefull for enum, == is sufficient.
Wondering if we shouldn't fire event in the way we do in CanvasLayoutUtils.fireElementSelectedEvent
I don't see where we handle HibernernateException.
I think this should be final.
I think this should be final.
I think this is redundant (default)
I'm fine on doing this on all server side classes, but in this case for ClassUtils, which is inside core-common module, it's not correct, because that class is also visible to the GWT compiler, and as far as I know it does not emulate the isAssignableFrom method from JRE... That's the reason I remember to do the comparison via classname, which the method is emulated and so we can always compare on js two strings... but feel free to test it guys, if I'm wrong lemme know and I'm agree on this change.
I think this should just return null, similar to the default MyFaces implementation of InjectionProvider.
We have a large number of tests that don't use TestHazelcastInstanceFactory at all and call Hazelcast.newHazelcastInstance() directly (in combination with Hazelcast.shutdownAll() / HazelcastInstanceFactory.shutdownAll() / HazelcastInstanceFactory.terminateAll()). Shouldn't those be checked as well, somehow?
I don't know if you'll take this as good or bad news, but there is no longer need for these uncertainty ranges -- every selection and window range times are now always exactly the expected nanosecond. The method validateRanges() could now take four longs as expected input. For example at line 479, old window was [30,70], we drag 30ns to the left, new window is [60,100].
Please take out prints used for debugging. If you really need to display this information, use the Logger and a String that makes clear what this number means.
Why not? Or it just doesn't support it _yet_ since there's no need?
Usually (especially for loop conditions) I like this style but in this case this is a mask, so if we ever go up to the top bit this becomes broken unexpectedly. Let's use == instead.
Instead of having add and remove functions separately, their code can be brought here and simplified to something like: java private void setFollowing(boolean follow) { threadFollowContainer.setSelected(follow); threadFollowTextView.setText(follow ? R.string.forum_follow : R.string.forum_unfollow); threadFollowIconImageView.setIconColorResource(follow ? R.color.edx_brand_primary_base : R.color.edx_brand_gray_base); }
Seems that empty elses are generated now (at least in Java)
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
Maybe a check here that getLeft() and getRight() have identical schema?
I know this is how the other hash aggregators do things, but I wonder what the perf impact (cache misses/RAM footprint/GC) of IntObjectMap vs. IntIntMap is here. Given that the hash function is MurmurHash3_128, the collision probability is negligible (you would need ~2^64 entries before the first expected collision), so I wonder what harm there is in assuming that collisions never happen?
How can this succeed if tupleWriter.open() isn't called (when dataSink is null)?
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
Please have a look at org.jboss.as.controller.operations.common.Util.createEmptyOperation.
Hey, I didn't ask for copying _everything_ from the code in WildFly Core test suite :-) I think that the original, where response was parsed for status code 500, was better.
elapsedNanos.
Do you need to guard against null here as well?
@nantunes doesn't the compareAndSet already do what line 41 is doing?
extract actual.getModifiers() to a local variable.
static import shouldBeEqualWithinPercentage, it makes the code more readable applies to the other classes
same thing, extract method to check suffix
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
What's the point of adding a copy here?
do not log errors from a util class. Rather throw an IAE or log as debug, if expected and not critical.
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
This could be a bit tighter as I think it should be called with account-id and the mockSecurityContext could be made to return known values for the api key and method that could be checked too? That might help assure that the correct values are being taken from the security context?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
I think there is a race in IndexingService between createIndexes and shutdown where population jobs can be added after IndexPopulationJobController.stop is called. Result will be that we can leak population jobs. It might be that this is guarded for higher up in the stack. But I think this should be guarded for explicitly. Either here or in IndexingService.
Yes I thought of waiting for the assertion. But when it is not possible the higher delay is fine too. The test only failed once of some runs so I don't see it as problematic.
Same as clean_after_checkout: is there no test possible that highlights the difference between clean_after/before_checkout ?
This is unreleated
Yeah, unfortunately the FunctionalInterface->Object conversion doesn't usually go well.
Why this is checkAdminUserAnd403 ? Plugin Infos API is accessible by all users, shouldn't it be apiAuthenticationHelper::checkUserAnd403 ? I looked at the v1 rails API, it too does [check_user_and_403](<LINK_0>
suggestion if (this.currentTask != null) checkAndRethrow();
suggestion if (this.currentTask != null && this.currentTask.isDone()) checkAndRethrow();
Include a failure message argument.
I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions.
may be try-with-resources?
you have lost the cause e
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Remove?
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
timed --> direct
we should probably call EcoreHelper.unregisterEcore on dispose, shouldn't we?
You'd probably dispose your stuff, and call super.dispose() at the end.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
you shouldn't need it as UnknownUserException extends LoginException
These errors here should be sent to the logger (<LINK_0> so they are easy to find and filter
Also inheriting CauseAction should be useful. Please have a look at NaginatorRetryAction#sceduleBuild. <LINK_0>
This can cause problems for some KnowledgeBase implementations when reporting statistics since the list of found causes can contains causes that are not in the knoledge base and hence has no key in whatever database it uses. A QnD way of fixing this could be to not include them in the statistics logging at all, i.e. add them to the list after the stat logging call.
Log the exception and pass the exception into it rather than doing a printStackTrace. Then, are we checking for null after build? Better wrap this into a Runtime exception with a descriptive message.
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
this method deserves a description
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
can be delegated as: getBooleanProperty(key(key))
StringUtils.isEmptry(XXX) if possible
See above. Final prevents overriding.
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
can be simplified as Objects.equals(name, myPojo.name)
It can be like: java if (o instanceof AdHocActivationCondition) { AdHocActivationCondition that = (AdHocActivationCondition) o; return Objects.equals(value, that.value); } return false;  instanceof operator check null value as well.
equals should also check dimension ?
Why do you not return directly the condition value ?
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
likewise, this one can be static
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "StringBuffer" by an unsynchronized one such as "StringBuilder". [![rule](<LINK_1>](<LINK_2>
Minor thing but maybe it'd be clearer to use a different name for the different matchers here, and thus allowing both variables to be final.
You need to specify your "When"s before you actually invoke your service in order for the mocks to work, which begs the question as to whether or not this is doing what it should, and if it is needed.
remove this line
Naming fun: consider using FakeStore or StubStore instead of MockStore - I need to adjust mentally each time I read mock because it is not a mock in fact.
remove when the export button is implemented
It doesn't feel right. Why it is required?
Or we can try to make sure we don't use the toxic TCCL, used inside KeyManager :  java ClassLoader originalTCCL = Thread.currentThread().getContextClassLoader(); ClassLoader cl = originalTCCL; while (cl != null && cl.getClass().getName().contains("org.codehaus.plexus.classworlds")) { cl = cl.getParent(); } try { Thread.currentThread().setContextClassLoader(cl); KeyManager.getInstance(); } finally { Thread.currentThread().setContextClassLoader(originalTCCL); }  yes it's ugly as sh*t
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
You can combine these 2 lines into 1
I think these null-checks are redundant, otherwise we should also check email.isEmpty() and maybe do some more validations. Also, the error message "Identity cannot be null" doesn't relate to email or resending email confirmation - this will confuse the users in case they encounter it.
Since we're tracking this event after the user taps the next button and only when the email is valid, maybe we shouldn't call it "email filled", as it may be misinterpreted as the user just filling in the email input. Does that make sense to you? To be honest, I'm not even sure why we need this event. What's the idea here?
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
I would really like to optimize, but having another sorted data structure would cost more than just having iterative approach
wouldn't it be great if count affects the array allocated in ArrayContainer supplier?
This method is in a non-final class, so there could be code out in the wild that override this method, so we cannot change its signature
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
This method boils down to  java return folder == null || recursiveDelete(folder);  or  java if (folder == null) return true; return recursiveDelete(folder);
This seems like it will cause problems for BamReader.queryUnmapped()
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in isDeleteHorizonSet below.
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
remove else
path.endsWith('/')
This doesn't delete the root, even if deleteRoot is set to true.
nit: I find this one easier to read  requireNonNull(clientTags, "clientTags is null"); this.clientTags = ImmutableSet.copyOf(clientTags.orElse(ImmutableList.of()));
This should make a defensive copy of the list.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Please replace that 1 by a constant indicating what it is.
final
I notice that most of the other models with this method don't use static. Would you mind making it an instance method for consistency? Also, can you see if you can change it to private visibility? I don't think there's any reason to leak this interface out of the package.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
Doesn't String.format need a value to be formatted?
suggestion return Optional.of("org.junit.platform");
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
Here errorMessage needs to have single quotes escaped. The permission error ('You don't have permission to upload media to the site'), for example, causes an error. errorMessage.replaceAll("'", "\\\\'") should do it. We should probably do this everywhere we're sending string literals from Android, since a translated String may contain a single quote even if the default one doesn't.
For consistency with the other tests, keep indention the same as testCharacterWrapperCastToPrimitive() above.
Changes unrelated. Please, revert.
What is this for? Feels like some unintended checked in code?
should this count be parameterized?
Use the narrowest exception required, I think in this case you just need ApiException
throw exception
As a nit, should have a null guard here.
new String() is redundant.
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
please decrease severity to "debug"
please decrease log level to trace or better remove statement
Please use org.ovirt.engine.ui.uicompat.external.StringUtils#isNotEmpty
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Maybe check for if name ends with ':' so we don't do a double one?
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
Feels like this could be less complicated. How about return ((getLabel() == null) ? 0 : getLabel().hashCode()); figuring that Favorites without labels are all equal and where they do have labels String's hashCode() implementation is just fine as-is?
How about return Objects.hashCode(message, Integer.valueOf(desiredCaretPosition)); ?
better cache this to avoid multiple db queries
static
return Collections.emptyList();
I guess you can use feature here instead of contacting separated values.
We shall trim at the final values level but not the above layers. What do you think?
should check that there are exactly 2 items in the array, and throw an IllegalArgumentException if there are not, with a descriptive message.
Use Optional.fromNullable(marker) instead?
should be ofNullable
This should be ofNullable, right?
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
Should we throw an error here?
put an empty line after
suggestion && (((BaArmor) part).getType() == getType());
Introducing a local variable for this is not justified.
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
suggestion logger.warn("Could not remove {} with key '{}': {}", element.getClass().getSimpleName(), uid, ex.getMessage(), ex);
suggestion logger.warn("Could not add {} with key '{}': {}", element.getClass().getSimpleName(), uid, ex.getMessage(), ex);
suggestion logger.warn("Cannot remove provider '{}' because it is unknown.", provider.getClass().getSimpleName());
Don't need this keyword here - the rest of this code only uses this when necessary.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
should this just throw if !hasNonNullValue? We already provide hasNonNullValue, shouldn't the caller inspect that before calling getMaxBytes?
unify the conditions to make this method clearer. Return true or false according to that.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
submonitor?
use multi-catch ?
throw exception
new String() is redundant.
As a nit, should have a null guard here.
Should be immutable by making a copy.
can these parameters be grouped into smaller and more meaningful objects?
We need them stored in the exception as well so that way when we are recovering from a partial get, we know exactly how many bytes were sent/received.
Please remove system.out.println and add assertion
Method should be synchronized probably?
If we use logger then we could append benchmark results to a file for instance...
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
blank line
Do we really want to move this from trace to debug?
IIUC, this means we create 2 KubeClients in the JobManager process? Would it be a problem?
make this synchronized.
This assumes the webcam res == screen size... Not the case. height:width set in reporter seems to be ignored
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
Use Boolean.toString.
I think can just be "isCancellable"
Don't we need to do the caching here?
If fileContext is not Cacheable then caching should not be used. hiveFileContext.isCacheable() would provide information at runtime if the caching should be used or not.
note: Generally having a composition based factory is preferred. However since the ORC writer is already implemented this way - let's keep it so for consistency.
Should this not be nested-projects?
:bug: surely you meant delegate.getCategoryId()?
Better to return "";.
NIT: Paths.get("src", "hello.rs")
Please.. take this one out.. it's just a debug.. never used in real life.
NIT: Paths.get("src", "Cargo.toml")
The property cannot really be changed at runtime can it? So why not put it in a static field and avoid the repeated lookups.
Are you sure that you should check value on null here?
Please add braces
Should this link to the course?
Return the zone id here instead of returning an empty string.
Let's make this value a constant.
Consider to move into constant variable into SAMLConstant
There is an INVALID_NAME type you can use instead of OTHER. (Same for the NAMESPACE validation method).
Could we rephrase this to say, the routing data is either _empty_ or invalid?
missing @Override declaration.
Add shared state
Oh yuck. ;)
What is purpose of this method?
Really? Don't we need something concrete here?
Need to implement
"==" to "="
Be aware of close() issue, ie: input.close(), output.close(). I cannot remember if we need to do that. Please check the IOUtils.copy() to do so.
Seems to be unused now.
nit, Collections.EMPTY_MAP?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Don't we have to say that this is uniqueId JDBC?
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Same code as in the method above, factor it out?
Should be a SamzaException with a message, not NPE.
Only thing I've got here is that perhaps when you use this approach of design (interface - implementaion) then the implementation class should never occur anywhere in the code except for the constructing. So maybe a factory, or factory method would be more appropriate and the suggester service would be a part of RuntimeEnvironment? The point is that the concrete implementation is always hidden to the end user. If it cannot be done, leave it like this.
& let's not forget about this.
It is best practice to use editor.apply() as commit() should not be called from the UI thread.
Unnecessary log.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
We're checking event.error != null twice here - but we can actually drop this entire line, since event.isError() above is actually a event.error != null check.
I am really not sure I like the fact that we have CQL statements in different places now. Could we collocate all the job scheduler CQL statements in a single place? This could be addressed in a different PR as long as we open a JIRA.
new ArrayList<>(causes);
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
we should return immutable list. You only expect caller to do read operations, right? #Closed
Collections.unmodifableList()?
This field is exposed to client code by getViewsToChangeBoundsRequest(). Changing it to a WeakHashMap is not a transparent operation, and changes the whole contract. Extract from the Javaodc "this class behaves somewhat differently from other Map implementations.[...] several familiar (though not required) Map invariants do not hold for this class. Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries". Have you actually checked that all client code which make use of the data in this map is ready to deal with missing entries, and handle that correctly (not just by not throwing an NPE)?
ImmutableList.copyOf each of them?
We could just always use the body instead of flipping based on the payload size.
Move both to variables for consistency.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Use HttpServletResponse.SC_METHOD_NOT_ALLOWED instead of hardcoding 405 please.
Should this be called id instead of store_id? Its a param and it shouldn't matter what it's called I suppose, but, id is the key we use in the response.
Can we invert this, so GET and HEAD are allowed, everything else is denied, prevents accidentally opening up anything else?
should be in separate PR i think
We could omit the second Integer.
working with prefetched columns should be faster (and more stable) than using findElements every time
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Tangentially, we should likewise install the backup service as ACTIVE, so that it toggles to NEVER instead of ON_DEMAND as well.
If we return inside the case clause, we can get rid of the res temporary variable, the breaks and the last return line. switch(format) { case LEGACY: return renderLegacySize(size.longValue()); ... default: throw ... }
Case 3 is redundant
consider a cleared state, in which we subsequently added a null. Why is the size == 1 ? I'm asking since it seems size is being evaluated to see if the association object should be removed.
What if fileName doesn't have any .?
@pwillworth why not use File#separatorChar ?
Missing codes.
There should be a corresponding JsonProperty getter for this
Is there a reason why you don't use [Collections.emptySet()](<LINK_0> here?
DTOs should represent what came from the exchange, this is premature adaptation and should not be here
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
suggestion assertKeyPair(file, null);
I would suggest making this method synchronized
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
nit, Collections.EMPTY_MAP?
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Why not make this create simple string and then invoke the setAddress(simplestring) , there by not needing the two new methods and logic encapsulated in the setAddress(simplestring)
Better to rename RoutingTable.removeWriter to RoutingTable.forgetWriter?
Oops, good catch!
please extract to a separate method
did you verify that flow? I'm not sure if the cluster is set on the template we get in the parameters
You have two DAO calls here, which is a shame. You can make one DAO call, get the DiskImage object, and pass its isWipeAfterDelete() and getStorageType() to ImagesHandler.
This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item.
IMO this should move to the presenter in the first place.. i.e. where you call view.init( this ) add the next line that calls if(this.canUpdateProject()) { view.enableAddAssetButton( false ); }
Why not inject this?
Add a message to the checkNotNull. It helps in debugging. The canonical form is:  java foo = Preconditions.checkNotNull(foo, "foo cannot be null");
I wonder is there a reason this is specifically a BlockingQueue? We don't block waiting for elements to be added, we instead use the semaphore and we don't have a bounds (besides Integer.MAX_VALUE). Can this not just be a standard ConcurrentLinkedQueue ?
Could we have two constructors? One with and one without an executor? This way it is obvious to a caller that they executor is truly optional.
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
"This method is not actually very useful and will likely be deprecated in the future."
Stopping and restarting a clock will fire two events. Have you verified that this does not cause unwanted effects anywhere?
Consider returning a constant
@Nadahar Right, text/vtt, i was too fast...my bad.
Should maybe other countries be added here?
does this method need to be public?
I don't think the process deploy should fail in the case of temp file deletion fail
You can safely remove the file.exists()(implicitly done by isFile
Same thing here. I don't think mProducerContext != null should be a precondition -- setup() may have thrown an exception and we still want to do our best effort to cleanup by allowing super.cleanup(context) to be called.
Generally speaking, there's no need to null out the fields of an object if no one is going to hold the reference to the object afterwards. The GC is going to do its job, you don't need to help. :)
there's no need to call super.close here
I'd feel better with this if this method was still protected. Why was it made public in Netty 5?
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
same here, why only these two methods?
run -> status
.in should not be in jar, it is template for makefile.
Would be great to have it part of the TestableObject directly; so when we change the build tool one day, this feature would still be present.
Can you reuse the scan variable? That will save connection time for every request.
This can blow up logs. Might be better to enable at TRACE level instead.
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
These might look a bit tidier as static imports
The only reason you had to override next(), expose pendingObjects, and duplicate all of this code was for this r.has(BOUNDARY) test? Any way we can skip that flag test on the commit?
Probably want to add the filter here: if (objectFilter.include(this, r.getTree()) pendingObjects.add(r.getTree());
Constructor should be private. Make a static factory method
Ditto missing trailing dot. This might be happening elsewhere as well. I haven't checked
Can this be private, or is there another use case for default attribute outside the builder's call?
This logic would be better: if element is an anchor, check for class, else check for attribute.
suggestion LOGGER.warning("DNS multicast capability has been removed from Jenkins.");
suggestion this.install.classList.remove(DISABLED_CLASS);
Use java.util.Objects.equals().
This should be both .class and .this, because this should allow us to get all debugger events dispatched jobs or only for the current dispatched.
Rather, I would recommend to move the JobNode.CONFIG_JOB_PREFIX to JobConfig and use it here, instead of hard code the string.
public
Same here: should be Branding, not ProductBranding
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
responseStr might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
Just throw it upwards.
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
According to the current way how those methods are implemented, it should be return false
just return m_closed.
Should this be one line down after site?
(Boolean)null -> boolean = NPE. ParcelCompat.writeBoolean() works with primitive types, we use object types to have three values.
I think this second parameter is meant to be flags and should be passed to the parcel.writeParcelable calls.
no need to assign the client to a var here since it's only used once; could collapse these 2 lines to 1 instead
These two lines can be simplified to:  for (StreamDefinition definition : findAll()) {
I don't see anyone calling this explicitly. Should the removal of Paths.build(Paths.CONTAINERS, id) happen as the ephemeral node removal?
This is not testing the frontend.
remove red
Since a single String string is required at each test, please use following code: suggestion return Stream.of("", "Knuth", "Donald E. Knuth and Kurt Cobain and A. Einstein");  This is more readble than String[]. The return type will be Stream<String>.
There is only one form indeed and a Flux read makes no sense but the method can produce a Flux, i.e. Flux.from(readMono(..)), even if it will never have more than one element..
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
I don't see the api for CosmosContianer (sync version). could you please add that too.
please put each parameter in separate line :)
Should we do three separate queries, one for each filter?
It's easier to read if expected values are provided.
why rewind?
nit: you can merge both lines above as checkNotNull will return the given argument
Add Gst.checkVersion(1, 16);
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
This method can be private too
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
why u did not update status of device as plugged/unplugged?
why we need to check for getVm().isInitialized() ?
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface ?
please use the other methods shorten format: i.e. return ValidationResult.failWith(VdcBllMessages.VDS_NO_UUID) .when(StringUtils.isBlank(host.getUniqueId()) && Config.<Boolean> getValue(ConfigValues.InstallVds));
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
Another place where the name should probably be updated
Is there a reason for not using the MoreObjects.ToStringHelper instead?
if getSessionTags print warning - this one should also do so
why null?
Implement this
getParent() can return null
This is the only place that add entry to the pool, is it the only way to fill the pool?
We need to be careful here because we're adding a node to the parent node outside of any synchronization block, which could cause problems.
nit: imageName field can be changed to DockerImageName, to make tests' bodies a little bit smaller
suggestion removeImage();
You're not checking if the ItemStack.isDamageable().
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
Wouldn't it make sense to check the argument in front of using it?
This should incorporate the standard clock skew accommodation: <LINK_0>
does this need to catch all exceptions?
I would just do e.addInfo("At line: " + lineno) as the exception message is already in the exception itself.
It would be nice to have a configuration file locally, like looking to see if a ~/bridge-sdk.properties file exists, that would override default props. Then environment variables can override both of these (don't know if Apache config does this but it looks like you're doing something like that here).
can we use here some simple words like variable, parameter, instead of cryptic lc1?
Please move new code block to the end of file so you will not have this change
This is outside the scope of the issue, but please - this import in file and duplicated violation, please remove them.
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
I would change the isStar method by containsStar rule to cover: java @CrossOrigin(origins = {"*"}) // Noncompliant  and java @CrossOrigin(origins = {"http://localhost:7777", "*"}) // Noncompliant
This.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
This code duplicates method isSwitchRuleLambda. Should this method be used here?
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
an expensive way to check if it exists ... if there's no other way, then this will probably do
How about narrowing it to ClassNotFoundException and fail with other exceptions?
consider to inline uris
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
You can use CollectionUtils.toImmutableList
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
Will * <LINK_0> * <LINK_1> work as well?
Should be private, could also be static.
Remove this
I think this also should not change if the accuracy isn't better, since otherwise we are updating the location in the background but not changing the reflection of it
Same: static import lightGray from Color?
style-nit; no braces for simple single-statement constrcuts
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
if the advantage of this compare to 0 <= b && b < 256?
what if none found? are we sure there is at least one?
I think a variable should be introduced for this long expression.
please don't use in middle of method return
why exit here ?
Why is this needed?
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
It looks like you are returning an empty ArrayList keys
We could omit the second Integer.
I don't know why that logic was there, looping over all the the datasetPhenotypes. This is a nice improvement :+1:
static import
wrap
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Shouldn't we throw here?
It is the same in this line, leave a blanck space before "+"
All actions from
This should be "isSetReboot". The reason is that we don't even want to call the backend method if the user didn't explicitly provide the value, as the backend method may have side effects (very unlikely in this case).
Use "guid" instead of "asGuid(id)".
in /export action we use action.isExclusive(), please do the same here.
use instead, please, implements IntegrationEvaluationContextAware
No, this. when you call methods.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
I think you can now drop !callGlobalsOrLocals && !hasWildcardImport on this line.
typo
this should be extracted to a method
We should not catch generic Exceptions. Can you make this more specific?
Actually as Part of reusability we have added Synchronized block inside TrapReceiverImpl.addToSnmpV3Users and same we are calling here.I hope this serves the cause or If still synchronized is needed even for this block i can update it.Please let me know if its necessary to wrap here as well.
Create new lists rather than assigning them.
If these fields were configured macros, then config.fileSystemProperties will not be set in the constructor, you will have to set it in prepareRun in that case.
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
I think it would be more correct to mock the DAO to return null.
please use for the positive tests the following convention: assertThat(validator.shouldVdsBeFenced(), isValid());
brr... I don't understand this ctor. it should do just this: this(new RqFake(), dispositions). why it's doing something else?
@dalifreire making a static method is a workaround not a solution. Here you could store the stream as a field and create Channel in requests method and pass the created variable to copy and make.
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check !getClassConstantOperand().endsWith("LocalBroadcastManager") can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
No, this. when you call methods.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
nit: you can merge both lines above as checkNotNull will return the given argument
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
Could we rewrite this method to make more sense like so: java try { Twitter.getInstance(); // Check for initialization } catch (IllegalStateException e) { initialize(context); } signOut();
Shouldn't the restoration be in the reverse order of the activation? So that we first restore the last activated context?
This check is unnecessary. context can never be null for a properly constructed object.
throws Exception should be avoided. Ditto for next 2 methods.
@sebing let's use try-with-resources feature here since we're now on Java 7. Make sure to include both input and output.
ServerSocket implements AutoCloseable which means you can use try-with-resources to close it. Also is there any reason to close the socket twice?
bad selector
You can use MoreObjects::toStringHelper().
helper.getGithubHelper().
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
Shouldn't errorContainer.setVisibility(View.GONE) also takes care of notificationButtonView since it's a child of errorContainer (Not putting this for other use cases, but should get corrected for install and update as well if we do it here)
Please also add a feature flag here to show the editing option only for pre-beta builds. (ReleaseUtil.isPreBetaRelease())
please add call to populate: addLinks(populate(connection))
Please extract method here, this is copy paste from lines 140 - 146
Better to put the call 'setPayload(vm)' inside the method populate(). That's what this method is for - it adds any information you want to the collection objects after they have been mapped.
We should also check the servers which we want to update the hook content is in UP state.
failCanDoAction?
The above two checks can be moved to a common parent class, as the same is repeated in GlusterHookStatusChangeCommand as well.
This should be at least a constant, and more probably an instance variable.
Aren't there cases where people might be changing/removing breadcrumb metadata in a callback? The case which comes to mind is intent extras from the EventReceiver.
It is not possible to change field after instance creation. Why you create unmodifiable map each time this method is called? I would prefer use it once.
I think we need to read stdout and stderr of command here. Otherwise it can never exit.
We don't need the positional arguments here. Same for the other format strings.
you can catch multiple Exceptions in a single catch block
nit: you can merge both lines above as checkNotNull will return the given argument
requireNonNull
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Same here... completeLoadRequest(request) ?
Instead of using String += otherString, it's more efficient to use a StringBuilder and .append() (especially when in a loop), then return sb.toString() at the end.
PlayerBackpack is redundant here, no need to specify the class you are already in.
Why '-lock'?
Since this method no longer throws an Exception, should that be cleaned up? There may be other methods to which this clean up might also need applying.
As Ryan mentioned, you may not want to implement locks like this on static methods. I'm guessing he is checking mappers for null in order to instantiate them only once, as well as set their SimpleDateFormat. Someone else can chime in, but one easy and simple way, while keeping the methods static, is to implement the default constructor with no arguments, then call a new static void method from the constructor called something like setMappers(). Inside setMappers() is where you would instantiate the mapper1 and mapper2 ObjectMapper instances. Then you can get rid of the null checks on the mappers, and instead just return them from their respective static get() methods.
automapSubProcess(..) ? Maybe not the best name.
As above: private, 100 chars, use error result instead of doOnError.
Alternatively you could use: java this.overlay.toBack();
Also for the lane I would use a bigger min width/height values rather than the actual 50, probably some value like 200x200, I say this because a lane is considered to be a container for other elements, so minimum size should be much bigger than for example the task one... just my opinion :)
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
the formatting is off here, not matching the rest of the project (disable "Align when multiline" for "Method call arguments" in your editor code style). Also the same in other parts of this PR
This method has an external annotation now.
Can have a isRef(Expression) and isLit(Expr)
I would suggest to declare at least callExpression.arguments().get(0) in a variable to avoid all this casting
isValid should also check that coordinates.get(0) and coordinates.get(1) are not null?
Better use switch-case Throw a new Exception for the default-case.
The NO_OPTION test isn't needed given you test for YES before taking action.
ChronoUnit.YEARS.between returns the whole number of years between two dates. This isn't the same logic as before (but perhaps *roughly* the same logic).
Just to be safe, and since I intend to delete our @Nullable, can we just put the string "Nullable" instead.
this will be called for each assignment twice on startup: * while warming up the cache * when events from ZK start to come in I think we should protect against this kind of obvious duplicates.
i think we could check if this assignment was ever added, no need to do the job on all callbacks
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Exposing PojoProperties (an internal class) to API
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
Let's add the partitions parameter to the message as well and verify the expected partitions are revoked.
Is this an outdated debug statement? If not, maybe add a similar line to onPartitionsRevoked() ?
We can validate only if validation is running?
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Shall initialise using newArrayList(txnId) instead of 2 statements.
@mikerhodes do you think percent encoding slashes in the db name makes any sense? It doesn't really matter what encoding we use as long as it's transparent to the user. We could just map / to any other forbidden character like . etc
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
will this remain package private once we have the next PR as well? Or will it be a private one?
They are mutually exclusive? Or is that a micro optimization?
change to List
change to interface List
well, I would prefer list.toArray(new String[list.size()]) - you save one instance :)
please extract method : protected GlusterVolumeInfoDao getGlusterVolumeInfoDao() The reason for doing this, is so you will be able to write a test using mockito (and not pockermock / static mocking) for this query.
use getDbFacade()
please separate to a method, getVmTemplateDao() and use getDbFacade().
Speaking of sanity checks, is this: (100 - lastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
Maybe we could replace this long function name with an overload instead? Kind of like extending the contains operation to lists.
Maybe just have an unbounded end factory in HistoryQuery, it looks like this is causing a lot of friction
"quality_gates" => "quality gates" as it's what is displayed in log for user
Are locks needed in Build and Merge Aggregators alike?
I do not like this check at all. What if we want a screen free from animation?
If the o1 is diff than null, o1 must equals o2. If the o1 is null, return "o2 is _diff than_ null" ? I think this second part is wrong?
I think the correct translation for "null" is null, not a blank string
Should be "else if (o2 == null)" only, shouldn't it?
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
Please provide a test with multibyte chars in the message body.
Minor nitpick (s/exist/exists)
Please considert moving this to line 238, and change this to positive condition
formatter?
why do we want to restrict it? the error messsage is relatively harmless and doesn't really alter the flow
Why is this private, when addFiles does the same thing and is public?
Minor: please move private utility methods to bottom.
have you tried Collections.emptyIterator() ?
These should get saved in a data structure so that repeated calls with the same name return the same map.
This method should return RemoteCache<K, V>
This method should return RemoteCache<K, V>.
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
could use matcher.matches here I believe
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
Why create LinkedList?
minor: can be package private
Make it final static
The newGuidInstance() method is redundant - you could just use: BusinessEntityComparator.<DiskImageDynamic, Guid>newInstance().compare(this, o);
Checking both JsonNode.equals and doing a string compare on the string representation is not so good. Does JSON have the concept of < and > comparison? Should we always rely on string equality to mean node equality? When would that break down? If that works, we should perhaps consistently check that for equality and hashcode, etc. If that doesn't work, we may need to introduce the concept of a type that doesn't support comparison, but only = and !=.
nit: we could extract this into it own method or extract the message in a constant to avoid duplicating it bellow.
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
It might be worth mentioning that if there is a partition-level failure, then the first one is returned.
why not just repo?
This method should be private in visibility.
@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Can this be private, or is there another use case for default attribute outside the builder's call?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Why not just return the condtional?
There's no point to else here...
This is still wrong for HTTPS. S3Proxy has both a getPort and getSecurePort accessor. You should probably just create this URI once after s3Proxy.build().
Not good to use Optional for collections, just return empty collection
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
This should be ofNullable, right?
This check does not belong here, this method should never be passed a null value...
We probably could return a shared instance for this as well?
target might be null.
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
Is someone going to look into this TODO?
Might be nice to inform people that the update handler will be removed entirely, so that they know that they cant expect any further updates after this.
Question: in the normal login scenario, reuseSession is called right after setSessionId. As both reuseSession (using getSessionId) & setSessionId are async now, I think we should utilize result callback when doing setSessionId, and only after setSessionId completes (result callback executes), we should proceed with reuseSession. This complicates the current code a bit, I can help with modifications/testing here.
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
should be mItem
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwnerByName_
The typing is not aligned with the declaration in RMRestInterface interface. Please confirm it's OK.
Cast to string can be removed
introducing double retrieval from thread local, unnecessary perf hit
This seems to be duplicated from Scope.getVarDeclNode.
IMO, this method should be removed, no need to have a getter in a builder pattern
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
sounds like it could be set on error level
If I understood correctly that empty result is a "non-standard" path I would invert the if.
How big is the chance that the heartbeatScheduler AtomicReference returns null? Should we cover for that by logging something or throwing an exception?
How big is the chance that the heartbeatScheduler AtomicReference returns null? Should we cover for that by logging something or throwing an exception?
Why is it a list of lists, not just a list?
Local variable could be declared List instead of ArrayList. Is this worth caching?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
better use a local variable for the return value instead of modifying the argument
check that charAt(1) is a . ? (and is also at least length 2)
This method should also saturate to MIN_VALUE when overflowing on the negative side. In case we trace dinosaurs.
Unfortunately, this cast doesn't work. Even if it did, not all the returned columns are longs (the AVG ends up as a double). From my fairly rudimentary knowledge of JPA, mapping the results of a query to a POJO without involving an entity or a bunch of XML is a bit of a pain. Using a native query makes it more so. However, your query is not actually beyond the capabilities of JPQL, so we can use plain createQuery. Something like this should allow us to get a PerformanceReportEntity object out:  SELECT NEW uk.gov.pay.connector.model.domain.report.PerformanceReportEntity(COUNT(c.amount), SUM(c.amount), AVG(c.amount)) FROM ChargeEntity c WHERE c.status = :status  But perhaps someone with a better grasp of JPA than me may be able to offer a better suggestion.
Are there any checks to avoid a case where both of these attributes are set? Can something screw up if that does happen?
Merge this with the loop above. You can still return false on a ResourceConflictException. Any OrmException should still be logged, though you should change log message to be a little more generic.
I would prefer to add a finally block to the try/catch, and close the cursor there. This would involve moving the declaration of the Cursor object outside of the try/catch, but is a much clearer model. Same for the other file. Also, please prepare the PR against the dev branch rather than master.
I think we might need to have the prototype factory available here. I don't think it's relevant today, but it's best to avoid ever deserializing without it available.
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
I think most of the callers of normalize() convert the String you return to a BytesRef. So maybe it would be better to drop the extra utf8ToString() call and make this method return a BytesRef directly?
Couldn't we always use Instant.ofEpochMilli( value.getTime() )? That would spare us one instanceof.
- log warning that option is not supported by SNMP
Why we return AsyncClient here?
Based on how it's used, it's more like a listener not callback.
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
should the message include "command _with options_:" + this.options ?
Should probably set a field with this value
something like "fallback-photo" is probably a better fit here
:ant: Why the itemcategory- prefix? Should just be uncategorized or standaloneprojects.
somewhat confused, if you've specified serviceName you can no longer specify sid meaning that you get screwed over here whenever you call namespace i.e. you go from having a namespace to *not* having a namespace. What are the implications of this in atlas? If anything it feels like getConnectionDataString should return the service name if it is specified, otherwise it returns the sid and that sid is *always* provided OR that if you specify serviceName, then you *need* to specify namespace explicitly when migrating over. Let's chat about this face to face.
I would prefer a use of Collections.emptyList() here, there's no need for this array list.
Exceptions.propagateIfFatal() Could we be stricter about what exception we're catching here?
We could probably just pass the existing ImmutableTimestampSupplier to the Scrubber - it feels awkward for this class to implement Supplier.
Is this one of those @VisibleForTesting things? Seems unnecessary
I don't think it should be renamed
I think you can plug in the User directly as a method argument. @MatthijsKok figured this out somewhere. Maybe we can even make it a Class field as every method in this Controller needs the User object.
do not assing parameter! nowhere!
Can you help me understand why you changed the scope of this method (along with the other methods listed in the PR)? It does not seem to align with the goal of the ticket to me.
Is there a reason for this to be protected?
make this private and move it after public constructor
(int) -> toIntExact (from Math)
This should be the check class.
Not necessary.
Why does this test have two entity dictionaries? Elide is really intended to have a single dictionary.
Can combine the 2 above lines and use the constructor which accepts disk-id
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
why this is in vmCommand? should be in stopBase command
With the recent writer change, I don't think this needs to be exposed any longer.
There's a formatting issue.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
you should use here acquireLockAsyncTask(), we need to acquire locks only for commands that require to hold them for the entire execution flow (including endAction()).
This makes the action no longer work on multiple repositories. I'd prefer not to regress here.
this should be true when index == 0 to allow optimizations for this particular case.
Should make this ObjectMapper instance static. For this method should use a writer(), for the deserialize case use a reader(). Does the mapper need any configuration to handle empty/null values?
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
same as above for log message.
Minor: Use this. consistently in the class.
Create new lists rather than assigning them.
If these fields were configured macros, then config.fileSystemProperties will not be set in the constructor, you will have to set it in prepareRun in that case.
Remove?
you have made all the above code with ImmutableList.copyOf() why not here also
I guess this can be replaced by a public CommandImpl(String name, String commandLine, String type, Map<String, String> attributes) constructor call, what do you think?
Dangerous to call callbacks under the inner lock.
Not related to this PR, but I think we can already replace kubeClientExecutorService with AbstractResourceManagerDriver#ioExecutor.
Minor: we can deduplicate the codes by generating the singleton list before switch.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
"has expired" "{}. Re-requesting again"
suggestion
I really don't like the user of instanceof. Why not overload the method to recive VDSExceptionBase? In both places this function is used, you already have that information.
nit: It seems a bit funky that we use static instanceof here but isInstance in unwrapAndThrow... - the methods do the same thing but we need the latter for throwIfInstance. We should standardise on one or the other, I'd prefer instanceof as createPalantirRuntimeException already uses that.
why this null check ?
is this going to result in a null reference exception? I think you can mock something for this.
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
@guiseco you don't need to check the validity of the position argument here, since it's based on the getCount() that you overrode above.
It would be useful to have such operation in seleniumWebDriverHelper class: waitAttributeEqualsTo(By element, attributeName, expectedValue)
How about asserting the expected TimeUnit as well?
suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
If the objective is to make sure the caller can't modify the properties after constructing this object then you'll have to create a new map.
@Nullable on this getter? Or, maybe we should just always return it, even if empty. Also, now that we have a mechanism to modify the map, maybe we should return an UnmodifableMap - if so, it should be a field instead of wrapping the map on every call.
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Reminds me of containsKey() :smile:
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
I think this should check that also the non coded value is not blank, we normally user StringUtils.isNotBlank
wait.forElementClickable() should be used before
Please make sure the button is visible or clickable.
wait.forElementClickable() should be used before
return SUPPORTED_SERDES.contains(serdeName);
return SUPPORTED_INPUT_FORMATS.contains(inputFormat);
MetaModelHelper already does the name check and lowercasing, so no need to repeat it. (Errr, nevermind the lowercasing, that was the old code, but the name null-checking is still redundant)
wait.forElementClickable() should be used before
wait.forElementClickable() should be used before
wait.forElementClickable() should be used before
use return ... ? ... : ...?
use constant for UTF-8
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
Which type would be assigned in this case?
Why don't we make inDegrees to ConcurrentHashMap also?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
should either read: "Must set either both SslSocketFactory and TrustManager, or neither" or "Must set either both sslSocketFactory and trustManager, or neither"
You need to also reject if keyStorePassword is present but keyStorePath is not
sorry, missed this first time through, I think we want to error if the URI contains the empty string, can we have a check for that somehow?
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
the tree is necessarily a NewClassTree here, so you already know it's going to be of the good kind. You can drop the if.
uncessary call to super. No need to visit further.
Should assert on the message contents to make sure it's the right one that got through.
Could you change this into assertEquals(expected, result) ?
Formatting issue
this is confusing, it is called router but actually it is routerUrl.
Not provided the Locale in the first argument can cause issues depending on which user the Locale has the app set to. I ran into this with the Simperium library.
Looks like you are making double slashes here...
The classical hack is to implement read() like this: byte[] b = new byte[1]; int n = read(b); return n == 1 ? b[0] & 0xff : -1; Its almost never used and this form is short and easy to read.
off should be p here, and since len isn't adjusted during the loop this should be len - n. This sort of bug is often why I just modify the arguments even though this is against the JGit warning policy in Eclipse. Whoever enabled that warning in our project settings is a bit too paranoid and in many functions trying to follow it actively hurts the readability of the code.
buf.capacity() would also work. And has symmetry with what you do in the constructor to make buf.hasRemaining() false.
Add a condition to the log.
Why Level.CONFIG?
Should this be in the try? For consistency, have the LOGGER messages in the same place for the start and stop functions.
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
minor: define: "__samza_checkpoint_ver_%d_for_%s_%s" and static final?
style nit: we don't use braces around single line blocks
suggestion return Arrays.toString(value);
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
It's better to introduce a new variable to complex stream operation and use string format for a final message
rename to segment
Should return true if super.hasIncomingChanges (the parent section may contain attribute editors directly, e.g. the bugzilla attribute section has attribute editors and also a subsection called Flags).
For easier maintainability in the future, I suggest having curly braces for this if condition.
Simple test is also possible to verify result stat. See #971.
We could stochastically test it.
This shouldn't declare throws Exception.
this looks backwards. If (!keepExtensions)?
filters method argument should be passed to isMessageInLogFile as an argument
is0D0Amode is always false and never true, then why we need this flag?
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, "name")); // THEN verify(failures).failure(INFO, shouldHaveAllNullFields(jedi, list("lightSaberColor"), list("name"))); }
refactor the test with AssertionUtil.expectAssertionError as in <LINK_0> Could you also do that for other should_fail... tests ?
extract actual.getModifiers() to a local variable.
println should be changed to a logging message
Consider @Restricted(NoExternalUse.class), I see no reason to make this public API.
Do we need to limit this to .in/.win for Makefile as we did before?
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
No new line. You can actually drop the whole else if and only keep the mVersion check as early abort. getVersion() should never return null this would lead to unforseen behavior of the other methods. It actually can never return null as we can never reach this if mPkgInfo is null (Constructor would crash).
This block could be shortened if using Ordering.nullsFirst()
can you add @Nullable as method signature
to be fixed.
return address.map(ImmutableList::of).orElse(ImmutableList.of());
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
Let's use debug level instead of info.
Encapsulation
The synchronized can be removed.
The ListenerList implementation already takes care of this. Remove the "contains" test.
The methods to add or remove a listener are usually thread-safe in Smack. This is not the case here.
Same it's 1 field.
Passing messages would be helpful to understand
Does this PR not implement the smelting recipe registry?
Map<TableScanNode, Void> result = new IdentityHashMap<>();
Of course this isn't quite accurate once the number of keys approaches 2^16...
again I think you can use the diamond operator
It'd probably be worth logging if is an invalid value rather than silently ignoring the input value.
That would still log a warning, which should not happen. Also if the prop is not set, I think we should keep it this way.
In what scenarios is this actually possible ?
I don't see the point for a wiki page, if the wiki page did not changed then why could we need to invalidate the cache ?
Am explanation would be nice
You need to go through the persistent resource (instead of the data store), to ensure security is invoked.
We should include a resolution step here: enable auth or change your rules (or something strange happened)
@mttkay If onCompleted() takes place, all the events which belong to STRING_QUEUE won't never be emitted in an app lifecycle? Basically I wonder whether it also follows Rx contracts. Also, I'm figuring out what differences between Otto and this EventBus are. @mttkay Thoughts?
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
Might this field connectClientTsApiFolder  ever be a null? it's created in CTOR and has a final.
Should this be compared with || instead of &&?
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
Why have a result if the only one you care about is allow? Cancelable exists for boolean things.
TrackType parameter not needed.
replace with return ((IGridHost) tile).getGridNode(AEPartLocation.fromFacing(dir)) != null;
lambda?
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
this should go in .canExecute(ITmfTrace trace)
Does it makes sense to return a boolean here(indicating it the application had shutdown within the timeout). Returning void on a timeout doesn't convey if the application had shutdown within the timeout or not.
remove
remove(int)
This is throwing a StackOverflowException if invoked. Should probably be sendNow(event)
I would say that we don't need to have one more method here, we probably can just move  ArchetypeOutput archetypeOutput = DtoFactory.newDto(ArchetypeOutput.class); archetypeOutput.setOutput(event.getOutput()); archetypeOutput.setState(event.getState()); endpointIds.forEach(it -> transmitter.newRequest() .endpointId(it) .methodName(MAVEN_ARCHETYPE_CHANEL_OUTPUT) .paramsAsDto(archetypeOutput) .sendAndSkipResult());  here or did I miss the reason that stands by this decision?
Use MainApplication.worker.execute(() -> this.submitChangeset()) if you aren't going to use the return value -- this indicates that you really don't care if it errors out, and the current thread isn't going to be notified of that.
This effectively turns the flag to "false" but now we have an instance variable that is null even though the child fragment might still be included in the FragmentManager. That's a confusing state to have the variable in and maybe we should work on removing the child fragment (right here or elsewhere, on child fragment's work finish perhaps).
Is there a rationale for exposing a public method to increment the count?
Should close kill the memspace? What if someone want to reopen the key?
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
This isn't needed. Actually I think that one constructor is enough, put everything here: super(ClusterFeature.class, ...); this.clusterId = clusterId; Also consider using Guid instead of String for the type of the "clusterId" field. The caller of this constructor will probably have converted it already.
Change this variable declaration to something with meaning in the context. map is unclear here
java Iterator iterator = value.iterator(); if (!iterator.hasNext()) { // ... } for (int i = 0; iterator.hasNext(); i++) { Object o = iterator.next(); // ... }  is more effective.
this should be parameterized
Can use constant for "4". More importantly: if the blob is not already encrypted, the config flag "requireEncryption" is true, and cryptoService is null, upload should be skipped. (You'll see some of this logic when you merge with master.)
Should handle -1 return value. ReadableByteChannel could return -1 if the end of stream was reached early for some reason
"= 0" seems sufficient?
typo
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
wouldn't this fail if pattern was null?
style guide
suggestion super(() -> name);
change to IAdaptable
Since it's the same in both branches of the if, I believe it can be put outside of the if
Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).
FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER
waitUntilContainerStarted is executed by .start(), no need to do it here
I think here we re-introduce logic we already have [1] [2], from my point of view would be worth to extract this scroll logic into a separate class and reuse it multiple times. [1] <LINK_0> [2] <LINK_1>
This is not correct, let's discuss f2f about it
can you refactor that in a test utility class?
For each?
why null check here? ... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
This test would be useless if the map had been initialized in the class.
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
wouldn't it be better to first register the observers and then trigger the action? - in this case up till now I guess not an issue, but I think it also doesn't harm to do it anyways, does it?
can we give different name to this variable? it is meaningless
This seem to be asserting callback failure. Consider making a helper method.
I think anyListOf(Card.class) would be even better
I think this should be any(List)
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
You have chose a policy=static for the reference, so it cannot be null.
Seems like a reasonable change. Can you extract formatter.withZoneUTC() into another constant to avoid additional overhead each time?
could we refactor the above into a setUp() method and not having to repeat for each test
Should we throw a MojoExecutionException here instead of just logging it? If something went wrong when installing features then we can't expect dev mode to continue working properly.
Ok, that's true, up to you then if you want to change it.
This will create 0 connections. Didn't you mean < ?
This test data is a bit suspicious. createRecord alternately creates mapped and unmapped records, which means some of the records created here will wind up as "mapped/half-unplaced" and others will wind up as "unmapped/half-placed", due to having an alignment start but no reference index. Those are weird states for test data, and its not at all clear from looking at this method whether its intentional. Not that we don't want to test the "aberrant" cases, but we need a cleaner separation between valid test data and invalid.
you might want to make 10_000_000 a constant
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
Is this thread-safe? I guess, maybe, although it might do extra work since not all threads will see the update at the same time. I'm also not sure if ParseSpecs need to be thread-safe; if it's an issue could you please double-check it?
Think it might be worth doing this in scanHttpRequestSend as well? In case Jso is being POSTed, etc. The method could be changed from using the msg to accepting the body.
I would change the 'by ourselves' into 'synchronously'
It should throw exception
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
Why don't we remove Consumer from the consumersByQueue as well, like we do that in the handleCancel()?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
This doesn't need any kind of null check if they don't use Paper?
simplify this to  return getVarArgIndex() > -1;
please provide extra line above
It would be good if you can applytrimming for white spaces on platform.
> this [](start = 8, length = 4) no this. please
Fix the prefix, should be impl$.
this and m_ is redundant
I added method in Utils for that
typo. 2nd one should be V2
It is not necessary to test REPLICATE region in this test.
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
You should use ThreadContext.putAll() here.
Same question
OK to return the empty set - the JavaValue is a value, thus no variables inside.
nit: line too long. final not required -- a static method cannot be overwritten anyway
The executeAndWait method should also be changed to expect a value in milliseconds (httpTimeOut is in milliseconds, not seconds).
I think buildBigtable*Settings should just return built settings and you can the InstanceAdmin one return null if the emulator is enabled
Please create a copy of the configuration new Configuration(configuration)
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for ? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well ?
@dmzaytsev let's inline this
other methods like this put name first, then id. switch for consistency
Could you please change this to use only one access to the map?
You can use assertFalse for these.
we should probably add a maybeEscalateHeadsUp() here if we are on the keyguard and remove the one in screenOff, this will be safer and ensures that we never have a heads up on the keyguard.
need to calculate logprob directly.
do we want to have actual percents? not rates as everything else is in Picard?
... yes it does ...
can be java public Seq<E> getErrors()
Here, it has to be java default Either<Seq<E>, T> toEither()
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Please keep annotations on separate line :-) I suggest to use Java 7 utils for easier computation: if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ValidationResult that = (ValidationResult) o; return Objects.equals(success, that.success) && Objects.equals(reasons, that.reasons);
This equals implementation should include attributes from the PingCommand super class.
nit: return mType == that.mType && mBounds.equals(that.mBounds);
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
Unsigned types are not used in the current implementation. So, you can omit them.
use Log instead of System.out
Bad variable name! Variable names should be clear enough. Rename it.
pvk should not be visible. Please remove it.
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Why is it a list of lists, not just a list?
Let's change it to get the child commands CommandEntity rather then the CommandBase, it's slimmer (doesn't require to build all the command objects) and contains all the data you use in the calling class.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
It would be nicer/easier to debug if you extract the numbers with this regex: "^(\\d+)\\.(\\d+)\\.(\\d+)" Then do a comparison separately. java int result = ComparisonChain.start() .compare(1, Integer.parse(matcher.group(1)) .compare(14, Integer.parse(matcher.group(2)) .compare(0, Integer.parse(matcher.group(3)) .result(); assertTrue(result <= 0, "Expected BigtableVersion.getVersion() to be at least 1.14.0")
What about testing with ALTER FUNCTION sin ... instead?
Unneeded since it is in teardown.
And here. needs some validation.
Same here, but check the max cook time instead.
No need for a checknontnull, the superclass does that for you.
Let's inline this: return doGetInputFieldsForPMMLStream(modelInfo.getPmml());
Why is it a list of lists, not just a list?
Style issue: @Override shuld be on line above the method declaration
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
studentsWhoRespond -> studentsWhoResponded
getters are doing this check so it looks odd to have it at both places if it's immutable it should be Collection.emptyList()
I would suggest calling getAmqpPort() here (and in other get*Url methods) to avoid a duplication of this code
Instead of string concatenation, better to use String.format("%s %d %d", ...)
Alternatively, this: java return JOINER.join( Arrays.asList( timestamp, remoteAddr, "", objectMapper.writeValueAsString(queryStats), objectMapper.writeValueAsString(ImmutableMap.of("sql", sql)) ) );  It leaves the native-query field blank, and adds a new field on the end of the TSV for sql query. It uses a JSON object rather than emitting the SQL as-is for two reasons: (1) we can extend with more info later if we want; (2) the SQL query might have newlines and such in it, and the objectMapper.writeValueAsString will get rid of those.
please use try with resources as in ConfigurationHolder
why not just use putAll?
Was this the full exception message you intended? It looks like you meant to include the path or something in there.
suggestion if (keyedStateBackend instanceof CheckpointListener) {  Since the instanceof operator always returns false for null, there is no need to have an additional null check.
What happens if a checkpoint fails? Wouldn't cancelAfterCheckpointId <= checkpointId be more safe?
Something per-method needs to assign null to lifeCycleManager.
since "acceptedType" is of type list i would suggest to rename it to "acceptedTypes"
lower case first
This is not being handled?
write nullable on the same line or don't write it
All the way man!
Object
style nit: we don't use braces around single line blocks
Why is this required?
We should still warn that setVisible is not implemented, since setting the value doesn't actually have any effect (just like setFocus).
You may want to make the default smaller - like 0.01.
Use static call. There's no need to instantiate this util class every time.
Seems very odd to call onSuccess method in onFailure. May be have a method called onEnd that is called by onSuccess and onFailure
done for patch3.
Would it make sense to automatically call this method via on-persist/commit hook, depending on the event state?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
What do you think about if (paths != null && !StringUtils.isBlank(sourceText))?
From PR it appears that you want to display a different error if the plugin is not loaded vs when the plugin doesn't implement plugin-settings. If that's the case, there are more straightforward ways of finding if the plugin has been loaded up instead of iterating over all each extension everytime. Its very easy to track that kind of information in DefaultPluginManager and ask it for it.
nitpick. Just single one statement is enough: return getPathMap(fileSystem, path)!=null
More efficient: getDB().getRecPtr(record + DEFAULTVAL) != 0
I think this should check that also the non coded value is not blank, we normally user StringUtils.isNotBlank
I don't see why is isConnectionSetup() necessary. Shared in SharedPubSubWebSocket client means it is shareable and must support concurrency. It should be the responsibility of SharedPubSubWebSocket to ensure that its state is properly managed and if setup() can't be called concurrently, enforce it.
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
remove this line
Why switching? Can't you just see if element is present?
you'd want to use StringUtils.isBlank() not just the empty string
suggestion return GitHubServerConfig.GITHUB_URL;
Integer.valueOf
- log warning that option is not supported by SNMP
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Based on how it's used, it's more like a listener not callback.
if you write new code please use java formatting
Not sure if it matter much, but the 'better' way of getting an empty list is: return Collections.emptyList(); In this case however we need to specify the type: return Collections.<CertificateInfo>emptyList(); As the compiler cannot infer the proper return type.
This converter does not have any effect
no need to declare the unchecked exception here.
Can you add a message stating that the query can't be found in the enum, so it's easier to understand what the failure means?
You can drop these from the throws clause. Not only are they not thrown, but they are RuntimeExceptions.
cid -> dialog, gp -> geopoint.
Can we avoid the switch as its not common practice and maybe people dont know about how it works and would think that remove and put does nothing in this example etc. Make the code understandable and maintainable for everyone.
this.
Should this maybe return RecordStore.DEFAULT_TTL (-1 --> use MapConfig's default) instead of 0 (--> infinite max idle)?
Shouldn't we return the actual estimate?
Remember to create a nativeGetFinalizerMethodPtr method too to free native resources. Check OsMongoCollection for inspiration on how to do it.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
Which tests fail if we don't have this line?
I think this should be replaceFailed = false instead.
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
equals() is not usefull for enum, == is sufficient.
Add the info log back after this line?
Delete this - it was just there during debugging.
Please use Optional if a value might be missing. null values often lead to lots of NullPointerExceptions.
nitpick: redundant
nit: now that we are passing in the processingMode, we could potentially use this check as a helper function as:  private boolean0 eosEnabled() { processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA; }
the type of pollTimeMs is *Duration*. It seems to me that the "ms" is a bit redundant.
this and m_ is redundant
You can do criteria.add(Restrictions.eq("experiment.ndExperimentId", experimentId)) I think
@cuenyad Replace logAndThrow
@vmaletta why cant this be List<ExperimentModel> and remove the annotation?
We don't need to merge internalExchangeInfo and exchangeInfo. Remove the merge from WebserviceProxy, ExchangeManagerHelper and all related code.
Fix logging level here (error)
I am OK with just using ex.getErrorMessage() than getLocalizedMessage(), but I do agree that we should try to stick with one method in our code for loggers.
what if we have a mount with one single volume? Following the current implementation we may assign an unnecessary capacity ratio to it. We only need to calculate and assign the ratio for volumes sharing the same mount with others.
maybe consider putting this check into a method
please use "else if" since only one option can be valid at a time. Please also format the code according to the Eclipse coding standards.
This variable name doesn't seem meaningful?
You probably want to disable some view components in the event of a failure!?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
should probably check the app name does not have any chars that are not allowed in a zookeeper node name
Strange naming. There is datastorePath and dsPath ? Maybe store dsPath as Path and use dsPath.resolve(applicationName.getValue()) and then dsPath.toAbsolutePath().toString() when needed.
Just "return appKey.equalsIgnoreCase(applicationName);"
Why the unparse SQL is different ?
alias is count but the function is sum
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
Same- catch NPE.
Shouldn't this Assert be before the this.clientFactory.getClientInstance ? For other side it looks like we should have another getClientInstance method without the url.
I wonder why do we care about this. We are just have her self-containing AcknowledgmentImpl with the client it has been created. If that client becomes invalid at the moment of acknowledge() we have nothing to do anyway. What am I missing?
Simple test is also possible to verify result stat. See #971.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
I think the annotations should be on separate lines
Better to return "";.
why not using the super constructor? super(nodeId, nodeLabel)?
Style points as before. In this case the class has existing code in a certain style.
static import
Did you format the diff with helix-style? @BeforeClass should take up a line to itself.
This could be one less allocation if you skip the Collections.singleton.
what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this
I think we should create a defensive copy of the Map
I think we should create a defensive copy of the Map
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
I don't think you want to keep this print in here and the rethrow as a cause
shouldn't the log message be updated?
This date format is used in multiple places. Consider making this a string constant.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
Please handle vds == null or call this method in a way which ensure vds != null. You could even make this more explicit by requireNonNull or NotNull.
you can use instead: return Version.v3_5.less(version);
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Highly suggest isEmpty
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Consider writing a header for backward/forward compatibility.
Likewise.
If you have to cast here then you probably should have casted when reading the value from the data array.
Readability is concern here, lets keep it as it is.
I was just suggesting if we could use a different data structure than the Context type here since the Context object is a linked list representation and if its populated enough could result the getData to get slower.
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
We could probably use getItem() method here, for consistency.
This line should be removed or change "stuff" to something more meaningful.
should we show the sura name here instead of the number?
Same issue as above.
Should add the rule to config file?
We have a removeConfiguration so let's not allow null value here?
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
It is safer to use Objects.equals(elem.getFactIdentifier, factIdentifier)) as it doesn't throw NPE if one of arguments is null.
IntelliJ says this is a typo and should be renamed successfulRequests with one l. I believe it blindly!
Could you add support for setting from console too since that would work with the 4/6 arg version?
Here you are using synchronized for the queue handling, but you don't do it below if you add something to the queue.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
populate with meaningful data. Version should fit to artifacts versions automatically Licence: <LINK_0>
It's better to introduce Pull.STATE_OPEN and Pull.STATE_CLOSED and use them
Inline?
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
as this isn't static, you should use lower case cache
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
If the format is null then we need to check for the translation type first. Anything not a text translation type has a format of markdown. If the type is text then if the project id is obs the format is markdown, otherwise the format is usfm. We cannot completely depend on the resource type here because a REGULAR type can be either obs or a non-gateway language translation of a Bible project. > NOTE: In the android app we don't directly support translating to a ulb or udb resource type. However, the desktop app _does_ support this. Therefore android provides just enough support so we can import a translation from the desktop app without breaking.
Same here with length() == 0 -> isEmpty(). I'll stop mentioning for the rest of these :)
this.
Unless I'm missing something, testFinished(class) == testStarted(class) (either a test starts and finishes, or it never starts). Can we just have one method (perhaps named wasRun)?
How would I build a description that doesn't map to a Java class? Perhaps another public static method named forNamedDescription(String displayName)? (if you do this, I can understand if you decide that describing the defaults in the with methods no longer seems like a good idea)
use logger
This will destroy performance. We cannot allocate a new byte array with every short read. You could use an instance field buffer of sufficient size to avoid the issue.
Same: performance will tank. Need a small reusable byte[] as instance field. This should be OK, since these methods are already not thread-safe.
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
>byte[] [](start = 11, length = 6) DecryptResult
Sync clients cannot use withContext. You need to explicitly add a Context to the API args. Note that Context is supported only for APIs that return Response<T>.
s/operaiton/operation
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
Please remove the protected keyword because this class will never be subclassed.
Please use curly braces for conditionals
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
Compare with null not necessary since null instanceof FileModelSource is false
instead of comparing topicPartition object, why not compare topic and partitionId?
whitespace/style
Pattern doesn't implement equals(), you could use Pattern.toString() here and elsewhere
Since this is a String, perhaps you could use Collections.nCopies
We should probably do this in a finally block.
make this method private. Being a bit more conservative is worth here.
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
does this need to catch all exceptions?
fieldNames
Any pointers why don't we just throw recreate() exceptions as is? Looks like all other places don't care about exception wrapping
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
no docs, and can you make a list from columnLabelIndices.keySet() so you don't need a new member?
Should we move this up to ChainedTokenCredential? That way users who created a CTC can continue to extract the list for further modification.
Pay attention that most methods of this class return the null as String, but this method returns "null" as String.
String.valueOf is only needed when the parameter isn't already a string, both Build.Manufacturer/Model are already strings.
@dalifreire is this enough? What e.g about class name?
no checking flow when user sets grace period in the action
Dont use setUpCreationExpectations, split it into two expectations
<LINK_0>
You could save a few lines by moving the return null into the default case instead of break.
ChannelClosed needs to be added to (though not strictly necessary)
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
This may be a bit performance-intense, so a prior Material check would be very adequate here.
In my opinion, we should have the type check here as well. So maybe change false to isWater(data.getType()) or something
not public
Probably it should just return false
According to the current way how those methods are implemented, it should be return false
Probably this should return 0 when doubles[index] == null && NullHandling.replaceWithDefault() == true? Otherwise it probably should throw an exception.
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentContext()_ once and store the result in a _context_ variable). As a side note - in this and the following cases, the number of lines to change (and detected as changed by git) would be much lesser, and so the overall impact.
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
This check is redundant because you check this in handleSelection()
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
nit: how about using ByteUtils.getIncreasingByteArray?
public static otherwise sonar will complain.
use ShellIsAvailable
add wait condition for shell
use ShellIsAvailable
I'm not sure how anyone can create a class where isTTransport is true?
Just do return "INBOX".hashCode(); Nice approach though Should be good to push once you've tidied that.
@dmzaytsev We should be able to inline user, alias, and inbox, since they are just one-use variables.
remove this try-catch block and pull runInternal code here. MultiMap does not support NATIVE in memory format so it's not possible for NativeOutOfMemoryError to be thrown.
Should use the log, maybe a warning.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
I think this method should check only case 'b' and have proper method to explain the problem. All the other case are covered by 'nicActuallyExistsOrReferencesNewBond(..)'.
if you use de-morgan on the second half of the predicate you get: iscompat() && getNetwork() != null && !isAttachedtoExternal() but isAttachedToExternal() checks for null network so you can abbreviate to: iscompat() && !isAttachedtoExternal() :)
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
not use this to reference class members
maybe we don't need AtomicBoolean?
Don't know if FixedChannelPool#close is idempotent or not, but it would be better if we could make closed an AtomicBoolean and call super.close() only if it wasn't called before, via closed.compareAndSet(false, true)?
Another place where the name should probably be updated
I've seen this a couple of times now, can we use Google Guava's ToStringHelper instead? Probably best addressed in a separate issue/pr.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
Hi @rezita, I think this should be isSHREnabled
GPS should be caps
public PostsListPage and return this for chaining purpose
Please make sure the button is visible or clickable.
log()
You could add a text here to show what the output means. You probably know, but me running this benchmark, I'd need something more verbose ;-)
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
Oops, (start + end) / 2
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
Putting a method call to an overridable method in a constructor means that you can end up calling a method in an object whose constructor hasn't been called yet. This can lead to some very hard to debug errors. One way to avoid this kind of dependency is to make a field lazily initialized, e.g. in its getter.
this if/else is equivalent to this.path = Optional.ofNullable(path);
Not sure, why not use @NotNull?
assert.NotNull ?
wrong message
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
can this just be collapsed into a single writeAndFlush() call?
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
return toStream(ele, eles).collect(Collector.toSet());
We mustn't use .get() as it can cause freezes to the whole chain of computation, it is probably worse than a synchronized list.
This can be done in functional style if you prefer: java return optional.map(Stream::of).orElseGet(Stream::empty);
I continue to think that **aifc** should to be here...
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
Can use the already defined Constants
will never be true, because of Objects.toString(null) == "null"
The 'modifiedInterfaces' contain just the existing nics with label changes. The list you should check is 'getNetworks()'.
You cannot rely on the value of 'networkName' in 'getParameters().getBonds()'. This property of the bond is not validated and should be ignored by the command. In the future we plan to stop using Bond as the parameter and use a class that has only the needed properties.
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
also include the test's source path, you can find it in test.getSources() This will help the developer to locate the TEST_MAPPING file.
I think we have now changed the term "service group" to "cartridge group". Might be better to use lower case letters inside the sentence.
Consider ordering this up one method to group public methods.
I think isDisposed should also be checked here, right?
you need a different method for this - the fact if the plugin is supported in the browser or not is independent of the one if it is enabled in vdc_options. If it is enabled, it has to work the same way as it did before.
Can't we do this once at the start, since we always enable(true)?
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
why are you changing this line ?
Use Objects.equals for cacheQuotaScope
_eventMetadata could be null for some events. I suggest comparing them with Objects.equals().
EmptyConfig.INSTANCE?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
config is a non-primitive object, cast to Map<String, String> here before serializing and adding into the map; similar to how containerModels are added above.
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
Consider ordering this up one method to group public methods.
if we know the result, break out of the loop.
The proper way is arguments[arguments.length - 1] instead of arguments[0].
Reset fLabel to null to clear invalid cache?
are these setters used anywhere?
Collections.unmodifableList()?
Which type would be assigned in this case?
Use StringBuilder instead.
Is a table alias of length 0 really a thing requiring special casing to drop the apparently unprefixed '.' ?
suggestion } else if (statusCode >= 500 && statusCode < 600) {
This should be replacable by switch (solverStatus.get()), as all the actual state mutation happens in solvingTerminated()/solver.terminateEarly() as I've suggested above.
There's an inherent race here, if the following sequence occurs: 1. Thread A: getRealmIdentityForUpdate 2. Thread A: removeFromCache 3. Thread B: getRealmIdentity 4. Thread A: modify credentials 5. Thread B: authenticate with wrong credentials, which are cached forever The entry should only be removed from the cache *after* modifications occur, i.e. ModifiableRealmIdentity has to be wrapped as far as I can tell.
You can sample the value as a static variable. You will save an access to the system properties map
could this be simplified to return Optional.ofNullable(principal);?
Maybe legacy version of SetDigest can not be cast to HyperLogLog
What's the behavior when the input is not between the min/max values?
Changes to this file should go in the previous commit
Why not declare GLOBAL_ID as a long?
we should change this - and the other two getters to @Nullable public Long and return objects instead of primitives
[minor] ~~How about memoization of this value in terms of performance?~~ Do you think we need to memoize this value in terms of performance?
You don't need this line because of green 31.
return Collections.emptyList();
is there no common place (at the broker level) we can add the unioning query runner?
Could have @VisibleForTesting annotation. Also could public be removed?
one more method where it can take file location of properties would be good.
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
it's better to do this(clazz.getName()) here and get rid of this DEFAULT_LEVEL constant, being used only once
suggestion this(clazz,PERIOD);
add requireNonNull for clazz
This code can be extracted to a general "run & check" method
use new Guid(String) - this literal can't be null
use new Guid(String) - this literal can't be null
Why do you use a new array to do iteration? If it is to avoid possible ConcurrentModificationException in multi-thread use case, a synchronized block would be more adapted.
curly braces
Pending this aspect of [JENKINS-24141](<LINK_0>, I recommend looking for a getChangeSets method via reflection, rather than adding (even an optional) plugin dependency on workflow-job.
Missing a unit test to ensure maintainability.
I end up by choosing _myClass.class_ syntaxe (@troger) to be consistency with the different implementations of getAdapter method and in the same think i change to use adapter.cast(this) syntaxe instead by _(T) this_ although it will be end by a double check :) (Class#cast is already check before doing the cast to avoid the classCastException)
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
Same as above for toString(): <LINK_0>
channelId => channelName
I think this is unnecessary => "profile =" + this.profile is sufficient.
suggest you want raw.split(":",2) here so that the value can contain colons.
can this be readSafely instead of readBuffer so that read uses readSafely
are spaces OK in namespace strings?
Turn this into one or more helper methods. The simplest thing to do would be to have something that returns and List<String> or Iterable<String>. Then you could use standard Hamcrest matchers to assertThat the list does or does not contain the expected outputs. Alternatively, you could make higher level helpers such as assertSleepCount(expectedNumThrottles) and so on. Or even assertCount("Sleeping", 0) would be okay. But for more complex scenarios, you might need to check the order and count of messages. Your call on the specifics, just need something a little easier to read.
I don't think you need this new flag. You should immediately return null from fetchNextReady() if the child has already been closed, which you can test with child.isOpen() or child.eos(). @jingjingwang do you agree?
checkState
that's invalid anyway, isn't it? what's the meaning of CLUSTER_DEFAULT on cluster, you can never set it. autodetect==null, and then only concrete values are allowed
We shouldn't have any LDAP-specific code outside of the LdapGroupBackend.
Possible race condition.
isValidValue() anc isNumeric() could be abstract on the enum, and therefore each instance could have its own implementation. Arguably, it could be nicer code, avoiding these monster ifs and the potential bug when a new type is added without updating the ifs Although I could also see how that kind of code could be considered worse, due to all the @Overrides. :-) So just something to consider.
I don't think we should relax validation checks just because we trimmed it in one place.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
we should use getAndSet(null) here to release the reference as well.
All promise rejections should include Throwable object as argument.
Nitpick: use Strings.isNullOrEmpty() as we do that throughout the rest of the code.
This whole check is fundamentally wrong. We should return all facilities for PERUNADMIN/PERUNOBSERVER and filter response only for FACILITYADMIN.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
Why do you use 3-argument constructor here?
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
For consistency, can you move this between passport and http handlers (line 65) and change the method to addLast?
Is there a reason this is package private? On a fluent builder this feels odd...
done for patch3.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
Why this change?
Why this change?
Why this change?
you can check the cache file exists (check line 147, which checks the output report), and you can check the output for the cache warning to not be present
Recommend throwing UnsupportedOperationException if the disk methods are called.
I'm not sure I like the way it would work. You mean that before every request, I would have to call "login"? Doesn't sound very user friendly.
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
Again, I'd go with asList and a static import.
default is true
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
@lvydra Please remove 'parameterName.equals(NAME) 'from this. My apologies; I should not have listed 'name' as an invalid key in the JIRA description. I've corrected the JIRA description.
private static final int FIVE = 5
This doesn't look like formatted.
throw if mPrettyPrinterInitializer is null. Basically only allow setPrettyPrinterInitializer to be called once.
Is there any case when we don't have config?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
no public
:question: do you need to do line 187 (final SolrClient c = client;)?
Format
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
is this value hardcoded?
Instead of returning here based on course access, we should make setHasOptionsMenu() dependent on it like: setHasOptionsMenu(courseData.getCourse().getCoursewareAccess().hasAccess())
If the feed is null, the menu items should still be setup. Just the feed title can be left out. That prevents possible flickering when menu items are displayed/hidden for some feeds.
selectedElement for better readability
please format if across lines, e.g.  if (!iterator.hasNext()) { return; }
Another way to do this:  @Nullable final Task result = Iterables.getFirst(_queue); if (result == null) { throw new IllegalStateException("Some useful message here"); }
I would suggest naming this variable as 'serversArr' instead of 'temp'
Local variable not required. You can directly populate the class level variable this.servers
this could be changed to foreach sytle
This should be constructed using a private SecurityAction, since it requires EXEC permissions (see the CI failure)
I know he's on holiday but we've gotta come back and remove these extra this.s.
Fix the prefix, should be impl$.
yeah
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
Not sure this would work. If 2 threads are racing for this code while val is still null, both can read val as null so both will create new instance and 1 count can be lost given the last of them will update the map so possibly using synchronized for cases like this is actually needed.
It seems asymmetric to allow returning a null Integer for getMaxConcurrency, but setMaxConcurrency only allows a primitive int which cannot be null. Is it meaningful for the max concurrency to be null? If so, how do you clear the max concurrency?
return Optional<String> to avoid nullable result.
Use Integer#valueOf(int), or delegate the work to the method above, so we can benefit from Java's internal int cache.
add sandbox
getAttribute returns null - add null check
Add parentheses, helps readability: return (fQueueSize.get() == 0);
@ivandalbosco Is it possible to have invalid line? and as a consequence a parsing issue on file level?
This should be rewritten to just change the key depending of filterAnyRule.
This kind of detailed logs can be done at debug level. Furthermore, try to record what exactly was changed (i.e. the new values). Can be helpful in debugging cases of 'missing labels' etc.
@ekondrashev move this assignment to line 103 above.
this is not safe, what if there will be HTTP/2.0? I would rather do .split("\\s", 2)[1]
@fanifieiev please, fix the indentation here.
either change the method name to refreshMetadataDevicesInfoIfNeeded or better yet add the if condition here.
either if (!storageDevicesListCalls.isEmpty()) or storageDevices != null below
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This should be log.error. Don't know why other statements here use log.warn
@rvansa I think stop() should release all the semaphore permits. Threads trying to read from/write to the store after it was stopped should throw an exception immediately, they should not block forever.
:ant: multicast is one word.
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
How about this  String now = String.valueOf(System.currentTimeMillis()); return String.format("%s-%s", now.substring(0, now.length()-3), now.substring(now.length()-3, now.length()));
I'm concerned about the stopTimer method. My thoughts: - the get() method of optional generally should be avoided. This is a pretty good article on optional usage: <LINK_0>, it sums up a number of similar points. I think one to help this is to mark startNanos as @Nullable and just use a null value and do a classic if( null )  type of check. Though, we still have a lot of internal state going that route. Even if we allow for disabled timers, assigning startNanos always to System.nanoTime would not hurt that much (we are still talking a ns operation, that is not a place to make performance improvements).
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
Should you check if there are some files you should still delete, in case this error happens?
I'm confused. Which of these catch clauses is the expected one?
The flag is being set to true always, the previous statement does the right thing - Did you leave this by mistake?
What's this for? Could it be a @Rule TemporaryFolder instead? That's preferred for any temporary directories or files needed by tests.
I think the default should be there is aggregation. Same as in runMultipleAction.
@essobedo once used variable can be inline
the old(LinkedList) is not thread-safe, multi-thread add might be wrong. You should protect it.
the old(LinkedList) is not thread-safe, multi-thread addAll might be wrong. You should protect it.
Unnecessary call to super()
Unnecessary call to super
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
Same here. And later you can again call await on the same countDownListener.
I think there are some not necessary white spaces, could we update as: java query.setExpression("select p.PROCESSINSTANCEID, p.PROCESSID, p.PROCESSNAME, p.PROCESSVERSION, " + "p.STATUS, p.EXTERNALID, pr.STARTDATE, p.USER_IDENTITY, p.PROCESSINSTANCEDESCRIPTION, " + "p.CORRELATIONKEY, p.PARENTPROCESSINSTANCEID, pr.LASTMODIFICATIONDATE " + "from PROCESSINSTANCELOG p " + "inner join PROCESSINSTANCEINFO pr on p.PROCESSINSTANCEID = pr.INSTANCEID");
Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.
any issue with I18N? I think it should be validated with SpecialAsciiI18NOrNoneValidation
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().ValidateEntity( } remove union (like you did in name validation)
All of this can be replaced with an ExecutorService
As the generated mask is read only and privately used it might be better to create once and reuse the same array.
use Arrays.fill instead for loops
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
We shouldn't expect this to be an Expression. Fix the test rather than having it handled here.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap
How would you get the next batch for pagination?
I would probably not use pagination to avoid any confusion in the test. I would create a separate test for pagination.
Is payeeIdL a typo or intentional?
Patametrrized logging please
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
Check if KEY_MEASUREMENT_FILTER_ID for specific measurement filter is present in request parameters. If present set value from request parameters, otherwise don't set...
Better to return empty collection rather than throw exception.
this cannot be an error...unfortunately. Perhaps just emit a warning? (also, you'll need to switch around your map...
should check that there are exactly 2 items in the array, and throw an IllegalArgumentException if there are not, with a descriptive message.
is incorrectly formed.
Space after []
Use ClientLogger for throwing exceptions
This is out of scope of this PR but while you are modifying this file, could you also instead import the package and remove this fully-qualified class name?
Does this get overridden in the subtypes?
I wonder if this change would result array allocation and extra cpu/memory consumption issues
If someone would copy paste this logic and hasn't defined the hazelcast-aws.version property, it will still fail. 1: Can't we look up the version of the module? I guess the module doesn't need to match the HZ version? 2: If we can't do a lookup, perhaps better to indicate <version>insert-right-version-here</version> to make it more obvious that some work by the end user is required here.
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Should this executor specify the Looper too?
@zxw1962 assert will not work in production, if you could change this to an actual if() statement it will be great.
Remove Unnecessary logging
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
Optional: this could be done without the index variable: for (int i = 0; i < emailPick.getItemCount(); i++) { if (value.equalsIgnoreCase(emailPick.getValue(i))) { return i; } } return -1
We should check if defaultValueRow.getColumn(i+1) is null or not, as the column's value may not be populated.
You could also use -> Objects.toStringHelper() from guava
return new StringBuilder().append()....toString();
This isn't what we discussed and implies mod_cluster can no longer work in a profile meant for 6.x hosts.
Same as above: could use searchPacksAgain
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackError(e, p); } ... private void handlePackError(IOexception e, PackFile p) { String tmpl; if ((e instanceof CorruptObjectException) || (e instanceof PackInvalidException)) { tmpl = JGitText.get().corruptPack; // Assume the pack is corrupted, and remove it from the list. removePack(p); } else { tmpl = JGitText.get().exceptionWhileReadingPack; // Don't remove the pack from the list, as the error may be transient. } StringBuilder buf = new StringBuilder( MessageFormat.format(tmpl, p.getPackFile.getAbsolutePath())); ... }
It's looks odd that the instanceof checks are not symmetric.
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
FWIW, please take a look at PR #642 , most of the changes here are already incorporated in that PR. Question here: any specific reason that you want to explicitly construct a LegacyTaskApplication here, instead of retaining the same API, but internally convert the MyStreamTestTask.class to a LegacyTaskApplication instance in TestRunner?
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
there are multiple uses of these values in different tests would be nice if you could move them to constants with a descriptive name. especially height and width because they are always the same
Please move these lines into sprite.resetSprite(). Apart from that it's a very nice fix!
please move this out of the for loop, since this is done once and only once, and do this before or after the loop. (then the boolean flag can be removed aswell)
nit: use List rather than ArrayList
IntelliJ says this is a typo and should be renamed successfulRequests with one l. I believe it blindly!
Missing final
just remove the fileSize from here... and that's the only change you will need.
write null explicitly rather than an empty string
Guava has Objects.ToStringHelper() to make it nicer.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Wouldn't this throw an exception if the element is null? Also, what about renaming the variable s to show that the variable holds the string representation of the JSON element?
Missing null check on sampleClass
Since the creator isn't modifiable, it doesn't need to be loaded from the database for an update. (It'll already be fully loaded in the managed dilution [here](<LINK_0> ).
Use {} for variable interpolation
Is this a programming error? Should it throw an exception? There is a similar case above.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
add reload
I get that standbys should never really be in RESTORING state, but it still doesn't seem like it's philosophically any more illegal to suspend from RESTORING than it is from RUNNING. I'd vote to legalize RESTORING here. It does seem like a useful sanity check for CLOSED to be illegal, though.
Math.max(..., 60) for ethernet padding
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
invert this.  java if (List.class.isAssignableFrom(target.getClassType())) { return multiInstantiator.instantiate(target, parameters); } return conver....
Aren't we doing this in the superclass?
Null values aren't used for item stacks. Use !target.getHeldItemMainhand().isEmpty() instead of target.getHeldItemMainhand() != null, and _maybe_ put target.getHeldItemMainhand() in a variable since you're using it multiple times.
if tags are displayed in a list, better use onData to get hold of it
please use the FormulaEditorWrapper, there should be no ids of formula editor elements in tests
This line needs to be updated with the new ID, too.
Replace with logger
New method doesn't covered
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
can you remove this try/catch? it could cause the sample app to get in a weird state
Is this conditional necessary? Maybe we could set the width unconditionally?
Can this be within the if statement above?
else if (SecurityUtils.isHadoopWebSecurityEnabled())
Why is it necessary to have Configuration and YarnConfiguration? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
optional nit: this is still confusing for me, maybe it could be reworded as suggestion Unable to determine max direct memory size. If druid.processing.buffer.sizeBytes is explicitly set then make sure to set -XX:MaxDirectMemorySize to at least "druid.processing.buffer.sizeBytes * (druid.processing.numMergeBuffers[%,d] + druid.processing.numThreads[%,d] + 1)" or else set it to at least 25% of maximum jvm heap size.
once applied changing the class signature, this casting can be avoided. Update should be done in VdsUpdateRunTimeInfo.getVmInfo where creating the command instance.
Instead of Integer.valueOf(int).toString(), just use String.valueOf(int)
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
we should probably check in the canExecute whether we reached the end of the list
Now we only support copying one object? Why?
you have a get editingdomain methid in the abstract table ;-)
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Sorry, I forgot that the re-enablement wasn't done automatically. Please set this back to true. Technically, double-clicking on the button _could_ trigger two dialogs to come up, but in this case, the command is fast enough that it does not happen. If you want to see it happen, you can set a breakpoint in the code that executes the command, then double-click on the command; because of the delay of the bp, you will see two dialogs. FYI, the way we handled this before is by extending RefreshableDebugCommand (written just for that case) and mimic the logic in GdbConnectCommand. But it is overly complicated in your situation, which does not need it anyway.
Same here... completeLoadRequest(request) ?
Do we want a test case that you can create an element with any revision?
It seems you can remove the IOException now.
I would not recommend a publish workflow for this, especially not a one-way publish workflow. In practice, developers will create a revision, publish it immediately to test with, and then create a new revision, resulting in a myriad of unused revisions. This is the same reason we ended up removing the publish workflow from schemas. It would be better to just always allow elements to be mutable.
The Exception is never thrown.
The Exception is never thrown.
The Exception is never thrown.
LOG.info("endpoint : {} , timeout : {}, connected successfully", endpoint, timeout);
Could you format the code in intellij?
better at least add a debug logging here
Those two should be equals (and even ==) rather than going through FQN
return
This logic seems potentially fragile. What if someone accidentally types in *two spaces*, e.g. -c[space][space]test. Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)? If we could just use that CLI API directly, it'd be better than rewriting it ourselves.
Sorry did not get. How AtomicBoolean is different compared to boolean wrt repeated roll possibility. In the past we used to keep the Boolean state in a Map. Now in this object.
Let's get rid of this. It can be created manually to run a migration
I know you were doing automated stuff and this is part 1 of 6, but we could inline function here.
Again small thing, but "the existing file" sounds better IMHO.
Arrays.setAll() is cleaner
the openConnection() call returns a DatastoreConnection. This needs to be closed in a finally block once you're finished with the operation :-)
For completeness it would make sense to also do a java assertEquals(dt.getZonedDateTime(), sdt.getZonedDateTime());
Why not just use " " + System.lineSeparator() ?
There should be an equality test for identical requests with different dependency levels
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
CustomTransactionSigner is a StatelessTransactionSigner thus I think this override is unnecessary.
You can move these to separate tests. You can also verify the error message returned from canDoAction
Please add java doc
the resulting code looks strange. can we just do:  case PLUGIN_TOOL_TYPE: case KUBERNETES_TOOL_TYPE: case OPENSHIFT_TOOL_TYPE: case DOCKERIMAGE_TOOL_TYPE: // do nothing break;
Is there a corresponding constant for cheEditor tool type?
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
I'd rather we use Assertions methods to catch the exception from a specific place, as opposed to catching the exception from anywhere at all using @Test.
I think that Kie server should return HTTP status 4xx in this case (possibly 400) as request parameter cannot be parsed.
Where in the code updates the connectionIdToRequestInFlight queue when a request gets timed out?
not useful I think
we just log, update metric and move ahead with next iteration?
AnnotatedTypes.getIteratedType is not longer called. The Checker Framework still compiles if I delete it. I think it should be removed.
node.getDistributionType() == SpatialJoinNode.DistributionType.REPLICATED
We should probably return an anonymous inner class implementation here instead of 'Unsupported' since we are returning something. Unsupported makes it sound like we are unable to do anything without though its really some generic representation of a volume source since we have no specifics at this time.
It must never be null
It's not actually container creation but machine starting which includes container creation, machine bootstrapping, server checking.
nextLong could return a negative, right?
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
an empty catch clause is not very fancy in our code. please handle the exception if it is caught and think about side-effects this code can have.
Might want to extract all the track line drawing code in a method, same below for the track icon
This should not use the --metadata parameter since that is used for object metadata. We should probably use a different parameter like, --datapolicy-id or something like that.
This line should be separated.
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
Here merge gets too complicated. More readable solution would be: map.computeIfAbsent(year, k -> new HashSet<>()).add(geoAreaCode);
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
I mean, Arrays.toString() *cof* *cof* for some reason, I though we had a generic printArray :(
new byte[fields.length][] is sufficient because you initialize the second dimension in the loop below and if fields are empty (empty array) then the initialization fails because the size is Integer.MIN_VALUE + 1 which is -2147483648 (-2^31 + 1)
use SLF4J {} expansion rather than inline; there's a lot of commons-logging era log statements, and changing a line is the time to upgrade them
I think we need a null check on the value?
misspelled. plus why are we leaving the first character capitalized?
added a default clause : default: // Do nothing
it should not give owasp zap catcher (0W45pz4p) chances are quite less however.
emphasized instead of emphasised
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
Don't we want to keep this?
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
What do you think about if (paths != null && !StringUtils.isBlank(sourceText))?
No need for else here.
Do you think we can continue with the exceptions refactoring you started in repository level and throw these exceptions to controller level catching them with exception handling mechanism?
Maybe it's better to use LOG.debug("Failed to find subscription: {}", subscriptionId, e); to avoid unnecessary string concatenations.
declare throws please
final! :)
don catch exception, better fail than return ""
I'm not sure this error message is going to be useful for users. Can we just report that the upload failed? You can add more details in the logging. Is there a retry path?
Please log a more descriptive message here. Remember e.getMessage() may be null. This should probably says something like "Search for owningCollection with UUID = [parsed uuid] resulted in an error"
maybe add a debug message here?
there does not need to be a null check since the [HttpClientWebRequest](<LINK_0> is doing this already (machtes all occurrences).
Looking at <LINK_0> Do you really want to swallow "Error" ?
I assume this is left over from tests
s/A submitted/The submitted/ s/task/event/ Also, is it possible to add some info here? perhaps the event's type or something like that?
This is too broad and is swallowing exceptions that need to be propagated.
you can directly check if loaded != null in the next line.
This can be moved outside the try block (by making it final).
Hard-coded string here. Also, it would be good to write the error to the AppLog.
Maybe add a description for the error here, something like "Error occurred while requesting purchases for deletion check: " + error.toString(). I think it'd be easier for us to find the issue from the logs, especially for the HEs.
I don't think we do a very good job with this, but I think AppLog.v might be more appropriate here since it's probably too valuable during debug. I also find it interesting that you chose AppLog.w over AppLog.e while handling the error, I think it [has the lowest priority overall](<LINK_0>
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
suggestion return Collections.unmodifiableMap(tags == null ? new HashMap<>() : tags)
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
Minor: same as in other number check, WDYT about checking for the decimal point?
Are these files typically named the same across multiple data sources?
Can use java 8 paths.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
@ikhvostenkov please name it just json
@ikhvostenkov please name it json
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
are we sure about this? :)
Just a small nitpick: We don't need the else here.
subscribe()
We should mutualize a hasTag (probably in stats)
Ah, it's a Multi-API thing. There's probably a way to make this a nice aspect since it's in every call.
Not sure if this is described in any conventions (DDF or otherwise). @shaundmorris might know, but for consistency with the rest of the code (including this file) I think this should be at a warn level:  java logger.warn("There was an error while trying to access the application", e);  It looks like you're using warn for other exceptions so it would be good to have them all the same. This might be something different and more severe though, so if it is just let me know :)
Can be replaced with call to computeIfAbsent.
ack vs association
Instead of using toString use the EObject to compare see below for an example : private Property getSourceEndNaryAssociation(Association association, DDiagramElement view){ final DEdge edge = (DEdge)view; final List<Property> members = association.getMemberEnds();  final DNodeListSpec source = (DNodeListSpec)edge.getSourceNode(); final List<EObject> sourceSemanticElements = source.getSemanticElements(); for (final EObject sourceEObject : sourceSemanticElements) { for (final Property member : members) { if (sourceEObject.equals(member.getType())) { return member; } } } return null; }
Why not just pass in only the message?
Isn't obs.getObsId() already tested on the previous line?
Shouldn't we put back the check for getData() not being null? Of course in addition to what you have just added. :)
no need to declare the variable before using it..
just set result to false first, and use that all over this function
better I think is : if (ec != null) { ec.setJob(this.getExecutionContext().getJob()); super.executeCommand(); this.setExecutionContext(ec); } else { super.executeCommand(); }
This looks suspicious: call to Optional.get without .ifPresent. You can avoid having those misleading Optional-s, if you replace .collect(groupingBy(...)) with .collect(toMap(SortExpressionContext::getSortExpression, c->c, SortExpressionExtractor::merge).
It's pointless to have this in the API level down if you're just going to throw.
return Optional.ofNullable(kill);
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
Please refer <LINK_0> We want to use Options class.
check the RestServiceErrorCode
This line can go with the playerCamera line below.
I didn't highlight this issue in previous nodes as it isn't overly important but perhaps we might want to decide if to consistently initialize the two rendering configs either by first obtaining the Config object from the context or, as you do here, by having everything in one line. I guess on one hand I feel that having a local variable helps with the readability given that getRendering() and getDebug() are a bit ambiguous as method names go. On the other I like the compactness of the one-line in this case. I'd say I'd prefer readability over compactness though. What do you think?
This line can go together with the playerCamera line below...
from L257~262, you can use Strings.repeat
we can just call repeat(" ", n)?
In cleanupNodes above we do a NPE check like: java if (nodeList != null) { // ... }  Shouldn't we do also here?
This message is not valid for getReplicas, but maybe it's not worth changing, since it's a trace message
make line 112 an else if?
minor: you can use == here since it's an enum (or change the == RestMethod.DELETE to .equals(RestMethod.DELETE) for consistency)
Looking at the usages better throw in this case.
Please merge those two nested if statements. It can be just one.
rename to childItem
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
I would flip the order and release the Inflater first. That basically cannot fail, while super.close() could still throw some other sort of exception. I'll cherry-pick and make the change.
random? really? I would have used idFor(). public ObjectId insert(int objectType, byte[] data) { return idFor(type, data); } public ObjectId insert(int type, long len, InputStream in) { return idFor(type, len, in); } or something like that. I forget which of the insert methods is the "bottom" of the call stack before punting to the InputStream version that is required, but I would implement both in terms of idFor and return the actual SHA-1.
Is this related to metrics? Or something else?
Can't see where this is ever unregistered. Memory leak?
This should definitely be a different PR.
This line now exists in the else statement as well [here](<LINK_0> I don't think this isOnline check is helpful. Because of that we have a hell of indentation here. I think shouldn't have getAsync from model 2 times. What we can do is that, we can first try to get it online, if that is unsuccesful, we can try to get from the cache, if that fails, we can use setIsloading(false)
onListLoadMore(1, 0) alone is not that understandable. Can you extract this into a separate method sayin something like loadFirstPageOfEvents()
Can probably just use MockFilterConfig from Spring?
You can just use Arrays.asList directly, e.g., final List<String> strings = Arrays.asList(...
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
retList is not actually used so it will always be empty. Should it be passed into the call to addTabCompletionOptions?
Do we need to do that ? I'm wondering because we are opening the door to a new way to retain channels: - Is there a use case where the server life is shorter than the application life ? - If so, should we just shutdown event loops to force channels to be closed ? - Is this related at all to the OOM since this is only doing anything when the server is closed ?
If we provide port value of "0", each time we call start(), it generates a new NettyContext, which has a different "address" - "port" value. So if the caller first calls start(..) and then asks for the "address" value, while another caller also calls start(..) and asks for the address value, then there will be a race condition. Other than that, when we call start(..) at the inside of a single thread, the address value of the initial call will be lost. It seems we only need the "address" if we pass port value of "0", otherwise address can be created by merging "bindAddress" and "port"? If so, we might have a overload method which also provides the address value back? If caller really needs the address back, the caller can call this overloaded one. So we will not need any class member and it will still be ok for multithreading?
I hate this line - I see it everywhere.
For each?
All of this can be replaced with an ExecutorService
Format this file using our code style.
Can you replace IDs with names in this log message?
Would it be the same to say lemmasList.addAll(keyValues) here?
Immutable?
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
event.equals("clear")
do you want to create a new list if its null?
We shouldn't expect this to be an Expression. Fix the test rather than having it handled here.
component will be instance of InputPort by default unless unless component is null.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
In general, we should probably be moving away from client-side validation where possible.
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
The null argument will lead to a NPE below in notify. Leaving it as this(null) should work.
Please use logger instead of e.printStackTrace()
nit: you could also move all the setUpServerChannel() calls
For me this case will always return null, or?
you should use enum here instead of string. I think that the best solution will be creating new AbstractClass. DhisDataValueStatusResponse and DhisStatusResponse should extend this new class and then you can use here getStatus method
not seeing the Locale.ENGLISH setup, also exceptions are not handled. is this intentional?
I don't think this is the a correct logic. If a global email is set then, termination email is going to be sent no matter it is enabled or not. I think we should first check whether termination email is enabled and then try to call getOwnerEmail to send the notification.
I think this is meant to be moved within the if (executor.inEventLoop()) { block below?
should use safeExecute here?
do we need to unvoid..?
Just use a ListItemReader instead of that odd one off
Can we inject this feature directly ?
Using Collections.singletonList() is slightly more efficient as long as the result doesn't need to be modified, which is true here and and for getDescription()
Embed the caught exception in the newly thrown exception
I suggest utilizing <LINK_0> to handle i18n of error message.
Just curious: what throws GeneralSecurityException and/or IOException here?
any chance group 2 could be null?
this is the same as the one above except for the extra. Can we combine them, or have mutually exclusive asserts?
I'm not sure what synchronizing on "this" does here. Which data is being protected by this synchronization?
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
If there is no MultiDetach service, maybe we should revert to the previous behaviour of not allowing detaching when multiple elements are selected? It may be confusing to arbitrarily allow to detail because the first selection allows it. We would just need to add a check here if (contDmcs.length != 1) rm.done(false);
Missing: getSession().addServiceEventListener(this, null); to make sure this is called: @DsfServiceEventHandler public void eventDispatched(IExitedDMEvent e) {
prefer  String operation = isFile ? SASTokenProvider.CREATEFILE_OPERATION : SASTokenProvider.MKDIR_OPERATION;
this is replicated enough it should be its own method, e.g  maybeAppendSASToken(path, operation, querybuilder) if (authType=SAS) { appendSASTokenToQuery(path, SASTokenProvider.RENAME_SOURCE_OPERATION, queryBuilder); }  and use wherever needed
nit: this line is long enough its time to split
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
This variable is not needed and in a scope where it's not needed. Iterate the return of the method directly.
You could combine this into the for loop conditional using && and removing the negation.
Big +1 to this change. Should never silently fall back to plaintext when there's an issue using the user-declared crypto. That said, I'm not sure the CryptoModule should even be configurable. It's too tightly coupled with crypto code outside of the module. I think maybe only the ciphers and crypto parameters should be configurable.
Why we are searching through all bundles?
Can be the className null? If not I would maybe rewrite as [1], what do you think? My point is to not nesting expression into try catch, if an exception can not be thrown. [1] java if (ScenarioSimulationSharedUtils.isMap(className)) { return new HashMap(); } else if (SIMPLE_TYPES_LIST.contains(className)) { return null; } else { try { return classLoader.loadClass(className).newInstance(); } catch (Exception e) { throw new IllegalArgumentException("Impossible to instantiate " + className, e); } }
You will probably need to change this auth and the accept type when completing teh request verification in the mock tests.
We want to make sure that every request is made to the right endpoint. In this case, just add here a common assertion to verify all requests are done to "/"?
The "Accept" header is set twice, is this intentional?
We shouldn't wait for the a bundle to become active. If a dependency exists from plug-in A to B, then B will be always active before A. If it's not the case, than further investigation is needed.
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
We are doing nothing here. Bad practice. We should let the caller know.
entry could be final?
Not critical, but for simple maps like this it can be nice to use Collections.singletonMap to keep it concise.
Why ignore producer level properties? My thought was that producer level properties always go with the message unless they are overridden by message level.
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
if ( This happens in several places.
We should do everything we can to allocate and reuse a buffer here -- i.e. create a transient byte[] / Buffer that is used for storing encoded output, rather than StandardCharsets.UTF_8.encode -- otherwise we're going to generate massive amounts of memory garbage.
why exit here ?
As this string is language dependent, should this not be externalized?
For now, we have to add case UPDATE_BEFORE here, ignore before is just an optimization. There is still cases the before can't be ignored, e.g. multi-sink (one way requires before), filter on agg result (FLINK-9528).
Same exception text adjustment suggestion as above.
we need to have a way to provide the engine lock in a way that the lock will be taken right after the task is submitted so the entity will be locked until the operation is executed think of the following case: HA VM went down the run operation gets rejected (next try on 10 sec) the user start and right after that stops the VM after that 10 sec, we'll try to run the VM again so I think that on reject we should have: 1. audit log for the user to know that something bad is going on 2. not try to execute the command again or provide a way to pass the context, including the lock, and lock the entity here. the lock should be passed to the command to be executed
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
metric?
other methods in this class are protected by a readLock, I think we need to have similar protection here.
You have forgotten to return, this results in two writes to setLore
I think you can use Objects.equals() here, we don't need to create CuKualiDecimalUtils
Minor: suggest moving port == that.port && xid == that.xid to the position close to Objects.equals(sslPort, that.sslPort). We can compare instanceName first. The port and xid are usually same.
otherGl should be changed to otherGroupLevel
maybe use variable or pass in as parameters instead of using magic numbers.
Rather than printing it out, use an assert*() test method. Simplest might be asserting the string is not null; you could possibly String.split() on the delimiter and assert that the resulting array has a length of at least 4.
add prefix to "About to invoke" message too
use Java8 stream anyMatch() instead of this loop.
This part of the patch looks fine and can be merged, with the small correction mentioned below.
This is similar to [assertBranchesExist(...)](<LINK_1> with Hamcrest's [not(...)](<LINK_0> sneaked in.
I have mixed feelings about this. On one hand, this won't interfere with a conventional callback. On the other, it seems like really bad practice to start Fragment C from Fragment B and manipulate it from Fragment A or Activity. I would prefer we don't support this callback pattern. Is there another way we could fix this?
I think that there is no need for a full package path as we already have import on the top of the file?
This should be done generically in BaseSingleFragmentActivity I guess, instead of needing to have the Fragments query the Activity's launching Intent extras. This would make the Fragments much more modular, as can be seen here.
I'm not sure if it is needed - wouldn't the command status be set to FAILED in this case?
This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.
Please a a warn log here, so we can know there was a failure for the specific child command and the command status
[minor] ImmutableList.<Segment>of should also work and avoid the cast
Could fall through and have only one return baseRunner.run(query, responseContext); statement in this method
we should probably throw an exception here as this should not happen
.toString() invocation is redudant here.
I don't think these are mutually exclusive. The manual shows them here: <LINK_0>
This is generated code, please remove this or adjust the EMF code generator.
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
Could this boilerplate be extracted in some method?
Unless there is a bug, as it is currently written, there is no point in creation of publishDoneFuture and publishFuture could be just returned from this method.
Do we need to remove the reservations here if the member is no longer the replica after rollback, same as for record stores?
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
Do we need to check here if this member is still a replica before clearing the counter (same as the check is done when clearing the record stores)?
format as final String[] array. Rename to errorMessage if possible
Is this method only used in unit tests? If so, is it possible to move it to the unit test source code tree?
See my question above regarding using mocks.
Maybe add the reason as:  LOG.debug(" EXCEPTION THROWN ", e);
I may be missing something here, but, say path is /a, listPrefix will list the objects with prefix /a/ (listPrefix appends PATH_SEPARATOR to the given key). If the returned iterator has no elements (so no objects exist with a key that starts with the prefix /a/), then how would getS3ObjectMetadata("/a/") return a non-null value?
Any possibility of metadata.getContentType() being null here?
This method sums over the second and third dimension.
use Bytes.memcmp()
Looks like even the brackets around i == j is not useful?
I think this will actually end up re-allocating when the second object is added to the hash map since capacity will be beyond threshold.
should be called resource.
Please auto format all files, so spaces are set properly everywhere
iteration over the entrySet is faster
Can you replace IDs with names in this log message?
Immutable?
Shouldn't we throw an exception here ?
Status.BAD_REQUEST would be more adequate here.
@rishabh-997 there is one in the application constants that convers this
here as well  java private void getSearchItems() { Preferences preferences = getPreferences(); ArrayList<Suggestion> suggestions = new ArrayList<>(); for (String recent : preferences.getRecentSearches()) { suggestions.add(new Suggestion(recent, HISTORY)); } mSuggestionAdapter.updateItems(suggestions); }
SecurityException?
i.e. assertEquals?
invoking combinations of close and releases here looks strange
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Thanks for adding these. Issue: Should specify which is null.
IntelliJ says the type parameters are not needed
Missing types
What about Arrays.equals? Also possibly an intrinsic in JDK9.
Arrays.setAll() is cleaner
please don't
Log the error cases.
use Arrays.fill instead for loops
For each?
Why not assign value when declaring: one line ?
Seems like this configuration is being created and not used. Does this test pass?
you can also test for number of attributes.
Is this going to be always not null entry.getContent() ? Could this throw NPE ?
This doesn't seem right. The JsonCodec in this handler supports either JSON or Smile, but not both, so we shouldn't accept both. Also, the error handling logic and getJson() API (used by error handling) assumes JSON. It wouldn't work for Smile which is binary.
Should we just add new ParseHttpResponse.Builder(ParseHttpResponse)?
Lines 56-71 shouldn't be indented while they are inside if statement from in line 55?
Style nit: Curlies not needed
style nit: we don't use braces around single line blocks
Please assume usage of org.drools.workbench.screens.guided.rule.client.util.ModelFieldUtil.modelField method
URL Decode would be necessary for parameter name and value
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
I think it is better to use static import here
"No Score" is not guaranteed to be the description specified for 0 in valueList. If defaultValue must be a LabelValue, then you would need to scan the list. But I'm pretty sure it doesn't, you can just make it a Short.
We can get NFE here and the values are from config so we need to take into account that they may not be numbers.
Just an FYI for future - You can use this method for this: <LINK_0>
I would use a StringBuilder for this (probably IntelliJ can automatically do that for you)
move a line below so you can use append
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
s/id/ID
Can we make toString a little smarter and print out what's appropriate for weather or camera?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
optimize
Can this be private, or is there another use case for default attribute outside the builder's call?
Why change to "unacceptable value"? Should we say specifically say "Request has a null value for header"?
Can't you merge 'if' with 'else' here ? It looks we can only support ObjectStat(bucket, object, headers)
Should also be in a method like for the other backends.
I prefer to keep the static import.
Why 5? With the minimum connectionTimeout of 1000ms this will generate a constant load of 5 connection attempts per second (200ms apart). / 2 gives a much more reasonable retry value.
It's already calling Math.min(long, long).
Avoid hard coding the path, use Environment.getExternalStorageDirectory() and the local path as a string resource.
The whole invalidation process may take a while. Should we improve this part so that it can happen without interference from other cache operations? I am interested in having other opinions on this. One idea would be to swap the underlying map while we do the operation as it can be discarded anyway.
If we are throwing runtime exception anyway when map is null isn't it better to just let it throw NullPointerException?
same for this handler. depend on tunnel, not on the entitlement
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
We could just always use the body instead of flipping based on the payload size.
If container is IWorkspaceRoot the scheduling rule must be WorkspaceRoot.
This could be entirely done as a stream.
It is here that runtime.matchesFilters(pickle) should be used to select the pickles to run.
Is this the right abstraction level to throw RestApiExceptions? RestApiExceptions make sense when this is called in the context of the REST API, but not when called from other places like from the ChangeInserter.
dyno_scan(int, String) calls dyno_scan(null, int, string) so should be ok to drop the if statement and always call result = client.dyno_scan(result, count, pattern);
You could use the set collector directly.
wouldn't all start times be invalid then?
I don't think you need the sychronized blocks (the concurrent hash map is good enough).
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
want to use try-with-resource instead?
I know you didn't write this, but it would be neat if you could extract a constant here with an appropriate name, while you're at it :)
invoking conn.remoteAddress() could be costly.
I think it should be non-null, since people have come to expect that for granularity: all. It would probably break stuff for it to be null.
All of this can be replaced with an ExecutorService
Cache primaryKeyColumns.size() into a local variable
NACK. this undoes #1272
Should'n it be range == null
This is not necessary.
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
This should really be initialized in onCreate as onOptionsItemSelected won't be called until someone clicks on a menu item. This means adminPreferences will have a high likelyhood of being null if someone tries to call it somewhere else. I'm guessing this was causing problems in your test? I've got some ideas around fixing that but I'll leave them on the test
Rubbish
You can't simply cast here (I learned this the hard way; the framework can return just about anthing here). Check the returned object for instanceof IStructuredSelection and simply return null otherwise.
What does happen when the action isn't of type check? Is this line ignored or failing or just doing something unexpected? It seems safer to only run this when it makes sense. For example by wrapping it in a if (action.getStyle() & IAction.AS_CHECK_BOX) { ... }
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
minor: you can return Collections.emptyList() instead
this noopSubscription seems used in many places, create a single one and reuse?
Please define s1 as final, it causes build failure!
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
This should be externalized. For instance: System.getProperty("hawkular-apm-test-local-dir"), with the value you have there as the default.
That snippet is basically the same as the other. Maybe we can move it to a single place?
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
Can you add assertInDirectory(file); ?
Should we catch throwable here?
what if valuelist is empty? should you check for that?
You might want to consider the ItemStack max stack size well, not just the slot max capacity.
What are the conditions under which this branch can happen? Can't we say that there must be a SharedSlot when this method is called? Making this stricter could allow us to catch other programming errors faster.
nit: put with the previous line
no need to move it above?
Why not return Optional.of(ImmutableMap.of()), like we do in FileHiveMetastore? It's expected that statistics might not be available for tables.
Space after cast (several occurrences in this file).
The RuleRegistry must not be registered if the managed provider is not available. Otherwise a rule from other provider with same uid as the ones from managed provider can be loaded into rule engine and all changes stored in the managed provider will be not visible (the rule from managed provider will not be available at all). For this reason the RuleEngine first has to be initialized with rules from managed provider and after then it is registered and give change to other providers to make make add their rules in the RuleEngine. May be the RuleRegistry must not be unregistered when managed provider is disappeared, because it can return available rules, only update command will throw exception
Do you mind explaining a bit why this changed necessitated a switch from 1 to 2 for provider id?
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Since you return in each branch, you don't need the elses.
The value only from partition column, use Unsupported partition type to make it clear?
Replace with a createParallelGroup (and add scanOnlyInScopeCheckBox and scanFuzzerMessagesCheckBox). Same for the vertical group but with a createSequentialGroup.
:o
dont think a setter type function should return the "this"
No need for a null check here, instanceof would allow both the class and null check as one.
same here, i bet noone needs all of them to be equal. don't make test code/reqeuirements leak into the main
the surrounding brackets aren't needed.
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?
We should not use this to set the BitSet size *aclInfo.getRightsList().size()*
Add default to the switch
This comes from when we pull the body out the camel exchange right? If somebody sends in the wrong type, the exception message does not seem accurate.
We could declare message in the try-with-resources, then move the null check inside and delete the finally block.
Why not String.format("(&(mime-type=%s)(id=%s))", mimeType, id);?
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
why not null as value?
Don't we have to say that this is uniqueId JDBC?
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
I'd prefer to not expose ResultSerializer as a JsonProperty, exposing only simple key values in the Factories and choosing the correct class in the implementation. This will make it easier to refactor the code down the road, while preserving the original configuration interface.
The producer is create using try-with-resource clause thus, the producer should be flushed on the implicit close() anyway? Thus, I don't think explicit flushing would help?
Check if byte[] b is null.
Could you drop this conditional and just write below as POWERS_OF_TEN[0] == 1:  double x = significand / POWERS_OF_TEN[exponent];  Maybe something for the benchmark to decide.
if the advantage of this compare to 0 <= b && b < 256?
The cast is not needed
Why store the length?
Don't think any method is going to throw an IOException. We can get rid of this.
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
You could also use for(Object nextSelection : structuredSelection.toList())
I would use "w" level in case of unsuccessful deletion
Optional: better to invert equals to avoid potential NPE
Which are the callers of this method? Are there any side-effects if an empty array is returned at this place?
final
final for both the variables?
It's possible between null checks that someone sets the subscriber to null when you retrieve it a second time.
typo
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
check if volume is null and log and return.
getGlusterVolume() from super class can be used
endDate.before can be used
Wasn't there the intention to exclude information_schemas and pg_* schemas from the result? I think in this class would be the appropriate place to filter the returned list.
Maybe remove the first :?
log with a message
This setting should not be enabled by default since headers may be C++-specific and not protected by #ifdef __cplusplus
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
Can this be private, or is there another use case for default attribute outside the builder's call?
I do not really like this intervention, especially if it is not necessary to implement the test. We are getting quite whiteboxy here...
Would you mind improving this test to use executeFile() instead of executeString()?
at a quick glance this looks contradictory to me: how can we know that Marker is a type annotation and not know the annotation type?
It seems that the following does the same thing with super.unparse(...).
IF EXISTS should be reflected in unparse
will VDSM's settings be equivalent to set "<on_reboot>destroy</on_reboot>" in the domain xml?
This annotation should probably stay, and again for parse below
Minor, but "extra".equals(tagname) would make this more concise. Java and its endless checking for nulls...
how about remove the null check and just have: "case".equalsIgnoreCase(name) ?
Put ITEM in front of OTHER_FUNCTION
Should be moved with other not treated cases
Unsigned types are not used in the current implementation. So, you can omit them.
typo in log message for word connection
Exception message should be more meaningful. Something like. Could not find dataSource with {id} for data feed with id {id}
Maybe log the exception?
static final String
if this is defined in tier 1 SDK, should we just use that instead of defining it again?
Return an int[2] here?
PMD/Sonarqube: Avoid concatenating characters as strings in StringBuffer.append
please keep the buildVmNumaProperties a void method and access the vdsId fron inside
I can't decide if StringBuilder is overkill. Seems like String concatenation is enough. What do you think @christiangoudreau?
This is missing maxTotalRows
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Why do we print a secret systemUserPassword here?
If disabled, we should not the forceRefresh attribute nor the representationToForceRefresh list.
.stream().filter(this::isMatchingEntityType).forEach(result.put)
You should be able to use the diamond operator here, i.e. new ArrayList<>()
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called.
I think this exception should be about a @ResultHandler annotation, is that's what's being verified in the MessageHandlerInterceptorDefinition#wrapHandler method.
personally I avoid names like o, i, l etc... Even obj is better. Also ... where is it used ?
Would you mind putting the lambda/function call in this map() function on line 52 in a private function? I think that would make it a little more readable.
BUG? you log the error but continue processing the invalid sequence number... what will happen? See call to m_gapTracker.truncate below using the invalid value.
This does not match the debug log below. We should ignore a remote Ack if we are the master.
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
To go up before the first "for" to avoid to call this code several times.
currentRemoteHostId ?
nitpick. Suggest to use a init factor " new ArrayList<>(batchSize)"
If there's a failure and rollback, the ongoing migration flag will be true until a relaunch, right? Does that mean that if the failure was caused by something that can be fixed, the user will need to also kill the app and relaunch for the migration to run? If so, that doesn't feel right to me.
Please move this to DBUpgrader. Also, use oldVersion < 1090001. Users might skip AntennaPod versions. When checking for equality, this skips the migration when coming from, say 1080100 instead of exactly 1090000.
these should be under a case 10: since the db would be upgrading from 9 to 10 and would run the migrations for the new version(s) only
Sorry, already removed this :flushed:
As the setSpeed method is deprecated we need a different approach here. Some more hints: * use edge.get(accessEnc) instead accessEnc.getBool * instead of setting speed to 0, set access to false
Consider wrapping this into the constructor, and getting rid off the setter? StreamEdge(isIntermediate)
We need to keep the throw exception as we are not changing the existing behavior
Seems like this will compare 1.0 and 1.1 as equal. I think this needs making protected and some tests written.
Do we need to extract this logic to a separate function?
please remove alias setting (should be encapsulated in addManagedDevice
this is probably not needed
this line is not needed anymore, right? because the VmPayload ctor already do this set
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
Should we just use a Set to store supportedGrains in the first place?
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
The hashCode() and equals() implementations depend on the current position in each payload's ByteBuffer. The implementations can also process the same payload bytes as it recurses through the child packets. The payload should be processed only when there is no more child packet, and it should process the whole payload regardless of current position.
I think you should keep the try
This drops the packet. This shouldn't happen just because it doesn't have the extension. I'd expect the wrapper to handle this logic.
Inserting line breaks in log entries can cause pains when reading the logs. Can we remove the \n?
foundData - does not sound like a good name. Any other choices?
let's rename -> setTopologyConfigId
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
In the meantime, we use NullPointerExceptionfor that (even if there is a lot of code not updated according that).
At the beginning of the method
is this supposed to be deadlineMs - System.currentTimeMillis()?
No need for final
exception can be improved a bit - "failed to flush within X ms, successfully completed Y/Z batches". wuold help distinguish between slow connection and no connection.
you're synchronized on shutdownGracefully. Is it possible we are active at this check, but then become inactive ungracefully? I'm assuming that is also synchronized? I see that the handshake case is covered below in the else{}
Why did you take out the isTraceEnabled() checks? Do you check for that elsewhere, or just decided to always write traces?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
extract false to a constant declared in the beginning of the class to declare the intent of the parameter, which then can be reused throughout the test file
@lautarobock Here too, let's declare throws Exception.
And why would you do that to begin with?
What is this proving? If you  groovy sh 'cat /any/file/at/all'  your log will contain  + cat /any/file/at/all
But you are not actually testing the credentials here. What then happens with src/main/ reverted? Is there a build failure, or are the credentials ignored, or a warning logged?
Looks like there is a copy/paste error here, and this should be indexFileChannel.
public synchronized
You can also use IO.close(bb) as IO.close will not throw any exception.
If the Deserializer is named, Deserializer. The Serializer should be call Serializer!
Personally I prefer to set all fields using this. in constructors, but you call the shots.
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
contributionList can never be null
Do we really need to test with more than 1 entry?
Why are you not using your UsbSerialDeviceInformationGenerator?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Please include clientTelemetryEnabled in toString() API
you can move this line out of the loop
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
Looks like you wanted to use append here.
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
You could combine this into the for loop conditional using && and removing the negation.
Does it need to be package private? Can't we make it just private?
Local variable could be declared List instead of ArrayList. Is this worth caching?
This should use LinkedHashSet, which would reduce the LOC since the !contains() check can be avoided.
Can this method remain private?
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
May need defaults.
Does shareName or directoryName need to exist here?
Is this method only used in unit tests? If so, is it possible to move it to the unit test source code tree?
We shouldn't ignore an invalid enum value.
The executeAndWait method should also be changed to expect a value in milliseconds (httpTimeOut is in milliseconds, not seconds).
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
I assume this fetches VLAN devices properly, i.e. if the iSCSI bond only uses eth0.101, this won't return eth0 right?
I don't think the poolId check is needed, if it is needed we need to verify that first and throw if it's null..if its null we dont check anything here.
This will create 0 connections. Didn't you mean < ?
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
Shouldn't we include just the SSLDs? Otherwise, if there are Kaifa smart meters in a system, we would be contacting those for their events as well.
@cuenyad Having 2 for is not needed. Iterate lotDepositDtoList and have a map with LotUID as key
![MAJOR](<LINK_1> 'Severity: MAJOR') Either re-interrupt this method or rethrow the "InterruptedException". [![rule](<LINK_2>](<LINK_0>
Maybe catch any Exception, and then after the loop, propagate if IOException, using something like Guava's Throwables?
Not sure about coding style, but I wouldn't use an else here ("else after return").
should this be altered to use the 2 parameter version?
Please convert baseDir to absolute path too. Otherwise, jadx skips all resources if run on file without full path like: jadx some.apk.
Do we want to return here so as to skip the older File.setWritable call?
Default action is missing. Should not it returns requestFailed(null);?
Just double checking if you added the log on purpose or forgot to remove it after debugging?
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
@Override should be on line above. Checkstyle/formatter config?
In my opinion, we do not need this log. WDYT?
These two lines get called repeatedly in (i.e., 87-88) several of the methods that follow. Would it be worth creating a private method that returns the objAcls?
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the binary data. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
This returns an optional. We should actually check if there are none in findFirst().
I missed it to change to return BinaryData.fromBytes(amqpAnnotatedMessage.getBody().getFirstData()) BinaryData will always have data, a null is converted into empty byte array inside BinaryData, So we do not have to check for payload.isPresent(). BinaryData store data in byte[] variable. so calling getFirstData will be efficient.
Maybe break out of for loop once we detect optional index, to avoid unnecessary compute cycles?
Nit: could you avoid static imports for non-obvious cases like this?
use final
why replacing lockKey by lockKey? shouldn't be lockValue by lockValue?
This block could be shortened if using Ordering.nullsFirst()
can someone review this condition? I don't think the log is printed correctly. If I understand correctly, it should be leader.getAndSet(isLeader) && !isLeader. leader was true and it was set to false.
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
Immutable?
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
I think it is better to throw exception
Nit: I would dispense with the elses since you return in the ifs.
We usually don final local variables.
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
can you pull this from a static string?
Can it be done as List<Deployment> adapters = services.stream().map(service -> getDeployment(service, routes)).collect(Collectors.toList()); By the way, creating each deployment by complete iteration over routes gives nice code but will have bad performance if the number of routes may be large. Is it realistic to have it more than 100 and the number of services more than 10? If not, the nice code may stay, if it is then another algorithm is needed that will treat each service and each route only once.
before with the other this?
Why do you use package-private access for this constructor?
Did this really happen?
Should be Localized in Android framework.
This could be made generic, share_image_via
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
We have another NPE here
This has to be cleaned up.
Is there any way to pre-compute these before processing the tuples? Perhaps computing an array of integers that represent the (ordered) location indexes for the selectors? We don't want to keep re-computing the indexes while we're processing the tuples.
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
This won't do. It logs PatternSyntaxExceptions. Just enter [ or \g.
You sure?
Is this the right abstraction level to throw RestApiExceptions? RestApiExceptions make sense when this is called in the context of the REST API, but not when called from other places like from the ChangeInserter.
Is order important here? Should the 2 collections correlate each to another?
I'm curious about the design choice that requires a new object to be instantiated for every basic operation. This seems potentially inefficient if these operations have to be performed many times.
same question here, do we account for the colo with single replica?
This could be null, we should probably handle this if the JIRA api changes again
Avoiding Empty catch. For example, you could use log
suggestion Preconditions .checkArgument(numExpressions <= 2 && numExpressions >= 1, "DistinctCountHLL expects 1 or 2 arguments, got: %s", numExpressions);
Don't need to return the Arguments.
Why did you synchronize this read operation, when you don't synchronize the write operation in captureFrom(..)? Also you should better use a Lock here, since a List should not be abused as lock instance.
As far as I can see, the boolean is not used anywhere, so maybe it could be dropped in favor of void?
Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files
Perhaps use mkdirs?
validate arguments before returning new rule
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
Please move this method just below getClaims()
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
I'm not sure what this indirection with the t -> business buys us
Yea I agree that is premature optimization. Lets avoid something that ugly unless data shows this is a horrible source of garbage that has to be fixed.
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
The first argument can be random.
I think this should be replaceFailed = false instead.
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
Very minor: elses are unnecessary.
java return disabled ? R.drawable.marker_disabled_other : R.drawable.marker_other;
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
We only want to take the hit of saving the message in a TL __if the poller is transactional__ - we can easily tell that in the XML parser and via the DSL spec, but not so easily via the @Poller annotation; we may need to add a transactional property to @Poller for that. On the other hand, any "around" advice that can throw an exception may need access to the message if it throws the exception after the proceed. So, I don't mind if we always apply it if the advice chain is > 0 length - that's probably the simplest solution that would work in all cases while only taking the extra unneeded hit if someone configures an advice chain.
objectRefs.get().acquireReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
result not object
result, not object
not necessary to add "due to"
in finally? You're not unlocking it at all!
Use logError(String, Throwable)
You could combine this into the for loop conditional using && and removing the negation.
Wrap the one line if with curly braces.
what is the purpose of testing a while loop? :)
This looks like a good candidate for doing ImmutableMap.of(Maps.transformEntries(...)).
Please describe this change The problem is that we have a lot of Java copy-paste configs for many primitives and in 1.0 release it should have the unified configuration to avoid strange cluster effects Do you have a test for this case?
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
@inverno We have 2 times "Second argument" :)
Please refer <LINK_0> We want to use Options class.
be a good citizen and call System.exit too :wink:
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
null? why not just a () -> {} ?
i18n
newVmStatic ?
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Could use a mocked Model to avoid the need to tidy up.
List<BreakpointMessageInterface> ignoreRules = Arrays.asList(skipBreakpoint);
you could forceMock(RequestBuilder.class and @Inject it as a field of DefaultRestRequestBuilderFactoryTest
This will work poorly if there is a lot of small groups (e.g: we will flush small pages and constantly resetAggregationBuilder). Additional condition here should be that aggregationBuilder accumulated enough groups.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
I'm not sure this can be null?
Should these define the default value? If so, then addDefaults shouldn't be needed, right?
Should we just use a Set to store supportedGrains in the first place?
mixing tabs & spaces
log with a message
Do we need to distinguish StreamsException and KafkaException (StreamsException is a KafkaException and both are fatal)? Actually similar question about KafkaException and Exception? The different error messages don't seems to provide much value?
:ant: multicast is one word.
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Why using empty string as first argument?
The addition of the "active = 1" check, is that because we actually expect id=:id to potentially return multiple rows or is it just being uber explicit?
503 Service Unavailable would be more appropriate I think
Does this do anything outside of test mode?
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
this method is only intended to validate the ItemType. Configuration validation should be executed in processBindingConfiguration()
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
Typo
I think this is a bit overly complicated as we can only copy the file if we find it (e.g. fileToExport is not empty). Moreover, please show a warning in case it is empty.
How about exception instanceof FetcherException?
You don't need to add it here. This class is only used for the field type in the entry editor, and there are predefined values for this field.
Can you explain me once again, why we store timestamp directly in ProducerRecord and still also serialize it? Seems redundant.
partitions.length is final, because partitions is final, so this doesn't need the lock. Are you adding this to get a code analysis tool happy?
This class is too kafka-specific. I think it would be more correct to abstract from kafka using TopicRepository layer
I think we can just go with the  @ContextConfiguration @RunWith(SpringRunner.class) @DirtiesContext  and avoid extra loads for the the same config in each test method. I that case the outbound-gateway-parser-config.xml should be renamed to the MongoDbOutboundGatewayParserTests-context.xml
Why did we switch out the old code back to this?
4h
Shouldn't this check be at the top of this method. Should we ignore working copies all the time?
Add final keyword.
We could also throw an exception if the transport client is configured with a user name and password, as that is only supported in the x-pack version.
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Should we better make this method package protected to only allow jackson access to it?
TextComponentTranslation allows ITextComponents to be passed to it, so the user's name should remain as an ITextComponent.
Need to add the types of the Estate card as well (i.e. Victory).
Maybe turn these three into a single if?
DefaultStainCategoryService calculates whether to add the 's' or not, could this one too?
Does it make sense to do all the checks in case there's some database shenanigans? Worst case, they'll be zero.
I think this would be cleaner if we add a second filter call. It can use a method reference: java .filter(this::skipGlacierObjectsIfNeeded)  However, this highlights that the method name seems inverted. filter() takes a predicate that returns true if the value should be kept, but I would expect skipXXX to return true if the value should be discarded. I'm having trouble thinking of a good name. What if we structure it like this: java .filter(object -> !skipGlacierObjects || !isGlacierObject(object))  Changing the method below to java private static boolean isGlacierObject(S3ObjectSummary object) { return object.getStorageClass().equals(StorageClass.Glacier.toString())); }
wrong order
suggestion return Optional.of("org.junit.platform");
as above: are spaces OK in namespace strings?
Why do I get the itching feeling that we should to seconds--; here?
Making only this message a constant only makes it less readable, and is essentially meaningless. It's a good idea to undo the fix or standardize the argument checking.
@davecramer Would it be better to do LocalTime.MAX.equals(localTime) here, instead of using the reference equality? Otherwise there will be a difference in write behavior between a LocalTime that has a value of 23:59:59.999999999 and when using LocalTime.MAX, even though they are value-equal.
With this Cluster mode for spark may not work. Though it may not be needed since the spark-interpreter itself is launched in a new pod. Usually driver memory might require changes as per application being run.
You could also use -> Objects.toStringHelper() from guava
do you need to add CRC here?
that class would be better with a builder, though I wouldn't ask changing it now
Why 0,8 if all we are setting is 7?
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
nit - I'd suggest creating a new variable called requestedFields instead of creating the HashSet in-line. Something like Set<String> requestedFields = new HashSet<String>(attributeOrder). The result is the same, but it helps keep the code readable for others.
This can be static.
I'd add an always-printed log message here too to make sure it's remembered.
Change LIKE to =
Same as above - make sure 56L is in array and is removed.
Make sure to test when 10.0 is in the array and you're removing with a 10 int argument.
add java doc what does it return?
You could combine these if-statements due to short-circuit evaluation. However, I wonder if perhaps getIdleChannel() should do this check internally and loop over all "idle" channels and return the first active or null?
You could probably check Jenkins core version here: Jenkins.getVersion().isNewerThan(new VersionNumber("2.64")) in order to optimize the call on the agent side. and to check JNR version before it . But it's rather polishing, which may actually break some use-cases with pre-loaded JAR files
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please add identifying for the Nuage VSP device to assist with operational debugging.
I think it might be nicer to register an anonymous inner class here instead of having this expose the PathChildrenCacheListener interface. Once someone gets one of these objects from the getter above, should they be able to register it with Curator?
Could you please use Map interface here (and not the implementation)?
Could you give here a little more formal description, e.g.: incorrect parameter value '%s' ?
why?
Remove else is redundant.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
This should be outside of the for loop, as there may be more than one set of temporary properties. Code: Ideally the logic from onClusterProvisionStarted should be extracted to a parametrized method, and called with different states from here and from that method.
Can't you return just the event itself without creating a new instance?
This map is going to get possibly large if we have a lot of rules to display. Instead lets try to avoid copying by keeping two maps, one static of permissions and one unmodified of the ones from the server.
Could you check for null or empty? Via StringUtils.isBlank
can these parameters be grouped into smaller and more meaningful objects?
I know we have an inconsistence here with all the controllers, but I would still remove public from the constructor and make it a final class as it should be.
This whole block can be simplified, no? You're effectively checking for negative health twice now.
Maybe some not-null check should be added here.
I think it would be good to give the user a little more of a hint about what has gone wrong/what they can do. Perhaps: suggestion throw new RuntimeException("This container's image does not have a healthcheck declared, so health cannot be determined. Either amend the image or use another approach to determine whether containers are healthy.");
![MAJOR](<LINK_0> 'Severity: MAJOR') Extract this nested try block into a separate method. [![rule](<LINK_1>](<LINK_2>
Interesting, I don't think I've seen the 'ToStringBuilder' class before.
Should this be trace?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Can this be private, or is there another use case for default attribute outside the builder's call?
why not check for null?
why not check for null?
check is unnecessary
Typo
Why do we use random node here? IMO we need to send task to the origin node and run GridCacheDistributedQueryFuture#cancelQuery there.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
System.out.println ?! Is this the only option ? Isn't possible to use some logging library instead ?
What about caching the list? AFAIK this method will be called multiple times on the same connection.
Need a process.destroy() here before throwing the IOException, so the cleanup can happen.
nit: If we make this method synchronized, then this synchronized statement is unnecessary.
If the condition can be checked with routingTable itself, why don't we move this sanity check to a few lines above, or to where EMRoutingTable is created (e.g., constructor)?
this.notify() would be consistent with L63.
Try to use CollectionUtils.isEmpty instead
Can't we use findMissingEntities?
It would be good to fix also the typo here ("Memeory").
wrapping
final, Lists.newArrayList(), etc
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
This check is probably redundant if we sanity check if netId == WifiConfiguration.INVALID_NETWORK_ID and return false at the very beginning of this method. In WifiStateMachine#handleSupplicantStateChange we already have: // Network id is only valid when we start connecting if (SupplicantState.isConnecting(state)) { mWifiInfo.setNetworkId(lookupFrameworkNetworkId(stateChangeResult.networkId)); } else { mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID); }
i don't know if this is something we want to do here, but it would be good to log the network id and the boolean too. then we will know if a particular network is enabled, who is to blame.. or after one is disabled, why the rest are also disabled.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
Could you change this into assertEquals(expected, result) ?
Hmm. Should the failure case be to show this message to users as the title of a search result? Seems like maybe the failure should be logged and the search result should fall back on some kind of best-under-the-circumstances title ("(Unknown content title)")?
You need to calculate the righ margin to account for the width
You need to calculate the righ margin to account for the width
Is this method supposed to also examine the results produced by the queued SQL statements?
why did you change to final here? should be outside of the scope of the patch.
this should be inside lock
WSTUtils.LIVERELOAD_SERVER_TYPE.equals(server.getServerType().getId()) is even safer, as it covers the _unlikely_ case of having a null id.
can you change name of this list because 'l' says nothing to me
@essobedo once used variable can be inline
Looks like this is the only reason for you to include the additional dependency. I think we can avoid that. You can use java.net.URI get the the query string from the referer and then just split by & and then by = to get the values. You should also use URLEncoder to decode the percent-encoded values from the query string. Then we can remove the dependency.
Again, constants would be nice for readability.
Does it need to be package private? Can't we make it just private?
IntStream.range()
Just inline the variable here.
We prefer nested try/finally blocks: InputStream in = openRobotsTxt(); try { OutputStream out = rsp.getOutputStream(); try { ByteStreams.copy(in, out); } finally { out.close(); } } finally { in.close(); }
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
Replace by Map<String, String> result = new HashMap<>(map.size());
minor, is it method scope for Visible For Testing? If not please change it to private.
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
I really like you are using HashCodeBuilder above. Why not use EqualsBuilder here (this would require to implement hashCode and equals in Provider too)?
Please put the && at the beginning of the next line. Makes it much easier to read.
This seems wrong to me because different objects may yield true. Same for hashCode.
Call Strings2.toStringAndClose.
(optional) Could decrease indentation with if (!iter.hasNext()) return;
suggestion if (a) {
You can simplify this a little like this: ColumnContextMenuItem<T> removedItem = items.remove(column); if (removedItem != null) { container.remove(item); } if the item didn't exist in the map, calling remove will return null.
rulesList will never be null, widget#getVisibility always returns a list instance.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
Could you check for null or empty? Via StringUtils.isBlank
This would never return a fully qualified host name.
I think we can reuse GWTDateConverter java static String format(final Date value) { return GWTDateConverter.getInstance().format(value); }
replace "ROW FORMAT " + s + " " with format(...) ?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Typo? What does this do? If partitionCapacity is null, this would throw a NullPointerException.
Why leave the capacityMap read logic outside of the validateAndGetPartitionCapacity? Note this will diverge the behavior of the check API and real rebalancer API. So maybe, the check pass but rebalancer fails. Let's just keep them exactly the same.
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
And this one is good, too.
We create a new map-operation for every call, so moving evictions here doesn't make any difference.
warn seems too relaxing for this kind of exception. maybe error?
constant or lineseparator from system?
This is never returned.
I would keep the original IOB strings and not use this GenericTaggerUtils stuff because it is unreadable. There is here something confusing about which annotation scheme is used, because actually it mixes here a Grobid prefix START_ENTITY_LABEL_PREFIX for testing a IOB prefix which is not the start of an entity but _inside_.
Cannot render banner ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
This should be mBannerPlacementId.
I think this is not needed since it is already initialized as false.
Let's be a bit more specific here: ("No FBO is associated with URI '" + arguments[0] + "'")
Here it's not the state of this class that's invalid, it's the given parameter. The relevant exception in such a case is IllegalArgumentException
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
These can't be thrown anymore?
Couldn't this if block move before the other if block? If the data has a size of 1 then the lower index will always be data.size() - 1.
Should we consider other measurement units, like kg?
nit: Suggest renaming iterations and its getter as well here
this and m_ is redundant
Two suggestions here: 1. You lost a linebreak I think. 2. use getOrDefault instead of the ternary.
Shouldn't we add the Transmit options field here?
I would add more detailed information about the sample here:  if (ioSample != null) { parameters.put("Number of samples", HexUtils.prettyHexString(HexUtils.integerToHexString(1, 1))); // There is always 1 sample. parameters.put("Digital channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getDigitalMask(), 2))); parameters.put("Analog channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogMask(), 2))); for (int i = 0; i < 16; i++) { if (ioSample.hasDigitalValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " digital value", ioSample.getDigitalValue(IOLine.getDIO(i)).getName()); } for (int i = 0; i < 6; i++) { if (ioSample.hasAnalogValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " analog value", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogValue(IOLine.getDIO(i)), 2))); } } else if (rfData != null) parameters.put("RF data", HexUtils.prettyHexString(HexUtils.byteArrayToHexString(rfData)));
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
No.
why do you need to start another processor? The monitor should trigger job model regeneration, shouldn't it?
No need
Can you use getUnchecked here to avoid execption swallowing?
visitMeterPrefix would be a bit clearer
You could use executeForResult(deploymentOpMain, masterClient); instead of executeOnMaster(deploymentOpMain);. The former will check that the operation was correctly executed, the latter has no benefits. If you do so, you could even remove completely the executeOnMaster method from the test, currently, it is only used here.
Technically it's the connector (jr://file vs. jr://file-csv) that differentiates between the two. I think this is ok, though.
It should be just an info, since end-user difinatelly can decide to disable asyncExecutor
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
This method should also synchronize on 'drivers'.
need to remove this print or convert it to log stmt
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
"is handled as if"?
there's an assertNull() for this; switch to that. Don't see a need for text here as the only text I can think of is "should have been null"
Bad format. You can probably remove the brackets here ;)
I think we should remove ObjectTriples... Originally, I created it as a Map. Perhaps we can modify ObjectTriplesIterator to TopicIterator that returns a Topic object when .next() is called.
Can you use BasicEntity.class.getName() instead? It's much better than hard-coding strings in case someone moves/renames/deletes the BasicEntity class.
maybe pull out a join method that takes varargs String... and joins them with a line break (using Joiner)? That'd make both this code more readable and the error messages the code might produce. I vaguely remember writing something like that in another file, but no longer remember where exactly - maybe look for Joiner in our test files.
With those 2 lines, you'll instantiate a new FilterInputStream whenever this method is asked. Instead, the generated filtered inputstream must be stored as a field and returned if already existing.
Since the "shouldLog" is already checked before instantiation in LanguageServerWrapper, I think it's clearer if we remove it from here now and to assume that any instance of this class will automatically create proxy streams.
can you call super.write here?
Can you use MediaType.PLAIN_TEXT_UTF_8 instead?
Do we want to override the Accept header, whatever it is? Or just append the version if missing? Both approaches LGTM. If we go for the former, then we could remove the @Consumes annotations from the Api classes, since the header will be always put by this filter.
Move both to variables for consistency.
This doesn't seem to ever be set to anything else?
Path and Package will NOT be available in Submarine.. is this meta-data essential?
we never use NULL, it is a bad practice in general.
missing the byte order: pcapPacketHeader.order(fByteOrder);
Why this one is not abstract ? This implementation is only working with old file, and ng override it anyway
If there are less than 28 bytes left in the file, it returns without advancing the file position. It causes an infinite loop when calling this method from a while (e.g. getTotalNbPackets()).
object -> function?
why removed?
sourceFactory -> dataGeneratorFactory ?
Is this effectively adding the external context? Is it guaranteed that the external context will not be returned from request.getRequestURI() already? (otherwise, the external context will be in there twice).
why not use new URI(scheme, host, path, query, null) to make it more clear?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
can use assertTrue here
1) Use fields for arguments: <LINK_0> 2) return the value of Parser.replaceProcessing: <LINK_1>
Why new String?
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
does it need to consider Windows?
I think it would be clearer inside the previous 'if' clause. I.e. if (action.isSetLease()) { ... if (action.getLease().isSetStorageDomain()) {
in /export action we use action.isExclusive(), please do the same here.
implement dedicated validateEnums(Action.class, action); it will validate AuthenticationType for you (see validateEnums(VM.class, vm); for details)
Per @sopel39 sueggestion: replace inner and outer loop to make better use of CPU vectorization.
Good that you use a StringBuffer instead of a String. It would be even better to use a StringBuilder instead.
It seems like it would be clearer to pull out 2 variables here, bufferStart and bufferEnd, and then check position >= bufferStart && position <= bufferEnd. (I think there are off by 1 errors in the currents checks. It will work fine, but it will potentially do an extra seek if you wanted to jump to the exact start or end of the buffer. ) I think there's a similar off by 1 error in the implementation of skip where it checks if it can skip or it has to seek. You might want to push this check into an isPositionAvailableInBuffer method in ExtBufferedInputStream instead of the getPositionInBuffer method. I think that would make this code clearer and make it easier to use that in
Let's take this out as the user can already do jwt -> jwt.claim("scope", Arrays.asList(scopes))
Would it be better to call jwt.getClaimAsString(this.principalClaimName)? The benefit is that the converter would work for principals of other types. I think this aligns with how AbstractAuthenticationToken#getName also coerces the principal into a string. cc @jgrandja
To conform with our team standard, would you please prefix the field with this.?
I would use stronger wording after the last comma, like "which usually leads to bad query performance." (Additionally, I'm not a native speaker either, but I believe you either need a "that" after "Despite" or use some other word, for example "Although".)
Please initialize this with setMaxInflightRpcs(BIGTABLE_MAX_INFLIGHT_RPCS_PER_CHANNEL_DEFAULT * BIGTABLE_DATA_CHANNEL_COUNT_DEFAULT)
Can we reference the constant here? There's an extra blank line after the return.
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
Please use the new method of adding one or more subtypes to a card. String methods will be deprecated.
Use {this} when referring to card names in text.
style nit: no braces, more occurrences below
Are these extra checks necessary since they all extend RealElement?
I would not mind such a change if scl_prefix gets filtered so it doesn't show in the outline. This is the reason why the eval was added.
I believe this call is useless when we have 150 instances
do we really need this catch block ?
I think this list should be final. How you managed to pass stylecheck?
Please add null check for volume.getAsyncTask()
possible NPE
use runVdsCommand method of superclass
Never. The thread sleeps in L454 until all remote sub operations are finished. We can unlock before handling result.
I guess you want to return Optional.empty() here
Similar to the RemoteOpHandlerImpl at the rangekey side, this for loop can be simplified with forEach statement
Here is another one.
It would be good to log these.
code style
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
seems unused?
static?
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
Any better naming?
if (f.isCancelled()) {...} else if (f.error() != null) {...} else {...}
I see that an instance of that object is created only when the log level for this class is DEBUG. May it's better to log operations in this class in DEBUG level also?
int -> Integer to avoid boxing on containsKey
With the requireNonNull, the null check would be redundant... I think...
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
assertNotNull() and assertEquals() in the following lines instead of assert?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
Use LinkedList instead, as we need to remove its head frequently in endInput.
As far as I understand, we can get rid of explicit type parameters is such calls
Why should we need this logic? The logic, including the null check and duplicate check have implemented in org.apache.dubbo.config.context.ConfigManager#setApplication. Why should be added it again? So as the other change in this file.
This should return the entity shouldn't it?
If you convert this to an instance method and define it in the ExternalTab constructor you can then init it with the dialogService and can directly access the dialogService method. manager = new PushToApplicationsManager(dialogService); So you don't need the getDialogService method in AbstractPushToApplication.java
@dkayiwa Are there any visits without patients? Should this not fail with an error?
Cosmetic: Indentation:  return npmUser != null && npmUser.getName() != null && npmUser.getPassword() != null && npmUser.getDate() != null && npmUser.getRoles() != null && npmUser.getType() != null && npmUser.getId() != null;
I guess _getDataSetQueryHelper_ is duplicated here?
Do we really want this to be public?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
How about a new ticket that introduces a MultiResult<T> type? List<Page<SearchHit<T>>> is somewhat hard to read.
@tarilabs I usually like to check that the ServiceResponse succeeded before doing any other assertions. It helps to quickly narrow down environment issues when the test suddenly starts failing for no apparent reason.
@jomarko you are asserting the result to be the string literal "true". The actual result is the literal boolean true. from "true" to true
This change is still incorrect
you can mutialize this code
mutualize code
It seems strange to deactivat errorCatch here ...
Have you considered using Regex with groups to parse the string. This would prevent some method calls and be shorter. Especially since the pattern is always the same - only the values differ.
A newline before the "while" statement?
what if input.length is a multiple of 256? wont this add an extra 256 bytes?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Can this be private, or is there another use case for default attribute outside the builder's call?
It's redundant if makeRequest is used to send request.
This will remove description set, please remove.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
This won't log the error. We want to use the public void error(String msg, Throwable t); overload, so we need to change e.getMessage() -> e
Is this really required?
Using Optional::get surrounded by try-catch is an anti-pattern to me. Instead, use [Optional::orElseThrow](<LINK_0> suggestion this.textureMat = Assets.getMaterial("engine:UITexture") .orElseThrow(e -> throw new RuntimeException("Failing to find engine textures", e));
doc
BlobProperties already has isEncrypted() which is added in this patch. You can call into it.
why not use BlobId.DEFAULT_FLAG directly here.
what if WebFaultException caused by absence of permissions to execute this query?..., i'd suggest using runQuery() and analysing return-value instead.
1) Please catch WebFaultException (not the generic 'Exception') 2) Please rephrase the TODO in a more informative way: "'getEntity()' always throws an exception if the entity is not found. It should be refactored to make it the programmer's decision. In this context it's legal to not receive a payload for this VM, so the exception is caught and ignored."
please make this upper case
assertEquals takes the actual result as the first parameter, but the expected result goes first here (the result is the same, but just to be consistent with the API of this method). Let's rename correctList -> expected and testList -> actual, and we can do assertEquals(actual, expected).
use createTempFile
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
IStateEx or IArgumentEx.
I'd like to see direct unit testing of withService and updateServices . There appears to be a fair amount of indirect testing of withService but updateServices gets little to no coverage.
You can extract the contextForType(..) code outside the switch.
shouldn't we use Builder here. coz, no one outside the package will have access to constructor.
Let's avoid null and rework to empty string
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[0]));
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
suggestion log.debug("Cache expiry completed for cache : " + cache.getName());  To improve readability? kindly check other places as well...
There are some formatting issues prior to '{' shall we correct in all places?
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
why extra ()?
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
System.clearProperty can be used instead.
externalize string ?
Is this call necessary? It is called on line 109.
Log the full exception
why did we use cast here? can we change it to -1L?
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
One of the need for acceptSession() API was to show user that it can fail. if session does not get accepted they need to do something? Either go to next session or have some code to log message about it.
this should be closed as well
Could u help me understand why before we didn't need to do a foreach with entity, but now we do have to do a foreach on entityCollection?
It seems like the number classes in java 1.8 have BYTES size constants (like Integer.BYTES). We could consider using these here.
no need use long type. int can fit the size.
Maybe m_data.size() * SIZE_OF_DATA in the for loop?
Please define s1 as final, it causes build failure!
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
This seems to change the flow of this test. Before it was depending on the notification arriving through the looper, now it is triggered synchronously. Wouldn't it be better to make a new test case listenerTriggeredOnCommit() or something that tests that the change listener is triggered _both_ on beginTransaction() and commitTransaction() ?
why 'scriptClass'? this should be something more generic like eg. 'pluginClass'
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
Is there a reason you are checking isAssignable? It seems like the parameter types for the Map are doing this for you. I think if someone bypasses the parameter types through erasure or something, they do so at their own peril. What would you think of something more like: java Class<? extends AuthenticationException> exceptionClass = entry.getKey(); Assert.notNull(exceptionClass, "exceptionClass cannot be null");
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
Oh yuck. ;)
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Please use try-with-resource for OperationContext creation
Context should be in a try-with-ressource statement, such as:  try (var context = new OperationContext(session)) { ... }
useless
why not instanceof ?
You could merge this for with previous by using TmfTraceManager.getTraceSetWithExperiment(trace)
Shouldn't receive a RuntimeException anymore?
How about adding the toLowerCase() here and then it wont be needed later?
Can be delayed to after the following check, avoids creating the strings unnecessarily.
Can be delayed.
Shouldn't those line be removed?
iface.getAddress() might be null, therefore the list will include null element. It may result within a false positive in the comparison below (in fetchServers) therefore the list should be filtered out null elements.
could this be private ?
checkList ? u mean errors ?
Given that this case statement spans two lines, I think it might be time to make this switch align more with the conventional format: java switch (path) { case FIELD_NOTIFY_SETTINGS: validateNotifySettingsRequest(payload); break; case FIELD_EMAIL_COLLECTION_MODE: //   }
Should this mention why it isn't valid, something like Value [%s] must be of type boolean for path [%s]'
Why return null?
why would this be required again?
Please init ArrayList size.
Don't need to call deleteOnExit
This test needs a verification.
This test needs a verification.
i'm really not sure why this is hard-coded for TextView?
maybe we should try different jenkins URLs in the loop since we have this loop in any case
Should not be this thread daemon?
Rubbish
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
This is missing a line return true;. Otherwise, it will fall through and execute the next case, too.
int mapSize
Please use abbreviation for Index(Idx), check coding guideline.
This should never load cubes
What is the purpose of cumulative after this change? When is map cleared?
no need to invoke valueMatchingPolicy.matches() in line 71 and 83
Can't you return just the event itself without creating a new instance?
As far as I understand, we can get rid of explicit type parameters is such calls
Use LinkedList instead, as we need to remove its head frequently in endInput.
Why is there a space between function name and parameter? AFAIK it should not be there  checkFBMD (String
assertThat(build.getConsole(), containsString(customWorkspace))
Shouldn't there be also a check that old name does not exist anymore?
All format changes should be done in getConfiguredJob.
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
baseId +diagram
createPackage mapping should take the toolsection in parameters and create a ContainerCreationDescription tool.
Why is it better to use more than one scope to test?
Removing test because you can not fix it is usually bad idea
A single test shouldn't run the context twice ideally.
What about this else case. Here also scheduling fails but we are not showing any error?.
Shouldn't it be logged in debug only?
no need to manually get from db, you can just use getVdsGroup()
Add the command that is being executed to the log
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Could be a try-with-resources.
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(byteArray)) != -1) { out.write(byteArray, 0, byteCount); }
1 -> numInputChannels ?
Why are you using an Iterator instead of a for loop?
check if getters1 is null and remove firstTimeStream
(implementer's choice) - we don't check for -1 here, it'd be ideal to encode this in the type system
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
} else {
Missing final
Unless this needs to be protected it should be made private
Unless this needs to be protected it should be made private
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
Don't know if this is just a gerrit foobar, but the indentation seems fishy here.
This is no longer paramConnection, just connection.
suggestion Assert.notEmpty(query.getIds(), "No Ids defined for Query");
What is the difference between queryForPage and queryForList?
I'm still torn on the naming. Spring Data typically adapts the store-specific operation naming to stay as close as possible with the original operations in the store. The names queryForList, queryForObject,   originate in Spring's JDBC Template where the method expresses the intent execution/result intent given an already formulated query (SQL in the case of JDBC). For Elastic, this would be search (or searchOne). What if we deprecate queryForObject (and leave the method signature as-is) and introduce new methods? We simplify migration and we can introduce methods that follow what happens in the store itself.
Simpler would be to call this method from the overridden initialize() method from this class. That way you will not need the templateValidate() method in the upper class at all.
What about SavingState and RestoringState?
please change to equals()
can you also test the case with begin > end?
so is everywhere using sample_value for human calling method?
braces
All configuration attributes should be taken from the model, not the widgets.
Why these shouldn't be overridden by users?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Isn't a LinkedList better if we don't know the size (to reduce reallocations and copies)?
Change first occurrence to Set
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
I would have put it after the createAnnotationAndAddSubscription call.
same suggestion as above
Yes this is the first thing i tried. But when I tried to empty the previous mails I couldn't get it to clear. If this works then fine for me.
fos can be inside try ()
The Exception message should contains the original IOException ?
One of 2 things should occur here: - Opt A) throw the exception ( add it to method signature ); not the generic Exception, but the IOException one - Opt B) set file to null, so it ends up getting returned as a null object, rather than a corrupted one If none of the above occur, and in a scenario where some exception takes please, the person leveraging this method would never know of it, and rely that the returned File object is a solid one.
Do you need all those empty lines, its a bit confusing to read
This looks good to me. A minor nit, can we change the condition around. !IsNull looks like a double negative to me. Something like if (isNull) throw UsageAuthenticationException; // no need for else return SSOStateSerializer.serialize(tokenItem);
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
Remove this check after merging #139 to develop and synchronizing this PR with develop.
I think there is a concurrency issue. Multiple threads can insert the same query in this line and DefaultOperatorChainImpl 145 line.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
@xpdavid is this the right thing to do?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
I see that this was the behavior before this change, but is it intentional that this method just logs an error message, but still completes successfully when the bucket name is invalid?
Remove extra semicolon.
Let's include the group name and say it's getting the ids that failed.
Good spot! We could actually do this: java authCardDetails.getAddress().map(AddressEntity::new).ifPresent(addressEntity -> { //   });
Minor, but could you make the height and width different? It provides a little bit of protection against the values being accidentally transposed.
I actually find the old mini methods breakdown a bit easier to read...
Can't you create a function that will create Observable from current operation and apply scheduler? Will save 2 lines in each operation. Same is applicable for Completable and Single, I believe :)
This is duplicated several times.
Why is this important for this test?
assertThat(entries).hasSize(3); the same for several occurances below
assertThat(related).hasSize(2); the same for several occurances below
Use "assertEquals(List.of(bibEntryExample3, bibEntryExample4), entries)". Hope, this works. Otherwise, a conversion to a set and comparing that could work.
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
I'm not sure why but we allow to set null bean class. If you remove toString() here, then this method should not throw NPE and the resulting string should be the same.
Do we want the toString()= in here ?
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
It seems like this happens even if there is no filter. Is that right?
How about making these constants as static variables?
Shouldn't we use empty list here ?
Use same order as the field declarations.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
replace with persistCommandIfNeeded
please have all the mutual behavior (locks/check if the execution has ended) in performNextOperation()
this is relevant only for live merge (after we modify the command parameters)
Is Itemizing (or promoting parts of) request option, to limit to applicable ones?
_Off-topic: Don't know why we used the <?> everywhere in instanceof checks - they are not really needed and add no value here. Nevermind, you don't need to change all occurrences in this PR._
The control-flow is somehow 'overlapping' because the if-else-block cannot be substituted with a function call. Please use this more 'straight-forward' version: java if (this instanceof PriorityQueue) { return (PriorityQueue<T>) this; } else { final Comparator<T> comparator = (this instanceof Comparator) ? ((Comparator<T>) this) : (Comparator<T> & Serializable) (o1, o2) -> ((Comparable<T>) o1).compareTo(o2); return toPriorityQueue(comparator); }
Exception is never thrown
Why not just call the constructor here like it was called before (new DeviceMessageMetadata(metadata))?
Why not just call the constructor here like it was called before (new DeviceMessageMetadata(metadata))?
Do we need String.format here? Seems like String concat would be fine.
other methods like this put name first, then id. switch for consistency
It seems like you only need synchronized while calling this.clone(). I don't think this entire method needs to be synchronized. Once you've cloned this, I think you can call .reportMetric() without holding on to a synchronization lock.
Use FileHelper.safeClose(rs);
This belongs in the service that deals with the scheduler database
I presume this means we are out of pages..
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Let's use stream API instead of a loop.
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
Shouldn't you be initializing the SSLContext here the same way you do it in the SocketFactory? As is, I don't think there will be any hostname verification for this client.
propagate a proper exception here.
If this is only for testing, use stream api
no need to specify type on RHS
final, Lists.newArrayList(), etc
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
format as final String[] array. Rename to errorMessage if possible
Better to return empty collection rather than throw exception.
error message should be changed to reference actual problem of "not a leap year". See existing implementations.
resolvePreviousValid(...) - to better guard against future failure, don't check day-of-month for year-day/leap-day, just coerce it:  if (month == -1 && isLeapYear(prolepticYear) { return createLeapDay(prolepticYear); }  (because there are situations where day-of-month may not be set). Month/day-of-month can't be out-of-range, and don't need the full checks (ie, just instantiate via constructor, don't route through static factories). The whole point of this method is speed and leniency.
Use IllegalArgumentException rather than DateTimeException for NPE checks (multiple occurrences)
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
if volumeId is null then we will have NPE here i think its safe to send null to getById method, no? if so then the null check on volumeId can be removed and this will prevent NPE
Can't we throw here something more meaningful? Where are you using this query? how does it feel in this case?
I would suggest we add one more console operator that would receive POJOs. Most downstream operators expect a POJO hence having it in example would be good.
Why is input generator called modifier??
now that the expected value is updated, is the replace all still needed?
if(!(o instanceof LegalInformationComplete)) is better, will not break the equals contract in case of inheritance.
White space.
Is it intended to not compare the size of the stack here? (FluidStack doesn't take size into account normally for equals, though it does for hashCode)
Rename this local variable to gid as well, like the overall renaming you have done for lrecId.
Replace with logger
final
why not null as value?
better to return an Empty Map, otherwise callers would need to check
Please ensure that null value won't be treated as string "null"
Do you want these to throw a ValueExprEvaluationException in order to follow the Function interface contract?
These two lines should come before the if. (Remove in the other branch.)
How about assertArrayEquals(new long[] { 2, 2 }, values); ?
overall the commit is very good, but this method might be misleading - it doesn't set anything if the field belongs to a probe.
Same concern as above.
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
use createTempFile
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
This should be replacable by switch (solverStatus.get()), as all the actual state mutation happens in solvingTerminated()/solver.terminateEarly() as I've suggested above.
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
since we did not advance so the event is not thrown away really.
It doesn't seem very reliable to me, because sometimes interruption status may be consumed (due to bugs). So in addition suggested to add "stopping" flag to RealtimeManager and check it here in addition to interruption status.
This should be log.error. Don't know why other statements here use log.warn
Mind renaming this to just requestOptions, as we removed the includeResponse flag?
Why no else here?
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
spacing
SpScheduler already does that in SpScheduler.shutdown(), you just need to offer a null task to MpScheduler. MpScheduler owns m_tasks which can be used to offer null task.
Should we log this instead of printStackTrace?
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
Is this conversion really necessary? The SUT does not involve an array at all.
Don't think the "Tenor" in the toString adds any value now. Merge toFormattedString into toString.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
have a default constructor with reasonable default values
@xpdavid is this the right thing to do?
They are mutually exclusive? Or is that a micro optimization?
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
return null to make this more explicit ?
start
ms
These achievements would be awarded even if their prerequisites had not been; perhaps a helper method that checks the achievement's parent before awarding it would be helpful here.
there is no separator between the versions. would you mind replacing this with : for (int i = 0 ; i < versionSet.size() ; i++) { sb.append(version.toString()); if (i < versionSet.size() - 1) { sb.append(','); } } return sb.toString(); In addition, it seems that this will become common around, maybe it should be pulled into new class, say VersionUtils ? (the class could be added next time there is a need for this).
Here return getName + '=' + formatNumber(getValue(), base); // trailing space it would be nicer.
Please avoid code style changes like this to existing code.
It can be written as return restTemplate.postForObject(verificationUrl, request , JsonNode.class).path("success").asBoolean()
new ObjectMapper() As above. Inject it please.
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
You don't want to use an exception that extends MyNakadiRuntimeException1?
can this happen? why not checking before cloning the whole list?
here too: tdigestPoint and below
Is there a need to move from getters to fields here?
Why are these probably incorrect?
hint: can we merge all these three "if" clauses? The same goes to equals method. You can break lines before "||" for better view.
Is it worth moving the reporting out of the synchronized block (though I wouldn't expect convention on that span)?
for these down, you don't want to early return as they remove data from the map (we want that data removed even in noop in case a span started before the tracing component was set to noop status)
.inc()
use arrays.copy? or system.copy?
Great! It was strange, that here was untyped array. Great catch!
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
Use logging instead of e.printStackTrace()
Can we define a final CONSTANT for the MD5 ?
Would we want that exception to make it back to the JS caller?
Typo: reassigned
This looks like a help string that really is intended to go to stdout
I'd make these numbers constants
It would be helpful to indicate what is invalid about the name. Is it the underscore at the start?
this hardcoded value can be replaced by ImmutableRelationshipField.class.getCanonicalName()
can we also have a test that validates the case when we have a none-string field in span_ctx? (Validation should fail in this case)
You can use CollectionUtils.toImmutableList
Wow. This method is much more elegant that it was before :tada:
filter(Objects::nonNull)
Spacing is wrong, Ctrl+Shift+F this part
checkArgument looks like the wrong function here -- should it be checkState? Also, missing informative message in the case when the check fails.
just Exception pretty sure, you can specify it
@bxf12315 Set<String> set = Collections.singleton("Extra");, also instead of "set" it could be named after set of what it actually represents (for better readability of the code), so e.g. in this case Set<String> headers... or something like that.
@bxf12315 the same as above, please use assertThat from the AssertJ library.
@bxf12315 same as above, please use assertThat.
Here should be NOT_INCLUDE_DEFAULTS
Please rename to something like originalDirectBuffersResult or at least originalResult.
please remove the spaces before }. Ideally add new line before the } instead of the spaces.
need to add them here
You could also use -> Objects.toStringHelper() from guava
return new StringBuilder().append()....toString();
This should check the endorsedBy field I guess, since that is what is displayed in endorsed responses.
Why we should change behavior for the deprecated method?
get(). (Btw since inner is plain, this check may end up hoisted and you'd never see it turning null).
why not process all files?
This is dependent on the platform's default character encoding. It is always safer to specify a known encoding that is required to be supported by Java, e.g. UTF-8 or ISO-8859-1.
Should we be caching the scaled image as long as height/width don't change? Or do we scale them a lot?
Put ITEM in front of OTHER_FUNCTION
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
If this should never happen throw an IllegalArgumentException instead.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
AFAIK Writer::close throws IOException, so there is posibility that exception is thrown by flush method will be suppressed.
Try to use "response.getWriter()".
This should be log.error. Don't know why other statements here use log.warn
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
highlight this and extract maybe into a method that return bool
is this check necessary?
!isEmpty
suggestion throw new RuntimeException(String.format("Failed to parse geometry from bytes: %s", BytesUtils.toHexString(argumentValues[i])));
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
what is being tested here? how is it being verified that the second thread actually blocks?
Minor: same as in other number check, WDYT about checking for the decimal point?
ParseUtils.isQuoted would be good for this.
"else if" maybe?
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
suggestion if (storeSupplier.retainDuplicates() && enableCaching) {  Should we only log if we're changing the configured caching? (Also applies below)
please double check that marking the end of things are being done in the right place (that is, do it in the finally if you want to cover all exit paths).
Use constant
Could you parameterize all the logging in the binding, in order to avoid lots of unnecessary object creation and garbage collection?
Please keep it in info level.
why not set serverCnxnClassCtr to NIOServerCnxn by default to avoid looking up the right constructor every time we want to create a new connection (a bit of a hot path)?
isTraceEnabled is missing here?
should be tied in to the FileSystem instance lifecycle too: an FS instance should really have a weak ref to all leases created under it, and fs.close to stop them all
setText in both cases (null defaults to empty and the append is not required, is being called as set).
this can be static
Could you please add clear message for case when assert failed?
Suggestion: "--active and --inactive options are mutually exclusive."
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
better to do !containsMacro("filePathFormat") check first.
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
This could be null, we should probably handle this if the JIRA api changes again
Let's move System.currentTimeMillis() somewhere to one source, as sharding logic is dependant of time and we may need some accuracy tweaks for it in future or whatever.
I believe these 3 lines should be moved to BMT, it's his logic
can you make one statement instead of two?
Trying to follow this. The check above has failed, so this is handling the transactional case, which means we should be in the abortable or fatal error states. If we are aborting and we can bump the epoch, then sequence numbers will be reset after receiving the InitProducerId response. If we cannot bump the epoch, does it make sense to reset sequence numbers here? It should be for the partition that raised the UNKNOWN_PRODUCER_ID error, but how about the rest?
nit: we might want log different message if we're ignoring due to a fatal state instead of due to a bumped epoch or ID.
Why the conversion to array? Also probably better to use the log call that only creates the string if the log level is high enough, but it seems the SLF API doesn't support that.
Let's move this line below, just before the requiresFBO line.
This line can be moved below, just before the renderingConfig.subscribe line.
ResourceUrn into static final field please. Here it is not strictly needed as this would be the only usage, but it would make this node more consistent with the others and it will be easier to eventually make a big bunch of all of them and handle things differently.
formatting
Locally, a ./gradlew test now fails on many tests. Does it work for you? I believe this test keeps a server running. Is that indeed the case? If so, please ensure it is cleaned up after the test completes...
maybe we should try different jenkins URLs in the loop since we have this loop in any case
Need to parse currency separately to notional schedule, with notional schedule parsed in parseRateCalculationLeg. As it stands, you've made notional mandatory for parsing KnownAmountSwapLeg which isn't true.
can be static
what happens if brandId is null at this point?
Should we consider other measurement units, like kg?
What if the string doesn't end with a " or '? You'll strip the last character.
Is this still needed after removing the download stuff?
There is no need to mock api calls to implement this test.
If I remember correctly this call to "build" isn't required, as the "options" method accepts an object and also a builder. If it is a builder it will call the "build" method internally. Same for the other calls to "build".
No need for a builder and a list here. Something like the following is more concise and easier to read?  java immutableEnvRunList.put(e.getKey(), ImmutableList.copyOf(e.getValue()));  Or use the more functional approach:  java immutableEnv = Maps.transformValues(envRunList, new Function<List<String>, List<String>>() { @Override public List<String> apply(List<String> input) { return ImmutableList.copyOf(input); } });
this should move to the applyUserChanges method
Do we have only two types of disks? Even if we have, this code will fail when we add another type. I think we should check for LUN type before trying to update one.
I don't really see any reason to add this else, but if you already decided to add it, it should not be in the execute phase but in the CDA phase and prompt a proper message to the user.
please verify response on remove()
Using printedTable might make these assertions a bit more readable.
Use the enum Dark...
It feels to me that there is much code duplication between this and DateTime.truncate
suggestion Unit unit = getUnits() .filter(value -> cssSize.endsWith(value.toString())).findFirst() .orElseThrow(() -> new IllegalArgumentException(String.format( "The parameter string '%s' does not contain valid unit", cssSize))); String size = cssSize .substring(0, cssSize.length() - unit.toString().length());
isEmpty()
This block could be shortened if using Ordering.nullsFirst()
Please replace this ^ with "log.error(...)".
It looks like protected final Set<String> labels = new HashSet<String>(); is not part of equals/hashCode methods, same as in BaseSubprocess.java. Not sure is it correct. @romartin any ideas?
This variable is very badly name if it's supposed to be the serializedUserReference.
Local variable could be declared List instead of ArrayList. Is this worth caching?
nit, Collections.EMPTY_MAP?
also these *xx things should be constants.
I know this metrics is helpful for testing but in practice I feel like we don't really need it. The other two inconsistent metrics should give us sufficient alerting. What do you think?
Typo? "BlobDet4acryptionCount"
create a member for ClusterServiceModel
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
Since the VM subtab always uses this query, I would encapsulate it inside VmAffinityGroupListModel and make its constructor no-arg.
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
what's the advantage of having so many *API ? Couldn't they be collapsed into DiscovererApi maybe?
kind of curious what these magic numbers are
format as final String[] array. Rename to errorMessage if possible
We must never remove resources from the resource set that are not unloaded, as I would expect adapters attached to them or their contents (such as the UML CacheAdapter) to leak memory. Any references to objects in these resources from resources that aren't being removed must be changed into proxies by unloading. I don't see any unload() calls.
Please return an empty RepositoryDTO here
It's advisable to start variable names with lower case
we never use NULL, it is a bad practice in general.
If you make the EMPTY_EXPIRES, you could use it here.
This can't be moved, the sleep above needs to happen after the call.
@dmzaytsev try to use org.apache.commons.lang3.StringUtils#join() here. It could be more visual
Also here it's still Image010 and in test above
You can simplify the if-else block to Java if (path == null) { return other.path == null; } else { return path.equals(other.path); }
Please supply the missing curly braces.
why?
brokersResult.brokerResult looks a bit unclear. Please consider renaming to something like addResult, registerResult
Can you also include the workspace ID in the message? Just in case.
same, we can delete LogReplicationDiscoveryServiceException.java file now.
The status are not unique so it pointless to have assertions for those fields, instead you need to compare the database id to ensure it matches the expected.
J) we should use chamberId instead of divisionId. There is only coincidence that divisionId is equal chamberId.
Is assertNotNull adding any value to the previous assertion?
why exit here ?
Add default to the switch
Why we want to fall through into the loading dialog in case of error?
We already checked post != null above.
Calling getPostListAdapter() will create the adapter if it doesn't already exist, so instead we should use mPostsListAdapter != null here.
do the comparison the other way around
Please rename this to eObjectMatchEngineFactory or something closer to the real use.
Given the number of times this pattern is repeated, this should be extracted in a common "setupTest(String nsURI)" method. Or even better, "private Comparison compareWithPostProcessing(Resource left, Resource right, String nsURI)" where everything except the "assert" would be extracted.
this seems dangerous, any reason not to manually construct the array as you did above?
nit: can be final Vector<URL> resources = new Vector<>();
Could use return ParameterUtil.toMap(StringUtils.split(processArgs, ","), "="); .. does the same thing.
Can you emit a warning when this happens? I think it could catch people off guard otherwise.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I think we will have to discuss whether or not to include the fromKafka functions in this class.
This could be null, we should probably handle this if the JIRA api changes again
Is there a need for an exp claim, and do we also need to account for time skew?
this block looks NPE fragile. Do you think it would make sense to catch NPE and rethrow with some meaningful message? Or check potential NPE places for null ?
Extract properties.getRest() into a variable.
typo
could put the loop inside if block? i.e. java if (!WAKEN_UP_UPDATER.compareAndSet... ) { // Busy loop ... while (wakenup != WAKEUP_NOT_ALLOWED) { } }
Thoughts on putting log messages in a Utils class?
Could not this run through without asserting if the Converter is never called?
This is essentially the same as:  java Observable.just(value).to(o -> { o.subscribe(subscriber); subscriber.assertNoErrors(); subscriber.assertCompleted(); subscriber.assertValue(value); return subscriber.getOnNextEvents().get(0); });
What do you think: java if (!context.getDestinationType().isInterface()) return context.getMappingEngine().createDestination(context); if (SortedMap.class.isAssignableFrom(context.getDestinationType())) return new TreeMap<Object, Object>(); return new HashMap<Object, Object>();  to reduce the deeply nested if statement. And we prefer no curly braces if there is only one statement in the if/else as our coding stye.
I don't think this optimization of repacing .equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't have the same instance of feature on each side of a comparison...
It is better to use ArrayDeck here
It seems .equals() has been replaced by == I believe this may be a problem, because it assumes that the same instance of meta-model is used on all sides, and I believe this is false in some weird use-cases (with dynamic EObjects involved). I may be wrong, @laurent.goubet should know.
Ok, this is what I don't quite get. Why is this feature being removed here?
nit: Make these this string and the one below static final variables?
Since the <credentials> element was blank, this ClearPass response almost certainly doesn't actually contain the end user's password, and so it's probably fine to log the raw response.
/s/else/elseif
This is inherently dangerous. sharedList is a CopyOnWriteArrayList which is _safe for iteration_ even while it is modified. However, once you abandon the iterator, it is possible for the sharedList size to decrease while you are in the loop, and sharedList.get(i) will generate an ArrayIndexOutOfBounds exception.
We could omit the second Integer.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Please move this check into the null check bellow, since we are already checking if this.key == null.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
- disabledFg Color variable should be created only when needed. i.e. after below condition is met: if (foreground!= null) {
- disabledBg Color variable should be created only when needed. i.e. after below condition is met: if (background != null) {
minor: this v == null check is unnecessary.
ImmutableSet<String> itemUris = StreamSupport.stream(items.spliterator(), false) .map(Item::getCanonicalUri) .collect(MoreCollectors.toImmurableSet());
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
@Serranya same here. See above.
@raphaelln I'm not convinced about these finally blocks... Can't we just invoke multi.body().close(); without finally?
@ekondrashev let's use new joiner here on ; character and avoid line length checkstyle suppression
why not use UNSPECIFIED_ALTERNATE_ALLELE_STRING here?
mobile and desktop tests are more of less the same - please re-use the code to avoid duplications
No need to check for poll validity in this test - this one should only verify voting part
Would it be better to do something like this instead of catch(. . ):  finally { if (!ackCallback.isAcknowledged()) { AckUtils.autoNack(ackCallback); } . . .
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
Needs a better error message.
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is easy to mistake for "hadoop" when someone is reading this code
Why not prefer the new one (spec) if it's set?
We shouldn't expect this to be an Expression. Fix the test rather than having it handled here.
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
you could use Exceptions.expectExecutionException();
Either catch NPE only or add Exceptions.propagateIfFatal.
looks like directory separator is missing here
> DRONE_TARGET_DIRECTORY it means that the last update cache is stored in the target directory, right? I'm not sure if it is a good approach as every new run of the test suite will require a new request - I had expected it in the ~/.arquillian/drone directory. On the other hand, I have to agree that the probability that you would run out of the limited number of request is very low.... Why you've decided to put it into the target directory?
Can use java 8 paths.
nit: We should verify the results are not recorded here as well.
This test appears to be duplicated.
In current implementation, killed is printed out only when the session attempt has been done...?
What's the chagne here, just whitespace?
final
Please write a unit test to test this transformation.
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
You can replace the for loop here with values.forEach(result::add);.
this seems like it should be exception != null or result == null
try-with-resources for FileReader
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
Do we have operationType in the message?
velocity..
Why are you removing this? LogoutController#init() says //If sub-classess override this method they MUST CALL super.init() at some point insider their custom implementation. Removing an existing explicit invocation to a method in a parent class could cause uncaught errors if we are not sure about what we are doing. Please add it back in and we can solve any new issue that this could cause.
You can just let the loop below handle the waiting - it'll all be logged, then.
Nit: Could you use Isolate.MAX_PRIORITY to make it clearer what the value is?
Should also be in a method like for the other backends.
Default action is missing. Should not it returns requestFailed(null);?
![MAJOR](<LINK_1> The Cyclomatic Complexity of this method "restartInErrorTask" is 13 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_3> ![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: org.ow2.proactive.scheduler.common.exception.UnknownJobException, org.ow2.proactive.scheduler.common.exception.UnknownTaskException [![rule](<LINK_2>](<LINK_0>
Remove else is redundant.
We need to create a new method in ApiErrorExtractor to check this (see other methods in this class for an example)
K **is** comparable because K extends Comparable<? super K>. We can't use natural comparator here. I believe this is correct fix:  java final Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo); RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?
We should add some log to the validation process
nit: Can this message be improved to state that one of them is null, how about "Either EnvironmentDto or NetworkDto is null. Neither them can be null."
I see that all the public method expects a VM as a parameter, why not to create it a member of the validator class instead of having this class stateless? It seems that the c'tor of RunVmValidator should get a VM on which all of the validation should be executed. This might be a bit out of scope of this patch - so i don't mind that a patch will be added as a follow patch to this one.
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
/s/else/elseif
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This magic number needs to be a named constant somewhere.
To make assertion message unambiguous I would change "status" to "instructions".
final float sleepDuration = (int) ((double)  feels odd.
Remove stack traces
:ant: multicast is one word.
What about using EnvVars expand() ? <LINK_0> If I understand it correctly, would also allow usage of Environment Variables?
Preconditions.checkArgument() on all non-null arguments to prevent bad config
Is there a reason why you don't use [Collections.emptySet()](<LINK_0> here?
You can also use StringUtils here, like StringUtils.format("Exactly one of %s or %s must be present", target.name, max.name)
Unsigned types are not used in the current implementation. So, you can omit them.
Can we avoid this switch/case block?
Put ITEM in front of OTHER_FUNCTION
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
add something like checkState(lookupSourceNotNeeded.isPresent(), "Lookup source built, but xxxx not set");
Is ADDED the right event received for a replace operation?
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
If we open up the expression for user specification, this if test would have to go inside the default FunctionExpression.
We don't really need to create a new deserializer for each request.
Make non-null.
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
Don't catch bare Exception
Maybe just keep it the way it is right now and add a task for migrating to PooledByteAllocator, so that we can benchmark it. I can take the benchmarking task if you want.
I _think_ this is ok - typically for netty applications, you want to avoid blocking the main event loop - but I guess in this case, we want to avoid the acceptor event loop blindly accepting connections when the worker group has to deal with a potentially blocked queue. I wonder if, given that the act of adding an item to a queue in logstash can block, whether the work group would be better in its own thread pool, but I think this should be ok in the short term
why is there a sound on sendString - it will be mostly user initiated. Am i missing something?
Does mLoginListener need a null check?
I think you are right, exception best fits this case :).
Please replace with a singleton
Same question. value is not annotated @Nullable
i am wondering what if we cast directly instead of the check because ( return (String)getProperty(RetentionConstants.INPUT_PROPERTY_KEY))if the type is not a string, i think we can find ourself with a non consistent data and this code will returns null and we have the setInput  which will do the insertion correctly
This won't generalize. I think you need a method to get a feature ID programmatically.
Another null test of the response. I won't mark any others I see below this point, but they should all be fixed.
As above, this should not be null. If it can be null, the Client.searchGenotypePhenotype method, or the server endpoint, are behaving in a manner unlike the other Client methods or server endpoints.
Don't need a line break here as well.
Can you extract this to a method? There is code duplication here.
Need to remove the casting for this too.
baseId +diagram
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
createPackage mapping should take the toolsection in parameters and create a ContainerCreationDescription tool.
this noopSubscription seems used in many places, create a single one and reuse?
Please null-check f
please null-check f
I am assuming nestedActivity is already defined elsewhere in the project
Is it really necessary to refactor this method that heavily? I personally find the old implementation to be much more readable. - What is the use of transformNoResponse? If someone wants to customize the behavior, they can simply override transform(). - Why have both "byResponseStatus" and "byResponseStatusFamily" methods? The family case is just a sub case of the status case.
should this be part of a different commit?
GitHubSCMNavigator. suggestion NamedArrayList.select(all, Messages.GitHubSCMNavigator_withinRepository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class),NamedArrayList.withAnnotation(Selection.class)),
Have you verified that order is preserved?
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
whole block indented one extra
The bytes array is only a buffer. For small files it is ok to use the size of the file itself as the buffer length, but it will never be greater than the max value of an integer (roughly 2GB, or 2^31-1), so why pass a long as a parameter on the signature of the method and then converting to its intValue? For files greater than 2Gb the size would indeed be a Long, but then you can't create a buffer of that size, since you will get an OutOfMemoryException. So why not use a sane default buffer? You could even use a mixture of both approaches, like checking if the file size is smaller than certain threshold, you can use the file size as the buffer size, otherwise use a default buffer size.
Please use a try-with-resources statement here instead of closing streams by yourself.
Its better to cleanup the Archived message on a server restart. Call deleteElapsedArchivedMessage() method if we find any archived message.
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Collapse the no-longer needed +.
The amount of duplicated logic we're amassing is concerning. This is going to be painful from a maintenance standpoint.
Not sure why we are passing connectionProcessor and connectionProcessor.getRetryOptions().getTryTimeout(). If the session manager has the connection processor, it should be able to get the retry options from it anyway. Also, it's weird to see retry options in connection processor.
The options don't seem to be propagated here.
A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge
Simpler: ArrayList<T> result = new ArrayList<>(collection);
You should be able to use the diamond operator here, i.e. new ArrayList<>()
There must be a more succinct way of doing this using streams.
I'd add an always-printed log message here too to make sure it's remembered.
This can be static.
Why do we have to check read scopes when we commit cursor ?
I also agree with Viktor regarding static imports, in most of cases they make code laconic. Also I think if every of us will just change what he doesn't like we will move into direction when we will just refactor each other's code without writing any new code. For now I'm more than fine if you don't use static imports in the code you create (until we have a coding guideline rule for that), but I don't really see the sense to removing static imports everywhere in existing code.
Strange that SubscriptionCursorWithoutToken has method withToken. Why not just create SubscriptionCursor hear?
Does this need to be a left join or would JOIN FETCH be sufficient? I don't think there would be an entry in this table if the association wasn't there.
add new DefaultShell(shelltitle) to make sure the required shell is opened
I think you might want "icsCode >= 1". ICS means "Inherited Certification Status" (i think?) and it is not a boolean but a count of the number of times something has been inherited... so it can be larger than 1.
> "org.hibernate.javax.persistence", "hibernate-jpa-2.1-api", "1.0.2.Final" Good candidates for constants
This pagination pattern is repeated in a few places. Consider the test output when the endpoint returns fewer results than expected. This will result in having us loop back around to the start and emitting confusing assertion failures. Perhaps accumulate all results into a set and perform a set difference at the end. Or else, assert that pageToken is non-null if there are still more expected reference sets.
removeAll
I'm not sure, but there might be a problem when destinationGroup == null if you try to check authz for VO/Group admin role. In such case you should probably check only VO manager role (on movingGroup).
Can you please convert this to throw specific exceptions instead of PerunException ? Thank you.
Use new lines.
You should check for entries: - exisiting in HEAD but missing in index (files where you already executed 'git rm' but have not comitted that) - symbolic links - submodules Even if we don't support all the bells and whistles of native git's ls-files we should not silently ignore links and submodules.
don't you want to add a/b?
why is it called 'symlinkA' . This test doesn't create symlinks. I took over this test into a bugfix commit which is now a predecessor of this change. There I changed this variable name to fileA
@Override
I wonder if this should be BatchReadTimer.... I know the Astyanax does Batch, but Datastax doesn't.. so...
what might throw and exception in this block?
double check that the group is still here
double check that the group is still here
double check that the group is still here
I'm assuming we can't use something from Joda because there are sometimes stupid dates? otherwise ISODateTimeFormat.basicDate() should work.
It would probably be better to use a date parser for this. That way we'd also find problems such as trying to parse the date February 30th.
SimpleDateFormat might help make this a lot simpler. <LINK_0>
Any better naming?
Not a huge deal but delimeter is spelled delimiter.
Missing blanks around "=".
did you want to remove this throws IOException as well?
Please avoir multiple statements per line, we are not writing JavaScript ;)
Perhaps useful to not do anything if leaseId is null ? Alternatively, the method can return a boolean indicating a successful operation or not. If you think it is appropriate for your usage, update it.
I think we should not be hardcoding the type here again, and instead use IndexableClaimedTask.TYPE or similar
Consider checking if ePerson is a repository admin. If so, return true immediately.
Why is this not based on context.getCurrentUser()?
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Not sure whether we should transparently fall back? I think using this interpolator should be an active choice, especially since it does not even handle all default constraints out of the box.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Sync on the _instanceMonitorMap while you are reading the map.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
You should use ThreadContext.putAll() here.
"error".equalsIgnoreCase(...)
constant on left side
Use getLineNumber which already has exception handling.
@prateekm and I were chatting, proposed that having a different grouper - AllSspToAllTaskGrouper would be cleaner for this scenario. That way, we don't muddle the existing Grouper implementation.
RuntimeIOException maybe?
Thanks for the cleanup.
Args need to be included in operation.
Important information for admins.
Add final keyword.
Here it is going to depend on the resilience strategy ... so hard to say. I would drop the operation result assertion though.
As with others, I would not assert on the return value of the operation
As with others, I would not assert on the result of the operation, only on the resilience strategy being invoked.
Removing test because you can not fix it is usually bad idea
I think in these cases, assertTrue() and assertFalse() would work better. It's quite a long read now :) Please consider.
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
We should implement filterOnlyAllowedAttributes() method to perform authorization check on list of RichUserExtSource as we have for groups and members. It will be part of Bl layers and called from here. Also, I don't know if we have authorization check on ues attributes. I believe, that right now they are accessible only to perun admin, and will need to configure it on each instance on deployment.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
getSourceVmFromDb can return null..
well it's not a must but i think the above line better be in the ctor
The above two checks can be moved to a common parent class, as the same is repeated in GlusterHookStatusChangeCommand as well.
can you add some docs around this method.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
This list needs to include soul lantern.
Can we name this something other than it? Even i would be better to me than it.
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
How does it sound: _Response for the key may have arrived earlier from another server_?
How does it sound: _Response for the key may have arrived earlier from another server_?
Should it be KeyStoreWrapper.getInstance().getRSAPublicKey
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
We were going to avoid signatures like IgniteFunction<Stream<UpstreamEntry<K, V>>, Stream<UpstreamEntry<K, V>>>, right?
Use .setBoolean() method.
assertThat(info.files).hasSize(2);
isTrue()
Unfortunately, this cast doesn't work. Even if it did, not all the returned columns are longs (the AVG ends up as a double). From my fairly rudimentary knowledge of JPA, mapping the results of a query to a POJO without involving an entity or a bunch of XML is a bit of a pain. Using a native query makes it more so. However, your query is not actually beyond the capabilities of JPQL, so we can use plain createQuery. Something like this should allow us to get a PerformanceReportEntity object out:  SELECT NEW uk.gov.pay.connector.model.domain.report.PerformanceReportEntity(COUNT(c.amount), SUM(c.amount), AVG(c.amount)) FROM ChargeEntity c WHERE c.status = :status  But perhaps someone with a better grasp of JPA than me may be able to offer a better suggestion.
what does this branch mean exactly, seems weird for me :/ Shouldn't we throw an exception instead?
Arrays.copyOfRange(tmpIdArr, 0, count) instead?
It's not necessarily a build script - only if the resource is a file.
e.getMessage()
You have to remove marker from clustermanager and add it again, as there is no way to update cluster
@mykelalvis please, rename to server. s is meaningless :)
please add curly braces
Can we make toString a little smarter and print out what's appropriate for weather or camera?
please format query
why filter is applied only to plot names, but not to summary? we are going to show monitoring params in summary when decision maker will be ready
Somewhat counterintuitively, I don't think this specific call actually should be app restricted. If the case model changes, it should invalidate caches around that case model regardless of which app produced them.
Unsigned types are not used in the current implementation. So, you can omit them.
This should be a slightly more user friendly message like User account conflict
For consistency, I think this should be "properties" plural to match the class name.
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
can you add metrics to this?
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
Can you report a span and verify that both senders and reporters were actually called?
When connect is called we should update the connectState to ConnectState.CONNECTING
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
I'd extract this into a method isUnset(Diff) as well. Don't we have util methods for determining whether it is an unset? They seem to be very generic and maybe should go there, if we haven't them yet.
I think it would be good to avoid multiple returns by either enclosing it within the negated if or, which might be even easier to read, extract a boolean variable: final boolean hasOpposite = diff.getReference().getEOpposite() != null; final boolean isOneToMany = hasOpposite && diff.getReference().isMany ...; final boolean isManyToOne = hasOpposite && diff.getReference().isMany ...; return (isOneToMany || isManyToOne) && ...; Also I think the convention in EMF Compare is to try to enforce final wherever possible.
Same as above (avoiding multiple returns).
Which are the callers of this method? Are there any side-effects if an empty array is returned at this place?
Nit: children is final, so children.length will not change and we don't need to calculate this every single time.
Stray .build()
example (with an a)
in the union types, is the NULL type guaranteed to appear before the actual type?
'map' name may be problematic. e.g. following line results in an error : a = load 'a.txt' as (map : [chararray]);
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
I think it would be useful to add some extra log lines, as there are a several if and it would help us investigate later
Can you please add a few log lines here?
What is the purpose of this logic? From the xml file I can tell that the 0210 thing has this channel, so why do you have this check and addition logic here?
locks should generally be guarded by try {} finally {}-blocks - especially when some (foreign) non-trivial code is called while the lock is in place.
remove this "if", only keep the "else" - you must not set yourself HANDLER_MISSING_ERRORs, this is done by the framework.
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
It might be good to still show the IOException handling at the end to demonstrate the difference between FailedRequestException and IOExcepton. Though probably not explicitly required.
Direct mutation of input Map: danger, danger will robinson! Please create copy if you're going to mutate something (just in case something else is done with the args) -- don't remember off the top of my head but there's a real risk this might break something like ArgumentsActionImpl.
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
Why do we need to check again?
Trying to follow this. The check above has failed, so this is handling the transactional case, which means we should be in the abortable or fatal error states. If we are aborting and we can bump the epoch, then sequence numbers will be reset after receiving the InitProducerId response. If we cannot bump the epoch, does it make sense to reset sequence numbers here? It should be for the partition that raised the UNKNOWN_PRODUCER_ID error, but how about the rest?
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
style nit: no braces around single line blocks
No braces
Again, needs a more descriptive error message please. In this instance we likely need to log something like "Could not create Item in Collection with UUID=[uuid]"
:ant: not a good test style, since this will make no sense after the bug is fixed, and will not catch unrelated problems. Better to set check to false initially, then set it to true after calling getSCMSources (with no catch block).
that's not the best reason i've ever heard...
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
I'd add an always-printed log message here too to make sure it's remembered.
This could be null, we should probably handle this if the JIRA api changes again
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
Align logic and method order with double and float.
Please align the logic with double. And if there is just one method, it checks anyway and returns an optimized impl.
Use TreeMap to keep the order.
This method should get the expected size of each lun, since vdsm reported it in getDeviceList (path capacity). So this should call each host, and report the hosts that do not see the expected size. We don't nee to create map of sizes, but create map of luns to failed hosts.
@aertoria Can you change all the variable names in test method to not have _1
nit: you could skip this announcement if details.location was already same as location.
BaseAsyncTask::RemoveTaskFromDB: can be removed
this log line is swallowing the exception. Makes it very difficult to debug :).
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
If you set wasExternal here then remove it from processFromExternalLaunch
You also need to update the text of the menu button here.
You can remove the surrounding brackets.
This fits 404 better.
Probably we can be consistent with the use of this. here?
This should be using parameter.requiresCast() which is the logic the original method uses.
Use a for each loop for (Entry<ChunkPos, List<TileEntity>> entry : list.entrySet()) and the left braces!
remove instead?
This won't do anything since metacard is a mock.
can we use the constant for "query"?
Was the original intent of this plugin to make it impossible for someone to create a metacard with a point of contact other than the subject that was creating it? I think you should be able to do this but wonder if we are breaking some assumption/requirement somewhere.
Why are you suppressing exception here? Let the runtime exception bubble up. This is changing the behavior of the wrapped processor.
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Instead of adding all of the parenthesis here, we could just change the return statement to: java return "(" + selection + ")";
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
local variable e is never used.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Same thing, using this method here may cause the getLinePixel method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
Throws AIOOB exception when called with index = line count.
Why are you keeping the len here? It becomes unsynchronized when you do the .trim() later on, but I think you don't need to keep this variable at all (just use line.length() when you need it).
Move this to after ePackage.getNsUri() check?
Replace Logger with LogManager
Can we log a warning in the else case?
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
* Why is super.reinitialize() not public? * If you want super.reinitialize() protected, this class could "open it up" instead of defining a new method: @Override public void reinitialize() { super.reinitialize(); }
java this.onPostServerTick(this.getMinecraftServerInstance());
getBigtableWriteThrottleMs() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableWriteThrottleMs() ValueProvider into a "true" or "false" for the google.bigtable.buffered.mutator.throttling.enable value
Please construct it, passing in the file?
add multiple entry points, make them look like closure namespaced symbols 'ns.entryPoint1', etc.
RuntimeException will be sufficient
same as others: log should have Exception as arg
final ![200x200](<LINK_0>
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
Add @Override
Wouldn't the below code be more readable and correct? public static boolean isStatusOk(Map<String, Object> response) { String error = (String) response.get("error"); if (error != null) { String errorCode = response.get("error_code"); String errorDescription = response.get("error_description"); StringBuilder sb = new StringBuilder(); sb.append(error); if (errorCode != null) { sb.append(", Code: "); sb.append(errorCode); } if (errorDescription != null) { sb.append(", Derscription: "); sb.append(errorDescription); } throw new RuntimeException(sb.toString()); } return true; }
The context type is a 'type', not a 'mode'
throw e will never be executed.
I'm not entirely sure about this refactor. I'm good with always take the first argument as the command, and always print the outputs with the prefix, because these are IMO common contract for all the BashJavaUtils commands. However, the assumption that the remaining arguments are used and only used for generating Configuration may not always be true. It is only true based on the current state with the GET_JM/TM_RESOURCE_PARAMS commands. This does not cause any problem ATM, but I think it might be better to pass in the commandArgs and generate Configuration inside getJm/TmResourceParams.
you should also do withRepresentationProperty(DS_ID)
Is it safe to do this here? It has some smell to me... Note that this is an expensive, potentially long-running and blocking call.
Question: Is it OK/Better to not send this key at all if there are no unsupported block VS sending an empty array?
I think in this case we want to revoke (not lose) the partitions no longer in subscription?
Bad double checked locking idiom. ThemeInfo theme = this.theme; if (theme == null) { synchronized (this) { theme = this.theme; // this is what you missed if (theme == null) { theme = loadTheme(); this.theme = theme; } } }
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
You're better off pokemon-catching these.
Log for these also
printStackTrace directs output to the console and should be replaced with logger debugging
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I would prefer usage of docker exec instead of DockerProcess. In that case it won't be presented in list of processes, and you won't need workaround in 100-102 lines of DockerProcess.
I would prefer a static constant field for string values like this... both when it is defined, like this statement, and when it is checked (if ever)
Use Sytem.getProperty("file.separator") instead of "/"
nit : It seems only the anonymousResult needs to be a field in the class, rest can be removed ? In case you meant this class to be used in JSON serde, please add @JsonProperty annotations to the fields and create their getter methods.
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
This null check should only be applied to the loadProfileImage() call. The profileImage variable should be assigned regardless, as the whole point of it is to store the image for when the view is initialized.
is to possible to catch some Exception sub-type? I mean some ParserException..
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
suggestion Pattern argPattern = Pattern.compile("^\\$(?:\\{(.*)\\}|(.*))$");  Align with start and end of the string. Otherwise you would also match bla$ad or ${foo}bar
"due to".
It's better to use "Preconditions.checkArgument" here. And it's missing a period "." before "Transaction".
use %s
context.getEntityType().equals(EntityType.FEED.name()) should do.
just use context as synch obj
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
We are aborting refresh by breaking out of the loop and basically, we are done refreshing master stubs. Better to log this at ERROR?
some exceptions will invisible to users? it will be not easy to get root cause if meet some exceptions but the core exception is not at head.
This should be error
There's a typo here, it should be no authenticator jar files.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
WRT to the changed logging, shouldn't this method return a success indication (boolean), so the caller could at least log one error message that the server is not running / listen?
What kind of exceptions are we expecting here? Shouldn't the queue be forcibly cleared if drain throws an exception so that later invariants (isEmpty) are still true?
Good info level, I think
Do we need two debug logs here?
Integer.SIZE here as well
unnecessary semicolons here and in some other try blocks for page cursor creation
pageId + 1 should really be 0, right?
suggestion Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
constants or directly as default properties ?
just remove the fileSize from here... and that's the only change you will need.
change variable to something more meaningful
Bad variable name! Variable names should be clear enough. Rename it.
remove printlns before this is merged
I don't think it's necessary to create a set here since it accepts collections and then tries to figure out the fastest way to check them.
Suggest using a constant for -1 and put it into somewhere like TestUtil that can be shared by all tests.
calcFilterAndProjects  -> calcProjectsAndFilter ? Because projects are the key part.
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Why not String.format("(&(mime-type=%s)(id=%s))", mimeType, id);?
Can we make toString a little smarter and print out what's appropriate for weather or camera?
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
Why do we need to .class.getName() here? It will just take up more time when the provider is loading.
this is counter-intuitive. You expect getPKStrings to get you PK strings only, but sure.
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
Is order important here? Should the 2 collections correlate each to another?
new HashSet<> is not needed; oldAssignmentNames is only used for exclusion from a set, let alone the returned assignments are always unique anyways (read straight from ZooKeeper). oldAssignmentNames  can be a List<String or even Collection<String>.
format as final String[] array. Rename to errorMessage if possible
calcFilterAndProjects  -> calcProjectsAndFilter ? Because projects are the key part.
remove line
add a message containing both values, in case it ever fails
Consider using the same code as com.facebook.presto.spi.block.MapBlockBuilder#computePosition
Maybe use an RLE block
why is it adding null?
It looks very much like those validation methods should throw an exception wrapping the list of invalid objects and not return anything. This would make it more obvious that we are in an error scenario and simplify the UploadServlet.
new ArrayList<>(causes);
mark this method private as this is only used in this class.
is getServerKey() invoked for every request? Is it possible to pre-compute the value and cache the URI? I think new URI uses toString and string parsing underneath which is CPU intensive.
I think match() result could be passed in, it's enough to parse the Uri once.
I am wondering should we use a ConcurrentLinkedQueue here instead? It is a collection that provides duplicates but in a non blocking fashion.
@wburns I don't think we handle correctly the scenario in which passivation is disabled. In this case the entries in memory are a subset of the entries on the disk, so I think we should rather use the store instead of the memory for these operations.
Can't you call valueList.addAll(set) ?
nit: instead of the boolean here, would be better to use an enum (would make the test clearer) or two methods runSslConnectionTestWithoutClientAuth, etc.
would love to also see this test against a dropwizard/feign stack (since that is really the default use-case for this library). have a look at the other sub-projects for a simple test setup.
This requires all substrings to be present, we want containsAny
I would be more defensive here. I would check if the num of containers returned by getContainers() is > 0 and if the value returned by getImage() is nullOrEmpty
Would it be better to add a separate service method for sending a no-files-processed email, so that you don't need to rely on null values and null-checks to do so?
PARAM_DATA is used to retrieve the data, but PARAM_SELECTORS is used in the error message.
The same here than for PreviewImageFragment.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
rename to childItem
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Why have you updated this test instead of writing new one?
One more times(1).
Three more times(1).
If we're changing asserts, let's make them AssertJ - in this case, Assertions.assertThat(presenter.getClasses()).hasSize(1). This reads much better, the error message will be nicer, and it will allow you to get rid of the nullity assert immediately before this one.
Could throw IllegalArgumentException instead.
How does this work when an item is evicted from the underlying cache, but is still in locker?
this.redisTemplate
Can we perform an early return here if mUseTimer is false?
"_helixManager != null ? _helixManager.getClusterName() : null" --> "clusterName" ?
Log as _error_ or _warn_?
We need to enforce TCP connect timeout and read timeout, apply reasonable defaults, and make the timeouts configurable.
Please use either parameterized logging, or the method signature that takes a Throwable as second argument.
Is it necessary to make the port file name configurable?
Can you use a more relevant variable name?
There's no need for this.
What is the use of this second list String[] items?
I feel like we should preserve the current behavior, and the verbatim behavior should be turned on manually with some option.
If component is null, this will have NPE'd by this point if typeMapping does not happen to be a type that allows null keys (most don't)
Use ImmutableList.copyOf when lists are not null.
Why do you need to add dates to the list? Why do not to use reminders list size? Does Realm have count function?
This is inherently dangerous. sharedList is a CopyOnWriteArrayList which is _safe for iteration_ even while it is modified. However, once you abandon the iterator, it is possible for the sharedList size to decrease while you are in the loop, and sharedList.get(i) will generate an ArrayIndexOutOfBounds exception.
i -> expectedColumnIndex
Cosmetic: Braces on a new line, please. :)
"Initial connection"?
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
Also mention that they will be ignored
Is this call necessary? It is called on line 109.
wrong message
Typically we use Map on the left hand side rather than HashMap
let's use LinkedHashMap
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
I think isEmpty() is more preferable to this construct.
What do you think about adding logging for !doCache and level==0? That way wrong usage of the API wouldn't go unnoticed.
Close FileWriter?
i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended
@essobedo field type can be relaxed to simple Map as we don't use ConcurrentMap specific operations
Use getLineNumber which already has exception handling.
1. Change Exception to exact exception you get 2. throw the exception after log or don't catch it here
We should call sweepOutcomeMetrics .registerOccurrenceOf(SHUTDOWN);
This doesn't look like it does what a stopGracefully should do. Maybe we should rename that method to something like suspend (not in this PR though). But, what it's supposed to do is suspend a task quickly so the jvm can be shut down and then restarted. Specifically it shouldn't be trying to publish or anything like that - just persist to disk and then stop.
assertEquals(org.apache.log4j.Level.ERROR, event.getLevel());
Use logger
If we have optimized cardinality(filter(array_agg(orderkey), x -> x < 3)), would optimizing cardinality(filter(array_agg(orderkey), x -> x < 3)) = 2 be an overkill? =2 seems to be very low cost operations. Also, it might make sense to add some benchmark similar to BenchmarkArrayFilter, or even do a comparison run from Tpch query runner and add the result as part of commit message.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
no need for the additional check if propertyParts.length is ok?
Both lines dealing with the provider should be moved together, following the usual pattern: if (x != null) { x.dispose(); } x = null;
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
Same as beforeApprove(), but now with User object. It might not be present, if module is used on VO. There is always a way to wrap all implementation and catch any exception and translate it to generic CantBeSubmittedException so user will see nicer message and not report error box.
let's call it updateCodeMinings() instead.
StringUtils.isBlank(nodeId)
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
Can this be private, or is there another use case for default attribute outside the builder's call?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
add this selector to UI mapping at the beginning
I mean that setBytes(1, null, 0, 1), setBytes(1, null, 1, 0), etc. should throw some exception (NPE or other) instead of returning 0 to indicate a problem.
Let's keep things tighter here. Extra blank line
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
Could you correct the error message while we're changing stuff around here.
What happens here when mergeOldAndNewHistory() returns null. Looks like it will fail in writeHistoryToFile() later.
can you assert something more - contanins some string, minimal length? it relies on the serialization and when it's broken you wouldn't catch it.
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
Please define s1 as final, it causes build failure!
As far as I understand, we can get rid of explicit type parameters is such calls
Can we move this above cGroupsCpuResourceHandler.prestart()?
Its probably not worth mocking objects like beans - as they really don't have any behavior - they are just POJOs. The tests will be less brittle if you initialize a query object for each test.
execution type is repeated. Also, do we need to add a when for all these?
"Entity" + id
let's remove this
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
I would have this test within the flow from yield method in fact, so the algorithm is pretty straightforward and the method to compute flow from yield will only do so if required... (and return an emtpy list otherwise). (In fact if I'm correct you actually don't need that test at all...)
I am not really sure this is the place where we actually want to check this and I don't really see what's the risk you address with this invariant.
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
Is this still needed if the value gets overwritten in the next line?
In other places in the code we check if the client is null first, so that we don't do any unneeded computation if the client is null.
What are these annotations ?
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
Please avoid code style changes like this to existing code.
perhaps worth to check if the map isn't null ?
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
There is a simpler this.getEffects().setTargetPointer() method for this.
BoostSourceEffect has to be removed.
Add another OS to the set, just to verify that only the right ones are ignored.
Personal preference... use of Collections.emptyList()
If you change the indention, move the first new KeyValue(1, 1) to it's own line.
Like above, using the absolute path should accomplish this properly
/denied also works instead of working with relative paths
Shouldn't this already be set?
This could still be helpful right? Or maybe the reverse logic. Maybe left should be the shorter one?
A method similar to this but with first parameter Connection<T> would be more convenient for use in CPPSemantics. Such method could be moved to /org.eclipse.cdt.core/parser/org/eclipse/cdt/core/parser/util/CollectionUtils.java
But the function actually finds element's index, not the element itself. The more appropriate name can be indexOfElement
I can see why this is necessary, with the change a few lines above from 'indexOf(".")' to 'lastIndexOf(".")'. However, there are two things I don't like about it: * what about, say, "model.profile.profile.di" ? (granted, unlikely, but handled by the previous version of this code) * more seriously, this hard-codes an extension that is defined in a <diagramCategory> contributed by some plug-in on the org.eclipse.papyrus.infra.core.papyrusDiagram extension point. Other plug-ins can define additional extensions that aren't enumerated, here. Rather than hard-coding this, we should look up the extensions that need to be trimmed off in the DiagramCategoryRegistry
A List<String> would probably be simpler to use as return value
Added code to print an error message and exit.
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
This exposes the unicode workaround to the public.
new ArrayList<>(causes);
maybe name this, offset-before-start.zst?
Maybe just throw unsupported since this isn't used.
The intervals can be stored as start/end millis pairs, which should simplify the cache key generation.
Would it be too nitpicky to question why there is an intermediate rolls variable? dice.getRolls() is just as descriptive and it's only used a couple times below. Removing intermediate variables is often a good thing, one less thing for a maintainer to keep on their mental stack when reading code. At this point when reading the method, there are 3 variables in scope, soon to be a 4th one, leaves little room for much else!
why protected ? please make it private.
if performance is really that critical here, I would pull the call to size into the initializer so it isn't repeated.
@tsurdilo take a look at org.jbpm.kie.services.impl.CommonUtils.getAuthenticatedUserRoles(IdentityProvider) that does some additional logic in case roles are empty list. There is an issue with some dbs handling empty list as part of in clause
> public abstract class ExecutionStrategy { this super(); call doesn't need to be here
setupCreateMandate
space before {
Translate this RuntimeException message in English please
should the message include "command _with options_:" + this.options ?
It would be nice to create constants for these props in AccumuloProps class.
parameters.putIfAbsent(parameterKey, new ArrayList<>()); List<String> cheServiceParameters = parameters.get(parameterKey);  May be rewritten in Java 8 style  List<String> cheServiceParameters = parameters.computeIfAbsent(parameterKey, (key) -> new ArrayList<>());
This synchronize block is for protecting interpreterBindings, and i think we still need for synchronize block for interpreterBindings. However, this.removeInterpreterForNote() doesn't have to be protected by synchronize block. So i think code can be look like  List<String> settingIds; synchronize (interpreterSettings) { settingIds = interpreterBindings.containsKey(...) ? interpreterBindings.remove(...) : ... } for (String settingId : settingIds) { ... this.removeInterpreterForNote(...); ... }
Logging.
This means that if there is an error in converting the JSON for example this would return a null and lead to null pointer exceptions. Better to return an empty list.
Do we want to support all the arguments the QueryResponseTransformer supports? ![image](<LINK_0>
Try to truncate some of these constructors. Add a \n to break up the parameters.
Coding best practices: Interface i = new Implementation();
IntelliJ IDEA tolds me to remove this unnecessary boxing.
change this to node.isPartial()
if ! isDeleteQuery, the optimizer should not change anything; here it empties distribution type
in theory this should be newTableHandle.getLayout . But if we decided to squash these commits it might not matter..
@maria-farooq we should provide a description to the log message
@maria-farooq we should provide a description to the log message
do we need to check if targetAccount is null, or can we assume this will alwasy be non Null?
Single pass is needed here.
I would wrap these like you did above to avoid excessive line length.
I think acceptableHostsList will never be null.
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
missing space after if
I would keep this where it was previously, since the super will validate based on the in-memory store, and if it's not in-memory, only then do we want to validate the alias.
I would prefer the format to use id next to the entity type, like  log.info("{} removed attribute {} from member {} in group {}",...
Any reason to log facility.getName() ? Since you then mostly use otherEntity.getId().
PerunClient is valid only for OAUTH2 clients. Otherwise its half empty object, especially client ID is not present. I would prefer logging whole PerunSession, but I understand, that this message should be rather short. But neither PerunSession or PerunPrincipal within it have a short toString(). Please add method in PerunSession like: getLogId() which will return value of actor property, so we will see user identity. If it won't be sufficient in a future, we can safely change such method to return also extSourceName or other properties. Thank you.
why?
this is a bit hard to understand, I would introduce a variable isntea of directly using the resolve
I would add this directly as a constructor, or if you want to have a more descriptive name as a static ComplexSearchQuery fromTerms(Collection<Term> terms) method in ComplexSearchQuery. The builder pattern is only useful if you have a lot of possible constructor arguments, and want to create a nice interface for it. I actually think the builder interface is mostly outdated since IDEs are now intelligent enough to show named constructor arguments, e.g ![image](<LINK_0>
If you ever make this public this _ will break the JavaBeans specification.
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.joining(",")); ?
Isn't it a bit hardcore for a mere selection of a random host for the pool just because we don't care which host it will be? I'm all in favor of removing RandonUtils though
This is ugly, see my notes in the token code.
Could you please catch more specific exceptions here? It's either KeystoneServerException or KeystoneConnectionException. In particular if it's KeystoneConnectionException, it doesn't seem correct to re-throw InvalidCredentialsException.
my understanding of the initial interface was that this method was for returning the token-stored-on-disk, if any but in general, I don't think you need locking here.
f.isFile() is better since it checks if .project isn't a directory accidentally.
unrelated change
This exception will be written in the logs and in the console output. It would be nice to add some valuable information : the location of the file and some tips, for instance. "Check the content and permissions of "+currentWK+"."
sb.length() > 1, please
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
Using stringbuilder and then a + op is pretentious ;)
you can move the declaration to the initialization.
you fetch vdsDao.getAllForCluster(getClusterId()) and then fetch it again in runAnsibleReconfigureGluster() (line 304) you can save it to a local variable and save the second call. Also, it seems that you rely on host 1 and host 2, therefore you can just pass them to the method runAnsibleReconfigureGluster(firstGlusterClusterNode, secondGlusterClusterNode)
instead of calling here to a function that only set the status to connecting (without any callback meanings), just getVds().setStatus(connecting..) does the same thing. otherwise change the name of it, because it's not act as callback function does.
Not really.
please keep the buildVmNumaProperties a void method and access the vdsId fron inside
Did you intend on nesting the code block in a paragraph block? If so the method name should be changed to indicate what this test is about.
this will go to the char after '[', is that OK?
suggestion }
use createTempFile
Since Rx is optional, would be great if you add a check, I've added this in Hawk.java but that can be moved to utils and used here as well.  java private static void checkRx() { if (!Utils.hasRxJavaOnClasspath()) { throw new NoClassDefFoundError("RxJava is not on classpath, " + "make sure that you have it in your dependencies"); } }
Doesn't need fully qualified
Is this wrapping necessary? Why not just pass out sub through the result?
Yes this makes things less racy. Why not use a CAS loop here to make even less racy (especially as we have a volatile field updater available)? Might be overkill I grant.
what if task.getTemplates() == null ? Also you can java8  java if(task.getTemplates()!=null){ dto.setTemplates(task.getTemplates().stream().map(TemplateShowDto::new).collect(Collectors.toList())); }
All actions from
should be named resource
should be called resource
move this to where signature is declared, since it never changes?
Including ip.toString() in the log message does not make sense here - it's a DynamicLookupInjectionPoint instance with no meaningful info.
Can we keep that original unit test as well?
ip variable is extracted here just for enabling the next line check. Once you make it !isSetIp, it'd be redundant and could be inlined.
Sorry, but I don't think this is right: IMO the new eventually calls should be exactly where the sleepThread calls were
Should we have a version of createStubSecureCredentialsStore that takes a String argument and use it in the rest of the tests?
I don't like having to use eventually* for both, it feels like we don't really know what the code that we're testing does. Since the listeners are always invoked after the availability status changes, I suggest using a regular assertTrue(pm.isAvailable()) after checking the listener.
Import this.
Space after cast? Also, should we log a warning in an else clause here?
should really be stored as a long in UTC, or at least ISO 8601.
You can do this a lot cleaner with .post(Entity.entity(mandateConnectorRequest, MediaType.APPLICATION_JSONTYPE);
I wouldn't use this error, this will return a message like "wrong field: agreement_id", but all we are doing is checking that the gateway account is not direct debit. So if somebody searches for anything with a dd account, we would be complaining about agreement id, which is not really intuitive. I would create and return a new error that says something like "Refunds are not supported for direct debit"
Don't need an explicit else clause here: java if (response.getStatus() == HttpStatus.SC_OK) { return response.readEntity(SearchMandateConnectorResponse.class); } throw new SearchMandatesException(response);
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
why did we remove the optimization here?
rename to child
It's written nowhere, but I'd prefer to have curly brackets even for single line.
ExtensionNamespaces.LBAAS to be consistent with the alias name.
If you found a better variable name as aFiles (previous aDateien was even not better) then rename this variable.
and we don't want to rely on the URIConverter's "exists" test. The given URI might not exist locally, but it might exist on the remote side.
final is unnecessary here
This can be null. E.g. if a mail address was matched but the account was not added to the result because the account is not visible to the calling user. Due to this SuggestReviewersIT.suggestReviewersSameGroupVisibility and SuggestReviewersIt.suggestReviewersViewAllAccounts are failing.
if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) { fullNameMatches.add(a); }else if(a.getPreferredEmail() != null && emailMatches.size() < MAX_MATCHES && a.getPreferredEmail().toLowerCase().contains(str)) { emailMatches.add(a); }
Could you please add clear message for case when assert failed?
Could you please add clear message for case when assert failed?
Could you please add clear message for case when assert failed?
Use unadj.stream() ...
Can simplify with Optional.ofNullable
If this is only for testing, use stream api
this should be a while loop. while(it.hasNext()). Common variable name for iterator is iter or even itr.
Why is hard to read generic coding used here?
if (! finalize) Check if first future is done. If yes then process it and break. If not, then break. if (finalize) Then process everything irrespective of future is done or not. In this case this is breaking out of the loop without doing anything...
use Arrays.fill instead for loops
unnestChannelInputBlock -> newInputBlock
Same here, stage-->i is pointless.
You need to also store the lastStartTime: long lastStartTime = prevFullState == null ? -1 : prevFullState.get(statusQuark).getStartTime(); Also, lastEndTime can change for the same attribute while it's being build and below...
I think you should wrap the whole for-loop in applyResults().
Yes! Drive by fix!
Let's be more explicit, to clarify that that noDictionary is being overwritten by aggregateMetrics for the column.
functionEvaluator should not be null
I could definitely see value in including NULL columns; we should special case that (if the user passes in C=null, it matches both NULL and "null". Obviously kinda odd and non-ideal but hey it's ok for government work)
Use " List<String>" instead of ArrayList<String> in declaration.
any reason we can't use an empty list for the sentinel?
You should use ThreadContext.putAll() here.
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
We should think about a way for this to be async on a thread pool or something. Or maybe this and ensureChangeLoaded() above aren't very relevant anymore with much of the search result data stored already in the secondary index?
May be worth providing the expected and actual values of the transaction cursor to help with debugging from the logs?
Could this be  return reportingCurrency.getCurrency().flatMap(function.naturalCurrency(target));
keep all params for format in the same line or one param each line.
You can replace the for loop here with values.forEach(result::add);.
I think fallback should be project.getDisplayName().
Is there a reason for this toBuilder().build()? The following compiles fine:  final Component component = TextComponent.empty(); TextComponent.builder().style(component.style()).build();  I haven't run it though - if there is a problem that you've worked around, we need to report it to Adventure.
This is strange that this method throws SizeTooLargeException and not the new one. Are you sure that this exception is always necessary?
just use context as sync obj.
just use context as synch obj
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
Would it be appropriate to add some logger.warn() statements to these two IFs, to make more explicit what's happening, both here in the code and at runtime?
style: unnecessary blank line
nit: Use Guava's Strings.isNullOrEmpty
Please mind if I ask, but what would happen if the request reaches this line?
Multiple method(*) methods
I don't think this is reachable
FIXME: Don't cast getActivity(), use an interface.
Do you need to initialize both layout managers even though you are only going to use one? See below.
I'm floundering on where toolbar code should live but it seems if it's going to access the Activity and has no dependencies on the Fragment, perhaps it should live in the Activity?
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Or maybe:  for(String s : mc) { managedCache.add(getNewMBeanProxy(mbsc.getSecond(), MANAGED_CACHE + s, ManagedCacheMBean.class)); }
I'd use getPathAsString instead of getName to provide unambiguous info.
Sadly checkstyle isn't as strict as I would like. We could probably do a custom regex for it.
that's too long I think. Travis will terminate the build run if there is no output in 30 minutes IARC.
maybe it should set the true/false property value randomly - in case someone implements smarter property setting (that would become no-op if the value is already set)
return (this.sslContextDependency != null) ? this.sslContextDependency.register(builder) : builder; :)
Rename to "dependency"
You can remove this lambda by having RemoteCacheContainerBuilder implement Function<RemoteCacheManager, RemoteCacheContainer>
This is very odd; not the sort of thing you should catch. Can this be prevented?
task.get() will throw a NoSuchElementException if the task doesn't exist. is that what you want? wouldn't it be better to return an empty string?
I'd add an always-printed log message here too to make sure it's remembered.
The existing return output.repeat(2, (long) getN()); should be replaced by:  try(MemoryWorkspace ws = workspaceMgr.notifyScopeBorrowed(ArrayType.ACTIVATIONS)) { return output.repeat(2, (long) getN()); }  We don't want this to be detached instead.
We should probably store the Pattern.compile() result somewhere, for instance in the constructor, instead of recompiling it every time since it's a constant (final at least) Otherwise LGTM!
Seems kinda silly but I recommend checking the inputs for null just in case something happens to the request.
Remove this line too because the variable "configuration" will become useless.
The advice applies here as well on account of the fact that you've already proven the method exists. It must be invokable else something very unusual has occurred that we want to know about.
seems like a good candidate to be extracted to a method and reused
markDuplicatesWithRemovingDuplicatesIntegrationTest and secondarySupplementaryUnmappedWithRemovingDuplicatesIntegrationTest are exactly the same. The contents of the test should be pulled out into its own test and the two separate data providers should be one line methods that call the abstracted test.
If this logic is need, please find a way to reduce the code duplication. see azkaban.test.Utils#initServiceProvider
If you use props.getString on line 347 then I don't think you need this if statement because if Constants.ConfigurationKeys.CUSTOM_CREDENTIAL_NAME isn't defined then an UndefinedPropertyException would be thrown.
When assumption fails it emits an exception that is ignored by the runner (effectively, later part of this test method is not executed)?
I already made several fixes to the unit tests cases and XBeeDevice class that are already committed in master. We will sweat blood to make the merge...
The intent of the test would probably be clearer here if you just used fail() with the same message
in all these OseeArgumentException constructors, you don't need to use String.format, it does that for you.
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
I have seen cases where a Throwable will return this for getCause() which can cause infinite loops in code like this. I think you want:  java while (true) { Throwable cause = root.getCause(); if (cause == null || cause == root) { return root; } root = cause; }  as a result instead.
Logging statements can happen outside of the lock.
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
again about redundant things - else block here and above is not needed,
parameters.putIfAbsent(parameterKey, new ArrayList<>()); List<String> cheServiceParameters = parameters.get(parameterKey);  May be rewritten in Java 8 style  List<String> cheServiceParameters = parameters.computeIfAbsent(parameterKey, (key) -> new ArrayList<>());
Need to exit the function here if the table was null.
May be convert to lowecase first? in case the same email appears in different cases.
camelCase
May use CPU excessively if pollTimeout is small
Why not using StringUtils::defaultString?
uuuf... each of the Class instance is probably serialized to a FQCN-long representation, that's easily 50 bytes. With 2 classes and 2 wrappers, this is 200 bytes per command. Isn't there a better way?
marshallCollection handles null
I think it is better letting this method throw the exception.
please extract as constant
this.global = global;
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
it seems to be there are spaces missing, shouldn't it be ...retire " + retirees + "
Why do we print a secret systemUserPassword here?
I think you might want "icsCode >= 1". ICS means "Inherited Certification Status" (i think?) and it is not a boolean but a count of the number of times something has been inherited... so it can be larger than 1.
Does HQL have an "EXISTS"? If so, using EXISTS rather than IN may produce a faster query, and you will not need the DISTINCT fi.ingestion.
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
The 'when' can be dropped from the log statement.
Even if it wasn't in this commti I think e should be consistent regarding the logging.
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
Can be replaced with method reference.
I wonder if that would better to rename to fromSupplier(). And yeah... remove that from(Supplier) altogether. Breaking change, agreed, but no choice. I will find this explicit casting style more annoying than removed method. WDYT?
need to pass Locale.ENGLISH here don't you?
Shouldn't it be MAX_BROWSER_NAME_LENGHT - 3? Or, if you want to save 2 chars, try using an ellipsis:   (\u2026)
seems like a good candidate to be extracted to a method and reused
Sneha, instead of having no owner, let's make the owner an argument to the migration script like you did in the other pull request.
Do these need to check itemToBind?
Checking for null here is unnecessary. We already do it in the validateConverters() method, if the user passes null, the usage of the annotation is invalid, and we do not generate code for it.
If the delay is positive, the thread can't be reused and the code must be enqueued. Or, we have to check in UiThreadValidator' ifPropagation.REUSEis used with adelay.
i think something is wrong here, when host moves to up this command is called, status shouldnt be non operational, also the reason, so this always returns true?
can you also add catalog id and database name into the message?
Consider doing a null check first, because this introduces the risk of a NullPointerException.
This is probably not the right example. This specific problem goes away when you use the Right R class here. Can you modify this change to repro your case i.e have another module refer to the resource in its main code and this module invokes that piece of code in it's test?
what about setColor(int progressAndThumbColor, int backgroundColor) if they alway need to be set together?
I think we need to set the normal notification text as well here, otherwise when the notification is collapsed a blank notification is shown: <img width="439" alt="screen shot 2017-11-17 at 9 10 54 pm" src="<LINK_1>"> Once you drag the bottom edge down to expand it, the bigstyle text appears: <img width="441" alt="screen shot 2017-11-17 at 9 11 25 pm" src="<LINK_0>"> So, we'd need to add  notificationBuilder.setContentTitle(title); notificationBuilder.setContentText(content);  to the NotificationCompat.Builder(context) concatenation right below
Generics on the right side are redundant since Java7
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
nit, Collections.EMPTY_MAP?
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
asserts are more or less useless, they are only enabled if you compile your program with -ea, which almost nobody does. Instead you should do an if check and log the error and/or throw the exception. Applies to other place below too.
tab can't be null at that point.
I would rename the original createAuthConfig() to a private method with a distinguished name to clarify that this should be the single entry point.
s/ret/partitionKeyStr maybe?
Could you please move this after List<Trace> fragments = getFragmentsForTraceId(tenantId, id); with ret definition. And change the if to ret != null and remove ret != null from the for statement?
Food for thought: When the user clicks Back after visiting a random article from here, do we want to show the same random results she saw before leaving this fragment? or should it be a new set of random results?
Are you sure it's necessary to use the Bus for this? Why not simply obtain a reference to SearchArticlesFragment, and call the startSearch function?
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded ?
Can these be declared at class level and used for both methods?
It might be helpful to use different min/max values for bounding box so we can test the order is correct.  peliasWithMock.search("test", "1", "2", "3", "4", "5", "6", callback);
Can you use Collections#reverse instead ? We're trying to not use Guava.
I would create a private static checkArgument method for these checks
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
remove else
Can you call this maxIterations, as the actual number is rather determined by the termination criterion?
@inverno We have 2 times "Second argument" :)
same about exception and doc Also resources might never be closed
Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable
suggestion  refresh still shouldn't be necessary.
final
TimeUnit is easier to read than the SystemTime constants: timeToLive = SystemTime.getInstance().milliseconds() + TimeUnit.HOURS.toMillis(1); I had to read your code twice to pin down that TTL is creationTime + one hour. With TimeUnit, its one read to understand.
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
Can we use a immutable Vavr map instead?
Create new lists rather than assigning them.
Let's find a better name for _bufferSize
Please move listener to desired mode
Missed this earlier. Should we call the super here and in onOptionsItemSelected?
Casting to MenuItem is redundant here
Use StringUtils.isNotBlank instead.
Leave out this line, the processException will already log it.
Leave out this line, the processException will already log it.
I think It's needed to convert to milliseconds.
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
@mariebawanan I think the proper fix for this is to remove the duplicates in variables VariableTypeList instead of just filtering out the duplicates here.
@cuenyad Having 2 for is not needed. Iterate lotDepositDtoList and have a map with LotUID as key
compare against enum
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
I don't think you need to print stack trace here. It'll wind up polluting the test output.
are you sure this is the best way to handle this exception?
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
CastException, not format.
CastException
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
PLUGIN_ID
PLUGIN_ID
The more appropriate thing to do here is Log this message
Please also add a feature flag here to show the editing option only for pre-beta builds. (ReleaseUtil.isPreBetaRelease())
I think something like this should be discussed in #3788. We already cause quite a lot of traffic to iTunes and I want to keep it to a minimum, so we do not get locked out one day.
ERR_DELETE_ERROR, add if there isn't one already
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
This line is now obsolete.
"Encryption failed"
can be assigned inline in class member definition
I think we should try and find an alternative to exposing onCreateAware and wrapping its call in a try/catch. When possible it is good to avoid wrapping large pieces of code in try/catch statements because doing so lets us be lazy about when things fail. I'll poke around and see if I can come up with any ideas.
only one element? maybe try to use singleton set
tab
should this be a lambda?
should be callback.readFromCache and getFirstPageGroups(bridge)
You're not using Result.success is the result always non-null? it doesn't seem to be the case since you're returning null in a couple of callbacks ...
what about making runPartialSyncRegistrationCallback non static, we will no longer need to keep sharedRealm in the callback
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
In this case, we should show the API Status message to the user
Should we now fall back to the flow where we prompt user to open it in another app? Or at least show a toast?
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
Bind these in the system module, aka Gerrit-Module. Its much less complexity for anyone to deal with.
handle these missing more gracefully than NPE
While I applaud the use of format, this syntax may lead readers to think the value of add.size() is the argument to size. How about "add.size == %d != %d == distances.size" ?
I'm not 100% sure but I think this should be the other way around. feeds.size() seems to be the expected value. This problem is also present in other tests. Before, a failing test just showed something about a failed assertion. Now it shows actual value and expected value, so it is misleading if they are exchanged.
ArrayList should be constructed with fixed capacity.
The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it.
Should we be reusing the walk we've already setup? Why create a new pool of revision objects when we can just reuse the one we already have? On the other hand, a walker could dispose of object bodies, and a reset and reuse might confuse the caller because the bodies are gone. That's actually a bug in RevWalk that we should probably address and fix there rather than forcing an entire new pool to be created for a second invocation. Likewise, RevWalk discards the starting commits when it resets. We probably should allow those to be retained somehow, so the same walk can be executed again without needing to maintain our own copy of the starting points (RevWalk calls them "roots" inside of itself.) Finally, RevWalk's implementation of Iterable is probably wrong. It only works once. Creating a 2nd Iterator fails. So we probably should fix RevWalk first so its iterator() method resets the walk and starts it over again.
Unnecessary.
method.getMethod() is already clear. You don't need to extract this method. Please get back to method.getMethod()
this comparison is not required to avoid NullPointerException?
OperationException
You also need to update the text of the menu button here.
As this method is duplicated thrice, you should make it a static util method boolean isRTL(Context context) and then use context.getResources().
FIXME: All front facing strings go in strings.xml.
Would it be the same to say lemmasList.addAll(keyValues) here?
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
new ArrayList<>(causes);
IMHO it's better to explain proposal of setup debug id here to prevent occasional removal in future, like the follow: > do not remove debug id; it's needed for selenium tests
redundant ";" character
I think these all should go into your symbol table class eventually.
Does the segment delete need upgraded locks?
Should the log say "unknown segments" instead of "unused segments"?
I think you could make SegmentPublishResult.fail() a static object instead of a function that returns a new one
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
Please remove that
I think the older version checked empty string and this change removes that check on the username?
Nit: No need for final variables.
Can we combine the two? I don't see the point to have a different annotation for multiple functions and single function. We use @ScalarFunction to annotate both class and method. It's also quite confusing to user since it's very hard to notice the difference of the two (so very easily to use the wrong one).
The cause should really have an abstract method for this instead. And return EnumCause rather than Enum<EnumCause> from its method.
on the catch, let's add a servere logger
Should the whole stack trace be logged? This exception is handled by the notificationSenderCallback
This is an Optional value and thus should not return null. Use Optional.of() and Optional.empty() instead.
I think we should prefer a setter here rather than member variable access.
Use direct check, not callback
Collections.emtpyList()?
Could use sl4j parameterized log statement. suggestion log.info("Looking for matching filesystem for {} from options {}", exportDir, tableDirs);
This was probably autoformat'ed but you could put a line break somewhere else.
Doing importDir + "/" + sa[1] repeatedly has the potential to use a lot more memory than just sa[1]. Maybe this could be an issue for really large imports. This could be addressed with a value object that points to importDir. Something like fileNameMappings.put(sa[0], new Pair<>(importDir, sa[1])).
So did you remove the null checks?
space before '('
rename to childItem
rename this to checkCompleteContext please
Internally this method just uses com.conveyal.r5.common.GeometryUtils#distance, which operates directly on two lat/lon pairs. By calling that function directly we can avoid construction of an ArrayList and two Node objects. It's essentially an optimization (and one that may not have a ton of impact) but one that also makes the intent of the code clearer (find a distance without actually retaining the List and Nodes). The Nodes are also really OSM objects so we're taking a detour through an only loosely related data model.
vmIsDown() == true than vmIsUnlocked() == true vmIsDown() == false than vmIsUnlocked() will not be checked.
Missing opening "(" before getDescription().
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
There are enough mock objects in here that it's worth using @Mock annotations instead.
This is not used anywhere
Are these mock objects used?
Why not just pass in only the message?
Isn't obs.getObsId() already tested on the previous line?
Shouldn't we put back the check for getData() not being null? Of course in addition to what you have just added. :)
The cast is not needed
Wrong class (TaskService?)
Why are you synchronizing on FilterService.class and not on ImageService.class as you are inside ImageService class?
This sometimes leads to IllegalStateExceptions. That's why I switched to startforegroundservice recently > The startService() method now throws an IllegalStateException if an app targeting Android 8.0 tries to use that method in a situation when it isn't permitted to create background services. > <LINK_0>
nit: doesPathExist or pathExists
The listener call and the doProcess should go outside of the try-catch block, if we're guarding against mapping errors here.
Collections.singletonMap() ?
Generics on the right side are redundant since Java7
check if getters1 is null and remove firstTimeStream
Perhaps also desirable to call track(Node, Credentials). (For BindingStep, just inject a Node; for SecretBuildWrapper, use the method on AbstractBuild IIRC.) @stephenc any guidance?
Why are you collecting these? The result is unused.
:bug: no do not call bind here please.
don't wrap at .
Simply: "return builder.parse(id);"
Shouldn't this be "Custom/"? Because if you look to string s (below) you will have a double slash on the one side and no slash on the other side
move to start, no need to loop if tree is not checkable
Probably a dumb question, but why can't this be written as a visitWindowSpecification method, which would remove the need to pass parameters into joinExpressions?
There is a util method for generating readable signature error: <LINK_0> Is it enough to use that method rather than manually create new error messages?
same as others: log should have Exception as arg
this method can be static right ? , so you can do ConfigurationLoaderImpl.load(); , the name of the class can be better.
Please remove the media type check; there is no requirement that Content-Type header is available for bufferEntity to work. readEntity(...) can work without it, for example, when doing readEntity(String.class)
It might be better to use Collections.emptyMap() instead of new HashMap()
should use given display in parameters
isn't it always true?
Sad times, but I don't think we can easily work around this.
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
naming
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
This line is redundant.
Unneeded change. This only used in RegexPathPredicateTest, that is in the same package.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Nit: this is duplicated at line 48, I would get rid of this line.
emphasized instead of emphasised
Why is this better than using org.junit.Assert.assertEquals? If we use assertEquals, we don't need to add assertj to the project.
Use type.getObjectValue to print the indeterminate in the error message to help user debugging: java throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "map key cannot be indeterminate: " + mapType.getvalueType.getObjectValue(session, keyBlock, i));
A future commit introduces a RowType enum. Is there any reason that change is not part of this commit?
add a message containing both values, in case it ever fails
There seems to be a convention established to update these metrics. For e.g. replicationMetrics.updateMetadataRequestTime(metadataRequestTime, isRemoteColo, isSSLEnabled, remoteDatacenterName); Is it possible to follow the same kind of convention here (updating via a function)?
remaining time only makes sense if the state is down. In the up case downUntil could be in the past and this could print a negative, misleading value.
Not your change, but I think we are doing this wrong. One of these variables should be forced to float; I suspect this resolves to 0 most of the time - with 300KB written (~ average size we see), even with 60 ms send time, this would resolve to 60 * 1024 / (300 * 1024) == 0.
Maybe mix multiple timezones? The idea really is to trigger a failure, so let's not make it easy for tests to pass... In particular, I would use local date/times that are not ordered, but become ordered when you take into account the time zones.
Here too, using at least two different timezones would be nice, be it only to check that the timezone is not retrieved as "Europe/Paris" by chance, because it happens to be the JVM default time zone.
Package private constructor, rather than just public?
This should have the data source name in the message and add the actual identifier as metadata on the alert. The messages are what turn into the email subjects... Also, after the alert happens, this is going to fall out of the if statement and do other things. Are we sure that those other things are what we want it to do?
(Optional) Does this need to be anything other than Collection<ServerHolder>?
Isn't the logic changed if the dataSource was not present? In previous version, it would exit early with Told to delete a queryable for a dataSource[%s] that doesn't exist. message. Now it create new DataSourceState(), checks that loadedIntervals is null (it's not), and finally creates an entry in dataSources Map. It should exit early via if (v == null) {message; return null}. Or use computeIfPresent() method.
Is it a conscious decision to throw an unchecked here?
Could eliminate the duplication by always attempting dir.mkdirs():  dir.mkdirs(); // don't care if this succeeds or fails if (dir.isDirectory()) return dir; throw ...
Include the path in the failure message?
hint: can we merge all these three "if" clauses? The same goes to equals method. You can break lines before "||" for better view.
This equals implementation should include attributes from the Command super class.
does it matter that you are not comparing owner (PublicKeyHash)?
why if is here?
I just noticed that this should be updatedSessionData.getAllAttributes(), not sessionData. It's not a big deal, just a minor performance tweak, so I think we can address this in a follow-on PR.
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
We shouldn't ignore an invalid enum value.
This doesn't seem to ever be set to anything else?
change to interface List
Why are you not using your UsbSerialDeviceInformationGenerator?
PlayerBackpack is redundant here, no need to specify the class you are already in.
There should be a white space before else Also you could use word.charAt(i) in both the if and else statements (e.g. word.charAt(i) == 'y') instead of using substring, that might make it a bit more obvious what you're doing
I would have moved this line after this.killNodeImpl(node, host); to be sure that a node is deleted and forgotten only if the runtime on the remote node has been really killed, otherwise the information at the Scheduler level may be wrong. Same apply for other infrastructures.
This method name is a bit confusing.
I am often afraid to print a list of nodes. Maybe we can print the number of nodes in info, and print the list in debug ?
typo _start_ -> _stop_
String concatenation here as well ?
If it is clearer then method name clear looks more natural for me than remove
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod - resourceInformationGetNameMethod
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
have a default constructor with reasonable default values
Since Preference changes may occur due to outside stimulus, we should bail if getActivity() is null here.
@cagryInside Could you also please add dispatchLocalHits() after reporting this event? I'd like to flush any existing analytics info here, so we don't have analytics continuing to report (e.g., in 30 min) after the user has opted-out. As we found, I guess this will only work on devices without Google Play Services, but at least its our best effort to be consistent with the user's wishes. And, if Google Play Services decides to support this in the future, we're already set.
The value checking is not needed here, only the preference. We already check the value in the other test.
Where is selector.close(). It is not in NonBlockingConnectionManager::close() (which is where I think it should be).
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
since you are awaiting termination otherwise, seems like this should either be an isTerminated() check or you should do an awaitTermination() anyway in the else. Let me know if my understanding about the ExecutorService interface is wrong.
well, the probability is very low, I know, but shouldn't be >= ? in terms of readability I would prefer to have if (fetchTime.compareTo(vmManager.getLastUpdateDate()) > 0){... } else {.. } - but that's subjective I guess, so for your consideration
it would be safer to take the lock first and then check-and-update the time stamp
there is no need to throw exceptions in the constructor, we have 2 infrastructures you can use: 1. bean validation in the parameters class (see AddBondParameters for example) 2. canDoAction method and return a nice translate-able message to the user with the problem
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
You line wrap MUCH later a couple lines down; should this wrap later on this line, or wrapped earlier down below?
lines should not exceed 80 characters
The check item.getUrl() != null is not needed.
Bad code. Remove try - catch.
I find it even easier to read without the (...)
Why is it required to do it for every event type in the subscription?
On line 133: partitionSession = getPartitionSession(subscriptionId, eventType.getTopic(), cursor); you take topic from event type. I think it does not make much sense.
this method validates much less than validateSubscriptionResetCursors used to validate.
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
in /export action we use action.isExclusive(), please do the same here.
name will change....
Well, if we know the Exception so its not really "unknown" :-)
can be debug
change
looping with a char is kind of weird?
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
We don't need this. There is each method in AbstractMatrix class that has the same logic. And we can't do it better than there.
typo
Why is true explicit?
java TimeUnit.SECONDS(30).toMillis()  is more readable
docPossibleAncestors and revPossibleAncestors?
no need to specify type on RHS
Local variable could be declared List instead of ArrayList. Is this worth caching?
This test against methodName seems to come too late. For efficiency, it could occur after the assignment and before the reassignment. More importantly, can methodName ever be "<init>"? If the method is <init>, wouldn't node have to be a ConstructorInvocationNode? Also, the reassignment could occur within the receiver != null test.
You can probably stop at METHOD level as well. If you reach a CLASS or a METHOD, before an ASSIGNMENT or a VARIABLE, it can not be stored in a static final field. Now, you may also want to group the KINDs you target by category for consistency (CLASS and METHOD are failing stop conditions, ASSIGNMENT and VARIABLE allows you to investigate further)
This is practically identical to the diff hunk just above. How about abstracting it out?
I wonder if we're getting to a point where we should have an isComplete method on our entities to check this kind of thing without needing this kind of code in a number of places.
do we really want to set this in the fixture rather than using the auto-generated value?
I think I'd prefer that we return a NonDeploymentSubscriptionContext. That could throw exceptions on any attempt to subscribe etc, and would just return false for unsubscribe. I don't like having lots of null checks in the calling code.
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
What do you think about Comparator.naturalOrder() instead of null ?
nit: this is a slightly nasty way around the line length issue.
The more I think about this, the less it makes sense to me. Specifically in the end of end-of-form navigation or register from case list (entity list <action>'s) you could add the session frame  m_0 case_id_one case_id_two  to the session, and have two menu declarations you are jumping to, each with an entry:  m_0 e_1 - case_id_one - case_id_two m_0 e_2 - case_id_two - case_id_one  and e_1 and e_2 should both meet this check. If you visited the m_0 form directly, you'd expect to need to choose e_1 or e_2 first, because their order of selecting id's is different (and they may have different filters), but once you've chosen both id's, semantically both forms should accept the two.
please apply formatting
This should happen within the future
Typo: Organization
The EVENT_TYPE_BY_NAME_MAP is not safe for concurrent access; I see you added a synchronized on this method, which is correct as it performs write operations on the map. But this implies that we'll need to have the same lock on reads as well; perhaps the map should be changed from HashMap to a ConcurrentHashMap? Alternatively, I wonder if the map could be statically initialized by discovering a service. If you define a "CustomEventTypeContributor" interface, then Hibernate RX could implement it and you could load them when this class is initialized.
Strictly, should also do if (resolve) resolveClass(result); (in case a class has been added that has not yet been linked).
maybe, it would be better to inline that actual following way:  java Matchers.containsString( new StringBuilder() .append("<a>") .append(System.lineSeparator()) .append("<b/>") .append(System.lineSeparator()) .append("</a>") .toString() );  what do you think?
same with this
the majority of your changes are simply passing arguments all around the codebase
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
Is this required?
"old" is the user identifier, right? I would rename that
please replase MojoExecutionException for a new generic DeploymentExecutionException
just remove the fileSize from here... and that's the only change you will need.
Cleanup: Remove all **throws MiddlewareQueryException** clauses
> When we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom. true
Please use Vector.ofAll() instead of Stream.ofAll(). See an explanation below (at the Option.sequence() change).
We provide 'user friendly' messages on NullPointerException, here:  java Objects.requireNonNull(values, "values is null");
You don't need this line because of green 31.
no need for concurrent
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
I think it would be better to have two asserts, one for each metrics file....that way when something breaks it's easier to understand where the probem is
What would the previous code have returned?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
All lines between beginning of this method (and all others) and this one should become the setup fixture (@Before). Then, for the methods that require a writer or loader, you could just reference the CacheManagerBuilder field, and append .using(...) as needed.
Have String headerKey = key.toLowerCase(Locale.US) only once to avoid repeated case conversion.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
@xpdavid is this the right thing to do?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
This is completely redundant as the Listener which calls this method already checks if it is cancelled. Also missing brackets.
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
Can check for Collection here
nit: we should use a config for this value, maybe we can update it in next pr.
Is this still a TODO?
I understand that this is quick and simple fix, but as experience shows we can't rely on the system clock: no guarantee that CPU will get access to the target process exactly after this timeout. In the end we are going to have sporadic test failures. The best way to sleep with short period and check the state of the component we would like to assert afterward. If you have some argument to proceed with this simple sleep, let me know here. Thanks
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
@brunoliberal We already have a class to do that. Take a look at TechGalleryUtil
the connections collection is never used so this change is superfluous.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
Ok probably ${} option format is bad because it conflicts with maven variables ... so just something else, but you get the idea.
OOC, in what ways does findSpecial differ from unreflectSpecial? are the two functionally equivalent (ignoring the JDK bugs), except one stards with reflect data (Method) and the other with a signature (MethodType)? if so, is it worthwhile simplifying this to _just_ use findSpecial? also: does this change have any impact on the calculus of who has access? if the types (args or return) are private, package-private or protected, will unreflectSpecial|findSpecial fail whereas the reflected approach would have succeeded, because we explicitly set the modes to all access levels?
rename to automationContext
speces before and after "+" :)
Remove throws Exception
code dup. would be better to move it to private saveInternal()
Fire the event outside of the monitor.
We may want to make the start/start stage, etc.. method names match up better.
Mmmh, I'm not sure to follow you here. What is bothering me is having two times the same message on the same tree (so a duplicate of Location). So why considering the kind of the tree and only the message value? It's probably way simpler to rely on equality of locations to filter out, with a LinkedHashSet for instance.
I think that domains.stream().anyMatch(d -> d.isAssignableFrom(lc.constraint.getClass()))) really deserve a dedicated method. It's not that easy hard to understand what it does, and a named method could be more explicit. I wonder about using direct access to the field rather than method call. Seems not coherent to use both approach, as both field sv and constraint are visible from here, I would also change the lc.symbolicValue() by lc.sv
constraint should be enough ForSv is a bit of a pleonasm
why not null?
iiuc, this will write to the log every 5 sec, which might flood it, i think its better to have this as debug/trace
We could use java.time to avoid manual calculation of time period.  Instant dayAgo = Instant.now().minus(Duration.ofDays(1)); return getCreated().toInstant() .isAfter(dayAgo);
Hmm. do we log tags? Probably a good idea but C Git doesn't.
Second parameter of Status is the pluginId. Why to pass path here?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Nit: Since you're not using the in variable, you could builder the isr in one step
end should probably be private static final String. Doesn't make sense to create new local variable in a while loop..
Which exception has been observed here? Please don't catch exceptions when we don't actually know what they are.
To be super clear, wdyt about renaming mTryAgainButton to better match its new functionality?
Call provideAppName() from SalesforceSDKManager instead for appName.
It's probably better to post an event here that the relevant TraktAddFragment then reacts to. No need to hang onto the adapter.
EditedStyleItem item = (value instanceof EditedStyleItem) ? (EditedStyleItem) value : null;
why are we doing this here? shouldn't resolveColor do this? also this same code is in 2 other places where it does not have these extra bits (ColorEditor, DrawableComponent)
Chronology is only needed in the else case, right? can it be limited in scope to just that code block?
is logics correct here?
Minor typo in first sentence of error message.
might it be useful to log the response body as well?
Oh yuck. ;)
Update labels to go with method names. Alternately, call super.toString for super attributes
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
only if name changes?
nit: hasMessage(...) and have the full message.
You know about <LINK_0> ? You don't need to write your own Map.Entry implementations.
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Weight init, Keras -> DL4J mapping: glorot_normal is xavier glorot_uniform is xavier_uniform he_normal is relu he_uniform is relu_uniform Normal and lecun uniform might map uniform and sigmoid uniform? check math on that
If Java doesn't have built-in libraries for this, may be use an external library such as jodatime or natty?
Redundant replicationSpec.isInReplicationScope().
perhaps, that should be a warning
I'd add a checkState to every one of these methods to make it clear how it lines up with the switch case above
Should we log a warning or throw an exception in the else of this if? I don't think we want to just quietly ignore a put call...
As previously discussed this is not thread safe. We cannot use Map.computeIfAbsent() or Map.putIfAbsent() introduced in JDK8 so I propose to add ConcurrentMap<K, C> concurrentMap field and corresponding param to the constructor. It would be illegal to provide both suppliers. The get() method could have two branches. One for regular map:  if (map.get(key) == null) { V newValue = supplier.get(key); if (newValue != null) map.put(key, newValue); }  And second branch for ConcurrentMap - the same as the current version but using putIfAbsent() instead of put(). Of course, we would have to modify SetMultimap and ListMultimap.
And this too?
It looks like you are returning an empty ArrayList keys
Just trying to figure out why this has this been done. Under what circumstances will we update the Germplasm and its name.
Check args?
this is not ok to schedule tasks using only delay from received header: - we should validate if value is within reasonable boundries (0, maxMessageBackoff) - we should discard message if retry-after is after message TTL to respect TTL policy
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
Let's make this log string follow the JSON format as well for consistency.
try-with-resources
not your code...(perhaps...) but should try-with-resources
/s/else/elseif
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
All of this can be replaced with an ExecutorService
use Arrays.fill instead for loops
For each?
Mid return may worsen readability
minor: this v == null check is unnecessary.
if test is in same package, then visibility can be default
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
model should be passed in the constructor instead.
Stick to java naming convention - variable starts with lowercase.
why use domain id from parameters and not from storage object from method parameter?
s/Mac pool/MAC addresses pool
are you sure that this should be logged with audit log and not regular log printing? imagine a system with 1000 VMs were most of them are running (production environment) and you want to import just 2 VMs that are down - we'll get too many audit messages..
Can you make this show a useful message back to the plugin?
Do we need any tests for the changes in this plugin info builder and others?
You'd better use a logger here to ignore the exception or propagate the exception using Throwables.propagate
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
I think this method can work just like set(). You complement the intMask with ~ and then &= it.
tab can't be null at that point.
you have lost the cause e
type might not always be a Class. If the API method returns List<User> this will be a ParamterizedType which isn't not a Class.
Please use IOUtils.closeQuietly(is); instead then.
Stick to java naming convention - variable starts with lowercase.
I'm curious about the design choice that requires a new object to be instantiated for every basic operation. This seems potentially inefficient if these operations have to be performed many times.
Nice choice of list ;)
Probably should use combineDegree - 1 instead of hard-coded 1 here?
As I understand the code we have 3 use cases of getHetGenotypeLogOdds: 1. tumor lod: use the allele fraction of tumor and reads from tumor 2. normal lod: use 0.5 (GERMLINE_HET_ALT_FRACTION) as the allele fraction and reads from normal 3. normal artifact lod: use the allele fraction of _tumor_ and reads from normal With the current code, for case 3) we use the allele fraction of the normal. My understanding is sampleForAlleleFractions should always be set to tumorSampleName .
Change OptionalDouble.of(0.5) to GERMLINE_HET_ALT_FRACTION (currently unused) or change NO_FIXED_TUMOR_ALT_FRACTION to OptionalDouble.empty(). I prefer the former.
You may want to use assertEquals directly?
Minor: Assert.assertEquals
Minor: Assert.assertEquals
it might be worth having this as a constant with a quick explanation for why it is needed (emulator's deletes are not instantaneous).
The span name should match the method name which is read here
please remove.
Is this wanted functionality? Making a new list will mean that this won't refer to same object anymore, which was what was done in the original situation.
Is this wanted functionality? Making a new list will mean that this won't refer to same object anymore, which was what was done in the original situation.
explicit type not needed
debug/trace/remove?
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
Hm, we could use == as well for comparison, as we don't have custom equals() implementation for model classes. (IIRC, most of GWTP infra code working with models just compares references.) Current code change is OK too.
Why the single quotes (')?
Since we put a log in the app deployment time stating authorizer is null, there is no need for this log.
nit - Can you improve the exception message?
why not use File.createTempFile() ?
still returning success=true if the spray fails
I think protected might be more appropriate
throw something if sqlCompatible
The last ask about using ZERO_ constants was particularly about makeObjectColumnSelector() methods, because they return Object. This method returns primitive so the change here is pointless (and in some other places in this commit)
0.0
This cannot be removed. The scheduled task needs to be saved.
a scheduled task that needs to be retried is removed on line 139. This cannot be right.
The method name for handleScheduleTask suggests the method deals with scheduling a task. It looks like something like handleScheduledTask is what actually happens.
optional nit: this is still confusing for me, maybe it could be reworded as suggestion Unable to determine max direct memory size. If druid.processing.buffer.sizeBytes is explicitly set then make sure to set -XX:MaxDirectMemorySize to at least "druid.processing.buffer.sizeBytes * (druid.processing.numMergeBuffers[%,d] + druid.processing.numThreads[%,d] + 1)" or else set it to at least 25% of maximum jvm heap size.
Why contains and not string equality here? For instance 140.0.0.0 contains 0.0.0.0 but I don't think we want to rewrite that to localhost. Also, it would perhaps be marginally cleaner to only set a variable storing the cleaned host in the if block, and then build the URI based on that cleaned host?
Please keep it in info level.
One of 2 things should occur here: - Opt A) throw the exception ( add it to method signature ); not the generic Exception, but the IOException one - Opt B) set file to null, so it ends up getting returned as a null object, rather than a corrupted one If none of the above occur, and in a scenario where some exception takes please, the person leveraging this method would never know of it, and rely that the returned File object is a solid one.
This can cause problems for some KnowledgeBase implementations when reporting statistics since the list of found causes can contains causes that are not in the knoledge base and hence has no key in whatever database it uses. A QnD way of fixing this could be to not include them in the statistics logging at all, i.e. add them to the list after the stat logging call.
As these lines for actually writing out the file are identical for file and backup (apart of this parameter, of course), could you please factor them out?
I think this might lead to unused space on the right, when one of the columns has a higher preferred width than it's maximum (because you don't redistribute the difference among the other columns).
Extremely minor, but this doesn't look like it needs braces?
I'd like to see direct unit testing of withService and updateServices . There appears to be a fair amount of indirect testing of withService but updateServices gets little to no coverage.
This could be null, we should probably handle this if the JIRA api changes again
Don't we have to say that this is uniqueId JDBC?
Useless parenthesis.
Remove this check after merging #139 to develop and synchronizing this PR with develop.
Since this is not really activity related, I think we should have this in the ViewModel. We shouldn't really need to clear the adapter and manually handle the empty view. This creates an inconsistency between the view and view model. If the search will go through, we should remove the current data in the view model and post an update and let the observer pattern do its thing. I've already made a suggestion about how to handle the empty view previously. There is an example of this which starts [here](<LINK_0>
log.info or log.error?
add the exception to the newly created exception
Did you mean to use this size var below? It doesn't seem to get used at all...
this is an implicit ELSE 0, right?
this should be outside the loop? Otherwise it will only check for the first brick in the list
Guid should be compared with equals.
It will never reach here, as you break after found=true. Add the found = false after for (GlusterBrickEntity paramBrick : bricks) {
Name it folder, or reuse doc maybe? domain is misleading.
You can also import staticly assertEquals.
I see it's just a copy/paste of similar code above, but note that you can do just file.refresh() instead.
Here you are setting activity argument to a presenter but the presenter is only presentation logic and a presenter should not know anything about Android Framework
Camel case
What about extracting this block of code into a private method? Ideally, public methods should be like pseudocode (no conditionals, fors, etc.).
Hard-coded. What if we add another format in the future?
Minor thing: please use "something <operator> null" convention.
Behaviour is changed here, is this intentional? Looks like tests failed because of this change in behaviour.
This just follows what's done elsewhere in this file but we should make these more efficient and not read the entire model, which could be huge in a domain. It seems like this could be done with 2 reads, a non-recursive read of the root to get the host name (which will be available even without recursing), and then a read of the server config resources under that host.
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
Shouldn't this be "show-history"? Or L77 should be "patch-info"?
We should never have to do a full permissions cache flush. Think about customers who have 1000's of sites with 1000's pages. This is too broad.
Does it make sense to validate before we schedule the job as well?
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem in the new serializer paths that we need to address. Ideally the following line should work: ConflictOverrides overrides = args.getAs(CONFLICT_OVERRIDES, ConflictOverrides.class) If so, the setter above should also change accordingly.
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
what if delete fails /system goes down after the dump ..how to cleanup the previous dump directory ?
Are we still keeping the cm?
This is sync can cause performance problems because it acquires locks inside the sync block and its the same sync as startCheckerThread() which every thread calls. Therefore it makes threads wait on each other unnecessarily, when they should be able to proceed independently if working on different keys. This is fixed in the changes I made in lbschanno/accumulo#3
Fix message
This should probably be an error since it is fatal and that way it will be seen by apprunner
Since it is major websocket endpoint it should be logged as error
I think e as a variable name would be prettier than executor1.
let's make a meaningful constant for 5
suggestion if (reader.relationshipDirection() == Direction.INCOMING) {
More examples of where this is used outside home pages.
Oh yes, can change this back to formatDateTimeForSessions and delete this method from TimeHelper? It's a workaround for this issue.
Can be written shorter as while (cursor.moveToNext()) {   }
Why this catch? I feel it may be related to category feature. We should write some doc here to tell more.
Shouldn't you add the colums disposition, disposition_type and disposition_log_guid?
it looks like createMergeConflictInfo() always shows the warning, then adding the warning should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
I think we should also display the involved branches/commits which the user tried to merge (in the same way we do that for a plain merge operation failing due to merge conflicts)
maybe it would be better to first open the interactive rebase view and then show the warning so that the user can see both to understand what happened
Isn't the devfile detached from the JPA session when it leaves this method anyway? Why do we need to create a copy of it?
I'm not sure if we should swallow the exception here.
Catch a less broad exception here?
make this one final maybe? there should never be a reason to override this
No need for a function, just make an inner class UpdateLogTask (like in SyncthinkService). Also, getSyncthingLog() and getAndroidLog() seem to have quite some duplicate code. I would just put that in doInBackground() and make an if to choose the logcat command/parameters.
Shouldn't this message disappear (be hidden at some point) ?
Not directly related to this PR. But at some point, we need to update <LINK_3> <LINK_0> They say " It is the average amount of time it took for ack or fail to be called". But the latency is only calculated on ack not on fail. The original code <LINK_1> is implemented the same. I believe this is a mistake introduced in <LINK_2>
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I'm missing the new field in the toString method.
Instead of calling this, please move the progress bar further down in the layout xml file.
This is duplicated
Format this file with A.S. default formatter.
Local variable could be declared List instead of ArrayList. Is this worth caching?
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
Not needed to test emptiness, it's contained in condition below
this should be able to reused. it can be a static field
is 404 not valid anymore?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Why do we print a secret systemUserPassword here?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Have you intentionally omitted index check?
In this case the order should be configurable for each of the event emitting listerners. This can be done via a Spring Boot property i.e. spring.cloud.task.events.<batch event listener>.order=<order#> . For example: spring.cloud.task.events.job-execution.order=<order#>
Why are these not returning mAlignmentStart / mAlignmentEnd ?
Better use Assert.fail
This exception should be in the logs
Is it required to add null value as the default value, since it will return null if key is not exist in the properties. Another point is, have you handled the null value for a non existing key in higher layer when they are referred from IgniteParameters. Check whether you end up in null pointer exception if one of these properties are not included in properties file.
Is this expected to be just single udnerscore? Bbecause other chars are replaced by double underscore..
I know it's done in plenty of other places in the code base, but I would prefer not to use parameter assignment.
Clean shouldn't be necessary in JGit. Its required in the C hook script because we are presented with the *original* buffer from the user, before its been cleaned up by the commit creation routine. So there we need to drop lines leading with #, etc. But within JGit that should all happen in the higher level UI before that UI invokes the ChangeIdUtil class. (Or simply not need to happen at all.)
System.clearProperty can be used instead.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
You shouldn't be using the Schema constructor; instead use Schema.of().
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
Why not throw a NuxeoException here?
typo
java TimeUnit.SECONDS(30).toMillis()  is more readable
I think this line is too long. Did you apply the formatting rules?
There's a third constructor with a third parameter - variation. Not sure if it's widely used though.
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
Same here? if (e.widget != widget) { return; // Not for us. } Though I wonder how that could ever occur.
Use "guid" instead of "asGuid(id)".
And then else if this
Please consider adding the following Preconditions.checkArgument checks: * alias is not blank * cert is not blank * privateKey is not blank
Since we don't usually run with assertions enabled, please consider converting assert to Preconditions.checkArgument.
Please consider consolidating the declaration of the cert and key variables into the try block, as well as, pulling lines 298-303 into the try block.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
This throws the _other_ CancelledException.
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
Nit: maybe use different keys for the two tables here.
This will give different values for null and "" for username which you marked @Nullable.
miimonValue, I would suppose.
Can you add the user to the logParameters as well please (there is a .user(String email) on the log builder so no need to do addParameter. Can you do this in all places where you added the new field (all places where it's already logging something)
typo in log message
I'm not sure if we should swallow the exception here.
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
you are right about that. Not sure how I got that impression. Will revert that then.
rename to child or childElement
rename to child or childElement
Is there a chance of a NPE? could be getFile() null?
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
Use the one-argument version of "convert" and keep the call to setTaskName. Most monitors (including SubMonitor) ignore the string argument to convert(...) or beginTask(...) by default. setTaskName is treated differently and is normally shown to the user. There is no need to allocate or consume any ticks on this monitor since the entire thing is consumed by the parent. Remove the local variable and change to: SubMonitor.convert(actMonitor).setTaskName(CoreText.CommitOperation_PerformingCommit);
1) When would getCause return null? 2) Why drop the exeption message and use the cause' message?
You can highly improve the performance of this line by calling the Vm.isCreated() method. Check issue #188 for details. suggestion if(broker0.equals(vm.getBroker()) && vm.isCreated()) {
Creating a new set here seems unnecessary. The check for bios type can be done in the filter() method. For example: boolean clusterBiosChanged = false; try { clusterBiosChanged = FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && oldCluster.getBiosType() != getCluster().getBiosType(); } catch (IllegalArgumentException e) {} final boolean biosChanged = clusterBiosChanged; vmStaticDao.getAllByCluster(getCluster().getId()).stream() .filter(vm -> vm.getOrigin() != OriginType.EXTERNAL && !vm.isHostedEngine()) .filter(vm -> vm.getCustomCompatibilityVersion() == null || (biosChanged && vm.getBiosType() == BiosType.CLUSTER_DEFAULT)) .collect(Collectors.toList());
The method should be as before, where it receives a Vm as parameter and gets the MIPS directly from it. The real problem is: if you change your code so that VMs will have different MIPS capacity, using the vmMips attribute will make your simulation to wrongly use the same MIPS value for all VMs.
You can use Collections.singleton.
Not sure this is strictly necessary, @efge?
You can compare directly, no need go through a String: if (!Boolean.TRUE.equals(doc.getContextData(DISABLE_TRASH_RENAMING)))
We should go with a single histogram tracking tag count, since every ReportPointHandlerImpl can handle only one atom type anyway. Having separate histograms for points and histograms is not useful - we would have impossible combinations like ~proxy.histograms.2878.pointTagCount.p99, or ~proxy.points.2878.histogramTagCount.p99, which would always be 0s and waste pps.
please check if list is empty instead
Avoid calling getOverload twice.
Can you do a more precise check? Comparing the string with exactly what you expect? You should check a specific blob as well, not just the first one (not sure you'll have a deterministic order).
Could we put this in a @Before method ?
My bad, not needed :)
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like:  if(!AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(user)) && !AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) { .. }
Same question like above.
Implementation should use and check param forceDelete. If true, it should continue, on false I suggest to simply call above method (without forced flag). Also I believe user shouldn't be able to force delete own UES (even if its available in API only), it should be available to Perun admins.
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
Or even a new EntitiesSafe.invokeXxxx which catches and propagates the exceptions ?
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
It would be better if we would show the user some message as toast as well!
This is missing a line return true;. Otherwise, it will fall through and execute the next case, too.
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorRegistry().getQuickAssistProcessors(...))
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
Does this need to be addConfig as well? Users might be setting a default system descriptor in their application themselves.
I don't understand this method signature. Why should generateJobConfig take executionPlanJson? Also, why is it being added to the config?
Other places in MISO use owner to refer to a user, but it's used here to refer to the associated QC-able thing. What do you think about changing the field name on the DTO from owner to entity to match the QC model?
ipAddress not set
BoxableDto doesn't have a position attribute; is this perhaps doubling up on the setBoxPosition() call below?
We could probably share the Iterable Iterator part with unnest by making the iteratorsPerColumn a parameter.
final
(implementer's choice) - we don't check for -1 here, it'd be ideal to encode this in the type system
The first three should be required.
I don't know if we should set a default key. We might want to require the user to generate something unique to their service.
It might be best to extract this into a helper method and call directly when addProcessor() is called. That way the corresponding stack trace is easier to map to the actually call to addProcessor() that passed in incorrect supplier? Similarly, we should add this check to KStreamImpl#process() and others
It's probably safer to use EntityList.createEntityByName(String, World)
Position position position.position. Hmm maybe there's a better name for some of these :thinking: Just thinking aloud, not the end of the world :+1:
both filtering methods should also be abstracted I believe. edit: by both I mean this one and the one above. the only difference being && or ||.
Please extract a constant, StringUtils may be a good place for it.
Aren't these values already in the map?
I find the original version easier to read in this case.
Remove this?
We expect this test to return null, so just assert that the URI is actually null and forget about the rest..
Remove this or use the anonymous logger
make all local vars final if possible
Simpler: ArrayList<T> result = new ArrayList<>(collection);
It seems you have to choose between @sputnikci and @codecov-io complaining :p Could we open a @codecov-io issue instead of making the code uglier?
Can you explain what problem this is solving? The jira does not tel much about leases.
it may not be sorted
docPossibleAncestors and revPossibleAncestors?
Should we have an isAnonymous method that we can call here to make this clearer?
The method is "getItemFromRegistry", not "getItemTypeFromRegistry". Shouldn't the error message read "Unable to get item for item name {}" ?
Is this call necessary? It is called on line 109.
Can this be private, or is there another use case for default attribute outside the builder's call?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Since the varargs parameter of String.format(...) is of type Object for which toString() will be called if non-null, it's a bit safer to do the following in case the key schema or value schema are null: suggestion return String.format("<SchemaPair: %s, %s>", keySchema, valueSchema);
Can you put here "storagePoolId" instead of "spUUID".
You forgot to add the address to the toString() as you did in the patch on the master branch
is caching disabled for descending queries ? this doesn't seem to be correct.
I am wondering if we can use ExpressionOptimizer returned by RowExpressionService to do the optimization? It looks to me the RowExpressionOptimizer did something very similar here (creating an RowExpressionInterpreter) and call optimize: <LINK_0> For this case, we need a variable resolver. I am wondering if adding another optimize method into RowExpressionOptimizer that takes customized variable resolver as well? cc @highker
This should check the endorsedBy field I guess, since that is what is displayed in endorsed responses.
Extra new line.
no need for an ArrayList
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
suggestion // STS endpoint usually points to MinIO endpoint in case of MinIO final String stsEndpoint = "http://sts-host:sts-port/";
suggestion final String stsEndpoint = "http://sts-host:sts-port/";
exportAsXLS separate with .
A question about the purpose of doing this -1 test. I do not understand how this -1 works in Socket InputStream. I would expect that int read = in.read( buffer ) will block read until we get something from InputStream, unless an exception is thrown. However if we get an exception, we will never get to this if.
This class is intended to be threadsafe, right? This would need to be a CAS on an atomic long then.
Surely the increment of loc needs to be synchronised?
Can't we do that in the EnvironementInitializationFilter to avoid adding this top all the sites?
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
Why do you need to clone builder here if you don't change it?
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling invokeAsync.
Same here, it's better to suspend the transaction before invoking the interceptors.
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Please use more specific JSON type names.
I dont think you need the RocketMQ version number in the name here.
Fully-qualified class name not needed.
google style is to not use final on local variables unless it's required
Collections.singletonMap() ?
nit: this doesn't have to be done in this PR, but how about making JsonIterator a CloseableIterator? It already implements Iterator and Closeable so it would be pretty simple.
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
missing final
final
final
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
Use ImmutableDataCachingUtil.getValue(ImmutableSpongeValue.class, Keys.IS_SNEAKING, this.value, false); instead so that the value can be cached.
instead of e -> e there is a Functions.identity()
Hmmm this test depends on the ResponseStatusFromPayloadHttpCommandExecutorService fixing the response code. Even if the _real_ provider returns a 500, I'd just configure a 404 response to make sure the API works, without coupling it to that class. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that should be enough.
[minor] This is redundant. Test will already fail if the method throws an exception.
bad name
Lets use VectorUtils.of(...).
In both this and the test above all changed values are expected to become 1, due to the highest diff being 100. Maybe we should test with some other value as well.
This method needs to protect against its parameters being null (data and commandType).
style nit: no braces, more occurrences below
we don't need the enabled variable nay more. We can directly return the parsed boolean value.
NPE when req == null
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
FIXME: Don't cast getActivity(), use an interface.
we could put all the calls to findViewById(...) before the switch and store the views into variables, which would make that block more readable
Write this as a for-i loop.  for (int i = 0; i < newPositionCount; i++) { int position = positions.get(i); ... }
nit: You could do:  int finalLength = stream(positions, offset, offset+length).sum();
missing checkValidPosition(positionCount, position); below?
final missing
Why not enrich IntervalStatistics with these strings and then call IntervalStatistics.values() or similar?
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
String#getChars probably faster than this loop
I would pack this entire branch in a differet method
I am not 100% convinced if this would be a trace info. We probably won't need this information to debug the internal work flow, but whenever this information is needed, there should be some error (or complaint from users). So from logging perspective, it more looks like an error.
compareTo() and equals() have to be consistent with each other, which it is here. But you can enforce it and simplify by simply doing return compareTo(blobId) == 0; at line 353 and avoiding the code duplication.
Instead of adding a new constructor to CloudBlobMetadata just for this purpose, could you just call getClusterAwareAzureContainerName(blobID.getPartitionId().toPathString())?
This variable isn't needed. You can still do return contentRepoService.getRepoObjectMetadata(manuscriptVersion); inside the try-block.
move health_check to a constant
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
the type of hotplugSupportOsIdVersionMap can be reduced to Map in this context.
/s/else/elseif
FormRecord::update can be made private now after this change.
nit: import toSet static for consistency with toList (see L46).
need to pass Locale.ENGLISH here don't you?
Typo
All attributes s values were -> All attributes values were
Since you log the whole object you can change ending to deleted for {}., since attributes toString() is like Attribute:[content].
Attribute object is unncessary enclosed in [ ], opposite to createAttribute() method/message. I suggest Attribute created: {} and Attribute deleted: {}.
Another lambda-ing opportunity:  source_.withSaveFilesBeforeCommand(() -> { server_.startBuild(type, subType, new SimpleRequestCallback<Boolean>() { @Override public void onResponseReceived(Boolean response) { } @Override public void onError(ServerError error) { super.onError(error); workbenchContext_.setBuildInProgress(false); } }); }, () -> {}, "Build");
As discussed before you can use WorkbenchContext for this
While you're touching this... could be lambda-fied. Braces and newlines as you see fit:  source_.withSaveFilesBeforeCommand(() -> { withDevtoolsLoadAllPath(loadAllPath -> { sendLoadCommandToConsole("devtools::load_all(\"" + loadAllPath + "\")"); }); }, () -> {}, "Build");
you might want to return a specific validation error. Something like, "Slave host name is required" "Slave volumes is required"
Use || (boolean OR) instead of | (bit OR)
you could introduce a getGeoRepSession(masterVolumeId, slaveHost, slaveVolumeName) ?
suggestion
English literals ruin the point of translation :P
this will npe args length 3 == args[0] to args[2]
Initialize this map. With an empty map.
possible NPE?
checking that c-tor works is not enough, please put in XpathFileGeneratorAuditListener some stream and compare stream result with expected.
This is a bug. please change one version to timeo.
Make this private and implement a builder?
these should also use getStringValueToSet
Possibly should check the entire screen stack.
element != null is useless
I think we should go for the BigDecimals. The list is homogenous filled with BigDecimals, so we have them from the start. Am I correct @etirelli?
_nitpick_: Indentation is pretty far for the anonymous class definition.
I would add cache=true/false as a parameter.
Move both to variables for consistency.
Could lines 154 - 170 be checked once outside the loop? It doesnt seem like they would change based on the sync path?
Even though it's java there is no reason for trailing spaces
Only this check might be enough?
avoid using java 1.8 methods, reimplement with StringUtil
I think it should be non-null, since people have come to expect that for granularity: all. It would probably break stuff for it to be null.
static import
Do you need to use the "text" constant?
This should use a specific Locale.
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
This test against AccessDecisionManager might be better to do in the AuthorizationManagerAdapter's constructor.
Don't need last else
I would prefer constant there.
why not null as value?
Won't Integer.toString fail with "def"?
Inconsistent format! space after comma
try-with-resource ensures the second is closed even if closing the first one fails:  try (MessageProducer closeProducer = producer) { session.close(); }  (Later Java supports try (producer) { session.close(); } without the dummy var.)
Do we need this else block?
I don't see where we handle HibernernateException.
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
I think this code should use SystemProperties#getInteger() isn't it? And if you want to log warnings, then maybe we just want to create a third overloaded method to specify the desired Level?
Seems better to use String.format() here. Also you can do LOG.error(msg, e); so you don't need to include the exception message in msg.
same here. however I'm not sure if you can update tags on version. AFAIK version should be immutable and be result of write operations. Does updating/setting tags bump blob version? (updating metadata does that)
I would prefer to see this logic broken up into a couple of lines, it is a bit hard to parse. As well, then you could avoid the need to create the empty set to pass in for the other getProducts(page) call.
for the boolean parameter could be useful to use enums, so that it is more clear what it means
Better to return empty collection rather than throw exception.
Let's only perform this if contextKey != null && !Strings.isNullOrEmpty(value) and remove that check from the cache loader (i.e. getNodeInfoFromMetadataContext)
you shouldn't need it as UnknownUserException extends LoginException
should this be synchronized?
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
This catch block could probably be removed.
This NOT_USED constant (which isn't even a constant) seems a bit silly, and makes thinks less clear, not more. The pattern isn't even used consistently throughout the test - sometimes just null is used. Probably makes more sense to use null in all cases.
SimpleDateFormat might help make this a lot simpler. <LINK_0>
This can be static
System.clearProperty can be used instead.
Should we clear the property if there was none to start with?
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
please fix the whitespace. You just need to return the options here.
Better to extract local variable for URL to avoid noise from Sonar that we defer NPE calling the method several times.
Please initialize this with setMaxInflightRpcs(BIGTABLE_MAX_INFLIGHT_RPCS_PER_CHANNEL_DEFAULT * BIGTABLE_DATA_CHANNEL_COUNT_DEFAULT)
Don't we want to check if it's a 401 first?
Call requires API level 11 (we are on 10)
the cast should be done on Collection instead of Set... Does it cover the Map case ?
I don't like to define code as a String. This looks quite ugly and hard to maintain. Is there another way to set this?
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
Do a fetch following the delete to ensure that it was actually deleted.
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
Can handle something like ".1" or not?
If it were up to me, I would call this method toString(Object).
In what scenario would we have a Container in the map without a message?
Great catch! Instead of maintaining another Set could you just check processToContainer.values().containsKey(container.getId())? That guarantees that we're always in sync with what startExecutor has started, since it updates processToContainer.
![MAJOR](<LINK_0> 'Severity: MAJOR') Assign this magic number 100 to a well-named constant, and use the constant instead. [![rule](<LINK_1>](<LINK_2>
use compare - that is every version implementation implemented.
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
What about using BKBookieNotAvailableException ? or something like that
Replace SizeOf.sizeOf. You statically imported it.
Write  if (value == null) { continue; }  instead
values.isEmpty() - does it mean I cannot have a claim with an empty object, like this:  "warnings": {}  I don't think it is right then. This is a totally valid claim. Same for empty array claim:  "alternative_identities": []
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
There's also a Stream.of(m).forEach(...) if you like.
use SAMFileHeader.SORT_ORDER_TAG
not so readable. looks like good candidates for parametrization
The method implements synchronization via  lock API, the synchronized seems redundant.
maybe reset the isValid entity here as well, that way you don't have to make a separate call in a lot of places?
why not use the logger for this?
Move this usage stuff to the main method? It's only relevant for the command line execution, so should IMHO belong with main().
any reason we are using System.exit(0) do you see a hang without this?
I would explicitly write throws NumberFormatException here.
Good point
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
You have two placeholders in the stream but only one argument, is this intentional?
You're better off pokemon-catching these.
NPE should be avoided not handled.
You compare disk id to image id, which is not the same thing.
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we're not having so many nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
can this be class field?
does inTransaction automatically handle rollback and commit?
Please update this string to say "developer mode" instead of "debug build".
int rowCount = model.getSize(); Then the code in if block can be shared.
For unknown size, getItemCount() returns either 0 (initially) or the current estimate. Why is not intentionally working if I ask for the item that is current estimate + 1? Why is not intentionally working if I ask for the first item before the data communicator has fetched any items? It should be my problem if my backend cannot handle the query for outside the range, or then when I return null then this just returns null. I would presume that 1) if exact size is used and I request outside the current size, I get the exception because we know this 2) if unknown size is used, the query is done even if it is outside of the current estimate - what this method returns cannot depend on the active range or the estimate at that moment or whether or not the data provider has loaded any items yet, as the flush occurs later during the roundtrip.
int itemCount = model.getSize();
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
this is being called on a different flow now. is this intentional?
check if u can use 'getTaskIdList'
should be executeIgnoredModules
While the channel is question is a ForkChannel by default, it is not necessarily so. Thus the name of this class isn't quite appropriate.
Could you check for null or empty? Via StringUtils.isBlank
now that the expected value is updated, is the replace all still needed?
Are prepare commands with 0 modifications that common?
![MAJOR](<LINK_0> Method new appeng.core.features.registries.GrinderRecipeManager$CacheKey(ItemStack) appears to call the same method on the same object redundantly [![rule](<LINK_1>](<LINK_2>
rename to delta
Please stick to java naming conventions - variabls should not start with upper case. rpmsDeleted it should be.
We can possibly collate this with the following if statement?
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
Shouldn't have printStackTrace() in production code switch to logging.
These three lines can be made into one line - you're concatenating three string constants.
Why?
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
Why is this variable outside the try block?
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
add some message info
In which scenarios would a single plugin register multiple handlers for the same type?
Use already defined Constants
Wrap the exception
'e' is not logged
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
it can be inlined as done in other places: new ExternalNetworkManager(oldIface).deallocateIfExternal();
this method isn't needed, it can be replaced by a call to: getVmDeviceDao().clearDeviceAddress(getInterface().getId());
java list.sort(Comparator.comparingDouble(ForgeTimings::getAverageTimings).reversed());
space after =
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
yuk! a System.out! Either remove or use a slf4j logger here
Start with upper case: Segment ...
Remove this if block. We can move check for instance HasNewPresentation  into below if.
rename softCacheCreated to softCacheCreatedNs
I think we need to use the qualified name here, otherwise, you could have a class/struct with the same name but in another namespace and it would match. Here is an example where this is problematic: namespace FIRST { class Base { public: virtual ~Base() {} virtual void baseFunc(Base* ptr) const = 0; virtual void baseFunc2(Base* ptr) const = 0; }; } namespace SECOND { class X: public FIRST::Base { public: X(); virtual void baseFunc(Base* ptr) const {} }; } namespace THIRD { class X: public FIRST::Base { public: X(); virtual void baseFunc2(Base* ptr) const {} }; } In the outline view, if I select the class SECOND::X and do Override Methods, then it suggests to override baseFunc even thought it is already implemented. This is because this logic actually picked THIRD::X as the selected class (fClassNode, etc).
Before returning, we should stop monitoring the buffer with locationMap.remove(location);
Please replace all tabs with spaces and indent consistently.
"invalid entry name" should be sufficient. the "unexpected" is implied :)
You mean startsWith()? Also confusing if positioning, looks like an else if.
You can move this if statement into mintLog()
Remove throws Exception
Why 0,8 if all we are setting is 7?
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
Typo; Should be authentication in lower case.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
You need to pass the auth option along when doing the resolving, also consider the options in the call
result.substring(PERCENT.length()) would be simpler and more efficient. String#substring() avoids allocating a new char[] by sharing the one from the original string (it's not always a good idea, but in this case it's fine).
What's the value returned if the default value is an array? On the other hand, the check !(result instanceof NullNode) seems redundant, because a string value is only returned for SYObjectNode and SimpleTypeNode.
missing dot!
*decedent = descendant?
please make list of strings that will contain internal modules, please place this module in that new list
Can you please also make this block contribute the the dynamicRegistration map?
Should we remove clientAwakeTime attribute from PresenceStatus. Looking at this quickly, it seems this is not need anymore.
needed in the synchronized block?
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
We don't need to generate uuid when updating the Registry. Shall we remove it?
use entry set
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
does this actually work ?
Why not just: java for (String msg : msgs.toArray(new String[0]))  ? No need to make a new ArrayList. Just the array.
"passed" instead of "passes"
this class doesn't have tests?
Check if value is null.
check for isDestroyed().
We're checking event.error != null twice here - but we can actually drop this entire line, since event.isError() above is actually a event.error != null check.
No need to check shouldCommit, no need to end before commit (in JDK 11). Simply just call event.commit()
The cursor iteration block can use a try-catch-log-finally, so we can see errors if read fails.
Does this really throw a IOException given the try...catch below?
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
Use Assert.fail() instead
if it isn't too much change, lets get rid of SecurityServiceCallback
doc
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
What about giving a meaningful name to the thread and making it a daemon thread?
I marked this in #951 already.
maybe access it throw OneSignal.java? or add it to the method params? because there should be already a repository instance alive if we have more that one instance then te synchronized won't work
Rename the variable to agentStatusReport
given, when then please so this is clear what are you testing here
isn't this the same as if I would have imported the method from Either? @danieldietrich, what's the take on that, is this meant as a shortcut for only importing the API?
NIT: File has a constructor with two params for this kind of usage: java new File(j.jenkins.getRootDir(), "config.xml");  should be equivalent FWIW
Redundant with the next assertion
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
This should be fine on the previous line.
Could you explain the reason behind removing setDate(true)?
My point was to test the method public List<JSONActivity> getActivities(Date fromDate, Date toDate, Integer offset, Integer limit) throws MambuApiException from ActivitiesService, the one with only four parameters, because it is public and can be used by our partners. Indeed, behind the scenes it calls the overloaded method, sending two null values for mambuEntity and entityId, respectively, but we don't have a test for that in DemoTestActivitiesService.java.
use Map interface instead
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
why would we add all an empty list here? Just wrap it in an if.
final
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
We could just always use the body instead of flipping based on the payload size.
We should either use DataSize for these or add the appropriate unit in the log message.
I assume the 0xffff is to deal with the down casting from long to int and making sure that it's a valid positive value?
Technically I think you should use the get methods on info to access its variables.
This actually brings up an interesting question. If user wants to store the point with column lat, lng as double, is it possible to create an index for them?
Minor nit: this method can be private rather than public.
didnt understand why this needs to be copied to another ObjectNode. Can we get it directly from JsonNode?
Sorry for being picky - but this too can take in a status code (404 in this case as it is NOT_FOUND) instead of HttpFailureException.class, right? This will make the tests more accurate.
Do you want this to have 15 retries? Also think about multiple threads calling this method since this is called from 2 places already.
Your implementation here should call the clear(record) method above. Basically you want to do something like  public void clear(Collection<Long> records) { for(long record: records){ clear(record); } }
yuk! a System.out! Either remove or use a slf4j logger here
why an iterator ? it gives you the ability to do a foreach on visibleMarkers
Maybe could be more defensive: final boolean hadChildren = node != null && node.lastChild != null;, not sure let me know what do you think.
I would put the "magic number" into a static var.
I think that we can simplify this code slightly by taking advantage of this BlackboardArtifact method: BlackboardAttribute getAttribute(BlackboardAttribute.Type attributeType).
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Please move this logic here: <LINK_0>
can you add some docs around this method.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
See if you can simplify this.
lock user_point
userMembershipModel != null
Nit: missing blank.
I think this exception should be propagated?
Nit: unnecessary new line
suggestion .filter(AudienceRestrictionType.class::isInstance) .map(AudienceRestrictionType.class::cast)
If there is a rich-text change, then insertedLength or removedLength is non-zero already. You probably want to first map and then filter out plain-text changes where removed.equals(inserted).
Is this still true in the latest Ehcache version? Based on that error messages it sounded like we should be doing instead just: c.setEternal(true);
better Exception
minor: could be a function reference instead?
logging
redundant check (466), consider changing
Enums use == instead of equals
These is a most ugly way of work, you crated wrapper, passed all parameters and you are passing a list of canDoMessages all over a code in order to fill it. Such approach is wrong (I know that it is used at our code, but sometimes someone should do something smart), you should use return value.
You can use Version.v4_0 constant. Also, space between "if" and "(".
let's change the order in the ctor - its clearer when the source is before the dest :)
Dataset is AutoCloseable object, so after fit it would be great to close it to clear resources. Try-with-resources is preferable.
the steps 35, 36 and 38 are not neccesary
The steps 36, 37, 38 are not necessary, please check this.... you should omit this steps
Assert structure is Assert.assertEqual("actual","expected") please check this in of all your test cases
In your @Test, you can use @Test(expected=IllegalStateException.class) and _not_ do the try/catch within the method. This is cleaner and more appropriate :)
Need to 'put' in the cache, after the trace set has been updated - the put may result in the cached object being written to disk or distributed to remote node if we change the cache type.
Is it worth moving the reporting out of the synchronized block (though I wouldn't expect convention on that span)?
which exception are you avoiding?
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
I don's see a reason for this method, please move it's content into findProxyHost_ChooseByDCWhenNoClusterMatch()
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
NullTimeEvent should not need any properties...
Indent like this to improve readability.  populateAssignedLabels(state.getInitialLabels(), state.getRemovedLabels(), state.getAddedLabels(), state.getCurrentSuggestion());
return this ?
Why not natively subscribe with a subscriber that forwards to the action?
I don't feel it right that in a class delivered by our library we have a method not signalled with @Nullable that returns a null. Of course we don't have anything meaningful to return because it's a fake client... But checking the code I see that in one of the methods there is one SphereApiConfig with fake data. Maybe we can go on that line and provide a dummy config with a project key and API URL that leaves no doubt this is a fake config. Maybe @katmatt has a better idea?
instead of calling String.trim() multiple times here use map(), e.g.  Files.lines(p).map(String::trim).forEach(...)  You could also filter there too, e.g. .map(...).filter(s -> !s.isEmpty()).forEach()
This doesn't seem to ever be set to anything else?
Better to return empty collection rather than throw exception.
can be shortened URI ssoRevokeURI = ssoRevokeUrl != null ? SsoUtils.buildUrl(ssoRevokeUrl) : ssoToken != null ? soUtils.buildSsoRevokeUrl(url, ssoToken) : null;
move to start, no need to loop if tree is not checkable
yuk! a System.out! Either remove or use a slf4j logger here
nit: do you need AuthMethodPickerActivity.this or could it be just this?
Could this line also be called from the Utilities.setThemeToActivity() method? It's called exactly the same from all activities and sort of intuitively fits in with that method.
Hmm this seems a little strange to me. We call a getListener method and then observe a listener? I think what we want is something like an Observable<PasswordResetState> and the state can include properties like boolean success and String errorMessage. Also avoids passing down the Task and lets us encapsulate the error instanceof logic higher up.
Same as above here: use .isEmpty() rather than .equals for the empty checks.
@xpdavid is this the right thing to do?
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
This won't do anything since metacard is a mock.
Is there a reason why we wouldn't want to use the unique identifier here as well?
can we use the constant for "query"?
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:  MockBattleState.builder() .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))) .defendingUnit(givenUnit()) .defendingUnit(givenUnitIsAir()) .build();
Nitpicky - Even if a multi-line, I still think this would be cleaner as a ternary. I think with context, it seems easier, but I would suggest that maintaining/reading the code, it's easier to grok as a ternary. Perhaps the boolean can be extracted to a helper method to make it a simple tenary. WDYT?
Would you also add an IS_NULL filter here?
Since we're invalidating the entire dataset in the adapter (a few lines below), which will cause all the views to be redrawn, do we really need to do this here?
Add a message to checkState so that it's easier to debug if we ever hit it.
could we dedupe the code here? maybe it could be a method on the Pages model? pages.findPageForThread(ThreadTime threadTime) to hide this logic away
Can these be declared at class level and used for both methods?
Can you make these variables final and they can be used for both methods?
Don't forget to line wrap when breaking past 120 chars; there will always be exceptions (NB auto formatter dislikes breaking up a long diamond operator, and it has some weird rules around multi-param annotations), but in general we should be trying to wrap for readability.
A warn as well. I am not even sure we need the stacktrace here
just remove the fileSize from here... and that's the only change you will need.
suggestion Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
This method can be private
Can we point users to some kind of regex about how to specify these options, or what the valid values are? I don't entirely understand the format based on the docs and usage string here.
This is not how you make an [unordered list](<LINK_0> in HTML. Example:  html <ul> <li>Coffee</li> <li>Milk</li> </ul>  produces - Coffee - Milk
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
In the previous section this is a warning and the default password is used. Why is it different here? Also if the error is "SEVERE" we probably shouldn't just log it and continue on.
this should be able to reused. it can be a static field
Optional: more compact write possible Map<String,Object> map = new HashMap<>();
This isn't needed since we are in try-with-resources. This can go into the while loop
Usually we don't pass / accept nulls. Please either use Optional, or better just simply pass the TuppleDomain.all() predicate.
In my opinion, it is bad API design on hive metastore to have those methods that take partition names. All of them should really be taking partVals. But anyways, that ship sailed. When using this API, care needs to be taken. I don't think it's acceptable to make all these extra getTable calls. * Based on my brief reading, the pre-existing getPartitionStatistics don't need to turn partVals into partition names, it should do all the conversions the other way around. * For the new addPartitions and alterPartition, I'm thinking maybe the right way to approach this is to use include the partition column names in the thrift-API-side (as opposed to the extended-side) PartitionWithStatistics. Otherwise, all these calls are going to turn into a significant number of getTable calls.
You need to specify your "When"s before you actually invoke your service in order for the mocks to work, which begs the question as to whether or not this is doing what it should, and if it is needed.
Can we avoid sleep by using another latch. Applicable to all places
would be good if you match the expected values in here. I would recommend bringing some of the values you defined in init to here. Those are execution/parameter specific, init should generally be a setup only.
NPE for: <LINK_0>
I think lowercase l should also be considered
We should replace this by a switch w/ a default fallthrough throwing an invalidparameterexception or something like that.
I continue to think that **aifc** should to be here...
Can use the already defined Constants
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
Don't you think that set in a static field will be simpler?
No need to check for null in primitives.
| configured | condition | runtimesPerUserLimited | | ---------------|-------------|----------------------------------| | runtimes unlimited | -1 > 1 | false | | 1 limit for runtimes | 1 > 1 | false | | 2 limit for runtimes | 2 > 1 | true | | 100 limit for runtimes | 100 > 1 | true | ^ is it right? If yes - I suppose something like singleRuntimeAllowed would be better as well, as runtimesPerUser == 1 condition.
suggestion .thenCompose((ignore) -> registerTaskExecutor(tmResourceId, taskExecutorGateway))
Good idea. Will do.
sourceFactory -> dataGeneratorFactory ?
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
Is it possible to serialize a custom problem that has not been registered before?
is this not already tested in testCreatePoolAfterDestroy? or maybe it is better to create a separate test case for this: testMemoryUsageInTheContextOfMemoryPoolCreation?
again about redundant things - else block here and above is not needed,
unsafeSubscribe shouldn't call the ERROR_HANDLER.
"Initial connection"?
log me?
synchronized
synchronized
Wouldn't asString(...) be the way to convert to a String representation? Also I thought I saw this identical method implementation in another class, was it AbstractNumericProperty? Are we on Java 8 yet? Could interface default methods help reduce duplication? Sorry I don't have a robust mental visual of the interface and class hierarchies yet, so not quite sure if this is even a practical/useful suggestion.
This line is over 120 characters.
this is leaking tmpFile if an exception occurs
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
change to info and then add another log after message has been added LOG.info("queuedMessage size is now: {}", queuedMessages.size());
It will kill the thread and recreate one. I'd suggest instead to proceed with exit code as below except log the error of the exception too. Recreating the thread doesn't guarantee that the subsequent thread can recover from the previous error and potentially run into this in a loop of some sorts without any concrete action.
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
excluded. isExcluded is name for a getter.
I think it'd be better to throw an exception if the user sets isForceGuaranteedRollup=true but it can't be applied, otherwise it may be confusing if the task succeeds but they later notice that rollup was not "perfect"
Could you add a system property check for Linux? See line 448.
booleanValue() is unnecessary?
You have gone through all the trouble to get the style defined here. so you can now do addClassName(style.normalFlexTableCell());
char querySeparator = '?'; if (request.isRegistrationWorkflowOptionSpecified()) { href += querySeparator + "registrationWorkflowEnabled=" + request.isRegistrationWorkflowEnabled(); querySeparator = '&'; } if (request.isPasswordFormatSpecified()) { href += querySeparator + "passwordFormat=" + request.getPasswordFormat(); }
Do we really need to make it info level?
is it worth to add a Log.debug ? or warning?
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
Try using StringUtils.isTruthy(this.path)? <LINK_0>
Same here: should be Branding, not ProductBranding
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), charge.getExternalId());
Even though it will end up with Connector going to the database twice I think we should use the emitter process here instead of manually emitting -- it takes care of handling multiple events created for a given transition (refund availability etc.) and will keep up with changes to the PaSTEE code.
could we make the getStructuredKeys method you've added on ChargeEntity public and use it here to get the basic keys?
we're always calling cancel here instead of close() for the normal case.
please use try-with-resources, you could also use apache commons for the copy suggestion try (InputStream in = input == null ? new ByteArrayInputStream(new byte[0]) : input; OutputStream out = virtualFile.getOutputStream(this); ) { IOUtils.copy(in, out); }
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
after the loop, we should check that the iterator is done?
unnestChannelInputBlock -> newInputBlock
It looks like it does double counting. partitionBuffer[i].getInitialRetainedSizeInBytes() is already included here. Let's have only a single method, getRetainedSizeInBytes. Otherwise it is confusing and error prone.
See earlier question.
can you reference the enum values here?
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
We should write a real test cases for dropping connections.
braces not needed?
If it is possible, let's try to restructure this a bit so that it is a little more intuitive.
If the error happen that early, can you map the error in early phase before mapping page result?
Should it be fine to log PII information here?
nit: can replace lambda
Please replace empty string with a proper error message
Use DoubleStream?
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
just two ideas * could be pending null or it could not be? * I would, personally and if I don't miss some detail, consider more readable the lamda style like pending.removeIf(record -> record.forget())
I still don't understand why the key cannot be the session id
> public abstract class ExecutionStrategy { this super(); call doesn't need to be here
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
Inflight RPCs and max threads are (I think) completely disconnected from each other.
you don't need validator here. you already have the errors (getErrors()), just use it. and remove validator dependency. no more cyclic dependency ;)
nit: remove this extra line
I believe it will be nicer to just generate a String containing either an 'On instance of...' or 'Of class: ...' and add that to the message.
Thanks for letting know, I have no objections, just let me know when I should have a look again.
You're conflicting with #631 :-O Shall I go pull some PR's?
Can you please move this logic to a method to improve code readability? (minor note, fix indent)
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
I'm not 100% sure but I think this should be the other way around. feeds.size() seems to be the expected value. This problem is also present in other tests. Before, a failing test just showed something about a failed assertion. Now it shows actual value and expected value, so it is misleading if they are exchanged.
Let's avoid null and rework to empty string
remove as below logic didn't use mTransportMgr? also, I prefer use mTransportMgr.getAvailableTransport than mDcTracker as latter initialized once and not get updated if availabletransport changes.
This exception should be handled properly.
I would argue that we shouldn't compare names, but actual columns. I know this is not new in this PR, but I think it's bad anyway :-P
Move this if block after all if blocks.
It results in a list with not encoded elements
Please use joinParameters method.
I think this is dangerous, because it makes a resources that's not loaded yet accessible by other threads, that will try and use it with the assumption that it is fully loaded.
using java.util.Collections.singletonList() is a lot safer, because it's also immutable
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
- disabledBg Color variable should be created only when needed. i.e. after below condition is met: if (background != null) {
- disabledFg Color variable should be created only when needed. i.e. after below condition is met: if (foreground!= null) {
Second parameter of Status is the pluginId. Why to pass path here?
We still need to find a better way to do this. See my suggestion about throwing a more specific exception in load. Would that work?
Second parameter of Status is the pluginId. Why to pass path here?
typo on empty.
Don't use + string concatenation if you already have a StringBuilder! Do append("reference=").append(reference) instead.
Prefer ToStringStyle.SHORT_PREFIX_STYLE as it's much more compact
What about using something less specific here like Map?
new HashMap() looks unnecessary.
If response contains result (which it should contain) then you are creating new HashMap instance for no reason. Wouldn't following code be better: Map<String, List<String>> namespacesMap = (Map<String, List<String>>) SSOOAuthServiceUtils.getAvailableNamespaces( getSessionDataContainer().getSsoAccessToken(getParameters().getSessionId())).get("result); if (namespacesMap != null) { namespacesMap = (Map<String, List<String>>) response.get("result"); for (List<String> entry : namespacesMap.values()) { Collections.sort(entry); } } else { namespaceMap = new HashMap<>(); } setReturnValue(namespacesMap); Also if namespaceMap is read only, then even better would be to use Collections.emptyMap();
String.valueOf(...)? Or TBH, I'm pretty sure the compiler does this for you if you just inline everything like so: java return "PageKey{" + "StartAfter=" + mStartAfter.getId() + ", EndBefore=" + mEndBefore.getId() + '}';
There is no need to do check for null, right? I mean you could just write something like return "SslSession(alpn=" + alpn +...
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
Why do we use iterators? I know the base class does, but why in the first place?
Get it from the model now that we have one?
You could use a Multimap instead
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn.
const for 5 .. use here and on line 445
Why do we print a secret systemUserPassword here?
Why <=0
worth having some generic method for checking 'IMAGE || CINDER'.. maybe even in DiskStorageType? or isSnappableStorageType somewhere? :)
Can we move that check up to the start of executeInternal() ? E.g. we can obtain the configuration there and add it as an argument to this method. Its much clearer to skip execution early if needed.
Delete the if statement.
Likewise don't need the if statement since the optional value will return empty.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
I don't think this can return null. We should probably add an external annotation.
likewise: can make package-private to avoid a synthetic accessor
Get it from the model now that we have one?
I'd just pass e, so the stack trace also gets logged.
skipId
Why not just 'out.labels = labelsFor(cd);'? In Eclipse this gives a warning about dead code.
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check for the presence in the list of the low-level permission like WriteProperties which are the ones actually checked by code in AbstractSession.
Shouldn't we use filter instead of *
Let's do return fDetailedLoad; even if it is always null for now
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
Typically we use Map on the left hand side rather than HashMap
let's use LinkedHashMap
this can be moved to localize() method
extract to an init method - e.g. initEditors()
It would be nicer to extract it to an init method (e.g. initEditors())
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
The first argument can be random.
I think this should be replaceFailed = false instead.
AbstractSnomedRefSetImporter.createComponent(String) already initializes the UUID property (probably also applies to core components, not just the reference set members). It could be removed from all classes implementing applyRow.
This is usually "ONC-ACB" when displayed to the public, right?
Why are you putting the annotation on the same line as the method name. Normally all annotations are on their own line
just wondering why do we need to cast it to Symbol here?
- this.ephemeralCount = new HashMap<>();
Please use braces {} for this even if it's a one liner, to follow the project code style
Avoid adding more dependencies/additions to using Preconditions as we're moving away from Guava explicitly in several aspects. Also, needs an error message instead of just a random IllegalStateException.
Why remove this? The JDK does not optimize multiple reads of the same instance field (even if the field is final).
you can use containsKey()
"0"?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Anything we can assert here?
:-1: i18ntranslation /system/i18ntranslationv2 is not mapped to nothing
See if some of these updateFeedbackResponse methods can be private. I have a feeling you won't need them all to be public, at least now.
4 spaces
4 spaces
4 spaces
why this null check ?
You have a method immediately above this one named closeStream(). Either use that, or use a try-with-resources block.
I think we should show an error dialog
"Gerrit does not currently support generating diff output for this kind of change."
Actually I think 8k is too small here for est. size. It may force the ArrayList to grow slowly from 1 to 2 to 4 entries as the diff is built. Perhaps do: Math.min(32*1024, args.settings.maximumDiffSize) as the estimate?
Did you want to inform the user, like "An error occurred formatting the patch"?
no need to write "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
invokeAll on an empty list returns null. So you may want to handle that
how often is this method called? Why not cache this computation like you did the others?
should these be logged at error? Specifically I'm thinking about exceptions where one node is unreachable so the delegate could throw
why'd you change the content of the error message here? Seems like it doesn't make as much sense as what was there before
nit: remove this extra line
log and throw
Log the exception here. Also, FluxUtil has a method called monoError which logs and returns Mono.error().
Is it helpful to log the error as a warning? if understand correctly we assume the error is going to be an auth error, maybe log helps to debug if it ever fails due to some other reason.
allowing flight is different from the player flying, I think you meant capabilities.isFlying instead.
You should likely surround this logic with if (dataHolder instanceOf Entity) for future possible expansions.
Likewise here. Removing a PassengerData from an Entity should unmount the passenger.
you can simply use Predicates.notNull()
Please factor the DataSourcesSnapshot()'s argument out for better formatting
I don't know how segments == null is possible here, but if dataSourcesSnapshot is already non-null, probably this assignment should be skipped. The cause may be intermittent database unavailability or failure. This condition should be logged.
can it be package private?
I'd use getPathAsString instead of getName to provide unambiguous info.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Some JVMs can't do type sharpening e.g. on Android so it's a bit faster to write out ArrayList explicitly here. Not a big deal.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
Need a process.destroy() here before throwing the IOException, so the cleanup can happen.
A newline before the "while" statement?
don't we want to/can't we pass all the target specs specified during the import rather than one? Or we are doing it multiple times for one project (once. per target)?
We could avoid cloning here? (The message is not modified by the view?)
Certainly getCanonicalPath() provides clean path. but this method always returns absolute path. It may need to confirm the logic is no problem or not...
Let's remove log.error. We shouldn't log and throw which is an antipattern.
Don't do this. This is the same O(n^2) bug you are trying to fix here, just in a different kind of Block. Ditto for getRegionSizeInBytes implementation of this Block.
braces
I would add a batchSize parameter defaulted to 8 :)
remove "public"
You are expecting the test to throw a TableDiffException but catching an IndexOutOfBoundsException. I don't think this is quite right.
Can you use an anonymous name for the maintainer? Not something from production
Why do we need extra comma here?
This is not related to computed attributes in any way. Also, setting attributes would clear existing attributes, so I don't think it's correct. Also, I don't think using special keyword is a good idea. We need some different way of copying all attributes. For example, if copyAttributes is not specified it would mean copy app.
rename cmdResult to commandResult
Can we have some meaningful messages to accompany the tests please?
context.getEntityType().equals(EntityType.FEED.name()) should do.
again, calling .get() alone...
As before, I'd say this is an InvalidConfigurationException since the UnsupportedCommOperationException is thrown when the configuration of the port is invalid (serialPort.setSerialPortParams(baudRate, dataBits, stopBits, parity);). We need to add this exception it to the method header.
This will break for IPv6 addresses
- please remove TODO - please use propper logging instead of using printStackTrace()
do you want a fail() in here?
This code here makes me think that this really should be forwarded directly to a method on NodeDescriptor. Otherwise we'll be making a trip back here every time we need to add setAttributeAsText() support for any new type. This also entails adding a pair of methods to ChainedDescriptor (it's a pretty straightforward pattern over there).
Should be a SamzaException with a message, not NPE.
prev is never reset so If an escaped backslash is found subsequent unescaped won't be deleted: For instance pattern "a\\b\c" should match "a\bc" but won't because unescaped backslash removal will stop after encountering first escaped backslash
why hadoop's StringUtils.byteToHexString is not used ?
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
If this property is set, shouldn't the classpath have been updated before? I'm not sure why we need this code.
since "validCatalogEndpoints" is used repetitively, shall we add it to a constant field?
I don't think it should be renamed
Need to add the else clause which fetches the Hibernate-persisted Project and replaces its updateable values with the passed-in project.
This method has RequirePOST but no permission check.
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
Could you also test what happens when the data isn't Base64-url-safe-encoded, with labels, collision with an existing secret, etc?
just curious: why wrap this in a block if you use different names for the ContainerInfo instances and therefore there is no name collision?
Use ExpectedException here too perhaps.
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
What is the benefit of returning Optional values over simply not including them in the map. The only caller of this method just discards absent values.
Don't we have to say that this is uniqueId JDBC?
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
Looks much better!
why not initialize this in the constructor (and only set the herder in the Worker#start() via a setter method in connectorStatusMetricsGroup)?
No need for try-with-resources
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
my experience with redis, is that listing keys by pattern can take a long time. This could be a problem, since we don't want those operations to lock up the query side. Is there a way to issue asynchronous operations with jedis, or we might want to create a separate threadpool to queue up those operations.
ideally put operations would be done asynchronously so we don't have to wait for them to happen, but it's ok if jedis doesn't support that, we can always do it in asynchronous manner elsewhere in druid.
Each of these catches should use a logger statement.
You can merge this conditions with the other wildcard trees
You can probably stop at METHOD level as well. If you reach a CLASS or a METHOD, before an ASSIGNMENT or a VARIABLE, it can not be stored in a static final field. Now, you may also want to group the KINDs you target by category for consistency (CLASS and METHOD are failing stop conditions, ASSIGNMENT and VARIABLE allows you to investigate further)
I don't understand the purpose of this test. Shouldn't you assert that fileInput.globalVariables() has 1 symbol of kind CLASS with empty parents property?
Should we create the file always in home directory? Shouldnt we create under /home/ovirt-engine or somewhere else ?
better Boolean.parseBoolean(String s) cause it would handle null for you as well
why not entity?
Should look into having a ConnectionStringParser class in Azure Core, I've been seeing this functionality in a lot of places.
@essobedo once used variable can be inline
Why do we have different checks in these two tag methods ?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
It looks like a publish buffer, thats set to infinite during reconnect. I don't believe there's an analogous buffer in the other clients.
having a try catch and a warning for every statement has to be avoided. "defaultFetchSize" value must be validated beforehand, then just initialize fetchSize to defaultFetchSize. Best seems to be in DefaultOptions.optionCoherenceValidation or something like that.
minor: you can return Collections.emptyList() instead
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
nit, Collections.EMPTY_MAP?
Let's avoid null and rework to empty string
There should be a white space before else Also you could use word.charAt(i) in both the if and else statements (e.g. word.charAt(i) == 'y') instead of using substring, that might make it a bit more obvious what you're doing
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
< 0 doesn't seem like a great overflow check, maybe be more explicit?
why warn here always?
BufferUtils.byteToInt?
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
the default should be made a constant somewhere instead of being defined in multiple places
Space after comma.
nit: remove this.
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
Those looked like good tests? Why remove them? Hash collision?
This is missing maxTotalRows
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
we never use NULL, it is a bad practice in general.
Do we want to have null maps here? Can't we follow the same pattern and default to empty ones?
If you make the EMPTY_EXPIRES, you could use it here.
This sounds pretty dev-like. Let's either make this an email address, or turn it into something like When defined: >Hi First Last! When undefined: >Hi! Should be easy to implement and avoids the awkward "Hi User"
I guess _getDataSetQueryHelper_ is duplicated here?
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Update labels to go with method names. Alternately, call super.toString for super attributes
This should probably be removed
Same error issue. I'd just fail rather than return a partial list.
String.format?
You cannot use Java7 feature otherwise the build fails. I think it's the same for GWT source code, isn't it ?
use Java8 stream anyMatch() instead of this loop.
They are mutually exclusive? Or is that a micro optimization?
new HashSet<> is not needed; oldAssignmentNames is only used for exclusion from a set, let alone the returned assignments are always unique anyways (read straight from ZooKeeper). oldAssignmentNames  can be a List<String or even Collection<String>.
could make use of java8's stream.map.collect thing
- spell out colStatsMap - null assignment is useless
No need for the null checks, primitive types cannot be nulls.
That should be toHtmlForAnthology. You mixed those two up.
This change is still incorrect
Any possibility of the module string being group:artifact:extension:classifier:version or group:artifact:extension:version? i.e., do we require custom modules to adhere to the 'exec' convention?
What does this do? The result is passed directly into Datasets.load above so it should produce a dataset or view URI. But it appears to check if the URI is absolute (assuming that it has a scheme) and remove the beginning '/' if so?
I would explicitly write throws NumberFormatException here.
I think most of the callers of normalize() convert the String you return to a BytesRef. So maybe it would be better to drop the extra utf8ToString() call and make this method return a BytesRef directly?
Why not in combination with above do this: setValue(value, false);
null and empty API key should throw
Worth to check but don't we support slashes in namespace? If so this would probably break with double slash if zk barks of it.
Same error issue. I'd just fail rather than return a partial list.
In my opinion, we do not need this log. WDYT?
prev is never reset so If an escaped backslash is found subsequent unescaped won't be deleted: For instance pattern "a\\b\c" should match "a\bc" but won't because unescaped backslash removal will stop after encountering first escaped backslash
I would prefer some brackets around the logic elements for readability
The name is now no longer accurate. Maybe don't replace the line delimiters inside this method.
@szczepiq What is tested here? I can't see an assertion.
Nit: Let's have this method private unless someone asks for it.
a better test would be to get actual after calling havinCause() and check that it is the same as throwable variable. actual is protected in AbstractAssert so it is accessible since the test class is in the same package
;
Do you have an opinion either way about (in the future, not now, let's just get this done already) rewriting this and any similar lines to Optional.ofNullable(property).map(prop -> new TypedValue(prop.getQualifiedType(), prop.get(obj)))?
Well, it'll work but, as I understand, it will hide an error if there is. I think the issue is in other place. Agree?
Let's move this line with the FBO-related state change. Just double-check if it needs to be before/after setupConditions();
I don't think clearing operations are state changes. It's more of a degenerate type of rendering: you fill the buffer(s) with one color rather than a pretty picture. So, I'd leave clearing statements within the Node.process() methods and eventually verify if they are actually useful. I feel that some are unnecessary rather than redundant.
Move up please.
i don't know if this is something we want to do here, but it would be good to log the network id and the boolean too. then we will know if a particular network is enabled, who is to blame.. or after one is disabled, why the rest are also disabled.
and the param?
log the param too so we know if it is on or off?
Probably should use combineDegree - 1 instead of hard-coded 1 here?
Last trivial thing, just return this value directly.
@pynicolas Are you sure about this method name? As I understand, it does the opposite
Null-check
getLong?
Null-check
Why would we want to silently fail here? Why not throw an exception on any update operations to tombstoned relation metadata?
lang is already a FunctionLanguage number why do you need to check for MyriaConstants.FunctionLanguage.values()[lang],null)?
Where do we delete the corresponding entries from the relation_schema table?
throw new VerifyException()
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
I think lowercase l should also be considered
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
Symmetry (throw)?
remove line
I think that this method deserves to be protected and tested.
Neat but violates coding style. Could you use the standard brace style. We use the standard android [coding style guide](<LINK_0>
move else if next to closing brackets.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
This device seems unused. Can it be removed?
1. you compare with vmDevice in the command. 2. please also use assert to check the return value shouldUpdateReadOnly(). thanks!
Any specific reason to throw an NPE here ? if yes, it should be added to the method signature
Could you add some spaces, please? I recommend to use the auto formatting in Eclipse.
In general, we should probably be moving away from client-side validation where possible.
List instead of ArrayList maybe?
I'm not 100% sure but I think this should be the other way around. feeds.size() seems to be the expected value. This problem is also present in other tests. Before, a failing test just showed something about a failed assertion. Now it shows actual value and expected value, so it is misleading if they are exchanged.
We normally add the static import when using matchers.
You would need to error out or S3 service to error out, not to delete with Set()
you could use executeGet()
This should be done in execute()
What is the use case for calling findFirst() here? I understand the motivation for its use below for the embargo.
Is this actually a statistic?
Do we need to test explicitly that the role is valid and not a patron, or does null get returned in those cases?
Should this throw? It seems like a serious error if there is no info for the table and any further processing can only compound the issues.
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
The property name does not match the one in SystemEnvironment, may be you could use SystemEnvironment.GO_WEBSOCKET_MAX_MESSAGE_SIZE.propertyName()
Although Java allows this, It will really help code readability and future refactoring if we need, if you could avoid accessing these internal variables outside.
When you changed the code to also provide the old API, you should be able to revert these changes.
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
Why did we switch out the old code back to this?
In BlockWriteHandler#createRequestContext() it looks like it calls mWorker.createBlockRemote, but in this method it can also call mWorker.createBlockRemote. Will that be a problem? Instead, should we just initialize the counters correctly in this method?
assertThat( query ).assertThat( query ) ?
assertThat( query ).assertThat( query ) ?
assertThat( query ).assertThat( query ) ?
Let's wait for the logging changes to be merged, and fix this one accordingly?
Since split returns an array, it shouldn't be necessary to manually assign elements? Just assign the whole array since it will always have length 2 here? java splitArray = layerName.split(":", 2);
Fedora uses 4 levels of hashed containers for identifiers, does it just use 3 for file storage?
move a line below so you can use append
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Please only log at debug or trace
This can be wrapped into another function for clarity purposes.
Do we need this catch block at all? I think exceptions are handled up the stack anyway.
Extract this try-catch block to a method to avoid code duplication
no need to handle failure (rollback, log, etc..)?
This sounds as though we have a technical debt here. How about "isn't required for file based domains"?
this should be called only in endWithFailure()
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
This is not the proper solution and there are many other characters which this would not solve for. Proper changes are needed in com.twilio.http.Request.buildURL()
might be removed?
You should handle the exception here, report the error and report the whole process as failed.
you could have merged the expression of this if with the previous one.
same here as well - on failure to stop vdo service, activate and move host to original status
should be private. Also, move it below the executeQueryCommand() - it's not the "public contract"
those 2 lines can be united
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists.
@cvrebert don't we need to stop the container in finally block? What if some method will produce unexpected exception?
let's stop container in finally block to be sure
I test fails than container will remain started and port is busy. So, good practice is to enclose tested code in try block and stop container in finally
Typically we use Map on the left hand side rather than HashMap
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
It's wired the method getXXXList does not return a list but a set instead.
Add this logic into the certificatemanagerserviceImpl class.
Why do we need this method?
why do we need this method
please log in error
new CommandContext().setExecutionContext()
but actually, the success here is kinda misleading, right? because a true success is if host gets to Up. So we will return to vdsNotResponding, if the ssh soft restart did not bring host to up, right? Can you elaborate with these code changes, how eventually the host will be fenced?
Use an interface instead of a concrete class. Same below. Space is missing before "else".
Use IASTUnaryExpression instead of CASTUnaryExpression.
The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.
Is the order for entrySet guaranteed to be the same every time its called? I know it will for HashMaps, but I'm not sure about other Map implementations.
any reason we can't use an empty list for the sentinel?
If values is a set, I think you could determine hasNull beforehand if you've already scanned values for empty/nulls, and avoid scanning again
Can this be made private?
IIRC, I use rawQuery with the same result like yours. Please check rawQuery API to simplify this function call...
Same as above; Consider using getClass().getSimpleName() instead of this
I think the old code (using default on the switch) is better.
ExtensionNamespaces.LBAAS to be consistent with the alias name.
I'd recommend < 0
Missing final
Missing final
Missing final
I think we should externalize the mapping (reading/writing) of the data into one of Spring's strategies. Then user's can inject their own strategies.
This can use MarketoUtils.ISO_8601_FORMAT
can you add some docs around this method.
Set this only if session details not null??
Apply default formatter
Use LinkedHashSet instead of ArrayList.
Suppose there are two interfaces:  public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { }  so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
let's just remove this function
here too we could use getClass().getSimpleName()
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Format, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
There's no need to do the additional (String[]) cast here, T[] toArray(T[]) is generic in T.
Can just call vec.toArray() I think
Can we also have a test for LUCENE -> NATIVE -> LUCENE
Strictly speaking no lines of code should occur after db.begin until the try starts.
this can be not enough on latest 3.3 version
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
Tests are expected to run quickly so don't use Thread.sleep(...). Signal a mutex to let the UI thread know this thread has reached this point and then block this thread on a mutex which you signal from the UI thread when you're ready for this thread to continue.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
this and m_ is redundant
No need for this.
You can remove this call and also remove the public default constructor: it's not used.
common format
Can we log the debug message in one line? Those multiline messages could be interleaved with multiple processes.
Looks like epoch and reset logic should be pushed to pool as generic solution. Isn't it ?
If instead throwing an exception when policyParameters[3] == null you log the error. I think it will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
Also, a test with an aligned with original OA to test the default overwrite will be nice here. Also with unmapped reads with OA tag because the current code won't overwrite them (and I guess it should).
final
It is probably worth noting that in order for this to match the service name needs to be set in server.xml:  xml <Service name="Catalina">  It would be nice if we could auto-detect the set of tomcat services that are available in jmx as users picking a different name has bitten us many times. Unfortunately, because of the way it is modeled I think this would require a full scan of jmx and then looking for something with the right sub-properties on the ObjectName.
suggestion if (throwable == null) { _rewrittenQueryConsumer.accept(query); }
You can use mapToLong here and then sum()
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
asserts are more or less useless, they are only enabled if you compile your program with -ea, which almost nobody does. Instead you should do an if check and log the error and/or throw the exception. Applies to other place below too.
Maybe use THREAD_0_SEPARATOR instead of a literal "_"?
use arrays.copy? or system.copy?
Looks like even the brackets around i == j is not useful?
This method sums over the second and third dimension.
Could we simplify the 2 lines above as if (FileKey.resolve(gitDirOf(name), fs) != null) {
This case is not so uncommon. I reported it because developers do mistakes in all weird ways. And this type of mistake causes confusion. If you push to plain git repo then you will get an error. Gerrit should do the same. Throw an error. So please don't give up :)
dir.getName() returns just the last segment of the path, since project names can be hierarchical (e.g. a/b/foo) I think this is not enough. We should rather include the full (encoded) project name into the file name.
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
I think lowercase l should also be considered
throw new VerifyException()
"expection" -> "exception"
this should probably fail on receiving interrupt
Do we need two debug logs here?
@Sami32 You removed result.append(", Sample Frequency: ").append(getSampleFrequency()).append(" Hz"); - I disagree. Remember that even though you already have the sample frequency from DLNAMediaAudio they are separate values and one can be used one place and another another place. We should see both values when debugging, if they are different that would be a bug.
I don't think these are mutually exclusive. The manual shows them here: <LINK_0>
This is generated code, please remove this or adjust the EMF code generator.
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}. (and so on)
*was created ;p
another log format? maybe make it compatible with existing? (or change existing)
Just do getAndSet(null). Then shutdown the returned value.
include isShutdown here in the log?
Just making sure: this line automatically cancels the scheduled runnable in _scheduledRefreshFuture right? If the refresh period is right after this line and before the next line, it's okay?
I think here you can do something like steps.stream().findFirst().orElse(null); If findActions receives null, return a Collections.emptyList();
you can use a stream here, such as:  return allFolder.stream().filter (folder -> permissionAPI.doesUserHavePermission(folder, PermissionAPI.PERMISSION_READ, user, respectFrontEndPermissions)).collect(CollectionsUtils.toImmutableList());
Immutable
Same nesting questions
I want a "nest" emoji; can't find one...
I'm confused. Assuming this is a "non-pending" reviewer, then if the TT is !null and retired, we give a warning; great. When would we give an error? If it's null? Are TTs required? If that's the case, then the error message with the name "testToolNotFoundAndRemoved" is either the wrong message or named badly. If this _is_ a pending reviewer, then we're still not removing TTs; we should just give them an error and make them remove it themselves, which also doesn't match the error name
allMatch returns true for empty stream, so separate test for emptiness is not necessary
Please inline the variable numberOfArguments (which is not used elsewhere), remove the finalmodifier (we internally don't use them in such context), and use type ProgramState.Pop instead of Pop (in order to avoid import of type Pop, and simplify understanding of the context). I would also prefer a variable name close from what it represents, like unstack, which is the name used everywhere in this class.
this.fileStates.remove(absolutePath); is correct.
I think more readable would be something like  assertThat(correlationId).matches("my-project/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
should check results here, not just size
java final List<String> jobIds = new ArrayList<>();
This piece of code to create an Authenticator is duplicated 4 times, but it's not relevant to the test. Can we make the test cases shorter so that we can see easily the differences between them?
Are the offsets needed for the test ?
Should we assert a string valued parameter too?
I would throw instead of just logging it.
String is an object, so for String comparison please use: language.equals("ja")
be backwards compatible
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
wrong logic a poolId should be retrieved from domain of disk and not passed by params, also a provided vm can be at wrong pool
please extract to a separate method
can you change this impl to be addJobProperties(job.getConfiguration()) ?
Use map.forEach
inconsistent curly brace placement. Lets move them to end-of-line like all the others.
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
Please add the else if clause for the DELETE action that is in the DeleteTask, for completeness.
This line is redundant.
that class would be better with a builder, though I wouldn't ask changing it now
Why 0,8 if all we are setting is 7?
My checkstyle is exploding with "magic numbers" here. You could easily use the constants from the Items themselves here I think. And if not, please make these numbers constant fields in the test. <review,testing,logic
You could define these inside the try block, since they aren't used outside of it, but it doesn't really matter.
You can use ValidationUtils.nonNull for this.
use multi-catch ?
Why do you want to ignore these exceptions? I don't think we should be acting on the exception's message like this, since the message can change later on.
better use WorkspaceJob to prevent refresh is triggered prematurely (see commit 786698088)
this isn't needed anymore after the logging changes made to the app, can just use the normal logger from LoggerFactory.getLogger(ScriptTransform.class)
ObjectMapper constructor does not throw any exceptions so creation can be moved to filed definition.
Please only log at debug or trace
NIT better to use Collections.emptyList() to avoid new objects
instanceof is null check itself.
I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
You can collapse this block to just:  java average[i] += (rubricChoiceWeight == null ? ... : ...) * ...;
So this is gathering the bitmap by invoking the BinaryOperatorTransformFunction?
This is potential performance killer, but I don't have better idea how to address this. So I assume we need to live with that. Fortunately there will be thousands of groups at most (not millions) and it is just about admin requests, so hopefully it is ok. IMO in general, it is probably better to have pagination approach, which doesn't require counts. Something, which always returns the token for next page? Although this approach also has limitations (EG. it is not easily possible to move to the exact page like "Go directly to page 50" etc), and there are probably other limitations. But maybe something to consider in the design of new REST API (CC @pedroigor ). Sorry for hijack the PR :)
This doesn't set account to null in case the condition isn't met.
no assertion on new param itself?
instanceof has some performance concern when you are using jre6(jre7 maybe)
final, Lists.newArrayList(), etc
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
This is where the if statement should be for checking the property for allowing for corrected times.
Same here, why public?
Why is this public?
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Please include clientTelemetryEnabled in toString() API
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
Use the whole path IPv4.Availability.PUBLIC
Use the whole path IPv6.Availability.PUBLIC
encodings ?
> return true if the listener wants to override the default behavior of clearing the text field and dismissing it, false otherwise. I think this should be true since we're handling it? You may also want to clear the listener here and in onDestroyActionMode() when searchView is nonnull.
Please move listener to desired mode
This is the line of code from the else branch. Since the version is above honeycomb you should use findPatientView = (SearchView) mFindPatientMenuItem.getActionView(); from the if branch.
Oh yuck. ;)
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
You might want to not over-complicate it and keep the toString of the Optional perhaps?
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel() will not call cancelling() and the refresh won't happen.
This will always be true right now, you'd have to setNofityRequestNeeded(false) also in buildManually of the history builder. I'm not sure what this adds, it's one more call the module developer will have to make, just to avoid calling this twice.
should it return an IStatus like buildStateSystem() to inform the user in case the analysis wasn't successful? Also module.execute also returns a status and should be forwarded to the caller of executeAnalysis.
Change this to == and I'll merge it.
The default should be updated to return 8 parameters to the test
Item dropped should be a hopper
add java doc explaining the packageName is used for finding the package and if it is not found it is created. method name should be reflect this. Maybe this should be split up into separate fucntions
rewrite use '?' and split out id var
Why is this needed , this seems like a side effect , i would suggest splitting it of to a separate method/service if needed at all.
Why do we want to assert here?
this seems safe enough...TBH could not find the path that can trigger this code ...happy to learn in case you want to share, thanks
Since it's present in all configurations, consider moving this object creation to the top of the method to occur unconditionally.
you need to first trim input otherwise this doesn't match if input starts with whitespace
Why not just use the primitive types? suggestion breakdown.getOrDefault(weight, 0) + 1);
Use switch instead (and add sanity check along the way).
if (
The code in this test is identical to the one above except for one line -- can you have both tests call into a shared method for most of the work?
use try-with-resources to avoid the need for explicit close
What about caching the list? AFAIK this method will be called multiple times on the same connection.
are we guaranteed that this mapping is the only thing stored in the metadatastore?
This can be a bit cleaner with Java8 streams: return getPluginProviderRegistry().entrySet().stream().collect( Collectors.toMap( Entry::getKey, e -> e.getValue().createLocalFileIngestPlugin(e.getValue().createOptionsInstances())));
Comparing the classes of both objects here make the instanceof call obsolete. You either go for getClass() or instanceof considering both having slightly different semantics but both having the same outcome if getClass().equals(obj.getClass()) applies. I did some further research in that matter: I haven't found any evidence that JobManagerProcessSpec and TaskManagerProcessSpec are ever used in the same context. This makes the case of equals being non-symmetric when dealing with subclasses kind of theoretical. But if you want to reduce the risk of this coming up later on I see two possible approaches: 1. Check the equality of both instance's classes (Keep in mind to add a null check for obj in that case). 2. You move the equals(Object) implementation into JobProcessMemorySpec and make it final. In that case, you can keep using instanceof.
Unless a good reason for this, the following is considered more correct:  java if (getClass() != obj.getClass()) { return false; }
buf may be null here because we discard it in toObject. We should be more aggressive about converting from buf to object format. T thisObject = toObject(this, this.codec, other.codec); T otherObject = toObject(other, this.codec, other.codec); if (thisObject != null && otherObject != null) { return thisObject.equals(otherObject); } else if (this.buf != null && other.buf != null) { return Arrays.equals(this.buf, other.buf); } else { return false; } private <T> static Object toObject(SerializableProtobuf<T> sp, ProtobufCodec<T> codec1, ProtobufCodec<T> codec2) { if (sp.object != null) { return sp.object; } ProtobufCodec<T> codec = codec1 != null ? codec1 : codec2; if (codec != null) { sp.object = codec.decode(sp.buf); sp.buf = null; return sp.object; } else { return null; } }
This should be indented and/or parenthesis around the body of the for loop. Also the pair should be appended not concatenated to a string and then appended. builder.append("CompleteTransactionTasks: ").append(pair); The output of this will be a bit strange because there are no separators between the different completion strings. Maybe append a comma and space or something between the task strings.
nit: might want to change this message to "Exception StackTrace:"
return builder.toString();
Try to call propagateFailure(returnValue) instead
the return statement is redundant here.
Shouldn't the bricks be from the parameters class?
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
Let's use Builder.put calls instead to reuse the validation. Even if the validation code is expanded with some more sophisticated checks, we'll always be okay.
Fine with me (although it does slightly detract from the opt-out possibility). WDYT about adding a retry backoff though? I'm a bit concerned we might just end up stuck in a loop of useless rebalancing, and waiting the full probing.rebalance.interval doesn't feel right either
Seeing this essentially duplicates the load code above, I feel there must be a more elegant solution to this - something that just retriggers loading of all the existing observable's data...
Shouldn't we use empty list here ?
Can you change this to: return new AuthenticationResult(user, authorizerName, name, null); It's not an error you introduced in this PR, but using "name" for the authorizerName parameter there is a bug
this is a good initiative. why are you checking the start time, it could be a valid use case to say everything after Marc-Andre's birthday. So start time = [removed] and end time = eternity
'coordinate' is a single word. Also calling toString from a constructor could lead to unexpected information being displayed, because the object might be partially constructed at that point. It would be preferable to show the negative coordinate instead.
Indent like this to improve readability.  populateAssignedLabels(state.getInitialLabels(), state.getRemovedLabels(), state.getAddedLabels(), state.getCurrentSuggestion());
what is the reason of this change ? I think you should revert to "this" instead of null
The base class TmfChartView already sets the trace in its createPartControl(). - If TmfTimeViewer handles TmfTraceSelectedSignal signal, shouldn't it initialize its trace itself? - If TmfChartView initializes its trace, shouldn't it handle TmfTraceSelectedSignal by itself? - After TmfChartView has set its initial trace, it never gets changed even when a new trace is selected. But it doesn't seem to matter because the viewers handle the trace change themselves.
I think reference assignment is atomic so this change and some other below don't make any difference.
This is apparently out of date.
I think that this method deserves to be protected and tested.
Neat but violates coding style. Could you use the standard brace style. We use the standard android [coding style guide](<LINK_0>
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Wrong wrap?
Shouldn't we remove the Realm and its management files?
Local variable could be declared List instead of ArrayList. Is this worth caching?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Why is it a list of lists, not just a list?
after saving can you broadcast, so as all other users on same note gets this save update ?
Don't we have to say that this is uniqueId JDBC?
LOG.error("Error in runAllParagraphs()", e);
necessary?
necessary?
studentsWhoRespond -> studentsWhoResponded
What are these annotations ?
These are not the node metrics
might want to also validate that metricName doesn't contain the DELIMITER, so we don't mess up when parsing out the tags
This cannot be removed. The scheduled task needs to be saved.
change
Do we have to check this as well? if (IFuture.CURRENT.get().isCancelled()) { return; }
Let's log this error as a warning, instead of as verbose
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
Please log the content's Identifier and relationship name too.
Logging.
fair enough
.forEach(intervals::add) avoids materializing extra list
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
Similar issue with the ZkWorker objects themselves; maybe it'd be cool to have an ImmutableZkWorker like the coordinator uses for druid servers to get around that.
notification? i think that makes it more clear what is happening than notice
@Suseika how about to check PsAll.enter() returns Identity from 3-rd Pass?
you don't want to check that images are legal and exist?
casting to Integer is redundant. IDE shows warning
minor: no need for final?
Shouldn't this be new RegexStringComparator(rowPrefix + con)?
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
This causes a reverse DNS lookup - definitely what we do *not* want.
Not sure how just the host, especially if extracted from a URL object, could have a trailing slash.
What is the motivation for checking the pool here _and_ inside the query method?
"belonging" -> "which belong"
"belonging" -> "which belong"
"belonging" -> "which belong"
Include the maximum page? "Page %s is greater than %s."?
Would it be better to hold this a member variable or maybe even break it out and put the resonsbility on the client?
(minor) I would test the positive condition isEmpty() and swap the cases. It is less information for the human brain to process and ! can be overseen
also assert the cause attributes
I don't imagine these KVTable tests require a validator. Should remove if not needed.
There is a constructor that just takes the input schema right? If so, just use that one.
The return type is a bit hard to use; Could we provide a higher-level API like DataSet instead?
nit: add static import? (similar elsewhere)
Should we add: Objects.requireNonNull(record)?
context.getEntityType().equals(EntityType.FEED.name()) should do.
again, calling .get() alone...
Why did we switch out the old code back to this?
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
My checkstyle is exploding with "magic numbers" here. You could easily use the constants from the Items themselves here I think. And if not, please make these numbers constant fields in the test. <review,testing,logic
Why is .name() necessary? Can just compare the enum?
Are you sure that you should add this file, too?
Origin is never checked, also the original ticket talks about implementing the CORS preflight which is used by SPA frameworks like angular, where they do an OPTIONS request in that case the request should not continue the filter chain since it only needs to respond with the CORS headers.
I am not sure if 503 is correct it this case. It indicates that something is wrong with server. In my opinion 403 will be better.
sounds nice! so users are not overwhelmed with hints. Shall we also add a change log entry for both this and schema hints?
Better to return the found dir instead of initialising the field so this method becomes independent of the class. It might become a method elsewhere or a static method that accepts a Config (from MPConfig) returning the dir which then can be passed as constructor argument to initialise this class. This allows to use this class with directory coming from MP config or any other source. Normally testing would be another candidate that then uses this parameter. You could think about moving the watcher part out of the constructor into a method that is called after constructing the instance passing in the executor service. java void updateUsingFileWatcher(PayaraExecutorService executorService) { //... executorService.submit(new DirPropertyWatcher(this.directory)); //... }  This would allow to not trigger this in tests while you use it when creating the list of config sources.
Did you check if here is any chance to share code with the warning generation?
HQL/JP-QL
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Detail: FROM capitalized.
{} for blocks
this should be tableViewerFactory
This is a weird place to add a listener.
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
This magic number needs to be a named constant somewhere.
To avoid busy-waiting, It would be possible to pass a CountDownLatch here, and replace getBroadcastCount() to a method that counts down. How does it sound?
what if the acl is not found? we should skip metadata update in this case and return false?
should we return false if no such acl is found?
Logging involves disk IO. It should be done outside the lock.
Message should probably be sent before actually unloading chunks. :)
it should be  java if (TFM_AdminList.isSuperAdmin(player.getName()))  Correct me if i am wrong
I might be nitpicking here, but could you lowercase that last 'W'?
Why do we need an explicit boolean primitive? .... using i.getRepeatable() does the trick
I'm worried this is fragile; now every time somebody adds/modifies/deletes a sourcefile, they have to know to call this method. But "every time" is currently only 2 places (unless you missed any :) ), so maybe it's not worth overthinking this.
inline getVariable
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
"this." is not necessary.
DANGER WILL ROBINSON, DANGER! Is the password really passed as an URL parameter? Any proxy on the way could record your password. Please check whether the API allows the password to be passed at least as a POST attribute...
Please remove the protected keyword because this class will never be subclassed.
suggestion Pattern argPattern = Pattern.compile("^\\$(?:\\{(.*)\\}|(.*))$");  Align with start and end of the string. Otherwise you would also match bla$ad or ${foo}bar
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
the default shouldn't be hardcoded.
The question for me: is this xml configurable or should it be the part of the interface? I personally prefer to use interface and ask the object, which might have some dynamics regarding whether it needs UI or not.
final
This branch can be simplified: java final String[] split = ListSplitter.split("\"", true, removeBrackets(value)); for (String val : split) { result.add(val.trim()); }  or shortened java Arrays.stream(ListSplitter.split("\"", true, removeBrackets(value))) .forEach(enumItem -> result.add(enumItem.trim()));
Whenever you're doing (last)IndexOf(String) with just one character String, you should replace it with overloaded version (last)IndexOf(Char), which is faster. 3 occurrences in this PR.
I'd go for: return ImmutableList.of("node", "show", "-l", nodeName, "--format", "json")
Why do you need this cast? Is it because ScreenLoadCallback implements both interfaces and its picking the wrong return type for the old style RPC call? If that is the issue maybe add a 3rd method addOldCallback() that calls the old type add() version so the compiler can't guess wrong for a ScreenLoadCallback?
why did you put this in a local variable? Why not just inline?
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
is there a reason for StringBuffer instead of StringBuilder?
optional: use buffer.append(msg).append(key).append("...")
Reuse result of StringBuffer.append instead of using buffer local variable.
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
Suggest to move the 2nd param to a class variable since I see that the other tests are using the same one with the same value.
Suggest to move the 2nd param to a class variable since I see that the other tests are using the same one with the same value.
this setter is no longer relevant, recompile the project so will be generated new setters/getters according to schema change
This is a status field. It should not be mapped from REST-API to Backend. The way that the user changes this status is by running activate/deactivate action. So please remove this mapping. The mapping in the other direction is ok (REST-API should show the status, so the status should be mapped from Backend --> REST)
potential NPE on .getNetwork().getName(), you have also to check if network is set before using it
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
I see, that's the reason why getBuildContext() is in the AbstractDockerMojo. However, I'm not sure if we would better move checkImageWithAutoPull() out of the BuildService. Doesn't sound very "build-y" and there is probably a better place for it, so that the StartMojo and the BuildMojo could both use it ?
this could go to previous line: "hub.mosaicSliderGetCurrentLargeImageDescription();"
can we please avoid copy & pasting the test ? Just extract a common method which is called once with "docker" and once with "registry" from each individual test. Helpful would be also a test that ensures that "docker" has precedence over "registry" to keep the default behaviour.
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
I would dump this iterable into a variable just for clarity. It looks more than a tad clunky in-lined...
I think you meant to use gtkVersion here, otherwise you would have just continued the previous if-block?
Bad variable name! Variable names should be clear enough. Rename it.
Would you mind improving this test to use executeFile() instead of executeString()?
suggestion "} else {\n\n" +
i'd prefer to read xml from xml file so you'd have proper IDE support for that
System.out.println("...... and path id (optional).......
return -- no needed
VoiceCallFlow has to be imported, no need NotFoundException import
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
I think we should use expireAfterWrite instead of expireAfterAccess here to ensure that we don't cache these objects for any longer than the configured time - the node details may change.
I guess that we should not change the behavior of the method. Because Config class is widely used within the project and it may be also used in users side. (Users can create their customized DigdagServer by using DigdagEmbed class) I hope fixing in bq_load operator or adding another method to Config class like getOptionalFromNullable().
This could use some refactoring too.
You should just negate it and include this in the if-statement above.
Enums must always be compared using ==, not .equals()
it would fit easily one line
Please add {...} here and below.
Sorry, but you cannot do this :-( The formatting is in accordance with <LINK_0> which states although not a formal standard it commonly used.
I believe it will be nicer to just generate a String containing either an 'On instance of...' or 'Of class: ...' and add that to the message.
this should go after the entrypoint, so that the metrics are incremented and FS open/closed state are checked
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
LOG.error by default prints in a newline (So no necessity to add one at the beginning of message). Please change it at other places as well.
If we delete the table when checkpointManager.stop is called, then does this mean that the persisted checkpoint data is lost? We want checkpoint data to persist even after the job is stopped, because during a restart we want to load from our previous checkpoint.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
Not sure if there is any chance that a trigger has no context or context=null. In that case, this will throw a NPE. wdyt?
what's wrong with the original condition? IMHO you shouldn't assign a value to the timeout parameter ...
nit: what about java nulls[i] = i % 7 == 0  ?
Do we need to check Null of the input parameters?
Maybe responseTotalIndex?
I'm surprised that getRequestParameter does not return an Optional :)
What's the identifier for this profile? We may use the username even if that doesn't change anything actually.
This is not necessary as it is null by default.
Unneeded empty line here.
Does mean there's no signal for "the user typing out a correct entry, not clicking on the entry in the list, and then clicking on the next question" which results in the value being set? Clicking the ">" or swiping would do it, since that triggers a "get answer", but I wonder if, say, losing focus should also attempt to set it?
Use Zlog.LogException(e) wherever Exception is caught!
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
Consider wrapping this into the constructor, and getting rid off the setter? StreamEdge(isIntermediate)
As the setSpeed method is deprecated we need a different approach here. Some more hints: * use edge.get(accessEnc) instead accessEnc.getBool * instead of setting speed to 0, set access to false
toTraceId already returns a string, on need to call format()
In your @Test, you can use @Test(expected=IllegalStateException.class) and _not_ do the try/catch within the method. This is cleaner and more appropriate :)
Need to do 'put' after the set has been changed. In case the put results in the value being written to disk or distributed to clustered caches.
getSchema parses the schema if its not null. however we should parse only if its not a macro right ? should we support macro for schema field ?
Shouldn't it be CONF_DEVICE_ID_TOPIC?
you should remove the source device id afterwards so this transfer only happens once.
Not worth debugging for this QS
Not worth debugging for this QS
Not worth debugging for this QS
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
Please use "something <operator> null" convention
rename to name
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Usually we use this. prefix only in constructors and setters, please remove if possible.
Can we have values in both m_left and m_args? If not, is there a debug assert somewhere?
do we need this composite? we have already the border composite
actually calling .layoutData(new GridData(......)).create... should be ok here, correct? like you changed from supplier to layoutData in addFiller()
Please externalize these strings.
do you need to add CRC here?
You could also use -> Objects.toStringHelper() from guava
Can we leave this out, or make it conditional on VDBG?
Spaces after commas
It'd probably actually be okay to call getTypes() for all objects. I think for binaries it'd still work, and we want to be able to process AdminUnits and likely folders too.
should we just test actionType in an if-block to see whether it's null, rather than catching the NPE?
Why not just call the constructor here like it was called before (new DeviceMessageMetadata(metadata))?
Why not just call the constructor here like it was called before (new DeviceMessageMetadata(metadata))?
Exception is never thrown
This (And other filters) need their type as well. The reason being we could have a TagValueRegexp with a filter like .* and a FieldRegexp filter with the same filter and want them to hash to something different. For this and other regex filters, you can omit the pattern from equals and hash as those are just compiled versions of the filter field. It's ok not to use the parsed version even if someone puts a space in front or back.
ArrayList<>();
Should it be KeyStoreWrapper.getInstance().getRSAPublicKey
Would you also add an IS_NULL filter here?
ImmutableMap.of()
should the SortExpressionExtractor be renamed as well?
There is no need to do check for null, right? I mean you could just write something like return "SslSession(alpn=" + alpn +...
Does this need to be a singleton?
Should we check that either all of the encryption properties are set or neither of them are set?
You don't need it in every Exception since you have a finally clause that will get executed at the end.
s/allow/allowed
you don't need to rename anything
Can you factor out psInfoFactory.get(db, pId).getAuthor() into a variable? I think it would be better than to have it in 3 places now.
Can't you get the name of the author like this: psInfoFactory.get(db, pId).getAuthor().getEmail() ?
authoId -> authorId
This should be a triggered ability of the enchantment, not a trigger gained by the creature
This needs to choose the target when the ability triggers, not when it resolves. I'd use adjustTargets to do this.
This needs to be a sorcery
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
May want to do a null check
Again, constants would be nice for readability.
Somewhat counterintuitively, I don't think this specific call actually should be app restricted. If the case model changes, it should invalidate caches around that case model regardless of which app produced them.
For consistency: "Updating group GROUP_ID, name NAME, ...
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
If createdByUid == null or user not exists, skip this settings and continue without seting role.
Bad indentation for this method.
We can check this using SQL constraint itself in impl/dao layer, since we update name and description separately. We can catch DataIntegrityViolationException when updating name and then throw GroupExistsException rather than current InternalErrorException. See example in FacilitiesManagerImpl method updateFacility().
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
pls rename to hostAndPort
Might want to also support the square bracket syntax?
There is a singleton for OK Status: Status.OK_STATUS
The boolean is not detailed enough (It doesn't explain why the profile is not valid. File does not exist? File is not a Profile? Profile is not defined?) The usual pattern for this is to return IStatus instead of boolean. The IStatus can contain a status code (OK / Warning / Error), as well as a message and an optional Java Exception. The UI can then print proper messages depending on the exact status
findMember can be used so that both folder and file are checked at the same time.
Can we do new CsvReader(inputPath) and do the conf/fs creation in the constructor?
else is redundant
I think we could extract DBI as a variable and then use Java-8 friendly method useHandle: java DBI dbi = new DBI(databaseUrl, "sa", ""); dbi.useHandle(h -> h.execute("create schema " + schemaName));
@aertoria Can you change all the variable names in test method to not have _1
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
why would this be required again?
Please init ArrayList size.
Please rename this method to match the return type
Same question about maintaining type information.
Should we consider putting that 512 into the AmqpConstants to keep all the protocol-specifics in one place?
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
Please use a try-with-resources block here
These two calls to parser.next() are strange... can you explain that a bit ?
let's include the entire XMLStreamException in the IllegalArgumentException
Can we make an enum or consts for these result strings?
I can see we using this symbol in multiple places. What do you think to extract and also use the constant from Character class? Character.MIN_VALUE?
You can use the IntObjMap here as well
Nit: I would dispense with the elses since you return in the ifs.
filters.addFirst(filter) ? <LINK_0>
I think it is better to throw exception
@vmaletta I think ep should not be there. Maybe a merge issue, could you please check?
Cleanup: Remove all **throws MiddlewareQueryException** clauses
@leonard84 to make FileBackedIndex thread safe we need to declare as synchronized **every public method which access (read or write) object state** (index or storage) fields. Otherwise, access to those state fields by thread 1 may be not visible to thread 2. Also 2 operations (such as this.index.put and this.save()) are not atomic when observed from other thread. Huge source of races :(
have a default constructor with reasonable default values
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
Alternatively you could use: java this.overlay.toBack();
style nit: missing braces, since a while we use braces around single line blocks, change this only for new or modified code
* fail earlier by moving this check to DfsBlockCacheConfig.setBlockSize() ? * I think we should also prevent blockSize == 0
// We want to override the concurrencylevel only
I think it is better for performance to get the member first, check if it is not null and perform deserialization. Also safer.
Refactor move code block into catch, then return statements are not necessary.
Class<?>
assert return value
This should be: cli.sendLine("reload"); When you use the high level CLI reload command instead of the low level ":reload" op, the CLI knows to expect the connection to the server to close, handles that cleanly, and reconnects. Any low level op like (i.e. the :xxx syntax) it just parses and sends a DMR op and then expects a response.
Please use try with resources
I understand the need, however, we must be careful when working with paths which come not from Java. /var/tmp may not exist, it may exist but be not writable, we may or may not have permissions to create it if it does not exist. Linux sysadmins may want to use some other directory instead, which is not possible when the value is hardcoded. Also, I doubt that os.name is always exactly (lowercased) linux when running on Linux. Perhaps, it makes more sense to check if such directory exists and is writable and use it in case of success, otherwise just use the default temporary file directory.
Can use java 8 paths.
rename to automationContext
This is a nit, but (at least here in the PR) the white space looks a little off (looks like one if was indented by tabs, the other by spaces, or similar) Also, I'd add curly-braces to the nested ifs (for consistency), or express them as ternary conditionals
@jon-wei Do you have benchmarks on how this performs relative to alphaNumeric for dimensions that only contain integers (in which they should order the same way)? If not could you please add one to the topN benchmarks? I'm wondering if we need to think about optimizing this for numerics that fit in primitives or not. If the performance is roughly similar I think we don't need to worry about it.
there should be a shortcut function for this on the super class notifyBlocksOfNeighborChange().
s/uninitilized/null
out is being closed but not in.
debug instead.
Using targetClass.getFields() here gives you the public ones (incl. those declared on parent classes). That removes the need for checking the public modifier later on. Did you know that you can check the modifiers using: Modifiers.isPublic(field.getModifiers())?
use StringUtils.SPACE
Do we really have to fix this here? I think simply rejecting _id in  .addExclude( ) should be enough, shouldn't it?
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
I assume the 0xffff is to deal with the down casting from long to int and making sure that it's a valid positive value?
IIRC anonymous users will crash here because they have no user account to get the prefs from.
Can we add more context to this log statement as well?
Why not just join() the thread?
We should check the future for exception here also. Also we aren't logging any kind of message for a failure any longer, we should make sure those are logged as well.
This code is almost a duplicate of getIncrementedSegment(), could be extracted to a method.
SegmentLoadingException is specifically checked for in a few places that treat it differently from a generic runtime exception. Please keep it.
extra space
Not strictly necessary, since the .get() will throw if there's no extracted content.
This should be a separate test. Each test should only be testing one thing.
we don't need to do this, it would be (imo) incorrect for the cache to return you something that has expired but hasn't gotten round to evicting yet. I've also checked, it doesn't do this either.
You can chain this like  java return ImmutableList.<String>builder() .addAll(currentSeeds) .addAll(newSeeds) .addAll(oldSeeds) .build();
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
Static import fromTypes.
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
Do you want to rename the fields, too?
private, should only be called from the builder.
can be removed now
style nit: this can be inlined
Can be inlined: for (RepositoryMapping mmapping : getMappings(project).values())
should we at least assert that it's a well-formatted timestamp?
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
Isn't this constant and shared across all producers? Then can't it be static?
super.init() method never throw an exception.
you should yield here (return). Operator shouldn't do a ton of work within single call, otherwise a query might be "unkillable"
Exception isn't thrown by consumer.close(), it should be removed.
empty hashmap.
empty hashmap.
empty hashmap.
Instead of creating a couple of extra Timestamp objects, move this as the first line in your if statement and just return true, like this:  if(divBy > 1) { return true; // As in this case, we've already got the correct value in ptr }  Also, another good optimization would be to check the last four bytes being non zero without creating a Timestamp object. You could do this like this:  int nanos = PDataType.INTEGER.getCodec().decodeInt(ptr.getBuffer(), ptr.getOffset()+PDataType.LONG.getMaxLength());
remove the logger.debug() for null arguments
remove logger.debug statements
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
This test would be useless if the map had been initialized in the class.
As you know it's a method symbol from getting it the methodTree, why testing it again? Is it to cover the case of unknown symbol? If it's the case, I would prefer to test it by using !methodSymbol.isUnknown(). Moreover, this case is not covered by your test cases. The same remarks apply to the overridee below.
This null check should in fact be avoided. The only case where a method symbol from a method tree can be null is when semantic is not available. In the ruling that happens for package java.lang of JDK. If it is not available, then it makes actually no sense to run this check so, in fact at the beginning of the visitNode you can have a :  if(!hasSemantic()) { return; }  You can test this by using JavaCheckVerifier.verifyNoIssueWithoutSemantic (which you already use).
probably no need to collect: filter and foreach should be enough.
is incorrectly formed.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Cast to string can be removed
If you see opportunity it would be great if you could refactor the methods with many parameters.
remove finally-block
"Initial connection"?
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
nit: missing spaces before and after +.
we'll need to plumb this change in custom Token Credential Auth policies too where a cache is being maintained. We can open an issue, for now, to track this work and get that change added to Track 2 SDKs when Identity is about to GA.
Calling fail() throws an AssertionError, so you'll get a confusing error message if we ever get here. When testing code that should throw an AssertionError it's best to use this pattern:  try { callThatShouldThrowAssertionError(); } catch (AssertionError expected) { // optional: make assertions on expected here return; } fail("Expected AssertionError to be thrown");
this for is exactly the same in all the array tests, let's move it to a private method
You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation
Add default to the switch
Why is this needed?
why exit here ?
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
we can use TestUtils.assertFutureThrows() here too
What's the point of the 6 trailing zeros ?
this method is written in a 'single return point' way, i'd rather use it (means set returanValue to false instead of return here) or refactor the method to have multiple return points. please, if you choose to refactor, have it in a separate patch from the change this patch is doing.
You're removing here the call to checkStorageDomain(), which is fine because if getStorageDomain() returns null, a NullPointerException is thrown when initializing storageDomainToPoolRelationValidator. So no harm is caused by removing it, but wouldn't it be better if we moved it to the beginning of the method? Something like: if (!checkStorageDomain()){ return false; }
please add specific error message for nic plug actions which specifies the valid statues for this action.
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
I will check over the weekend if it is possible to remove this workaround, otherwise I will create an issue to remember that
Why use if one time and ?: in the next line? Actually, I would sugggest  encoding = context.getConfiguration().get(HBASE_ENCODING, HBaseConstants.STATIC_FIELDS_ENCODING_UTF8); mergeBodyWithUpdates = context.getConfiguration().getBoolean(IMPORT_MERGE_BODY_WITH_UPDATES, false);
Minor: Maybe extract local variable with the size. Will be more understandable.
Shall we just warn the user instead of throw exception for this case? Also change line 120 to be: double effectiveRate = (double) e.getValue() / numTasks;
to toImmutableMap?
"e" is an exception. Per definition. :)
no need to call Assertions.assertTrue since you already imported assertTrue in line 30
maybe use variable or pass in as parameters instead of using magic numbers.
Missing null check on sampleClass
This returns a ValidationResult, which you must check and handle appropriately if validation failed
this should probably fail on receiving interrupt
Null check required?
TABs
Any worry about case sensitivity wrt to scopes?
Same observation as WCS and WFS tests
I believe every instance of displayName() should be name(). Latter is canonical, but former will / can vary depending on Locale. <LINK_0>
Somewhat counterintuitively, I don't think this specific call actually should be app restricted. If the case model changes, it should invalidate caches around that case model regardless of which app produced them.
isEmpty
Delete the second point
Bad, no printStackTrace in test.
This error message is not very useful. How about "no matching files for folder with regex: " + regex.
Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files
Instead of the regex, can we use new File(folder) and call getParent() until it returns null? This way a test could use newFolder("foo/bar") and be able to run on Windows and Unix.
I think lowercase l should also be considered
I would recommend an else if here to avoid comparing against a string unnecessarily.
Maybe it's not worth it, but a subclass of ByteArrayOutputStream could look at ByteArrayOutputStream.buf and decide to copy all of buf or all but the last byte, saving one copy.
Modern Java does not need StringBuilder any more. Simply use += to build a regular string, this is fast. It may even be possible to use StringUtils on an array of longs, but I'm not sure about this.
Did you intend on nesting the code block in a paragraph block? If so the method name should be changed to indicate what this test is about.
Newline at the beginning of the string? For readability?
Should this use a try { } finally? Otherwise other Throwables leak.
If HEAD is not a symbolic reference (aka its detached) you want to return its SHA-1. So really: Ref head = repo.getRef(Constants.HEAD); if (head == null) { throw new ResourceNotFoundException("HEAD"); } else if (head.isSymbolic()) { String n = head.getTarget().getName(); if (rsrc.getControl().controlForRef(n).isVisible()) { return n; } throw new AuthException(); } else if (head.getObjectId() != null) { if (rsrc.getControl().isOwner()) { return head.getObjectId().name(); } throw new AuthException(); } throw new ResourceNotFoundException("HEAD");
unused try catch block
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
why did we change this. SchemaResource should be unrelated to MLRegistry. We require having topicName + ":v" for schema registry to work with
I wonder if this (along with the getTableConfigsForSchema function) can be moved inside validate ? So that the caller doesn't have to do this every single time (and can be done implicitly)
Is this better than Assert.assertEquals?
Why delete this line?
use static import
If the response data contains apiName, does it mean that api is deleted?
after publishing API we need to wait for the deployment
check the message code
This looks like different logic. You only have one serial read. putChar also writes two bytes into the buffer. This seems weird in the first place. We could maybe jut write:  return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).put( new byte[]{serial.read(), serial.read()}).getShort(0);
Findbugs reports this, as you ignore the result of read(). Please add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).
requireNonNull(row);
setGameState( BOT_VS_PLAYER ). make final int
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Another FYI, not a required change: note that there are some "gotchas" when using String.split with a regex. [Here's a nice breakdown](<LINK_0> If this was high-performance code, you'd probably want to compile the Pattern ahead of time, and split using that instead. I only learned about this a couple months back.
maybe mention the field type?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
The super() returns "" on null. Why should we differ?
The same here than for PreviewImageFragment.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
If item is null, the code will enter here and we'll have a crash. The condition must be split in two; it item != null, all the code is done (including the if (sendEnabled) ... else ...) ; if it's null, do nothing
You can just early return by checking leader == null.
Does not compile, but not really important.
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
Should this one be turned into Throwable as well?
Is this one missing Call.propagateIfFatal(e);
Not sure but I think this would only happen if there is an error in the business logic on the client side when processing the closure, even if the request itself succeeded. So this might not warrant marking the span as error.
this whole thing can be replaced with Stream.of( args ) .filter( StringUtils::isNotEmpty ) .toArray( String[]::new ) right?
no need for the additional check if propertyParts.length is ok?
Bug? format requires 4 params but only 3 are provided?
If you are in Java 8, it is nicer to use .then.
For fix tests on Jenkins you need to create project directory, like here PerformanceTestBuildTest#testFlow#L38
You can use a MockBuilder (or TestBuilder?) which waits for a Semaphore. More reliable, portable, and faster.
Maybe a wider exception would be better idea here if anything rather than sql exception happens. Since we don't deal with the exception itself.
Missing opening "(" before getDescription().
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Test for last four digits as well?
minor: could make a reusable method  given().port(app.getLocalPort()) .header(AUTHORIZATION, "Bearer " + API_KEY) .header(CONTENT_TYPE, APPLICATION_JSON) .body(payload) .post(format("/v1/payments/%s/refunds", CHARGE_ID)) .then()
Can we also have test for /v2/api/accounts/{accountId}/charges ?
Please use a [StringBuilder](<LINK_0> instead.
why do you need to convert the bundle to a map, instead of using it directly?
What is 1? Perhaps have a static var describing what this signifies?
Let's use request body rather than request params for this. You can use getAndValidateRequestBody method with List<String> or String[] as the type.
Similarly here; use request body.
When testing, I got an NPE when studentProfile is null. This needs a non-null check. Also needs a test to prevent that from happening again.
please rename to performOpenMoreOptions
please use the FormulaEditorWrapper, there should be no ids of formula editor elements in tests
why is this necessary? why onTouch? please do not use espresso onView or onData operations in setUp.
I think we can remove this line.
Should this work with versionID? It's already in stg73 branch.
This method should get the expected size of each lun, since vdsm reported it in getDeviceList (path capacity). So this should call each host, and report the hosts that do not see the expected size. We don't nee to create map of sizes, but create map of luns to failed hosts.
Should just return properties.get(), the containsKey() call is redundant.
Why is this method static? Only singleton access methods like getInstance() should be static.
can you make this Callable a class field?
can you compute difference and then use in if condition?
Should maybe be "SocketException has occurred"
why this file relevant for this specific pull request?
@tbarsballe has gone through and done a QA run to ensure closed writers return hasNext(): false (rather than thrown an IOException). Lets stick with that for consistency (principle of least surprise)
@ivanursul, I think this should be as it was... The idea is to be able to import a strongbox.xml if one is on the path, or specified as via the parameter. If there is no such specified (and there is no configuration yet in OrientDB), then load the one from the classpath (available in the strongbox-storage-api-resources artifact).
Shouldn't it rather throw an UnsupportedOperationException? Alternatively, it could return new ByteArrayInputStream(buffer).
return id list
should be a while loop here
I think this case should be in the list of fallback cases (unfortunately, I don't know how to create a COPY diff)...
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Should this have output partition too?
Add .omitNullValues() before the toString() call
Nit: Map on the LHS. It doesn't matter a huge amount, but I'm curious why you've used ImmutableMap elsewhere and not here.
this should be able to reused. it can be a static field
Optional: more compact write possible Map<String,Object> map = new HashMap<>();
You can probably use EntityPredicates.id(), which gives back Function<Identifiable, String> (rather than just for entities).
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
Generics on the right side are redundant since Java7
remove the unnecessary space, catch throwable
Add the command that is being executed to the log
Do we need two debug logs here?
invoking combinations of close and releases here looks strange
return element instanceof DDiagram && ((DDiagram) element).isInLayoutingMpode();
I'm not sure this can be null?
Should we also have the same tests for the email template?
Why did we remove this from the test? Does creating a user with the consentUser no longer function?
We generate the token, but we don't actually store it anywhere. So when the user goes to verify their phone, they will always get the "token invalid" error. Also, VerificationData currently doesn't distinguish between phone and email. This allows users to receive the token on their email, and then use it to verify their phone,
suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream);
mark this as deprecated. gut the function in favor of calling requestRouteToHostAddress, casting the hostAddress into a InetAddress
.filter(part -> (part instanceof SpongeSkinPart) && (flags [...])?
do you think debug is enough to report this problem? I would use warn.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
maybe, would not be keeping the map null better, to ensure uninitialized mapper will not be used accidentally? (even NPE is better then complex debugging why roles are not mapped...)
Second parameter of Status is the pluginId. Why to pass path here?
Can you remove this first case for FileNotFoundException and just let it fall through to the general case.
No need for else here.
you can use Schema's isNullable and getNonNullable methods to help out here.
Type for Field + config.field + must be String
use the same error message as above for consistency: "Field %s must be of type bytes or string. It is currently of type %s"
Type casting should be avoided and seems indicative of a problem with the model. Why are you not passing the configuration via the constructor?.
@zxw1962 assert will not work in production, if you could change this to an actual if() statement it will be great.
Please consider map.computeIfAbsent
channel.close().sync();
Why do you need this change? Seems you should prefer the autogenerated Shadows.shadowOf()?
same as for AddAddress here
if it existed in containers, is it not sufficient?
Make them on the same line if possible?
So this is gathering the bitmap by invoking the BinaryOperatorTransformFunction?
NaN if outputRowCount is 0
nit: there are other places where we for symbol %s, without :
validate type isn't null here (especially that is taken from a map, so can be null silently)
why do you need retries on stop but not start?
Doesn't firstRedirectException mean the first exception? Then, this should be: java if (firstRedirectException == null) { firstRedirectException = e; }
This is usually considered a bad code smell and can be corrected by dividing the logic into two methods:  java public static void initAsyncPrettyPrineterForResponse(...) { prettyPrinter = matchPrettyPrinterToResponse(...); if (prettyPrinter != null) { associateAsyncPrettyPrinter(...); } } @Nullable public static AsyncPrettyPrinter matchPrettyPrinterToResponse(...);  Many engineers find this easier logic to follow because they can more easily predict the exact flow control semantics of matchPrettyPrinterToResponse(...) based on its name and signature.
delete all private setter and just set the meta object. For the getter take the values out of the meta object. Much less lines of code
nit: use org.apache.zookeeper.server.ExitCode
ExecutionException wrap the actual cause on loading the file channel. so you need to unwrap this.  if (e.getCause() instanceof IOException) { throw (IOException) e.getCause(); } else { throw new IOException("Encountered unknown exception on opening read channel for entry log " + entryLogId, e.getCause()); }
This may introduce NPE if a resource is not in the resourceTimestamps
Why are we forcing the creation of the directory? Surely it should be writeable?
this seems like it's going to be incredibly verbose. Can we nix tihs?
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
This looks like it's just for card payments so don't think we should add these her.e
Add new catalog options.
parser.teardown() call should be part of finished() call of TestWatcher
Can you add small addition to make sure that error port has same string tuple that was passed on input port?
Can you also use: MiscAssertsKt.assertFieldCountEquals(5, TetherStatesParcel.class) to make sure this is not missed if a field is added ?
The countdown latch is not decreased so waitForInitialization hangs.
Can you add a getDeclaredConstructor ?
Use parameterized logging instead of string concatenation.
Why not in combination with above do this: setValue(value, false);
Minor: same as in other number check, WDYT about checking for the decimal point?
I think this should be > 0 since a value list item of 1=One does not work.
why couldn't we return results before the analysis is completed?
Can be O(n), move fast exit up or remove, and set to 0. or some equivalent number. Maybe 1000, to avoid the initial resizes?
space
please show the new line within the text: ( " --%s%n" + " %s%n" + "%n" ),
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "StringBuffer" by an unsynchronized one such as "StringBuilder". [![rule](<LINK_1>](<LINK_2>
diamond operator?
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
object.toString() isn't a null-safe call, while sb.append(Object arg) is doing 'String.valueOf(arg), so it has a null-safe Object-to-String conversion. So we just shouldn't call toString() here.
We know exactly how many elements we need, why are we allocating 1024 instead of (end-start) ?
android.R.id.text1 Change this.
This feels weird to me - why are we manually setting the height like this?
use description only, remove " - "
Why bcast when it can be sent to Admins only? Ops could use it to spam.
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
You can use Layout.INVALID_CLUSTER_ID
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
You don't need this line because of green 31.
You can do this without an Iterator:  for (Map.Entry<String, String> entry : rawQueryParams.entrySet()) {
This could be null, we should probably handle this if the JIRA api changes again
no need to specify types on RHS
I wonder if it might be better to only check the time if we've yielded... unless we're spinning really a lot, it shouldn't delay thread termination (which is really what this is primarily for) by too much. OTOH, it's possible that nanoTime() is effectively acting like an onSpinWait() in this case; the total time spent spinning will be probably significantly higher than on the version of the loop without this call... something to think about anyway.
It would be great to have braces around.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
Why is it a list of lists, not just a list?
why not using addAll?
move it to be aside of deleteFolder
Any reason for doing this?
Same deal here. Hibernate's containers tend to not adhere to the contract on .equals and .hashCode, so make sure you're not at risk of running into the issues such violations present. Product.hashCode has another example for this scenario.
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
.. does not exist or is not a directory. Also: put %s and take /meta/credentials from the constant.
Is it a conscious decision to throw an unchecked here?
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
Has already said on branch v2 patch set : 2 access to eResource() --> Create a local variable for this
I wonder if we don't break some existing users use cases with this change... but I guess it wasn't very useful before. @miniway ?
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
I think it would be more readeable if you would return here DbUser instead of setting the private user attribute, in method which has "get" prefix. Could be confusing. Then pass the DBUser to userDbIsSet method.
boolean is never null. Please find a user where it is true.
This can be skipped before we even test isGitRepository().
It was on purpose (the directory is about to be used so there is no need to delete it), but I guess either way is fine
This may introduce NPE if a resource is not in the resourceTimestamps
static import?
How would you feel about having a DataSegmentInputSplit as per <LINK_0> ? Alternatively we could have a "HadoopDataSegment" which has a hadoopy loadSpec which is only a URI parsable by hadoop (in addition to the other things a DataSegment usually has. That could allow the peon/overlord to setup stuff correctly for hadoop. We have the data to get all the splits done completely, it is just a matter of ensuring the data gets propagated to Hadoop correctly.
The avg size puts the 1/2 of the items as small items, would this bar too high? Especially we put all the partitions belong to the same topic into small group, so it's more than 1/2. Should the threshold set to 1/3 or 1/4 of the total items?
We better not have the supported/unsupported versions hard coded here. Please check whether discard is supported using the FeatureSupported class.
Given there is no caching going on and lazyEntriesView is not exposed externally anyways would it make more sense to remove lazyEntriesView all together and just do lazyEntries.keySet() (with the remainder of the line being as it currently is).
You can use CollectionUtils.toImmutableList
href.indexOf('.') == -1 is a pretty unreliable test for a file extension (folders can contain a dot)
Maybe /accessTokens/ should be a constant defined in this class? Not a show stopper - just a thought
When can this be null?
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
Minor nit, feel free to ignore: I prefer setCancelable(true) so you can hit the back button to leave the dialog.
Is it possible to pass just the string id (you'd need to import R) instead of calling getString? It is more readable and might help with your 64K limit issue.
Since it now is a closeable and java 7; I think we should use the "try with resource" form instead.
style nit: we don't use braces around single line blocks
maybe better: localBranch
Hm, why is the caching logic here and not in the mixin definition?
remove unnecessary checks
it's better to use registerAndRefresh() because registration can be done async in monitoring server depending on when voltron is calling us.
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
id is the unique element in a HTML page. Therefore, there is not need to have a chain to locate it. Check if there are similar case in your PR.
I saw the Travis build report. All these *.click() must be click(*) as per the new version of Selenium's change in implementation.
ID is a unique element in a page and therefore you don't need a chain.
Should these be assertions?
non-actionable: ... and this is where I complain about not having Java 9 Optional#or which does exactly what you need
Its just a little bit weird to have the "left" arguments at the end. I am wondering if it would be simpler to read by changing the order of arguments to:  Optional<String> left = handleTimeValueCast(arguments.get(0), leftDefinition, arguments.get(1));
Neither here, nor in the interface, does it say as to how much data is read into the buffer. Let us be clear: unlike other similar apis, it is not "read as much or till EOF", but "read exactly buffer.remaining() or throw".
This will throw an NPE if eventTimeInstant is null.
just remove the fileSize from here... and that's the only change you will need.
Space before and after ()
have you thought about using the builder pattern to follow the code line in the other projects?
Can be moved to if block above
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
Can this be nested in the last if statement instead of calling isDebugEnabled twice?
While here, this could be replaced with a foreach (and below)
This returns InputStream no? We need to read and convert the value to string. We can add a helper to do this: String readContent(HTTPResponse r) { BufferedReader reader = new BufferedReader(new InputStreamReader(r.getContent())); return reader.lines().collect(Collectors.joining()); }
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
Is it really necessary to refactor this method that heavily? I personally find the old implementation to be much more readable. - What is the use of transformNoResponse? If someone wants to customize the behavior, they can simply override transform(). - Why have both "byResponseStatus" and "byResponseStatusFamily" methods? The family case is just a sub case of the status case.
same as others: log should have Exception as arg
You can also use IO.close(bb) as IO.close will not throw any exception.
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
suggestion throw new IllegalStateException("The JDK Throwable does not provide a detailMessage.", e);
This should be log.error. Don't know why other statements here use log.warn
Can this be a wrapped exception so the stack trace to here can be recorded?
We could omit the second Integer.
@NonNull on its own on line above
public
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
Inconsistent log format. Use either {0}th or {0} th. {0}-th is even better.
nit: let's make it one line.
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
same question as before, about the value of heart beat..
well, of course I can read the code and understand, but - still, maybe enum is better.
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
Minor: this could be a bit simpler if you used a private implementation method and passed in the map container to use. Then toQueryMap could pass in a LinkedHashMap and the normalized version could use a TreeMap.
This can be collapsed to a single line.
This (the whole method) could keep the same indentation char.
Check isDebugEnabled()?
Generally we only add final when really needed.
suggestion sourceFile.tryDownload().ifPresent(handle -> handleArchiveExtraction(process, handle, shouldOverwriteExisting, targetDirectory));
Oh dear, I'm sorry, there's a change in it that I made for testing. Could you please undo it?
maybe System.identityHashCode ?
s/vdsGroupId/clusterId
doesn't really matter but i'd do - Guid vdsGroupId = getParameters().getVdsGroupId(); if empty(vdsGroupId) ... instead of the else
check here also if the groupid that you got is actually exist..
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
trace
Debug has to be detected first otherwise we'll always take the INFO branch.
I would prefer to see this logic broken up into a couple of lines, it is a bit hard to parse. As well, then you could avoid the need to create the empty set to pass in for the other getProducts(page) call.
We do the same ternary operator above - how about breaking this out into a seperate function.
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
@fuss86 Sorry for disturbing, but don't you think that this is "tight coupling" here to check this optional every time?
I am not following here - why do we want this in sync block?
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
You could also use -> Objects.toStringHelper() from guava
do you need to add CRC here?
redundant else
Why we should avoid using ContinuousFileMonitoringFunction here? and why not return SourceFunctionProvider of InputFormatSourceFunction directly?
Same as for doubles, maybe make one of these negative?
Delete try/catches. An exception always fails the test case.
Why delete this line?
Why do you have to include this test data for reason concept? Is it required for this test?
Having the SWT.Read_only gives the text with context menu items {undo, cut, copy, paste, delete, select all , right to left reading order, show unicode control char , insert unicode control char, open IME, Reconversion} Since our objective is only copy can we restrict the text selection context menu to select all and copy ?
actually calling .layoutData(new GridData(......)).create... should be ok here, correct? like you changed from supplier to layoutData in addFiller()
final
Any reason why not to add this as const as well?
Note that there's nothing wrong with leaving logging in to help debug problems later. Loggers can be enabled/disabled while the program is running. If calculating the arguments are expensive, prefix with if (logger.isInfoEnabled()) "
Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your newBuilder() desire.
Hmm, this should probably act like the column is a string column full of nulls. The rationale is that the classic Druid behavior is that when you filter on a column that doesn't support filtering, it acts as if the column is full of nulls. So that'd be consistent with behavior in 0.9.1.1 and prior. This could be done by calling predicateFactory.makeStringPredicate() and checking if it applies to null or not, then using that to make a BooleanValueMatcher.
Yes, that is correct.
Please put assume as the first line in the test, makes the precondition clearer.
I think that using containsOnly could hide the fact that duplicates are not preserved. Inspecting the variable load.getParticipants() I get this: > 0 = {Programmer@4134} "Programmer{nick='fax4ever'}" 1 = {Programmer@4135} "Programmer{nick='phone4induction'}" 2 = {Programmer@4136} "Programmer{nick='telegraph4eternity'}" I think that duplicates are lost even in a @OneToMany. Aren't they?
Use IResource.adaptTo(Class).
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
suggestion if (System.getProperties().containsKey("javax.net.ssl.trustStore")) {  this suggestion would look clear to me.
why not to replace this with an instance variable annotated with @Inject ?
optional nit: this is still confusing for me, maybe it could be reworded as suggestion Unable to determine max direct memory size. If druid.processing.buffer.sizeBytes is explicitly set then make sure to set -XX:MaxDirectMemorySize to at least "druid.processing.buffer.sizeBytes * (druid.processing.numMergeBuffers[%,d] + druid.processing.numThreads[%,d] + 1)" or else set it to at least 25% of maximum jvm heap size.
Oh look, some SafeArgs :)
Nit: "Archive license file..." is an imperative, seems like you're telling someone to do something. Maybe "License file archived to..." is a better way to report what has been done. "Archived" seems a little odd to me, it's like you're putting a copy away that we will never use. Do we say "archive" elsewhere? If not, I suggest "copied". Or even "staged", since that's what you say in the error message.
Remove stack traces
if there is unhandled exception it will cause that opengrok will need to be restarted, isn't it better to check for Exception or Throwable?
I'd prefer to see this run once when opening the database (avoiding the need to queue it) and then storing the version as a constant for any use later. We could include it in the thread name for instance.
Probably don't need package name here
Can be static.
@HeartSaVioR If multiple threads invoke concurrently on getParsedScript(), they may create their own instances of groovyShell and parsedScript and do not give thread safe instances. There should be only one instance of GroovyShell and parsedScript each and they should be shared across all threads. It seems we do not want to create them in constructor to avoid serialization issues. You may want to synchronize while creating these instances for thread safety. IMO this synchronization penalty should be avoided and they should be created in constructor. But the components which are creating GroovyScript instance should only create them only when it is required. This kind of stuff is typically done in org.apache.storm.task.IBolt#prepare instead of in IBolt constructors to avoid serialization issues. We can file a separate JIRA to address that.
That's true It's fine then.
Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your newBuilder() desire.
This isn't needed since we are in try-with-resources. This can go into the while loop
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
this line should be replaced with: when(osRepository.getNetworkDevices(any(Integer.class), any(Version.class))).thenReturn(NETWORK_DEVICES);
... you should be able to assert that the Transform offset X is correctly set here.
suggestion .thenCompose((ignore) -> registerTaskExecutor(tmResourceId, taskExecutorGateway))
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
Nit: Move future to be right above the "final Action action =" line.
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
Should use assertThat
can you reference the enum values here?
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
replacing this with helper method would be great
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Use the pre-existing localized string R.string.multimedia_editor_popup_cloze, and definitely follow up on the "TODO" by using a static constant value instead of a magic number.
I thought all of these were changed to com.ichi2.anki JSON classes to avoid the try/catch since we just throw RuntimException anyway? #5550
I think this can be a bit cleaner by calling super.onCreateActionMode(), and not exposing getTag(), and then proceed to inflate the menu. (and remove the default inflating of the menu in super()). Or better yet, create an abstract method that asks for the resource-id of the menu to inflate.
Class name is not needed when calling method on same class.
same for thos changes
Why is this change necessary?
Why is this not a if condition
if output is not connected, will your parsedRecords will be zero? Same for validRecords. They should be incremented if there is no exception.. Why have two different parsedRecords and validRecords when they are same?
why not null as value?
suggestion setValue(relativePos / rectangle.width);
Please, refactor this abreviation. <naming
I wonder whether the upper bounds should rather be: x < this.maxX and y < this.maxY as current this is inconsistent with the int version of this method, yielding for exact integer coordinates false with the int version and true for the float version (for exactly float-representable integers).
At this point, too, an AtomicReference does not bring any added value compared to a volatile variable.
We don't use old style RPC calls on new change screen. It should be migrated to REST API.
Should we skip doing this if scrollIntoViewPending_ is already true so there's no way for requests to stack up?
Use CharacterEncoder.getSafeText()
should the request be closed after return? meaning moving the finally to the outer catch-block?
This is not necessary and generally a bad practice, especially in production code.
db.components().insertComponent
Can we also have a test for LUCENE -> NATIVE -> LUCENE
(minor) You could add an explicit .setPrivate(false).
Can be replaced with this.constructLockKey()
Same as above for toString(): <LINK_0>
String.format
I think the order of the checks here is relevant to minimize the work. We should check "firstParent" first, then SEEN and then parsing the headers if needed.
I think it makes sense to skip the parseHeaders, too, with the logic being that we haven't traversed into the other parents at all. If it causes trouble, we can make a followup change. :)
1. Should this be continue? If not, if the 2nd parent is not uninteresting but the 3rd parent is, the 3rd parent won't get added. 2. Put braces around single-line "if" statements [1]. [1] <LINK_0>
ugh again ..
Can m_asynchLoggerPool be null if it is disabled?
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
Arrays.fill(filler, '0');
Null pointer...
Why does this just return blank strings?
I don't understand why you don't use the sonarUsersGroupId and have simply the query:  "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_id=u.id and gu.group_id=?)"
IMO "deactivated users" is enough
No idea why, but the loaded_template entry on quality gate has not been removed on my box
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
Maintenance of the map will be simpler than that of the list
Maybe wrap in an immutable map.
Could we add something like: if(System.getProperty(PROP_UUID) != null) { return System.getProperty(PROP_UUID); } Then product creators can disable by setting the property to whatever value they want.
do we still nee line 390
You can use try with resources here so the Input stream is closed automatically.
why is the lower bound 0? Should it not be at least 1?
probably best to use getIntInRange() here too to avoid negatives (I think I didn't know that the function existed when I first wrote this).
32 * 1024 * 1024 here as well?
Let's explicitly check whether numBlockOwnershipByEvalIdForWorker contains workerId. Same for storeServerMetrics().
Same applies here; could we move the if statement in [L251](<LINK_0> down here?
It seems that the logic related to ongoingSyncs has potential concurrency issue. The worker never sends sync reply message if the following scenario occurs: each statement is executed in the following sequence L193 (if clause is true) -> L204 (if clause is false) -> L194~196 (if clause is false) -> L207.
My guess is that you'll probably want to extract out the class portion of the metric name unless we're just doing blind search replace of s/remotingN/remotingN+1/g across the project each release
I'm fine with making a test-local factory method here to keep the tests shorter. (didn't want to bloat the public API main/ with another factory)
assertThat(info.files).hasSize(2);
One of the original issue raised was regarding this permission check; since its going to run in the caller's app space (and not across an IPC) its not really guaranteeing that the permission check occurs validly. You'd need to do the actual sending of the intent from Telephony so that it can do the permission check there.
mediationAdLoadCallback is not required here. The code should be something like: if(mediationRewardedAdCallback != null) { mediationRewardedAdCallback.onAdFailedToShow("Failure Message"); }
Replace with Objects.requireNotNull
Would it make more sense for these error messages to end in periods since there aren't any related messages added after them?
is 500 really not included?
Apache commons is already present; can replace with if (CollectionUtils.isNotEmpty(contentParts))
We should not use Optional
log and throw
Is it helpful to log the error as a warning? if understand correctly we assume the error is going to be an auth error, maybe log helps to debug if it ever fails due to some other reason.
you can use wizardPage.finish(TimePeriod.getCustom(2500));
same question as before.. why isn't this handled in the base class.
@ndinu @alegmarra Is this correct? The expression has to always return a number
@vparfonov maybe starts with <username>- ?
The output should be as before. That means you should print what the sysout was printing: String.format( "%s %s %s", GdbPlugin.getDebugTime(), TIMEOUT_TRACE_IDENTIFIER, message )
I would ignore empty notifications and would log warning.
Missed it at previous review. Question - why via getVmDao()? and not via VmStaticDao()?
the MaintenanceNumberOfVdssCommand is used to put into maintenance several hosts are one command. Wouldn't having the parameter set for all of the hosts being put to maintenance end up with activating the callback and stopping the gluster services by all of the hosts ? Is that the desired behavior ?
"remove merge" is hard to understand
This test appears to be duplicated.
ditto for 4
What was the problem with logging the condition?
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
can you reference the enum values here?
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
extra space
I think this can be simplified to experimentFolder.getFolder(experimentName);
Can be removed
check for null before adding it
I love LinkedHashSet's :-)
would it be simpler to read with streams / filter/ Collectors.toList() ?
provide style as parameter to above methods
use style provided with callback instead
add style as parameter to initLayerIcons
optional: if you look at my PR you'll notice I made a type of Task that uses the type system to force you to handle merge exceptions at all call sites. Since you are pretty constantly doing instanceof checks on the exceptions for these operations you may want to consider something like that.
Can we inline getArguments().providerInfo below? (Trick: use Ctrl + Shift + N)
What about caching the list? AFAIK this method will be called multiple times on the same connection.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
ligically i'd say addVmToDb ends here, and from here is images handling
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
This method should override the one you specified in LoginContract
Can you use inline returns carriesUnmergableSack() ? ... : ... please?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
I believe that this is the same as Objects.hash(readName, pairStatus);
In general, we should probably be moving away from client-side validation where possible.
getSelection() should be returning the current selection
Remove the redundant null checks.
Code style
Check code style for building mvc test rules on my latest commit on PR #556
Code style
Rather than signaling this condition via an exception, maybe a better approach would be to have a globally unique instance that signals a hole.
Use equals for comparison checking rather than ==. It's flagged as Sonar violation
nit: Might be clearer to do: int bytesAvailable = data.bytesLeft(); output.sampleData(data, bytesAvailable); sampleBytesWritten += bytesAvailable;
You need to send cookie here.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
In my opinion, there should be another class/classes containing methods used by both servlets. This will help have smaller classes and avoid static methods which are harder to test.
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
Remove the catch block for IOException.
We should log here why the generation fails. Taking an input stream is a bit dubious? It could be: - not at position zero when we start reading - another thread could be reading concurrently - caller might not realise we're reading through it Is there a way to make sure we have a new stream that only this method is using?
Here an exception should be thrown if we have a conflict
Add final keyword.
Here a Set could be used instead of ArrayList
The logic in this function isn't entirely correct. The standard specifies the type of the init-capture in terms of the 'auto' type deduction rules, so let's reuse the 'auto' type deduction logic. If we factor out the logic in this 'else' branch [1] into a helper function getAutoInitClauseForDeclarator() that takes a declarator and returns an ICPPASTInitializerClause, we can compute the type as follows: IASTDeclarator declarator = capture.getDeclarator(); ICPPASTInitializerClause initClause = getAutoInitClauseForDeclarator(declarator); if (initClause == null) { return ProblemType.CANNOT_DEDUCE_AUTO_TYPE; } return createAutoType(initClause.getEvaluation(), null, declarator); [1] <LINK_0>
We probably should log and rethrow this exception, correct?
Instead of looking for the presence of the new keyword, you should check for presence of initializers. Currently, you will have an issue with the following code :  final long[] array = new long[] {3L, 4L}; // Should be compliant
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
Collections.singletonMap() ?
null? why not just a () -> {} ?
Why aren't you using 'createNic(..);
Why aren't you using 'createNic(..);
nit: s/result/fileList/
I think you need to do this and the next line in a finally
resourceLocation + "swaggerFiles" + File.separator + "APIScopeTest1.json" can be used here
So the algorithm here is: * if unencoded file exists, return it * if encoded file exists, return it * encode the filename if required * trim the filename and return the file Have I got that right?
Don't forget to delete this
Could you parameterize all the logging in the binding, in order to avoid lots of unnecessary object creation and garbage collection?
just remove the fileSize from here... and that's the only change you will need.
We required braces for single-line if statements.
huh? please inject a TimeSource that enables you to simulate time - that sleep needs to go
I've been going back and forth, I think I'd find it easier to read the answers as responses to the method calls i.e. List<Int> answer = whenModuliAreRequested(9); and then make assertions on that. I also think that thenOperationFail is misleading as it could fail anywhere in the when chain but the test will read as if it failed according to your sequence of commands. I almost thought I caught something, but I just had to reread it.
Style-nit: Parens aren't necessary around the conditional.
Please don't use platform encoding in tests.
I think the FileOutputStream should be closed at the end
suggestion public void onTabLoaded() {
why exit here ?
Nit: Debug logging (and elsewhere)
I think this can be truststorePasswordAlias instead of the string?
Why the name of the resources directory is "property-resolve" ? Can we have a meaningful name that goes along with the test cases?
Don't use 5.2.0-SNAPSHOT, this will break the test case in next release, Instead derive it programmatically, based on the current version.
Could be final?
value varchar(65534), type varchar(20)
need space after if
These tests should also check the name and url are showing up correctly in the TaskData.
You don't need this extra empty line
This doesn't test what it should. It should test that a non-null list with zero items is returned when there are no results.
I think the granularity should be 1 seconds instead of 5 seconds here.
Why adding unneeded braces?
please use formatter
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
Please, avoid using the RepositoryLayoutEnum.MAVEN_2.getLayout(), as I'm thinking of removing this (you can check #437 for more details). Where possible, could you please use Maven2LayoutProvider.ALIAS instead...? Thanks! I know, it's going to be tricky to remove this enum because it's used in places like Repository for the default layout.
Are we sure that getCanvasHandler() and event.getCanvasHandler() are always not null values? Otherwise, I think we should use Optional.ofNullable(..).
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
move "SELECT" to StringBuilder constructor call above.
":where_clause:" and 14 are sprinkled around, maybe best to add a constant for both?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
use existing constant
This can be reduced to java if (!new File(path).isAbsolute() && relativeTo != null) { return new File(new File(relativeTo), path).getAbsolutePath(); } return path;
Yes indeed, fast copy/past
You can also import staticly assertEquals.
Name it folder, or reuse doc maybe? domain is misleading.
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
Instead of doing this, I think we can override isQuestionSkipped in FeedbackContributionQuestionDetails instead. That's called earlier in this action and sets the answer to be empty so this branch is taken.
logger says "Unsubscribing"
please put the ".dst" into the Constants.
UTF_8 is one thing that can be really useful to have a static import, for readability.
No need to check if the file actually exists or is a project?
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Can revert this removal of a blank line as it's an unrelated change.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
This method is not specific to jar files, right?. Write it in a more general way?
== false is a bit silly :)
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
Is there any way to avoid this call on every swipe?
Does mean there's no signal for "the user typing out a correct entry, not clicking on the entry in the list, and then clicking on the next question" which results in the value being set? Clicking the ">" or swiping would do it, since that triggers a "get answer", but I wonder if, say, losing focus should also attempt to set it?
How about using try catch instead of if else?
how about we redirect to the non deprecated method? The only downside is that the closure cleaner will be applied on the AssignerWithPeriodicWatermarksAdapter.Strateg but I think its fine.
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
use existing constant
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
The exception message doesn't reflection reality:  "no query or collectionCallback is specified"
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
@xpdavid is this the right thing to do?
This test fails today but should pass in the future once ARC is implemented. So I would replace it with a test checking that we do not try to switch a count based resource to a memory based one.
Reads like a problem that still needs solving
vcore is a unit of cpu. If we are using memory instead of mb, we should use cpu instead of vcore.
You can use assertFalse for these.
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
Indent like this to improve readability.  populateAssignedLabels(state.getInitialLabels(), state.getRemovedLabels(), state.getAddedLabels(), state.getCurrentSuggestion());
node.getDistributionType() == SpatialJoinNode.DistributionType.REPLICATED
node.getDistributionType() == SpatialJoinNode.DistributionType.REPLICATED
I think we should be able to pull DetermineJoinDistributionType and DetermineSemiJoinDistributionType outside of if (!forceSingleNode) check in the PlanOptimizers
should reset interrupted status with Thread.currentThread().interrupt()
Is this a reason to have separate if statement instead of while (!shutdown)?
we probably should never ignore an interrupted exception, even in tests (at least need to call: Thread.currentThread().interrupt();)
This should be getModified.
Personally I think it's clearer if you move this line so it comes immediately after the call to assertSimilar(), inside the try block.
I'd rather this method be split in to : "getMasterEquivalenceOnEOpposite" and "getMasterEquivalenceFeatureMap" with this second part you introduce. Do note that filtering might help here too : Iterators.tryFind(diff.getEquivalence().getDifferences().iterator(), Predicates.instanceOf(FeatureMapChange.class)). Not really necessary, but might make the loop cleaner (and remove the "break" while we're at it :)). I don't really like where this concept of "master equivalence" is going (yes, I know I'm the one who introduced it :p). If even more cases carry on creeping up on this, we might need to try and find a better mean to detect them and reorder (or rethink) the equivalence relationship.
Can add  Utils.nonNull(segmentsFile); Utils.regularReadableUserFile(segmentsFile);  here.
Immutable?
sampleNames -- unless there is a case where columns don't represent samples.
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
I am not convinced that using the stream API here is the right choice. What we are doing is to do computations with side effects. For that I would always prefer a traditional for-each loop.
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Using logging would be definitely better, and maybe the exception should be rather rethrown (even if wrapped into RuntimeException)
This will not include the line break. Probably should append('\n')
It is the perfect case for a try-with-resources.
you can just use a primitive long here
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
Use TreeMap to keep the order.
We can move this audit log to the common method. As this is common code for all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception)
Can we log the object as well? At the very least the object's class. I would also consider this to be an "Error" level, not Info.
Why removing the throws declarations?
Why delete this line?
Should we have a version of createStubSecureCredentialsStore that takes a String argument and use it in the rest of the tests?
use -1L constant
Can this be private, or is there another use case for default attribute outside the builder's call?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
I assume the 0xffff is to deal with the down casting from long to int and making sure that it's a valid positive value?
We should either use DataSize for these or add the appropriate unit in the log message.
also, at this point in the code, the plugin is not loaded, only PluginInfo is read from the jar metadata (correct me if I'm wrong). The loading actually occurs on line 74. The log could be misleading.
setBounds(Bounds rect) has protected access in BasePropertyWriter and that's why jenkins fail (it is not possible to compile this PR). Will check the code, but I need Full downstream build to test this PR properly.
Is it Strict-Transport-Security: 31536000 or Strict-Transport-Security: max-age=31536000 ?
you should make sure that its setting the object of the relationship to the expected filename in all these tests.
I think better to use string concatination, as info log level this might called lot many time and string concatination has better performance the String.format. Another place where place I could think we can make more use of make logging, if present the file full path instead of file object.
should we throw an exception here?
If you did this in the reverse order, you would prevent races... so blindly delete and then check if it still exists.
No need for else here.
the rpcs use shouldLoadMetadataIfNotExists to check to load metadata, but this method also calls shouldLoadMetadataIfNotExists again. Is that intentional, and why do we need to check again?
"Path validation" instead of "Request validation"
This test method has no asserts to verify the results of the send statement operation. How does it verify that the send statement operation succeeded rather than simply not failing.
this smells... never use NULL, never ever :)
suggestion
I think this is the condition for !editable, i.e., readOnly.
while this has been an if-else previously, can we please convert this to simple statements editable = ... setEditable(...)
verify is probably more trendy
_sigh_ we need a better logging strategy.
The setup of updatedKeyStorage is not needed if fireOnlyUpdatedPanes is false.
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
please replase MojoExecutionException for a new generic DeploymentExecutionException
What about using FileUtils.moveFile() here instead?
still not loving null returns and the null checks that are needed then. :crying_cat_face: how about throwing a different exception here? e.g. throw new IOException("some cool message")
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
As discussed, a metric would be useful.
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1);  =>  assertThat(violations).hasSize(1);
assertThat(violations.isEmpty()).as("Violations are not empty!").isTrue();  =>  assertThat(violations).isEmpty();
- [x] Why create iterator twice...?
With the new out-factored structure, hopefully we can get rid of the "backreference" to the workbench here.
You should add an additional check: does this outline correspond to the current diagram editor ?
If it is then do what exactly? If we don't want to do anything do we need this if(..) block at all?
This seems like a good place to use our LocaleUtils class instead.
Better get and validate details when map is not empty.
This will probably fail to deploy. appengine doesn't support java 8
you could use filter + ifPresent
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
since we already perform checks on the project there, I'd put this in searchProject for consistency
We can use defined constants for project natures at org.wso2.developerstudio.eclipse.platform.core.utils.Constants class
Use the 2-argument constructor.
Ik. Maven has logging facilities. We should use them.
I feel that these services are kind of "hidden" in the registry implementation here. In ORM there is StandardSessionFactoryServiceInitiators apparently for a similar purpose. Maybe it wold be more transparent to do it similarly? Or could these entries be registered in the integrator instead?
I'd prefer ImmersiveEngineering.MODID, that should eliminate any possibility of typos. And the compiler should inline it, so there won't be any difference at runtime.
wrap INSTANCE = new IndexClient() in another if (INSTANCE == null) { check - this is known as the double locking technique
isOverrideLuns() operate on the value, so basically you stil have NPE here when OverrideLuns is NULL, do: model.getStorage().isSetOverrideLuns() ? model.getStorage().isOverrideLuns() : false;
This is comparing for equality values of two different enum types, which should never be equal. Did you intend to use org.ovirt.engine.core.common.businessentities.storage.StorageType.GLUSTERFS?
don't we want to copy the name from the model to BE?
minor: no need for final?
suggestion  refresh still shouldn't be necessary.
Same here, also using values that can only be represented as a BigInteger would make sense. You could use new BigInteger(String), for example.
mapper.readTree(new String(Base64.getDecoder().decode(params[2]), UTF_8))
Does not compile, but not really important.
this for is exactly the same in all the array tests, let's move it to a private method
add style as parameter to above 2 methods
Shall we directly pass the mapboxMap to the getRoute method as an argument? Since there seems to be only one usage of the mapboxMap in this activity.
use style provided with callback instead
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
actually calling .layoutData(new GridData(......)).create... should be ok here, correct? like you changed from supplier to layoutData in addFiller()
this should return parent2
Much simpler version:  return ( symbolTables.get( program.context().source() ) != null && symbolTables.get( program.context().source() ).symbol( name ).isPresent() ) || ( symbolTables.get( context.source() ) != null && symbolTables.get( context.source() ).symbol( name ).isPresent() );
Let's try sticking to the current style add final and use it as return value
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
This should be ops().run(net.imagej.ops.Ops.Image.Equation.class, out, in). That way if someone writes another specialized CoordinatesEquation op, it could also be matched.
This should be ops().run(Ops.Transform.RealTransform.class, in, transform). That way, in the future, someone could write an op which is a specialized version of this and it could also be matched. Please change this for all your other realTransform(...) namespace methods as well.
I think it makes sense to use builder and return ImmutableSet...
spacing
These should probably be getJSONArray() since we handle the exception.
again, since next call is System.exit(), write to STDERR.
this.fileStates.remove(absolutePath); is correct.
we should probably add a maybeEscalateHeadsUp() here if we are on the keyguard and remove the one in screenOff, this will be safer and ensures that we never have a heads up on the keyguard.
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
Maybe change DEFAULT_PUBLISH_TIMEOUT to DEFAULT_PUSH_TIMEOUT?
avoid having logic here. pls decide what kind of targetTab we need on the caller method,.
You can also use StringUtils here, like StringUtils.format("Exactly one of %s or %s must be present", target.name, max.name)
I think this lines are not required, but never mind.
Why not MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Arrays.asList(range1, range2));
please break the line
Replace by Map<String, String> result = new HashMap<>(map.size());
healthyWritablePartitions
is it necessary for this to be synchronized when the map is concurrent?
Use the enum Dark...
final
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
Use ConfigUtils:isBetaFlavour
Can you explain a bit more about this?
Use ConfigUtils:isBetaFlavour
It's written nowhere, but I'd prefer to have curly brackets even for single line.
This will work poorly if there is a lot of small groups (e.g: we will flush small pages and constantly resetAggregationBuilder). Additional condition here should be that aggregationBuilder accumulated enough groups.
Don't we need an index-based AST?
Met List:  @Override public boolean inputIsConnected(int index) { return index < inputs.size() && inputs.get(index).isFullyConnected(); }
same question
if we implement that offset we mentioned, we could even map negative elements here with a negative offset :)
Please include clientTelemetryEnabled in toString() API
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
You might want to not over-complicate it and keep the toString of the Optional perhaps?
formatting
createEntity and why is EntityType a parameter? in that case it should be part of GameObjectDTO. in either case i dont think this is a solid way to handle creation of objects. We have the possiblity to give the client different collections of objects in joinGame and thus we may have different methods for object creation. I do however think that having the single collection with gameobjects is the best approach, but gameobjects that have fundamental differences (could be character) may need their own collection
Same as above here: use .isEmpty() rather than .equals for the empty checks.
the connections collection is never used so this change is superfluous.
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
Can revert this removal of a blank line as it's an unrelated change.
shall we do the same for empty string ?
suggestion: rename to output
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
To be more efficient you can use TreeIterator.prune to skip subelements
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
It is here that runtime.matchesFilters(pickle) should be used to select the pickles to run.
Should this be CF_METRICS_METADATA_NAME ?
I wonder if this should be BatchReadTimer.... I know the Astyanax does Batch, but Datastax doesn't.. so...
Is there a risk that this query requires PAGING instead of loading the whole table to memory?
do you need to add CRC here?
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
You could also use -> Objects.toStringHelper() from guava
This is a great optimization. Should this point to first character in the ASCII table ? Also lets verify that this for UTF-8 encoding as well.
Can you duplicate the logic from getDiscriminatorWithoutTimestamp here (ie leave getDiscriminator as it was). getDiscriminator is called a lot and any performance we can squeeze out the better.
Maybe you can use Guava's Files.simplifyPath. Saves some lines...
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
Add default to the switch
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
Does this update instance or return a new copy? Because if it's the latter then a new instance needs created for every invocation of this method. We only create the converters once but call them many times.
Let's keep things tighter here. Extra blank line
should this be the sink's timeout?
Change to return Response.ok().build();
maybe instead of this if else parseFromString could return ACCEPT_ALL if the argument is null or empty, wdyt?
The typing is not aligned with the declaration in RMRestInterface interface. Please confirm it's OK.
Where do you use this assignment to the local variable 'authorizedUser'?
Worth also checking LockClientStopped because it has pretty much the same meaning. I'd also vote for having a static set of all "OK" statuses and doing set.contains(error.status()) here.
There are some formatting issues prior to '{' shall we correct in all places?
I would add cache=true/false as a parameter.
Method name is missing from log message.
you can skip the exception, no? just set header and error here?
Is that really possible here given that the button is not disposed?
**DateTime.now()** returns the same as **new DateTime(System.currentTimeMillis())** but looks more readable and shorter.
prevent NPE when used by other developers
Would it be better to use:  java if (thing == null) { continue; }  If there are two factories that could create the thing, you will return "null" here and do not try to use the other factory.
I just learned that addItems actually only adds the group item for the thing (and its groups), but not the items for the channels (which is done through enableChannels). I wonder if we should hence find a better name for the method? Something like "createGroupItems"?
In case the thing is null we should imho also query the database here.
it might make sense to provide a recordDiscarded(int) instead of this silly loop. (and above)
As mentioned above, why don't we making it a non-static method?
Could you check for null or empty? Via StringUtils.isBlank
nit: merge with previous line seems no longer than 80
Same here, this method return void because we don't want to have nuxeo-java-client outside this class.
matchAll will internally still copy the entire match set, so in case of hybrid matching, this will not perform as expected
We shouldn't expect this to be an Expression. Fix the test rather than having it handled here.
Can we add log that the configuration setting from query is ignored?
can you change this impl to be addJobProperties(job.getConfiguration()) ?
Please add curly braces around blocks after conditions
child
I think this can just be file = file.getCanonicalFile();. If getCanonicalFile() throws, the assignment will not be executed.
this should probably fail on receiving interrupt
Should be Refreshing_X and use NLS.bind()
better use WorkspaceJob to prevent refresh is triggered prematurely (see commit 786698088)
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
this check should go [1]
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
repeated ...
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
newWindow is false in this case only (the perspective stack has a selected element). You'll need to calculate this even if there's forcedPerspectiveId set.
This line should be: if (platformName != null && !library.getPlatformName().equals(platformName**.getKey()**)) return false;
Cache the call here and above.
Why iv.removeValue(i, this) and not iv.removeValue(i, aCause)?
Error message "workspace" parameter seems to have been lost in translation
In general, we should probably be moving away from client-side validation where possible.
is there a reason you don't just return this here?
could we make this log line have structured key/values while you're here?
This whole block can be replaced with functional style Java, as per example given in Epdq.
can this mask be precomputed in the plan?
After <LINK_0>, tuple should be singleton.
what if already bound to a value (e.g. in case of loop edge)? Didn't you have to perform an equality check here for the analogous pattern call extend?
Can just use diamond operator on RHS
":" -> delimiter?
What's the chagne here, just whitespace?
Apparently this method returns false when the wait time is exceeded. The old implementation was just buggy. It completed the future anyway and lied to the caller the indexing was done. The new implementation avoids this, but makes the caller potentially wait 2x the timeout. When waitForGeneration returns false the method should throw TimeoutException.
This isn't an SPI, so I'm not sure it's worth putting the implementation in the interface.
Using CompletionException would be more appropriate I think. Otherwise we would end up with longer ex-> RuntimeException(ex) -> CompletionException chain of causes.
why?
and return false here?
please switch clauses in AND operator. if quotaMode == disable, you should not invoke dao.
What about doing one thing at a time?  java View frame = Views.findById(this, R.id.login_icon_frame_layout); frame.setBackground(new BubblyDrawable(getContext()));
Can't be set in xml ?
move setUpToolbar()?
I would have put it after the createAnnotationAndAddSubscription call.
Put it after updateAnnotation.
Yes this is the first thing i tried. But when I tried to empty the previous mails I couldn't get it to clear. If this works then fine for me.
Why not in combination with above do this: setValue(value, false);
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
Minor: same as in other number check, WDYT about checking for the decimal point?
In lines 41 and 42 you're using o.get("port").isString().stringValue(). Pay attention that method JSONObject#get not as simple as it may seem. I think it would be nice to move o.get("port").isString().stringValue() to the local variable. Also it would made these two lines much more simpler for reading. WDYT?
the steps 35, 36 and 38 are not neccesary
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
Change Object to String
seems like this variable should be called json because it 'aint yaml...
I would maybe use String.format("%n") for platform specific line separators instead of introducing a new replaceNewLine() method which alters the "code under test". => I'd rather transform the code into :  assertThat(request.body()).isEqualTo(String.format("{%n" + " \"key1\" : \"value1\",%n" + " \"key2\" : \"hello {{test}}\"%n" + "}%n"));  WDYT ?
Do we need to check if manager is null? If not, maybe we should remove geofence manager check?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
Can't we use lookupConfigString instead? Ideally we want it to be configurable globally in the config instead of per-device.
Have you checked that the test fails if the this assertion fails?
Added for debugging?
These should not be here. If you want you can log at debug or trace level, but tests should not produce output under normal circumstances.
addAll or stream?
addAll? Or stream?
shouldn't this be ArticleRelationship?
It looks like right now when a connector is made diagnostics aware, There is a lot of boiler plate the connector needs to do to parse out commands and parameters. We could consider creating a library or utils that helps diagnostic aware connectors to reduce this boiler plate. We don't need to do this right now. Something to consider for future enhancements.
Might want to propagate exception back to the user?
same here - might want to propagate exception here?
Conventional header capitalisation, please.
As discussed on the mailing list, probably best to remove the query.
You could put "?format=xml" on this request to ensure that it is removed in Resource-Parent.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
please add vm id for the log messages in this method
please add brackets after the 'and'
Isn't it possible to use empty diamond? Map<String, E> map = new HashMap<>();
so it records stopped time only if all workspaces are stopped? Shouldn't it be all user's workspaces?
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
wrong code format
can't we use optional?
Oh yes, can change this back to formatDateTimeForSessions and delete this method from TimeHelper? It's a workaround for this issue.
not even e.getMessage() ?
Same as above for toString(): <LINK_0>
Guava has Objects.ToStringHelper() to make it nicer.
Result.SUCCESS
Remove this code mean that when user do logout, the push will execute for ever? I think that logout should cancel the push process
Darn, I had overlooked that. Might be worth creating package org.eclipse.egit.core.internal; public final class SafeRunnable { public static void run(Runner code) { SafeRunner.run(code); } @FunctionalInterface public interface Runner extends ISafeRunnable { @Override default void handleException(Throwable exception) { // logged by SafeRunner } } } Then we could do here simply SafeRunnable.run(() -> listener.indexDiffChanged(repository, indexDiffData));
optional nit: File::getName
remove the debug trace
All lines between beginning of this method (and all others) and this one should become the setup fixture (@Before). Then, for the methods that require a writer or loader, you could just reference the CacheManagerBuilder field, and append .using(...) as needed.
Please include clientTelemetryEnabled in toString() API
Update labels to go with method names. Alternately, call super.toString for super attributes
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Why 0,8 if all we are setting is 7?
that class would be better with a builder, though I wouldn't ask changing it now
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
throw exception
reopen -> open
If we have optimized cardinality(filter(array_agg(orderkey), x -> x < 3)), would optimizing cardinality(filter(array_agg(orderkey), x -> x < 3)) = 2 be an overkill? =2 seems to be very low cost operations. Also, it might make sense to add some benchmark similar to BenchmarkArrayFilter, or even do a comparison run from Tpch query runner and add the result as part of commit message.
wrong error text
I think you might want "icsCode >= 1". ICS means "Inherited Certification Status" (i think?) and it is not a boolean but a count of the number of times something has been inherited... so it can be larger than 1.
What do you think about Comparator.naturalOrder() instead of null ?
Why don't we make inDegrees to ConcurrentHashMap also?
Setting variables to their default value on construction is a no-op semantically but still mean instructions executed which causes the construction of the object to take longer.
TextComponentTranslation allows ITextComponents to be passed to it, so the user's name should remain as an ITextComponent.
This function returns false if the players inventory is full. You should probably do something related to that. (See the obsidian bucket for an example)
Could we skip this if the bucket amount is 1, and just set the type to water bucket?
nit, Collections.EMPTY_MAP?
are we guaranteed that this mapping is the only thing stored in the metadatastore?
There must be a more succinct way of doing this using streams.
I'm not sure it is a good idea to include this in the equals - two accounts are equal by virtue of their properties - not on their snapshot versions, correct?
better to use Strings.isNullOrEmpty
I think we should use leftOperandList.containsOnlyConstantAndParamNodes() here just to be consistent with the right.
this else seems redundant
@necosta Can you handle it with try-with-resource as well?
Should be in finally?
This line causes an endless load on linux when a node has zero children.
this will be called by the superconstructor.
use a lambda
Should we only assign the external ID if it changes?
Would it be better to move the null checks to the SignInCredentials constructor? This way, you can guarantee that SignInCredentials will always have non-blank fields. Similarly for SignUp and Email.
Should we have an else that throws a "impossible code path" exception? This way, if we ever add another channel and don't update this code, we'll get an exception instead of a silent failure.
This should be done inside checkIfImageDiskCanBeAdded(VM). If the disk is a direct LUN, getStorageDomain().getStorageType() will thrown an NPE.
perhaps unite those two if statements
Shaerable??
No space between STARTS and WITH??
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
reference would be concatenated w/o a separator. Is this intended?
The value for this test in the develop branch is the correct value. Changing to this value is a bug.
It's sort of important that it was _Integer_.MAX_VALUE, as Long.MAX_VALUE wouldn't work. I'd prefer this stay explicit.
Shouldn't you rather log directly?
unrelated change
exactRef
will this be null in some versions?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
String key -> String columnQualifier, and also update its subclass
I think protected might be more appropriate
java assertEquals("Unexpected failure code", ERROR_SUCCESS, result);  Try to provide as much information about the failure - in this case, not only that it has failed but also why.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
You can now use [RegistryHelper](<LINK_0> here
Why is this needed?
Add default to the switch
This needs to be changed. 1) It turns out that the spec was changed and 'N's are allowed in both the REF and ALT fields, so they should be treated just like other bases above. 2) '_'s are acceptable only in the ALT field (so NOT if isReferenceAllele is true). But they are also only allowed as the ONLY character (so this check needs to occur outside of the for loop). E.g. if ( wouldBeStarAllele(bases) ) return true; and wouldBeStarAllele() would check that it's a single base == to '_'.
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
This can also be package private :)
Another FYI, not a required change: note that there are some "gotchas" when using String.split with a regex. [Here's a nice breakdown](<LINK_0> If this was high-performance code, you'd probably want to compile the Pattern ahead of time, and split using that instead. I only learned about this a couple months back.
Same question. value is not annotated @Nullable
Please replace with a singleton
Yes, the 'contains' can cause a problem when a normal Java file has any string say "String moduleName;". Since we don't have a JavaElement in our case and also considering the effort required to reset the configs, I think we can leave this template without syntax coloring. So, your patch set 2 will be fine here.
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
seems like synchonized is not needed here, given increment/decrement already protect
Add the original ClassNotFoundException as cause.
Here, source and dest should be specified as @NonNull, it would avoid the null check below, and won't throw an exception if the compareTo method is called with null as dest.
Is 20000 a github limit?
You can directly call "copyFileToTestProject(Activator.PLUGIN_ID, DATA_UNIT_DIR, ECORE_FILE, SESSION_FILE, VSM);"
this doesn't looks good at all :( let's log the exception using Logger.warn().
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
what this line is for?
should(times(1)) is the same as should()
Remove the matching given method call as well.
There should be 3 different applications in the returned list.
here schema is always not null
Should something be logged or thrown if this is reached?
to make the whole backend/frontend interaction clearer, we should move all the read/write to conf and udfcontext into setInput() Those three lines can go to setInput() as they are not costly and don't need to be cached. That will remove the interaction between setInput and initSchema. initSchema is only called in setInput anyway.
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
I don't think we need this catch - this is handled by the boolean return value.
This only runs on Gtk3. How about trying to set this to not run on gtk2 instead? would this work on cocoa/win32?
Using a value that will never occur in practice is a hack to express "always render the initial value". I'd rather express this explicitly, e.g. by omitting the defaultValue parameter.
how can this happen? and should we check for null like in stop?
Use context.getCapabilityServiceTarget().addCapability(...) if possible.
Use ServiceRegistry.getRequiredService(...) here, as it is impossible that the service does not exist.
I would prefer that you use a map to the boolean value followed by a orElse(false)
this should just be type != Schema.Type.STRING (you can compare directly for enums). It is not valid for it to be an array. If it is, it means the field is an array of arrays.
it doesn't make any sense to allow boolean fields, as this model is for text. It should be a string or nullable string. Don't need to support an array of strings either, should just have an optional split pattern as a property that defaults to whitespace.
does it really make sense to allow float and double? It could potentially go out of memory easily, with 0.000001 different than 0.00000001, etc. In Java when you check equality of floats and doubles most IDEs will flag it as a warning.
no System.gc() before/after?
Maybe add a verbose message to the fail, with the loops number when the error happened (may not be the same reason if it's the first or run X)
Other test suits have a line with perf.tagAsSummary() as example below. Do we need that here, too? perf.tagAsSummary(pm, TEST_SUITE_NAME + ':' + testName, Dimension.CPU_TIME);
still for DAO
Pretty sure you meant to send your new command type here..
please check if not duplicate with the method in quota helper
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
Generally we don't check for GTK dev versions. GTK3.21 is a development version, so this call should be GTK3.22.
- This method shouldn't be public, instead make it default. - Add a space between method-name and braces.
Is the purpose of this to show the user the REPL prompt again?
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
unnestChannelInputBlock -> newInputBlock
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
Did you intend on nesting the code block in a paragraph block? If so the method name should be changed to indicate what this test is about.
please keep the buildVmNumaProperties a void method and access the vdsId fron inside
I think you could avoid the GSON dep by just calling  java inspect(launchEnv, objectId, "{{.Config.Volumes}}")  or something along these lines.
[optional] assert that the response status is OK
isEmpty()
Would it be possible to fix workspace object as soon as possible in the chain, so we would avoid ifs like this in the code later?
Use workspaceId here and below
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
Maybe just inline this into the for loop that walks over the caches in getCaches(), and fold getCaches into this method. There isn't a lot left and you remove a completely unnecessary intermediate O(n log n) TreeMap insertion step.
There must be a more succinct way of doing this using streams.
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
the definition can move to the else block
the update is unneeded, the method is called before the disk is saved in the db in line 131.
1.can we have those two conditions in setQcowCompat() to avoid repeating them? 2. if not - let's have them in one in condition with &&.
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
what if the account id, container id is 1? I think its probably better to do something like "current id + 1" so you are sure it is different
It may also be fine in a lot of situations to just cast it, since presumably nobody is actually trying to cast the returned Void value to a Void, so there should never actually be a bad cast at runtime. But, eh.
Can you explain why we should use Scheduller in this particular case?
assertEquals
Hi @xstefank, This is a minor point, but I would suggest using a status like 456, something that wouldn't arise otherwise. You could get a 404 by getting the URL wrong. -Ron
Conventional header capitalisation, please.
Local variable could be declared List instead of ArrayList. Is this worth caching?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
calling Thread.isAlive() seems like a bad sign. I don't think fixing "query engine source single" or equivalent should be considered out of scope here
Inline
again about redundant things - else block here and above is not needed,
We can validate only if validation is running?
Maybe you could do this with only 1 remote call?
Would it be better to hold this a member variable or maybe even break it out and put the resonsbility on the client?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
KFSConstants has a constant for a single-space string if you want to use that here instead.
@pwillworth why not use File#separatorChar ?
what if extension does not return VALID_TO? I guess you have null pointer exception.
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
should be: valid_to = default if we have valid_to from extesion valid_to = min(valid_to, valid_to_from_extension
reference would be concatenated w/o a separator. Is this intended?
is comparator actually allowed to be null? It looks to me like it isn't (it has to be DefaultComparator if not set explicitly)
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
These parameters are too complicated and redundant: baseURL and baseURL + id
The method name for handleScheduleTask suggests the method deals with scheduling a task. It looks like something like handleScheduledTask is what actually happens.
Has the code formatted properly? As it looks like the indentation is not even.
I think we should also allow here a comparison with a String (fullId) and Metdata (map)
use java.util.Objects
use java.util.Objects
can we have test case for this method? Like pass in a list of scopes and see if it returns the right DC
Unnecessary (and incompatible); revert.
why not null as value?
Gson doesn't run on these versions so I don't see any reason to include them.
I'm pretty sure this line doesn't compile. You can't use the bitwise function | on booleans, so if it does compile it's treating it as if (block.getTypeId() == (Config.getInstance().getRepairAnvilId() | block.getTypeId()) == Config.getInstance().getSalvageAnvilId()) Regardless, I'm pretty sure you meant to use || instead.
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
This is not the proper solution and there are many other characters which this would not solve for. Proper changes are needed in com.twilio.http.Request.buildURL()
can be inlined into a single line by using Streams
next time you can leverage switch case for ENUM
Why do the other String.format changes use Locale.ROOT where this does not?
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
1. You could just make calculated limit a field that you set in the constructor instead of reading it here. 2. If you don't do that, I would make it final here. 3. Would it make sense to have a lower default value, like 100? All of these are trivial and probably not necessary.
Thinking it might be better to just choose the newest version available and setting that to the default version (in the case that there is at least one left).
I know you only added one additional information to the log, but what is the reason to create an object array? Why not using the vararg logging method of slf4j's logger?
Do we need two debug logs here?
This should be done in a proper try finally block. If a reinitDatabase method threw an IOException the semaphore would be irreparably broken.
log should be initialized when was defined [above](<LINK_0>
Instead of removing "bbbb" which is the longest element so won't have trailing spaces, try removing "a" or "c" as it's a better test.
Same as above - make sure 56L is in array and is removed.
Make sure to test when 10.0 is in the array and you're removing with a 10 int argument.
Ugh. Why do we have updatePresenceStatusForXmppProvider(pps) and updatePresenceStatusForXmppProviders() that implement the same logic twice? :/ I know that's not related to the PR, so I don't expect you to fix it
One implementation of Ref.getPeeledObjectId() (the one in SymbolicRef) seems to be so expensive that it would make sense to cache the result of ref.getPeeledObjectId() in a local variable. Or do you know we will never deal with symbolic refs here?
Why is this not directly injected into the component? Is it not available at construction time?
Perhaps put sendError(ex); after the branch (since it is the last statement in each "leg" of the branch.
Why?
So, technically, it is possible for a Sequence to get used more than once. Meaning that with this setup, we can actually get multiple decrement()s for a single increment(). We don't use them multiple times right now, but I think it would be better to be safe. In order to be safe, though, we have to do the increment on the Sequence.toYielder() call instead of here. This ends up introducing a delay in when the actual incremental happens, which is unfortunate, but I don't think it's the end of the world. I think we should move the increment into the toYielder() method of the ReferenceCountingSequence<>, and we also need to make the ReferenceCountingSegment thread-safe and aware of when it has been closed. Once it is closed, it should reject increment() calls (let's make it return a boolean and set it to false once it is closed, meaning that it is not safe to use the instance) and return null for all of the other methods that rely on the underlying buffers.
Check if value is null.
There is no use for creating new util methods to create ProductData instances. You can create a ProductDataTranslatorTest instance and call initSourceObject() instead
This logic is very similar to encodeNullsAsBits, hence, for consistency: - remove mask variable - fold nullsBufferIndex++ into ByteArrayUtils.writeByte  private void encodeRemainingNullsAsBits() { byte value = 0; for (int i = 0; i < remainingNullsCount; i++) { value |= remainingNullsFromLastBatch[i] ? 0b1000_0000 >>> i : 0; } nullsBufferContainsNull |= (value != 0); ByteArrayUtils.writeByte(nullsBuffer, nullsBufferIndex++, value); }
I feel like this test and the above test have switched titles.
Is this even possible? You just created and stored this ticket
Please use the addTicketTransfer method. This is duplicate code.
The SerializerException is completely unrelated to the operation codecs - you should throw something else
else could be better here..also some duplicate code can be avoided (from 139-142) if that part of the code is made common. Can we also abstract the allocate difference between sequenced and normal elements and use a template pattern here?. Again possibly a future refactoring.
Consider slicing the ByteBuffer instead of allocating another byte[], a bit more math to compute bounds, but less allocations in the end.
this can be an info
can we make this an error please
Should this be "Recieved info"? Or should it be deleted?
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
why not make "update" a constant too?
collect on new line.
Seems like info would be more appropriate.
we can set variable directly here.
There are many command with VM in the name so please run add it only for specific commands. The code needs to be generic because we will have soon other events.
This looks like it can use the new isEmpty method
Can even use Iterables.filter(locations, SshMachineLocation.class), given that it's only passed to an Iterables method afterwards. That would save the subsequent casting as well.
When I did expunge(true) on a jboss7 entity, I saw logging of:  2014-01-28 22:18:47,089 WARN brooklyn.management.internal.LocalEntityManager@2524e205 call to stop management of unknown entity (already unmanaged?) JBoss7ServerImpl{id=mPXYvab1}; skipping, and all descendants  This is because Entities.destroyCatching will also unmanage. So you want an if-else, to only do the mgmt.getEntityManager().unmanage(entity) in the else block.
I'd use getPathAsString instead of getName to provide unambiguous info.
let's just remove this function
Use org.apache.flink.table.utils.EncodingUtils#objectToString
here too we could use getClass().getSimpleName()
There is actually yet another error here: this should be java int start = Util.toIntUnsigned(getValue(ir));
Magic constant.
I see that this is symmetric to the implementation in Size but are these short circuits really necessary? Long#compare() will usually just do the right thing .
you need to check that keyValueSeparator is not -1 (ie no = in the line)
"".equals or StringUtil.isEmpty.
This is not the proper solution and there are many other characters which this would not solve for. Proper changes are needed in com.twilio.http.Request.buildURL()
remove
style nit: no braces around single line
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
Decompose this into multiple lines for clarity.
Can this be moved down into DropboxActivity so that less classes needed to know about USE_SLT? Maybe a starAuthentication method on the base that this calls on click and it decides which Auth method to call?
wait.forElementVisible returns WebElement, so you can assign the value to avatar here and then remove the line below completely
please move CSS selector to field in this class private final String .... = ".ve-ui-mwSaveDialog-viewer.WikiaArticle pre"
remove this line
no need to define this variable that early, move ruleIndexer.indexRuleDefinitions(disabledTemplateAndCustomRuleKeys); after dbSession.commit(); and get rid of the ugly variable initialized to null closing the connection is not that important. The correct code would pass it to ruleIndexer.indexRuleDefinitions anyway (or it wouldn't really be closed so that a single SQL session is used by HTTP request)
Should be done before opening a db session - for to fail fast.
Should this also handle the suffix 'es'?
OperationException
Minor: probably QueryFieldType.fromName would be better than just fromName to make it more readable.
Arrays.setAll() is cleaner
I prefer the createMock because it is more strict. Can we just add consumer.host(), consumer.port() in the mocked consumer object?
Would you please remove the unnecessary type argument?
Why not passing the expected return value as an argument to mockOffsetResponse(), this way you can control whether the mock object should return true or false.
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
This helper function seems to only be used by fetchUsers and perhaps it could live as private instead of public until someone really needs it. Cheers!
Please log to Log.e instead of printing the stacktrace.  Log.e(TAG, e);
Message seems to be unused. Remove this line?
suggestion if ((command instanceof AbstractDataCommand) && ((AbstractDataCommand)command).hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP)) {  (needs an import as well)
Use parameterized logging instead of string concatenation
we don't use braces around singe line blocks
isEmpty is probably more consistent with other equivalent methods like the ones in Collections.isEmpty(), etc. Just a personal preference
Why not: if (value.names().equals(value.toString()) n = value.name().toLowerCase().replace('_', ' '); else n = value.toString();
you are really testing everything !!!
Use org.apache.flink.table.utils.EncodingUtils#objectToString
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
what if result is empty?
Debug line needed?
optional: can take the opportunity to add braces
Not necessary to call getType here.
I think it would be clearer to wrap persisters in a synchronizedMap[0] instead. [0] <LINK_0><K, V>)
This looks like it might be a merge error. I would trust the AggregationDataStore branch over your own here.
Can you please add a WARN log stating an attempt to stop the driver when it was null.
Is it really worth checking before setting it?
Won't fix.
Local variable could be declared List instead of ArrayList. Is this worth caching?
Style issue: @Override shuld be on line above the method declaration
This will throw redundancy warnings in IntelliJ
You don't need this line because of green 31.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
return Collections.emptyList();
Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.
I found that rounded corners were not rendered correctly on the bottom. I will also push a fix for this.
Please, refactor this abreviation. <naming
See my question above regarding using mocks.
See my question regarding using mocks above.
Also since the "incorrect" metrics name is out in our previous releases, but fixing it we are effectively breaking user's compatibility. I think this okay since we are fixing a bug, but would still worth clarifying it in the upgrade guide docs.
put an empty line after
This method returns null for unknown schemes, why an exception is required for a null name?
Shall initialise using newArrayList(txnId) instead of 2 statements.
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
You could use the content of the input field to filter the list of proposals. The list of proposals may be very long.
Since we're returning a new set anyway, why do we care whether it's immutable?
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> escape), we should avoid @Nullable parameter in the constructor.
inline
Should something be logged or thrown if this is reached?
Condition seems unnecessary since INT4 is returned any way.
this state does not exist...
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
We are using assertj for assertion, please use this instead:  import static org.assertj.core.api.Assertions.assertThat;   assertThat(logger.isErrorEnabled()).isTrue()
@StefanPenndorf Are we introducing a memory leak into the test suite here? If nothing removes the LogCatcher when the last runs then presumably it continues to accumulate log entries until the JVM exits?
The logging actually happens on the "client" side. So we'll need to setup the log level there, maybe using @BeforeClass and @AfterClass? I tried to move this code to the AbstractShutdownHookTest.deploy() method and it seemed to work.
needs to consider customAttributes?
You know what I was going to say here.
Please use instanceof check otherwise you're breaking the Liskov substitution principal.
L112 and L114 conflict. And validatedNumaMap doesn't seem to be used anywhere
Would it make sense to extract  /E /Y as constant and reuse it as kind of WINDOWS_XCOPY_OPTIONS for the other occurrence in line as well? Or add a parameterized xcopy method that can be used in both places?
:bug: IIUC this will not work at all for a RemoteJenkinsController-hence the complex trick for Unix. If you do not want to implement it correctly for Windows now, OK, but make sure this method throws a meaningful error when a remote controller is in use.
Clean up in a finally.
This belongs in the service that deals with the scheduler database
Magic number
can you pull this from a static string?
Pointless assignment
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
don't make getDetails return null, instead return an empty hashmap.
I would add a check here for empty string & also check if the namespace ends with a "." to avoid exception if someone changes the namespace.
Have String headerKey = key.toLowerCase(Locale.US) only once to avoid repeated case conversion.
This is not required since you are checking for null in view
Why did you change the modifier? If you want to change the list of bondingOptions, isn't is enough to do- 'getBondingOptions().setItems(newBondingOptions)'?
Please use interface List in the left side
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
Same here. Magic -1 :P
I tried running your test locally; the new question button cannot be clicked because the discard changes confirmation dialog is still open.
It it better to throw unchecked exception than simply print error because if error occurs then variable 'm' will be null and NullPointerException will be thrown later (line 16). try { m = MessageDigest.getInstance("MD5"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); //use logger instead throw new RuntimeException("No Such Algorithm: MD5"); }
Another way to do this would be to override setIsAvailable in PluginModel to be no-op. (This would allow us to get rid of the instanceof check here.)
since the MetricRegistry maintains a ConcurrentHashMap for all of the registered metrics, and examines it when you call register.meter(name), feels like you could do away with the same map-keeping here, as it is pretty unlikely to try to request a metric with this name that isn't a meter
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.
is this needed as anyhow last statement in method returns the address.
why did you remove this ?
"put(key, val)" will take extra lock that you don't need.
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
See if System.arraycopy is supported in GWT emulation library. Copying should get optimized to something more efficient in the browser than iterating over the list one-by-one.
Please construct it, passing in the file?
minor: you can return Collections.emptyList() instead
Do we know that it was a standby before participate was called?
In this block, you could avoid doing two conversions(String -> int, int -> String), and use directly the String value returned by execDmc.getThreadId()? That way this code will be ready to handle the "new" thread ids without change.
we need the modulo here, right?
constant or lineseparator from system?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
This is missing maxTotalRows
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Would like to see a check that these docIds are correct.
unused
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
Throw a NullPointerException if address value is null.
For each?
use Arrays.fill instead for loops
That's what I wanted to check with you on irc: we don't want the typeId here, but the metric Id (the string like MT~feed~resource~etc. I don't remember exactly the pattern)
optional: can skip this line since it is the default: if (!pushOptions.isEmpty()) { push.setPushOptions(pushOptions); }
Same here, correct the error messages.
I think we can remove this or downgrade to trace as we already log right before sending.
Log level could be trace? Since LOG_REPLICATION_ENTRY message is pretty common.
Why we need to update topologyConfigId here?
== false is a bit silly :)
Here again we want to do a loop to go back to sleep for the time left. Typically, you would compute and end time using long end = System.currentTimeMillis() + downloaderConfig.getDelayBetweenAttemptsMS() before the while loop then inside the loop you compute how much time left using left = end - System.currentTimeMillis() and bail out if <= 0L otherwise do a Thread.sleep(left). Then make sure to propagate the interruption outside the loop in a finally clause if a flag was set by your catch.
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
Do we need to show the gluster volume mapped to the storage domain ?
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please add them also here. Otherwise if you are sure none of the fields will ever be null you should remove it from the VmGuestContainerListModelTable.
See coding conventions in CONTRIBUTING.md
Should we put the check here too?
Unknown data source to calculate sha256 hash. This should not happen, please report this issue at <LINK_0> - is better i think.
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
instead of path separator create new path to make it generic
@sutaakar Any potential timing issues here to get the counter to be 0?
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
try using stream api for filtering
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate.
I believe the default is true, so no need to explicitly set it here.
should isShutDown be volatile?
better name needed
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
That was exactly what I want.
Maybe this big expression could be cached and not computed on each matches() call?
Cloning after calling getEyeLocation is unnecessary
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
add this selector to UI mapping at the beginning
add this selector to UI mapping at the beginning
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
ImmutableSet.copyOf() would probably read better here.
This virtually the same code as in AddImageFromScratchCommand - can't it be extracted to a helper somewhere?
Nitpick: Can probably remove both the if and the else (saving three lines) by starting with description = MoreObjects.firstNonNull(description, "") right at the top.
use lambda syntax
java TimeUnit.SECONDS(30).toMillis()  is more readable
Do we really want to move this from trace to debug?
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
What about Arrays.equals? Also possibly an intrinsic in JDK9.
nit: what about java nulls[i] = i % 7 == 0  ?
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
I'd rather we use Assertions methods to catch the exception from a specific place, as opposed to catching the exception from anywhere at all using @Test.
I think that Kie server should return HTTP status 4xx in this case (possibly 400) as request parameter cannot be parsed.
Google Java style always uses braces for if and while statements
please Log.SEVERE instead of printing to stdout.
i would put in threads.lengths as initial capacity micro optimization
style nit, put the { up with the if clause
>80 chars and extract.
Why returning a boolean here? I mean, you capture a checked exception here, and then you return false. Then, in the method where you use this markBackedUp, you will check if the return is false, and then you throw a runtime exception. Why not capture the checked exception and throw the runtime here? Also, what about unit test cases?
please don't swallow exceptions. Re-throw up the chain.
Return a Map<String, String> instead.
no need for the additional check if propertyParts.length is ok?
Note that there's nothing wrong with leaving logging in to help debug problems later. Loggers can be enabled/disabled while the program is running. If calculating the arguments are expensive, prefix with if (logger.isInfoEnabled()) "
Any reason why not to add this as const as well?
nit: this is building an object on every method call - it could just be a constant
can we refactor to reduce copy-paste with fromList?
can you move this to if(sorted) block?
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
URL Decode would be necessary for parameter name and value
no need for the additional check if propertyParts.length is ok?
else throw an exception with a descriptive message about whats wrong.
Magic numbers here and in the line below
Why do we need the extension? I removed and tested it with abnormally large bases and it seems to work.
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
This is incorrect. If ps is null, you'd still need to close fos. You need to rearrange the try block to acknowledge the existence of two resources - nesting is the usual approach.
This also needs to denote that "Nothing should process the 'cancel' signal anymore, even if the disable signal hasn't propogated out yet"
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
This is missing maxTotalRows
Sometimes we overload the createExchange method on endpoint to take in parameters so we can create the exchange that is specific of this component, eg the code below can be part of the createExchange(a, b) method
Nano time is prone for overflows. Millis should be fine.
Why the change from 0?
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (or warn) may be good enough.
Actually if we set the root path as below, we don't need to prepend the root slash, which is not that clean.  @Path("/zookeeper{path: /.+}") public class ZooKeeperAccessor extends AbstractResource {
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
Why delete this line?
typo: Sored -> Stored
Suggest adding a brief fixed sleep to the loop (1-2s should be fine here), to avoid excessive volume of API calls
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
make public static
why exit here ?
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
Why is this needed?
You moved this method only to another method, but is it really correct? If the scheme is http the default port is 80, so all is fine. If the scheme is https the default port should be 443 and so uri.getPort() should be checked to be 443. Okay, this only affect the strange situation if someone runs https on port 80, so we should perhaps never run into. But shouldn't it be fixed?
Are you trying to print the set of ids or just the size of the set? (The header doesn't match.)
@yingsu00 use toStringHelper
You may want to extract attribute.getAttributes() into something, so as to not repeat the call a few more times.
I think you need to add file.exists() check here
chields?
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceOperationResult and not FenceStatusReturnForXmlRpc?
Please reformat: else if ((getParameters().getAction() == FenceActionType.Restart || getParameters().getAction() == FenceActionType.Stop) && getParameters().getKeepPolicyPMEnabled() == false) {
why do we still have a condition on getParentCommand() ?
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
if the project doesn't exist, get() returns null, so we NPE during getProject() before we can get to the null test one line below. sadly, if you want to do this proj == null test, you need to store the ProjectCache.Entry result, test for null, and only then can you do getProject() to obtain back the project entity.
repo must be closed when you are done with it.
This IMHO introduces a rather surprising piece of global state into the translation. What about extracting a relativeTo(namespace) method that returns the appropriate Function?
The notInitailizedRules set is not needed.
Extract a method isArrayLike(symbol) or maybeHandleArrayLike(symbol)?
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
as mentioned we should maybe discuss this
Would it be better to check AbstractLogger.getRecursionDepth() > 1? The class name check is fragile
It should call getNameTextField().discardAllEdits(); instead.
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
String.valueOf() shouldn't be used to display integers since it doesn't consider the user's locale. Use i18n.number() instead.
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
Print algorithm here as well so we know which algorithm we're using?
What is the currentStateOutput used for? I don't see it used anywhere
Can you move the Config to ConfigKey instead?
This looks wrong to me, why throwing an exception when nothing has to be done?
Isn't below more readable? if(!ExternalStatus.OK.equals(host.getExternalStatus()) {
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
String.format(... is not needed here, or perhaps you need to passe the rule you process in it
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
please apply formatting
why not null as value?
Don't we have to say that this is uniqueId JDBC?
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
Logging.
I would just do e.addInfo("At line: " + lineno) as the exception message is already in the exception itself.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Let's add DataWord.ONE predefined value
Please use joinParameters method.
these arrays could be static finals. That would save allocating new ones all the time.
Also mention that they will be ignored
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
I think we can remove this line.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Extra newline
Should we add: Objects.requireNonNull(record)?
Do we need a partition lock, Do you think we should assume the underlying transport provider is thread safe?
RU compatibility?
Should be: in.skipIds(); in.skipId(); in.skipIds();
skipId
- this should delegate to call two functions above. - also, here name would be a bit confusing from displayName. Maybe @rongrong could provide suggestion.
operatorHandle
Let's use StandardFunctionResolution for the constructor; so it's more general
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as  PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL)  as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
You can just do a ptr.set(out) here. Will the out byte array always be the correct size?
Subtle difference for the ptr.getLength() == 0 case. Return true in this case as an indication that the expression was able to be evaluated, but the answer was null (as opposed to returning false which means that you weren't able to evaluate the result because you don't have enough information). Often both cases end up evaluating to null, but during filter evaluation on the server side, where we're operating on partial data, it'll cause the expression not to continue to be evaluated as we see more key/values for a row.
I'd rather put all there magic strings into constants
it looks like we were writing DESIRED_CAPABILITIES twice before
Note to myself: That's the first time I see this method being used in a plugin.
Why this change? Do we still need the doPrivileged?
Do you mean s.length() > len?
can this use the MMX StringUtils functions?
This should be atomic - looks like it was broken by INT-2856. There is a small timing hole where there's no recipients, or an incomplete list.
Can this affect the other versions that don't specify any families, like flush(TableName tableName)? Because region.flush(true), internally, loads all families before delegating to flushcache(List<byte[]> families, boolean writeFlushRequestWalMarker, FlushLifeCycleTracker tracker), but it doesn't seem we are doing this now.
return this.setBccRecipients(Arrays.asList(recipient))
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java .put(TESTER_NAMES, testnames.stream() .map(ProjectTesterImpl::maybeQuote) .collect(Collectors.joining(",")));
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
Ummmm, my memory does not check out this time :\
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Then should we just use it to save the update items?
There is Text.builder() for this, although I guess it wouldn't be a big problem to make this public..
Extract the 75 to a constant, it is used in more places.
call chDecoder.finish() and assert the return value
:smile: We prefer to use fail("BeanDefinitionStoreException expeted.") within try...catch
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
I still think it would be best to add public boolean can BeHurtBy(Entity entity) to Player which takes flamepass and invulnerability into account depending on the type of entity attempting to hurt it. The logic is much more centralized this way.
Maybe some not-null check should be added here.
Same here.. Should it be a utility?
I am talking about this code. Its converting. If this is only intended to add nature it should maybe another wizard?
What if the server is not associated with a DC but rather with an RC
This also happens when enabling legacy token options in the security configuration, and seems therefore inappropriate for a warning.
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
As explained in URIish, I think these two assertions should fails, but assertEquals("ssh://example.com/path", u.toString()); assertEquals("ssh://example.com/path", u.toASCIIString()); should succeed, and I think assertEquals(u, new URIish("ssh://example.com/path")); should also succeed.
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
this should probably be Level.FINEST
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
should it be endsWith instead? .class can be in any part of the string
move dir.listFiles out of this for loop, otherwise listFiles will be called multiple times.
Can i simply be used instead of getRandomStringOfLen(5)?
Logic is pretty broken. Let's make it in sync with naming, i.e. we should call decrypt only if isEncrypted. so inside get method do: if (isEncrypted(...)) { value = decrypt(value, CRYPTO_PATTERN); } and remove your 180-182 if lines...
the whole point of returning empty Properties is to avoid the check. And you need to update the end date in the copyright header for every file you change.
why do the values "true", "yes" and "1" equal true?
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
please add the itemName to log statement (using parameterised logging) for the sake of readability of the logs (also applies to the subsequent statements)   image you only have the log at hand and try to give advice where the problem could be.
i think on update we should use null as "don't touch device setting" (if its there leave it, if not don't create)
NIT: are we sure we don't want to call it 'compatVersion'? :-) also in subsequent patches I think the one letter adds more clarity :-)
please extract to a separate method (something like buildAddAllTemplateDisksParameters)
Unhandled
We can just use == instead of equals:  if (type == BOOLEAN || type == DATE || isVarcharType(type)) { return value; } if (type == BIGINT) { return ((Number) value).longValue(); } if (type == INTEGER) { return ((Number) value).intValue(); } if (type == DOUBLE) { return ((Number) value).doubleValue(); }
This filter allow any double value other than null, e.g. it doesn't filter anything, but nulls. Is this intentional?
Are we able to test this method ? Same for updateStateOfReplicas  method.
This should be using parameter.requiresCast() which is the logic the original method uses.
do you want to log the list too?
Use getBackend() instead
why do it again? already done in line 54
reminder: use DeleteImageGroup and extract to revertTask.
if this is called on edit, then this check will fail.
reminder - we should be agnostic to migration support.
s/ cpuPingMigrationEnabled/ cpuPinMigrationEnabled
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
Might be great to add some logging later, but the current chance follows the convention
we can refactor this if and the one below into more compact code by checking nonnullable using ternary operator
nit: no need for else clause here
Any particular reason why we convert to String here? I'd rather have it as long
see if we can change this method in instanceDao to accept instanceid (I bet instanceid is what get used in db query anyway). This way we don't have to load instance on the line 132.
I don't think you need this since state ids are supposed to be unique.
Please keep annotations on separate line :-) I suggest to use Java 7 utils for easier computation: if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } ValidationResult that = (ValidationResult) o; return Objects.equals(success, that.success) && Objects.equals(reasons, that.reasons);
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
This change does not seem to be related to the bug being addressed.
Then should we just use it to save the update items?
redundant ";" character
Move the namespace to a common place and a constant
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
_cough_
We need to be careful here because we're adding a node to the parent node outside of any synchronization block, which could cause problems.
This is the only place that add entry to the pool, is it the only way to fill the pool?
there is no change, why have you pushed?
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyProvisioning = currentlyProvisioningMap.computeIfAbsent( category, ignored -> new HashSet<>() );
Is order important here? Should the 2 collections correlate each to another?
I think lowercase l should also be considered
you should use a local variable instead of reallocating the argument, IMO.
I'd recommend < 0
invokeAll on an empty list returns null. So you may want to handle that
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
either if (!storageDevicesListCalls.isEmpty()) or storageDevices != null below
should you be checking for variable == null ? for clarity's and performance's (slightly) sake even if it might be logically correct and checked in getVariablesByRegex()
The keyTable.get(.. ) checks the cache and if no entry is available in cache, it gets from the DB. We can avoid the reading from the DB again here and check the cache alone. This is applicable for volumeEmpty check also but if we are going to maintain a full bucket table cache then it does not matter.
Please retain this immutable itself if it is only serving the ListModelListBoxEditor
change method signature to return interface List as opposed to a concrete class
Again, if there's no query executions in the differ, your changes shouldn't affect it.
In this test case we want to compare the empty table another another empty table. This should not result in any exception.
Doesn't this result in two calls to loadEnv (the other in checkConfiguration)?
I think it's more neater to not write extra lifespan/maxIdle parameters, but instead to write them where you write lifespan/maxIdle already and just add the possibility to send a new option which defines the granularity of lifespan/maxIdle. Your current solution feels akward since you're adding two new fields and the existing ones are not used. IOW, just add one more flag to the flags parameter here and you're done on the client :)
Maybe? suggestion log.debug("Error when closing datadog client: ", e);
format as final String[] array. Rename to errorMessage if possible
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
Symmetry (throw)?
this variable is unused
nit: Will this run for the entire 5 sec? I was wondering what happens if we cut the sleep times by a factor of 5. like 200ms and 1000ms.
Is this error handling enough? What are the risks of getting here?
segmentStoreStatus
If rev is null, what will happen. Shouldn't it bail at that point? Also, brackets are needed.
I think 15, 11, and 4542278 should be named constants.
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
Should we just add new ParseHttpResponse.Builder(ParseHttpResponse)?
Since Dates are mutable, startDate and endDate should be copied into the response to avoid downstream side-effects.
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
Can you replace IDs with names in this log message?
Brackets not necessary
instead of transport!=null, could we use globalConfiguration.isClustered() ? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
I'd reserve the All word for methods that work both on tx and non-tx stores.
Could use a long instead.
Should we add some warning message here, in case of ClassCastException ?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
why not null as value?
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
Need to use parameterized logging instead of string concatenation.
I'd make these numbers constants
You don't want to move them all to hamcrest?
Good catch. But I think we should still replace the File.separator with a ..
Will this file path work on all OSs! Will it work properly on windows? Can you use Java's abstraction and get the system's file separator?
not using mapNames and mapAge?
There should be a curly brace pair here for the if too. Otherwise, it will always return 0.
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
I would throw instead of just logging it.
This line is very long and complex. It would be better to externalize this check in a dedicated method in order to ease readibility.
I think the old code (using default on the switch) is better.
This can be private, I think
@chrisgioia64 Pls use StringBuilder, which is faster!
Couldn't we just define the String to begin with instead? Perhaps over-eager optimisation, but would some sort of fixed mapping/lookup for the already-known/'popular' cases (or just recently-seen ones) be preferable to calling this and concat'ing and substring'ing and replacing the same things repeatedly for each applicable message?
rename toRefresh
rename to hostCandidate
rename this to hostSpecification and then you can use host as the foreach var.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
here too we could use getClass().getSimpleName()
use SLF4J {} expansion rather than inline; there's a lot of commons-logging era log statements, and changing a line is the time to upgrade them
Put a Sage.rez() around "Forced"
This will run every minute while Jenkins is connected to Gerrit, I don't think that is good, nor what you intended.
remove this statement
Should not log under warn after testing for isInfoEnabled (or isDebugEnabled). Always log at the same level as if test. simply replace both with a single if (logger.isWarnEnabled() { logger.warn(...., ex); } (See JMS AMLC)
log should say store is not initialized.
suggestion assertTrue("Original state should be cleared on access", ctx().isOriginalEmptyValue());
Safer type: COMPARTMENT_CONTAINMENT_RULE_ID.equals(ctx.getCurrentConstraintId())
you dont need this line You can simply do Metrics.newHistogram in the line below
rename this to pointTagCount.received
rename this to spanTagCount.received
why do the values "true", "yes" and "1" equal true?
Class and constructor can be package-private as only used internally.
Should add the rule to config file?
Replace with retVal = wish1.getIndex().compareTo(wish2.getIndex());
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
why exit here ?
Here have to be 1 self link
isUnauthorized 403
isUnauthorized 403 ?
We can use private here.
suggestion // getSomeInt() has no user-defined annotation assertTrue("Normal field name (someInt) should have been found",
I thought that strict parser should generate orthodoxJson
I think we can just move this out of the done loading listener, which would keep the table in scope
remove unused whitespace
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
rename to column
Do we show some icon If visibility equals to public? If no, why? I think it is not good behaviour to show icon for private project but not show some icon for public projects.
Use constant?
Log as _error_ or _warn_?
should be Repeater.RAND
Generally, when logging an exception, we also log it's stacktrace. That way we are able to directly jump to the incriminated code section. It could be cool to also say what value we fallback to... I'd propose:  LOGGER.warn("Exception encountered while computed JMS next delivery (delay {} {}). Fallback to {} ms", delay, unit.name(), Long.MAX, e);
This should be log.error. Don't know why other statements here use log.warn
here you can avoid the log.warn, because you're throwing an exception
nit: Throwing an exception isn't a criminal offence - we don't need to read the cache its Miranda rights I think this is a bug if we get here?
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
tokens.size() can be used in place of zero to provide the size necessary
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
Please don't print stack trace like that. Either log it properly or ignore if the information is useless.
remove the explicit initialization?
Is the complete try catch needed?
Translate this log message in English please
Can we name this something other than it? Even i would be better to me than it.
Translate this log message in English please
Wrong method name in log message.
KualiDecimal objects are immutable, so it should be safe to set this variable to the original total directly. Also, I would suggest avoiding the doubleValue() conversion, to avoid the risk of having the calculations messed up.
This should be using parameter.requiresCast() which is the logic the original method uses.
Should perhaps make this protected (or package protected) since it's only used internally?
Default action is missing. Should not it returns requestFailed(null);?
This line is redundant.
String.format?
Does not compile, but not really important.
Check Args?
This should go before this.starts.next() as if this.starts.next() is empty, it will throw FastNoSuchElementException and the previous iterator would not have been closed.
I don't understand why do we need to call hasNext() here? we can just use this.iterator.next() and let it throw if there is nothing left
let's do Objects.requireNonNull(predicate, "predicate is null"). I've also forgotten in in various places and will add them later...
@vilchik-elena what if parent is a parenthesised expression?
Why not push/pop methods ? bit clearer IMO.
uncessary call to super. No need to visit further.
I would prefer it if you could save all settings (soundeffect and soundtrack) in the settings object, not the main object <review
I understand that "msSpent" is not needed for your task, but do you think that we may need it in the future? Or maybe we can keep the event-type forward compatible and add it later if needed?
I guess you are putting it twice. Here and in line 181.
*style*. same line
It is OK to leave it and prevent the user from specifying 'LOCATION' when they use a CREATE EXTERNAL TABLE statement.
can we use assertions instead of log? this is only for debugging. E.g: number of files == X or just > 0
right.getHighValue()?
Is it okay to use unnest like this here? What if one array has more dimensions than the other?
This is in essence an assignement. As such this method should be simplified to handle the fact that if left is zero, then resulting SV is the right SV.
cache?
The debug logging can be removed
suggestion assertTrue("Original state should be cleared on access", ctx().isOriginalEmptyValue());
Optional.map
use MoreCollectors to get an immutable collection?
Slight preference for the lambda variable to be rcc for ReadCountCollection.
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
Do a fetch following the delete to ensure that it was actually deleted.
Neater on one line, like the if below? for i in {1..x}; do
I think only calling setVisible is fine here. We don't need to also toggle "enabled" if you also omit the enabled flag in the menu xml.
Please don't compare to true. if (mSelectionModeActive && selectedTextView != null) is enough.
II think this code was also inherited but it might be clearer if the scope of this block was reduced to activity.getResources().getResourceName(item.getItemId()) and we just do a null check on resourceName.
This won't work... now your just breaking builds without proper checkout. Please make it throw AbortException.
How about putting the condition in the 3rd param to avoid duplication?
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
This should probably just be !parents.add(p) instead of !contains and then eliminate line 222. That would eliminate the double lookup and potentially detect a parent loop one step earlier (I think when a parent points to the original project)?
This loop does not detect and abort potential loops.
There are a couple of copy-paste lines here and there, could you please refactor it a little bit? e.g. extract the reader.readEvents-reader.commit loops to a method. The assertion part (listFiles, checking the count, removing from the expectedLeftFiles, checking the emptiness of it) might be possible to extract too, to improve the readability of the code. (e.g. void assertExpectedLeftFiles(String... expectedFileNames))
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
Why is it a list of lists, not just a list?
Yes, what Tor said: Please add a dispose() in LayoutCanvasViewer and chain the dispose methods.
This line is redundant.
Shouldn't we use empty list here ?
nit, Collections.EMPTY_MAP?
This will throw redundancy warnings in IntelliJ
Generics on the right side are redundant since Java7
I think we should close the StringReader after unmarshaling.
If you make the EMPTY_EXPIRES, you could use it here.
Dead statement? Loop will not loop if empty.
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Member variables should be prefixed with this -> this.databaseClient
suggestion var result = this.serviceRegistry.findServiceByExactServiceName(name, clazz);
Already adding network incompatible change, might be a good idea to encode more boolean flags into byte[], potentially also giving a way to add future changes. It's small amount of data so probably not really worth it as an optimization, but it would allow to add 5 new flags later while still allowing new clients to join old servers.
this is very confusing. minBlockY vs blockYMin.
wait, what? How does it even work?
I think we should create a defensive copy of the Map
I think we should create a defensive copy of the Map
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Minor: use AssertJ org.assertj.core.util.List.list and static import for readability.
@domhanak TL;DR: simplify to assertThat(mavenRepository).isDirectory(); Just 3 nitpicks about assertj usage: 1. The whole point of SoftAssertions.assertSoftly is that you don't have to thing about calling assertAll at the end (it does it [internally for you](<LINK_1> 2. You don't event need soft assertions for doing multiple asserts on one object, you can just do java assertThat(x).assertionMethod1() .assertionMethod2()...;  3. The assertion isNotNull() is redundant, because most assertj methods that rely on object being non-null [call it automatically](<LINK_0>
use standard assertions (no need of soft ones)
I know this doesn't really change from how it used to work but not all ListValue implementations have constant time random access - FilteredListValue hasn't. So it would be more efficient - at least in that case - to use the iterator instead.
I see that this is symmetric to the implementation in Size but are these short circuits really necessary? Long#compare() will usually just do the right thing .
use foreach style loop
I've been meaning to ask you if there's a class I can actually instantiate, thank you!
... you should be able to assert that the Transform offset X is correctly set here.
java when(plugin.editingCol()).thenReturn(editingCol);  is already done in @Before method
You should update this as well. This should require the MODIFY_SESSION privilege.
Same as above, just return the 404 jsonresult with the message you need.
Might be worthwhile to also factor this out into a method getInstructor to be consistent with getStudent below.
well, of course I can read the code and understand, but - still, maybe enum is better.
same question as before, about the value of heart beat..
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
Extract if conditions into named structures (variables or functions), like isThread, ... ? (Especially the last one is difficult to comprehend)
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
Can you use LOG.debug("CSS parser error: {}", exception.getMessage());
Do we really want to catch Throwable here? How about ClassNotFoundException?
Instead of having this be a part of every authorizer, we probably want to push it up a level and have it be a part of the code that calls the Authorizer.
instead of creating a new StringBuilder object, you could maybe do something like: text.append("Date: ").append(date.toString())); (you might need "\nDate: " depending on what the line situation is)
do you need to add CRC here?
Name doesn't look right
Missed one
Why do you want to ignore these exceptions? I don't think we should be acting on the exception's message like this, since the message can change later on.
Also, why return CoreException in some cases, and null in others? Are you handling this differently depending on the result?
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
Is it possible that a task maps to multiple partitions, while only some of them have old owners, would that cause us to encode a partial task here?
I guess it wouldn't hurt to explain what the exception means (our position is too old and has been deleted or compacted by the broker) and what we hope to accomplish by marking the task as corrupted (to re-bootstrap the stores from the changelog and return to normal processing).
are we guaranteed that this mapping is the only thing stored in the metadatastore?
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
Add a check for the number of warnings
Same as clean_after_checkout: is there no test possible that highlights the difference between clean_after/before_checkout ?
warning
these 2 for loops should be replaced by a single entryset iteration
suggestion if(value == null) { return null; }  We do the comparison the other way round and always use the curly braces.
why not using addAll?
The entire emails is the join link?
just remove the fileSize from here... and that's the only change you will need.
Oh yuck. ;)
typo "host address"
locks should generally be guarded by try {} finally {}-blocks - especially when some (foreign) non-trivial code is called while the lock is in place.
remove this "if", only keep the "else" - you must not set yourself HANDLER_MISSING_ERRORs, this is done by the framework.
Does this one need to be changed to '...' too?
If the message is not what you expect (e.g. NPE with null message), the exception raised by the test will be hardly useful. Use org.assertj.core.api.Assertions#assertThatThrownBy:  assertThatThrownBy(() -> assertUpdate(...)) .hasMessage(...)
All these count -> COUNT / from -> FROM are unrelated to this commit. I would suggest to do it in a separate PR :)
What if workspace is not running at the moment? It doesn't mean that workspace is restarting at the moment, or language server will be restarted as well, do it?
asRuntime(getRuntime()) doesn't seem very clear to me. Maybe asRuntime(getInternalRuntime())?
Not sure if instantiating the driver manually is a good idea.
Immutable?
why not just return it directly?
We probably don't need to catch this one, we can let it bubble up and be handled by the DefaultHandlerException The OverwriteDataException is good here as it's particular to this request
I am just not 100% sure why the conversion to BigInteger is needed here.
suggestion if (list == null || list.isEmpty()) return Collections.emptyList();
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
As it's a nullable field, null protection would be good just in case: if (occurrence.isValidated() != null && occurrence.isValidated() != validated)
How about extracting this expression into a method called hasWeightingChanged, and also use it in the updateDiseaseOccurrenceFinalWeighting method.
Can be simplified (SearchOccurrence searchOccurrence) -> searchOccurrence.getLineNumber()) -> SearchOccurrence::getLineNumber
Why are you checking the members inside the compute block? I smell race conditions since the membership change does not have to lock this map.
If this is supposed to be catch-all-and-ignore clause, make it so.
Isn't there a way to just refresh the single CacheStatus attribute ? Not a real issue, but it would be nicer...
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is on a DATA domain: [pseudo code] StorageDomain sd = getStorageDomainDao().get(image.getStorageDoaminIds().get(0); if (sd.getStorageDomainType().isData()) { // update status to illegal... }
Please, consider to add image details in both log messages.
please use getStorageDomainDao() instead of DbFacade.getInstance().getStorageDomainDao()
It seems like we can add two storage domains at the same time
name suggestion: isInternalDomain
1. No need to use warn, info should be enough 2. You can remove the redundant space at the end of the sentence. 3. Please rephrase the log to indicate this is related to Hosted Engine.
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first system-disk and skip non-system disks.
please add vm id for the log messages in this method
use getVmDeviceDao() instead of getDbFacade().getVmDeviceDao()
Should this be a write lock because we might delete the page if there is not enough space?
RocksPageStore will be in a bad state after restore then initialize.
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
Should be final
If this situation happen, I need to know some information to be able to investigate why. For this reason, I would add at least Audit event to the log.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Iterator could return multiple items erroneously and pass.
These assert are not needed here, the fact that append works should be tested elsewhere already.
Again might want to check the iterator behavior here.
& is not correct need to use &&. if data[0]==null then data[0].equals(Boolean.TRUE) will through a null pointer
suggestion  refresh still shouldn't be necessary.
I don't think it can be significant in practice, but why allocate an array (presumably on the heap) just to read the individual cells and then forget about it? Using 4 locals (on the stack) would be more straightforward (and possible marginally more efficient, though it can probably not be measurable). The only drawback I see is to have to invent 4 names. (Note: same "issue" in the other class).
Not sure why we allow null for the event list when the monitor gets cancelled, but not for the link list?
could you use Collections.emptyList(); ?
Collections.EMPTY_LIST
If we remove the null check, will it results in NPE? (Line 74)
The previous setting INSTRUCTOR_PERMISSION_MODIFY_SESSION is correct for previewing. This is correct for moderation only. Refer to checkAccessControlForStudentFeedbackSubmission.
There is no usage of checking responses for a specific session?
Sure, you are right. This saves a stat call. Done
We should take care of removing those files after the tests end...
That only passes on your computer... Use Hamcrest java Assert.assertThat(result.get(0), containsString("you are extending ..."))
I see, what I'm more pointing to is that we are testing multiple/all aspects of firingGroups per test rather than testing on behavior at a time. For example, it's considered a best practice for tests to have only one reason for why they would fail. If for example the firing group size were to change *or* if the displayName were to change, then this test would fail. At a more concrete level, isolating the behaviors makes it easier to see which parameters control which outputs. Hence I'm suggesting to pivot the tests to group and isolate the tests that verify display name, size, etc.. and do so independently.
Why is this the case? A more specific description could be the key, what is special about the new unit exactly that makes this assertion the case?
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
Nit: I think the mask is unnecessary, when you cast to byte the higher-order bytes will be discarded. suggestion out[i] = (byte) (msb >> ((7 - i) * 8));
A method similar to this but with first parameter Connection<T> would be more convenient for use in CPPSemantics. Such method could be moved to /org.eclipse.cdt.core/parser/org/eclipse/cdt/core/parser/util/CollectionUtils.java
please remove TODO and printStackTrace() and use proper logging instead
can we also have a test that validates the case when we have a none-string field in span_ctx? (Validation should fail in this case)
Maybe it's overkill, but do you think it would be useful to have a test that tries to get partition N + K, from an event type with N partitions (where K > 0)?
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
why you need this? isn't there is the same code below? For local typedefs?
Consider Objects.hashCode(object) instead of the ternary (but only consider, do not consider this a normative statement).
We decided to use Objects.isNull
btw, do we need try catch around destroyProcess?
My intellij inspections recommend using a method reference instead of a lambda here: this::postDecodeHelper
why are you calling the onGetUserListFailure method when there is a failure in counting the users?
I like that we create the operator here as now we push further down the runtime-related stuff. In the future we could have a translator that gives, for example, not an operator but sth else.
Why not making the following like:  Collection<Integer> ids = translateInternal(transformation, context); if (isKeyed && !isInputSelectable) { transformation.setChainingStrategy(ChainingStrategy.HEAD); BatchExecutionUtils.applySortingInputs(transformation.getId(), context); }  This will make the if () ... check being checked once. The same for the other translators.
Our current logging convention doesn't use !
This also blocks the ui thread. You could use ModalContext.run() instead.
I believe we should add if(isShutdown()) return; right after "for" begin
Still an NPE if there's no Folder plugin installed. The acceptance tests should give you the same result.
rulesList will never be null, widget#getVisibility always returns a list instance.
I know you just re-factored this code into another method, but I am asking myself why the getItem() method is called on the itemRegistry vs itemUIregistry in case of the basicui.
Suggestion, we can probably inline this logic for selecting delimiter into process method public static final String COLON = ":"; public static final String SEMICOLON = ";"; // On Windows we need to use semicolon, use normal colon on other OS String delimiter = SystemUtils.IS_OS_WINDOWS ? SEMICOLON : COLON Then we can just call items = process(depsModules); here
This variable name doesn't seem meaningful?
Better also check first Desktop.isDesktopSupported().
It could use a lambda, less code.
I don't think you need to flush() and clear(). Considering this init is specific to the test method, I would have moved it to the test method and would remove this setUp() altogether.
DEREncoder shouldn't be referenced from ASN1Encoder - the implementation of this method should just be moved to DEREncoder.
I think this should stay protected. Non-subclasses have no business calling this.
This looks suspicious: call to Optional.get without .ifPresent. You can avoid having those misleading Optional-s, if you replace .collect(groupingBy(...)) with .collect(toMap(SortExpressionContext::getSortExpression, c->c, SortExpressionExtractor::merge).
no need to specify type on RHS
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
This causes the warning Plate is a raw type. References to generic type Plate<T,S> should be parameterized.
org.apache.commons.lang.StringUtils.isEmpty(String) is available for null safe string checking.
subclass
Why not just have the property be a JSON array of strings?
we log this already for each batch, in BufferedRecords.add(), so let's remove this log line
What are the reasons for which a node wouldn't report a version? I think the first map operation should rather return the first node that's up and we should then use the information provided by that node.
I think this should have its own integration test as this is nth_value specific stuff only
This is not how you make an [unordered list](<LINK_0> in HTML. Example:  html <ul> <li>Coffee</li> <li>Milk</li> </ul>  produces - Coffee - Milk
Can you use an anonymous name for the maintainer? Not something from production
Move both to variables for consistency.
Safer to call: getFirstHeaderOrNull("Signature") == null
left over I think
testStr1 is not used in the test case anywhere.
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
there's no update anymore, right? we either create or skip (At least that's what I see in impl)
Is there a reason why these are called "value1" and "value2" instead of more meaningful names?
Remove this check after merging #139 to develop and synchronizing this PR with develop.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
This doesn't seem right. The JsonCodec in this handler supports either JSON or Smile, but not both, so we shouldn't accept both. Also, the error handling logic and getJson() API (used by error handling) assumes JSON. It wouldn't work for Smile which is binary.
if i get it right: if response is null, we will not retry. i think we should retry even if response is null. btw what caused this in your case? so it would be:  response == null || ....
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
what about making resolveExternalServers(String) part of the ServerResolver contract so that we don't need to depend on native server resolver being a subclass of AbstractServerResolver?
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This test would be useless if the map had been initialized in the class.
component will be instance of InputPort by default unless unless component is null.
Add a break to this if? Then, this condition is not needed.
This chunk here seems common to the three functions, plus the new Expectation.OnComplete<..> boilerplate. Maybe it'd make sense to have: abstract class OperationWrapper extends Expectation.OnComplete<OperationResult> { // implement onFailure here } Then the code here would end as: opResult.onComplete(new OperationWrapper() { @Override public void onSuccess(OperationResult r) { ... } } which is less verbose, and less duplication. Doesn't seem mandatory, but it would help a lot with readability for the next one to read it :D
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Try:  java final List<PoolBagEntry> bag = connectionBag.values(STATE_NOT_IN_USE); int removable = bag.size() - config.getMinimumIdle(); for (PoolBagEntry bagEntry : bag) { if (connectionBag.reserve(bagEntry)) { if (bagEntry.evicted) { closeConnection(bagEntry, "(connection evicted)"); removable--; } else if (removable > 0 && idleTimeout > 0L && clockSource.elapsedMillis(bagEntry.lastAccess, now) > idleTimeout){ closeConnection(bagEntry, "(connection passed idleTimeout)"); removable--; } else { connectionBag.unreserve(bagEntry); } } }
Ew, that just looks icky. Admitedly less efficient ... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer:  java for (PoolBagEntry bagEntry : bag) { if (removable > 0L && connectionBag.reserve(bagEntry)) { ... } }
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
This could be combined with the previous line.
setErrorMessage
That should be toHtmlForAnthology. You mixed those two up.
Why create a separate Kryo instance for every partition?
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
return Collections.emptyList();
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
Map
we never use NULL, it is a bad practice in general.
If you make the EMPTY_EXPIRES, you could use it here.
It is the perfect case for a try-with-resources.
This will not include the line break. Probably should append('\n')
@vzool one more printStackTrace ?
Can the filteredHeaderNames be put into a case insensitive TreeSet? Then this nested loop could be converted to a contains.
This function should ignore the local result and instead just merge the two incoming maps.
In Sunrise we follow the rule that unless a parameter is annotated with @Nullable, it can't be null. Therefore this line of code is unnecessary.
See objection to "standard neo4j.conf file" above
Update labels to go with method names. Alternately, call super.toString for super attributes
Why do we print a secret systemUserPassword here?
should just be inside try block
add a null check in 597
This seems defensive also, and it's also just a sample in a test. If the underlying method the handler invocation returns isn't expected to return null, then we shouldn't check for null and we should let the NPE happen.
this line is gone, why?
This is very odd; not the sort of thing you should catch. Can this be prevented?
since elements of the stream come from ImmutableList, they cannot be null, can they?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
same for this handler. depend on tunnel, not on the entitlement
suggestion
Typo: attemp_t_ToUpdate
We can probably partition on the QUERY_PARAMETER_LIMIT (may not exist in 0.9.x, but it's set to 32k by default) rather than the IN_OPERATOR_BLOCK_SIZE. If we opt to keep this as-is, we should probably drop use of CPRestrictions, as it won't add anything of value.
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
redundant ";" character
suggestion this.dataStoreMap = new IdentityHashMap<>();
Why is no this. used in lines 320-321 but this. used in lines 322-326?
nit: we don't do this (argument alignment) throughout the project, any reason to start with this method?
Why do we have this method here? Can't we have this like PostgreSqlEngine?
Space after if. Same HC/ICS stuff as above.
This won't work on blockdevice. Take a look at how the StoreMigrator does it.
This will gonna delete old label scan store if that was used which is a nice thing. In the same time, we will not gonna create the new index as part of migration for those guys and people will be forced to wait during the startup, while they expecting everything is ready to fly. I know that proposed behaviour differs from how it was before at the same time that is something we had complaints in the recent past and as well it sounds like a correct thing to do. WDYT?
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgWithFreshAcsrfToken, instead of getTokens and getTokenValue)
This function seems like a good candidate to return an Optional
This line is redundant.
Can you separate it into two lines as because of the condition in check style plugin i.e. you can't put more than 100 characters in one line, the build is failing.
Docs (<LINK_0> you must always check isConnected() before initia...
Lets not create a the local variable and just: sendScreenState(pm.isScreenOn());
Number of rows of input does not change since we don't allow reshaping of layers. Thus, checking the number of columns is enough.
Free?
Why change to create?
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
I'm curious about the design choice that requires a new object to be instantiated for every basic operation. This seems potentially inefficient if these operations have to be performed many times.
this should probably be Level.FINEST
this should be moved out of the try/catch at all filters
why is this ^ here?
can you please explain why to put false? the absent of property is a good marker... what is it used to?
log statementId as well?
**Intellij warning:** Initializing this variable is redundant, the same result can be done with: return "<?xml version=\"1.0\" encoding=\"UTF-8\"?><repositories>" ...
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
I don't see clusterId being used in sync-job. Is this required?
I'd add an always-printed log message here too to make sure it's remembered.
This can be static.
You should access the attribute directly
I don't quite understand this. A reply can't be "HIGHESTMODSEQ NOMODSEQ", can it? this whole loop can return null if a NOMODSEQ ImapList is found though, in which case CONDSTORE should be disabled for this folder's connection.
create a member for ClusterServiceModel
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
Could you please remove the checks for boxStore != null ? The lack of this particular cruft is one of my favourite parts of the services.
@super132 we can init decrypt/encrypt ciphers in Ctor, no need to create this each time.
inline this variable.
Remove unused binding variable.
Using instanceof here seems like a code smell -- is there a nice way to add a method to ApplyFunction that gets the necessary info out?
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
isUnauthorized 401
isUnauthorized 401
isUnauthorized 403 ?
@CheckForNull
Superfluous check I think-it has been a long time since Executors were reused.
btw, do we need try catch around destroyProcess?
doesn't Files.walkTree work here? or does that have a problem with this being inside a jar?
This if-else is redundand. Please replace it with just return deps; If no deps are added in the for loop, the deps will be empty ;) The same in the method below.
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
You can use assertEquals here as well.
It should be: combined.put(entry.getKey(), entry.getValue().toString()); With the current code I get: Parameter value [1] did not match expected type [java.lang.String (n/a)] With the fix it works fine. I tested on Hibernate 5.3.6 and querydsl 4.2.1 with this pull request applied.
Why use JDK assertions and not fail()?
Variable name should probably be change to bundle or subscriptionBundle since this is not a subscription object.
still think that we should log when there is a not found mapping
use final
This is very odd; not the sort of thing you should catch. Can this be prevented?
Should it be Locale.getDefault()?
replace this with java return scopes.stream() .filter(this::matches) .map(AuthScope::getProject) .collect(toUnmodifiableList());
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
NIT: are we sure we don't want to call it 'compatVersion'? :-) also in subsequent patches I think the one letter adds more clarity :-)
wrong logic a poolId should be retrieved from domain of disk and not passed by params, also a provided vm can be at wrong pool
These is NullPointer
You should have this loop also under the childStart loop
use Arrays.fill instead for loops
All of this can be replaced with an ExecutorService
It's too bad we have to resort to regex for this, is this format considered fairly stable and unlikely to change in the response?
why relaceFirst instead of replace
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
Debug still needed?
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
Format this line
This needs to not have the sunburst text, check out Skyrider Elf
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
Use {this} when referring to card names in text.
> I feel like site_id here makes more sense just because the only use of it is for the network calls. If it's used for network calls, it's not "local". Local_id was used for blogs/sites because we can have a mixture of self hosted and wordpress.com sites, so we can't use the id provided by a network response. Will this be used for wpcom sites only?
Why is COLUMN_SORT_TYPE text? Shouldn't it be integer?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
why public?
Well, if we decide to go this way, than it would be better to reuse accept(File) instead of logic duplication.
This doesn't get rid of the NPE. The method checkNotNull will throw the NPE. To fix the NPE you need to do an if statement for that.
I thought that we did not need to have this mapping in the compute engine
Default size not necessary.
why is it Collection of Strings (instead of String)?
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
resource.isExpired()
Does it really make sense to have a plugin with multiple secure-stores ? What would be the rationale behind it ?
Maybe instead say: log.warn(String.format( "Plugin name %s must match [A-Za-z0-9-]+ to use capabilities;" + " rename the plugin", pluginName));
"consider changing the plugin filename"
Does this do anything outside of test mode?
We don't have a test that covers all the browser action. Changing this here could cause a lot of trouble, unless you have exhaustively test all browser action. You need to change your implementation so that this can stay as it is.
cleal ?
I would rather use a constant such as com.splicemachine.primitives.Bytes.UTF8_CHARSET
again: removing the explicit initialization: worse, not better
is.close() should be in the finally {} block
suggestion LOGGER.trace("The service with name [{}] is not found in the cache, try to find it from [{}]",
suggestion var service = getCandidateServicesToMatch(serviceId)
Remove these. Use AuditableExecution registeredServiceAccessStrategyEnforcer; instead.
Should there be a check to make sure the asset is non-null before modifying it?
Maybe make seance create static variable for this?
You should check whether the global entity already exists, or set it to not persist.
Shouldn't this code run even if mHasWifi is false?
This is wrong; you're returning before calling super.tearDown() at the bottom of the function. Express this more directly: if (mHasWifi) { if (mWifiManager.isWifiEnabled() != mInitialWifiState) { // ... the rest of the wifi-specific teardown ... } } super.tearDown();
I know this is just a refactor, but please remove the return...super.tearDown() still needs to be called at the end.
after this line, call collector.getOrThrowException() to stop execution if there are problems.
nit: it's more readable in these situations to do:  if (inputSchemas.isEmpty()) { return; } // rest of logic  doesn't make much difference here, but is more true if the logic within the block is longer.
Do we want to check both getProjectId() and getJobProjectId() here?
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
If calendarName can be null, there are other places in this class that might need null-checks. If the calendarName cannot be null, null-checks in the hashCode are redundant, and should be removed. The same goes for the other fields.
You can use Objects.hashCode(Object...) from Guava here to simplify this (we use this in a lot of classes already)
There are a few other mocks higher up in this method. This can be moved to be with them.
Are these mock objects used?
Should remove, and use similar functionality in CoreAuthenticationTestUtils
These strings are not meant to be translated, so move it to ApplicationConstants instead.
Let's clean up non-generic keys.
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
no need for StringUtils, modules.keySet() will work nicely :)
now I get it... this is your own context, the key should be here as it is private. but why do you need this? all loaded extensions can reference each other using the global within base. need still to figure out why it is required in context.
Can you move this functionality to IjProjectPaths?
You can move the inner loop out of the outer loop so that you dont have to set all the fields for each split. That way you will be able to reuse the builder
Same error issue. I'd just fail rather than return a partial list.
Won't this cause a trailing comma on each line? To avoid that we could save all metrics in writeQueryResult and do the actual write in postCollect
Shouldn't this menu reflect either hide or show? Or does this one menu apply to the entire MTrimBar?
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
Not sure what is going on here, as String.format always takes at least two arguments? "Select" is being picked up as an actual class and not treated as a string for some reason.
I think Local.ROOT is probably a better choice.
let's use LinkedHashMap
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
These first two test methods are identical except for the slice creation, and can be replaced with a single method and a data provider.
Actually, wait, I'm confused. I don't think that 0 should mean MASTER_ID. Not all CollectProducers go to master.
Minor point, but it seems like the reading should be in a separate outer try-with-resources, rather than nested in side the writer.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
This is missing maxTotalRows
I think we should avoid printing stack traces and make the app crash... Could we setup an error activity or handle the error as transparent?
2-times the same thing?
If the fragment is good, rename to RecentNotificationsFragment and remove the old one.
suggestion if (containsHtml(text) && qualifiesAsConvertedList(text)) {
I don't understand what command parameters have to do with key bindings. The way you implement it you will also skip the adding of parameter values to the tooltip of menu items. Also, why is it necessary to distinguish between menu item and tool item regarding the tooltip?
I think that this method deserves to be protected and tested.
Do we have enough examples for same that will show violations for all the items you added in this input? None of the other inputs changed in violations, which makes me think we may not have enough examples.
Missed the full file name. InputRegexp.invalid.header => InputRegexpHeader.invalid.header
I'm not sure how I didn't notice this before, but this test is a lie. PropertyCacheFile can't be instantiated without a configuration, it will throw an exception. The whole reason the cache is empty is because destroy is never called to commit the changes made because we play with Checker directly instead of going through a 'normal' lifecycle. We specifically set the configuration with the line checker.configure(createCheckConfig(TranslationCheck.class));. So it is a lie there is no configuration. Also if there are no violations, cache is still filled with all files checked. Is this test relying on some code coverage? If so, let's rework this test around that. If not, let's make this into a more normal workflow and test all contents of cache.
No need for this step, just use this.attachmentList directly.
This is an indication that UNSPECIFIED_IPV6 should be not in the IpAddressPredicate , maybe in NetworkUtils? but I will not fight for this.
Most of the method is a duplicate of #set() so you should reuse it instead.
"don't add another exchange"
Use Constants.DOT_GIT. But actually if you want to test that a directory is a Git repository, use RepositoryCache.FileKey.isGitRepository().
org.eclipse.gmf.runtime.diagram.core.util.ViewType.{NOTE,TEXT,NOTE_ATTACHMENT} can be used instead of hard-coding the strings. Unless we expect these to change in future versions of GMF (as the whole pour here is to use the names from the version we migrate from).
I noticed that this change affects also getRequestURI method. It is mentioned also in the analysis. We should probably extend test coverage also for this method too.
Do we care to know how the login failed (no auth token versus wrong auth token)? If so, maybe we want different debug statements. I would be inclined to think they might be errors that we would want in the log.
LOGGER.info? Maybe LOGGER.warn?
suggestion long requestOffset = buffer.offset; CollectCoordinationResponse<T> response; try { response = sendRequest(buffer.version, requestOffset); } catch (Exception e) { LOG.warn("An exception occurs when fetching query results", e); sleepBeforeRetry(); continue; } // the response will contain data (if any) starting exactly from requested offset buffer.dealWithResponse(response, requestOffset);
Make non-null.
is this message misleading?
Please use ""
StorageHandlingCommandBase has: jobProperties.put(VdcObjectType.StoragePool.name().toLowerCase(), getStoragePoolName()); jobProperties.put(VdcObjectType.Storage.name().toLowerCase(), getStorageDomainName()); jobProperties.put(VdcObjectType.VDS.name().toLowerCase(), getVdsName()); So either rely on it or remove the super.getJobMessageProperties call above, but right now it looks like you're doing something redundant. Personally I prefer the latter (getting rid of super...)
I'd rather to modify ovirt-engine/backend/manager/modules/dal/src/main/resources/bundles/ExecutionMessages.properties: job.ImportVmTemplate=Importing VM Template ${VmTemplate} to Storage Domain ${DomainName} to job.ImportVmTemplate=Importing VM Template ${VmTemplate} to Storage Domain ${Storage} (same for job.ImportVm=Importing VM ${VM} to Data Domain ${DomainName}) and use jobProperties.put(VdcObjectType.StoragePool.name().toLowerCase(), getStorageDomainName());
is this left by mistake ?
Use static strings.
so by this all labels are escaped so you are not able to provide HTML code into the report and with it will be displayed as HTML (eg link to external server in description)?
Avoid variable names like event1
This should probably be stack not block.
Unused variable
As in DateWidget you don't need this variable just return binding.getRoot() at the bottom
There is something wrong with the button text. You set it to default here but it's not set to R.string.replace_bearing when we record bearing (only if we create the widget from scratch and there is an answer).
I think given you want to test the shared behaviour it's good to try and think hard about what the responsibility of onButtonClick really is here. For me what it does is ask for geo data for the widget. It feels to me like there could be an interface called something like GeoDataRequester or GeoDataFetcher with methods like requestPoint, requestShape etc:  binding.simpleButton.setOnClickListener(v -> { geoDataRequester.requestPoint(promp); });  In each of the different geo widgets you can have a test that the requestPoint or whatever is called and then those methods can be tested for some implementation of the interface (ActivityGeoDataRequester). Just to detail my questions here the though process I'm going through is: 1. I have shared code used in multiple places does it make sense to just test the behaviour in each place? 2. If not, what is the shared code responsible for? Is there some kind of interface/object/entity that could be responsible for that?
Add Override annotation
I think you can remove the surrounding if, it's quite safe :]
check with isEmpty() ?
Ditto about interfaces
Inline
Let's inline this (like we do for prefix.getCatalogName())
I almost settled for this solution as well, but then I tested Win7 at 125% and got {120, 120}. On GTK at 125%, I get {96, 96}. What this implementation effectively does at 100% and 200% is to return DPIUtil#DPI_ZOOM_100 (which is 96) as x coordinate. But at 125%, DPIUtil effectively uses a deviceZoom of 100%, which explains the different results. I'm undecided at this point whether we should change Win32 or GTK, but the two need to return the same at 125%.
use Arrays.fill instead for loops
- Points to Pixel conversion needed.
Should maybe be "SocketException has occurred"
Can you convert this into using a ternary operator?  this.diagnosticsLogs = stdOut ? new DiagnosticsStdout(this) : new DiagnosticsLogFile(this);  It makes the code less verbose.
suggestion } else if (statusCode >= 500 && statusCode < 600) {
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
nit: you can merge both lines above as checkNotNull will return the given argument
You may use 8 * data.length - ByteUtil.numberOfLeadingZeros(data). And check the residual against 0 or 1
Why would hdfsHost not be set? That should come from the mini cluster config.
There's no point to else here...
I'd inline these variables
An empty loop can be written as while (vcfReader.read() != null);
Remove blank line.
The first argument should be expected value.
Why change the initial size of the selectedProjects? It used to be projects.size(), now it's request.getSelectedProjects().size().
same for this handler. depend on tunnel, not on the entitlement
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Can this be private, or is there another use case for default attribute outside the builder's call?
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
String#getChars probably faster than this loop
prev is never reset so If an escaped backslash is found subsequent unescaped won't be deleted: For instance pattern "a\\b\c" should match "a\bc" but won't because unescaped backslash removal will stop after encountering first escaped backslash
The only reason you had to override next(), expose pendingObjects, and duplicate all of this code was for this r.has(BOUNDARY) test? Any way we can skip that flag test on the commit?
Math.pow does long to double conversation, which is inaccurate, try (double) 9007199254740993L <LINK_0> then just to convert it back to long (again, inaccurate) Lets simply do r.getDrivingTimeFromPreviousStandstill() * r.getDrivingTimeFromPreviousStandstill() ?
Probably want to add the filter here: if (objectFilter.include(this, r.getTree()) pendingObjects.add(r.getTree());
Is this a safety check? Whats the case where this would be null?
How about a private helper method to remove the above duplicated blocks? That method would take both propertyName and properties as params, to add property to properties if non-null.
stream isn't closed
pass in the metric registry
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
This change should be reverted too.
Make this a debug log. if (log.isDebugEnabled) ...
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Introduce a new exception and throw it here, since this is not related to model building but publishing.
Why is it a list of lists, not just a list?
it can be private, and remove method from interface
Use TreeMap to keep the order.
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
Need to 'put' in the cache, after the trace set has been updated - the put may result in the cached object being written to disk or distributed to remote node if we change the cache type.
The result of 'spanToNode(span)' should be added as a node on the trace. The list 'nodes' should then be set as the node list on the node returned from spanToNode.
RocksPageStore will be in a bad state after restore then initialize.
Is the right exception caught when HADOOP_CONF_DIR is not defined ?
don't need this try catch if FileCopyRecordWriter throws IOException
You could also use -> Objects.toStringHelper() from guava
do you need to add CRC here?
Why removing failure? It is the failure reason.
This should probably go to System.err, as goes e.printStackTrace()
Added for debugging?
Better to just add a throws to getPolicy and not catch IOException if you aren't doing anything with it.
Why reverse the logic? I thought we normally write termination condition first, before recursion.
It's not the provider, it's the future here.
.map(future -> future.exceptionally(e -> { CodeMiningManager.logCodeMiningProviderException(e); return Collections.emptyList(); }) ).collect(Collectors.toList());
Local variable could be declared List instead of ArrayList. Is this worth caching?
Don't we have to say that this is uniqueId JDBC?
I would implement this as a loop that calls describeSpotInstanceRequests every 10 seconds for 1 minute or more. Check Stopwatch from Guava.
why not this String nodeSourcePoliceClass = StaticPolicy.getClass().getName() ?
We already have an instance of SavingsService at the line 208. Can't we use that one instead of creating a brand new one?
The exact error message here will be a custom message coming from the "skip" operation, which basically tells the user that a studyType is not a skippable entity (that was another new annotation: @SkippableEntity. To make generic "skip/unskip" functionality, the system needs to know which entities are skippable). In the test client, it's just demonstrating that message.
This code is an exact copy paste of the code just 20 lines above, can we avoid this :fearful: ?
it would also be important to be able to specify a Locale
Shouldn't it throw some exception when date is not convertable? Lets imagine that at for example endDate String is corrupted (with a single character typo for instance). The user intention would be to have a job that would end at particular time. Returning null, I suppose, would lift that 'stop' condition. I am wondering whether it would not be better to throw some sort of our own custom 'validation/parsing' exception to make it explicit that there is an error.
These aren't equivalent. The StringUtils version checks for null and "" in one call.
This looks like it should be part of another Gerrit (according to commit message)
for direct calls on debug and trace, I would use an individualized Logger. Logger logger = Logger.getLogger(StompConnection.class) we should use Logger only for INFO messages with ID... as of debugging this, it gets fairly difficult to do it without the individual logs. Just wait till you ask debug loggers from users and it gets fairly difficult.
It is probably not necessary to use a mock here. One of the fixture in ServerFixtures should work just as well.
No need for a mock.
For the enumeration, can we not use ENTRY_TYPE id as test data? It can be confusing because we've used that as the standard variable to be returned (we are interested in enumerations of this standard variable). Maybe use TermId.CHECK instead as enumeration
You don't need this restriction and createAlias calls, I think you should have one restriction in place of the 2 lines above like this: Restrictions.eq("m.patient", new Patient(1)) Alternatively you can load the patient by the patientId first and use the loaded patient object in place of of new Patient(1)
what about stream_filter_prepend as described in the ticket ?! I think that for this case, I would prefer to raise an issue every time string.strip_tags is used literally, whatever the context.
While I applaud the use of format, this syntax may lead readers to think the value of add.size() is the argument to size. How about "add.size == %d != %d == distances.size" ?
why not just use packages as its name
To not to write the part between lines 352-365, maybe you can enhance FutureUtil#waitForever.
Could you try to benchmark with and without it? From my previous experiments, I often had System.identityHashCode() in my profiling but it was more of an artifact.
Add a check for the number of warnings
Same as clean_after_checkout: is there no test possible that highlights the difference between clean_after/before_checkout ?
We probably do want a constant for it in the metadata project in any case. I don't object to strings.
Why don't you use formatCurrentTimeForId() here like the line 217 below? Likewise for the line 115. We can pass the time as a parameter to that function for general cases rather than just current time only.
review the params alt and organizationName below
primitive boolean cannot be compared with null.
better Exception
This can be skipped before we even test isGitRepository().
better to replace the original call to Files.deleteIfExists(f.toPath())
You're still taking the performance hit here, as you're walking the iterator and storing the sourceId in a variable _only_ to be used in the debug. Instead... java if (LOGGER.isDebugEnabled()) { LOGGER.debug( "subscription is a site-based subscription starting with site id {}", sourceIds.iterator().next()); }
Insert a space after if
LOGGER.info("Couldn't get availability of source {}", sourceId, e);
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
Add new catalog options.
this migration becomes useless since analysis_uuid can be null
check if you can use fluent api to add the storm tag
This could be moved to VampirePlayer#onEntityAttacked. But I guess it is fine here too
Do we need to check here if this member is still a replica before clearing the counter (same as the check is done when clearing the record stores)?
Same as above, either introduce a local variable or just use getCompiledScript() in the expression, but don't reassign the volatile field.
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
Consider writing this more simply, e.g. using Collections.singletonMap()
No need to check whether this is zero. The for loop won't iterate. (I see you did so for a Log warning, but I don't think it should be a warning, the user can simply detect the empty array.)
no need to specify type on RHS
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we're not having so many nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
Isn't it better to user iterator().next() instead of creating ArrayList from Collection? getQueryReturnValue().setReturnValue(users.iterator().next());
We could keep track of the input watermark and emit the maximum at the end.
nit: Do this:  int taskId = Objects.hash(split.getPlanNodeId(), split.getSequenceId())) % numTasks;  As discussed in <LINK_0> ;)
ArchitectureType.forValue(rs.getInt("architecture")
This should be entity.setActualImagesSize
is this new line intentional?
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
Actually looks like you can make this method protected and call it from the OpenshiftClientFactory to avoid duplicated code. WDYT?
It might be useful to enable the logger as well.
what do you think about instead logging it where the other log statements go here? <LINK_0> I don't think passing a listener down to the publisher is great as its mixing two concepts, the listener has nothing to do with it
Why are you collecting these? The result is unused.
How about putting the condition in the 3rd param to avoid duplication?
It is danger to use equality tests with floating point values. Is it correct usage here?
Minor point, but it seems like the reading should be in a separate outer try-with-resources, rather than nested in side the writer.
Actually, wait, I'm confused. I don't think that 0 should mean MASTER_ID. Not all CollectProducers go to master.
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
This should probably just be !parents.add(p) instead of !contains and then eliminate line 222. That would eliminate the double lookup and potentially detect a parent loop one step earlier (I think when a parent points to the original project)?
Don't use default shell, dialog has one.
substring(0, 7) why 7? please avoid magic numbers
what you do is reasonably good as the class and method has default access modifers.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance() .getStoragePoolDao() .get(storagePoolId) .getCompatibilityVersion()))) end eliminate the else cluse from line 105.
In case of passed Guid.Empty pool id we'll get a NPE here.
Why assugning this and not just using storagePoolId
extract into method?
lowestTimeAxisOffset is used above. Looks like a bug in findbugs.
@Nullable but actually, why allow null here?
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
Why are we not using baseTestDir here?
Test case can probably be simplified.
I think the order of entries in these maps are undetermined. You probably want to sort both the expected and actual to ensure this does not randomly break in the future.
Program to interface, not to implementation - please change return type to Map<String, Object>
Ummmm, my memory does not check out this time :\
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
I think the logic should be more like:  if (context.isRoot()) { fetch root object } else { if (field is attribute) { fetch attribute } else { fetch relationship } }
Why did we switch out the old code back to this?
this can be done simpler using a sorted stream of param entries to produce output string
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
Have String headerKey = key.toLowerCase(Locale.US) only once to avoid repeated case conversion.
initialize with US_EAST_1 than null and remove else part.
This should be done in execute()
URL
pls log the "else" cause of this if
We should add log messages to this method about what's happening.
Do you want to rename subnet to newSubnetCidr to match the one in getStackParameters. I am assuming that this is the CIDR for the subnet.
if there is unhandled exception it will cause that opengrok will need to be restarted, isn't it better to check for Exception or Throwable?
Remove stack traces
:ant: multicast is one word.
We need to test the regular constructor without a custom serializer.
Is it required for the upgrade?
Note this will eagerly materialize the parameter Instant.now().atZone(UTC).format(TIMESTAMP_FORMAT) even suffix is presented. I don't think it's a major performance issue since suffix will only be presented in two places. @haozhun any thoughts how should we handle this?
@dkayiwa Are there any visits without patients? Should this not fail with an error?
now we can use configName
this is throwing errors when patients don't have an age. To get a patient without an age, create a new patient and don't set age or birthdate, but check child or infant or adult. I think it would be good to put this in a try{}catch{} statement, it would also help to check for null before using the age parameter
In the error message userid should be null instead of case_id ? Also in the jira issue, seems like owner_id was not defined while from the error stack it seems like userid is getting set to null. So I am a bit confused what exactly is happening.
We have quite a few isSimpleType( ) calls. Do we want to consolidate these into methods?
Could use a StringBuilder.
Any possibility of the module string being group:artifact:extension:classifier:version or group:artifact:extension:version? i.e., do we require custom modules to adhere to the 'exec' convention?
Should anyone be able to create a new instance of reference instead of GitProjectSetCapability? I would rather make it package-level.
Explain this change? How can beatLength be 0?
Technically this is doing needless byte to char conversion. E.g. were it a multi-byte encoding, then decoding is not worthwhile. My original thinking on HeadHandler was to have the principal buffering at the byte-level. E.g. a BufferedReader(InputStreamReader, /*tiny*/200) atop a BufferedInputStream. Then when all the needed readLine() calls are done to just read() and discard from the BufferedInputStream - probably not a byte at a time but with say a very small byte[1024] buffer. (Using readLine() here would defeat the goal of avoiding needless heap allocation.)
exiting, so STDERR
extract some constants while you're at it?
Rubbish
Please remove this line
Could this just be a plain getActivity() call? Any reason you need a BaseActivity for startSupportActionMode?
Again, on purpose to avoid the array list
Unclear to me why this would be done in a separate loop. This will be much more time-consuming. Suggest this would be a performance regression. Suggest instead iterating over the EntrySet of the attributes and calling the remove method of the iterator. There is *no* reason to do things this way other than misunderstanding how to deal with iterators over collections. It should be something like this: Map.Entry<Object, Object> anEntry; for ( Iterator<Map.Entry<Object, Object>> iter = attributes.entrySet().iterator(); iter.hasNext(); ) { anEntry = iter.next(); if ( ( (String)anEntry.getKey() ).startsWith( ATTRIBUTE_POOLING_PARAMETER_PREFIX )) { iter.remove(); // Removes it from the collection immediately and correctly } )
- indentation to fix - I think the second null check is nor necessary (the type can never be null and event if if was, there is no null value in widgetTypesToFocus)
I am missing why we're offering to delete a test when the user clicks on rerun
As above: private, 100 chars, use error result instead of doOnError.
Usually a "Builder" variable is never saved, since it is needed exactly once. Also, why can't you use AlertDialog directly without the full path specification? suggestion new AlertDialog.Builder(getActivity()) .setMessage(R.string.remove_watched_popup_warning) .setTitle(R.string.remove_watched_popup_title) .setPositiveButton(R.string.remove_watched_popup_yes, (DialogInterface d, int id) -> removeWatchedStreams(false)) .setNeutralButton( R.string.remove_watched_popup_yes_and_partially_watched_videos, (DialogInterface d, int id) -> removeWatchedStreams(true)) .setNegativeButton(R.string.remove_watched_popup_cancel, (DialogInterface d, int id) -> d.cancel()); .create() .show();
This handler is not used at all, please remove it.
I think in this class it is possible.
flagging that we should fix this in the next major version and move back to a parameter for the id
delete on exit?
Preconditions.checkNotNull(is, "Input stream required to create temp file for %s*%s", prefix, suffix);
'.'
no need for the "this"
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
I would retain the existing indexOf body to to avoid indirection in the most common case.
Is there possibility to use here some more specific exception ot it must be catch all?
I'm thinking to avoid having to work this out later we should probably also record the number of logical cores as well. I guess the most stable way of doing this would be counting the number of model name instances. On my machine there is also siblings, but idk if that's standard, esp on android.
We will leak the connection if table.close() or resultScanner.close() fails with an exception. I believe the proper way would be to wrap each close in a separate try block, and catch and log the error.
import it directly -> import static org.carlspring.strongbox.net.MediaType.APPLICATION_X_GZIP_VALUE;
same as above, you probably can use injected artifactPath parameter directly.
@ptirador why you can't use injected artifactPath directly here?
Well, you could make BeanAttributesConfiguratorImpl.qualifiers and types package-private and use something like:  throw BeanLogger.LOG.noCallbackSpecifiedForCustomBean("Configurator [types: " + Formats.formatTypes(attributes.types) + ", qualifiers: " + Formats.formatAnnotations(attributes.qualifiers) + "]");  Hm, BeanAttributesConfiguratorImpl.types should be final - pls add this change too.
Pull this change out. It's a temporary override.
field.getName() is not unique. For the purposes of ScatterplotController, field.getName() + field.isStored() is suitable and unique.
why wrap the shoSelectInstanceDialog result in a Set?
eObject may still be null at this point. The diagnostic is added to key null in the map. The connections currently always compute null as their business object and therefore they (all) receive this entry. 1. index = -1 maybe should not occur but does. In this case the problem should be associated with the parent object 2. decorations are attached to States, ChoicePoints etc. so the diagnostic should not be attached to the eObject found but rather to the parent object of one of those types. If none is found the diagnostic can be discarded for our purpose here
Do we still need this var? (Probably yes, just looking at the GH diff, so lacking the full context).
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
I would recommend putting these strings visible to the user in strings.xml
"our" => "out"
We won't detect if newProperties contains a property that is not in oldProperties. Shouldn't we? Why don't we just do oldProperties.equals(newProperties)?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
I'm not sure that's correct: what about code like alias\foo\bar?
remove final modifier.
Is there a reason not to use streams? I would prefer to use one style or the other, but not mixing them
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
This location parameter should be renamed as in other methods I think
Label should be reporting.parameter.onOrAfter
Same issue with usage of WRITEOPENW as in RemoteSageFile class.
Flush after you write the data....same thing for all the places you write data.
This flush() call and the one 7 lines down need to be moved up before you read from the stream.
What do you think changing the name to memory. We do not know whether it is in kilobytes?
I think you rather want to reuse Computer.getUrl, which escapes special characters in the URL. (But it needs to be fixed to use getName rather than getDisplayName. And getSearchUrl in both Computer and Node need to be fixed to use that implementation.)
Why create ObjectMapper on each invocation, instead of having ObjectMapper field that gets initialized via (package-private) constructor?
This builds the set on each lookup. It should be built once and then used.
Missing final
Missing final
strange, what fails? what is <jsp-file> you are using?
log.debug still consumes CPU. Should we avoid logging here?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
While I understand your concern, it's fairly daunting and error-prone to have to call computeHash() in (almost) every single method that would mutate this object (but not all of them). Precomputing hashcode is mostly useful when the type is immutable. I think it'd be more straightforward to just compute the hashcode on demand, especially that most - if not all of - Brooklin's code is not CPU bound anyways.
You can use Layout.INVALID_CLUSTER_ID
no longer necessary, after changes in xml.
Why do you use a static newInstance Method? Just do it f.e. like this: AboutDialog aboutDialog = new AboutDialog(); aboutDialog.show(getFragmentManager(), "dialog");
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
ParseUtils.isQuoted would be good for this.
Do switch instead of ifs. Also, you can't really compare strings like that in Java.
This is an incorrect cast. Cast to Optional<?> instead. BTW isn't printing null a bit inappropriate for non-null optional values? Wouldn't ---- (or something) be better? (We could change "null" above for value == null case too)
it is better to extract these endings into some list and iterate over it, it will be more readable
Isn't the path absolute already?
storecould be null, could you add a check?
Don't forget to delete this
Also, why return CoreException in some cases, and null in others? Are you handling this differently depending on the result?
We still need to find a better way to do this. See my suggestion about throwing a more specific exception in load. Would that work?
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Style issue: @Override shuld be on line above the method declaration
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
I've seen this "is not null && is not empty" check a lot in this PR. Commons-collections 3.2 adds a null-safe CollectionUtils.isEmpty() method. Let's add that as a dependency (we're using 3.1 currently) and we can cut down on a lot of this boilerplate.
This block has shown up in another PR, which is a sign that we have dependent work, and is something we should strive to avoid in most cases. Additionally, database operations are slow, and lookups should be avoided in loops if at all possible. Change this to a bulk lookup.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
write null explicitly rather than an empty string
What do you think about putting this in a class constant instead to improve visibility/maintainability?
Any reason not to include id, dilutionUserName, and library (ID)?
I'm not sure it's safe to change between fake and non-fake sequences. I'm having trouble working through it in my mind.
Does it?
Join type check should be consolidated probably in the logical phase
I think these two tests have duplicate code. Maybe they can be refactored taking into account this.
Do we need to distinguish StreamsException and KafkaException (StreamsException is a KafkaException and both are fatal)? Actually similar question about KafkaException and Exception? The different error messages don't seems to provide much value?
There are some formatting issues prior to '{' shall we correct in all places?
nit: remove this extra line
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
ms
start
Do we need to do another lookup here? We have the consumer already, is there a reason we're not just translating it straight away?
There are other places we perform the same validation. any scope for reducing redundancy?
verifyAndLookupConsumer will throw an exception if it is not found. The null check is not required.
Whats the meaning of catching an exception just to rethrow it under a different class?
just inline this in the enum? java public enum Category { CONFIGURATION(Messages._ManagementLink_Category_CONFIGURATION()), SECURITY(Messages._ManagementLink_Category_SECURITY()); //..... private Localizable label; Category(Localizable label) { this.label = label); } public Sting getLabel() { return label.toString(); } }
no need for this double nested try/catch, move this block to the cleanMySqlCleanupThreadsThreadFactory method if want to log that this particular cleanup failed. Is more cohesive to handle the exception for logging in the method that has the logic that failed.
if you use "android.R.string.ok" there is no need for changing the strings.xml file
Pass null as a listener, it will dismiss the dialog.
This alert dialog seems to not survive rotation. It's not super important to survive it so I'll leave it up to you to assess if this needs to be addressed. Thanks!
is this needed for the test?
since this persist is triggered by the maxRows config, would it make sense to persist the one having the maxSize ? as the oldest one may have very small number of rows.
I think this is probably the last item. Add organization to all the relevant log statements.
You don't need the extra \n when using println
why retry?
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
space after if
space after if.
I don't necessarily have a problem with defensively checking if this parameter is null, but I will call out that if onSuccess() was called with a null result, we wouldn't make it this far: it would throw an NPE inside of onSuccess() when we log out the accessToken. You could omit this check, since this code should never get hit.
why not null as value?
I think you have an additional "\n" at the end of the new error message.
This can be collapsed to a single line.
Hm. I guess it would be a weird case (some variants with names, others without in the master playlist), but it would be strange if we ended up exposing some tracks with indices for names and other tracks with actual names. How would you feel about: No name: Integer.toString(index) With name: Integer.toString(index) + ':' + name The same will apply for the TODO in the WebmExtractor, where I would guess some tracks having names and others not having them may be more likely.
Here, you are using DEFAULT_MAXIMUM_BYTES as an un-configurable hard limit (as well as DEFAULT_MINIMUM_BYTES). Meanwhile, you have the configurable fields minimumBytes and maximumBytes. Sometimes you used the DEFAULT_* constants as defaults, sometimes they are hard limits even here or for configurating the *Bytes fields. It shall be more clear which value is a default, which is a hard limit and which is configurable.
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
Should this be try with resources? I don't see the reader closed
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
why not null as value?
There's no point to else here...
Could you be a bit more precise what and where an exception is thrown?
and we don't want to rely on the URIConverter's "exists" test. The given URI might not exist locally, but it might exist on the remote side.
Again, constants would be nice for readability.
Does it need to be package private? Can't we make it just private?
final, Lists.newArrayList(), etc
You could replace lines 933 to 945 as follows to make use of short-circuit evaluation:  if (file.isFile() && ((suffix == null) || (file.getName().toLowerCase().endsWith("." + suffix)))) { files.add(file); } else if (file.isDirectory()) { listFiles(file, files, suffix); }
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
does this method need to be public?
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
Local variable could be declared List instead of ArrayList. Is this worth caching?
Why is it a list of lists, not just a list?
This step is same for standalone as well as domain ;-)
Did you consider to use org.jboss.hal.testsuite.util.Console.maximizeWindow() instead?
Did you consider to use org.jboss.hal.testsuite.util.Console.maximizeWindow() instead?
nit - for me creating ke is unneeded. Create the exception directly as the argument
Add the command that is being executed to the log
Missing a blank after "if" If propertyToList returns empty list, check if (!includeLists.isEmpty())
Maybe "[No preview available for contentType]"?
what classes are we accounting for with isAssignableFrom?
nit: this can be reused in other places, like ChannelStateSerializerImplTest#getData(int len), ChannelStateSerializerTest#randomBytes
docPossibleAncestors and revPossibleAncestors?
Local variable could be declared List instead of ArrayList. Is this worth caching?
nit, Collections.EMPTY_MAP?
Everywhere in this file please use getAncestor() instead of getFirstAncestorOrNull() where possible. getFirstAncestorOrNull() is designed for multiple values types.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
In general, we should probably be moving away from client-side validation where possible.
use rewrite than getVisitor
It's pointless to have this in the API level down if you're just going to throw.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
The duration variable should be qualified with the this keyword.
add this selector to UI mapping at the beginning
Cloning after calling getEyeLocation is unnecessary
shouldn't we have an array of configs (just like the others)?
shouldn't we use Builder here. coz, no one outside the package will have access to constructor.
Do we have to divide the gradient by batchSize?
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
Could you add info in the docs on the valid output formats?
I'd prefer to use a single long option for this: --xml-entities
let's call it updateCodeMinings() instead.
small thing - filterList.isEmpty() is shorter
change to Set
It would be sufficient to check lower-left and upper-right corners.  checkLatitude(envelope.getYMin()); checkLatitude(envelope.getYMax()); checkLongitude(envelope.getXMin()); checkLongitude(envelope.getXMax());
let's declare this variable when it is ready to be used
- please squash the commits - fix commit message. Optimize Min Max geospatial functions is too generic, instead please describe what you changed which resulted with better performance of min max geospatial functions.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
rootNode = Node.MISSING_ROOT ^^ something like this makes the code more obvious, plus you can search references for Node.MISSING_ROOT, where you can't search references for null
perhaps, verify that node is a ValuesNode  verify(node instanceof ValuesNode, "Unexpected node type: " + node.getClass().getSimpleName());
Same as above, maybe I misunderstand something
Should not it be "5" ? Else you can just do something like assertEquals(results.size(), moduleGroups.size())
This might fail on an engine that trims spaces when returning JSON. I would just trim them.
May I suggest a pre-check for getParameterCount() == paramTypes.length in order to avoid possible allocations coming from getParameterTypes()?
Assert.requeiesNotNull(clazz); ReflectionHelper.getInheritedDeclaredMethods(clazz).filter(m -> method.isAnnotationPresent(PostConstruct.class)).filter(m -> method.getParameterTypes().length > 0).findAny()...
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
This is missing maxTotalRows
Do we want the toString()= in here ?
I believe that setters normally return the type/value they just set as well.
.toString() invocation is redudant here.
This is generated code, please remove this or adjust the EMF code generator.
please include the VM's ID as well
nit: Extra parenthesis
please add brackets after the 'and'
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
Remove the unused variable declaration and the annotation is not needed
This is already covered on line 524, isn't it?
Just a thought, will it be better if we make a getCopy method and make the copy-constructor private? Something like:  java public FeedbackQuestionAttributes getCopy() { return new FeedbackQuestionAttributes(this); } private FeedbackQuestionAttributes(FeedbackQuestionAttributes other) { // as per this method }
nit: use this on other assignments for consistency
Please change the line 38 to also use EnumMap<> for consistency.
Wondering what happens if shutdown takes forever. If we did add a timeout, what would happen then?
While you're here, could you make this warn instead of info?
shut down one word; i.e. shutdown
isnt segmentsMapToFind? (not Maps)
Why not remove the entries in the first stream?
Another question, this is something I am not sure. No true or false passed in here as 3rd parameter in line 962. THe function signature has not default value. What value would be then for this invocation of fireDataChangeEvents?
Maybe I missed something but could we implement this like that ? java if (certificateTypes == null return setIdentity(privateKey, certificateChain, null) else return setIdentity(privateKey, certificateChain, Arrays.asList(certificateTypes))
Please throw an exception instead of logging, otherwise assert error will raise but with a different reason.
Consistent use of this.
![BLOCKER](<LINK_1> Close this "FileOutputStream". [![rule](<LINK_0>](<LINK_2>
storecould be null, could you add a check?
"No revisions were found to delete for the Siddhi App "
please change to 10
9?
should be final
Instead of comparing type and value for equals, do this:  return type.isComparableTo(other.type) && type.compareTo(value, other.value, other.type) == 0;  This will ensure that a CHAR type of 'AAA' will equal a VARCHAR type of 'AAA' and a DECIMAL type with a value of 5.0 will equal an INTEGER type with a value of 5.
better to use Strings.isNullOrEmpty
Do we need to check which button triggered the event?
Might as well call delegateFirehoseFactory as firehoseFactory from the start. The renaming isn't doing much useful anymore.
can we just close the firehose instead of the factory?
what happens if there is no lock? thinking of the case of running the peon on its own
Instead of returning here based on course access, we should make setHasOptionsMenu() dependent on it like: setHasOptionsMenu(courseData.getCourse().getCoursewareAccess().hasAccess())
If the feed is null, the menu items should still be setup. Just the feed title can be left out. That prevents possible flickering when menu items are displayed/hidden for some feeds.
Please don't compare to true. if (mSelectionModeActive && selectedTextView != null) is enough.
If we're no longer using a translator to translate the owner, then the owner translation should move outside of the if(translator != null) block. And since there are no other entities being translated by a translator, then that block can be removed completely.
In addition to checking these for null, now that TimestampedEntityTranslator is not extended, we need to manually also translate the created/updated fields.
Even though when translating from User to UserDTO we shouldn't be translating the password, when doing the opposite, the password should get translated and hashed. So I'd expect this kind of assertion here: assertEquals(Util.hash(source.getPassword()), dest.getHashedPassword())
let's change this to look like try { return objectMapper.readValue(jsonString, type); } catch(JsonParseException | JsonMappingException | IOException e) { throw new RestMappingException("Error maping jsonString to " + type + ". jsonString = " + jsonString, e); } that way we pass the exception to the RestMappingException constructor and get information about what kind of exception occurred.
Same error issue. I'd just fail rather than return a partial list.
what what? When did we add addsTo ?
Could you remove Error message from log message and give to logger the exception ?
are we guaranteed that this mapping is the only thing stored in the metadatastore?
Number of instances matching search criteria ( processVariable = "var_a", "a1" ) are 3, or am I missing something?. If I change it to the following below, I get data size = 3 (which I presume it is correct): Map<String, Object> variables = Collections.<String, Object> singletonMap("task_in_a1", "a1");
I don't understand what this line is trying to do.
This could just return a List, Collection or even just Iterable. We shouldn't return a concrete type like this.
This is using Pattern.compile() on something that was extracted with another pattern?
I would change this. If the caller passes in a trace token that starts with {, but it doesn't parse as json, then I would just call registerRequestToken() using the raw string value. That way we continue to pass along the trace token that was passed in to us. Creating a new request token when we were given one doesn't seem right.
Move firstMovementToken == null and firstFeedRateToken == null to the front of the outer if/else to short circuit the string comparisons for most of the program.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
put some context to wrapper exception.
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
@cuenyad Having 2 for is not needed. Iterate lotDepositDtoList and have a map with LotUID as key
Will journal be null ever?
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
The tags example (<LINK_0> shows quite a wide dropdown. Is it possible to make it wrap the text at a reasonable length so that it doesn't take up the entire width of the screen in such cases?
nit: add braces.
Debugging artifact?
why 10? Is it important for test? Or would 2 be just fine? My point is: maybe, if we're not having so many nics, we can instantiate them nicely without for loop. Reconsider this everywhere in this class. If there's no actual need for 5 instances, use only such amount, which makes difference. if you need loop, please extract creation of existing interfaces into separate method. Also extract creation of nic with/without implementation details.
Pass null as a listener, it will dismiss the dialog.
We should probably rename AppUpdateUtils.
It seems that we're not checking for current user when removing. Should that be allowed? If not, perhaps we can put out a message explaining why it cannot be done, or more simply remove the "remove" button completely. Cheers!
Can we inject this feature directly ?
I don't quite understand the logic for this. What happens if two lines are the same? Does that matter? Should we throw an error or warn the user?
Why create ObjectMapper on each invocation, instead of having ObjectMapper field that gets initialized via (package-private) constructor?
I think here we could just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.preWrite() invoked. Really not a big deal though.
My guess is this needs to read and cache the value in setup and then either undefine or set it back to the original value here. My guess is the latter is what would be right in many cases where -Delytron is used, hence the failures in the elytron job.
Please change to " has no members."
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
The first argument can be random.
I think this should be replaceFailed = false instead.
The PROPER solution would be to make getContainerItem NOT return null, as Null ItemStacks are not valid anymore in 1.11
Please explain the operations you are taking here, especially the thoughts behind the nested for loops and the while loop.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
@Override
same thing here, it doesn't need to suddenly start working after the first experiment, plus is this test strictly necessary, considering it's subsumed by attemptsExperimentAgainAfterEnoughTimeHasElapsed
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
just use context as synch obj
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
Putting a cleanup here may result in weird behavior, since the interpreter.exec(pythonFunction) will no longer be called at each processElement
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Must be Outcome.Benefit to keep good card
Missing discard command
Replace this with The number you have entered (<Number>) is too small, it must be at least 0
No need to send this error, just return false. It would never happen to a block/entity/console.
it should be  java if (TFM_AdminList.isSuperAdmin(player.getName()))  Correct me if i am wrong
token.toString() will not print token.decodeIdentifier().getUser()) which may be useful in debugging. UserGroupInformation.getCurrentUser().addToken(token) ignores null tokens. Better to log and skip when token is null like below instead of changing the current log statements.  for (Token<? extends TokenIdentifier> token : allTokens) { try { if(token == null) { LOG.debug("Ignoring null token"); continue; } LOG.debug("Current user: {}", UserGroupInformation.getCurrentUser()); LOG.debug("Token from credential: {} / {}", token.toString(), token.decodeIdentifier().getUser()); UserGroupInformation.getCurrentUser().addToken(token); LOG.info("Added delegation tokens to UGI."); } catch (IOException e) { LOG.error("Exception while trying to add tokens to ugi", e); } }
Double-checking seems like overkill here... in the very worst case where you hit this race condition, the collection type is a Set anyways.
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
For some reason, getString() has priority in AOSP so it can skip the resources. suggestion numberOfNamesInList.setText(numberOfNamesInList.getContext().
Not sure if this is really more readable than  settings.setRequestBody("[]");
Since both annotations define a default value when is this ever 0?
This is not an integration test, you're working with a mock version of Github. This test method belongs to another class (and another ticket)
it's better to use some Unicode chars in it, for better testing. for example "the raw \u20ac\u0000"
it's better to stop container in finally block
Here I have 4 connections and the dialog shows 4 lines with <unknown> as a label.
No need for Multi since dialog.open returns one path anyway
I think this is not needed
does this work if we have two accounts on different servers but the same username?
You might consider rearranging the order of the lines, to make it more obvious, that one of the users is not made a member. Alternative: Create a method createMember, that creates a user + makes it a member.
Not sure you need the password as you don't use it.
Typo; Should be authentication in lower case.
StringUtils.isNotBlank()
If the token is blank you don't need to check/fetch the client-id. Return false immediately, and marginally help with performance.
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
Please check that the data buffer has at least 2 bytes to avoid a NPE.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
nit: this is a slightly nasty way around the line length issue.
LGTM in general. There might be performance/less memory consumption gain by declaring Color pixelColor outside of the loops and then just updating it, however I'm not sure about it - maybe it is optimization that JVM is able to do itself. Not a merge blocker in my opinion.
not correct
Are you sure that updating array and than drawing it to canvas as bitmap is faster that drawing directly to canvas?
Is this what we want here? If so we should have it as a Log method then.
you could have done everything inside the same Function.
shouldn't be putIfAbsent()?
This will always be false? What did you mean?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
This class has no superclass, so I'm not sure we need to call super() here.
how often is this method called? Why not cache this computation like you did the others?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
How about in-lining o1 and o2 since they are not reused?
This if statement is not necessary as the while loop below would handle the negative case.
Better to break after the equal sign.
I would rather get rid of RuleSetAdapter because: * it assumes that rules in RuleSet have particular semantics (e.g: only one rule matches) * it wraps and executes rules in a different way than during actual optimization * it doesn't allow to test how rules interact (e.g: trait rules before other rewrite rules) * it only allows to test rule set which are grouped in RuleSet, but we might want to test not grouped rules (e.g: trait rules and rewrites). * it is a work around RuleAssert limitation of testing singular rule. I would rather test multiple rules explicitly in RuleAssert with assertions.
This is already done in the other method.
Why are the problems not enough?
Platform.exit()
Why should tis run on Backgound thread
The client aims to be as non-intrusive as possible. Immediate notifications should therefore be used sparingly and only in cases where a user's immediate action is required. Let's say someone only has the client installed for chatting in #aeolus, or maybe he's a client developer who doesn't actually have the game installed but starts it very often. This user gets an annoying notification now, every time he starts the client. This is why we made it a PersistentNotification.
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
Integer.parseInt
We could just always use the body instead of flipping based on the payload size.
This would be better as:  java if (projectsAdded.add(targetProjName)) { IProject targetProj = ... }  That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
So I believe if IPath bundlePath and IFile bundleFile is not null that means we have a workspace archive so we should use ArchiveSourceContainer as before. But if those aren't in the workspace we could fallback to using the ExternalArchiveContainer.
super.children().forEach(res::add); ?
Usually tryLock shall return a boolean instead of throwing exceptions.
Bad format. You can probably remove the brackets here ;)
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
You can remove this line. It is probably just for debugging.
This log is too frequent. Please remove it and add only "info" log to the Auditer class itself where we will have better control on using these debug messages.
I would prefer to take care about two different situations: 1] value of attribut is not null - set, 2] value of attribute is null - remove. Same like in the schacHomeOrganizations user virt attribute module.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
Formatting?
Is this going to cause a problem upon restart? Should we log something higher than debug?
docPossibleAncestors and revPossibleAncestors?
Use LinkedHashSet instead of ArrayList.
Should be able to do a multi-id query using something like criteria.add(Restrictions.in("groupId", groupIds)) Current method allows for nulls to be included in the returned list too I think
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Why do we need those lines? Unit tests are still green if I remove them.
Prefer interface instead of concrete type. suggestion for (Map.Entry<String, Boolean> entry : privilegesMap.entrySet()) {  Same in other places
else throw an exception with a descriptive message about whats wrong.
no need for the additional check if propertyParts.length is ok?
better to return an Empty Map, otherwise callers would need to check
Shall we use 'isValidCacheRequest' like method name, as this is a boolean operation. When reading the method, it does not look right. It feels like if request is valid 'return'. it should be like if(isValid()){ }else{ returnl }
This would be a good time to change this to fire exception via the log object, i.e. org.infinispan.util.logging.Log.invalidConfigurationIndexingWithInvalidation
technically "status=" should be "state="
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else? Window has this anomaly as well where the unsubscribed outer may never deliver an onCompleted on the inner windows and thus they stall.
This allows unsubscribing the state while an onNext is in progress which requires extra care for the state object.
I think we do not maintain key order here, which is iteration order of the elements of this Traversable. The result of toMap does not guarantee any specific key order. So we need to do some extra work to order the keys of the LinkedHashMap: java default <K extends Comparable<? super K>, V> Map<K, V> toLinkedMap( Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valueMapper, BiFunction<? super V, ? super V, ? extends V> merge) { final Map<K, V> map = toMap(keyMapper, valueMapper, merge); final Iterator<K, V> entries = iterator().map(t -> { K key = keyMapper.apply(t); V value = map.getOrElse(key, null); // the default value will not be used return Tuple.of(key, value); }); return LinkedHashMap.ofEntries(entries); }
Need to revert this code. Should always have id and subsystems
Don't you just want to delete anything at the location, if the value and type don't match does that matter?
Why you take a array of size 4 not 3?
Strange... the JDT UI settings in our projects should remove trailing whitespace. Please remove.
Please change to !message.trim().isEmpty()) {
What do you think about if (paths != null && !StringUtils.isBlank(sourceText))?
looks like you missed these
Why not generate these in the constructor? Otherwise, you're creating _sizeof(prefixes)_ new Strings every time createSortTitle is called.
We don't use braces ({}) for such simple one-line statements, please remove them.
@cuenyad use factor variable
You can remove this call and also remove the public default constructor: it's not used.
this and m_ is redundant
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
replace "ROW FORMAT " + s + " " with format(...) ?
Nit: Add space before AND
style nit: no braces around single line blocks
Since we are using Histogram everywhere, replace AbstractHistogram::reset with just Histogram::reset.
Please call isEmpty() instead and check null for cursor
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
maybe use clusterName.pid to not conflict with instances from other nodes?
Please avoir multiple statements per line, we are not writing JavaScript ;)
Could you check for null or empty? Via StringUtils.isBlank
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Same as before, you can bump this up to "1.8".
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Just an FYI for future - You can use this method for this: <LINK_0>
Why the sub string ?
I think you want to pass in the errorListener to super
This can be placed directly inside of the function call.
Immutable?
Logic is meant to be a facade class. As such, you should put a method deleteAllStudentsInCourse in StudentsLogic and have this method call that one instead.
Change the type to Set<String>
Streams
Please write a method ProcessService.getNumberOfChildren(process) which is calling the ProcessDAO to count on database
suggestion if (Objects.nonNull(PrimeFaces.current()) && Objects.nonNull(FacesContext.getCurrentInstance()) {
Please adjust getting the configuration parameter like in #1623.
rename 'listeners'
rename
not all listener
Why it is named by testLoadYamlFileFromDirectory ? Does it mean it will include all .flow files in the directory?
We only want to take the hit of saving the message in a TL __if the poller is transactional__ - we can easily tell that in the XML parser and via the DSL spec, but not so easily via the @Poller annotation; we may need to add a transactional property to @Poller for that. On the other hand, any "around" advice that can throw an exception may need access to the message if it throws the exception after the proceed. So, I don't mind if we always apply it if the advice chain is > 0 length - that's probably the simplest solution that would work in all cases while only taking the extra unneeded hit if someone configures an advice chain.
explicit type not needed
These seem like class constants.
minor: no need for final?
Change this to == and I'll merge it.
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
If the tryCreate() is true, and for any reason, unable to create connection, it should be in the loop till the specified timeout (server-timeout), right? throwing an exception here will return before the specified wait time.
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment()  PodSpec podSpec = new PodSpecBuilder() .withContainers(container) .withVolumes(getVolumesFrom(volumes, workspaceID)) .withTerminationGracePeriodSeconds(OPENSHIFT_POD_TERMINATION_GRACE_PERIOD) .build();
do we need such wait ?
WDYT if we change two checks to just one? Something like: Plugin brokering supports one pod only. Workspace 'ID' contains 'N' pods
"SocketServer time spent on write per key"?
Perhaps closing the send buffer in close(SelectionKey key) method would be better, since it already calls Transmission.close() and it would unify the cleanup paths. Would it be valid to release the send buffer whenever Transmission.clearSend() is called?
We should just expose getRemoteAddress()
NPE when req == null
register should be renamed to be consistent with current approach (was more meaningful when it was stateful). Proposal: generateToken.
:ant: Still weird as there's no way to have a submission that doesn't enter this branch. There's no second button.
You can use CollectionUtils.toImmutableList
Please always use curly braces in 'for' statements.
Shouldn't this return a segment?
'e' is not logged
Use constants for these types of String literals
Wrap the exception
huh?
just one space
hmmm, correct me if I'm wrong but I think there is a case where this is not correct: - have 2 storage domains, A and B - have a template with 2 disks, X and Y - have disk X on domain A and disk Y on domain B - lets say the domain A is 10x bigger than domain B so even after putting all the disks on it it will still have more empty space than storage B - this algorithm will put all the disks on storage A even the template has it's disk Y on storage B what you think?
might be safer to use a constant for "cookie".
just remove the fileSize from here... and that's the only change you will need.
There is a Log class for the project (Log.java into utils package)
Please refactor DbFacade.getInstance().getLunDao() to a method...
You don't care about the order, and you're doing several remove operations - better use a HashSet
it's kind of confusing to have a set named with "List", consider change that.
When does this method throw TckRepositoryException?
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
i -> expectedColumnIndex
hostsPerTable.get might be null if beginCreateTable but finishInsert didn't. There is a race condition here I think
Suggest to move the 2nd param to a class variable since I see that the other tests are using the same one with the same value.
This can use partitionChannelTypes
It seems like we can add two storage domains at the same time
1. No need to use warn, info should be enough 2. You can remove the redundant space at the end of the sentence. 3. Please rephrase the log to indicate this is related to Hosted Engine.
name suggestion: isInternalDomain
Calling cancel method like this will not actually cancel the task. You have to do this through task driver.
Please extrace the generated url into a variable before calling HttpUtil.executeUrl(), this makes debugging much easier.
Debug has to be detected first otherwise we'll always take the INFO branch.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Would it be too nitpicky to question why there is an intermediate rolls variable? dice.getRolls() is just as descriptive and it's only used a couple times below. Removing intermediate variables is often a good thing, one less thing for a maintainer to keep on their mental stack when reading code. At this point when reading the method, there are 3 variables in scope, soon to be a 4th one, leaves little room for much else!
no need to specify type on RHS
Better to return Optional.empty()
return Optional.ofNullable(kill);
This can be simplified to Optional.ofNullable(id).
There's a utility class for this. Check out DisplayUtils.dpToPx()
Probably not an intentional if (false), I assume.
Current assumption why we see some missing parts in WS is that we should apply the current transform to the clipping before we intersect it with requested one. We are investigating in this direction.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Missing types
These should get saved in a data structure so that repeated calls with the same name return the same map.
It may be easier to use [GenericJson](<LINK_0> java GenericJson genericJson = new GenericJson(); genericJson.setFactory(OAuth2Utils.JSON_FACTORY); String content = genericJson .set("foo", "bar") .set("asdf", "qwer") .toString();
Returning entity.toString() could be ok. iirc, the stable id should be the same as the canonical path except for the very long canonical paths.
this might look weird but is done to allow rolling upgrade of the cluster where overlord is upgraded before middle managers. we can possibly remove this if we decide to not support rolling upgrade for 0.10.0 .
InterruptedIOException
This seems wrong/redundant. The check !file.exists() && !dest.exists() will often return true before reaching here. We will only get the IllegalStateException if !file.exists() && dest.exists(), and the catch block after Files.move already throws the same exception if we are in this state anyway.
child
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
Ummmm, my memory does not check out this time :\
nit: you probably need to update this test as well
It looks like we create new mappers very frequently. Is that supposed to be the typical use pattern for Jackson? Does creating these have any kind of cost? Can they be re-used?
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
swap and use if(booleanVar) (which I would rename to just prettyPrint)
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Collections.emptyList()
This needs to be the last line of this method.
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
Perhaps we should add 1 or 2 more cases with reordering the scalars a bit and gather some more confidence regarding the assumptions on the ordering of the arrays. What about select b, b.id, a, a.id from EntityB b left join b.a a?
Oh yes, can change this back to formatDateTimeForSessions and delete this method from TimeHelper? It's a workaround for this issue.
can't we use optional?
This can be collapsed to a single line.
Its worth adding a null check here too.
Duplicates the code in 'getAllInterfacesByLabelForCluster(..)'. Please refactor to avoid the duplication.
move this up, than you can use it in the if as well.
Same as above - log or throw the weird state.
let's check item is not null before accessing it (and make a call to AppLog if it is)
Nice, i was wondering if this would work for overloaded methods and it appears it does (i.e. findSliceInvoker1 is defined if a previous findSliceInvoker exists.
as I see this code block appears twice in the class, please extract it
This can be reduced to: java return getLatestLiquibaseSnapshotVersion().map( snapshotVersion -> LIQUIBASE_SNAPSHOTS_FOLDER + File.separator + snapshotVersion + File.separator + LIQUIBASE_CORE_DATA_FILENAME);  Not that you need to make that change.
Logic is pretty broken. Let's make it in sync with naming, i.e. we should call decrypt only if isEncrypted. so inside get method do: if (isEncrypted(...)) { value = decrypt(value, CRYPTO_PATTERN); } and remove your 180-182 if lines...
Same as above, using GeoWebCacheExtensions.getProperty would allow more options to set a property.
the whole point of returning empty Properties is to avoid the check. And you need to update the end date in the copyright header for every file you change.
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
Why this change? Do we have audio streaming too?
simplify this
unnestChannelInputBlock -> newInputBlock
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
Can this be private, or is there another use case for default attribute outside the builder's call?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Redundant. See DirectReplyToMessageListenerContainer ctor.
input and expected output should be copied to test's input folder.
Unneeded since it is in teardown.
It seems like it'll build versions that match our tag names, like "v0.2.190" and create a "stable" version for our most recent release, and "latest" pointing to current develop branch. Probably safest to just return "latest" for now so we know it won't be a broken link in the next release though?
I'd consider writing a helper like this to remove boilerplate:  private <T> List<T> nullToEmpty(List<T> list) { if (list == null) { return Collections.emptyList(); } else { return new ArrayList<>(list); } }  and then call it in constructor like this.mavenOuput = nullToEmpty(mavenOutput);
Same here - don't have to create a new ArrayList. Do the same in all other places too.
![MAJOR](<LINK_0> The Cyclomatic Complexity of this method "run" is 12 which is greater than 10 authorized. [![rule](<LINK_2>](<LINK_1>
This can only happen if the ref disappeared after the caller resolved it. I think it is okay to return Collections.emptySet() in that case.
Public methods on package access classes seem a little strange to me.
(optional) could inline the value of m
Remove this :)
It would give caller more flexibility to add another API acquireLockWithTimeout(int milliseconds).
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
this won't work. in the immense majority of cases, the declaration of the parent method won't be in the same file, and so you won't have access to the modifier.
Just a reminder to not forget about managing the message.
this should maybe be encapsulated to avoid leaking executionState class in the check class.
I don't think these are still necessary, because of the catch block on line 1053.
I would rather not involve controller code in this fix if we can help it. Could we just put  html <#assign isArticlePage = true />  near the top of article.ftl instead? Also, won't this create inconsistency between the main article body tab and all the other article pages? As currently implemented, I think we would get "Journal Title: Journal Slogan" on non-article pages, "Article Title" on the main body tab, and "Journal Title: Article Title" on the other article pages.
Please add this: requireNonemptyParameter(articleId);
This method sums over the second and third dimension.
This is a real Error, I don't think we ever use this, so a RuntimeException seems more appropriate (also applies to the other uses of AssertionError).
This can also be package private :)
I think CDA is not the place to set values
Should be done in the constructor
it's better to have the 3 lines above in the constructor + we might get NPE on getVds().getVdsGroupId(), we need null-check before doing it (and canDoAction check)
Have a look at <LINK_0>
Any particular reason to use 100_000 ?
typically, you don't use getters when inside the same class
Timestamps within the last hour are rounded to "0 hr. ago". I personally prefer showing "X min. ago" for those cases and "A moment ago" or "Just now" for timestamps within the last minute.
We could probably use getItem() method here, for consistency.
move this up, than you can use it in the if as well.
nit: would case switch be better?
Do we still want to include cleaning when checking for under provisioned, this will exclude it for both under _and_ over? Trying to make sure we avoid any false alerts if possible
This function is called by two callers: xxxFromMetadata and xxxFromAssignment. For the former we do not maintain the old topics but just replace with the passed in value, for the latter we still maintain the old topics -- this it to take care if the leader did not assign all tasks / partitions due to assignment error. We should still keep that logic here.
can we add this. in front of setting these fields
We don't have such a usecase, it must not be allowed to use fulltext resources when motivation is tagging. Please remove
I know that we don't have a linter for java projects yet, but what do you think if we'll try to follow some basic formatting rules, common for most languages? Like spaces before and after = and + for example.
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
this can be inlined
This doesn't really make sense, onPartitionsRevoked is always called before onAssignment
What are the conditions under which this branch can happen? Can't we say that there must be a SharedSlot when this method is called? Making this stricter could allow us to catch other programming errors faster.
Does it make a difference whether slotStatusUpdateListener.notifySlotStatusChange is called before effectuating the state change on slot? I am asking because transitionSlotToPending and transitionSlotToFree do it in the different order.
You might want to consider the ItemStack max stack size well, not just the slot max capacity.
"authentication timeout"
No need
Does it work? Aren't we still skipping the access token lookup even it's still valid?
String.valueOf
I would just get of any semblance of support for Apache.
Typo - should be "length".
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
If getCurrentStorageItem() is null isn't getCurrentStorageItem().getRole() should through an NPE? I think that it should be like this if (getCurrentStorageItem() == null || getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)
duplicated
you need to check for null case
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
Just to stay consistent, I would keep this as its own check. We always use "return true;" on its own at the end normally.
order of operands
order of operands
call equals on constant
I think I prefer spaces before "leap-day" and "year-day", but not too important. Wikipedia has all words capitalized (and no hyphen before "Day", either), so you may want to check some of the original references.
if that previews is showing cleaned-up code, why is this one still here?
Name doesn't look right
Protect against an empty url? (If url is blank, this will throw IndexOutOfBounds.)
@korthout Let's use cactoos equivalent of trim and replaceAll methods
@xupyprmv shouldn't it be sections now?
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
this if/else is equivalent to this.path = Optional.ofNullable(path);
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
I think we can remove this line.
Should this work with versionID? It's already in stg73 branch.
Add check for null here.
Doesn't this return an int? So you can't orElse?
I'm thinking that we should provide a different strategy for some block types, such as table, numeric list and bulleted list - there's no need for <br/> <br/> to terminate these.
consider a assertSupported(BlockTypeStrategy) as altenative to all the instance of checks
Don't return, just do a continue so other modules can still add their state systems as children.
I found that trace.getEndTime() is not always coherent, especially with traces whose analyses were already built. It seems to have to re-read to whole trace before the end time updates itself. Anyway, this last is useless because it is && with start and end being equal to start and end of eternity ;-)
can this return emptyMap? and just be another clause of the if below?
Move this binding to StorageModule.
Nit: I would always use asEagerSingleton to catch errors early on.
Is this needed? For future use?
I feel like there should be a better way to do this...
We have a new U.nonNull() method.
Put a Sage.rez() around "Forced"
Could you, please, explain, why verification the command palette had been removed?
What about checking running the test from command pallet?
In my opinion, just renaming of variable to something like "testProject" will be enough.
Formatting issues
How about the following to simplify the string construction below: java String clientEnabled = System.getProperty(ZK_SASL_CLIENT, "default:" + DEFAULT_ZK_SASL_CLIENT); String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, "default:" + DEFAULT_ZK_LOGIN_CONTEXT_NAME);
I assume these tests will never run on Windows, right?
you miss the "&& mouseOver"
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = (observable, oldValue, newValue) -> { if (newValue && !repositoryManager.isRepositoryLoaded()) { repositoryManager.triggerRepositoryChange(); } }; this.mainWindow.getApplicationsTab().selectedProperty().addListener(tabListener); this.mainWindow.getContainersTab().selectedProperty().addListener(tabListener);
I'm missing the new field in the toString method.
Looks like spurious changes with no changed behaviour in this file. Necessary?
this check-then-set is done in a transaction, right? Because I don't think it catches all possible races if not in a transaction.
YMMV on whether this is more or less readable, but this could also be  java final List<String> hosts = hostsAndStatuses.entrySet().stream() // we only care about hosts that are UP .filter(entry -> entry.getValue.getStatus() == HostStatus.Status.UP) .map(entry -> entry.getKey()) .collect(Collectors.toList());
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
Should we catch throwable here?
Files::isRegularFile
I think the unmodifiableMap should stay in getRoutes().
Please keep this.cell near the related fields (previousFamily & cell count) below
I guess this could blow up...
Please use "something <operator> null" convention
Not sure, but profilesToActivate() may be too late for the foo(literal) => fooExpression conversion.
Now that we see different behavior with 1.0 and 1.1 should we build test so that it works in both versions? maybe repeat this with different protocol version.
Again, these should not pass validateInputs()
These is a most ugly way of work, you crated wrapper, passed all parameters and you are passing a list of canDoMessages all over a code in order to fill it. Such approach is wrong (I know that it is used at our code, but sometimes someone should do something smart), you should use return value.
change to if/else
Use UTF-8.
this is pointless, we don't need to close byte array output stream
Can WebContent be moved to test/resources?
Update labels to go with method names. Alternately, call super.toString for super attributes
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
can you add some docs around this method.
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
:thinking: Is there any situation we would want a dirty dag? Perhaps there should be a default method in LanguageHandlerInterface that auto-cleans all getContent calls and getContent should be protected and only called by that
This same block is in this file 4 times. I would recommend at least making a constant out of "validations", and/or creating a method to avoid duplication.
Missing braces
Is this supposed to be here? A cache entry expiring isn't a synchronous thing.
bug: else is missing
Hmm, I'd reformat to make it more readable: if (host.isInFenceFlow() && (host.getStatus() == VDSStatus.Down || host.getStatus() == VDSStatus.Reboot)) {
Isn't below more readable? if(!ExternalStatus.OK.equals(host.getExternalStatus()) {
I think we should change the level to debug. All the other weight policy units use debug levels.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
I still think you should throw an exception if name is null
Isn't this the default max width? In any case I would prefer to see these definitions in the css files.
repeated ...
I'd prefer  public String toString() { MoreObjects.toStringHelper(this).omitNullValues() .add("id", id) .add(...) .toString(); }  What do you think @akemr?
Try combining the two returns. You do not really require a if else here.
Delete try/catches. An exception always fails the test case.
Why delete this line?
The code in this test is identical to the one above except for one line -- can you have both tests call into a shared method for most of the work?
if a column was missing, should we ever match it in this case? fn.apply(value) looks a little bit unusual as value is really an element from the Range of the function and not Domain. may be it should be...  return new BooleanValueMatcher(false);  @xvrl ?
should this be BooleanValueMatcher(matchNull) ?
Great catch! I have one worry here which has to do with quoted identifiers. For example you can have a table with the following schema:  CREATE TABLE simple.blah ( "hI" int PRIMARY KEY, "Hi" int, hi int )  By using equalsIgnoreCase, "Hi" would match against "hI" and be considered part of the routing key values, which we don't want. I think to work around this you could use:  java Metadata.handleId(name).equals(partitionKey.get(i).getName())
Is this really more readable? (IMHO it's not)
I'm not sure it is a good idea to include this in the equals - two accounts are equal by virtue of their properties - not on their snapshot versions, correct?
I have figured out how to do this :-) You have import the static field like this: <ui:import field='com.google.gerrit.common.PageLinks.SETTINGS'/> Then just add href='{SETTINGS}' to your g:Anchor tag ...
Can we pass the string separator instead of configuration to avoid unnecessary Configuration.get() for each RPC?
May be more readable if the check for null userCompactionTaskQueryTuningConfig is moved up: java if (userCompactionTaskQueryTuningConfig == null) { return new ClientCompactQueryTuningConfig( maxRowsPerSegment, null, null, ... ) } else { return new ClientCompactQueryTuningConfig( maxRowsPerSegment, userCompactionTaskQueryTuningConfig.getMaxRowsInMemory(), userCompactionTaskQueryTuningConfig.getMaxBytesInMemory(), ... ) }
I am wondering whether we should consider the case where explicitly above( null ) has been invoked. E.g. if the null token is "-1", that may make sense to exclude some negative values existing in the database for some reason. Maybe it's contrived, but I'd like to hear what others think.
Actually, in what way does this change relate to adding a new status command? Because this change affects all other CLI commands perhaps it deserve its own separate commit. Anyway, just making sure this change landed here voluntarily and not as a result of mingling with another context...
style nit: no braces here
There are also a few cases of IllegalArguementException's that could be thrown by malformed encoding headers.
I would use else if here
Same trouble: what about this.myField = "";
@highker , @hellium01 , would you mind also taking a look at AddExchange ? -- it's basically a template parameter change.
deviceIdentifcation => deviceIdentification
Shouldn't this be: is allowed GET_MBUS_ENCRYPTION_KEY_STATUS_BY_CHANNEL?
The method name has been refactored, but the log statement still uses the old name.
from L257~262, you can use Strings.repeat
we can just call repeat(" ", n)?
as we are changing how the digest is computed anyway, we can simplify this as buf.append(',');
This should be a triggered ability of the enchantment, not a trigger gained by the creature
Use {this} when referring to card names in text.
This needs to not have the sunburst text, check out Skyrider Elf
this class doesn't have tests?
make this default package instead of protected.
Who is responsible for closing the streams? In the normal case, and when there are exceptions?
ah, I forgot that the primary key components are part of system.schema_columnfamilies, not columns, so that wasn't a problem.
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
Can't we create many arrays with this change if there are high partition counts? Maybe we should calculate the size upfront.
Debugging artifact?
wrapping
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
Should go into @After method to make sure it clears authorizations even if an assert statement fails.
Should go into @After method to make sure it clears authorizations even if an assert statement fails.
datum.toString() seems suspicious
Not sure idPos variable is really needed here
it looks like we were writing DESIRED_CAPABILITIES twice before
The fail()method throws AssertionError which is an Exception. Either use ExpectedException or change your catch clause to catch the exact exception you are expecting
So the message is expected to contain the misspelled csanceling, right?
I think there's also hasMessageStartingWith. AssertJ is crazy...
what if storageDomainDR.getJobId() != null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId()
else if (storageDomainDR.getJobId() != null) {
I'd change it here only for consistency if we already pass it by the paremeters.
This turned out great, I think it's really easy to understand exactly how we get retries to work properly with this code.
Again, this is fine for a first cut, but we should file an issue to change how this is keyed/checked. Since a topic may have data formats evolving over time, I think we need to actually compare the schemas as well.
Seen -> Saw. Should we also log this at a higher level, like error? This is a pretty critical error. I'm not even sure we should proceed if we hit this because it means we could be losing data since this method just ignores the data and moves on. It either indicates a serious problem with the underlying consumer or that something got messed up in this HdfsSinkTask code.
This can't be true, as Math.min() would return max if nsz would be > maz. :-) I think you really meant to write: if (buf.length == valid) { if (buf.length == max) throw When buf.length == valid we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw ...
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
unnecessary else clause can be removed
Can this be private, or is there another use case for default attribute outside the builder's call?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
scheduleTimes --> scheduleTime
How did you convince your IDE that primaryIP is definitely not null here?
Just a matter of taste, but I would name the method without abbreviations: scheduleNetworkInterfacePolling
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
We have the two letter codes here only for backward compatibility and changing it will break it. I suggest we remove the two letter code for Japanese.
If we want to be totally safe here, should we add || pages.isEmpty()?
please revert the changes here - it'll cause to issues. the spms should be moved to prepare to maintenance last, so in case that we move to prepare to maintenance few hosts from the same pool the spm role won't be taken by any of those hsms and will start "flipping" between hosts, causing to many unneeded operations, therefore the spm need to change the status last.
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
Don't you wanna continue the loop and add more patients, just in case only a few fail?
This has to be cleaned up.
detach?
what is the value of getting the instance this way?
At the very least, extract '(CreateImageTemplateParameters)getParameters().getImagesParameters().get(0)).getVmId());" to its own method...
Please dont use this {0} , and use String.format instead.
please move it to resourceManager.resetVmAttributes
hmm, no need to use C# coding style here. should be initXXX and not InitXXXX
Could you check for null or empty? Via StringUtils.isBlank
isn't used...so perhaps do not set?
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
Immutable?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
Can you replace IDs with names in this log message?
I think this is overkill with memory allocation. We can revert back to the model we had in 0.6 and used a thread safe data structure here.
We always put {} in for and if..
Throw a NullPointerException if address value is null. Can any int array be provided or should establish a concrete length or a min/max length?
subMonitor.newChild with 1 tick
subMonitor should be used here
Use two parameter constructor
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
Shouldn't this Assert be before the this.clientFactory.getClientInstance ? For other side it looks like we should have another getClientInstance method without the url.
scheduleTimes --> scheduleTime
If this is never going to happen, why modify this to be less chatty?
Why are there two messages being logged? Can it just be: LOG.info("Retriable exception from end point id: {}", endPoint.getId(), e);
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
extract this rethrowing to a new method
The duck and throwsUnchecked methods need to be moved from this interface (where they are public methods) to some class in this package where they can be package private. Then the code above can use this duck method.
Locking the configuration shouldn't be necessary. FileBasedConfig extends from Config, and Config is thread-safe via atomic references. So you just need to determine if either file needs to be refreshed, and if so, run its load() method again to pull it in from disk.
This should have the data source name in the message and add the actual identifier as metadata on the alert. The messages are what turn into the email subjects... Also, after the alert happens, this is going to fall out of the if statement and do other things. Are we sure that those other things are what we want it to do?
This is pretty dangerous because alerts bigger than 1MB will break the emitter
(Optional) Does this need to be anything other than Collection<ServerHolder>?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
let's break lines here to make the formatting a bit nicer, and not have such long lines below.
Now I have looked further down, this looks the same as my way above, but all on the one line to avoid having to specify the types.
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner:  Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri()[0], "Config server URI is undefined.");
Couldn't we use an Assert.notEmpty like the one below this?
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
braces seem unnecessary
java8-isation [forEach][filter]
Why add and not collect into the list?
nit: can replace both checks with CellUtil.matchingColumn
Would it be safe to turn on normal HBase replication on the new System.CHILD_LINK? (That is, is there any unwanted data in System.CHILD_LINK that this WALFilter wouldn't copy that normal HBase replication would?) If normal HBase replication works for System.CHILD_LINK, and all view data left in System.Catalog starts with tenant_id, then the logic here can be greatly simplified, similar to how it was before PHOENIX-4229
Why not just "else"? Also, please add a space between if and (. There should also be a space between { and else
Minor ( ): Consider removing the cast to NoteEditorActivity for this case, it is not needed, isn't it?
Ideally leave in a separate commit as it's a functionality change - has been an issue for some time. suggestion Timber.w("LeechHook :: could not show leech toast as activity was null");
Translation between request codes. Please keep that in the presenter.
Add newline before return.
Add newline before return.
Add newline before return.
would be nice to have the message in the exception here because this will also show up on health check potentially, and that only shows the direct message iirc. IOTW I don't think "Could not process request." is more telling than the cause.getMessage()
The debug logging can be removed
Use (StringUtil.isEmpty(elementName)) instead that ckeck if your String is null or empty instead (elementName == null || "".equals(elementName))
Are you sure this won't cause MC to access parts of ChunkCache that aren't there? It's reasonable to expect it to get blocks from outside of the range between target and current position to get around some obstacles.
Can you combine in one line? Sorry that the original code was like that.
Any particular reason to use 100_000 ?
No need to use a separate xLogAxis variable (especially as it's a local variable, so there is no multi-threading danger whatsoever). Also change the original code to avoid unnecessary instantiation: NumberAxis xAxis; if (!...) { xAxis = new NumberAxis(xAxisLabel); } else { xAxis = new LogarithmicAxis(...) ... }
why final variable? :-)
I wonder, does the setShowGutenbergInfoPopupForTheNewPosts() call in line 646 below need to adopt a "PrefKey" param as well? I'm a bit confused by the codepaths but, it looks to me that when the flag is true, we'll try to clear the Phase 1 flag only.
new byte[0] is kind of ugly. Maybe another method that doesn't take it?
use try-with-resource instead: try (Scanner scanner = new Scanner() { }
Should the scanner be closed after the call ?
Extra space after synchronized.
macOs implementation is pending
Should we check that either all of the encryption properties are set or neither of them are set?
nit: "Raptor page writer max buffer size."
We may want to log a warning when files are _not_ applicable, since that would indicate that some kind of junk had been uploaded.
I think you should be able to pass config in directly
Can't we use ITypeMarshalBuffer.BASIC_TYPE | shiftedKind | ITypeMarshalBuffer.LAST_FLAG and not write kind separately?
There is only one bit left between FLAG7 and LAST_FLAG. It makes sense to define ITypeMarshalBuffer.FLAG8 and use it instead of SECOND_LAST_FLAG.
Makes sense to swap FLAG2 and FLAG3 since volatile functions are less common than the varargs ones.
Do you want to make the check that portFields is of size 2?
I think it should be non-null, since people have come to expect that for granularity: all. It would probably break stuff for it to be null.
This is not correct, let's discuss f2f about it
Seems this should not be public. Why providing such internal structure is needed?
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Can be deleted since apis was used by ViewEnhancer.
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
You added a parameter but this command is also used from other places, so this will cause compilation failures.
Also please notice that the format is not fit for empty or null string, so you might want to check StringUtils.isEmpty() before.
Why do you wait?
Each test should be self-contained. Please change the shared (mutable) variables to local variables in each test.
Looks like this return value is not being used. Is this intentional? If not, I think it's better to make this Runnable instead of Callable.
Put these three blocks into a helper maybe.
We need this to be synchronized every where it's used (i.e. loadObject and commit). Would it be easier to wrap LinkedHashMap and synchronize the entire structure? Or do we want to do the bookkeeping here?
non-actionable: ... and this is where I complain about not having Java 9 Optional#or which does exactly what you need
Should it be numJsonBytes?
This could break existing users... perhaps deprecate, and add nextByteBuffer()?
CodePointIterator might be a better choice here?
This line is now unnecessary because disposedOperators is updated in disposeAllOperators before throwing an exception.
Its better to cleanup the Archived message on a server restart. Call deleteElapsedArchivedMessage() method if we find any archived message.
I wonder if we shouldn't throw some exception?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
jsonRow != null? So what will be happen when jsonRow is null?
:+1: I am surprised we didn't have this before I wonder if returning the size used may be better, WDYT?
For loop?
Better: append this unconditionally, and only append the other part based on the condition.
Remove, and use StandardCharsets.UTF_8
Intellij will probably display a message on this saying that you should use plain string concatenation rather than a string builder.
This cast will fail on any primitive array. e.g.,  java new int[] { 1, 2, 3 };
IMO we should still throw an Exception here after logging the error - failing the deployment seems OK to me, as long as the user can find out _why_ the failure occurred. (If these values aren't specified, **the function itself won't work.**)
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
Only set the map if non-empty.
why not null as value?
I wonder if that would better to rename to fromSupplier(). And yeah... remove that from(Supplier) altogether. Breaking change, agreed, but no choice. I will find this explicit casting style more annoying than removed method. WDYT?
extract the logic to fetch/build the retry policy to a provate method, for code readability
We call this ModelData in the .NET client, maybe call it the same here as well?
If you want you could build the whole string directly as: String s = bids.stream().map(snapshot::getBundle).map(this::represent).collect(Collectors.joining());
Check out the guava class Joiner. This section could be reduced to Joiner.on(' ').join(restApis);
there is no separator between the versions. would you mind replacing this with : for (int i = 0 ; i < versionSet.size() ; i++) { sb.append(version.toString()); if (i < versionSet.size() - 1) { sb.append(','); } } return sb.toString(); In addition, it seems that this will become common around, maybe it should be pulled into new class, say VersionUtils ? (the class could be added next time there is a need for this).
not sure why this switch case is required - just use whatever is passed in?
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
EAP_7_2_0
Hi Tolis, would you mind to move the code below to another class?
private, should only be called from the builder.
Please remove this empty line.
Package private constructor, rather than just public?
It might improve readability a little bit if the expected score was a variable instead
I'm confused why we're returning the response. As far as I'm aware, either the call worked, or it didn't. If that's the case, return void, and let the exception bubble up to communicate the failure condition.
Should we really be returning an empty map of properties? If this happens, isn't it a system internal error? How about throwing an exception?
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
the dataStores list is being accessed from multiple threads either by iteration (as here) or to add or delete entries. However, I do not see any concurrency considerations which would require the collection to be synchronized on whenever accessed, modified or while being iterated.
Are we using lamda notation in this project?
IMO, we should directly pass bundle, instated of intent.
Minor thing: I'm generally not happy with reassigning method parameters.
this check is again done in getTaskCategory(..) and is redundant.
In Sunrise we follow the rule that unless a parameter is annotated with @Nullable, it can't be null. Therefore this line of code is unnecessary.
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
Spacing
Looks like there are true/false for query conversely then in other factories - should not be false for create and true for getMechanismNames?
In getBaseDownloadUrl you can't really identify what the context is. Instead you should just do a url.startsWith(Framework.getProperty("nuxeo.url")) I think, and drop getBaseDownloadUrl.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
Make them on the same line if possible?
Looks like even the brackets around i == j is not useful?
Remove conditional + exception. Uniqueness is guaranteed here.
Missing types
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
The only reason you had to override next(), expose pendingObjects, and duplicate all of this code was for this r.has(BOUNDARY) test? Any way we can skip that flag test on the commit?
I would like to see all new code using lambdas where possible.
Please stick to java naming conventions - variabls should not start with upper case. rpmsDeleted it should be.
I think this is a bit overly complicated as we can only copy the file if we find it (e.g. fileToExport is not empty). Moreover, please show a warning in case it is empty.
Can simplify with Optional.ofNullable
Please name it "Shortest unique abbreviation".
Don't catch bare Exception
No need
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
s/createPolygon()/createMultiPolygon()
so is everywhere using sample_value for human calling method?
s/numnParts/numParts
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Usage of StringBuilder would be more readable IMO
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
This doesn't look right. Should be:  result = services.get(result.getId(), k -> this.serviceRegistry.findServiceById(id, clazz));  Also, don't forget to check the result to make sure it's has the correct type based on clazz
Let's stick with T instead of Optional<T>. A huge number of folks already asked us to roll back the Optional change at findById and Optional isn't being loved that much.
Maybe we should move  && !authorizationProperties.get(id).getOnDemand() to public boolean isAuthzClient(String id). And enrich AzureActiveDirectoryConfigurationTest.
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(), ...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); }
Same nit about L.e(caught)
Missing @Override.
use of raw class, should be new ConcurrentHashMap<Long, Boolean>()
You can remove this call and also remove the public default constructor: it's not used.
If Defaults.REFERENCE_FASTA is set, is there any remaining mechanism for propagating it to CRAMFileWriter? Should something be calling ReferenceSource.getDefaultCRAMReferenceSource()?
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
please refactor number into a constant member field
style nit: no braces around single line blocks
can you make the name more explicit? array doesn't indicate anything.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Is it possible that the same project is added to the list twice?
should cleanup be in finally block?
Ik. Maven has logging facilities. We should use them.
Because a BlobProperty is also a complex property, this check should come before prop.isComplex(). In my local tests I got a NuxeoException with Trying to access a member of a null object: mime-type when trying to write a blob property, which was treated as a complex.
You also need to transform for the attribute for old version 2.1.0. I recommend looking for usage of ChainedTransformationDescriptionBuilder to make it easier to add transformers in one place going forward.
I have spoken to @dmlloyd and 'remote' and 'remoting' are two separate implementations, so we should not replace this behind the scenes. Instead, I would a) reject this if it is an expression b) introduce 'remote' with the converter if the attribute is **undefined** If 'remote' is not a valid value on 6.2 - 7.0 then we need to do something else :)
Given that this is a map attribute, when is this value ever FALSE? Why not use DiscarcAttributeChecker.UNDEFINED?
Even if it's very unlikely in this context, you could test whether the getViewer() return null or not (the return contract is "the EditPartViewer or null") before calling deselectAll()
Okay then I will apply a patch for your proposed bug report.
you can use IStructuredViewer::getStructuredSelection
Runtime Exception
Run formatter
Same here as well.
This method can be left blank-will not be called for a block-scoped step anyway, unless it is doing something between returning from start and the BodyInvoker.start.
can be shortened URI ssoRevokeURI = ssoRevokeUrl != null ? SsoUtils.buildUrl(ssoRevokeUrl) : ssoToken != null ? soUtils.buildSsoRevokeUrl(url, ssoToken) : null;
Can be shortened URI ssoURI = ssoUrl != null ? SsoUtils.buildUrl(ssoUrl) : kerberos ? SsoUtils.buildSsoUrlKerberos(url) : SsoUtils.buildSsoUrlBasic(url, user, password);
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
Do we have a test for RestServiceErrorCode.MissingArgs case?
Can simplify this to: return partitionIds.stream().collect(Collectors.toMap(Function.identity(), partitionId -> new CloudReplica(partitionId, currentNode)));
Nit : you don't need this local, you could just inline the member in the next line. (it doesn't matter)
How about also test the null NetworkCapabilities case?
I think the right command to run in this context is UpdateNetworkOnCluster, if the network is already attached to the cluster and only gets the display role. What do you think?
This is unrelated to the current PR, but seeing -argument looks strange from a UNIX perspective, where usually we use two dashes for long args and one for the short version (e.g. -v, --version). Could we change this to suggestion "--push-endpoint", cheWebsocketEndpoint, "--runtime-id", String.format( "%s:%s:%s", runtimeId.getWorkspaceId(), MoreObjects.firstNonNull(runtimeId.getEnvName(), ""), runtimeId.getOwnerId()), "--cacert", certProvisioner.isConfigured() ? certProvisioner.getCertPath() : "", "--registry-address", Strings.nullToEmpty(pluginRegistryUrl)));
getProcessValue doesn't throw an NPE -- you catch it in there and return null. I think you need a null check here instead of a catch. Or better, IMHO, have getProcessValue return an Optional<String>, then  getProcessValue(processAST).ifPresent(processName -> { ... });
You dont use anything from container except the name. Maybe leave param containerName?
I'd prefer to remove/deprecate AsyncTracer in favor of proper APIs to support what we want to measure. <LINK_0>
@ndinu @alegmarra Is this correct? The expression has to always return a number
dont hard code the format of the date
Please use diamond operator, you don't have to repeat time a second time. ArrayList<Integer> a1 = new ArrayList<>();
Why is it a list of lists, not just a list?
Use LinkedList instead, as we need to remove its head frequently in endInput.
It would be more Java-idiomatic to not modify the input variables (they're actually often declared final)
Do we need to spoof the location in the packet or can we just create the ender pearl at the correct location server side (by adding 1.75 to throwLoc)?
Does it work on line across dateline?
should the SortExpressionExtractor be renamed as well?
To avoid clogging up the majority of tests, the authorization result could be a parameter in the "full" overload (the one where you provide a planner config, context, etc). Then the "basic" overload (sql, expectedQueries, expectedResults) would stay the same.
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
Should stay consistent with the rest of the params. java public VideoDecoder( final EventPublisher eventPublisher, final VideoDecoderConfig config, final String broadcast ) { ...
different value 50 versus 1. Is that intended?
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
This if condition is already covered by the one below.
add null check for transcription id
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
In general, I think we should start the tasks that need to be started, and then stop the tasks that are supposed to be stopped. The other way around could potentially introduce latency.
not your fault nit: please change the type of toCancel to Set<DatastreamTask>
I would have three methods: usesIssueTrackerWorfklow(), hasAssociatedTask(), and hasTaskState() (meaning context or dates). Then just call setArtifactState(task, usesIssueTrackerWorfklow() && hasAssociatedTask() && !hasTaskState()).
If someone tries to add a plugin which already exists, should we overwrite it? Naively, I would vote yes. (Though I suppose you could remove it and readd it, otherwise-but then there are two separate events.) And actually it might cause problems/skew if the PluginIndex was overwritten with a new version of a class, but the SingletonServices ignored that new version and kept the old one, no?
createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME); should be the first thing we try. It will be the fastest and the most common scenario. pure createObject(name) should probably be used last when user supplies full package as name. Order of finding module should be, imo: 1) our module map test 2) 3rd party map test 3) full package (or raw) test 4) fail. We can probably discuss skipping 1-2 if given name has a period in it. 3 is only really needed if we don't examine maps for the full package. I don't really see a benefit from doing this.
If instance is null it means that Jenkins is either initializing or on its way down and if that is the case we cant do that much so throw an IllegalStateException.
This has to be cleaned up.
you could use Exceptions.expectExecutionException();
Why is the runtime tracking two layouts (i.e. layout and latestLayout), remove latestLayout and just update the this.layout as you discover layouts with higher epochs.
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
regionContainerMapping and regionMapping You should check that parent mapping is in stack mode.
I think we should make sure that the list of sorted by some criteria, so that we consistently choose the same element if/when there are many.
nit: Doesn't matter much because these are just examples, but I think it would be more clear to use the methods on the options builder instead of using an opaque properties object, like Option.Builder optionsBuilder = new Options.Builder().server(Options.DEFAULT_URL);
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
It is a bit nitpicking, but Camel is not started yet at the time of this message :-)
![CRITICAL](<LINK_1> 'Severity: CRITICAL') Remove this call to "wait" or move it into a "while" loop. [![rule](<LINK_2>](<LINK_0>
rename to launch
Please consider using org.eclipse.debug.ui.DebugUITools.launch(final ILaunchConfiguration configuration, final String mode)
Check null case?
why was this changed from constructor to static function?
lets make this an internal server error
please put in a separate method or rename this support method accordingly
move outside the if please
return id list
skipOnly is named terribly wrong. However as long as it means "continue search only when", you should _not_ modify this if.
rename the method instead of commnting
in theory this should be newTableHandle.getLayout . But if we decided to squash these commits it might not matter..
Shown on the UI so should be i18n aware.
BTW ^ and ( ) both gratuitous here; could be simplified to java if (!num.matches("\\d+")) {
return Jenkins.getInstance().getCrumbIssuer() == null?
- Does Consul take docker client as a parameter?
This could benefit from checking for IndexOutOfBoundException.
Should this be allowed?
Could you please move this message to the ThingStatusDetail of the updateStatus call below? This way users will see it in the UI directly.
i think you should be able to pass in config directly
I think you should be able to pass config in directly
Why not directly call a canDeleteInstance(input) ?
Shouldn't this be canDeleteInstance(input) && canEditInstance(containter)? Why would we need to delete the container?
Are you sure that this DRepContainer will be use at the end?
I think this check if not necessary and next check device for null be enough .
rename cmdResult to commandResult
Ignition should be boolean value. If it's not, we can just ignore it.
Shouldn't have printStackTrace() in production code switch to logging.
Why was this removed?
could you add a short description, as the method is non-trivial
No big deal but think readTree accepts JsonParser too.
This could probably be simplified with try-with-resources
Mb it is better to use common format for toString method? <LINK_0>
@vmaletta I think ep should not be there. Maybe a merge issue, could you please check?
Cleanup: Remove all **throws MiddlewareQueryException** clauses
Left-over debug ouput?
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
Use LinkedList instead, as we need to remove its head frequently in endInput.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Oh yuck. ;)
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
Does new consumer start not earlier than 10 sec and only if one of consumers 'got tired' from more than 10 message?
Nit: would you like to say "flow pause requested by user"? It's not given that it will be paused at this point, right?
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
:art: Personally I would lean toward using a guard statement. java if (entity == null) { return null } ...
I think that the logic to build these URIs, even if it is this simple, doesn't belong into the API. Please move it to the backend.
unnecessary linebreak
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
@danielezonca a negation over an sc AND and the result of an sc OR over two negations: is there a way to simplify it ?
IIRC anonymous users will crash here because they have no user account to get the prefs from.
suggestion sb.append("QueryImpl{"); sb.append("filter=");
Use conditionals to avoid the inner string concat with the subject.
Should we expose it users?
If we move the factory to QueryContext then this can just be replaced by QueryContext.empty();
@mderamos would not be clear to use IFNULL in the query instead og having a IF in java? also you can sum + 1 in the query something like SELECT IFNULL(MAX(Convert(s.uniquename, SIGNED)), 0) + 1 FROM stock s where s.project_id = :studyId
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
Unsigned types are not used in the current implementation. So, you can omit them.
ChannelClosed needs to be added to (though not strictly necessary)
Do you think it would be better to find a way of doing this without sorting a collection on every call?
Generating view on service level
Better to return empty collection rather than throw exception.
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
p2 still Java 5 as BREE and String.isEmpty does not exist before Java 6. Use version.length() > 0 instead
Minor suggestion/subjective: could get rid of the nesting here using something like: java if (displayName != null) { return displayName; } if (name == null) { return fileName; } if (version == null) { return name; } return name + ":" + version;
This seems defensive also, and it's also just a sample in a test. If the underlying method the handler invocation returns isn't expected to return null, then we shouldn't check for null and we should let the NPE happen.
this should probably fail on receiving interrupt
Log the full exception here as well, this should be fixed in entire PR.
maybe use dnsServerAddress.isEmpty()
Its worth adding a null check here too.
We shouldn't catch a NPE. We should prevent it from happening. What is resulting in an NPE?
flowName is not necessary as an additional method argument since it can be obtained from azkabanFlow.
Should we return true when file does not exists ?
IMHO ActorMappingConverter should be passed to ActorMappingContribution constructor
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
invoking combinations of close and releases here looks strange
Why don't you set them to empty lists so its safe to iterate over them in all cases without null checks? I know this is the deactivate method, but still, a Collection should IMHO not be null.
There's another potential issue I just noticed. The following code is only invoked within the launchDaemon() method, and not from launch() method: * <LINK_0> So can you please try using supervisor.launchDaemon() instead of just supervisor.launch()?
Thoughts on putting log messages in a Utils class?
When you have innerexception do you still need to print the exception? Won't the inner exception be printed twice when you print the outer exception?
return flagdown; ?
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
Potentially NPE can be thrown here. It's needed to check that the corresponding environment parser is present before using it.
_cough_ You might want to remove the println. ;) FYI, you don't need to create a new PR, just make a commit to your branch.
Can you please rewrite this to use a new key class? Doing this has quite a high overhead. [Here's an example fixed version of the old LiquidContainerRegistry.](<LINK_0>
We should only set the field when the key is present in the manifest, otherwise we will have to alter code in two places when the default behaviour for detectNdkCrashes changes to true.
Any insights of this change? If the inetAddr isUnresolved, shall we just fail the bookie, because: - if it is a fresh bookie, the address '127.0.0.1' that it announces is wrong. - if it is a bookie already registered, the address will be different from the ip in the cookie. I am not sure why do we need this change here.
Just a suggestion but I think this is a bit more readable and Optional is a bit nicer to work with than explicitly passing nulls around:  public static Optional<InetAddress> getLocalLoopbackAddress() { try { for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) { if (iface.isLoopback() && iface.isUp() && !iface.isVirtual()) { for (InetAddress addr : Collections.list(iface.getInetAddresses())) { if (addr instanceof Inet4Address && !addr.isMulticastAddress() && (addr.isLinkLocalAddress() || addr.isLoopbackAddress() || addr.isAnyLocalAddress())) { return Optional.of(addr); } } } } } catch (final Exception e) { LOG.warn("getLocalLoopbackAddress: an exception occurred while attempting to determine the local loopback" + " address.", e); } return Optional.empty(); }
I think this could be made smaller. - Always write the address - Write a boolean saying whether it's a scoped address (if getScopeId() returns 0, then it's not) - If the boolean is 1, write the scope ID
unecessary test : less is more.
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
Suggest you use .add(BashCommands.sudo("yum install -y riak")). If running as the root user, then on some VMs it causes problems to try to execute sudo. The sudo(...) method gets around that by checking if the user is already root. Same applies for other uses of sudo.
1. The code that tracks memSize needs to not run when the resource profiling is not enabled. 2. You don't seem to handle mutation of the strings. What happens when the string is replaced?
nit: space between REQUIRED and end quote
Just stuff all this logic in "getAllowedCategories" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getAllowedCategories(marketingInsightPool, marketingSeenCategories),random);
I believe we added a guard class to the sdk that will do this exact check.
scheduleTimes --> scheduleTime
use of raw class, should be new ConcurrentHashMap<Long, Boolean>()
Why the sub string ?
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Just an FYI for future - You can use this method for this: <LINK_0>
nit: remove this extra line
log creation on each run() ? that is redundant
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
Should be the responsibility of service/requestman layer after Hibernatization
random? really? I would have used idFor(). public ObjectId insert(int objectType, byte[] data) { return idFor(type, data); } public ObjectId insert(int type, long len, InputStream in) { return idFor(type, len, in); } or something like that. I forget which of the insert methods is the "bottom" of the call stack before punting to the InputStream version that is required, but I would implement both in terms of idFor and return the actual SHA-1.
why would this be required again?
There needs to be an optional API that can accommodate a user supplying a seed other than assuming the DEFAULT_UPDATE_SEED. Otherwise, the resulting Jaccard would be garbage if the original Tuple sketches were created with a different seed.
Could you check for null or empty? Via StringUtils.isBlank
This would never return a fully qualified host name.
Does it actually fail if the expansion path is not recognized? In a normal situation I know it fails silently, returning the query results as nothing happened, so it wouldn't fail. But as it's wrapped in this VrapRequestDecorator maybe it's checking it against the RAML specification?
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
When you changed the code to also provide the old API, you should be able to revert these changes.
what's the point of doing this?
You don't need this line because of green 31.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Create new lists rather than assigning them.
Can we use a immutable Vavr map instead?
Let's find a better name for _bufferSize
can be assigned inline in class member definition
What about doing one thing at a time?  java View frame = Views.findById(this, R.id.login_icon_frame_layout); frame.setBackground(new BubblyDrawable(getContext()));
move setUpToolbar()?
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
can be just inlined as setItems(new ArrayList...)
This is not required since you are checking for null in view
This should be List or Strings
since elements of the stream come from ImmutableList, they cannot be null, can they?
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
might want to change this to checkButton.setText(Strings.isValid(checkBoxMessage) ? checkBoxMessage : "<NONE>");
lambda?
We should have at least some kind of detail here, e.g. "Rebase this patch set against master head?"
We could just always use the body instead of flipping based on the payload size.
Why ISE instead of IAE? This is a setter. Assert.isTrue() ?
This could be set in the constructor instead of checking this on every request.
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
Do we need to start deprecating some of these cases if we are going to just combine them?
previous naming was more clear.
can we also include a test where we set includeInsights to be true?
I believe this onError clause may trigger for 200 status code if the response JSON does not contain all the information that we expect it to have. I suggest to change the error to mention that it's either an HTTP error or a malformed JSON. (We can still include the response code into the JSON.) &mdash; Or am I missing something?
Should we just add new ParseHttpResponse.Builder(ParseHttpResponse)?
This looks rather scary here: I would think you'd want the return type of #processUpdate to indicate whether there was an event that should cause everything to be reset?
This can be reduced to: java return getLatestLiquibaseSnapshotVersion().map( snapshotVersion -> LIQUIBASE_SNAPSHOTS_FOLDER + File.separator + snapshotVersion + File.separator + LIQUIBASE_CORE_DATA_FILENAME);  Not that you need to make that change.
Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
Just add an envelope section to createFromEsriGeometry method in this file
we'll never reach break;
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
I think this should be after oos.writeObject(o);, in case there is buffered data. In any case, before obtaining the byte[] result.
You can consolidate these into a single try e.g.:  try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos); ObjectOutputStream oos = new ObjectOutputStream(gos)) { oos.writeObject(obj); conf.set(key, new String(Base64.encodeBase64(baos.toByteArray()), "UTF-8")); }
Why is this hardcoded? and why is it 1 not 0?
prj is not a good name for variable
Also the exists -> exist
Could you please remove the double "must"? In all the other methods in this class as well.
We should change that test, it makes it cumbersome to implement rules in parallel.
Removing test because you can not fix it is usually bad idea
Nice, I wouldn't have thought of that!
This isn't really great, as startAngles could be empty.
For each?
Please write a unit test to test this transformation.
nit: final modifier for unmodifiable variable.
Did we mean to remove the subscribeOn here?
Instead of calling into the Utility conversion method we should just chunk the InputStream into ByteBuffers the size of ParallelTransferOptions.getBlockSize. It'll need to be a conversion that runs until the InputStream is depleted and indicates end of file/stream.
modify it as it was implemented in ENG-10264
typo
This is what caused the problem. Please change the message.
What are the possibilities of a null return value here? I guess such a case depends on how clients define ParameterUpdater, but is it okay to let that happen? Just out of curiosity, but this seems more of an entire EM question.
This can be simplified to return Futures.immediateFuture(name);
AggregateRoot is not an Entity.
Hm, I think this should probably fall back somehow in its current form, or throw a much more explicit error if it fails. Before we had a guaranteed no-error, since the array was fetched from ID resource. Now it could get removed and our error message would be incredibly vague. Especially since this can now fail due to a change in commcare-core that is quite invisible to the end-user here.
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
Why did we switch out the old code back to this?
this doesn't look like new code... was it reinstated after a merge or something?
log the sleep duration maybe? and maybe remove the exception?
I assumed you were going to pass entryFactory here
Cloning after calling getEyeLocation is unnecessary
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
If the test fails, unsetColoring would not be called. Could presumably affect other tests.
remove or assert ;-)
@ndinu @alegmarra Is this correct? The expression has to always return a number
What is the reason for the longer version? EDIT: ok, did no see it was from hibernate. You could use String.join from Java 8 though.
I think you could read the file contents with many fewer lines of code, especially in Java 8. Something like: java return Files.lines(filename).collect(Collectors.joining(System.lineSeparator()));
Should use ToStringBuilder.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Can this be private, or is there another use case for default attribute outside the builder's call?
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
I think there are race conditions where this loop will not see all of the locks (like locks added during the lifetime of the loop). That is why I used an array of locks in lbschanno#3
Since the wait may be long here, it'd be useful to have a log before the the attempt too please.
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
I had to do a doubletake here, it's an extra line but this could help readers java if (caught != null) return caught; if (request == null) return null; return request.maybeError();
Ah yeah that makes sense to me
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
isDebugEnabled
We don't use final for local variables (noise for the reader). It's not needed for the lambda because the compiler can detect that it's _effectively final_.
This seems sneaky
A bit shift would be faster ? Also we don't check for integer overflow issues.
Please add the {} even for one-liners
Using this syntax you are creating a subclass of HashMap everytime this method is invoked. Can you please refactor to avoid the creation of this map?
can you reference the enum values here?
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
Having execute{Head,Get,Post,Put,Delete} are just wrappers to execute() for convenience and readability across APIs Spreading the logic of type checking will lead to confusion in future and its not a good idea.
This should be done in execute()
this might not be true for 'executeDelete()' when we implement Multi object delete API. Change this to executeDelete() itself taking the content length.
Why is this hardcoded to 4 threads? Should there be an option to control this?
We should use Configuration so we can pass STORAGE_CONNECTION_STRING via system properties or environment variables
Why not inject it using guice?
suggestion
suggestion  refresh still shouldn't be necessary.
suggestion
Didn't we talk about reusing the code of SyncAllHostNetworksCommand? Maybe we can have a util for 'getUnSyncNetworkAttachmentsByHost'.
Best to do it before line 69 so the iteration of the selected ones will be shorter
It's pointless to have this in the API level down if you're just going to throw.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
Now that this is not a part of the original method anymore, it makes even more sense to not unwrap the original exception in order to not lose the whole trace leading not only to the executor thread but also to this finishAllThreads method. I think my original attempt to make the stack trace shorter has the potential of reducing clarity rather than improving it (in other words, I did a stupid thing originally).
Tests should never suppress exception but rather propagate them or use an ExpectedException rule.
This can be small D double
These members don't appear to be used.
Use Iterators.transform from Guava?
boolean strict = Boolean.getBoolean("nuxeo.start.strict")
Why do you have to check for null here?
final
checkNotNull
With <LINK_0> could we remove this method, avoid the loop and use trace.getAnalysisModule(id) instead?
In the events table the columns "Tid" will display the HostThread.toSting() which includes a long Host ID. This is not what I expected for that column. Shouldn't we see the TID value instead? It's confusing for me (at least for me).
s/Started/Starting
If this throws an error it should not need to log it. Perhaps you can throw new RE(e, "Failed to start lookup [%s]:[%s]", lookupBean.getName(), container);
in the end can we log the failed lookups that we were not able to load even after all retries?
This statement is the wrong way around, you are checking for the opposite, so remove the negations here. Also the armor item and the SlimefunItem need to be swapped too.
else on the next line after the bracket.
No need to cast a Player to a Player here.
Why do we want to return here ? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fPostListenersByPartId.get(listenerPartId)
same here. however I'm not sure if you can update tags on version. AFAIK version should be immutable and be result of write operations. Does updating/setting tags bump blob version? (updating metadata does that)
!part.trim().isEmpty() ?
you can append "twice()" to the expect
Should we verify regardless of the NPE?
Would you please remove the unnecessary type argument?
Swap the equals condition.
We can use the constant - MultitenantConstants.SUPER_TENANT_DOMAIN_NAME here.
shall we use a more meaningful name like 'gson' rather than 'g'?
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I think .equals would handle it anyway, but to be safe you should put a L at the end of the literal.
Also called twice here.
I think that if JsonObject and JsonArray implement it, we need to remove them from this list as well
Enum should not be handled here, should be left to SerializationContext.canMarshall() because it needs to check that a custom marshaller was defined for the Enum.
It's not your doing, but this line cannot be reached because of line 171/169. And, in fact, CLASSVARIABLE is never used. (Also not your doing.)
I Don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an abstract method where each subclass does their own thing.
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
Would it be the same to say lemmasList.addAll(keyValues) here?
no need to specify type on RHS
All lines between beginning of this method (and all others) and this one should become the setup fixture (@Before). Then, for the methods that require a writer or loader, you could just reference the CacheManagerBuilder field, and append .using(...) as needed.
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
I would prefer a bit more OO way, something like: new KeyValue(key, value). append(new KeyValue(key2, val2)) ... .toString Than the KeyValue would be an inner class which looks like this: class KeyValue { private String html; public KeyValue(String key, String value) { html = "<b>" + key + "</b>" + value; } public KeyValue append(KeyValue other) { html += "<br />" + other.toString(); return this; } public String toString() { return html; } } BTW there is no real need to worry about StringBuilder vs "+" in the GWT since it anyway compiles to JS and it is hard to tell which way is faster (in some versions of some browser the StringBuilder, in some the "+" but the difference in this small amount of concats is not significant...)
@aertoria Can you change all the variable names in test method to not have _1
we still need this snapping logic if the window is not divisible by the step size
Incorrect grammar for "is correct include"? Either "is correctly including..." or a semi-colon before "include"?
suggestion return details.getHtmlDescription() + "<br/><br/>" + extendedDescription;
Should this pass true for dryrun, when calling parse?
So just initialise the rubricWeightsForEachCell as empty 2d list should be enough.
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
One cannot assume the request object in the context to be always of type of HttpUriRequest. It would be safer to use the generic HttpRequest type here. Otherwise everything looks good to me.
This needs to stay or we need to initialize the array with an empty array to avoid an NPE in the LoggerNode.addHandler().
I dont think this is necessary at all. In fact, The existing MFA extractor I think should be removed entirely. Rather than putting this into a request attribute, why aren't we just using the swf context directly?
doesn't the node need to be closed?
do you need to check the other fields? two objects cannot be equal otherwise right?
Minor thing, but should the null check come first.
Pass "e" into the LOG call and remove the explicit call to print the stack trace. (Avoid calling e.printStackTrace();)
Won't this logic always execute if the path doesn't exist? What is the point of the previous if?
remoteSize is never read. If the line is remove, the function can be removed too since it's not used.
assertFalse(...);
assertFalse(...);
Since it isn't an expensive operation after each test would be better
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
paranoia: can we first set it to false, and *after* that call GTK.gtk_widget_queue_draw(widget);
I think 15, 11, and 4542278 should be named constants.
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
I think pending file is not required as your fileQueue becomes list of pending files.
This is not needed after ConcurrentHashSet
I'd instantiate the ProducerArbiter before parent and supply it to SwitchIfEmptySubscriber and child, saving on this 'relaying' allocation. (Remark, our life would be much easier if we could implement Producer in Subscriber, but since request() is protected final, it is unoverridable :( )
Can you please merge duplicating code here? Something like:  java final Subscriber<T> parent = after ? new BoundedAfterSubscriber<T>(child, capacityHint, predicate, prefetch) : new BoundedBeforeSubscriber<T>(child, capacityHint, predicate, prefetch); child.add(parent); child.setProducer(new Producer()  ); return parent;
I think we shouldn't call the error handler if the error can be delivered or replaced on the normal path.
This should be an @Override of implemenatioin super type..
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
I don't think the timing of setExpanded() is the real cause, it is currently done in the correct order. It must some other timing issue that your patch is modifying and helping. Maybe there is something in the Eclipse platform that is not ready at the time that the events are received, maybe something is computed in a deferred thread? It needs further investigation to understand what is missing to properly set the tree item label and when does it actually get set.
InsertOrUpdateObject?
will VDSM's settings be equivalent to set "<on_reboot>destroy</on_reboot>" in the domain xml?
This change should be discussed in another PR.
close streams
I would add mcast-port=0 as a default
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
java this(parent, batchSize, supplier, excludedKeys, topologyId); this.currentTarget = Objects.requireNonNull(specificTarget);
Translate this RuntimeException message in English please
You've got some auto formatting thing on which basically adds "this." everywhere. You may like it, but it makes for a very noisy diff :-( This diff Should be a 2 lines fix. There's no need for the incremental approach here either, given that it's a trivial change. Making it an incremental PR just delays it's acceptance.
There must be a more succinct way of doing this using streams.
taskStorage.getStatus(entry.getValue().getId()) might return Optional.absent().
What is the TTL for tables that don't have it set explicitly? If it's LONG_MAX, then please make sure hasRowExpiredOnSource() does not overflow when doing sourceTS + ttl.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
canWrite() includes exists(), so no need to test for existence separately.
If we already have a value, we don't need to determine it anymore and can just return the previously computed value even for read-only directories.
try using getOrCompute instead. Besides delaying creation of the collection to the moment where a key actually wasn't found, it also stored the result in the map, making it somewhat faster for consecutive invocations.
could make use of java8's stream.map.collect thing
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Should be moved into a private method that makes the above find() more readable.
Just return listCache in here
mReportList instead? I know, annoying. But I am so used to m\* in our code base I code seriously confused reading this function understanding what is local and what is global.
Why not just LogKitten.ex(e)?
What about catch (Exception | LinkageError e) {...?
@sbespalov : What is isLsm(...)? What doest this abbreviation stand for? Layout-specific metadata, or is it something else? If this is it, could you please rename the method, so it's clearer? Thanks! :)
shouldn't required be true here?
lets make this an internal server error
Why are put requests injected differently than post requests? Put requests contain the blobId, but that doesn't appear to be used here.
minor: Not sure if there is like a single pattern we want to advocate. inlining versus having OutputStreams being pre-declared. If so, would be nice to use them consistently.
I think this should also be able to lookup the membership with the matching patient and remove it so that a call like the one below works too: Cohort.removeMembership(new CohortMembership(Context.getPatientService().getPatient(patientId)))
maybe make a copy constructor for this case?
should not error if docker doesn't exist?
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
Should we return emptyMap if we are SUSPENDED as well?
I like the use of Map.Entry here. Nicely done.
Use TreeMap to keep the order.
Why are you using a Queue here? And then by extension a LinkedList?
This should Log the exception to the logger
Would this be a good place to use the LOG instead of printStackTrace, or was there a reason you chose this method?
These asserts are unreachable
please remove this "assert", it is not required , it will do no good in future updates.
This test doesn't show a difference with testBasic() Maybe there will be enough this:  RetryTemplate retryTemplate = new RetryTemplate(); ... assertSame(retryTemplate, TestUtils.getPropertyValue(interceptor, "retryOperations"));  ?
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
Does mLoginListener need a null check?
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
remove "public"
Maybe "Default instance resource, CPU: %f, RAM: %s, DSIK: %s"
Please remove sysout.
IIRC patchTable can be null if a user directly jumps to this screen without coming through the web UI. (Consider copying and pasting the URL of a side by side page into email then clicking the link to open a new browser window.) So we need to handle patchTable being null here and assume diffSideA is null.
should we use connection.equalsPeerAddress ?
why is equalsIgnoreCase used and not just equals? Also, this if statenebt is redundant: if (booleanStatement) { return true; } else { return false; } just do "return booleanStatement"
BUGBUG: Should be checking whether the shard contains the start position, not the entire event.
When you changed the code to also provide the old API, you should be able to revert these changes.
@katmatt i'm not sure you are right person to ask, but at least you could refer me someone else. My question is: don't we want to update assertJ dependency from currently used _3.3.0_ to the latest _3.8.0_, it is 1.5 years since that version and now it has a lot of handy tools, like arrays comparing (including ordered or unordered).
Should be outside the if
Maybe instead of repeating the checks here, we could remove the .size() checks, leaving it to be checked by the following call to the overloaded isEqualCollection.
Collections.emptyList()  might be better here too like you did above.
Should stay consistent with the rest of the params. java public VideoDecoder( final EventPublisher eventPublisher, final VideoDecoderConfig config, final String broadcast ) { ...
optional nit: this is still confusing for me, maybe it could be reworded as suggestion Unable to determine max direct memory size. If druid.processing.buffer.sizeBytes is explicitly set then make sure to set -XX:MaxDirectMemorySize to at least "druid.processing.buffer.sizeBytes * (druid.processing.numMergeBuffers[%,d] + druid.processing.numThreads[%,d] + 1)" or else set it to at least 25% of maximum jvm heap size.
Since we're using -timeShift could you check the Schema factory and MockDataStore factories to verify they're the same please?
This block only compares AttributeAccessItem objects to themselves. It should compare them to the AttributeAccessItemDto objects from the corresponding indexes of attributeAccessItemDtoList.
@cuenyad Having 2 for is not needed. Iterate lotDepositDtoList and have a map with LotUID as key
This is duplicated several times.
There are a few checkstyle errors left:  [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
Nitpick: Should we name checkedItems1 to something else? Or maybe we could do something like this:  mListItems.setCheckedItems(((AlertDialog) dialog).getListView().getCheckedItemPositions());  _P.S: Android Studio can't find MaterialAlertDialogBuilder for me, so I couldn't play with it._
This array must be calculated one time only
any reason we are using System.exit(0) do you see a hang without this?
I think we can later implement a logger instead of directly printing to sysout. For now it's okay though. :)
I would not put this method as an example. This API is just... not possible for me. It looks more an error than an API. Is this used by users @wfink ? If 'not really', for me we should remove it from here IMO This API of creating caches at runtime should be changed and I mentioned in the thread in zulip @tristantarrant @wburns
I propose to change it to:  Map<String, String> metadata = new HashMap<>(); metadata.putAll(clusterConfig.metadata()); metadata.putAll(Microservices.metadata(servicesConfig)); clusterConfig.metadata(metadata);
Just a thought (not a review) - I wonder what values we achieve by testing server side behavior like this. Do we want our build to break if server side changes this behavior, say, one day they just allow updating the metadata?
Can we inject this feature directly ?
It's probably best to have more descriptive names for these. "running," "direction," and "open" would be fine.
Is there a reason you can't do this when it's already at the bottom?
Shouldn't we be moving the elevator while we're moving the clamp?
nit formatting space between methods
why don't you do an index loop?
personally I avoid names like o, i, l etc... Even obj is better. Also ... where is it used ?
no need to specify type on RHS
We don't need another ImmutableList.copyOf. You are doing this when parsing.
you can actually just set the private List<String> enabledTemplates = new ArrayList(); above and not have to worry about this. When dropwizard/jackson reads the config it will override based on the yaml if needed (since you also provided a setter)
avoid increasing visibility?!
initial null seems not needed. Probably can be a for () loop :) for (ISourceModule module; (module = modules.poll()) != null;) { ... }
As a style thing, I don't know why you have the CheckFileExistenceJob directly do the refresh, but the other job does it in a JobChangeAdapter?
This will loop forever if the user sets a negative size.
4 spaces
4 spaces
It seems there exists a ProActive property that could, perhaps, be reused: PAProperties#getFileEncoding. However, after a quick look, I am not sure that setting file encoding is required. We define encoding at JVM startup to UTF-8, thus default encoding is UTF-8. Then, if charset is no set when creating an InputStreamReader, default encoding is used.
Can be changed by Framework#doPrivileged(Supplier).
Don't need last else
This should go in a finally block in case an exception is thrown, right?
Nothing harmful, but the null check is done twice.
coding style:  try { ... } catch (ClassNotFoundException e) { // Don't mind... Attempt next class loader |
Minor: Please add whitespace before the final argument.
This should be simplified to just: >return value;
This should be simplified to just: >return valueParameter;
why is this necessary? Is the tab sometimes hidden?
View.edit(model) should not add new listeners to model object. This should be the responsibility of associated presenter - for example, in GlusterVolumeSnapshotCreatePopupPresenterWidget: @Override public void init(final GlusterVolumeSnapshotModel model) { super.init(model); model.getForceCreate().getEntityChangedEvent().addListener(...); } View.edit() is responsible for populating UI from model data and can be potentially called multiple times. Model listener registration therefore doesn't belong here, but in AbstractModelBoundPopupPresenterWidget.init(model) method override.
is this required?
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
actions can be null when anonymous, need to test the null pointer here
Would we want to preserve the previous selection (before archive radio was selected)?
The default toString on the List doesn't do the same thing?
lots of loc here :) this method was only present for toString ordering
should be just "display"
4.2
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
You could probably use the same URL as in getResultById here.
suggestion return getInstance();
Please refactor to different methods
No, RunVmCommand is executed before the VM is running, The VM's status should be down
I don't see any change that is related to elapsed-time, why is this change needed?
Why is it a list of lists, not just a list?
either if (!storageDevicesListCalls.isEmpty()) or storageDevices != null below
Perhaps you could extract questions.get(response.feedbackQuestionId) into a variable to make more readable
Can be replaced with ImmutableList.of().reverse().
Maybe we should name this variable entityReferencesDescriptions?
s/sssion/session
Use fire(event); for all EventHandler based events
nit: plural naming on list?
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
rename to childItem
I am finding this confusing. Why would we need to parse the version to figure out if it is a range or not? Shouldn't we be able to just pass the version as set in the POM (range or not) and let the artifact resolver figure it out?
Please, refactor this abreviation. <naming
Please create a temporary directory and remove it in @AfterClass.
unneeded - just use tmp
A public method should not throw more than one exception
The stream() is not necessary here.
fair enough
@cvrebert We should name this variable existing, as per our naming convention [here](<LINK_0>
handle null case (same for rest below)
We can probably partition on the QUERY_PARAMETER_LIMIT (may not exist in 0.9.x, but it's set to 32k by default) rather than the IN_OPERATOR_BLOCK_SIZE. If we opt to keep this as-is, we should probably drop use of CPRestrictions, as it won't add anything of value.
This might be a little cleaner with streams.  return streamingPropertyValues .stream() .map(StreamingPropertyValue::getInputStream) .collect(Collectors.toList());
I'd break this up as java StringBuilder sb = new StringBuilder() .append(formatExpression(column.getName(), parameters)) .append(" ").append(column.getType());
nit:sb.append(" NOT NULL")
Can you add the other flag values as well?
the build() call is not necessary here
Shouldn't we be passing an executor here? Was this missed by will's checkstyle PR?
RestCacheManager.getCacheManagerAdmin() should already return a privileged RemoteCacheAdmin so remove all these Subject.doAs invocations
since you are awaiting termination otherwise, seems like this should either be an isTerminated() check or you should do an awaitTermination() anyway in the else. Let me know if my understanding about the ExecutorService interface is wrong.
Cassandra has not started
Where is selector.close(). It is not in NonBlockingConnectionManager::close() (which is where I think it should be).
if (trace) ...
I would add the keys directly to ReplKeyTracker. You are creating a new HashSet here and when you instantiate the ReplKeyTracker.
why the addAll()?
Is there any value in asserting that these commands come in the right order? Although the implementation is a List I guess it protects against changes to duplicate checking or something doing an insertion into the wrong place in future. Maybe something like: if (latch.getCount() == 2){ latch.countDown() } else { fail("Wrong order")} for start and similarly with a 1 count for the stop event. WDYT?
What does the *10 do in this context?
The same as ^^^ above
void observe(@Observes Object event, Foo foo) has no observed qualifiers so it would NOT be recognized as a container lifecycle event - that's not correct. Also org.jboss.weld.tests.extensions.validation.WildcardObserverTest accidentally passes (the deployment fails with "_org.jboss.weld.exceptions.IllegalArgumentException: WELD-001456: Argument resolvedBean must not be null_").
This looks like a merge error. This code should not have been deleted.
Hello @mcimbora , I think it can be worth to provide a more fine grained filtering here. To be sure that the method is not a constructor, has the @Generated annotation, and also "is one of the generated" by the planner stuff. Probably inspecting some additional planner generated annotation for the method (I I don't remember wrong for this planner generated method you added has also a planner annotation with two parameters?) or eventually exploring the return type, or some other trick. This will prevent us from loading other methods with the @Generated annotation that we don't know how to manage. Specially because when the java source is being updated, all the accepted methods are being deleted.
s/any(List.class)/anyList/
Dont we need to verify the execution of runInternalAction ?
IMO using a concrete instance of PerformAutomaticLayoutCommand and passing mock objects to its constructor is nicer than mocking the class under test and using doCallRealMethod(...)... but it's only my opinion.
should it return the record count?
I would rather choose to have a while loop to implement this rather than a recursive call (call stack can grow quite big unecessarily because of this call depending on the level of nesting of the file) and moreover, I believe a while loop would be more readable.
break?
it's a minor thing but you can avoid the duplication here by changing this to suggestion {"pass_queryname.sam", 0},  And use Paths.get(TEST_FILES_DIR, input) below.
would be nicer if you'd use a block dispatch node here instead of doing it manually, and unoptimized.
Thought: I we would use java.nio.file.Path instead of java.io.File we could easily use [Path#of](<LINK_0>,java.lang.String...)) for convinience instead of coding this logic ourselves.
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Would be good to add one final assertion that the folder created exists at a non-transactional uri after the tx closes, so just make sure that a non-tx client can get a 200 response at the obj uri
Also verify here that the created folder does not exist after the rollback. Also maybe check that the active transaction was cleared?
Should not the latest _win_ here, as per last discussion?
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
seems like we would like this log message for all exceptions no? can move this to mutlicatch as well.
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
something could go wrong here, it would be nice to be consistent and not return null but string array of size 0 like on the other functions (in other classes)
Why new String?
we should add a log statement here for more info on what's going on. And I don't know how I feel about returning null.
You have chose a policy=static for the reference, so it cannot be null.
do {   } while (current == null) is more natural here.
So you removed final, but keep it immutable * Returns an empty list (immutable). This list is serializable.
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
Should be DRYer to extract a method to update the texts of all 3 stats text nodes, as they should be updated together (either all or none). So I think it's not a good idea to just update the totalIssueText like in the if branch.
unnecessary parenthesis?
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
any reason we can't use an empty list for the sentinel?
This seems like a good place to use our LocaleUtils class instead.
It might be better off to calculate all this on initialization of the clustermap. these are never going to change and recalculating them every minute is not useful.
Same as getLatestSequenceNumber - save the current position and restore after
This call has the side-effect of actually changing the position of the pointer in the stream which may be unexpected by callers. You should save the current position, get the latest sequence number, and then restore the current position after.
Maybe use a somewhat more descriptive variable name rather than 'x' :)
we never use NULL, it is a bad practice in general.
Leave this and others empty if you don't intend to support any other metric types. This will cause it to ignore data which is of the wrong type.
CREFormatException, not CRECastException
return CBoolean.get(Character.isUpperCase(check)); No need to make this into 6 lines.
unbalanced closing ] at start of string
this still needed?
Remove this. =)
I don't like the word "command" in "where the WES command should run". If anything, you're sort of running the (client) command on your local box. How about The URL of the WES server, e.g., ..... Also, I think you should say URL, just to be consistent with --wes-url; right now it's a mixture of url and URI.
1) what do you want to test between line 65 to line 69? why not write it in a loop? what is the difference between line 67 and other lines? 2) you might consider verifying the mock BookieClient on how many times it is called?
I don't see the difference between testWriteAdvHandle and testWriteAdvHandleWithFixedLedgerId. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
Isn't there some simple little library for generating JSON output? This seems icky, who knows whether item.getItemID() returns something nasty containing backslashes and whatnot...
i18n
i18n
Please log the bundle ID here.
nit: put input.getId() in new line, and also other calls to addOperatorToStreamGraph.
why not just return it directly?
This will return all revisions for a single ID, use RevisionSearcher.search(...) instead of the raw searcher. Also you can use the already opened RevisionSearcher instance via context.service(RevisionSearcher.class).
Please change to "clear tokens from local token cache for the user".
Who told you to do this? We still want the localized message for these exceptions
I think exception instanceof InterruptedException should also work... But I think maybe we want some kind of exception hierarchy, e.g. InterruptedException trumps everything else, in which case a separate variable for each exception type would be better. Also, I think we should try to preserve all the exceptions when there are more of them, maybe with addSuppressed().
Why is this needed?
adLeftApplication() should be called if the user clicks the Ad and adClosed() should be called once the user returns to the app.The Publisher assumes that the user regains control of the app when adClosed() is called. But here adLeftApplication() is called after adClosed(). Please change accordingly. Similar change is needed [below](<LINK_0>
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
Add a message to checkState so that it's easier to debug if we ever hit it.
Changes to this file should go in the previous commit
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right?  1 2337032 rs1129171 C T,<NON_REF> 480.77 . BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
Maybe just throw an exception here to make this more clear?
@datang1992 another thought, just do 0 to x (where p(x) is close to zero).
Can we move the path to ApplicationUtils class?
shouldn't we use Builder here. coz, no one outside the package will have access to constructor.
It will be very easy for this to break silently if the panes array length changes in the future (which of course it could). Maybe we should just continue through the loop for this tabset?
@cvrebert can we move this up?
It's better to introduce Pull.STATE_OPEN and Pull.STATE_CLOSED and use them
Maybe you didn't commit it?
do we need to sleep(1000) here? can we make this test sequence more deterministic rather than depending on time, to reduce flakiness?
I'm not sure we can consider angle-bracketed alleles to be INDELs any more. For instance, in the RS release VCF report we are going to write <156_DEL_BP> and consider that a SEQUENCE_ALTERATION.
It might be helpful to use different min/max values for bounding box so we can test the order is correct.  peliasWithMock.search("test", "1", "2", "3", "4", "5", "6", callback);
How about return Objects.hashCode(message, Integer.valueOf(desiredCaretPosition)); ?
We need to check null before reference dvd[i] here.
Hashcode of the groupname should be sufficient.
can be replaced by:  acp.getOrCreateACL().add(new ACE("Administrator", "Everything", true)); acp.getOrCreateACL().add(new ACE(USERNAME, "Read", true));  and the code section will be  ACP acp = new ACPImpl(); acp.getOrCreateACL().add(new ACE("Administrator", "Everything", true)); acp.getOrCreateACL().add(new ACE(USERNAME, "Read", true)); doc.setACP(acp, false);
Name it folder, or reuse doc maybe? domain is misleading.
Oh yes, can change this back to formatDateTimeForSessions and delete this method from TimeHelper? It's a workaround for this issue.
This if/else could be replaced with:  getHistoryWriterFromElementType(ElementType.getTypeFromElement(element));
I would not mind such a change if scl_prefix gets filtered so it doesn't show in the outline. This is the reason why the eval was added.
style nit: no braces, more occurrences below
This is fine, but even better would be to also catch any ToolError (e.g. a typechecking error) and print the error message on standard error.
Is randomData optional? When I only specify the version to generate some data (with a command that looks like .... org.apache.parquet.benchmarks.DataGenerator generate v2) I get an exception  Java Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 2 at org.apache.parquet.benchmarks.DataGenerator.main(DataGenerator.java:188)
Let's omit System.err here, as printStackTrace() without parameters is doing the same. (Also in the other file)
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
Better enclose the if block in {}.
nit, I think this can be simplified like this: java return Arrays.stream(line) .skip(1) .filter(component -> !component.startsWith("--")) .findFirst() .orElse(null);
:o
If you don't think we want to expose it to the user, then I wouldn't include it at all. We can always add it later if there does seem to be a need for it. However, if this is part of building the response, then don't we need to include the version so it can be used for choosing prior versions to roll back to? Or at least, you need some kind of unique identifier for each version to enable that feature. If we don't want to expose the real primary key of that table, you could use sequential integers for each version (sorted), or something of that nature.
Omit nulls or not?
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
You could replace lines 933 to 945 as follows to make use of short-circuit evaluation:  if (file.isFile() && ((suffix == null) || (file.getName().toLowerCase().endsWith("." + suffix)))) { files.add(file); } else if (file.isDirectory()) { listFiles(file, files, suffix); }
It makes sense to introduce UNCPathConverter.isUNC(IPath) method that operates on path directly without calling toString().
- this.ephemeralCount = new HashMap<>();
Do we need L106~L112?
is it necessary for this to be synchronized when the map is concurrent?
code formatter missing? At least there should be a space before the curly bracket and you have a lot of tabs in here...
Is it by intention that you set the status outside of the "synchronized" block? Before you set the status within it...
I think it would be better to store the output of getRuleStatus(rUID) in a local variable instead of doing this call twice.
Why not use Thread.isInterrupted() ? I know we had that discussion already, but my memory need to be refreshed.
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
And btw we tend to write Camel instead of Apache Camel in these log messages, maybe we should just do that. Yeah its friday and its 'bike shed' day ;)
I think it is better to return an empty collection instead of null.
Shall we throw GeoLocationBasedServiceException  wrapping RegistryException ?
Shall we throw GeoLocationBasedServiceException  wrapping RegistryException ?
Check if this test of relation is also in BlImpl part. If not, move it there.
I'm not sure, but there might be a problem when destinationGroup == null if you try to check authz for VO/Group admin role. In such case you should probably check only VO manager role (on movingGroup).
Use new lines.
Could use forEach here too, otherwise we're not really gaining anything from using a lambda
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Could inline syncGet() in getCacheEntry() and use that here.
in calculateQualifiedVersion(), there are other ways to set the qualifier which are not being validated. rather pull this out into a dedicated validateQualifer method and call it after qualifier was determined.
nit: lowecase "a" - applicationProperties
just remove the fileSize from here... and that's the only change you will need.
Since you are returning inside the if-blocks, the elses are redundant and can be omitted.
Same as with for. Spacepolice is calling :)
Casts should have a space after the closing parentheses. There's a couple to fix here. Ex.: ((GlowTntPrimed) source).getPlayer() != null Also you can store the GlowTntPrimed instance before returning because you are casting it multiple times: java GlowTntPrimed tnt = (GlowTntPrimed) source; return tnt.getPlayer() != null [...]
Do you have an opinion either way about (in the future, not now, let's just get this done already) rewriting this and any similar lines to Optional.ofNullable(property).map(prop -> new TypedValue(prop.getQualifiedType(), prop.get(obj)))?
It's better to base this decision on the full type signature than using instanceof:  if (Map.class.isAssignableFrom(GenericTypes.getErasedType(type)) && String.class == GenericTypes.resolveType(Map.class.getTypeParameters()[0], type) && String.class == GenericTypes.resolveType(Map.class.getTypeParameters()[1], type)) {  Also the factory must be able to bind null with the correct SQL type.
as far as I understand the usage of this method it seems you don't get anything out of Optional: this method should just return null
should go to stdout, well, I would have put the stdin/stdout/stderr in context by core, but not that important for now. and again, all this can be acquire from the parser, so if we add new fields it will be available to all. all you need to do is print parser.getUsage().replace().replace().replace()...
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
I don't like the density here. I would prefer if all arguments of the constructor are declared as local variables.
Catch SkipException in separate catch clause
np: s/LocalApplicationRunner/RemoteApplicationRunner
Nice, thanks for consolidating the method signature.
1. _1 suffix almost everywhere means that error code has one parameter. Use different names for exceptions. They are also expected to be self-descriptive. 2. Vendor-specific codes can't start with '0', '1', '2', '3', '4', 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H'. Don't use 42S here, add some plain 90*** codes instead.
What type of view will TIMEX3 be? Right now, it is of type NULL. Move the case to the block that contains the correct view type.
Unsigned types are not used in the current implementation. So, you can omit them.
What if client is null?
ClientConnectionException mean that there are issues with network connection. Please consider reconnect logic here.
I'd like to understand the reason of this extra MutableMessage creation object before encoding...
Please extract to a method and call it after you verified this is an image disk
Very unreadable, please extract to a boolean with a meaningful name
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
Can we use already-defined constants for the following three strings?
Can these be declared at class level and used for both methods?
Don't forget to line wrap when breaking past 120 chars; there will always be exceptions (NB auto formatter dislikes breaking up a long diamond operator, and it has some weird rules around multi-param annotations), but in general we should be trying to wrap for readability.
Just a style thing, but would it read more easily if the "exit case" were more explicit? I.e.  if (updatedInstance != null) { return updatedInstance; } instanceApi.delete(instance.getId()); InstancePredicates.awaitDeleted(instanceApi).apply(instance); ...
IDE says to use Collections.singletonList
A tiny optimisation would be: Integer n = null; if (newOccurrenceCountOverThreshold != null) { int thresholdAdjustment = ... }
why do we need to check this? I believe we can directly remove
Any reason that we call the get method multiple times? zoneGroupIdNameMap.get(zoneID) is called four times (one time should be enough) groupIdNames.get(groupID) is called twice (onen time should be enough) So, instead of call get and if it is non null call it again, it would be better to store the result to a local variable and reuse it.
nit: I would probably have next() call a method to find next so n and next are clearly separated. ProjectState n = next; if (n == null) { throw new NoSuchElementException(); } next = findNext(); return n;
relevant non-logging code change here ^^^
Perhaps word as "Deleting submitted but incomplete task (without automatically cancelling it first): "+removed?
non owning side
The second parameter should be "addResourceSelfServiceGroup".
The second parameter should be "removeResourceSelfServiceUser".
The second parameter should be "removeResourceSelfServiceGroup".
Minor improvement: BindingMap is a map so it's bigger than the one slot binding. This is slightly better when not returning the score:  public Binding apply(TextHit hit) { if (score == null) return BindingFactory.binding(binding, match, hit.getNode()) ; BindingMap bmap = BindingFactory.create(binding); bmap.add(match, hit.getNode()); bmap.add(score, NodeFactoryExtra.floatToNode(hit.getScore())); return bmap ; }
While it's private, this should probably still return an Optional.
I think this should be a while loop. So that we exhaust those bits if client does not accept, before returning to next label bitset.
PercentType is a DecimalType and for DecimalType calling toString() is the right thing.
NullTimeEvent should not need any properties...
we need the modulo here, right?
agreed that this block should be removed
Unused variable
Now I have looked further down, this looks the same as my way above, but all on the one line to avoid having to specify the types.
Why are you using supplyAsync here? createFromInitializingJob should be non-blocking.
factor out into createInitializingJobDetails
Sim mod could not be installed (otherwise, it sounds like "it wasn't but now it is")
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Don't we have to say that this is uniqueId JDBC?
There must be a more succinct way of doing this using streams.
Since this block is repeated in above, shall we move it to a separate private method?
Maybe remove the package name as it is already in the import statements.
shouldn't this return at least the group ?
I don't think you can guarantee the order of the findAll results, maybe add a sort by columnLong?
also assert that returnedInstance.getScoreWrapper().getScore() is not null.
What about creating own separate methods in client for starting solver and terminating it? It would be more intuitive and user friendly from my point of view. Also it would show what parameters are mandatory for each action.
You should access the attribute directly
create a member for ClusterServiceModel
Since the VM subtab always uses this query, I would encapsulate it inside VmAffinityGroupListModel and make its constructor no-arg.
i++ is generally the convention unless you explicitly need to preincrement.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
Shouldn't this be summing the quals, not the bases ?
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
could make use of java8's stream.map.collect thing
I wonder if we should change this command to receive the device id to unplug - so from the ui the user will pick the device to remove in the vm-devices subtab and UpdateVm will look for the actual device to remove. Because then we could simply lock the device to prevent multiple simultaneous unplug operations with the same device
Why is a Double treated at a uint64_t? Shouldn't this be treated as a float instead?
combine maybe and re-throw?
probably not a bad idea to log an error here too
Don't use final here.
Won't this cause a trailing comma on each line? To avoid that we could save all metrics in writeQueryResult and do the actual write in postCollect
could you remove the tab and use spaces for indents?
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
nit: remove this extra line
Should this method be private?
Probably need a better message here :)
:o
GSON initializes classes with reflection and not the constructor. The default definition should be set at the field declaration.
final
this for is exactly the same in all the array tests, let's move it to a private method
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
format this as:  a -> a .globalGrouping() ...
this is identity projection, can you use something more complicated like a +1?
ditto :)
Again, constants would be nice for readability.
There should be a curly brace pair here for the if too. Otherwise, it will always return 0.
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
same here as well - on failure to stop vdo service, activate and move host to original status
those 2 lines can be united
Minor - can use getAuditLogTypeValue() here.
I don't think this is the right test... you should do something like if (superclass instanceof ParameterizedType)
I am wondering if there is any particular reason to use AtomicReference, the code block seems to be local to the function, no sharing or race conditions should be observed.
We should probably delete the shaded class that I was using from testing with my monitoring utility and provide a way for users to configure their own class names here.
That snippet is basically the same as the other. Maybe we can move it to a single place?
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Access
buffer size 1, why?
how about:  if (Types.getRawType(type).equals(Optional.class)) { if (response.status() == 204) { return Optional.absent(); } else { return Optional.of(delegate.decode(response, getInnerType(type))); } } else { return delegate.decode(response, type); }
So there are no jackson runtime exceptions thrown here?
remove this... openFileInput(fileName) should be sufficient and using an Application context is often an anti-pattern
Personally I would have preferred FileDialogFactory.create()...
can be delegated as: putBytesProperty(key(key), value)
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
When would this be the case?
from the readability point it's better to divide verification by given/when/then sections.
Can you add the other flag values as well?
If you want, you could use ToStringBuilder to simplify the construction of more complex toString() overrides.
campain in tostring?
Minor thing: "referer != null"
Missing space before {
Run formatter
can this use increment util?
Why delete this line?
could call toInteger() and drop Integer.parseInt
minor: this v == null check is unnecessary.
if 'v' is not a member of enum why return it in upper case?
I think the getProperty has method which accepts the default value as second parameter, wouldn't it be more appropriate to use here?
Do we want to turn this on by default in elide-standalone, or did you mean to wrap this in an if block?
Shouldn't this be automatically scanned and discovered? Do we need to add it here?
Why does this test have two entity dictionaries? Elide is really intended to have a single dictionary.
spacing
printStackTrace directs output to the console and should be replaced with logger debugging
Could you replace these with SalesforceSDKLogger.e(...) calls?
Why is this wrapped to IOException? You can wrap it to another OperationException. @honza-kasik , @rhatlapa WDYT?
The version is available directly on the OnlineCommandContext: ctx.serverVersion
Again, why a batch with a single operation? If you want, you can use the batch to do replaceExisting in a transactional fashion, but you're not doing it right now, so the batch is useless.
please review code formatting
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Minor: IMHO it'll be a little cleaner to add a .map after the window to do the counting and send that value. Or maybe use an aggregator here? As an aside, it's a little confusing that the WindowPane has getKey and getMessage. Maybe we should rename it to something like getWindowKey and getWindowContents (or s/Window/Pane)?
Needs to shut down the scheduler.
for this purpose better use a handler and postDelayed function
Give a name to this thread, so if it hangs or blows up, the stack trace will give us a clue who called it. i.e:  new Thread(r, "Hawkular Java Agent Stop Thread").start();  I also need to think about this some more before merging since we are now making the stop() method asynchronous. We have to check to see what kinds of thread safety/concurrency issues this might cause (especially in cases where the agent is restarted, for example, and the stop is followed quickly with start. We need to make sure nothing in start is initiated before this stop thread is actually kicked off and finishes). In other words, making stop method asynchronous could have some side affects that are "bad" without some synchronization/locking put in place.
minor: no need for final?
What do you think of the following: java int EXPONENT_MASK = 0x7f800000; int EXPONENT_SHIFT = 23; int MANTISSA_MASK = 0x007fffff int MANTISSA_SHIFT = 0; // ... private void setTemperatureMeasurementValue(...) { // ... int exponent = (bits & EXPONENT_MASK) >>> EXPONENT_SHIFT; int mantissa = (bits & MANTISSA_MASK) >>> MANTISSA_SHIFT; // ... }
We prefer to use assertj where possible, can this be changed to assertThat(matrix).containsSequence(expected, withPrecision(0.001f));
return StringUtils.isNotBlank(value) && value.equals("true");
directly return generationOptions.isAutogeneratedScript()
Comparing the effects of destroy. Previously this was invoked: java clearMapStore(); clearLockStore(); clearIndexedData(true); NodeEngine nodeEngine = mapServiceContext.getNodeEngine(); NativeMemoryConfig nativeMemoryConfig = nodeEngine.getConfig().getNativeMemoryConfig(); boolean shouldClear = (nativeMemoryConfig != null && nativeMemoryConfig.getAllocatorType() != POOLED); if (shouldClear) { storage.clear(true); mutationObserver.onClear(); } storage.destroy(true); mutationObserver.onDestroy(true); storage.destroy(false); mutationObserver.onDestroy(false);  Now this is invoked: java clearMapStore(); clearLockStore(); clearIndexedData(true); storage.clear(false); mutationObserver.onClear(); storage.destroy(false); mutationObserver.onDestroy(false);  So I guess that now, instead of conditionally clearing and then destroying twice, we now clear (even if the allocator is not POOLED) and destroy. Is this right?
countVal is not necessary. you can use state.setSumC(State.getSumC() + count) directly.
When will this happen?
I'd inline result variable: DOUBLE.writeDouble(out, strategy == null ? Double.NaN : strategy.calculateEntropy());
Recommend changing this method to use the reference name exclusively. Eg.,  if ( SAMRecord.NO_ALIGNMENT_REFERENCE_NAME.equals(rec.getReferenceName()) ) { return record(null, 0); } else { return record(rec.getReferenceName(), rec.getAlignmentStart()); }
I think this method should either: 1. start with if (rec.getReadUnmappedFlag() || !rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) return false 2. or make it explicit in the javaodoc that it's only legitimate to call this method on a read that is paired with both it and the mate mapped
unnecessary parens here and on lines following suggestion rec.getReferenceName(),
Immutable?
shouldn't be NotFoundInDbException or similar to get 404
Should this method signature take a FileAsset rather than a contentlet or check the baseType to insure it is a FileAsset?
nit: just simplify to throws Exception
@vmaletta I think ep should not be there. Maybe a merge issue, could you please check?
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
Space between if and ( Space between ) and {
Cannot happen. @RequestBody is required by default. Remove check.
Can you make this a public static final constant instead? (And maybe use the same constant in the RequestMapping on line 37 too?)
why not null as value?
I don't see clusterId being used in sync-job. Is this required?
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Could you check for null or empty? Via StringUtils.isBlank
We can just modify the method since it is not public API. This will however require an update of wildfly-legacy, I can help with that once this is merged
this and m_ is redundant
Why this get deleted? Your code depends on this function?
Similar to FeedbackMcqQuestionUiTest.java above, not sure why this method is used here
Same here. Magic -1 :P
ping
not needed
Can you separate out the 4lw call onto it's own line?
typo!
can you create a private method with these common lines to avoid duplication?
Let's change the signature to ImmutableMap as well, please.
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
new ObjectMapper() As above. Inject it please.
"Occurrence data must be provided." ?
notification? i think that makes it more clear what is happening than notice
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
Null comparisons can be replaced by UtilMethods.isSet(object)
overflow = ((xl ^ yl) & (xl ^ zl)) < 0;
Call it 'unused', as this suppresses an annoying static check that runs on Google's Java code.
Is this really faster than retaining the int32*int32 special case? The sheer number of branches alone makes me skeptical.
Why put at i-1? Wouldn't it be more natural to use i?
use arrays.copy? or system.copy?
@inverno We have 2 times "Second argument" :)
check return value
Is it necessary to have an additional loop for spurious wake-ups? Doesn't the outer loop take care of those?
I would call queue.enqueue(that.next()) (which is the same)
Could you check for null or empty? Via StringUtils.isBlank
Maybe refactor to a constant on the class.
mapping.getParent can be extracted as avriable
i would refractor this method to if (!contentLengthManuallySet) { response.setContentLength(calculateContentLnegth(this.body)); } and create a new method with "calculateContentLnegth".
silent errors are evil, even the "its almost impossible" ones ;) just surround the entire methods body with try - catch you have a good catch that handles it in the end
@essobedo this code is NOT thread-safe
no need for empty default, you can use it to throw a viable exception or log a message
Why we want to fall through into the loading dialog in case of error?
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
you control all the source here, I think it's fair to assume non null + you have Preconditions.checkNotNull
Should it be an error to call this method if you can't actually get the result set? Feels like it strongly indicates misuse / coding error.
I presume this means we are out of pages..
I assume these tests will never run on Windows, right?
Use LOG
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
use final
This reference may be null in theory if called outside of UI thread. Display.getDefault()?
Should this be removed or moved to debug level?
Looks like wait forTaskRelease is buggy. it seems to swallow interruptedException and return which means that waitForTaskRelease will return when the thread is interrupted making the caller believe that the task is released whereas it was not. Can you please take care of that issue?
I suggest utilizing <LINK_0> to handle i18n of error message.
Should this be a new Exception class?
Should this be a new Exception class?
Should be final WebTarget resource
The initialization of length needs to be done only once and not all the time getClonedStream() is called. If we would like to handle file length changes it does not work (IIRC) as the file size could change also after the file input stream has been created. So, I think this line could be moved above after file = new File(outputFile); Or is it because you don't want to handle FileNotFoundException twice? But reset the size all the time... Hm WDYT?
file might be a directory - message will then be misleading
Please use "something <operator> null" convention
is this line useless?
These two checks are redundant, only the "poison pill" can be by itself in a chunk, and only it can have a start time of -1 (right?). You can keep only one of them.
why do this at the level of the private method, and not in the public ones that call this?
Maybe more of a dashboard question, but I had thought that we made a distinction between errorClass and exceptionClass in the wording, but that doesn't seem to be the case. I'd be interested to hear the reasoning behind renaming this, as in my mind an Error in Java is not something that is recoverable
Minor: asBoolean() parses strings. You should use booleanValue().
We should keep these and suppress the deprecations, to continue checking that they are working properly.
if we fail here we have a stale VM version in hand. we should roleback
@ivandalbosco Why not ParsingErrorCheck.class.getSimpleName()?
while(!cls.equals(Object.class))
final
Please use joinParameters method.
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
@weijjia I am ok with this, but I think it would still be good to make it a class local constant.
I think try with resources should be used.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Remove debugging output.
same for this handler. depend on tunnel, not on the entitlement
We probably could return a shared instance for this as well?
target might be null.
Here when the valueMappings are not null they can be empty. What exactly we need to check here? If we don't generate mappings. Then @InheritInverseConfuguration will _only_ pick up annotated methods from the same mapper as well.
So we are now failing here for all external groups? What if I want to retrieve the name of an external group by GET /groups/<uuid-of-external-group>/name ? Is this not possible anymore?
We shouldn't have any LDAP-specific code outside of the LdapGroupBackend.
Catch a less broad exception here?
Assertj has a fluent API. You have to do assertThat(events.size()).isEqulTo(1);
Please use AssertJ
Please use AssertJ
No tests to cover this method! :open_mouth:
Don't really need this check which lets you inline the getInterfaces() call into the for
These should refer to constants rather than the string literals.
We can use the getTitleView function here instead.
nit new line
NITPICK: There is a class for this that already exist, can you reuse that.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
why do you do the substring if you are using contains?
Typically we use Map on the left hand side rather than HashMap
any reason we can't use an empty list for the sentinel?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Typically we use Map on the left hand side rather than HashMap
minor, is it method scope for Visible For Testing? If not please change it to private.
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
metricsA and metricsB are initialized but never used. It looks like they can be deleted.
Our convention is to include curly braces around if clauses
minX
use { } around if body
Who is responsible for closing the streams? In the normal case, and when there are exceptions?
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
Logging statements can happen outside of the lock.
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
typo in DATAPAAKCAGE
Please reword this message and fix the formatting. I suggest;  java logger.log(Level.FINER, "Working directory created successfully: " + isCreated);  That said, we don't seem to be doing anything if it was not successfully created. Should we be? If not, then why bother logging the message?
You should re-raise an exception here or let the one above be raised. Applications are getting the wrong result in case of an error, 0. And it's certainly expected that wmic ... works 100% of the time.
Code should not contain System.out.println(). Please remove all occurrences, or replace with appropriate logging.
style: catch on the same line as the closing }
Yikes. I didn't see this before. Is it in master?! We shouldn't unwrap ExecutionException like this. It makes it look like the exception happened in this thread, rather than in the other thread. For example, if the other thread was interrupted then ExecutionException.getCause() will return an InterruptedException. Rethrowing the cause make it look like _this_ thread is being interrupted (and looks like the interrupt is being handled incorrectly, because it is just caught and wrapped without marking this thread as Thread.interrupt().
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Again, we shouldn't do this.
you should probably check Item.Configure here
Won't this cause a trailing comma on each line? To avoid that we could save all metrics in writeQueryResult and do the actual write in postCollect
Better style to revert and remove the static import.
Can we move that check up to the start of executeInternal() ? E.g. we can obtain the configuration there and add it as an argument to this method. Its much clearer to skip execution early if needed.
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
There is no need to do check for null, right? I mean you could just write something like return "SslSession(alpn=" + alpn +...
Does it really need to be 'public static'? Is this method used from somewhere outside?
please don't forget to close the stream for new FileReader(filePath)
We could inline encoding.
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
To be verified that it was NOT covered before. Otherwise it's a regression.
What's the point of the 6 trailing zeros ?
Check args?
final?
Make xInitial several standard deviations away from the mean because a slice sampler should be robust against bad initial guesses. To be honest I can't think of any coding error that would fail in this way without failing in general, but it just seems right to stack the test against the code.
Preconditions.checkNotNull(is, "Input stream required to create temp file for %s*%s", prefix, suffix);
Re-use temp file
delete on exit?
should check results here, not just size
Why not just 'out.labels = labelsFor(cd);'? In Eclipse this gives a warning about dead code.
Maybe wrap in an immutable map.
Could this be merged with what we have from line 85?
It seems a little strange to pass the LOGGER. Is there any reason the listener shouldn't have it's own LOGGER constant?
should the message include "command _with options_:" + this.options ?
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
nit: can we consolidate producerFencedOnCommitTxn to the more-general commitTransactionException? I.e. if you want to fence on commit, you just register the commitTransactionException as a ProducerFencedException
Can this be private, or is there another use case for default attribute outside the builder's call?
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
again about redundant things - else block here and above is not needed,
Should not log under warn after testing for isInfoEnabled (or isDebugEnabled). Always log at the same level as if test. simply replace both with a single if (logger.isWarnEnabled() { logger.warn(...., ex); } (See JMS AMLC)
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
Should we do this action in a separate transaction? I'm thinking about listener rollbacking the action to avoid creation of record in system.
Shouldn't this be:  } else if (options.containsKey(CoreEventConstants.PARENT_PATH) && options.containsKey(CoreEventConstants.DESTINATION_NAME)) { docModel.setPathInfo((String) options.get(CoreEventConstants.PARENT_PATH), (String) options.get(CoreEventConstants.DESTINATION_NAME));  ?
So now, with #615, if the prepare phase is failing, the node won't be restarted because the Nomad transaction is not applied. So status quo ;-)
So now, with #615, if the prepare phase is failing, the node won't be restarted because the Nomad transaction is not applied. So status quo ;-)
do not forge to test the isActivated() flag: it is as important than testing the node count... withTopologyService(1, XX topologyService -> assertFalse(topologyService.isActivated()));
This is bytecode equivalent to using the for-each syntax on an array.
if this is still required despite the waitForVariableValueEquals function below, maybe the timeout for it is too short.
final
Remove this check after merging #139 to develop and synchronizing this PR with develop.
Now that we are adding offset and limit directly, I feel like this functionality (appending the offset & limit string) should move to the SQLQueryConstructor
The result of this call is unused. I don't think it should be here.
The above code is only used when the Realm is defined at the Context level. That isn't what is required here. The role mappings need to be checked for the current Context irrespective of where the Realm is defined. Something like: Context context = (Context) wrapper.getParent(); A similar change would also need to be made to UserDatabaseRealm and potentially other sub-classes. Consider moving this to Wrapper.findSecurityReference. i.e. Look up Wrapper references first and if none found try the Context.
not a show stopper but I think setting the property on the role only is better in 1. gives that admin the ability to configure a role (Action group is not a building block the admin can interact with) 2. easier impl - no need to consider what the underlying roles are about naming - you suggest allowView... something. Everything is better that inheritance
check the message code
try-with-resources for FileReader
remove line
Perhaps use the Map<String, List<WriteRequest>> batchInsert(final Map<String, List<WriteRequest>> requestItems) method to reduce duplication
java buf.get(bytes, i, bytes.length)
If I'm not mistaken, this will produce the same hashcode for two arrays, that contain the same char[] but in different order. Why not use Arrays.deepHashcode?
Consider using the same code as com.facebook.presto.spi.block.MapBlockBuilder#computePosition
I understand that this is quick and simple fix, but as experience shows we can't rely on the system clock: no guarantee that CPU will get access to the target process exactly after this timeout. In the end we are going to have sporadic test failures. The best way to sleep with short period and check the state of the component we would like to assert afterward. If you have some argument to proceed with this simple sleep, let me know here. Thanks
does description need to be part of equals?
why is this public now?
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
oh yea. A spy :)
Too many unnecessary blank spaces in this class. Please refactor.
I still don't understand why the key cannot be the session id
Creating a new empty Set and adding the correct media ids feels more natural to me than removing stuff from a copied array :). It's not a big deal we can keep this implementation.
This if statement is not necessary as the while loop below would handle the negative case.
We need to check if it actually has bootstrapProperties, otherwise this would cause Array index out of range
Rename to getSortedPermittedLabels()
Can we move the path to ApplicationUtils class?
Seems applied to both RUNNING and SUSPENDED?
If previousFormatParameters is empty you will enter this if while it used to not be the case before.
Nit: Maybe a try/catch around this so that an exception can't stick isPerformingEditLinesAction_ in the wrong state?
why public when all the other are protected.
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
Should this be an UnsupportedOperationException?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I think you could remove unnecessary brackets around path
Can change this to HashSet as TreeSet will not buy us anything additional?
Does this still apply for the non-YV media sets? e.g. those that aren't iptv-all?
Let's not modify HadoopUtils. Instead, if hadoopConfDir is not null, set ConfigConstants.PATH_HADOOP_CONFIG in the Configuration instance.
Why use the JDBCDriver.class.getName() in one place and a string constant in these two places. Stick to one way. I prefer the class.getName() myself.
shouldn't this be throwing the exception ?
AFAIK all jdbc objects can by handled with a try-with-resource
shall we have try-with-resource?
throw that please
Why do you have to check for null here?
this is effectively a noop
When there is no valid CFs to be repaired, a skip event with 100/100 progress is fired, and then another success event with progressCounter/totalProgress is fired in success().. Should we use progressCounter/totalProgress for skip progress event?
How about in-lining o1 and o2 since they are not reused?
Is this first else-if dead code? It seems to have the same condition as the initial if() statement.
We still need to fix the coercion.
Using something like this might simplify this code a bit UriComponentsBuilder.fromUriString(request.getRequestURI()).build().getQueryParams();
@Nullable
This branch can be simplified: java final String[] split = ListSplitter.split("\"", true, removeBrackets(value)); for (String val : split) { result.add(val.trim()); }  or shortened java Arrays.stream(ListSplitter.split("\"", true, removeBrackets(value))) .forEach(enumItem -> result.add(enumItem.trim()));
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
@danielezonca I think <Z extends ScesimDataWithIndex<T>>
ArrayList should be constructed with fixed capacity.
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
Since the default is false, this will basically no-op in the majority of cases. What we should do is, instead, set the locked flag to true during refresh (which also covers manifest import), as that's where non-custom pools are coming in anyway.
put these 2 in a finally block. don't know whether acquire can throw an exception like a runtime exception. similarly in other tests as well
Could you please log the transaction ID here, instead of the entire transaction?
It's ok, but there is an extra set of parentheses here. I think we can delete those that are around the very last inner condition; the ones that start right before the second occurrence of accountState.equals(...).
I would add "because" between "run" and "transaction" -> could not run because transaction is null
should the message include "command _with options_:" + this.options ?
optimize
You probably wanted to put result = this.translatorForeign;?
Did you mean to make it a constant?
IMO if we know executeTask() doesn't trigger maxIdle expiration, we should assert that
Debugging artifact?
needs a space b/w if and (. also with braces needs newlines
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
i++ is generally the convention unless you explicitly need to preincrement.
Same here with not needing the local variable.
Same thing here with the inputStream, probably want to when() the actual object instead of any(InputStream.class)
Do you want to make this when(urlService.inputStreamToByteArray(inputStream)).thenReturn(null); since you on the line above you made that method return inputStream?
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
Missing ! operator?
Why not if (matrixParams.containsKey(param) { ... } ?
Consider to do this only once in the onInit(). Even if it is void method call, it is still a CPU tick on every single incoming message.
Using something like this might simplify this code a bit UriComponentsBuilder.fromUriString(request.getRequestURI()).build().getQueryParams();
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
There's way too much try/catch in here. Check out try-with-resources (Java 1.7+) or Google Guava's [Closer](<LINK_0> A cleaner approach is having a try/catch with an inner try/finally (closing the resources) block. The try/catch could then wrap any checked exception within a RedisException.
nit, java should be able to use (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex)
forgive my ignorance, but how does this solve the issue? Isn't there still the org.hibernate.Query vs org.hibernate.query.Query issue in the source code?
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
don catch exception, better fail than return ""
now we are changing the defintion of numberOfFilesProcessed..earlier it was only data files now it will also have empty files
Nitpick: might be better to use constants for these.
Please define new config keys in the Constants class.
Should the string be "Password" with capital letter "P" ?
This seems unnecessary. What advantage is there here versus before ? Both guarantee the order is respected.
Isn't this doing the exact same thing as before ? When viewer.refresh() runs, connection.getImages(true) has completed. I would avoid touching this if there's no benefit.
I would remove this and keep the flow as it was before.
pesky booleans
this should be a plain-jane for-each loop:  for (Map.Entry<KV<String, String>, KV<Double, Integer>> entry : accumulator.entrySet()) { context.output(KV.of(entry.getKey(), entry.getValue())); }  Also, might want to consider extracting it out as a more general pattern since it doesn't really have anything to do with Strings:  static <K, V> void output(DoFn<?, KV<K, V>>.Context context, Map<? extends K, ? extends V> map) { for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) { context.output(KV.<K, V>of(entry.getKey(), entry.getValue())); } }
Should we return emptyMap if we are SUSPENDED as well?
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
Do we know this is a refresh and not something entirely different. or opposed to the IOException, which we really don't know much about either
Hm, this worries me a bit, do we not have a positive verification for resources that are in a bad state (IE: Resource.RESOURCE_STATUS_CORRUPTED or similar)? I don't think of the 'recovery' process as being 'safe' for resources that are in an acceptable state, so I'm wary of the ambiguity between uninitialized and 'broken'
Yes that's right, but code-wise if the current restore consumer only contains partitions of standby tasks then the updatedAssignment.removeAll(closedTaskChangelogs); below would be a no-op since the updatedAssignment would not contain any of the closedTaskChangelogs (well, unless we assign the active and the standby of the same task to the same thread, which is even worse).
Fair enough. I don't think it was meant as a cost saving thing, just to make it easier to understand when something did or did not have caught-up clients. If you find this logic easier to follow, go for it
Fine with me (although it does slightly detract from the opt-out possibility). WDYT about adding a retry backoff though? I'm a bit concerned we might just end up stuck in a loop of useless rebalancing, and waiting the full probing.rebalance.interval doesn't feel right either
I think Local.ROOT is probably a better choice.
In my opinion, we do not need this log. WDYT?
Hash operations now support compression. The values in the cursor returned for hscan, sscan, and zscan all need to support this now.
please use only existing constants. LATENCY_SEC is what you are looking for :)
lets move -- to a constant so we can change it easier if needed
insert newline before each .set.. and .build
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
Shouldn't we use empty list here ?
since we construct a default conf already, better to use it rather than call defaultValues.  internalConf = ClientInternalConf.fromConfig(conf)
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
This can be static.
Avoiding Empty catch. For example, you could use log
You don't want to use an exception that extends MyNakadiRuntimeException1?
Now that this is not a part of the original method anymore, it makes even more sense to not unwrap the original exception in order to not lose the whole trace leading not only to the executor thread but also to this finishAllThreads method. I think my original attempt to make the stack trace shorter has the potential of reducing clarity rather than improving it (in other words, I did a stupid thing originally).
Weird, but makes sense I think?
Same as above, try to simplify this by adding meaningful local variables.
We should go with a single histogram tracking tag count, since every ReportPointHandlerImpl can handle only one atom type anyway. Having separate histograms for points and histograms is not useful - we would have impossible combinations like ~proxy.histograms.2878.pointTagCount.p99, or ~proxy.points.2878.histogramTagCount.p99, which would always be 0s and waste pps.
Avoid calling getOverload twice.
You should determine if you need a regression model in the scheduler
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
Currently init/deinit will be treated the same here. This should really only wait for initialization. If we are deinitializing, this should fail quickly.
What if there was a previous symbols list that was empty?
we should probably add a maybeEscalateHeadsUp() here if we are on the keyguard and remove the one in screenOff, this will be safer and ensures that we never have a heads up on the keyguard.
this.fileStates.remove(absolutePath); is correct.
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other methods located elsewhere, because it makes the intention of the test unclear.
The debug message for the replacement is useful too. See AbstractMappingMessageRouter
Can we name this something other than it? Even i would be better to me than it.
This would be better as a logger.warn, since logger.error is reserved for messages that affect system stability.
to make the whole backend/frontend interaction clearer, we should move all the read/write to conf and udfcontext into setInput() Those three lines can go to setInput() as they are not costly and don't need to be cached. That will remove the interaction between setInput and initSchema. initSchema is only called in setInput anyway.
Make non-null.
I think we could only just set the StrictMode in Application.
Are we keeping this public method for a reason? Isnt this a remote param now or are we keeping both?
DatabaseHelper.init(this);
@hibooboo2 Did you hit this code and verify that it outputs what you expect? I don't think it is going to. I think the string needs to be a formatted string with {} where you want to do variable replacement.
Tests should never suppress exception but rather propagate them or use an ExpectedException rule.
Should this be handled as a SearchHandler? That way the generated API docs include this automatically
Not sure what Select2Common -> SuggestConstants has to do with the rest of the changes.
Simpler if you use an iterator?
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
nice! Thank you.
Let's set this to true in fixtures.xml so we make sure we properly load a non-default value?
the backup flag of the result will be false for 72e3a666-89e1-4005-a7ca-f7548004a9ab
Note that using builder.setNegativeButton(R.string.cancel, null); here will accomplish the same thing.
Seems to work, but probably shouldn't have this on the UI thread, especially, once we get to delete images as well.
I know I started using just title, but looking at some Google apps, like the Play store app, I think it's better to just use message. so, I recommend to change HistoryActivity instead to be consistent with this.
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
should break request.toBuilder().header(HttpHeaders.AUTHORIZATION, authHeader).build(); into it's own method as you call it twice and the long chain is a little hard to read
Make this part of the centralized CorrelationIdProviderService or create an in between CorrelationIdResponseUrlProviderService to have the functionality of storing the responseUrl with the correlationId in one place. All other endpoint should make use of this centralized CorrelationIdProviderService/CorrelationIdResponseUrlProviderService
rename to callgraph...
externalize
You need to use the following pattern when using reentrant lock. Otherwise it could happen that the lock won't be unlocked if an exception happens in between lock and unlock. lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() }
Hm, we could use == as well for comparison, as we don't have custom equals() implementation for model classes. (IIRC, most of GWTP infra code working with models just compares references.) Current code change is OK too.
ActionConfirmationText/ActionConfirmationMessage
I'd prefer overriding of setEntity() method to listening for events in this case.
The default should be updated to return 8 parameters to the test
Item dropped should be a hopper
Do these strings all need to include the escaped newline? Everything seemed to work ok for me if I replaced all occurrences of \\n with a simple \n? On a related note, would that change make the matrixAsString.replaceAll("\\\\n", "\n") lines removable too?
<field name>_COLUMN
I'm not 100% sure but I think this should be the other way around. feeds.size() seems to be the expected value. This problem is also present in other tests. Before, a failing test just showed something about a failed assertion. Now it shows actual value and expected value, so it is misleading if they are exchanged.
You can use Collections.emptyList here
Please only log at debug or trace
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Is it possible context.getAuthenticationInfo() is null or context.getAuthenticationInfo().getUser() is null
Just stuff all this logic in "getAllowedCategories" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getAllowedCategories(marketingInsightPool, marketingSeenCategories),random);
maybe just replace all these error codes by default block since we are doing nothing for any other error code
try prefix is used to distinguish this method from public toMessageClass(). I find it better than innerToMessageClass() or something. I use try prefix for such methods as Bob Martin does in his great book, Clean Code.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
that class would be better with a builder, though I wouldn't ask changing it now
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
- store
Why create a separate Kryo instance for every partition?
Same issue here. We should keep this as static if at all possible
Second parameter of Status is the pluginId. Why to pass path here?
Second parameter of Status is the pluginId. Why to pass path here?
Second parameter of Status is the pluginId. Why to pass path here?
yuk! a System.out! Either remove or use a slf4j logger here
Does it have any memory requirements?
Probably a dumb question, but why can't this be written as a visitWindowSpecification method, which would remove the need to pass parameters into joinExpressions?
let's change the order in the ctor - its clearer when the source is before the dest :)
I don't like the following constructor, during creation of class we are trying to perform a queries to DB, if for some reason they will failed , the exception will be something like that java.lang.ReflectionException or InvocationException, which will not provide us with any clue for reason of failure.
This is completely unreadable. It should be something like: if (supportsDeferredPrallocation()) { }
BoostSourceEffect has to be removed.
You must check choice.getColor() to null values, it's will get it on player connection problem. See #4263
Must be AIDontUseIt (otherwise AI will discards all own hand for lands).
why do you need to clear sortedSessionSet and add chsenSessions again ?
I know that you're just using this header to test the get() method, but I find it a bit confusing to have an Authorization header in an object that represents the _response_'s header. Would you mind changing it to something else? Either a generic name e.g. "Some-Header" or a header that can actually be found in our responses e.g. "Stripe-Version".
why is it adding null?
Could you prepare a test case that covers this? The thenComparing method doesn't modify the state of comparator but returns a new one instead making this line a dead code
remove newline at the end of methods
Why do you have to include this test data for reason concept? Is it required for this test?
May we detail the logger message a lit like > error in registering flow trigger <PojrectName_FlowName> in Quartz,
same as above, put the check in a util method
Why to you need to print out flow.toString()? Would flow.getId() be better?
what about : this.myField ? This isField method should probably return the referenced symbol.
remove final modifier.
What about expressions like this.field = null ?
Why not update it in setZoomRatioInternal()? Is it because of float rounding error?
I think you might want "icsCode >= 1". ICS means "Inherited Certification Status" (i think?) and it is not a boolean but a count of the number of times something has been inherited... so it can be larger than 1.
might consider using a Joiner here:  c.output(Joiner.on('\t').join(call1, call2, sumOfRatios / numberOfRatios, sumOfRatios, numberOfRatios));
these 3 lines are common in closeXXX() and can be moved to close()
remove extra space around parenthesis for consistent styling
can we avoid writing headerOutLong file in cases where its not needed? may be, we can write headerOutLong on demand at the point when fileSizeLimit is crossed (and stop writing headerOut afterwards)? in most use cases, headerOutLong would not need to be written at all.
This code should use instead entrySet
Rename method to match config: setOverwriteGenerationMismatchIgnored()
Should be a SamzaException with a message, not NPE.
please dont remove explicit initialization
I would rather throw the IOException forward so that it can be dealt with properly at a later stage. Here you will end up with an empty list which is not showing clearly if it comes from an empty file.
Wouldn't the contains method be more reliable here, in case some spacing was different at the beginning or end of the line?
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
:ant: Deserves a functional test.
not sure if we are gaining anything by using generics in this case?
In general, we should probably be moving away from client-side validation where possible.
should be int y
Remove the redundant null checks.
Replaceable with Iterators.transform()
Can we use getPredicate here?
This Iterable chain of nested classes is very noisy. Maybe create a simple List of bitmaps, fill it in a for loop with i between startIndex and endIndex, then return bitmapFactory.union(bitmaps)?
Is numDuplicated missing here?
Why would be just cache store initialization failure, the backup could fail as well, isn't it. Shouldn't this be unable to initialize cache manager.
Could you please use TextUtils#isBlank here instead of "".equals(s)?
Can this be private, or is there another use case for default attribute outside the builder's call?
Why is there no default? I'd expect it to be the other way around, assume the normalized keys and expect the occasional override
scheduleTimes --> scheduleTime
Can you replace IDs with names in this log message?
Small thing - I think it's better to do: List<String> result = new ArrayList<String>(allLocales); because with original code: List<String> result = allLocales; any modification of "result" will also modify "allLocales" input parameter. In other words, are we OK with modifying method input parameters? (I'd rather avoid this.)
Immutable?
I would substitute:  if (lx == x) sb.append(lx); else sb.append(x);  with:  sb.append(lx == x ? lx : x);  or add the missing {}.
andCardinality(Container) should be called here instead of and(Container).getCardinality()
the if and else clauses here will both result in the same behavior below
check is unnecessary
check unnecessary
check unnecessary
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
Is there any reason that this is read from a config file instead of system properties? Unlike most other things that are populated directly using system environments, this seems to be populated from a json file. Is there any reason to break consistency here? While I don't mind reading from a config file, I think we should probably consider "one file to rule them all" sort of a thing, or drop this file (for the current release) /cc @zabil @arvindsv
verify that that user.dir system property is used
Why change the name the property? Accident due to mass refactor/rename with IDE?
This is what is causing the ConnectionPoolImplJUnitTest failure. That test creates two servers and a pool in the same JVM, so both servers have the same membership ID. If you delete that test and replace it with a distributedTest that creates the servers in different JVMs it ought to pass.
Don't need last else
Is it possible that this method is called from different threads, e.g. when synchronization is requested synchronously after the job has just been scheduled? If so, should check the result of calling add() and abort the synchronization if one is already in progress?
I don't think synchronization should throw an exception if the problem could be handled by adding an error marker. There might be some conditions where we really can't continue (like we can't even import the root project), but in most cases the error is not really in the synchronization process itself, but in the users's build.
won't exit the loop. You need to return here
Extract notification to own method notify...
Extract notification to own method notify...
no need for an ArrayList
use ConcurrentUtils.withLock()
should not lock everybody just because one thread is doing test connectivity
use ConcurrentUtils.withLock()
There must be a more succinct way of doing this using streams.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Why do we need those lines? Unit tests are still green if I remove them.
You can use a foreach loop of the form for(BibEntry entry : entries).
Can we please make this less than 80 characters wide?
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; }
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
maybe would be better to write java return oauth2Token(request.attributes()) .map(oauth2Token -> bearer(request, oauth2Token)) .defaultIfEmpty(request) .flatMap(next::exchange);  This should create less Publishers/functions and it does not duplicate next::exchange
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
what is being tested here? how is it being verified that the second thread actually blocks?
I think the generic SWT.ERROR_NO_HANDLES is more appropriate. Or simply return zero here and let the data query fail with E_FAIL. Since the error is abnormal, converting it to Java exception isn't useful.
I wonder if we should have a static method somewhere getAbsoluteUrl(String) and call that instead, making the code ever so slightly higher level. Config.APP_URL + is a lower level operation and I don't like that it is being repeated in many places.
It might be an idea to move the string generation into its own method. So at least we can test the generated string and guarantee it will always stay consistent.
Sorry, I was thinking of this:  java private void handleBadgeResetPN(Bundle data) { if (data == null || !data.containsKey(PUSH_ARG_NOTE_ID)) { // ignore the reset-badge PN if it's a global one return; } removeNotificationWithNoteIdFromSystemBar(this, data); //now that we cleared the specific notif, we can check and make any visual updates if (sActiveNotificationsMap.size() > 0) { rebuildAndUpdateNotificationsOnSystemBar(data); } EventBus.getDefault().post(new NotificationEvents.NotificationsChanged()); }
I'd suggest parsing the week from "MMM" to "MMMM" even in this case. TalkBack is smart in English and it reads automatically the full month name, however it works only with some languages (doesn't work with Czech).
Do we need to check Null of the input parameters?
Put a Sage.rez() around "Forced"
nit: you may also want to check !forceCloseInit.get()
Is this working? With voidPromise? @merlimat @ivankelly I think not using voidPromise we are going to add an allocation on the hot path
Unsynchronized access to channel.
Might be better to throw the Exception instead of swallowing it. I'd write something like: java public static String getFileExtension(File file) throws Exception { return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); }  This new method might deserve also some unit test in FsCrawlerUtilTest.
extension can't be empty or /
You could remove the braces around the first check.
Same as above, using GeoWebCacheExtensions.getProperty would allow more options to set a property.
You're still taking the performance hit here, as you're walking the iterator and storing the sourceId in a variable _only_ to be used in the debug. Instead... java if (LOGGER.isDebugEnabled()) { LOGGER.debug( "subscription is a site-based subscription starting with site id {}", sourceIds.iterator().next()); }
Should we use something like EXTENSION or EXT instead of SER?
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
just two ideas * could be pending null or it could not be? * I would, personally and if I don't miss some detail, consider more readable the lamda style like pending.removeIf(record -> record.forget())
I still don't understand why the key cannot be the session id
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
This does not make sense to me. First of all, could we fix this to not send out user metadata ever? Secondly, let us send out the boolean for whether the blob that is put was encrypted or not.
This font resource leaks. It should be disposed when the dialog is disposed. You could add a dispose listener on the text.
With this change Weld will only suggest a bean matched by type only if the injection point requires specific Qualifier and a bean exists with the same type and no qualifiers. If you change the getBeans() call and add AnyLiteral then Weld will also suggest other combinations such as injection point with no qualifiers plus a bean with a qualifier.
I wouldn't detect processSynthethicBeanObserved at all (we don't detect ProcessSyntheticAnnotatedType neither). Instead, just check the extension param: if (extension != null) {
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
Can we avoid this switch/case block?
Unsigned types are not used in the current implementation. So, you can omit them.
This list needs to include soul lantern.
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
I think we should use leftOperandList.containsOnlyConstantAndParamNodes() here just to be consistent with the right.
I think in this case we want to revoke (not lose) the partitions no longer in subscription?
Suggest adding "break handlePayload" here too
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
See above about title, file_name, and content being required parameters.
Yes, this would be a good idea.
The first argument can be random.
I have question about this config. Will this determine the serverfactory for ambry-frontend and ambry-server?
All these numbers should probably be defined in static final variables up near the top
protect against config value of 0 and specifiy "...journal", 1, 5000)?
For null values, we just do not supply those properties in the autoGenerationOption
When will these last two lines ever get executed?
How sure are you that these values were not already false, even before the rest call?
Also include the values here?
why not use the field directly ?
I suggest including the uri in the exception message
Nitpick: We can do the if else together here :)
Should there be a return here after the error toast is shown?
If the event is not isError() and also event.type == EMAIL and event.isAvailable, then we enter [this case here](<LINK_0> , so we should insert these same 2 lines there as well.  // hide the keyboard to ensure the link to login using the site address is visible ActivityUtils.hideKeyboardForced(mEmailInput);  Also, what do you think about replacing [this line here ](<LINK_1> EditTextUtils.hideSoftInput(mEmailInput.getEditText()); (marked deprecated) with ActivityUtils.hideKeyboardForced(mEmailInput); to keep it consistent?
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
won't it better to have it as args... ? SSOQueryServiceUtils.getFromSsoQueryService("command=sso-token-validate", String.format("sso_token=%s", sessionId); or even as: SSOQueryServiceUtils.getFromSsoQueryService(req, "command=sso-token-validate&sso_token=%s", sessionId);
Lacks permission check. While #doQuietDown does, this logs messages before permission is checked.
I noticed in some other command line classes, the total run times are recorded. Is it worth doing it here?
Looks like epoch and reset logic should be pushed to pool as generic solution. Isn't it ?
why this file relevant for this specific pull request?
Arguments should be switched.
What does rcvMsg stand for?
format as final String[] array. Rename to errorMessage if possible
Do we need two debug logs here?
Add the command that is being executed to the log
Could be just resourceNode.getContent() instanceof IRootResource. This expression can only be true, if resource.getContent() != null.
If we expect an exception here (i.e. i see it's meant to be ignored) should the test fail() if the request succeeds?
iiuc, this will write to the log every 5 sec, which might flood it, i think its better to have this as debug/trace
this will be written every 5 sec (by default) i think its better in debug
suggestion final Deque<Integer> ccStack = new ArrayDeque<>(numVertex);
I guess it wouldn't hurt to explain what the exception means (our position is too old and has been deleted or compacted by the broker) and what we hope to accomplish by marking the task as corrupted (to re-bootstrap the stores from the changelog and return to normal processing).
nit: seems we could module this if check with L120
Actually, would you please have this still error? It likely represents a programmer error if the application is handing a null Collection to this method. I'd instead suggest something like: suggestion Assert.notNull(userAuthorities, "userAuthorities cannot be null");
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
I think UnsupportedOperationException would be more appropriate.
this code cam be shared across process/subprocess property writers, isn't it? In some helper method or abstraction works for me...
do we want to assertFieldCountEquals here?
This test makes me a little weary since it could pass even if clear didn't work but the write to file/load from disk part wasn't working.
It seems like we shouldn't need to override this, since it should work the same for all columns.
Instead of adding inline styles like this could you pass in a class name that we apply to the element instead? This makes maintenance a lot easier as well as making branding applying different styles.
It would be great if we could have unit tests for all these new methods inside say PhoenixTTLRegionObserverTest.java
suggestion assertThat(filter.beforeRequestMessage).contains("/hotel");  This is analogous to the aforementioned .startsWith() change. Please apply to all affected methods.
Just for the beauty of the source code, I would have prefer request and response instead of arg0 and arg1...
response can never be null, can it? The call to searchGenotypePhenotype should either throw GAException or return a valid SearchGenotypePhenotypeResponse.
We should implement filterOnlyAllowedAttributes() method to perform authorization check on list of RichUserExtSource as we have for groups and members. It will be part of Bl layers and called from here. Also, I don't know if we have authorization check on ues attributes. I believe, that right now they are accessible only to perun admin, and will need to configure it on each instance on deployment.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
Please add also VOOBSERVER.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
Please write a unit test to test this transformation.
Possible Nit: Early return if Timber offers .isDebug(), you know better than me, don't think it's possible
we just log, update metric and move ahead with next iteration?
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
code style
Let's also do a null check on evidence as well
rename to location
I think this should be Locale.getDefault() instead. My thinking assumes that if a user has no preferred locale, he/she is satisfied with the default, and as such, that should be the one in which the message is sent, not the one in which the sender is currently in.
if one of them is null, the result is true? This means that they overlap?
maybe worth using debugFormat and replace let let debugFormat() decide whether to perform string concatenation
not seeing where busy is set to true?
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
why pass in a SocketChannel when you could pass in whatever .pipeline() returns
Need to create the ExecutorGroup in the same way that you created the idleExecutorGroup, otherwise each new connection will create an executor group
It is a bad practice to print stack trace instead of logging or processing exception
I think we could use a better naming here. It should express that the project hierarchy is (or is not) flattened in the Tasks view. How about TaskViewState.isProjectHierarchyFlattened()?
Given this part hasn't been changed since 2014/5 .... I'd be tempted just to remove the logger line. We don't need it in tests (and if we do have logging / System.out.println I tend to use them in conjunction with <LINK_0> and mute for success.
This code also does not respect devices in single-SIM mode (i.e. phoneCount == 1) where there are both pSIM and eSIM slots, but only one can be active at a time. This case still needs to be accounted for using the old logic.
No need to check this.
is that possible this is null?
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
does it need to consider Windows?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
I believe this should appear below the isAdded() check
no need for an ArrayList
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
so do not resolve groups and no recursive as you going to search it anyway.
pls format (>120 chars)
Please rename your variable to tempPassword (we use camel case). Remove parenthesis between the ternary expression.
category
the [ and ] are obsolete as there is only one char between them
This could be entirely done as a stream.
shouldn't need the throws declaration?
must be of type bytes or string
use the same error message as above for consistency: "Field %s must be of type bytes or string. It is currently of type %s"
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
minor: I don't know if it makes the code any better - but did you consider the use of Boolean.parseBoolean()?
Please refer <LINK_0> We want to use Options class.
it also need to be checked that token not expired at the beginning and expired only when expected time passed.
better will be to also check that content size is not 0.
Cosmetic: Could you please, follow the project's coding convention?
it is non-standard. and the dialog should be modal, taking up the ui, so the user can't interact with the button anyway while it is open. so i don't see any value in disabling the button while the dialog is open. we usually only disable buttons during an rpc, where we are waiting for the server to respond and the rest of the ui is still live.
RefNames.REFS_CONFIG
This was renamed in [1]. [1] <LINK_0>
maybe it's better to tag them with the status so that we can break them up that way?
You can remove this call and also remove the public default constructor: it's not used.
explicit type not needed
Can you write this conditional expression in the complete syntax ?
This should be replaced with Preconditions.checkNotNull(context, "servlet context") and nullServletContext() should be removed.
When can this method throw ServerException?
return Collections.emptyList();
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
this.
@cyberone no need for Mockito.times(1)
We should use better variable names (filter, path, entries). It would make the assertions and verifications clearer.
We should use better variable names (path, entries). It would make the assertions and verifications clearer.
extra ;?
Can you check for RecordTooLargeException instead of SamzaException?
we should use CellUtil.createCell rather than making KeyValues directly. (KeyValues are InterfaceAudience.Private, which means that projects outside of HBase shouldn't refer to them.)
What if the string doesn't end with a " or '? You'll strip the last character.
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
ParseUtils.isQuoted would be good for this.
might be more logical to swap the order of the two lines above (install java, download tarball, unpack tarball)
I thought that global install was not recommended, should use normal when possible? Not a NodeJS expert though so might as well be wrong.
It's worth changing the stdout/err redirections to append to the files rather than overwrite them so we can keep the logs from the create-user script.
Needs to be inside try to make sure cleanup happens
Formatter
Can we define credDir as public static final String CRED_DIR so that it can be reused in tearDown and testResolveAlias? Thanks!
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the constant value.... ...though I should probably bring this up on wildfly-dev and not this PR :)
Do we need this stack trace to be printed or should it just fail?
I think the granularity should be 1 seconds instead of 5 seconds here.
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
Translate this RuntimeException message in English please
By catching the exception, we are not failing the test. Tests like this should just propagate all unexpected exceptions.
Just seen this... Would it be more convenient for this method to be named assertPredicate? The current name seems to mean that it will perform arbitrary assertions...
please use "else if" since only one option can be valid at a time. Please also format the code according to the Eclipse coding standards.
stepId is not set while fetching the task details from the db. You might need to check null for taskId
Is this a minimal reproducible example? Frankly speaking, it is really hard to follow the code, and it is sad it is the most trivial example in the PR. I would prefer to have a simple example that makes it clear what the rule produces.
final ?
I think we should use more readable name such as empno and deptno instead of jb and nm.
Why time this... noop?
PARAM_DATA is used to retrieve the data, but PARAM_SELECTORS is used in the error message.
What about caching the list? AFAIK this method will be called multiple times on the same connection.
the name numRetries is a bit confusing; could we rename it to numRemainingRetries?
You can use Wake BlockingEventHandler (I may misspelled the name).
Reminder: we will have to change the code to fix the number of instances per mini-batch later in #824, which is quite simple here.
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the FollowUserTask class
hide the default (centered on-screen) loading indicator since you have your own inline indicator: getCourseDetailTask.setProgressCallback(null)
This should not be a ProgressDialogTask, since this code just drops disc cache, it executes pretty fast and there is no need in displaying progress.
Shouldn't it be true ? (legacy SQL used for old jobs)
I would consider cleaning this up using JSONObject -- since this JSON is currently pretty simple and this is only test code I wouldn't let this stop ship. That said, I'd much prefer to see something like the following  JSONObject json = new JSONObject(); json.putString("id_token", TEST_IDTOKEN); json.putString("access_token", "blah blah"); ... return json.toString();
Isn't this constant and shared across all producers? Then can't it be static?
Can use java 8 paths.
speces before and after "+" :)
rename to automationContext
why are you 'just' getting the host messenger?
This is changing the batch directory name. This shouldn't be changed. Only the filenames need to be changed.
there is a getInt variant
same here, we might want to move some of the common memcached / redis cache code to druid-processing and reuse it.
is it possible to have tests for the encrypt/decrypt methods of this util?
Please use joinParameters method.
We have a removeConfiguration so let's not allow null value here?
Please refer to PR #642 , we need to have the full jobNameAndId in the config job prefix.
what if my value is " " ? should use trim
The type should be included in the context.
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
Use fire(event); for all EventHandler based events
Use " List<String>" instead of ArrayList<String> in declaration.
Immutable?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
Glad to see that with this change, one can now navigate the (java) code and notice the different icons the button can display. Previously, one of the cases was set vie the xml layout file.
getColor is deprecated, bro. <LINK_0>
move else if next to closing brackets.
nit: missing newline
not all listener
I think ServiceDiscoveryManager should be a field of this class.
To make this more bulletproof, can we use the variant of waitFor() that takes no arguments? The Jenkins test harness puts a timeout on each test, so if the code under test has failed, the test would eventually time out. In contrast, this approach has an implicit assumption that the CI system will be running at a particular speed, and I'm not sure that we can rely on the Jenkins project's CI system to have any particular performance guarantees.
[nit] Should we combine the calls to TestUtils.runSwarmClient and TestUtils.waitForNode into a single call to TestUtils.createSwarmClient?
Shouldn't the two lines above resolve to true?
do you really mean "master cluster"
Is this the right thing to do since the flag isn't there anymore? It seems like it should be removed to me, since the behavior without fromPigAvroStorage set was to skip this section, which means that it would likely get picked up by the if (field instanceof List) { .. block below, which does a different transformation.
Same concern as above.
suggestion + "the generics incorrectly, a class cast exception could be raised during processing, but the "
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
Should use AC_DIRECTORY and CAS_DIRECTORY respectively.
I think Local.ROOT is probably a better choice.
let's use LinkedHashMap
why not null as value?
Does not compile, but not really important.
final
this for is exactly the same in all the array tests, let's move it to a private method
Can we short circuit here as well and return false instead of having it go through the path of validating offsets?
use markers like {}
Would it be better to add a separate service method for sending a no-files-processed email, so that you don't need to rely on null values and null-checks to do so?
ID is a unique element in a page and therefore you don't need a chain.
Could you perhaps try to use similar approach to [this](<LINK_0> The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.
Could you perhaps try to use similar approach to [this](<LINK_0> The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.
no need for this change now
please rename variable
rename - a bit more specific :)
use Arrays.fill instead for loops
What about Arrays.equals? Also possibly an intrinsic in JDK9.
For each?
going to assume a potential illegal argument exception here, too, if adSpaceName=""
What is the deal with the type converter?
this cast seems dangerous: why is an optional stored in there?
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
missing space between () and {
@pveentjer One potential reason why we may observe worse latencies is that registration of selection key is blocking operation. Typically, all calls to selector methods are wrapped in a synchronized block. So registration of a new selection key could be treated as a call to blocking queue. E.g. this is what happens in Linux in JDK 11 [1]. Before the change we did concurrent queue + wakeup, now we do blocking queue + wakeup. Most probably we need to have some throttling mechanism, which will prevent a call to the selector if the write operation is already scheduled. E.g. AtomicBoolean. WDYT? [1] <LINK_0>
Use TaskType.STANDBY.
Standby task should never be in RESTORING since we always transit from CREATED -> RUNNING -> RESTORING in one call. Did you observe this was not the case from failed system tests? Even in unclean close case you described I did not see why it could be possible..
Add newline before return.
Add newline before return.
Add newline before return.
right.getHighValue()?
use single quote to make this a Char
Put ITEM in front of OTHER_FUNCTION .
Duplicated _for_ loop could be extract as a private method to factorize the code.
IllegalArgumentException?
Update: This is wrong!  java if (n >= length) { return empty(); }
Creation date and last modified date should not need to be set here since the database sets them. You may need to mark them as insertable = false, updatable = false in the entity.
This debug statement and log should be removed, or hidden behind a public static boolean flag which is set to false by default.
I think I'd prefer that we return a NonDeploymentSubscriptionContext. That could throw exceptions on any attempt to subscribe etc, and would just return false for unsubscribe. I don't like having lots of null checks in the calling code.
Findbugs reports this, as you ignore the result of read(). Please add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).
This can be defined inside the try block.
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
nit: remove trim on both lines above.
just remove the fileSize from here... and that's the only change you will need.
nit: lowecase "a" - applicationProperties
I think it would be nicer if we removed the intermediate OptimizeTableAnalyzedStatement and instead directly build the request classes. WDYT?
IDE hints to replace source.map(x -> entityConverter.convert(x)).filter(x -> x != null) with source.map(entityConverter::convert).filter(Objects::nonNull)
IDE hints to replace source.map(x -> entityConverter.convert(x)).filter(x -> x != null) with source.map(entityConverter::convert).filter(Objects::nonNull)
Can we please mock the Future?
Can we please mock the Future?
assertThat(info.files).hasSize(2);
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
~~If cubeGenerator already contains generatorPipeline and it's no longer used in this class, remove the field completely from world (unless there is some other reason for it to be there)~~ Considering that GeneratorPipeline seems to work mostly as StageRegistry now I would suggest renaming it to GeneratorStageRegistry and keep it in World.
Can this be private, or is there another use case for default attribute outside the builder's call?
Pass null as a listener, it will dismiss the dialog.
Note that using builder.setNegativeButton(R.string.cancel, null); here will accomplish the same thing.
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
The builder is from HDFS. It is NOT a pb. It has pbs in it?
you dont want to use java docs here.
You have channel here as a separate variable, so I don't think we need to use context.
Your find by ID method should be doing the same logic. SERVICE_SHORTNAME is the old way of registering a transformer and SERVICE_ID is the new way. You should be able to remove the find by filter after doing this.
Please remove info that is not in public API.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
When would the offsets be unsorted? Is this more of a precaution or is it common? Is it again the small file optimization?
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
How about instead of adding mutable lists with addLast and then adding to them, we use an ImmutableList.Builder local variable. We start with an empty builder, then, when the line is done (because wrapping is required), we build that list and then add it to the main list -- then we reassign that variable to a new builder. We could then skip the need for a Deque and use List<List<String>> with ImmutableList used for both the main list and the line lists
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
Synchronous command may have a job id as well (see ExecutionMessages.properties) - that's the operation we see under the "tasks" tab, it doesn't necessarily mean that the action has asynchronous operations. I believe the we add a flag on the action result to determine if a command has async operations (I believe we should set it to true if the command has callback or if it has async tasks as being checked today).
no need for the failover treatment, this is done by the infra, just return doAction()
Setting the style isn't needed for this component as this is the default already.
What if the simulation is in the "decision phase" when you build the panel?
What if the simulation is in the "decision phase" when you build the panel?
Given that the Ant task already checks for the existence of installUtility, shoudn't we just combine the logic from lines 97 to 105 like this:  // If we have the kernal JAR and the product jsons exist, then we use the kernel. Otherwise just use installUtility. if (getMapBasedInstallKernelJar() != null && !downloadedJsons.isEmpty()) // do the installation using the kernel else // call installUtility
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Instead of: ArrayList<String> trackedEvents = new ArrayList<String>(); trackedEvents = getTrackedEventsFromFile(harDirPath+listOfHarFiles.get(i)); finalTrackedEvents.addAll(trackedEvents); Can you do something like: finalTrackedEvents.addAll(getTrackedEventsFromFile(harDirPath+listOfHarFiles.get(i)); I don't know if it is good idea to initialize ArrayList inside loop, that is really a placeholder for something that you can pass directly
I have only several problems with this class: 1. We have AbstractSurefireMojo here. 2. We know what provider is being executed. What about to add a boolean to this method isPlatformPrvicer or enum instead of using null-checks in if ( junitJupiterApi != null && junitJupiterEngine == null ). 3. Why we do not align the versions of junit-platform-launcher dependency of our provider in classpath according to user's dependency version as well?
Please use StringUtils.equals
compareTo() and equals() have to be consistent with each other, which it is here. But you can enforce it and simplify by simply doing return compareTo(blobId) == 0; at line 353 and avoiding the code duplication.
Use of this.getClass().getName
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
no need for the additional check if propertyParts.length is ok?
set it to the appOptions by default. If it's still null, set it to a new instance.
Looks like a typo. If XOR is on purpose, it is coupled with the last line checking the asServer flag. That is less readable than straight-forward logic, ATM.
Missing the variables for replacement?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
why not null as value?
If you make the EMPTY_EXPIRES, you could use it here.
Doesn't seem possible, if the topology id matches. OTOH I'd rather retry based on ownership than on topology id...
asyncInvokeNext already checks if the delay stage is completed.
Feels like skipRead should always be true here, but it looks like it's not really used.
You catch only NumberFormatException which could be thrown by Long.valueOf, but timeTZOf-> checkRange could throw IllegalArgumentException that is not handled.
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
Do we need to handle BigDecimal as well?
In several tools, we're using "jopt" for argument parsing. Perhaps you want to introduce it here as well?
@inverno We have 2 times "Second argument" :)
add a System.exit(-1) after the usage output
The UserStorage SPI needs to be backwards compatible. It means that UserStorage providers developed in the previous Keycloak versions must still work with the newest version without any changes needed in their sources. So the BackwardsCompatibilityUserStorage provider should still work without this change needed... The similar will be good for other user storage providers - will be nice if no changes are required in them
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
any reason to not do this in the constructor? Is it null in the normal flow?
Can you make these 5 seconds a constant like the other timeouts?
@excaliburnan I would not go for an ioexception here, maybe IlligalArgumentsException
<LINK_0>
null check?
This cannot be removed. The scheduled task needs to be saved.
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Not mandatory but we could save some duplication by refactoring these tests
can there be a failure here? enclose in a try...finally?
Will this message be propagated to clients? If so, can this be more actionable, and/or informative?
This is no longer needed if MVs dont support indexes.
replace "ROW FORMAT " + s + " " with format(...) ?
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());". Line 91 includes the update of the dc mac pool. So in case of a failure (crashing of the engine for example) after the mac pool update and before moving the macs to the new pool, the dc will be in inconsistent state and needs to be reverted.
I think its better to if (isCopyPerms()) { execInTX -> save quota copy perms } else { save quota } and remove the check for isCopy... in copyQuota method
what if the user sent another enf. type in the params?
The blank lines before and after method bodies are quite strange. We don't have rules about that but it seems inconsistent to me. It could be valuable to have feedback from others.
Avoid logging an error if there's already a throw.
Same as above here: use .isEmpty() rather than .equals for the empty checks.
This is pretty inefficient, the way you would normally do this in JGit is: while (baseUrl.charAt(baseUrl.length() - 1) == '/') baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
0 is the default value for an int field. We do not make assignments to default values in constructors.
we don't use braces around single line blocks
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
Did you compiled and notice the test passed? check line 1394.
Why don't you use an existing user?
Could also do:  ApiDate lastSeen = Optional.ofNullable(r.getLastseen()).map(ApiDate::new).orElse(null);
why not make logger a static field?
Could you load requested into a local variable here as well?
Return the provider object using new instead of using Class.forName(...) as we have only one provider per module.
This IMO should come from the provider, to keep use of configuration files to a minimum.
else is not needed. Remove it and you can dedent the block below.
final
Maybe we could use a Redis pipe here as well.
what do the 0L, 100L represent?
since getTerminalAtIndex can return null there should probably be a null check here (realize that it's vanishingly unlikely given the current contents of the panel!)
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
What about also checking operands here? Should be the same except for labels.
This method need not be static
We could make this as static method.
Please move the validations to a separate method called validate() or validateName()
Curly braces in the same line of if statement. Add spaces between variables and operands, such as cursor != null
I think it's best to explicitly specify projection, so you are more free in future to change default projection in provider
No System.out please
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
Too many unnecessary blank spaces in this class. Please refactor.
A diamond operator would suffice.
Let's remove the BsmAdminPageEditWindow(String) constructor.
Can you check return value and log if not found?
Please follow the strategy employed in ParallelExecutionIntegrationTests to make these tests faster.
As I have mentioned previously, Item/Build is nonexistent. The Java constant is Item.BUILD. The permission as displayed in the UI is Job/Build.
style guide
Delegate to isNonCodedDrug() when making the check.
do we need this composite? we have already the border composite
actually calling .layoutData(new GridData(......)).create... should be ok here, correct? like you changed from supplier to layoutData in addFiller()
Having the SWT.Read_only gives the text with context menu items {undo, cut, copy, paste, delete, select all , right to left reading order, show unicode control char , insert unicode control char, open IME, Reconversion} Since our objective is only copy can we restrict the text selection context menu to select all and copy ?
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
Which tests fail if we don't have this line?
Why 2? It doesn't matter what number you send as the second argument right?
why is this necessary?
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
Why do you pick b as the variable name? It could be model or m. I am just curious.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
I think it would be better to have two asserts, one for each metrics file....that way when something breaks it's easier to understand where the probem is
Why we need spy here?
If we arrive here the statusCallback is notified already in the DownloadBatch.batchCannotContinue method, right?
What makes this status UNKNOWN instead of DOWNLOAD_ERROR?
We can extract urlByDownloadId.getValue() as a fileUrl and also reuse it in the new DownloadFile
Should this get a trailing newline too?
<LINK_0>
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
Why is it a list of lists, not just a list?
Use LinkedList instead, as we need to remove its head frequently in endInput.
ambry does not support PUTs. You should do the same thing you did in AdminBlobStorageService here.
shouldn't required be true here?
this is not required since the PUT doesn't reach the router
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
final, Lists.newArrayList(), etc
[minor] Here and below, can many of the methods be static?
why? just don't set _vds, and if _vds is null then do not enforce. I think we talked about this. Always use the engine interfaces.
Don't you want to add some logging here? at least at debug level?
This looks like a lot of repetetive code from GetFingerpringQuery- can't it be reused somehow?
Asserts.succeedsEventually(new Runnable() { public void run() {assertEquals(x[0], 1); } }); will avoid waiting 5000ms when 1ms might have done.
do not check equality based on toString
hi, few notes - 1. we should take locks for all the commands in status different then ENDED_SUCCESFULLY/ENDED_WITH_FAILURE/NOT_STARTED/UNKNOWN (so basically - for commands that are during execution, i think that we should add boolean member or method to the enum for checking that so that it'll be maintainable when new enum values are added). 2.we should also filter out the commands not managed by ATM/COCO - those are the commands that their status is updated to ENDED_WITH_FAILURE in line 98. so this code needs to be after the update done in line 98.
cleanup this temp dir afterwards
given that we do not need to save on memory here, you can replace the remaining lines of code here with a java Assert.assertEquals(File.lines(file),Files.lines(outFile))
You also need to keep track of whether you got any exception at all, and assert that you did at the end of this test (since you can't use the built-in expectedExceptions here due to the wrapping).
handle the case when splits[1] is empty?
The else is unnecessary, the above returns (same for the following else).
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
Looks like even the brackets around i == j is not useful?
int[] props would make everyone including the style checker much happier
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
nit: consider having it only declared, but not initialized. This way you'll ensure that it's set correctly below and you aren't missing a case
why removing?
Debug has to be detected first otherwise we'll always take the INFO branch.
just remove the fileSize from here... and that's the only change you will need.
Same as above for toString(): <LINK_0>
a bit of NPE's will happen inside of combine on the first exception
Should be a good citizen and re-set the interrupted state when catching InterruptedExeption.
System properties should have meaningful names like mylyn.tests.configuration.url
I'd avoid introducing new term target  partitionData[i].ensurePositionsCapacity(page.getPositionCount()); partitionData[i].resetPositionCount();
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
For each?
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
This can be simplified to return Futures.immediateFuture(name);
You need an explicit {} block
why final variable? :-)
remove
remove
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check here since testFolderPath must be path to a directory
{}
unnecessary new line
Any specific reason we are handling 2 tables in a single file? This might throw off some people. Also, if we are making the separation, wouldn't it be better to do it in FluxC? I haven't thought about this too much, so I am actually asking and not suggesting :)
Why are you removing metrics at the end ? It's not already done by DbTester ?
Isn't this a BLOB?
suggestion && (((BaArmor) part).getType() == getType());
Any reason to copy-paste implementation from mapPartitionToPrimaryAndBackups?
Should return false if !super.supportsRefreshing()
This might be cleaner with a stream, something like:  Optional<IVolumeSource> vol = podSpecVolumes.stream() .filter(v->v.getName().equals(volumeMount.getName())) .findFirst(); assertTrue("Expected to find secret volume in pod spec", vol.isPresent());
this test can be simplified by using [AssertJ](<LINK_0> java assertThat(KmsTextEncryptor.extractEncryptionContext(ENCRYPTION_TEXT)) .containsOnly( entry("param", "L'homme c'est rien"), entry("test", "l'oeuvre c'est tout"), entry("valueless", ""));
It will never reach here, as you break after found=true. Add the found = false after for (GlusterBrickEntity paramBrick : bricks) {
Should we make this intermediate commit point *configurable*? I'm hoping committing every 10,000 is a sane default, but just wondering out loud if it's worth making this a configuration setting.
Note that we get the message twice when oai.import.batch.size is defaulted. Cosmetic. But do we really need this?
Formatting
_cough_ You might want to remove the println. ;) FYI, you don't need to create a new PR, just make a commit to your branch.
Can you please rewrite this to use a new key class? Doing this has quite a high overhead. [Here's an example fixed version of the old LiquidContainerRegistry.](<LINK_0>
As for me, brokerConfig variable name would be simpler here
There is a better way so that a new Arrays.asList wrapper won't be allocated. java.util.Collections.addAll();
map is also whitespace separated, so should be not split on tabs only
suggestion final Deque<Integer> ccStack = new ArrayDeque<>(numVertex);
Remove the * 2
Remove
Do we need to doc that this is not-thread-safe? I guess it's internal.
