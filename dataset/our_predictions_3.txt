Is this order guaranteed, ie ls-refs before fetch?
shouldn't you clear out restartToken and lastPackId at the start? The way you are using class variables is error prone. Any thing that should be remembered across sessions should be stored in the Session, otherwise pass the information as arguments. This will require you to create some helper types to hold data e.g. a Header class with two fields, restartToken and lastPackId. This does not apply to in and out, since they are used everywhere.
Move to a separate file? UploadPack.java is getting pretty big...
This is really minor, but could you use Path api here? As it will return better error message than File will. giving some context on what is going on...
Could this relatively general code be reused in the needsOrderBy method?
in all these OseeArgumentException constructors, you don't need to use String.format, it does that for you.
throw an exception? this is not intended to use.
Symmetry (throw)?
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
Here is also that unusual check.
Using a boolean as abort condition for the parsers main while loop is also a deprecated pattern. Instead replace this line with outerloop: while(true) {.
Should use nextTag() and switch-case instead.
Please remove an excessive space character.
In case self is a BufferedIterator should this return self instead of re-wrapping?
same as above... why not use simple if/else here?
Strings would be better to be stored in a constant
I see this duplicated in a lot of tests, maybe we should put it in it's own utility function?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
Maybe relate those hardcoded strings to the enum above?
shouldn't be setDaemon(true)
Nit: I would like this broken up into multiple statements so we can tell where it breaks if we get an NPE.
ACCESS_CONSENT_ATTR and INST_ACCESS_CONSENT_ATTR are defined in both SamlConstants and NhincConstants. Remove from NhincConstants.
Consider to use StringUtils.hasLength(str) to check
rename the method to createResourceIdAttributeStatements
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Why going for semantic here ??
Should we handle StatusPart separately?
Maybe not needed? We don't have to check if a target process definition exists in the source container.
are we not covering this when we do the merge?
This could be written as if (!invoked)
nit: create static variable for this empty set and return that static variable
return Collections.emptyList();
Check that the RyaStatement and Config are not null.
ERR_DELETE_ERROR, add if there isn't one already
Possible NPE here in case of default constructor. Let's mark the 'log' field as 'final' and initialize it in default constructor.
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
Out of interest why can you not do DecisionTableOrientation.values()?
At present, we try to avoid use of the keyword final as per our [POLICIES](<LINK_0>
map - confusing name
in what scenario path list will be empty with copy error set to true ?
This is File copy error not file system retry case.
switch them. checking boolean is faster than checking isMaster
No need to log here: return binary.getLong();
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
What about l < Integer.MIN_VALUE?
no need to specify type on RHS
These two methods seem unnecessary. We already have a way to get the PanelInfo. Since they're only used in tests, map over that in the tests instead.
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
check to make sure notificationUUID is not null
This should check to make sure that notificationUUID is not null before attempting to delete it.
It doesn't look like you are doing anything with the bucket here. This can be removed.
static
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
Was thinking about collisions here, <LINK_0>, theres about ~1% probability of collision in 10k tables, but we are fine I think (except for the large internal product that is creating and truncating tables). We can take a 16 character substring?
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
Two TimeAndDims might have dims of different length so I think this could cause an out of bounds array access on that.dims[i]. This also doesn't check types at all but the Comparator for sorted facts does check types. The equals impl could do return dimsComparator.compare(this, that) == 0 although this does some needless name lookups.
Did you mean --i?
Seems like there's a spacing issue here, two spaces instead of 4.
Normally, a 'validate' method should return true in case of success, and false if validation failed.
I'm probably missing something, but it seems like this is part of the next case (isn't queue.size() >= 0 an invariant?). Is this called out just to emphasize that setting 0 => "no queuing"?
do the comparison the other way around
JDBC
there is an 'n' missing at the end of 'pattern'.
Because it can be called by both focusGained and mouseEnter, sometimes you have two active contexts. Maybe there should be only one?
<LINK_0> Let me know if you have any issues managing or adding items to the project
This seems like something the client would want access to, "request a new full page of cards".
You don't need this line because of green 31.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
why was this done?
Yes, polymorphism is what you want. instanceof generally is a last-resort kind of solution. Here you're in charge of the design so you can easily avoid it by adding another level to your hierarchy.
Please keep this.cell near the related fields (previousFamily & cell count) below
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
The responsebody annotation can be removed, because the class is annotated with RestController. suggestion public Promise<CodeSystems> searchByGet(final CodeSystemRestSearch params) {
I'm almost tending to use VRaptor specific exceptions for this case, instead of reusing IllegalArg and IllegalState... We're doing this only because of validations, right? We could create a ValidationFailedException.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
this.redisTemplate
Nit-pick for the variable name. It is really not file, so just entry would be good. The new HashMap() is bad code too. Must be with generics
Should add the rule to config file?
can't be null?
Hi, I am currently evaluating exception aggregation tools and so far bugsnag seems to be the most promising for my needs. Especially with a logback extension, which is why I am following your pull request. Here at this line you might consider making the initialization of the UncaughtExceptionHandler, which is implicitly done through the constructor, configurable. In my use-case for example I am running a centralised logging server which is reading log events from sockets and writing them to files as well as to an exception aggregation tool. In this context a global exception handler may not be wanted/needed.
Isn't it enough to declare Exception here? An exception will fail the test, regardless of the specific type.
Why the sub string ?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Can we change this to LOGGER.INFO
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
filter(Objects::nonNull)
this.
Should this be String.valueOf or is cnn the way to go?
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
ConfigurationImpl_toString = Node configuration: {0}\nEdge configuration: {1} MessageFormat.format(Messages.ConfigurationImpl_toString, nodeConfiguration, edgeConfiguration);
I think pNode.getClass() doesn't have to be in the loop, you can move to above and return empty is the condition is true
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
I would suggest moving pNode.getClass() == PointNode.class before the for loop
See above about checking the labels
See above about checking the labels
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
nit: we don't do this (argument alignment) throughout the project, any reason to start with this method?
Yeah, here's where I was thinking of using our custom exceptions. IdpResponse.fromError(...)
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
Shouldn't have printStackTrace() in production code switch to logging.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Please replace that 1 by a constant indicating what it is.
final
Make this a typed exception (e.g. PlatformServicesException)
Remove stack traces
can you change this method to call your new method instead? Make sure to pass 5 seconds as the timeout to not change the meaning of this function.
Why does this need to be ordered by the synthetic primary key?
Possible copy/paste bug in the order by clause.
Lists obtained from a message are immutable. No need for extra copying.
Was seconds an intentional omission here?
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
Hash code
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
Please store these values in a static variable, such as ASSISTANT_USERNAME :smile:
I would rather rewrite the assert to check the full URL or to chack whether the URL contains the name. Just removing the check is a bit hackish
@mcivantos-tribalyte _successCallback_ has changed in another commit, you need to update this to: _(WorkspaceProject project) -> successCallback.execute(project)_
no need to create a set here..
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Maybe it's just me, but I would find a simple if-else clause more readable.
this part looks similiar to #validateAuthenticationState consider extracting the common code into a shared method
Could call the method addCookie(String domain,....) instead.
fail
same as others: log should have Exception as arg
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
null or empty list?
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
ahh, here it is
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Can this be private (or at least package protected)? It's only used by this class.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Can this be private (or at least package protected)? It's only used by this class.
Preferably have one call the other?
can you pull this from a static string?
This looks like a good candidate for doing ImmutableMap.of(Maps.transformEntries(...)).
please apply formatting
can be simplier: showing empty array even if the value is null is not really a big deal imo. Also, toString are usually only used for logger..
you don't need this. the "+" operator does this for you.
since host_name can be ugly fqdn or ip i think it would be nice to print vds_name as well
recordCount++; doesn't work?
grammar nit: 1, not one, and no :
I would really like to optimize, but having another sorted data structure would cost more than just having iterative approach
Should use StatusHandler.log() instead
:astonished:
We should fail() if addTodo() doesn't lead to an exception, to cover the IsThrown part of the method name.
Could you check for null or empty? Via StringUtils.isBlank
Oh please, no! Don't ship a null object! :cry:
Symmetry (throw)?
rm 99
Constant
IMO, urlInitialized check here is redundant. I"m not sure how can you get to this point with urlInitialized=false. (And if it is false- don't you want to return?)
Same concern here. true looks wrong.
mapping may be null at this point
Only 'wrapTextFlag' is needed
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
put call of this method to appropriate place in each method that requires it
why not null as value?
@Serranya The same here. See above.
@Serranya The same here. See above.
@Serranya Please, add the name "body content" into the message to be more clear and specific. It's too much generic.
2xx
@mavrk I think you mixed tabs and whitespaces in the description.setConcept(this) line. in OpenMRS we use tabs. Please remove your whitespaces.
don't need the else here. Too bad java doesn't have XOR :)
You should use ThreadContext.putAll() here.
minor, is it method scope for Visible For Testing? If not please change it to private.
Unnecessary (and incompatible); revert.
I think it might be easier to create a list and compare that?
Actually this should fail, because the input isn't a list of strings, and the type of "properties" is "String[]".
This could use Collections.singletonList
same as above... why not use simple if/else here?
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
Same issue here. We should keep this as static if at all possible
For readability sake, can these two increments use the same atomic method call?
similarly here, if this is general, I've lost updates...
computeIfAbsent?
You can inject the header variable in this class too, to avoid dealing with static methods.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
Immutable?
For backwards compatibility, why is passing the CAS protocol service param not enough? (I'm assuming that's what happened previously?) We've had some issues in this service url construction lately so I'd like to reduce our chances of getting it wrong again :-)
Why do we need those queues? Can't we just invoke handlers in add(), delete(), move() methods? Are there any benefits of using queues that I've failed to catch?
Please use networkClusters instead of getNetworkClusterList().getItems()
Both of these lines should be moved into corresponding methods calculating the desired state according to the two dependencies, as I described in another file.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
so for IPv6 hosts when a machine is cloned this is going to break?
there is no need for using FQDN because only one Base64 is imported now
if that previews is showing cleaned-up code, why is this one still here?
I continue to think that **aifc** should to be here...
Can use the already defined Constants
@Nadahar Right, text/vtt, i was too fast...my bad.
SetConfigurationObject should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetPushSetupAlarm should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
Is there a reason not to use Util.TOLERANCE?
doing += on a Long object causes boxing every time. It'd be better to have sum be a "long", and return Long.valueOf(sum) at the end. Or simply return a long in this method.
why sink->getSink()?
This could be null, we should probably handle this if the JIRA api changes again
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
I don't see a test for this new method
Does it make sense to have this for a class that states it's "modified"?
Rename this local variable to gid as well, like the overall renaming you have done for lrecId.
More accurate error message
Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)
Style issue: @Override shuld be on line above the method declaration
would this be called often, and would the list copy be expensive?
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
I understand you're trying to emphasize the connection between the two methods, but calling this onPartitionsAssigned feels a little confusing in this class; on ConsumerRebalanceListener it is intended to convey some subscription/notification semantics that do not apply here. The same applies to onPartitionsRevoked and onRecordsReceived.
Add check that non-null
is it at all possible to use standard URI building things here? Either hadoop FS path building or the java File and Path constructs?
The forbidden apis check is flagging an error here: > [ERROR] Forbidden method invocation: java.lang.String#matches(java.lang.String) [Use startsWith(), endsWith(), contains(), or compile and cache a Pattern explicitly] The regex also looks more complicated than necessary and is causing test failures: <LINK_0>  [ERROR] testIsTaskCurrent[numThreads = 1](org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest) Time elapsed: 0.142 s <<< ERROR! java.lang.IllegalArgumentException: dataSource cannot contain whitespace character. at com.google.common.base.Preconditions.checkArgument(Preconditions.java:125) at org.apache.druid.segment.indexing.DataSchema.validateDatasourceName(DataSchema.java:108) at org.apache.druid.segment.indexing.DataSchema.<init>(DataSchema.java:76) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.getDataSchema(KafkaSupervisorTest.java:3636) at org.apache.druid.indexing.kafka.supervisor.KafkaSupervisorTest.testIsTaskCurrent(KafkaSupervisorTest.java:3099)
if (realm != null) maybe - just to be safe.
Remove throws Exception
Is this really needed?
final
Most callers are assuming that this method returns a non-null DBCollection, so there's no point in having this check.
Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?
minor: don't need this. qualifiers
String.format
I think this is unnecessary => "profile =" + this.profile is sufficient.
bad name of method <LINK_0>
What's the thinking behind inverting values that are passed in?
we don't really use _ (underscore) prefx for any other variables. can you rename it to just 'e'
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
It is not public API so don't worry about changing that, but we should get @alzimmermsft and / or @jianghaolu to review this to ensure that our builders always have a serviceVersion API and not version or any other naming convention.
should this be pipeline.executor?
Seems like the previous tests should also assert on the length?
No reason to save chars here. I would strongly prefer dynamic
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "enforceNotNullNorEmpty" a "static" method. [![rule](<LINK_2>](<LINK_0>
I guess snapshotting right now is cheap since there aren't actually going to be events, but this could lead to unintended consequences later on. It seems safer to return Optional.of(FAKE)? - you still take a snapshot when there's a leader election, but that's relatively uncommon
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
A create card payment request should always have a return URL, so I don't think this should return an optional
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
EndOfStreamException is never thrown in this method, as far as I can see.
unnecessary else clause can be removed
Checking for test mode is fine, but maybe we should do it when this method is called, rather than in here -- the environment it's run in doesn't seem like a concern of this class.
We do not consider the whole resource, but only the selected elements (and their descendants). It should read "The selected elements do not contain".
These 2 methods have some overlapping logic with methods getFeedSLAMissPendingAlerts and getSLAStatus of FeedSLAMonitoringService. Please reuse those methods, so that the API and this service are in sync.
And this change should be reverted as well.
Uses the varargs version
As we're down to one arg, just do:  return threadRecord.hashCode();
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
I'd use a different name, e.g. doStream
Missing types
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
weight is missing from toString()
We should validate that's non-null (to fail sooner).
Why did we make this public?
Given that Void is imported in the file, is there any reason to use the package name prefix?
This should return an immutable collection.
Should not this method create a copy of the set just as getStages()?
The keySet is a view... So, the caller could run into a CME using the returned Set it the Map changes. Wouldn't it be better to return a new set created by the content of the view set?
Do we want to use the platform's default charset when we read this from the database? I suggest we use a fix encoding here like UTF-8? suggestion return new String(licenseResource.getBytes(java.nio.charset.StandardCharsets.UTF_8));
Let's append java checkNotNull(event);  as the first line. EventsShould should have a "nullability check" test case (see other Spine tests for a sample).
We can also skip the query if the resourceId is *
If the code fails to close in, it will never try to close out
for such change. If the code fails to close in, it will never try to close out
Perhaps try-with-resources? And there are also tabs here that could be fixed.
I guess this will crash as well if getCompatibleOperatingSystems() returns null.
context.getClassLoader() can return null
suggestion return getChannel(context) != null;
I keep seeing these checks everywhere that provider is not in SOCIAL_PROVIDERS. I think a positive assertion would be better. Like GENERIC_PROVIDERS.contaains(providerid)
Instead of relying on all the properties shouldn't we just rely on discoveryType? less confusion with if else logic and also while defining the descriptor.
Create a common function for checking the regex and compiling.
You need to check that conceptUuid is not null and blank
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
+ desc
...if you do not provide...
Missing NLS
I think this should be headers.get(name).
Map
just return "" instead of new String()
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Put into constant.
Doesn't this now need a @SuppressWarnings("unchecked") ? I think there are a couple of other places just like this.
Do we really want to move this from trace to debug?
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
@apc999 This needs to be public or reflection will not work
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
I don't know much about how the serialization code works, but is this supposed to be a 1, instead of a unique serial? I'm guessing it doesn't matter because these factories will not be serialized.
No need to use ConcurrentMap.
YOu can remove the syncrhonized block.
I know this is pre-existing, but getQuery has a bunch of other usages that refers to the query text. I would rename one or the other.
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
The most likely case of this if statement is the opposite I think.
Could do this.mode != mode instead of comparing the name.
Why give relayType its own variable and rcIndex and rcIntern not? And is it safe to parse a String to an Int without a try / catch?
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
@erimerturk let's rename this to ex
style nit: we don't use braces around single line blocks
Code style: Always use curly brackets, and space after if.
Code style: Always use curly brackets, and space after if.
is DebugLogger.INSTANCE.w a sneaky way of calling the logger even when logging is disabled?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
Unnecessary blank lines after a method - let's remove all these to keep it slightly shorter
I think null is default
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
I'm confused. Which of these catch clauses is the expected one?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
throw an assertion here, i should probably do that in my code as well
Can be checked on a running cluster: <LINK_0>
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
Is this necessary? We have the StructuralProbe mechanism in the parser. Could that be used instead? Structural probes have recordNewMethod(SInvokable method).
@vilchik-elena Why not make this constructor call the third one?
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
Shouldn't receive a RuntimeException anymore?
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
Modifier 'private' is redundant for Enum constructor - needs to be removed.
When can the name be null? If not possible, then add an assertion.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Unknown file name and known line number? Should that be an error?
These error messages are already pretty good! I'm wondering whether we could store the character index for each token and emit it as part of the error message instead of the "token index". Thoughts?
suggestion assertThat(got).contains("Description");
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
Will * <LINK_0> * <LINK_1> work as well?
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
Do we need to handle BigDecimal as well?
Here also, comparison of value should look at similar types like long and doubles (checking for overflow)
Would it make sense to add something this.caches.clear() to the stop ?
This empty implementation will override CordovaActivity.onXWalkReady. According to the doc, this seems a deprecated Activity replaced by CordovaActivity, so why we make it different here?
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
Preferably have one call the other?
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
Should this return the AzureTable?
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
Synchronize on private lock. <LINK_0>
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
should the message include "command _with options_:" + this.options ?
you're not logging the exception
I see a problem with this error - user doesn't know where the expected type comes from (it is already added from other task).
The model value could be passed as a parameter to the validate method in order to create a single instance of ModelValidator and reuse it.
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
I would probably catch throwables, because ClassDefNotFoundError..
I tend to think that this should just return - I think it's totally reasonable that I as a user might first close the writers independently (they do implement closeable after all) and _then_ close the pool which is going to call these methods again.
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
it would be easier to understand, and way easier to see whats going wrong if something breaks, if youd also compile a expected and actual list and then compare them with arrayEquals
I think you can get rid of the first condition now, due to the change above.
does this needs to also do a null check for payload before assigning a new reference ?
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
please create a more specific exception that extends this one.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
please extract to a separate method
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
<LINK_0>
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
why the new line?
I understand that we still leak off of VerifyingChannelInterceptor in our Testing Framework, but you still can use a MockIntegration.mockMessageHandler() instead of logger in the main flow to verify an incoming message. WDYT?
When you changed the code to also provide the old API, you should be able to revert these changes.
I'd rather toLowerCase() is applied after substring(), not before.
tmp must be a constant and we dont prevent nullpointerexception for filename.
It may be over thinking this but I got some errors when I tried to make a form name with spaces around the "/" e.g Form with / back slash where as Form with/back slash worked on the device. So maybe we can add another replaceAll() after the first one to replace any patterns like Form_with___back_slash?
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
could be static
devtype is not camelcased, also deviceType would be more descriptive.
Space before {
SonarLint is going complain about String concat
Let's include the giver and recipient here too
studentsWhoRespond -> studentsWhoResponded
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Expose Map if you can
let's call it updateCodeMinings() instead.
The implementation is the same as in HostNetworkQos, please implement in HostNetworkQosProperties.
please move the isEmpty methods to the scimSchema
We should avoid using Java8 for issues which could be backported in 2.4.
There is a duplicate implementation in PushTest. It's a good candidate for a test util function that can be imported statically.
It's pretty inefficient to create all these AclBinding instances, just to check for unknowns. Is it possible to avoid that?
kind of curious what these magic numbers are
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
@ilyakharlamov I think that this test won't run on windows, it fails on creating files on /dev/null
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
There is a lot going on this one line.
Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Could use Double.BYTES
This null check should be done in line 274
You can use sourceSummary.getPageTitle() and targetSummary.getPageTitle() for the PageTitle
Looks like a null check on sourcePort is missing here because sourcePort is Integer and therefore can be null. If sourcePort is null then the comparison "== 0" will cause problems when trying to debox sourcePort to int. Just tried the following similar code and it crashed with NPE: Integer sourcePort = null; int x = (sourcePort == 0 ? null : sourcePort);
don't need optional, just use ImmutableSet.of(ports.get(getNodeType()) should work
Check if there is an appropriate constant for "no metakeys" mask.
nit: We can store this into a static final field TEST_PARTITION_INFO int this class.
This is basically a guaranteed crash right? To be avoided at all costs, it's just making future work. A toast and a fall back to the note editor or anything is better than throwing a RuntimeException if we can avoid it
nit: We should use UIUtils.showLongToast(). If it doesn't exist, we should make one.
Any reason for switching from using the PermissionsManager here?
Lots of unnecessary this. qualifiers.
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
The return statement can be simplified return (currentTime - lastHealthCheck) >= minInterval;
give some meaningful name to this thread.
I think the granularity should be 1 seconds instead of 5 seconds here.
getParent() can return null
this can be implemented with: decodeBucketIndex(EXTENDED_PREFIX_BITS, entry)?
This is the only place that add entry to the pool, is it the only way to fill the pool?
Simple for-each?
I still don't understand why the key cannot be the session id
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
this could also use the get treatment
getCells() can never be null
Please close client at the end.
restore might fail with exception => client should be closed in finally block
I suggest to clean up the client in the same class where it is created - in the parent AbstractMessagingTestCase.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
Same issue with the change in visibility of this method as with JcrRepository.start().
newline
Just return data.
nit: you can merge both lines above as checkNotNull will return the given argument
@robbavey don't we have to release this ByteBuf after we've deserialized its contents?
Let's do return fDetailedLoad; even if it is always null for now
Don't need this - regionGuidePosts is either set in the other constructor or set in the readFields method.
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "e" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignored" Please use fail() <LINK_0>
may be it is going to be more obvious to have dedicated variable for that? 'boolean predefinedSamplesCount' instead of 'totalSamplesRequested != -1' ?
Get it from the model now that we have one?
Fix the method name here please.
Same as above - log or throw the weird state.
We could probably use getItem() method here, for consistency.
Like, super.onFailedToRecycleView, this doesn't seem to do anything. Why call one super and not the other? Ditto for below?
To be safe, should check gerritTrigger.getJob() != null first.
job
Should we track additional information here, like what kind of trigger it is? What would the cardinality be of that? (e.g. is it a pipeline trigger, an internal trigger, etc)
since this is an instance variable, regardless whether it's thread local, you should have it qualified with this.
why do we use this. on getters but not on alpha? I would skip this. all together here and use getAlpha()
Wouldn't it be better to only show iterations OR epsilon?
fileName seems a bit redundant - why not do this in a single line? File file = new File(baseDir + "/src/main/resources/bundles/AppErrors.properties");
can we use BeforeClass annotation?
please use method directly, you don't need to store it in variable
In general I wonder why one should instantiate an (immutable) null Password. I mean passing a null parameter to the constructor. Should this be considered a bug instead and hence throw a runtime exception? Should we update the copyright date to 2017?
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
This should be a constant, not a magic string.
throw exception
It should throw exception
Possibly more descriptive error message?
Geometry is comparable?
There's probably some edge cases where this isn't true. Consider the case where there's 1 discrete parameter to optimize, with possible values {A,B,C}. In this case, there's only 3 candidates - and the candidate generator should terminate once all 3 have been generated.
return defaultFilterFactorEnabled ?
also check this
This represents a poor API. If you are not going to provide a working implementation for all versions, the newInstance method should be marked @Nullable and you should actually return null. This way callers explicitly have to write:  java if (mHighlighter != null) { mHighlighter.highlight(...) }  An alternative strategy is to add an isSupported method that NullHighlighter (prefer NoopHighlighter as well since null has no semantic context here) implements and returns false, then throws on all other methods, forcing callers to write:  java if (mHighlighter.isSupported()) { mHighlighter.highlight(...); }  The reason for being explicit is so that readers of the highlighting code can see plainly that it might not be supported and that would explain why it's not working for them on a naive/quick read of the source code. Forcing folks to dig all the way down into the implementation to see that possibility is frustrating.
static.
Assert.notNull(expiry,..) checking might make sense here
nit: line too long. final not required -- a static method cannot be overwritten anyway
how about we redirect to the non deprecated method? The only downside is that the closure cleaner will be applied on the AssignerWithPeriodicWatermarksAdapter.Strateg but I think its fine.
we should not throw an exception here, simply ignore
![MAJOR](<LINK_0> Make "isExcluded" a "static" method. [![rule](<LINK_1>](<LINK_2>
Does the system property check influences the dataType too?
<LINK_0>
<LINK_0>
Why are you catching and ignoring? as above, if you catch, you should do something, if you wish to ignore an exception, please say so. Typically using the word "expected" as the variable name. <LINK_0>
Question: Should not we add braces to this statement?
throw exception
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
Make it a static method in ExecutionExceptions or similar class?
Please use curly braces for conditionals
equals and hashcode are only comparing stepNumber, which is half of the key. Should compare the Progress objects or their IDs too
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
Could you add an assertion on one of the associated props? Just to be sure...
All these vars are used just once. Maybe just use the method call directly? i.e.  "<LINK_0>" + mUser.getAccountToken() + ....
Why the sub string ?
As [mentioned](<LINK_0> in #408, this variable should be renamed to "args" to be more descriptive.
Good note. I think USER_PORTRAIT would be better so it works upside down too
Why are we configuring drawer in this activity. This activity shouldn't have it.
add message to log
What if client is null?
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
@apc999 This needs to be public or reflection will not work
This is already initialized by super class.
correct.
Any reason in particular that it shouldn't give the effect to players?
Check first that target is not null.
should be ...object instances can be deleted"
static import
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
could use diamond op
Looks like validation result is ignored. Let's wrap it with Assert.assertTrue(). Also constants on rows 115 and 118 should be changed to long (0 -> 0L and 1 -> 1L accordingly).
@stefanbirkner I question using LinkedList here, because I understand that ArrayList, the main alternative, usually performs better on modern hardware because it can better exploit processor caches due to it using an array internally, whereas LinkedList cannot due to it using pointers.
why ConfigurableApplicationContext, not ApplicationContext?
Sorry forgot to mention to change the read to access here too
style nit: remove curly brackets
Should you set the module logger after calling WildFlySecurityManager.setCurrentContextClassLoaderPrivileged(logModuleClassLoader)? (as it is done in activate)?
is this required ?
I note this is using the same namespace as the pre-existing "aggregating" metric.
can this just be collapsed into a single writeAndFlush() call?
please add new HelpTag and HashName (as in StorageListModel)
consider a ternary statement instead...
I might be wrong in understanding the bug. Correct me if I'am wrong. But, the bug says "Message in the Restore Popup is not correct when volume is online and snapshot is deactivated" and lets assume now that the snapshot is deactivated and then without this change it would go into the else which is doing the same as your change already right?
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
Could change to ProcessInstance.STATE_ACTIVE ?
This should check to make sure that notificationUUID is not null before attempting to delete it.
check to make sure notificationUUID is not null
It doesn't look like you are doing anything with the bucket here. This can be removed.
While the completeness here is appreciated, toString is generally only used for logging. We can probably reduce the amount of fields we write here to keep our log statements cleaner.
Maybe make this a static final List now that is is used two places? (here and line 123).
have a default constructor with reasonable default values
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Integer.parseInt
Shouldn't options be Immutable?
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
Looks ugly and potentially a source of future NPEs.
what if fParser != this? shouldn't this be fParser.createTimestamp
Please use the Spring's Asserts for that, for consistency with rest of codebase
unrelated change ?
This doesn't seem to be used?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Would return builder(SecurityLink.resolved(security)); be simpler?
nit: param doesn't need final
don't catch, but instead allow the ExceptionMapper to handle it
Better, but use logger.logAndThrow(new ...)
This method is not being used anywhere. This class has findbugs failures as well
we never use NULL, it is a bad practice in general.
is there a reason for StringBuffer instead of StringBuilder?
Since Kieker now requires Java 7, you can use the try-with-resource clause here.
don't forget default case
When you move the default keyword to the corresponding case you don't have to implement it twice. :wink: java case R.id.brick_glide_to_edit_text_duration: default: // Code
Left over from debugging?
The try-catch surounding this can be replaced with JUnits [ExpectedException](<LINK_0> rule. It reads a bit nicer.
do these test methods really require throws Exception?
should this exception be left to bubble up and fail the test ? If afterEach fails it means the repository was not shutdown properly
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
Maybe make it _this.pool_ to keep it consistent.
Actually as Part of reusability we have added Synchronized block inside TrapReceiverImpl.addToSnmpV3Users and same we are calling here.I hope this serves the cause or If still synchronized is needed even for this block i can update it.Please let me know if its necessary to wrap here as well.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Do we want the toString()= in here ?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Just return checkNotNull(id, "id").split("/");
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
Consider adding null check here.
Finish implementing function?
Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods "checkDuplicateEmail" and "checkDuplicateUsername" . And you can instead implement method on the HardcodedAttributeMapperFactory "validateConfiguration" and throw an error in case that "username" or "email" was configured as user model attribute.
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
This shouldn't get thrown.
nit: style wants newline
Do you need the fully qualified class name here?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
I believe that this validation doesn't belong into the API. I'd suggest to modify this 'ticket' method so that it works similar to the 'ticket' method in the 'BackendVmGraphicsConsoleResource'. If the 'graphicsType' is null, it should pass null to the 'SetVmTicket' command. The command implementation should then check if it is null, and generate the appropriate message. It should also check if the VM is down.
Oh yuck. ;)
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
protected instead of package protected
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
public
Why we removed final?
Why do we even have this check. It seems like issue in other place of the code.
just readability - we can move 'updateAllVmsSucceeded' declaration to line 118, as it's not needed for floating disk flow.
rename to contribution
style nit: no braces around single line blocks
You should probably call super.dispose() here too
Likewise don't need the if statement since the optional value will return empty.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
Remove the if.
Please use TIME_FORMAT instead of "HH:mm:ss"
Please make the constructor private (see Invalid).
What if the string doesn't end with a " or '? You'll strip the last character.
nit: use SUBJECT
What are your thoughts on using an AndroidPreferences instead of a raw SharedPrefs?
I would use something more random here, like RandomStringUtils.randomAlpha(Tv.TEN), for example
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Local variable could be declared List instead of ArrayList. Is this worth caching?
This exposes the unicode workaround to the public.
check name?
Can we check for an empty string too, please?
shall it also be >= 0?
Have you intentionally omitted index check?
Is this correct?
This needs to be changed to return the long value.
No need to use UriBuilder
No need to use UriBuilder
Just this.home is enough
return tags;
I think we can remove this line.
returning null cause null pointer exceptions
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
shouldn't use the CLUSTER log CLUSTER.debugf("Shutdown while handling command %s", command);?
Again, we shouldn't do this.
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
Asserting the exception type is sufficient.
You don't need to add this exception to the signature as it is an [unchecked exception](<LINK_0> :)
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
sorry i missed that before, you should send "getActionType().getActionGroup()" instead of specifying the actionGroup here, and specify the correct action group in VdcActionType enum (where currently it is wrongly MANIPULATE_USERS it should be the new EDIT_PROFILE
make permissionList private variable, permissionList should be created only once
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
**USB**-serial
Do we care about threading? device is set in the thread that calls initialize (in the parent class), device is unset (set to null) in a thread used by scheduler. So, should we use volatile, some synchronization, ...?
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
agentDisconnect also sets this state.
Rest of the class does this lookup in the DataPurgeJob instantiation, this should be there also for the clarity.
sgtm
ImmutableSet.copyOf(Iterables.filter(...)) ?
ImmutableSet.copyOf(Iterables.filter(...)) ?
That's good to know.
Can this happen ?
I would recommend componentType.cast(new GlobalSecurityManagerImpl()); instead.
I would suggest updating this to analyze the primary keys map, to verify that the appropriate IDs are being sent in before returning the result.
you should have here setSucceeded(true) IIRC.
Do not forget to check that there is no link after enablement/disablement of the preference. With separated tests like the current stat f the class, we do not control the order of the tests.
This method needs to be implemented in LexerATNSimulator as well as ParserATNSimulator.
Mid return may worsen readability
is it not empty if for example type is an valid empty string?
You have chose a policy=static for the reference, so it cannot be null.
The "Name" class implements correctly the "equals" method, so you can do just this: return SCHEMA_ENUMS.contains(type.getName());
if these strings are used elsewhere, create static constants and share
If the list is static, then you don't have to remove the static modifier everywhere. However, I would prefer you to use a dedicated getter lazily loading the configuration of excluded types.
Why decryption is excluded?
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
can we factor out this code, here and other places? e.g, java return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)) .subscriberContext(reactorContext -> factoredOutFunc())
assertThat(element).hasTotalSize(6)
assertThat(result).hasId("analysis")
Ik. Maven has logging facilities. We should use them.
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
formatting
We could also have a test to establish that we can be rate limited on one read and then have a smaller read succeed.
Because there is only one argument, we can pass workerMetrics instead of an object array.
Inconsistent log format. Use either {0}th or {0} th. {0}-th is even better.
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
typo notifiedMessage ?
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
Hi, @nvazquez. I see a little mistake in you test, you are testing if the method has inserted a tag or not, I think that this test needs to verify if the template inserted in the templateResponse is the same that you has passed in the first param of the method. You can do it checking if each variable in both templates are equals. The same problem in the other tests cases. Ty.
This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.
make it fluent
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
This method looks horrible to me (and to whoever is a sane engineer, I should think).
We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.
From <LINK_0> I still think that a declarative programming approach with streams is a much more elegant implementation than this.
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
just = bit != 0?
Why change the order? You normally stop in opposite order to creation. So, if you create embedded cache manager first and then the server, you normally stop server first, then the cache manager.
Is this double invocation performed on purpose?
I would always call stop regardless of the mode (and make sure that stop is a no-op if it wasn't started). That way, as we implement other modes, we don't have to update that piece of code.
does this need to be a class member?
You could use METRICS_PERFIX constant here instead of priam
Typo? "BlobDet4acryptionCount"
please add setSoftLimitInterval() setter and use it.
We need to get rid of DefaultMinThreadPoolSize and DefaultMaxThreadPoolSize and define those as JMX properties inside ovirt-engine.xml.in
Consider getting this value once, and save it, instead of calling it twice.
@fanifieiev Let's put this in a constant.
@fanifieiev Why not use the constant here too?
... remove the final modifier from the method. It will be easier for future tests.
We get to rename this variable to prefix it with is I guess
Don't we usually include a test for these validations?
Does getEmails2 always return a collection? Take a look at code to be sure. Concerned about possible NPE.
should be false unless one of the vm's disks has true for this
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
Why should the About dialog no longer be resizable?
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
It would be great to rename the variable to isParamCountValid.
Is this a good practice? Casting to an abstract class? it may be better to have an interface AccessControl and AbstractAccessControl then implements that interface... but that way you program against interfaces which seems cleaner to me.
this is redundant with next instanceof check
since this is the vdsbroker, you should be able to use java.util.Objects.equals()
Please remember this ctor changed.
There's no reason to maintain a large cache for the dummy transaction manager. We can just do this(null, null, null, null, null, null, null, null, null, 1, 1);?
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Would be simpler as: return Arrays.asList(Action.RELOAD);
this.
Could change the return type on method to Collection
I realize that the test case was just moved, but maybe for a separate commit or a follow up: Maybe the error could also give a hint on what would be correct. E.g. StringType can only have a single parameter value, received: ... Also in the other error messages. E.g. with 0 it could point out that it must be > 0.
the method name is misleading. You insert a default organization uuid but it's failing. Why?
Since IllegalArgumentException is an unchecked exception you don't need to include throws here
user.get() can return null
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
I could be missing something, but why can't we call deleteAll with toDelete and not create a separate KeysIterable temp var? Actually, this method doesn't even need to accept an iterable over entries, just keys.
value is redundant, just return right away.
are these setters used anywhere?
Same here. Add clarifying parenthesis
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Same variable names (change to senderVouches.
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
The smile has an impact on the currency exposure. Run the test with a VOL_PROVIDER_FLAT such that RISK_REVERSAL_5_FLAT and STRANGLE_5_FLAT are 0.0 everywhere. The last 3 lines of the test are incorrect. Replace by: double ceBaseFD = pvBumped.getAmount() / (SPOT + FD_EPS) - pv.getAmount() / SPOT; assertEquals(computed.getAmount(EUR).getAmount() \* FD_EPS, ceCounterFD, NOTIONAL \* TOL); assertEquals(computed.getAmount(USD).getAmount() \* (1.0d/ (SPOT + FD_EPS) - 1.0d/ SPOT), ceBaseFD, NOTIONAL \* TOL); The code in 'BlackFxSingleBarrierOptionProductPricer' seems correct, it is only the test which is incorrect.
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Use catch (NoSuchAlgorithmException | KeyStoreException e) when having multiple catch blocks with same output inside them. Also since you are catching 'Exception' finally and throwing the same exception with same message, the 1st two catch blocks has become redundant here. BTW its not the best practice to catch Exception, its better to catch specific exceptions and handle them. Any reason for catching Exception?
this.lockVerbs (like below)
This condition seems like it'll fit in InstructorCopyFsToModal.java more, to reduce the reliance on that id string.
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Make this "info". there's relatively fewer operations scheduled on the executor, and would be good to log their completion status
nit: not sure why this method called generateSendFailure. Should this be renamed to handleSendFailure?
Assuming this is noting completion of initialization, perhaps "Finished initialization."
Get the service registration reference and unregister within the deactivate method
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Let's re-word this to a forced shutdown
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
Pretty sure this is also supposed to just be the localization key.
getUsage(...) expects a localization key.
getUsage(...) expects a localization key.
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
Assertion is missing for operator name
it is not really needed, we can simplify the code here
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
This is missing maxTotalRows
Doesn't List as a Collection have a defined method to check whether it's empty or not?
idx -> index
can just do new ArrayList<ICommand>(commandMap.values()); instead of separate addAll
Why is LinkedHashMap required? I think the following is more efficient: java String[] entries = clientInfo.split(" "); Map<String,String> clientInfoMap = new LinkedHashMap<>(entries.length); for (String entry : entries) { String[] kvArray = entry.split("="); clientInfoMap.put(kvArray[0], (kvArray.length ==2)?kvArray[1]:"" ); }
discussed a bit more, we're going to make both key-values, and make sure to split on just the first colon
studentsWhoRespond -> studentsWhoResponded
Could you check for null or empty? Via StringUtils.isBlank
these 3 methods are public do you really need them?
">=" would be robust, even though not possible as the code is now.
Can lease.getStartingAllowedRequests() every equal zero? Might want to check for that.
withMillisOfSecond(0) is not necessary here if it is used above.
same here re: serialization test; probably worth having an example string to verify consistent serialization, would recommend a non-zero duration too (because zero will frequently be serialized on a different codepath to other things).
Verify the injector has been set before using the delegate here
Similar
Similar
Please remove this line
Could this just be a plain getActivity() call? Any reason you need a BaseActivity for startSupportActionMode?
Can be transformed into an if statement.
Is it the 'native snappy library' that is missing or the java-snappy jar?
In the original code, we throw a runtime exception if the native snappy is not found. Should we follow?  throw new RuntimeException("native snappy library not available: " + "SnappyCompressor has not been loaded.");
nitpick : final Throwable t
addPermissions means you added a permission, but it doesn't mean that no restart is needed... unless I'm missing something here.
u can simply use System.out.printf("Please enter a password for %s:",user);
Is there a need to have both asserts? The reason I'd prefer only one is that I don't want the user to get one error, fix it, and then get another. Since nonNull is implied by hasText, we can give the user only one error message that will repair both problems.
I think this should be > 0 since a value list item of 1=One does not work.
If the input string is "(123(456)" this approach will strip the middle bracket and parse when it shouldn't. You'll need to use substring()
Is this still needed after removing the download stuff?
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
you can collapse these 2 lines
It doesn't seem that you did what I asked for. It should be checking the toggle in addition to networkinfo. If the toggle is set to offline then it should return false. If the toggle is set to online then you can check network info and if there's no connection set the toggle to offline and return false, otherwise return true.
Pull this into a static final variable
You could have inlined this loop into the other method because this will create 3000 threads.
should this count be parameterized?
Needs to be in finally - we might get interrupted.
should this only be set if the latch.await above returned true? in the current impl I don't think it would make a difference since clientTimedOut is checked prior to clientHasReceived in the if/else below, but that order could be a fragile assumption
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
Cosmetic: Please, split the throws list clause on separate lines.
What if this path actually exists on the user's workstation?
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
scheduleTimes --> scheduleTime
same as above with the actionBarWrapper
make it protected. It was my fault to make all API constructors private. I fixed that. In master branch all API constructors are protected, so anyone can extend API in their code if they want. But couldn't instantiate directly, forcing them to use singleton
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
please use java.util.Objects.toString(username, "") instead
maybe use dnsServerAddress.isEmpty()
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
I haven't tested yet but the code seems ok
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
We can use the res variable here instead of getContext().getResources().
Can this be private, or is there another use case for default attribute outside the builder's call?
I'm missing the new field in the toString method.
public?
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Same here, keep the order consistent with BenchmarkSuiteConfig
need to change as well
Removing the interceptors removes logging.
This cannot be removed. The scheduled task needs to be saved.
Output the message that caused an exception, possibly at the FINE log level. Also include the exception parameter so we can see a stack trace.
Here and below: previously the code used only one table lookup operation, not it performs two lookups. Please consider to use get(name) and check the value to decide if it is illegal or not.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
Use this.key
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
why exit here ?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.
not sure why this field is public
It's better to cache the values(), a new array is allocated on every invocation.
encoder returns data as a double representing rotations, so it wouldn't really make sense for this method to exist. Have we ever used get? should we modify it to fit this type of sensor as well (in CustomEncoder) or delete it?
> Use emoveCallbacksAndMessages(null) to remove all the messages. > Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
refreshJob field should also be set to null on dispose.
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
I'd recommend using <LINK_0>
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
Why not just include FlagUsageException in the throws here and then if it's thrown it will still count as a failure.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
Collections.singleton?
What's the point of adding a copy here?
different value 50 versus 1. Is that intended?
new DateTime().now() is the same as new DateTime(), so you can just use the latter. (side note- now() is a static method, so DateTime.now() would have been better than new DateTime().now())
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
why do we have a ; here?
remove redundant ; it will only cause static analysis to complain
previous naming was more clear.
Probably makes sense to move this up too.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Saving preferences inside a setter is not appropriate. Please follow the pattern used for other preferences.
are spaces OK in namespace strings?
as above: are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
fos can be inside try ()
Should that be 8192? 8024 seems like a strange number.
I think try with resources should be used.
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
redundant ";" character
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
For loop?
For each?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
you shouldn't need it as UnknownUserException extends LoginException
Is this reload really necessary?
If resources are not dependent on each other, reload after adding isn't needed. One reload after adding endpointConfigurationAddress and one after adding both preHandlerChainAddress and postHandlerChainAddress should be enough.
"Clean orphans from PROPERTIES" to be exact ?
Do you have time for this? We talked about it on Slack.
I think we should leave getClassName() and getMethodName() as is but _only_ pass them to PojoStackTraceWriter to "optimize" the stacktrace.
It's not a _really_ expensive computation but how about using orElseGet?
probably don't want to keep filling this map up as we browse around. could just use getOrDefault?
Actually the underlying objectExpr could have free variables.
return ImmutableSet.of();
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
You could probably use the same URL as in getResultById here.
Should this refer to a platform-relative constant?
Well that's a bit dumb :/ Ah well.
If you have to cast here then you probably should have casted when reading the value from the data array.
use use java.util.Objects
Change to use this.jsonAsString.hashCode().
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
Should this constructor one just delegate to the new one with Function.identity()?
extra ()
super.init() method never throw an exception.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
Throwing the generic Exception ?
I feel like we should be able to take out a lot of these nullity checks. Let's keep this in mind for a future refactor.
Here's another reason for why magic numbers are considered evil: This time it is six 9s. Over in AbstractWidget it is _five_ 9s. On purpose? Bug? With a public static constant you wouldn't have to worry or ever have to make a change in more than one place :-)
I think you can validate the hierarchy here. 1. If section == null && session == null, only general privileges should present. 2. If xxx then xxx ...
This cycle has very confusing brackets. Could you please add brackets to if and properly tabulate the last bracket?
Here's another unsafe cast that can be changed to use mapperType.cast() instead.
Make this final and since we know how many tasks we're dealing with, make sure we're creating a list with the right capacity.
This one is already done on line 816. Do we need it again here?
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Likewise.
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
Is it worth distinguishing what is null in this case? Is it different if m_txnState or the invocation is null
Remove the redundant null checks.
what happens if you call this several times? It will recreate again and again the asked number of threads. You should have some flag to specify that it's already started no?
with 10 threads I can almost always reproduce the bug.
Suggested to extract a static utility function zeroOut(ByteBuffer)
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
I have doubts about this code. It means "a single-line case/default must end with a break, otherwise it needs a pair of braces". For example, this code raises two violations regardless of allowSingleLineStatement option:  switch (0) { case 1: return; // false violation default: throw new RuntimeException(""); // false violation }  and they can not be fixed by adding a trailing break. Why not check the last child's line? Something like  private static boolean isSingleLineSwitchMember(DetailAST ast) { final DetailAST slist = ast.getNextSibling(); return slist == null || slist.getFirstChild() == null || isOnSameLine(ast, slist.getLastChild()); }
it is strange to see all those code to handle null if we are using optional...
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
correct thread safe code looks like this: if (stopped.compareAndSet(false, true)) { cancel(); }
The Exception is never thrown.
Aren't there any chance that super.inputStream() **is** already PushbackInputStream, so, we don't need to wrap at all?
suggestion "A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.");
The above 2 set* calls don't make any sense other than the fact that the call generates a logger.info line. Note that connectRetries and reconnectRetries are defined only in AbstractSolaceBaseInputOperator so super.setConnectRetries(this.connectRetries) assigns a variable value to itself via a function call. Need a reason for this code.
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
I thought empty was OK, and it would point to latest?
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
Can this be private, or is there another use case for default attribute outside the builder's call?
Please remove this field.
shall we rename this as brokerUrl ?
merge else if?
how about doing it a bit different: change #1259 to something like: devices.stream().map(VmDevice::getId).forEach(vmDeviceDao::remove) and this method to something like: removeVmDevice(devices.subList(...))
don't need to wrap safeFormat
I think it is done on purpose to avoid auto boxing/unboxing.
To be sure, we choose this format: blobExpression == null ? false : blobExpression.isLiteralText(); regarding this one: blobExpression != null && blobExpression.isLiteralText(); ?
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
no!
This is good, this thread does not cause the bad failures and dealock anymore. But it should mark the analysis as failed. And for very large traces, I think some failing mechanism should be put in place, to cancel the analysis. For instance, the waitForCompletion could wake up from time to time and make sure the analysis has not failed in the meantime. While this works perfectly fine, resources on a computer _are_ limited and it is better to avoid dragging this thread, and the request thread, and the threaded backend thread and some more view threads waiting for this, imho.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
You should also update the error message in order to tell users that this option can be used in order to switch the duplicate field validation off.
Now that services are class members, we should not need to pass them internally in functions either. Please remove them from parameters and access directly in other functions. This needs to be done for all instances of ontology and germplasm data manager services that are being passed in function parameters. I will fix this @abatac while I am syncing master.
Do you want to update this one to make sure that the key _and_ the value are there?
Done, it looks like the change was not included in patchset1.
@jmmut should these checks be placed after the variant object has been constructed? I remember there was some weird situation with code being executed after the checks.
We generally prefer assertThat(..., is(..)) for better error messages.
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
Ik. Maven has logging facilities. We should use them.
Use IResource.adaptTo(Class).
local variable e is never used.
one more method where it can take file location of properties would be good.
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
What's the point of adding a copy here?
close streams
I think you're missing getDefaultConfigurationFile() here.
Again, use IOUtils.
Needs some sort of assert to show it succeeded
Just for fun ... I'd fid it more readable to have a static import of Mockito.mock() (this is a complete detail, feel free to ignore).
please use static import for Mockito
You have yo use compareAndSet
maybe we don't need AtomicBoolean?
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
Why going for semantic here ??
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
requireNonNull
minor, is it method scope for Visible For Testing? If not please change it to private.
there is no need to convert to map. can we directly print headers ?
I think we should have a better exception message, it should state that the header is not allowed to be set by the user
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
No need to put before/after annotation since the class is extended from TestCase, We can simply remove the inheritance from here and use the annotation, I favor annotations over inheritance in test. Don't remember why I've extended it at the first place
This should always be read from the configs.
Why should the About dialog no longer be resizable?
I suppose this should be true ?
Why is this removed?
we need to reset this property in a @Before block
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
Use Logger instead of sys out.
Debug still needed?
Assert.areNull
Please use the correct "assert" versions. To check for equality, "assertEquals"
@gjd6640 how about making this more explicit and robust this way:  int windowsOffset = System.getProperty("os.name").contains("Windows") ? 1 : 0; assertTrue(firstHighlightingData.startOffset()).isEqualTo(1 + windowsOffset); ...
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
suggestion return format("metadata[%s]", key);
should use a format placeholder instead of string concat
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
The operator should be && not ||
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
missing final
should be named resource
flagging that we should fix this in the next major version and move back to a parameter for the id
should be called resource
This needs to be changed to support locked stream syntax now.
I think this is main issue that needs to be resolved. The problem is that this implementation can consume a lot of resources because of the retrying and the long latency. It could even end up in a livelock. The best approach is to get everything done in a single remote call. There is no retrying needed here because the operation will have exclusive access to the partition.
I think it'd be a bit cleaner to move the value type check into nullSafeValueHolder.
"else if" maybe?
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
should be logged only once, not for each block (spooling is either enabled or disabled).
extract out into a const?
what about outWriter? Move this stuff up into the blocks, so you cannot forget adding it here.
This is not necessary.
unused variable
Why don't we make inDegrees to ConcurrentHashMap also?
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
is there a reason why this method isn't implemented?
What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
This code can be called from RefreshVdcOptionCache() method too, instead of it being written there also.
I would consider rewriting as: if (values == null) { values = new HashMap<String, Object>(); _vdcOptionCache.put(option.getoption_name(), values); } values.put(option.getversion(), GetValue(option));
This could be entirely done as a stream.
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
Also added a try with resources here.
RocksDB reference.
remove this?
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
This used to be mBoardSize.height + 1...bug?
You don't need this line because of green 31.
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
given/ execute/ assert
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
I would add in reindexing at least one ref tag to show if it updates correctly.
Not worth debugging for this QS
Not worth debugging for this QS
Not worth debugging for this QS
hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm! so we cannot validate this on gwt, but I do want to validate it at core. can we have something conditional? if the isAssignableFrom works then perform validation else not? when gwt will not use these classes any more we can just remove the conditional.
Might make sense to use a RowMutation here and have the PutAdapter take a MutationApi interface
Should this use RANDOM_PORT_INDICATOR instead of 0?
Don't we have to say that this is uniqueId JDBC?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
just use context as synch obj
One more - this will be 3
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
[Checkstyle] ERROR: '{' is not preceded with whitespace.
is Options.INDEX_ON_THE_FLY the same as Defaults.CREATE_INDEX?
I feel like there should be a Defaults.toString() or similar for this sort of thing...
Any way to combine both of these try blocks, since it's basically the same error message?
any particular reason why this method doesn't require an IJavaProject ?
are you sure we need to use OSString ?
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
This is an opportunity to stop the bleeding for this naming standard. I would suggest using the bean naming standards that archaius uses.
just return ListeningExecutorService
given that specificity of this SV is exception type I would add the exceptionType in this.
code format
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
This will add the flag to *all* read-resource operations. I'd rather add it only when necessary as suggested at <LINK_0>
shall it also be >= 0?
If the variable name is normalized on the set() method, is it necessary to normalize on the get() as well?
are these setters used anywhere?
this works only until you maintain the order with the values. Safer is to write it like this: return Arrays.stream(values()).filter(e -> e.getValue() == value).findFirst().get();
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
this is not thread safe, nodes can be modified while building the subgraph. I suggest to use Lock for reading and writing accordingly instead of synchronized blocks
The local var is useless, you can remove it.
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
return void
how about  java private boolean needAck(Message message) { return message.getSequence() == message.getBatch().getWindowSize() }
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
add braces
I guess this doesn't really matter but we normally use toImmutableSet so just keep it consistent?
instanceof Dataset is redundant
Something to think about: if all of the DataModel types have a specific view type, then you could add an additional generic parameter to MockChartDataModel for the view type in addition to the dataset. This would allow you to move the view field up to the superclass.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
pull this out into getMockAuthorizer() {return getFileSystem().getAbfsStore.getAuthorizer()}
I think we can still end up with < max threads in the following case: there is only 1 thread doing work, rest are waiting on queue.poll the thread is going thru files or the list responses are slow. it is yet to queue up any subdir. The rest of the threads timeout and fall of their thread main
1. close() the stream and ask for the stats again, to verify they are still readable 2. call toString on opened and closed streams.
This will remove description set, please remove.
Maybe the simpler thing is to send the content type as "application/x-xsrf-token" and have the server require this as the content type of the POST body. This makes it harder for a browser to format a valid POST request using a traditional <form> tag. It also means the server won't attempt to parse the _token field from the POST into the parameter map, which means you don't need the _token hack in the CmdLineParser loop, and you don't have to worry about + or = being incorrectly handled somewhere by an incorrect escape. Alternatively we make the GET return valid JSON of {_token:"text"} and we echo that as-is using a JSON content type in the POST. Just as simple for most script language tools to work with, the client just has to strip the first line of the response body from the GET (to remove that JSON_MAGIC literal) and echo that as the POST body, with Content-Type set to JSON_TYPE ("application/json").
This will remove description set, please remove.
There is no need to set the local scope reference to null, but if you prefer...
I would prefer to use System.nanoTime() for such time, as it is independent of the system time and cannot be corrupted by time changes.
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
matter of taste, this could also be return this.profileTypeRegistry != null;
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
Can this be private, or is there another use case for default attribute outside the builder's call?
Same here: should be Branding, not ProductBranding
I'm missing the new field in the toString method.
Is value == null a valid case here?
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
No need for super()
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
Do we need to start deprecating some of these cases if we are going to just combine them?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
What happens to dst and copier in this case? try-with-resources style wouldn't try the close() again, so should we retry the close to prevent them from leaking?
Why uppercase fs?
I would suggest using the related constant instead.
I would suggest using the related constant instead.
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
Should we add null check?
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
use return ... ? ... : ...?
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
How big is the overhead to do this check on every log?
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
[nit] There is also a cleaner approach using Guava:  java return Enums.getIfPresent(LoadbalancerAlgorithm.class, value).or(UNRECOGNIZED);
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
Send this exception to the log.
Can the current method be executed on an other thread than the UI thread ? The layout command might need to get the figure info wth ui thread access.
don't we want it also for edit? i.e. do we have a similar issue in vms->disk->edit?
I prefer to use the member "instance" instead of the return value. It's a little bit of confusing.
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
Catch exception.
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
Use constants
checkNotNull
With zero knowledge of the code, are you sure this object is not reused? Because if it is a scheduled task it be just reset rather than recreated, but you cannot reset the telescope client, you'll need a new one.
the workspaceitem needs to be deleted
Why Exception instead of Throwable like we did for before()?
Instead of an empty implementation, make this an abstract method that the subclasses need to implement
final?
Binary output length can also be calculated.
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
You may also want a test case for a search value that is non-blank but invalid.
This should be public
Have this call the other tryEvaluateWithAll method
Can be reduced to throws IOException.
Can be reduced to throws IOException.
I would add the other createTempFile method to enforce the fact that we explicitly target this one only.
Should we add null check?
Assert there is no JPrimitiveType in types?
why do we have a ; here?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
copyright
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
please replase MojoExecutionException for a new generic DeploymentExecutionException
this(cepInputTypeParam, cepInputConfigurationParam, fieldsParam, DEFAULT_SEPARATOR);
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
KETTLE_LOGGING_REGISTRY_PURGE_TIMEOUT should probably be a constant in Const.java for consistency with most other kettle params. I know KETTLE_MAX_LOGGING_REGISTRY_SIZE was already there before, but should probably also be defined in Const.java.
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
I think we should remove the following events
I've always been slightly confused by this - is this only used for the pause before we start sweep? If so, it might be better to defined the backoff time you're adding completely separately from the definition here, unless it should always be 5x this one.
14_000_000
You should be returning the values returned in getCalculatedProlepticMonth() here instead (ie, that leap-day is accounted with the 7th month, and year-day with 13th). Ditch the other method.
As there's no extra handling when an IndexOutOfBoundsException is caught, both old and new code behaves the same way: any exception thrown by logicalPages.get( page ) will always be thrown back! As so, the try-catch is dispensable and it's best to leave the code as it was.
Duplicated code, try to share/reuse.
Duplicated code, try to share/reuse.
get rid of "..." not enterprisy!
Can use java 8 paths.
Is there another place where we can define this, so that this does not need to be defined in RealVoltDB as well as here?
move this line before above line, After super.cleanup method couldn't do any of the server requests.
As noted above, just put the init code in init() unless there is a reason not to.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
You should use ThreadContext.putAll() here.
Unnecessary (and incompatible); revert.
Typically we use Map on the left hand side rather than HashMap
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
Is that safe to call when not holding it?
I think Long.MAX_VALUE is too long. How about using 1 hour?
:smile: We prefer to use fail("BeanDefinitionStoreException expeted.") within try...catch
I think your tests would be cleaner and more clear if the validation methods returned true/false instead of throwing an exception. If there is a good reason to keep the ValidationException then I think it would probably make more sense to have a boolean local variable here, something like success, that is initialized to true and then set to false on catch. Then you would have a single assertTrue statement at the end: assertTrue("The counts should be been the same.", success); The same goes for all the tests in this class.
y not use @Test (expected...)
You can use try with resources here so the Input stream is closed automatically.
Is it OK to swallow this entirely?
@xxDark can you link to the spec where all of this is explained ?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
It seems that if the caller knows the initial capacity we shouldn't use a Mini variant if the capacity would already put us into using the non Mini variant ?
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Should this method be private or protected?
Racy. Maybe just chuck a synchronized on.
Delegate to isNonCodedDrug() when making the check.
Remove?
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
need to remove this print or convert it to log stmt
Shouldn't options be Immutable?
throws TaskException is part of the interface, did you mean to remove it?
Config class have constant defined for default config file name
The <Integer> can probably be omitted.
EmptyConfig.INSTANCE?
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
Could be inlined here by using test()
This needs an @Override annotation.
style nit: s/if(/if (/
This is fine, but why did you think of changing it to protected ?
consider to inline uris
Why not simply return an anonymous abstract list that delegates the two methods you have to implement.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Nitpick: startingCounter?
You increment just one of the counters. The total is produced by prometheus automagically. So basically, we could have: starting_attempts.total#debug=false and starting_attempts.total#debug=true and just increment one of them here. We would not have an untagged counter at all.
This is using the default locale when converting to bytes. Not sure if that is a big problem since changes of the locale should be fairly rare and under our control, but still..
Type casting again.
Type casting again.
Using a try .. catch block instead of pre-checking with contains is bad code style and also not very _fail fast_.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
Collections.emptyList() seems cleaner here.
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
We should still be able to set the dialog's title (?) In this case, title is always dynamic as it comes from UI plugin API function call.
This could be: filterListEditor = createFilterListEditor(); filterListEditor.hideLabel();
Remove public
rename to contribution
rename to contribution
enableEditingButtons(..)
Why do we have this constructor?
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
I really don't like this convention because it means that we can no longer rename-refactor the identifiers without changing the meaning of the program. It is in effect a very subtle kind of reflection. So I would prefer a distinct string field in this case and others like it. I realize that there's lots of this kind of thing in OCS, but we should fix it when we encounter it. Does this make sense?
nit: language is not supported: %s ?
Using a static map would be easier?
Put this exception in the default branch of swith.
can this just be boolean instead of Boolean?
Add TODO to not forget implement this in the future.
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
.hasSize(), 2
This is not time zone?
isNull()?
Do we need to null check event.post here?
This line is redundant.
We can drop final PostModel post = event.post; at the top of this method.
Is this signum call really needed here? compareTo should already return the correct value.
Also, there's no zero comparison covered?
I suggest using "ComparisonChain.start().compare(o1.name, o2.name).result()" - Location.name can be null.
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
The editor can't be null
I think this should be replaceFailed = false instead.
getFullName()
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
I think the setMaterializableResourceProperty should handle the materialized scenario itself. This means that this method can simply invoke setMaterializableResourceProperty(ACCOUNT,account); and then, the internal code of setMaterializableResourceProperty will check whether the account is materialized or not and then will relay on setResourceProperty(ACCOUNT,account); internally.
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
do u need to guard against NPE's anywhere here?
I would suggest extracting the format as a constant and hardcoding some of the format constants instead of doing it the other way. e.g.  CONTAINER_HEART_BEAT_SERVLET_FORMAT = "%s" + "/containerHeartbeat"; CONTAINER_EXECUTION_ID_PARAM_FORMAT = "executionContainerId=" + "%s"; CONTAINER_HEART_BEAT_ENDPOINT_FORMAT = CONTAINER_HEART_BEAT_SERVLET_FORMAT + CONTAINER_EXECUTION_ID_PARAM_FORMAT  Or some flavor of the above, so that you can reuse the format across the unit tests & other places in code. IMO, having the constants by themselves still forces users to figure out how they come together and repetitive code e.g. "%s%s?%s=%s" with readability hit as well.
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
return Arrays.asList(boolean.class, Boolean.class)
return Arrays.asList(....)
close already done in Util.read(..)
here we should guard against null is
Since we don't usually run with assertions enabled, please consider converting assert to Preconditions.checkArgument.
Now this method does not do as it's named...
you should have here setSucceeded(true) IIRC.
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
Let's have some constants here instead of repeated magic numbers.
Wouldn't it be nice to check the path was observablePath rather than _any_ path?
unsubscribe()
We could cover it with some tests.
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
only EE product can have runtime lineage
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
Check the env variable before returning true.
Check env variable before returning true.
This should check the environment variable before returning true.
We should close the FileOutputStream, relying on finalizers is very finicky
I wonder if this is really necessary... jansi uses [isatty](<LINK_0> to avoid writing the escape codes when output is redirected.
I don't like the word "command" in "where the WES command should run". If anything, you're sort of running the (client) command on your local box. How about The URL of the WES server, e.g., ..... Also, I think you should say URL, just to be consistent with --wes-url; right now it's a mixture of url and URI.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
"^.*" + USER_SCENARIO_ID + scenarioId + US_STEP_ID + "\\d+_" + stepId + ".\*$" should be enought
Instead of using the message, evaluate the topic to generate a good string message
Are you sure we need that condition? Are you able to cover it by test case? The null-test was not present before and I can't see any test related to that.
Why is it a list of lists, not just a list?
Style issue: @Override shuld be on line above the method declaration
You can use GenericMath.DBL_EPSILON here.
Does a straight comparison work here? NaN isn't usually equal to itself.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
Why is this removed?
Will not delete directory. You should FileUtils.deleteDirectory
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
DEFAULT_HTTP_TIMEOUT?
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
I think this method has no need to be static
It seems that throwing a generic Exception is not a good practice in Java. Is there a strong reason for that?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
Let's use debug level instead of info.
Encapsulation
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
Instead of repeating the addition assign it to a value on the stack.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
Release lock?
Move the logic to configAccessor.
Since this will add one more zk read, and admin.getClusterTopology(clusterId) actually reads the cluster, I am not sure how heavy this call is. I assume it is mostly used during deployment? I wonder if we can use the result in admin.getClusterTopology: if the cluster doesn't exist, an exception(HelixException/NoClusterExistException) is thrown. Rest code here catches it and returns 404. Then it saves one zk read.
These lines could be in a private check method to reduce duplicate code.
Nitpicking, but I'd prefer creating the builder with  org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder(hotRodServer);  and then setting the marshalling. Same in RemoteStoreMixedAccessTest
I don't think setting the timeouts are required in this test, especially since the default is already 60 seconds.
I believe we should add the ability to override the baseUrl of the s3 client. This will allow support for beta regions of S3, and other s3 compatible storage APIs (GCS, Azure CS) <LINK_0>
There is no call to this method outside TableManager, shouldn't we change it to private?
s/RemoteTable/RemoteReadableTable
question: why do we need the TableImpl class? The only usage of the tables map is in ExecutionPlanner.createJobGraph() and it is only taking the TableSpec keySet. Also, it seems that TableImpl class does not provide any further functions except as a container for TableSpec. Can we remove it?
Magic number <LINK_0> Try to use a constant for the timeout. Review the constants in the project.
this is already called in BasePageObject so you don't have to call it
you can remove this
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Should move this try/catch deeper into the call stack, either the public overload or in the package-private method so that we don't need to put it in multiple locations.
Did you use our code formatter? <LINK_0>
Don't we need to return something like -1 in the null case (i.e. when the type is not in-house one)?
In alignment with valueOf, perhaps name this valueOfType or fromType?
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
Why is there a fromByteArray method? Why not call the constructor directly?
I think it is common to return the written value.
Superfluous blank line :).
For each?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
int[] props would make everyone including the style checker much happier
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
This line is redundant.
that class would be better with a builder, though I wouldn't ask changing it now
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
You could remove method("POST") as you set the HTTP method on create
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
wouldn't UnsupportedOperationException be a better match ?
Same here, no need a transaction
No need to make this a transaction, its a single insert statement.
The value checking is not needed here, only the preference. We already check the value in the other test.
HQL/JP-QL
clause?
Detail: FROM capitalized.
Could you please use DecisionTableInputType.XLSX
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
looks broken, as L262 will always get a closed stream
Optional.ofNullable could be used?
This pattern is captured in Optional's [ofNullable](<LINK_0> method, so in this case the body of the method can be simplified to  Optional.ofNullable(gitRepo)  Similarly for other methods in this class. Let's get rid of the boilerplate :)
The original code style in this method is better:  private PagesSerde createPagesSerdeInternal(Optional<SpillCipher> spillCipher) { if (compressionEnabled) { return new PagesSerde(blockEncodingSerde, Optional.of(new Lz4Compressor()), Optional.of(new Lz4Decompressor()), spillCipher); } return new PagesSerde(blockEncodingSerde, Optional.empty(), Optional.empty(), spillCipher); }
Ingest modules need to throw IngestModuleException if there is an error in startUp, with a user readable exception message, since it is displayed to the user. You need to wrap the NoCurrentCaseException in an IngestModuleException and throw, not log here.
I think we can use ConcurrentHashMap::computeIfAbsent to replace synchronized and containsKey
Shouldn't the restoration be in the reverse order of the activation? So that we first restore the last activated context?
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
Not a good idea to have two methods with the same signature except for the type, espcially when one is a subtype of the other.
I would have inverted the check but that may be unnecessary
Encapsulate this here. Should be returning a MapView here.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
we need a gauge metric here to ensure the thread is running
Why this debug log is removed? Not sure, if it's there for any security issues.
please provide e as argument for stacktrace
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
-1. This means input does not get read.
Style-nit: Should be after this.accountCache = accountCache.
Here you use Byte.toString() where a bit lower, line 63, you use ..Factory.convert(..) - might be better to unify.
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
You need to send cookie here.
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
suggestion return Arrays.toString(value);
I think we should sort the tags in a specific order here. Otherwise we could have tests excluded for the same reason, but the strings will not match if tags are not in the same order.
It would be even better to get rid of this line: java String.join(" ", translatedWords);  with java .collect(Collectors.joining(" "));
I would suggest using the related constant instead.
I would suggest using the related constant instead.
Why uppercase fs?
name could be more descriptive
Vague variable name s
Add maxBytesInMemory, maxTotalRows, logParseExceptions, maxParseExceptions, maxSavedParseExceptions, maxRecordsPerPoll, and intermediateHandoffPeriod. I would also just remove buildV9Directly from the toString if the parent class is doing nothing with it.
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
throw new RuntimeException(e);
nit: how about we just use the class name of input strategy by default
could uh, use checkState(false, "") instead of a lambda ;)
AndroidStudio's inspection highlights and suggests replacing indexOf with contains for the condition expression. WDYT about replacing it? If we will touch this line, and since the index is recalculated below, how about introducing a temp variable to hold the index to avoid doing the lookup twice anyway?
These should be marked as abstract and let the subclasses should implement them.
Do we need some kind of synchronization here, or will next() never be concurrently called from two separate threads?
Avoid duplication with:  long sliceLength = Math.min(getRemaining(), partSizeInMB << 20);
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
These seem to be covered by NUMBER_TYPES already?
This could be confusing here. How the user know the all fields?
let's call it updateCodeMinings() instead.
ooh! I ...Connector, here!
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
Please add ? and % as well
Isn't it also important that adType was async and method was top?
Please remove an excessive space character.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
Added because?
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
Should not be able to submit when there is no question selected.
To defend against catastrophes from bad future refactorings, I would recommend extracting a protected method for the computer's log directory, to make it clear that what you are deleting is specific to this computer only.
Should the InterruptedException here be treated as a cancellation?
You can use GlowServer.logger.log(Level.X, "message", exception)
seems like synchonized is not needed here, given increment/decrement already protect
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
Same here, if it's not supported we need a test checking that trying to set indexNullAs fails.
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
Not good to use Optional for collections, just return empty collection
Should we use UTF-8 instead of default character setting?
maybe test first char for empty letter as well to reuse s if possible?
can this use the MMX StringUtils functions?
Is it really worth checking before setting it?
Should you be closing the connection as well? What happens if the caller attempts to execute query after closing the prepstmt
just remove this check and the corresponding else. managementRealmOpenTask permissionRealmOpenTask may finished at the different time, so you could have managementRealm != null but permissionRealm == null
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
This could be reworked to avoid having ! in nearly every condition to make the different cases cleaner to read.
Why not push/pop methods ? bit clearer IMO.
suggestion if (this.currentTask != null) checkAndRethrow();
Same why not else if?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
I prefer ", not "+(l == null ? null : l.getClass()));
This method can be static, as all the methods it calls.
Since this logic is getting more complex, it probably makes sense to reuse isBindableType here.
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
Shall Alter database to add source_of_replication DB property and see if Dump succeed afterwards.
It looks like sparkObject could now be a byte[], so should setSparkObject call deserialize here, the same as the code you added in getLength() ?
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
final
Unnecessary.
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Why not unconditionally update the SessionData?
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
Is it possible context.getAuthenticationInfo() is null or context.getAuthenticationInfo().getUser() is null
I tend to prefer having all code at the same level =>  if (0 != context.prepareSelect("select count(uuid) from quality_gates where is_built_in = ?".setBoolean(1, true).get(row -> row.getLong(1))) { return; } context.prepareUpsert("insert into quality_gates (uuid, name, is_built_in, created_at) values (?,?,?,?)") ...
minor: don't need this. qualifiers
channelId => channelName
s/id/ID
The two methods above are the same except for the first line...perhaps reuse the code instead?
The two methods above are the same except for the first line...perhaps reuse the code instead?
Can be rewritten as Assertions.assertThat(utilities.getValueList(column)).isEmpty()
Parameter should be a string instead and be called label
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This fix is incorrect. It only caused the empty oplog (created by the offline compaction) is not deleted by the recovery's auto compaction. I modified the dunit test a little bit and proved it. Unfortunately, there's no flag or status to show that a compaction is just finished. Even we want to use the empty oplog created by offline compaction, we need to careful arrange the logic. Such as: change needsCompaction to return int. 1: need to compact, -1: no need to compact, 0: there's one empty file, only need to delete it. But maybe there's better ideas.
Braces on following line
Let's not catch NullPointers but do a check whether element is null before trying to get the attribute.
I don't think you need this new String
If this should never happen throw an IllegalArgumentException instead.
ChannelClosed needs to be added to (though not strictly necessary)
if we can avoid hardcoding strings here and [here](<LINK_0>, that would be great. Otherwise everything looks good to me.
I see what you mean, the link will refer to the ID, and if ID is integer, as opposed to the new UUID, then the link will be limited as new objects will not have old integer ID, but all objects will have uuid. To ensure compatibility, perhaps we would need to leave getLink to return the integerID, but getLinkUUID could use the new identifier. (this is because we don't otherwise have rest versioning, and don't want to break contracts).
suggestion return GitHubServerConfig.GITHUB_URL;
Existing code use null as the sentinel for this field, so I think you should keep using null here. suggestion this.apiUri = null;
I believe this whole catch block can be removed. The standard WaitUntil handling will be sufficient I believe.
Is it OK to swallow this entirely?
Avoid logging an error if there's already a throw.
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
You're passing into this method, as an argument, directly the return value of getObaBaseUrl(). That currently returns either String or null, leading to an occasional error or crash.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
please create a more specific exception that extends this one.
factor out
you could be more specific and check instance of Function0 maybe?
Can this happen ?
Clone method is wrong. Kernel/stride/padding are already handled in superclass clone. And it doesn't set depth multiplier.
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
Format this file using our code style.
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
this is confusing, it is called router but actually it is routerUrl.
Looks like you are making double slashes here...
style nit: we don't use braces around single line blocks
style nit: we don't use braces around single line blocks
What's the point of the 6 trailing zeros ?
Apply changes similar to setVisibility.
Simpler to apply the mask after the shift.
You need to calculate the righ margin to account for the width
A message might be helpful
this seems misnamed
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
you need call addColorSettingsListener on the new instance.
They are mutually exclusive? Or is that a micro optimization?
This thing does check the value for not being null. So the previous expression is redundant.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
Just in case, please wrap with Collections.unmodifiableCollection()
It would be better to not hand out a reference to the internal data structure. The TagName objects are immutable, but the collections are not.
return Collections.emptyList();
Define "data-agent-conf.xml" as a constant
duplicate regex as above, can we reuse it?
correct.
Did you intentionally ignore the patientProgram parameter?
?? why this and the following ones could be left empty?
We could throw an UnsupportedException here.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
Great idea! Can we use Locale.ROOT instead, though?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
log.trace if at all
log.tracef
Might be cleaner in terms of minimum visibility to just return the timestamp from the transaction task.
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
The cast is not needed
I think this should be done in the constructor rather than here - or at least, in the if-clause of this method. Otherwise we risk adding the instance as a listener multiple times for each getInstance call
can just be return pattern.matcher(value).matches();
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
can we move this method to Utils
Use logging framework instead of printing to stdout
assuming this was for debugging, should remove.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Should this be removed from here if this is already being updated in getValue?
I am confused b/w the description and implementation of filter here.
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
Oh, I see Well, I'm not against mentioning subscribe() as long as we don't just say to "set this error handler to avoid this exception" We can also mention onErrorXXX, might be a bit overwhelming tho
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
we never use NULL, it is a bad practice in general.
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
This can just be catch Exception.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Should we check for systemConfig.isOutdated() as well?
suggestion return Optional.ofNullable(getLhsType()).map(s -> s.getTypeImage() + ".").orElseGet(() -> Optional.ofNullable(getAmbiguousLhs()).map(s -> s.getName() + ".").orElse("")) + getImage();  and avoid computing the ambigousName unless necessary
Must be in format ID@ADDRESS
Just an FYI for future - You can use this method for this: <LINK_0>
An optional of not null is a bit painful. Use another constraint perhaps? Do we have one test on the payload business btw. (applying it to the wrapper)?
UnsupportedOperationException ?
The current style used for the method return annotation is to put it above the declaration. This also applies to all other usages in this PR. suggestion @NotNull public static IReferencePoint create(@NotNull Module module) {
Maybe wrap around a [CountDownLatch](<LINK_0> instead?
Would suggest to make it private.
Patametrrized logging please
Why this change?
I think it would be better to make drawing the border conditional on the line width.
public? And maybe put it next to the other setter.
This must be unique, as it is the ID jclouds will try to find when calling the computeService.getImage(id) method. Is this label unique?
shouldn't we do it only if getParameters().getSourceDomainId() is null or empty?
Why is it setting the SD to the Master SD? What if the disk used is not on the Master SD but on some other random SD? I think qemu-img will fail and so will the import.
Something like this.
Same here. Multiple places.
You may find many examples in the existing code base.
several style nits: spaces before {, before variable names, between functions, etc.
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
invert it
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
@andreoss Why throw Exception here instead of the original IOException?
Maybe IOException since it's supported here?
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Might this not cause extra copying of the buffer contents when transferring data between network and storage?
Just personal preference, for this, I would use java 8 style getOrDefault to make it a bit cleaner :) java _currentAssignments.getOrDefault(resource, Collections.emptySet());
Move this validation to PluginProfileService.
Move this validation to PluginProfileService.
That should be toHtmlForAnthology. You mixed those two up.
side note to bringing in this dep, installing this module would also likely start up a number of pollers/db connections/zk connections/etc which we don't want
Should you call analysisReady(false) here?
Missing call to super implementation of onResumeFragments()
LinkedHashMap please <LINK_0>
why silent catch?
ConfigurationException?
should be setSucceeded(true)
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
Doing this via double math is still 3x slower than return (nano + 1000) / 1000L;
same here - call the constructor with 4 args
Same here.. we should not have these checks here.
Here, we need to check value also along with key. A case like createBucket, DeleteBucket, we will have the key in the cache for that bucket, but with the value null. And also is this isExist will be called with the lock? As someone can modify the same key while checks are happening.
change "get(key)" to "redisSet"
Why is it public?
Can you add a check to see if the metadata is present (stream.hasMetadata()), if not create metadata?
@fabriciofx Here also, we could return the body() of our decorated object directly
Should return ReadOnlyArray.
Should return ReadOnlyDictionary.
personal preference (so up to you to take the suggestion into account) but I would go for :  if(cond) { return 1; } return 0;
ImageData for current image needs to be updated in the array?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
A List<String> would probably be simpler to use as return value
I would prefer to move this line in the if branch, so it is more clear, "return element" is done if a managed provider is available only
add(int, E)
We should not catch generic Exceptions. Can you make this more specific?
I think only one impassable entity should be allowed on a Square. Exception otherwise.
I foresee clashes here. Should at least use <type> + "/" + <name>
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
you have to add a canDoAction message if you fail canDoAction
return Optional<File>
For easier maintainability in the future, I suggest having curly braces for this if condition.
Program to interface, not to implementation - please change return type to Map<String, Object>
import that one as well, to make the code more readable, or prefix all with ConfigValues
Should this be putTransient because of IMap#putTransient?
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
Why are you calling setUp()? Is there a way to avoid this?
Alex, I don't think they can be merged. getLong is still missing in the code base. Committing this patch without test seems a bad idea to me.
there is Long.hashCode(long value) method.
Could you put this change to a separate PR?
bad hashcode.
can it be made in one line?
Please group mr, ms, and mrs together
Was the closing head at the end on purpose?
I think you want logical AND, so double ampersands. Can we use !license.isEmpty && !licenseShortName.isEmpty && !licenseUrl.isEmpty() instead?
Are we comparing InputEdge vs SourceInputConfig here?
Is it OK to assume that neither of these can be null? Couldn't a user easily create a ref entry which only has one of these defined? Perhaps you don't really support this case in the code, but perhaps it should be supported? I can easily see a project wanting to override one without overriding/specifying the other.
is logics correct here?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
ChannelClosed needs to be added to (though not strictly necessary)
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
Unsigned types are not used in the current implementation. So, you can omit them.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
Possible NPE here unless I am mistaken -- there may be no defaultValue.
Could throw IllegalArgumentException instead.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
Since this a string, safer to use StringUtils.isBlank
rename to child or childItem
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
suggestion list.setSourceList(new ArrayList<>());
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
This is just a quibble given that the entire thing is private and the class is tiny. Still we could separate the loading of the preference and turning it into a ScaleInterpolation from the side effect of updating the menu selection. On the other hand I guess this is never going to be pure function anyway given that it reads from mutable source (Preferences), but it still might be an improvement. Regardless, we should log the exception instead of just printing it there so it shows up in the log. Since it isn't critical it could just be at INFO priority I guess.
getItems().length > 0 implies menu.getItemCount() > 0, so menu.getItemCount check can be removed. getItems().length is not sufficent, it should be checked that any of these items is visible, e.g. Stream.of(getItems()).anyMatch(IContributionItem::isVisible)
should we use ObjectUtils.nullSafeEquals here as well?
It might be a tiny bit more readable to call this.sortFileSizeConditions as well. Ditto on line 359.
Good catch. Should be the same for initCond on the next line. It's a bit unnerving that this is not a compile-time error :( EDIT -- I checked with a structural search: Objects.equals($o1$, $o2$) with a constraint on o2's expression type java\.util\.Optional. This is the only occurrence.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
I still don't understand why the key cannot be the session id
Move this else if just after the } above
Have we tested this with a song that is currently being played
should call super.onClick() here?
If you'd like to get the String value of something and want it to be null friendly you could always try this:  java String s = String.valueOf(obj);  I believe String.valueOf(obj) looks like this under the hood:  java public static String valueOf(Object obj) { return (obj == null) ? "null" : obj.toString(); }  Applies file wide :neckbeard: #notadealbreaker
Delegate to isNonCodedDrug() when making the check.
Please use <br /> instead of <br>
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Why not override visitClass() method?
Is there any particular reason to call getMuteReason instead of just checking the value of muteReason directly?
constant?
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().
Why fromUnfiltered(), if you then filter anyway?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
can you explain why this change ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
This is a test for the userRepository in my opinion and should not be here.
no need for type cast
This line should be placed before the thrown.expect... calls, because the exception must be thrown by tempFolder.newFolder.
super() can be spared here.
Do we really need this? It's implicit
this("Safety Command")
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Don't initialize to empty when null.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Shouldn't this message be changed to "Should be 500"?
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
This doesn't look like a recoverable scenario, should you be re-throwing this one? Or is there some default/fallback VipAddressResolver if the instantiation fails here?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
Please group mr, ms, and mrs together
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
nit: param doesn't need final
Collectors.toList()?
Would return builder(SecurityLink.resolved(security)); be simpler?
I want to method accessor to be package private :eyes:
Please use the more compact one-line syntax:  java if (defaultUI == null) return;  for consistency with the other blocks of code in these here parts.
Also this: parent.syncScroll(DisplaySide.A); // match A's viewport
Add log.info "connecting to ATSD at host:port"
Why are we eating the exception here?
I think it's unnecessary, method is synchronized?
rename to comply java standard name convention. validateEmail
Avoid ByteSource in API. byte[] is ok here
format should default to "tar.gz" is null or empty and not throw an exception.
70-75: extract method (see following methods)
i would add additional check to make sure we will never make it to more then 100 :)
if the max stream tail moves, it calls prepareSiteRoleChange(), which call queryStreamTail() one more time, and will update totalNumEntriesToSend. Then it call queryEntriesToSend() again, will get a pretty close result as currentNumEntriesToSend. So percent calculation will always return a 0.
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
no need to say "public" here, it is always public in an interface. "static" is important though.
Given that there's at most 36 possibilities, it's probably best to cache the immutable version.
public?
I'm missing the new field in the toString method.
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Let's add a message here: "Checking if port XXXX is in use...".
Why is this still using the Id?
format should default to "tar.gz" is null or empty and not throw an exception.
Why is this still using the Id?
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
Just let the exception bubble up, otherwise it can be confusing to debug IOException ' s.
I would not print anything to stderr. I would suggest using a logger and use it in both cases (cleanMethod or invokeCleanerMethod)
rename
not all listener
maybe rename?
Should we return immutable list here?
@v-stepanov Is method marked as @Nullable ?
Is there a reason to create an ArrayList here instead of using Collections.emptyList() ?
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
This is a bug
This is wrong.
this should be config.get("path-style-access", boolean.class, false)
It is good to have a method to convert config.get(Config.TOPOLOGY_RELIABILITY_MODE) to enum and then compare two enum values. Comparing two Strings is error prone.
This code should use instead entrySet
This method should first attempt to get it's result from a file stub.
@ivandalbosco This method should be annotated withjavax.annotation.CheckForNull.
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
Please add ioe to the exception.
Please add ioe to the exception.
we should pull the ObjectMapper out as a static final and use Afterburner, to avoid thrashing and testing too much serDe  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().registerModule(new AfterburnerModule());
Ahhh, the speaking check is here. Calling speakNames() to have to sometimes not speak names is confusing and wastes a method call. I think we should just pass the boolean into presentation manager.
null != settings
I think the existing code is correct for the "jump" plot behavior - this should advance the plot as time marches on. Although this change would result in desired behavior for the non-changing historical data, it would result in incorrect behavior for live/streaming data. The issue comes from the fact that settings.getMaxTime() is returning system time in the first place. This makes sense as a reasonable default only in the absence of a time service, but should be overridden if a time service is available. Some care should be taken to ensure that only defaults are overridden in this manner (e.g. to avoid overriding when getMaxTime() is returning a persisted user-specified value.)
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
How is this changing how it used to work previously?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Static string constants
Could you please replace this boilerplate pattern with a single method registerSerde(String, Supplier<ComplexMetricSerde>) thoughout the code?
How did this happen?
Why create so much strings ? ", " + "JdbcRuntimeInfo: {" + "driverClassName:"
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Should have a space after add
Another space after add
binding -> bindings
I'm wondering why we even need this class; can we not simply add a boolean property to the base class called "appendPartitionId" ? Also, the ticket description says "If SingleFileOutputOperator is partitioned into **more than one** physical instances then it should append partitionId to file name" (my emphasis), I don't see any check for that condition before appending the partition id.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Remove this
Don't we normally do null checks in builder methods? Or are we happy to wait until build is called before blowing up?
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
My problem here is that the timeout is coming from another place (that will override this). I don't like properties coming from two places. I don't have the best answer but I don't think it's a good idea.
What is this test for?
As iirc a HC can not spontaneously become a DC, I wonder if we could cache this data. Otoh, this is a relatively light-weight call and not done often, so probably does not warrant the hassle of cache invalidation checks.
F.isEmpty()
What about skipping parenthesis, so that we still raise issue for the following: conn.setRequestProperty("Authorization", ("Basic " + encoding + encoding))
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
@tsurdilo take a look at org.jbpm.kie.services.impl.CommonUtils.getAuthenticatedUserRoles(IdentityProvider) that does some additional logic in case roles are empty list. There is an issue with some dbs handling empty list as part of in clause
getStorageDomain is the TARGET domain - you should get the SOURCE domain according to the storageDomainId parameter passed.
collect to a set that can preserve order?
I don't think it's necessary to create a set here since it accepts collections and then tries to figure out the fastest way to check them.
We should check whether the variant context in the output vcf is filtered. The output vcf in testDreamTumorNormal has one filtered site (20:38245275, alt_allele_in_normal) and it's counted as a false positive. This applies to calculateConcordance in HaplotypeCallerIntegrationTest also.
Once again, just use getMonth(calendar), which embeds the knowledge of the +1 difference in its body. DRY.
But existing rows use null not "" for the parentUuid.
Perhaps instead of using a boolean parameter we could either: - provide an enum with three values (TypeParamsNotSpecified, TypeParamsDerived, TypeParamsNotSpecified) - make this constructor private and expose two static factory methods
CheckReturnValue?
style: extra parentheses
we need good docs here
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Remote exception handling changed a bit, so I think you can make this more specific: if (throwable instance of RemoteException && throwable.getCause() instanceof RetryPrepareException).
I think you want isPossiblyOkHttpTimeoutBug(cause) otherwise it will SO.
Optional.map
Optional.map
You should pass here message not group converted to string.
remove
NPE if header missing.
How about to use here NamedParameterJdbcTemplate as you've done in the JdbcChannelMessageStore#doPollForMessage ?
Add here if (outlinePage != null) { outlinePage.setSelection(new StructuredSelection(selected)); } to make the normal outline page follow the selection in the quick outline.
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
boolean canExecute = false; if (selection != null) { canExecute = Iterables.all(selection, Predicates.instanceof( AbstractToolDescription.class)); } return canExcute;
Is there a subclass? I'd like to see these protected methods be private if possible.
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
I don't think you need to use 'mTimestamp' in the printout, the other internal variables (payload, kafkaKey) didn't do that either.
Should check if the Counterparty that should be updated belongs to the logged AppUser
A validation should be made to compare the oldCategory.getUser() to current authenticated user. Maybe...what do you think?
See UseCase.
Add not-null check here.
@aklish what do we expect if both initializer and injector are defined?
Maybe some not-null check should be added here.
Why change the name the property? Accident due to mass refactor/rename with IDE?
Translate this RuntimeException message in English please
space before {
Let's use the same logger we use for the rest of Baragon rather than System.out, for example <LINK_0>
nit, Collections.EMPTY_MAP?
what if the subExpr is empty ?
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
How about remove the property, rather than set it.
super.init() method never throw an exception.
immutable copy!
Should make sure the constructor and this method follow the same pattern around ensuring the internal values list isn't mutable. Right now the constructor will clone the list, effectively a deep clone based on how Strings work, ensuring it is immutable if the original list changes but this will return a reference to the internal list that could be mutated.
Can't this be further improved to just Arrays.asList(values)?
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Do same for this one
> new Date(mExpiresOn.getTime()) [](start = 15, length = 30) why are we returning a new object? #Closed
Better to return "";.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
You could probably use the same URL as in getResultById here.
Is it really filter name?
This should stay final
Should this method be final?
Currently we know that close doesn't throw, but just to make the code future proof we can use guava Closer here to make sure that both readers get closed.
If the first orchestrator throws an exception when closing, the second one will never get closed. Please use a closer instead; see org.hibernate.search.backend.elasticsearch.impl.ElasticsearchBackendImpl#close for an example.
Why not closer.register(...::close), as above?
lockRefreshToken should be set to Optional.empty() here, otherwise isHeld() will still return true. There should be a test for this.
This seems needlessly complex. You're using a boolean supplier to assertTrue. Why not just call doSomething() directly?
fyi, you can use @Factory method to replace the actually tested instance (its methods have to be annotated with @Test ofc)
We don't need this, the ConfigSaved would handle this already.
Typo
as a suggestion you could remove the followup NPE check and use Objects.requireNonNull suggestion org.eclipse.core.resources.IProject project = Objects.requireNonNull(getProject(referencePoint), "No project found for reference point: " + referencePoint);
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
Need to use parameterized logging instead of string concatenation.
Missing codes.
Is there a better solution to this? Maybe throw a new NoOpNameFoundException? It auto skips in the first place when you do that.
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
same here simply inline the attributes variable
if you do not need the variable to make assertions just inline it patientService.getDuplicatePatientsByAttributes(null);
The binding shouldn't refer to the currently selected entry because this might change in the future and then the binding needs to be reevaluated. The following should work suggestion ObjectBinding<BibEntry> entry = Bindings.valueAt(selectedEntries, 0); return Bindings.createBooleanBinding(() -> { if (entry.get() == null) return false; else return entry.get().getFields().stream().anyMatch(fields::contains); }, entry, entry.getFieldsObserable());
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
does queryNextPage need the query string again?
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
you can directly put .commit() at the end of this. Editor calls always return the Editor again ;)
java @Override protected void setUp() throws Exception { super.setUp();
We are always in a case of an AbstractDiagramElementContainerEditPart host here?
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
rename fileInfo to ledgerInfo
EchoParametersDao.getEchoParameters() already returns a list.
this variable may make more sense just as itag given it isn't only for items.
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
We can use guava Closer to make sure we close all of these clients (just in case if one of them throws a runtime exception in the middle of the loop)
rename to breakpointRequest
can't foreach be used here?
This might throw exception
make this private and move it after public constructor
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
I know this is not introduced in this PR, but could we consider not allocating the buffer multiple times (here we would allocate three times, each in different levels of the object's serialize() function).
if you want to be Really Fancy, you could rewrite this as:  java final Optional<TimeZoneHistory> timeZone = this.timeZoneHistoryDAODynamoDB.getCurrentTimeZone(accountId); final Optional<DateTime> nowForUser = timeZone.transform(new Function<? super TimeZoneHistory, DateTime>() { @Override public DateTime apply(TimeZoneHistory history) { return DateTime.now(DateTimeZone.UTC) .plusMillis(history.offsetMillis) .withTimeAtStartOfDay(); } }); return nowForUser.or(new Supplier<? extends DateTime>() { @Override public DateTime get() { return DateTime.now(DateTimeZone.UTC).withTimeAtStartOfDay(); } });
Does it still make sense to use forkJoinPool? The tiles are no longer downloaded at this point, so it would add an overhead to run this in parallel.
Could you check for null or empty? Via StringUtils.isBlank
Why do we need this constructor? It doesn't use the 2nd parameter...
What you should be sending is the cluster compatibility version, not a constant version.. You could send the host's version but that would be confusing to the users. The norm in oVirt is to restrict version specific features by either cluster or DC - since this is clearly related to cluster (and not related to storage), the restriction should be by cluster level.
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
when can it be null?
Lists obtained from a message are immutable. No need for extra copying.
Maybe unmodifiable
does this have to be a list or can it be an iterable?
I don't see where we handle HibernernateException.
it would be nice if we could instead use a class called Wait, that would keep trying until a certain condition was reached in the server. This type of sleep will certainly eventually fail. i'm looking for a case where the test always pass.. with this we will still have eventually a failure.
I think we should add this datum to the frame and confirm that the session also successfully moves on (just to ensure the end-to-end is also still working)
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
From the code it appears that 'nulls' may be in the Iterable<TokenCacheItem> returned. Because we create the collection as ArrayList<TokenCacheItem> tokens = new ArrayList<TokenCacheItem>(results.values().size()); If decrypt fails, we will not add the tokenCacheItem.
we never use NULL, it is a bad practice in general.
suggestion return new SearchHitsImpl<String>(hits.size(), TotalHitsRelation.EQUAL_TO, 0, "1234", hits, null);
nit, Collections.EMPTY_MAP?
- s/userPassCollection/userPass - s/userPass/userAndPassword - s/lastIndex/atPos - s/firstIndex/colonPos  for (String userPass : userPasses) { int atPos = userPass.lastIndexOf('@'); checkArgument(atPos > 0, "Invalid Credential format. Requires user:password@collection"); String userAndPassword = userPass.substring(0, atPos); String collection = userPass.substring(atPos + 1); int colonPos = userAndPassword.indexOf(':'); checkArgument(colonPos > 0, "Invalid Credential format. Requires user:password@collection"); String user = userAndPassword.substring(0, colonPos); String password = userAndPassword.substring(colonPos + 1); builder.add(createCredential(user, collection, password.toCharArray())); }
Could use assertEquals?
maybe also add?:  java mapper.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, false);
Does this need to be a perpetual change or is it bound by this method? If it is the latter, I'd reset the context classloader to its original value in a finally block in this method.
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Shouldn't this be set to false?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
No, this. when you call methods.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
We shall trim at the final values level but not the above layers. What do you think?
Consider returning a constant
Fair enough. I don't think it was meant as a cost saving thing, just to make it easier to understand when something did or did not have caught-up clients. If you find this logic easier to follow, go for it
suggestion private MockClientState getMockClientWithPreviousCaughtUpTasks(final Set<TaskId> statefulActiveTasks) {
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
should be VOT.Storage
this should be the disk id, not the image id
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
No need for the *31 here.
bad hashcode.
static
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
this can be done with a stream, filter & collect so it'd look something like this return film.getPeople().stream() .filter(crewMember -> crewMember.publisher() != Publisher.RADIO_TIMES) .collect(MoreCollectors.toImmutableList);
This should probably be private.
You can use CollectionUtils.toImmutableList
this.
This variable name is misleading. These bounds are _not_ verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).
Couple more static imports here?
Another static import?
Statics
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Immutable fileinfo
Better to return "";.
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
public?
I'm missing the new field in the toString method.
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
This is the wrong method to update, replace the one that was called here. For a global check if the patch was successful check for references like registerDeploymentPlan, instantiate, they should we restricted to the EntityManagementUtils class only (outside of camp projects).
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Can StringUtils.fromUtf8 be used?
@nielsbasjes Is making this method public really necessary? Do we need to expose this method in the public APIs? Can't it be package private?
final float sleepDuration = (int) ((double)  feels odd.
Methods in Preconditions should be imported statically
This can be removed.
Do you think we can use an [unmodifiable map](<LINK_0> here?
StringPool.EMPTY instead
I think there is some findbugs issue with not using {} not sure.
Generic type not used, remove.
Why are you looping here? Can you give a use-case?
Should we return true at some point? It looks like the old code could.
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
Do we really want to always assume Latin-1?
Could just use Arrays.fill(max_byte_arr, (byte) 0xff); here
please remove TODO and printStackTrace() and use proper logging instead
Why don't we make inDegrees to ConcurrentHashMap also?
On second thought, adding a isEmpty method in BibEntry might lead to more readable code.
Why is no this. used in lines 320-321 but this. used in lines 322-326?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
A for each loop on the listeners can be used here instead.
should this count be parameterized?
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
you can use IStructuredViewer::getStructuredSelection
remove assertion and change ISelection to IStructuredSelection
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
The cause should really have an abstract method for this instead. And return EnumCause rather than Enum<EnumCause> from its method.
Return this enum from the Target instance.
This should be part of the try-with-resources block.
This is ok but can be made more compact: java try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()))) {
we can use try-with-resources statement and avoid the finally clause
Item dropped should be a hopper
my guess is that this should be: return receivedStatus[0] == statusCode[0] && receivedStatus[1] == statusCode[1];
this for is exactly the same in all the array tests, let's move it to a private method
is this still needed?
This will throw redundancy warnings in IntelliJ
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
The this. in getters are unnecessary too.
public @Nullable String...
Why do we return the parents name instead of the name we store a few lines above?
assertTrue or assertFalse but never equals. Also add a message so if it fails you know what has failed.
When using suggestion Assert.assertThat(testRealmResource().users().search("a", true), Matchers.hasSize(0)); Assert.assertThat(testRealmResource().users().search("apollo", true), Matchers.hasSize(1)); Assert.assertThat(testRealmResource().users().search("tbrady", true), Matchers.hasSize(1));  the output on failure shows the search results which is better for debugging potential failures.
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Missing types
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
you should probably check Item.Configure here
Single or double pipe?
I think a compare between capacity and maxPageBytes is still reasonable here - even through the capacity > maxPageBytes is always true here. Because we cannot ensure the private HeaderChannelBuffer constructor is always called in create. Maybe it will be called somewhere else someday? A compare here may seem redundant now but will decouple the private constructor and the create
Might be nice to list valid dio pins out in the message?
Can we make logger a private static final
You don't need to save an ObjectReader; you can call readValue directly on the ObjectMapper.
nit: Suggest renaming iterations and its getter as well here
what does compare and hascode mean for datanode if they have different ssl ports?
how could contributions be null? Create it at the field level if you want. It should also be final. There are minor style violations in this file, no spaces around operators
This can never be null given the code in setData above?
why this change?
I think the current state of the art is to do something like: int hc = key.hashCode(); hc *= 31; hc += value.hashCode(); return hc; But actually for an attribute there aren't too many that can can be multi-valued, are there? So just using the key's hashCode as our own hashCode might be sufficient here.
this client side GWT compiled classes needs a sort of sanitized hashCode implementaiton using our utility class HashUtils. Should look something like this @Override public int hashCode() { return HashUtil.combineHashCodes(super.hashCode(), executionSet.hashCode()); }
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
Since this method process any type of attributes, exception text is misleading. You can get eg. facility attributes with non-null value from all facilities specified by attribute definition.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
type might not always be a Class. If the API method returns List<User> this will be a ParamterizedType which isn't not a Class.
space after ,
It's not a good design pattern to close resource-parameters in methods. There are the following converntions (which may violated in certain cases) - If you pass in a resource, the caller is responsible to close it - If you wrap a stream (e.g. new BufferedInputStream(is)), closing the outer stream will close also the inner. You should fix that resource leak at the caller side, there is only one in io.ebean.config.properties.Loader: java void loadYaml(String resourcePath, Source source) { if (yamlLoader != null) { try (InputStream is = resource(resourcePath, source)) { yamlLoader.load(is); } catch (Exception e) { log.warn("Failed to read yml from:" + resourcePath, e); } } }
should be debug and consider moving logging to checkData()
Could be written on one line RemoteService.getRemoteService().doRemoteFunction(value)
we don't need to change the Creation classes.
please keep style changes separate from PRs (or better just don't create them at all)
Should reset the values in the config file too?
Alternatively you could have a static constant Set<String> and do a contains(). It would go nicely when we can use a Set.of.
Please extract this string
It'd be safer to put EXTRA_SUBJECT only if !TextUtils.isEmpty(subject)
I would try to reduce the code duplication by something like that  final Class... activity; if (PreferencesHelper.getCreateAccountStatus() == CreateAccountStatus.WAITING_FOR_SMS) { activity = VerifyNumberActivity.class; } else { activity = AgreeActivity.class; } startActivity(new Intent(this, activity).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP));
static imports
static imports
In general we use == to compare classes (Cf. *AdapterFactory implementations for example)
does this have to be a list or can it be an iterable?
why public?
What about :  names = new ArrayList<>(attributes.keySet());
innerInterfaceOrClass checks parentType, but in line 236 similar check is performed. They can be merged in one method
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Please split this if into two and revert else if. The condition will be easy to read. Or, the whole condition can be inverted: java final DetailAST parametersNode = ast.findFirstToken(TokenTypes.PARAMETERS); if (parametersNode != null) { TokenUtil.forEachChild(parametersNode, TokenTypes.PARAMETER_DEF, super::visitToken); } else if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) { super.visitToken(ast); }
createObjectFromMap(name, NAME_TO_FULL_MODULE_NAME); should be the first thing we try. It will be the fastest and the most common scenario. pure createObject(name) should probably be used last when user supplies full package as name. Order of finding module should be, imo: 1) our module map test 2) 3rd party map test 3) full package (or raw) test 4) fail. We can probably discuss skipping 1-2 if given name has a period in it. 3 is only really needed if we don't examine maps for the full package. I don't really see a benefit from doing this.
just return "" instead of new String()
This check is useless as the customParams can never be null.
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
please inject the DAO
try to consolidate with the previous method
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
nit: s/upload/upload ID/ I was thinking of consistent log keywords so taht for any retry log we can search "upload ID" or "commit ID"
extension can't be empty or /
extension.toString()
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
I understand the purpose of the change is to make sure we streamline the value change in the class variables to happen as late in time as possible, and issue the notifyDatSetChanged() signal right after that. Can we then enclose these 3 below lines in a synchronized block to make sure these 3 are packed together in an atomic action?
Should this be as in OzaBag?  @Override protected Measurement[] getModelMeasurementsImpl() { return new Measurement[]{new Measurement("ensemble size", this.ensemble != null ? this.ensemble.length : 0)}; } @Override public Classifier[] getSubClassifiers() { return this.ensemble.clone(); }
needs US-ASCII charset, or some other simple ascii encoding conversion
use 'waitForElementByElement(newestVideoDeleteIcon); and use 'waitForElementByElement(deleteConfirmButton); before each click
this method suppose to return instance of DiffPagePageObject class, because its redirecting to diff page beginning of the method should be: public DiffPagePageObject goToDiffPageFromHistoryPage() and last step should return new object: return new DiffPagePageObject(driver);
log () here and after
Are there mandatory parameters which require validation?
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
This won't invoke the additional interceptors, is that okay?
you could invert the if to avoid negate the condition.
Wouldn't Arrays.asList() be enough here? Arrays.stream seems to have a lot of memory overhead.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
the instanceof check includes a null check
Compare with null not necessary since null instanceof FileModelSource is false
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
Check if there is an appropriate constant for "no metakeys" mask.
I believe it should be replaced with produceCalled = false. Could you modify your pull request? Thanks for noticing!
Why don't we make inDegrees to ConcurrentHashMap also?
Why is no this. used in lines 320-321 but this. used in lines 322-326?
0 is a legitimate option value for min. selectable choices. Why not -1?
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
IMO, return (int) Math.min(size, Integer.MAX_VALUE); looks better (as you did above)
In other places we use java.util.Math.toIntExact(long).
I think it makes sense to use builder and return ImmutableSet...
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures
Use Logger instead of System.out.println
Reads nicely if this is written as if (isBinaryValueAvailable()) {.
this.sourceType
throw -> failure or exception?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Should this use RANDOM_PORT_INDICATOR instead of 0?
Please keep this.cell near the related fields (previousFamily & cell count) below
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
we can replace all these with getTxBuilder()
Why an event ID is built around project UUID?
nit: I'd prefer warn, this is probably not super actionable for us?
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
is there no common place (at the broker level) we can add the unioning query runner?
Why not create the taskExecutionDAoFactoryBean in the ctor?
Should pass parameters along instead of doing null checks.
Instead of making it a singleton, why not create the connector in setUp?
if we continue with this convention, please init to true also here
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
You probably want checkNotNull here - assertNotNull is no op if assertions are disabled resulting in a NPE below, checkNotNull will always fail on null leading to a consistent error message.
This bit of code needs the same treatment as lines 120-122 I think. If the evidence type is PasswordGuessEvidence, then return the result of getCredentialAcquireSupport for any algorithm (pass in null for the third argument).
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
can be replaced by List.of
Collections.addAll saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.
Please use Collections.addAll(Collection<? super T>, T...) instead.
why not an empty map?
@ILikeToNguyen Why the change in visibility here?
You can use Map.of
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
the if and else clauses here will both result in the same behavior below
I think you can remove the surrounding if, it's quite safe :]
Before go through the loop make sure that position and symbol parameters are not null.
Extract this into method getTotalSellAmount. The refactoring tool can do it automatically. Code smell Overly long function
needs to be named something more relevant like market
What does the magic number 2 mean?
Do you have unit tests? Again you need to use equals
Did you take a look at HibernateDiagnosisDAO? The service layer will delegate to the data access layer which fetches directly filtered data from the database instead of fetch it all and then filter in the application memory.
name it github config
If you get something like an InterruptedException, this will just catch it and move on.
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
Idem this could be handled with an Optional...
If we are changing this code, then relying on Optional could be a good move.
If we are changing this code, then relying on Optional could be a good move.
Wouldn't this test be more "accurate" if the only thing that changed in each entry was the timestamp (and not the value)?
exists is statically imported.
Unlike other tests, this test does not compose the chain using expected.
Call I18N.getString(String) (there are no parameters in the resource messages).
Can we use url building here, to avoid problems with / at the end of the server.
this is confusing, it is called router but actually it is routerUrl.
This logic needs updating to handle non-deterministic filters. See latest BooleanSelectiveStreamReader.
use filter.orElse(null) with requireNonNull this.filter = requireNonNull(filter, "filter is null").orElse(null);
Maybe add a requireNonNull for filter and outputType. Missed that before.
I think the annotations should be on separate lines
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
Same backward compatibility concern as in EC2AbstractSlave.
remove static
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
Looks like this function is never used. Do we need at for this feature?
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Imagine we have 2 KIE Servers. None of them are up and running when we do the first round of client creation. So they both fall back to async creation. First KIE Server client creation then succeeds and it then forbids the scheduling of next possible tasks for other KIE Servers. I think we should just cancel the periodic task just for the KIE Server which we were able to connect to. So we should hold all tasks in a separate collection. Moreover, after the last task is removed, we can shut down the executor service.
I believe this line is incorrect and should be removed
This will only work if Jenkins is running on the same host as the docker daemon. It won't work in the general case where Jenkins is on a separate host from the docker hosts/swarms that it's talking to.
It seems cleaner to make this private, and add 2 static constructors: ServerFrontEnd.udp(adapter, port) ServerFrontEnd.tcp(adapter, port)
hasAnnotatedAllParameters is already checked in the super class, right?
I tend to prefer passing different values/mocks for different parameters so you can verify the correct parameters are used on your assertion below (who's to say the implementation of scrollHelper.scrollTo(e1, e2) does not swap the parameters around!? You'd never know from this test.
What if extended SherlockActivity contains android MenuItem or vice versa? I haven't tried, but it seems that the user will get an error in generated folder.
you can either remove else or add pair of curly brackets
why this double usage of URL? Wouldnt be using URI instead of URL be fully sufficient? (URL is known to have severe flaws and should be avoided if possible)
As per bug 487713#c11, the previous revision used to return the path in case of IOException. Do you think it makes sense to add that return statement?
Is there a chance of a NPE? could be getFile() null?
Looking at the usages better throw in this case.
We need to keep the throw exception as we are not changing the existing behavior
@dmzaytsev let's inline this
Maybe expectThrowable for consistency?
Although your change enables editing the right-hand side if the left-hand side is read-only, the changes on the right-hand side still won't be saved; I assume you need to modify the check here too: (isLeft && getCompareConfiguration().isLeftEditable() || !isLeft && getCompareConfiguration().isRightEditable())
Add { and }.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
I can't believe I let this line of code get in. Terrible.
Debugging code?
The system properties that we access from Java (as opposed to Maven-only) usually start with infinispan.test
just return ListeningExecutorService
same here for node
as above for cache
super nit: make string task a public final variable.
return id;
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
JDT uses compact assignement, e.g. i= 3;
Should be added the Override annotation.
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
Maybe take the opportunity to set index = null here?
If storageManager gets a value in constructor, then we don't need to check null.
cannot be null.
Same as above: I think it is clear enough without the id variable same for below too
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
I think can just use the @FindBy defined at the top instead of findElement() againt
I think it will be better to close the other store as well.
Could you please add a null check and isClosed() check (if available)?
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
Check command and status null.
Check if address is null.
Not sure if we want to print out the exception.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
suggestion return new BridgePath(virtualFile.parent(), fileSystem);
we could prevent this if the color is "white"
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
check if getters1 is null and remove firstTimeStream
Style issue: @Override shuld be on line above the method declaration
null != settings
A check for settings.getConstructorArgs() != null is not required if we check that null can't be passed to MockSetting.useConstructor(Object ...args) as described above.
return settings == null || settings.isChatColours()?
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Please check that the data buffer has at least 2 bytes to avoid a NPE.
why is this necessary?
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
this.
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Move the intent instantiation code inside the else branch, as it is not needed otherwise
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
Should be here ac.stateChangingCheck(); @zlamalp?
List<User> -> List<Facility>
Please change the return type of the method to Long: suggestion public Long call(ApiCaller ac, Deserializer parms) throws PerunException {
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
how do we utilize timeout?
why this is in vmCommand? should be in stopBase command
@Before / @After could overwrite System.out :-P
When the view is closed you need to stop the build thread
Will need a @since tag.
Which type would be assigned in this case?
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Then should we just use it to save the update items?
You could just use Closeables2.closeQuietly(azureBlob);
Remove by dn/key.
Let's keep it as it is for the being.
The original version is more precise?
[If a player is targetable becuase VANISH_PREVENTS_TARGETING is false](<LINK_0>, should spawning also be unaffected?
are you still creating new contexts here?
reference equality?
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
I guess you forgot "other." prefix
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I am not following here - why do we want this in sync block?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
The %2$s is positional and needs to be adjusted since payload type moved from position 2 to position 4. Or, alternatively keep this the same, but move getQuoteString to the end and use %3$send%3$s above rather than %send%s.
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
alias is count but the function is sum
should atleast check o being non-null and instanceof IdentityExtractionFn .
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
Can we please add limit to the exception message? So it will be much easier to see the problem!
Use checkArgument instead to throw an IllegalArgumentException?
We don't need to cast to int.
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
Maybe we can improve the message further by checking if null == operation and show a different message in case it is. Something generic (like Unable to complete operation on "event-type-name" + reason. What do you think?
@NielsCharlier this is a strange idiom. Does your intent differ from !resource.path().isEmpty()? Can resource.path() return null?
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
As discussed; are there character or length limits on the string returned? Also, although nothing wrong here, these are fairly structured strings. The first is a fully qualified class name and the second and third are uuids. Such there is opportunity for a simpler format; e.g. "%s|%s|%s"
nit: maybe merge the lines as the formatting looks a bit strange.
This is a bit weak when it comes to IPv6 addresses, as it assumes "hostname" is properly enclosed in [ ].
I guess we can use the following instead of both lines? suggestion ensureNotEmpty("hostName", hostname);
@inverno Why public?
Only null check here, so empty string will go through. Shouldn't we check for blank strings ?
Given there is no caching going on and lazyEntriesView is not exposed externally anyways would it make more sense to remove lazyEntriesView all together and just do lazyEntries.keySet() (with the remainder of the line being as it currently is).
can we use sysprop or something for url?
version is protected. I don't think we need to access it via its accessor
options -> version
use Long.valueOf() instead of new Long() - always for performance reasons
456L
use 'L'
Is start check needed? Could it be problematic (somehow delay/miss the start when it should be immediate)?
Would it not be enough to only catch MergeException here?
Can this be private, or is there another use case for default attribute outside the builder's call?
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
This should be package scoped, not public.
Did you test the response == null branch? I believe login returns either error or a valid access token, never a null response.
Why we return AsyncClient here?
Don't we have to say that this is uniqueId JDBC?
- log warning that option is not supported by SNMP
Not sure about coding style, but I wouldn't use an else here ("else after return").
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
By convention, files in Jenkins home indicate what they were based on class names. Maybe jenkins.install.InstallUtil.lastExecVersion?
Nit: it is a good practice not to reassign the input parameters so I would change this to something like the following: Map<String, String> mapToUse = (map == null) ? emptyMap() : map; JSONObject pathPartMap = new JSONObject(mapToUse);
you can use  return CollectionUtils.map("inode",contentlet.getInode(),"languageId",contentlet.getLanguageId()+"");
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
How about AM's memory mentioned at Line 111?
shardSpecFactory -> partialShardSpec. Lombok would be nice and hide all of this away :)
should this have a ,  to match the rest of the pattern?
the idea of using a builder is a bit off here :-)
I am not sure the changes here improve the situation. It would probably be best to change this into a String.format(...) call... or at least to format the code to remove the many line breaks.
one param per line; leave the first line empty
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
These should change to store the names in the attributes map so that you don't need special handling for all the places that handle the tags.
@weisebrazil all indentations should be 4 spaces, not 8.
It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look
it's more natural to use String.format() here
If environment accepts null, mark it as <code>@CheckForNull</code>
Maintenance of the map will be simpler than that of the list
Is this first else-if dead code? It seems to have the same condition as the initial if() statement.
Create date once and use it twice. That way the acceptance time will be the same for both.
Matchers.is
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
From reading this line I'd expect this test to pass. We should probably name this CONFIG_WITH_KEYSPACE_2, or make CONFIG_WITH_KEYSPACE receive KEYSPACE and compare it to KEYSPACE_2.
Nit: Make "content" a constant?
I wish there is a good place to have these convertor util methods so that it's more discoverable. Not sure, may be as static in GsonJsonSerializer type, just a thought.
no braces around single line block
oops, I missed to merge with Stefans fix for annotated tags (calling getPeeledObjectID()). I'll add that again.
It shouldn't be public
Let's do return fDetailedLoad; even if it is always null for now
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
Since we are changing I think it is better to use Collections.emptySet(). Like in fromMappingPrism
using compareAndSet() might be better since you need not execute the rest of the statements if this is already false, right?
I would guess that the work queue itself listens to the stop event and cancels the tasks. But this would have to be verified.
what happens if the future is already completed?
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
Check if byte[] b is null.
what about location ? we do not need LocationSerializer ?
this is redundant
Will this have any effect to legacy data (i.e. those existing before this PR)?
Used to be fileSystem.deleteFileOrThrow underneath.
there is no case in which httpClient become null, right ?
the second parameter can be removed
Shouldn't we call removePropertyChangeListener, BEFORE we call doEdit, since doEdit will change the current object?
isn't it true by default?
Please have result variable.
I think we should at least log this exception here before throwing other one
log.trace if at all
log.tracef
I believe this method should be getServerMetricConf()
I would prefer not to use null ... just a empty set and then assert that its not null
Please extract some values to make this more readable.
This is a local variable, should be camelCase not fCamelCase
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet header (incorrectly).
I think 28 bytes have been read into the packet header (incorrectly...), so it will read too far into the next block?
Sort of believe We should have MetricManager in parameter given this case.
can we avoid this null check and instantiate it on fields directly (+private constructor if we don't want to create it in any other way) - it's potential race condition if we need that for tests we could have it package scoped reset method
sync
log message is about "attach" in the "detach" method. this is misleading.
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems duplicate code. We can also put the exception throwing into checkIfPathBelongsToZkRealm or validateZkRealmPath() so we don't have to have the duplicate exception throwing in each method. Update: Maybe I would just wrap this into a method getZkClient(path) and put this check logic in it. So just getZkClient(path).operation()
This is duplicated
make it final
To be super clear, wdyt about renaming mTryAgainButton to better match its new functionality?
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Please remove extra line
I never knew you can do typeof(...) although it's a little misleading because typeof is not a function, it's an operand, adding () makes it look like it's a function. How about triple =?
Why include the name in the comparison? fullName should be enough.
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
Check if byte[] b is null.
style-nit: avoid braces for simple constructs
could use writeInt(Float.floatToIntBits(v)) to avoid code duplication.
SHOW+DATABASES? looks strange.....
formatting
viewers > 0 implies page is non-null
Same as above, this looks like an error.
I don't think the process deploy should fail in the case of temp file deletion fail
You can safely remove the file.exists()(implicitly done by isFile
targetValues is a List<String> so we don't need to use toString. Could use String.join(", ", targetValues) instead.
suggestion return Arrays.toString(value);
Please use - StringUtils.join(Entities.objectNames(networks), ", ")
events can't be null
please use {}
Why are these probably incorrect?
Would you mind if we kept our privates on bottom? I'm a class client (reader) of more code than I author, which means the most relevant source is almost always the public API. It's quicker to get to on top since codes read from top to bottom.
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
we don't need to change the Creation classes.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
- log warning that option is not supported by SNMP
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
should be edit
why add?
Similar to start, stop, etc. I think the name of the action enum can be more generic (VAR__ACTION__ENABLE)
why don't you just use a node here that does the right thing? There should a node to read outer, no need to duplicate that logic here, or is it somehow special?
To avoid confusion, rename the variable to sessionId.
entry
RuntimeException would be sufficient
RuntimeException will be sufficient
Should the scanner be closed after the call ?
This change could break people.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
public isn't needed
simpler:  return (this.partitionSelectorClass == null) || (this.partitionSelectorExpression == null);
The operator should be && not ||
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
suggestion return new PgClassTable.Entry( OidHash.relationOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name(), info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
i would add additional check to make sure we will never make it to more then 100 :)
@decarbonization: i think this should be Math.round(0.25f * temperatureScore + 0.25f * humidityScore + 0.50f * soundScore) coz right now Math.round(0.25f * 90) + Math.round(0.25f * 90) + Math.round(0.50f * 90) returns 91
Under what circumstances (given the validation you do) could index.equals(indexInterpolated) be true?
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Should this constructor one just delegate to the new one with Function.identity()?
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
Why U don't want to consider id in equals and hashCode ?
Please remove the unused method.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
Do we need this else block?
We don't need to cast to int.
checkState
Can remove the first clause if you change maxWriteSize to Integer.MAX_VALUE
DoubleMath.isMathematicalInteger?
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
final field to it's computed once and for all, as most values should be constants
Should be public.
Should be public.
Should be public.
In fact, I don't think it's a good idea to allocate a Long. This function should be fast. Thus, a three branch if seems to be the solution. if (a < b) ... else if (a > b) ... else ... The domain trick works to avoid the "sign" hack.
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
Add parens on (value - 1)
throw exception
Please don't catch general Exception class, this could catch also exceptions that we don't want to be catched. E.g. NullPointerException.
Is it done by a purpose that error thrown by activityDao.findExpired will prevent launching checkActivityRecordValidity ?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
can you call it first, just for consistency..
This can be simplified to model.getCommands().addAll(uiCommands).
System.out.format instead?
Symmetry (throw)?
can these parameters be grouped into smaller and more meaningful objects?
true=>false
There is no point of having separate variable. Why not to use it directly in method call or even hard code it in pollWhileWaitingForTaskCompletion.
may want to externalise to constants..in a separate patch maybe? call it GEOREP_ROOT_USER or similar
I don't think we ever use this method again
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Move both to variables for consistency.
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
Use a builder method from TestNG Collections
we don't use braces around single line blocks
@paulodamaso the braces and return are not needed here
@fanifieiev the same above.
@super132 please use Collections.emptyList()
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
for write and getActiveMessageFields, you can check if the lists are null OR if their length is 0. If either of those cases, don't write/read them.
At a high level this is what I meant.  java // member variable AtomicBoolean shouldRotate = new AtomicBoolean(); ... In the TimerTask shouldRotate.set(true); in save() if(shouldRotate.get() == true) { // do the file rotation ... shouldRotate.set(false); }
public?
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
I'm missing the new field in the toString method.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
Null comparisons can be replaced by UtilMethods.isSet(object)
All actions from
cannot **be** empty
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
"else if" maybe?
Same as above. this is deprecated and should no longer be used.
This is deprecated, we should use MoreObjects.ToStringHelper(this) instead.
Should just be dimensionId, ToStringHelper automatically formats and uppercase keys look odd.
reuse getAcceptableTokens()
I am a bit confused that this check will be called on almost every line of code.
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
Why is this needed?
input and expected output should be copied to test's input folder.
Use getSimpleName instead?
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Are "hdHardInMB=" and "hdSoftInMB=" still correct here, then?
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
<LINK_0>
projectExplorer.waitAndSelectItem(PROJECT_NAME); projectExplorer.openItemByPath(PROJECT_NAME); projectExplorer.openItemByPath(PATH_TO_GO_FILE);  Can be changed to "ProjectExplorer#expandPathInProjectExplorerAndOpenFile(String path, String fileName)"
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?
seeing this, I am a little worried that these checks are not always at the same abstraction level in the code. Why is it checked here at the level of the callee, instead of the caller as for instance in the Actor class? Not sure which version is better, also because I don't know how many callers these methods have. But, would be good if it is done somehow uniformly, if possible/sensible.
Hum seems we are already setting this listener
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
nit: you can merge both lines above as checkNotNull will return the given argument
As for me, brokerConfig variable name would be simpler here
I generally don't have an issue wit bitshifts when they are actually useful but here it only obfuscates the code for people who don't know much about them
What do you guys think about setting this method to Evolving, at least for one release.
Can we weaken the signature to throws Exception?
...this change really doesn't make sense. > Changed off screen limit for unlocks to 1(on unlock it was 2 and once activity open it would report usage of all 3 fragments, so to add little more accuracy I moved to 1 off screen as on SoldierStats) Are you really considering to give the user a WORSE experience, just so that we can get a bit more accurate analytics? I for one would rather get analytics with a known misrepresentation (all three fragments) than a random misreprentation. Example in your current implementation: 1. User opens unlocks 1.1. Fragment A and B are downloaded (A=1,B=1) 2. User scrolls to fragment B 2.1. Fragment C is downloaded (A=1, B=1, C=1) 3. User scrolls to fragment C 3.1. Fragment A is cleared (A=1, B=1, C=1) 4. User scrolls to fragment B 4.1. Fragment A is downloaded (A=2, B=1, C=1) 5. User scrolls to fragment C because he forgot something 5.1. Fragment A is unloaded (A=2, B=1, C=1) 6. User scrolls to fragment B again 6.1. Fragment A is downloaded again, third time now (A=3, B=1, C=1) So, basically, what that would generate would be... three hits for A, one for B and one for C. How is that more accurate? If we load all fragments at the same time, we get one for each, which is a more viable representation. I'm just trying to make sure that we don't do stuff that makes the app worse for the users (and the experience). For example, I would rather look into if we can use the ViewPager "hooks" and send a "trigger" once we switch to a given fragment. That way, if we go from A -> B -> C -> B -> C, we'll instead notice that the user used fragment B and C twice, and A once. This seems both possible and more useful to me, instead of causing people to re-download information just because we're doing it wrong. :+1: @peter-budo
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
I know its not your line, but please remove "driver" parameter. This parameter is not needed here, because screenshot is not needed in verification methods.
why is there "waitForCongratulationsLightBox " in PageObjectLogging.log, if you don't wait for lightbox? Maybe it should be waitForElementByElement method or in PageObjectLogging.log method should be "closeNewWikiCongratulationsLightBox" and "Congratulations lightbox closed".
IMO it's better to use different values, e.g. 0 and 1 to be sure, for example, that the "delegated" method is not simply using the first parameter twice...
If your initial value is Double.MAX_VALUE, then this reset must be the same
I know you didn't add this, but it would be great if you could change throws Exception to throws TriangleException as it's usually best to be as specific as you can :)
use execute i mentioned above
replace (String) js.executeScript(script) with js.executeScript(script).toString()
use js.execute(script).toString()
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Two "parallel"?
let's call it updateCodeMinings() instead.
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
Will this inject all instances of Task on the classpath?
Clarify doc. Returns a proxy not a real result set, and throws NPE if not initialized.
Why do we print a secret systemUserPassword here?
Oh yuck. ;)
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
StringUtils.isBlank(nodeId)
Style-nit: We avoid curly braces on single statements.
Item dropped should be a hopper
Change this to == and I'll merge it.
The default should be updated to return 8 parameters to the test
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
but if the feature is unchangeable, then the user cannot do anything about it, so it should be set to readonly, or am I misunderstanding the unchangeable feature?
should be setSucceeded(true)
Why do we use iterators? I know the base class does, but why in the first place?
Get it from the model now that we have one?
I don't think this can return null. We should probably add an external annotation.
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
I dont see any reason for adding this to string.xml. It is not really a string resource, it is more of an id. We wouldn't want this to change if we decide to translate the App strings later. A better way would be to move it to the Constants class.
Same here, better in the constant class.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Is this already protected by a lock?
How about to check whether workersToCheck is empty or not before notifying?
Does it make sense to set globalMinimumClock as 0 when workerClockMap is empty?
I would suggest that it checks the count of the entries to see if it increases one after the recovery happens.
other.awsRegions can be null and exception will be thrown in this case. Please add check for null.
Is this the recommended way in Karaf - do they not have an equivalent of JCA I wonder? I guess for the dummyxaresource it has to be this way but can we try a H2 datasource somehow?
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
why uniqueKey, be consistent call it keyField
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
@cvrebert maybe MkIssueEvents.class.cast(?
this doesn't looks good at all :( let's log the exception using Logger.warn().
Please, add the opposite case  other.compareTo(commit)
Remove useless assert
Jackson is fine with private constructors. IMHO this and the Update one should be private or at least protected so that users cannot instantiate this essentially invalid objects.
This test is exactly the same as testPublishWithNullUsername. I think you meant to pass in a non-null username into resource.publish()
don't use finalize, it's a bad practice
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
This check will be needed in case of every single widget button. If so it would be better to create our own WidgetButton class that will extend com.google.android.material.button.MaterialButton (then you can use it in your layout file). In such a class we can then override:  @Override public boolean performClick() { if (MultiClickGuard.allowClick(getClass().getName())) { return super.performClick(); } else { return false; } }  what do you think about this approach?
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
Ah - guessing that we are using static Bugsnag everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?
use the constant defined earlier (moreover, aren't jdo connection options available from some sort of options class)
Could have @VisibleForTesting annotation. Also could public be removed?
Add this to WireMessages localization resource
Do we want to include data= (since it's required) similar to how we include connection= for SQL? It would also be nice if the cursor was placed at the end of data= (as we do for connection=)
I assume there is no suitable interface/class that could be used here instead of Object?
why does this test need to change ?
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Isn't that should be setWriteRate
Error message needs updated.
Can we rename from exonCollection to something more appropriate, like targetCollection?
Could this be delegated to one of the classes that deals with HDF5 specifically?(like **HDF5AllelicPoNUtils**) Seems like some other classes might want to use it too
Should we return true when file does not exists ?
@ILikeToNguyen Why the change in visibility here?
I think it is not only the platform name. W3C defines a bunch of keys, which must be supplied without prefixes and Selenium has this list somewhere in constants
Should this variable name be updated as well?
can you explain why this change ?
Does transform need a null check here?
should we have an "unsupported" status instead of successful? successful seems misleading to me.
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
It's good practice to use getters (like getPerunBl()) than directly accessing attributes.
Please catch GroupResourceMismatchException from conversion method here and wrap it to ConsistencyErrorException. Because on input, there is no group and we retrieve groups assigned to resource - hence from the same VO and there shouldn't happen any Group-Resource mismatch.
Why is it a list of lists, not just a list?
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
Calling cancel method like this will not actually cancel the task. You have to do this through task driver.
I'd make these numbers constants
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
shouldn't we return a new or immutable copy of our internal list? just returning the list allows plugins to fully modify the list. @WonderCsabo wdyt?
I think the lambda expression could be passed directly to Comparator.comparingInt
That's good to know.
Is there a need to have log.debug within transaction scope?
it appears that this change can be reverted.
also should be warning
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Missing types
please decrease severity to "debug"
just wondering, w/ slf4j do we still need the custom format() ? I hope/think that's done by the slf4j logging library
lets use loggers
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
Init should only be called one single time when constructing the controller. That is done in OnStart. Please add a space between if and (
no need for an ArrayList
public?
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
use return ... ? ... : ...?
Reliance on toString method for anything but debugging is a dangerous practice. It is preferable to introduce a specialized method or methods with clearly defined semantics.
Let's rename locationModule to just module. Then we can bind SessionPropertyProvider inside the module. (The name is already bad, as it's no longer for location. I missed that when converting to Drift.)
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
suggestion return new PgClassTable.Entry( OidHash.primaryKeyOid(info), OidHash.schemaOid(info.ident().schema()), info.ident(), info.ident().name() + "_pkey", info.relationType(), info.columns().size(), info.primaryKey().size() > 0);
I would add a check here: if the ID contains the suffix, throw an IllegalStateException or InvalidParameterException, otherwise, there's a chance that you'll have an ID like abc-client-client, which is never appropriate.
You could probably use the same URL as in getResultById here.
This is not needed anymore... now you can just return id
not all listener
not all listener
not all listener
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
unecessary test : less is more.
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.
new AssertionError -> new UnsupportedOperationException
As this operation is optional, just say it won't be supported because it's not mandatory.
Lol! You're going to remove that, right :)
do not assing parameter! nowhere!
Optional<String> ?
This can be java return valueOf(value.toUpperCase(ENGLISH));
nit: Unsupported byte value ' + value + ' for row kind.
You could save a few lines by moving the return null into the default case instead of break.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
Better to return "";.
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
As I said in #1208 : In driver 4.0 we don't have any specific exception for codecs except CodecNotFoundException. When a codec cannot serialize or deserialize something, we use IllegalArgumentException. I don't think you need to introduce a special exception in these examples.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Seen proxies before that didn't parse multiple entries on a Cache-Control line. Do we need both, or can we just use max-age?
NB: no-cache is a value usually found in requests, not responses. I'm not sure of the effect in this case. To be on the safe side, I'd update this to read private, max-age=0 instead.
I think we need to check validation of the state transition diagram. Let's handle it in a separate issue. Please create an issue for this.
please move the isEmpty methods to the scimSchema
let's call it updateCodeMinings() instead.
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
These 2 conditions can be merged into 1 condition
Please call this one time and also check only one time.
This line can be combined with previous line.
upt.unifyGraph(graph) is double code. Better use this structure: new ReferencePositionTraverser(reference).referenceMapGraph(graph);. The graph = isn't needed.
same for thos changes
assertThat(graph.getEdges()).isEmpty() looks better
Initialize with 1 here, remove assignment of 1 in all the tool data building. As long as there is no other value set by something else it should always be 1. Also rename it to attackSpeedMultiplier, to not confuse it with the actual attackspeed stat of the tool (which is the product of the value + the tools AS)
A little wasteful when all you need to do is just set the fields and return this...
BlockPos.ORIGIN
s/policies/policy
Use getSimpleName instead?
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
why object? lets change it to the particular time we expect to receive so we could catch potential failures here
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Should we break the for-loop early if the condition is not met?
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
in the case where the Bytes object is immutable, it would be nice to store this after computing. This way it does not need to constantly recompute for case when Bytes are used in hashset.
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
+NonNull for return type
entry
entry
entry
delete
Use [Bundle.putInt(String, int)](<LINK_0>,%20int)) instead, no need to serialize a base type.
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
directly return
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
should this filter out null resources? (ie. bad paths)
Do we need to make sure these file names are also Windows-compatible? If so, we should include a few more characters to the list. - Linux/Unix: / (forward slash) - Windows: < (less than) > (greater than) : (colon - sometimes works, but is actually NTFS Alternate Data Streams) " (double quote) / (forward slash) \ (backslash) | (vertical bar or pipe) ? ( question mark) * (asterisk)
Codacy found an issue: [Use explicit scoping instead of the default package private level](<LINK_0>
style guide
Default should be false
Default should be false
It could be useful to factor out this constant, which is also used by org.nuxeo.connect.client.jsf.AppCenterViewsManager.shouldValidateStudioSnapshot
return Promise just to symmetric with start()...
Should this also set engine to null in a finally block? If not, I'm not sure why it checks for null (line 177).
Need to check those variables are initialized or not to avoid NPE.
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
I would prefer IllegalStateExceptions in such cases.
This will NPE if BundleRevision.getSymbolicName() returns null, I would reverse the equals target to be symbolicName.equals(bundle.adapt(BundleRevision.class).getSymbolicName()) This does not scale well if you have large numbers of bundles. If this is a hotspot of your code you can consider using org.osgi.framework.wiring.FrameworkWiring.findProviders(Requirement) using an "osgi.identity" namespace requirement. If I recall correctly virgo uses Equinox regions. That can end up hiding bundles from a BundleContext perspective. Using FrameworkWiring.findProviders would bypass the equinox region hooks so you need to be aware of that.
This will probably be permanently unsupported.
MemStore is used for tests, so we need to implement this function.
This should be implemented for consistency.
should return false if the validation fails
You can remove all the following code: if (!(.... return false; } return true; With simply : return super.canDoAction() && canRemoveVm()
We should also check the servers which we want to update the hook content is in UP state.
The operator should be && not ||
done for patch3.
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
please use (1 << priority) instead of priority + 1
This can be static.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
Better assume immutable parameters. Don't modify references to an input variable.
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
I think we can avoid this .INSTANCE. business by putting the fromV1APIJson method inside a companion object.
We mix two different comparisons styles here: "expected".equals(actual) vs. actual.equals("expected"). I would prefer to use the first one only as it is NPE safe.
These implementations are fine, but I wonder if the code wouldn't become a bit simpler if the defaults were stored as String values, and instead of the parameters.containsKey(String) you would do something like: return EventLogCategory.fromValue(Helpers.getString(parameters, PlatformSmartmeteringKeys.EVENT_TYPE, DEFAULT_EVENT_LOG_CATEGORY)); as a one-liner.
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
inUse is set twice in this constructor
unnecessary
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Instead of catching NullPointerExceptions, it's better to check if session.getRemoteAddress() returns an object (and only call .toString() in that case).
Would this method stop the rebalance as well? I can not see stop call here.
Can you just change the return type of this method?
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
Should this be false or true?
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
why are you using getAdapter() and not directly mAdapter?
why getAdapter() and not mAdapter?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Since the varargs parameter of String.format(...) is of type Object for which toString() will be called if non-null, it's a bit safer to do the following in case the key schema or value schema are null: suggestion return String.format("<SchemaPair: %s, %s>", keySchema, valueSchema);
Should we just use MoreObjects.toStringHelper() for this?
this does not handle the empty 'lists', it will throw an exception
This is already done in the other method.
Why are the problems not enough?
This should follow the normal exception handling path and let the caller handle the printing of the exception.
To avoid confusion, rename the variable to sessionId.
Missing the substitutions for the {}'s. suggestion LOG.error("Failed to parse value of system property {}='{}' to an integer. Using default value.", sysProp, val);
So, if the xpath query matches event than this method will return true, right? Than the event will be propagated to TreeWalker. This java if (!filter.accept(event)) {  will be evaluated to false and the message will not be removed from the set. Thus, what is the sense of the suppression? What do you filter? Look at testMatching. The user writes the query /CLASS_DEF[@text='InputSuppressByXpath'] in order to suppress the violation, the filter should deny the event, but your filter will accept it.
we should only handle non-transient values, or?
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
You can make this method private
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
StringUtils.isEmpty
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
This branch is not needed
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
This will throw redundancy warnings in IntelliJ
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
Why did we make this public?
We should validate that's non-null (to fail sooner).
My point is about consistency between different codecs. Protobuf codec assumes the callback handles the flush, while this code has to call it explicitly. We should make it consistent and set the expectation that the traverse callback should handle flushing/closing the generator. Then the codec's would just close the traverse callback.
I think 15, 11, and 4542278 should be named constants.
It would be great to rename the variable to isParamCountValid.
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
could be simplified: Collections.addAll(refsSpecs, specs);
same thing, while you are cleaning, other thread could store other key.
Is this idiomatic? In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns? Would be clearer to omit the assertTrue?
Formatting issues. Please use appropriate spaces between string literals.
static
sounds like it could be set on error level
unneeded throws Exception
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
Same as TestIsAppPageview, better to test the UDF wrapping than the actual functionality.
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
or more simply: if (forceRemote != null && forceRemote)
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Use map.forEach
filename
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
If this should never happen throw an IllegalArgumentException instead.
Unsigned types are not used in the current implementation. So, you can omit them.
Is it necessary to call this again?
As there is no else branch you seem to allow unknown/unexpected fields. Is this always allowed (i.e. per setting on the mapper/parser)?
Minor, but "extra".equals(tagname) would make this more concise. Java and its endless checking for nulls...
Argument name
Argument name
MarketData.getValue never returns null
Looking at the CommandCache#reset() method you pointed me to, it made me realize that we should check here that ctx is not null first, to avoid any risk of NPE.
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
So this will be used for quantity and duration too or you need separate ones?
+ NUM_HEADERS + NUM_FOOTERS;
I suggest to move this a few lines up - we can put it into the else block for the headless check. No need to enable this when running a headless server.
.add("noShutdownOnExit", noShutdownOnExit) (was shutd **wo** n)
No interest in removing the stageTimeoutMs value?
I feel like there is a case here where there isn't an existing pipeline (via the save entrypoint), which should probably be legit from a stale checking perspective. I also suspect the submitted payload in that case would not have a last modified (unless that is magically set somewhere along the way with a default value).
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
Can you add getId() and mark id() as deprecated?
Can we make it final?
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Is this method used?
Not good to use Optional for collections, just return empty collection
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.
This should occur before setInput(input);
![BLOCKER](<LINK_0> 'Severity: BLOCKER') Refactor this method to not always return the same value. [![rule](<LINK_1>](<LINK_2>
this change is no longer needed.
Check other tests in this class. Replace startGrid(1); by startClientGrid(1);.
Field should be named the same as the resulting JSON object to reduce confusion (if possible).
Is payeeIdL a typo or intentional?
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
Update labels to go with method names. Alternately, call super.toString for super attributes
make this synchronized.
This assumes the webcam res == screen size... Not the case. height:width set in reporter seems to be ignored
Worth reporting what was null?
Here it would be nice to use a static import - that would make it more consistent with the other code
Shouldn't there be an assertion checking that the shipping method was actually set, price and all?
Here it would be nice to use a static import - that would make it more consistent with the other code
Why is this necessary? This should probably use the generic updateBiometicListeningState(). I think you're doing this to turn on the iris scanner? If so, you should leave it authenticating state, like we do for fingerprint, and send another signal to go into high power mode to complete authentication. This is what we do in fingerprint.
Same question.
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null");
java Objects.requireNonNull(callable, "callable is null");
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
It's a good update
use the optional, luke! ![image](<LINK_0>
Program to interface, not to implementation - please change return type to Map<String, Object>
technically speaking... :) the user agent header value could be stored in a static field and not computed each time getDefaultHeaders() is called. I'm sure the performance difference is negligible, but I couldn't stop myself from mentioning it :)
I'm seeing most of the string literals used for property names, etc are re-used in quite a few places. Let's introduce appropriate constants upon them to be able to make the code more maintainable.
Maybe wrap in an immutable map.
Maintenance of the map will be simpler than that of the list
What do you think about Comparator.naturalOrder() instead of null ?
Can we have a thread name here?
please validate ledger id
you could use Exceptions.expectExecutionException();
must be package local
Minor: Ideally we should avoid doing work in the constructor. Pas apiRooUrl and Client to the constructor, and provide a factory method receiving apiRootUrl, username and password and creating the constructor dependencies.
There are keystore types which don't require a password or gets it from another channel (e.g. WINDOWS-MY type).
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
We can strip this down quite a bit to just java this.eventReceivers.forEach(EventReceiver::close);
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
this("Safety Command")
I think this will be called automatically.
No need to call super() since it currently doesn't extend anything.
Should be a SamzaException with a message, not NPE.
Not sure, why not use @NotNull?
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
use ShellIsAvailable
use ShellIsAvailable
use ShellIsAvailable
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
nit: plural naming on list?
This class has no superclass, so I'm not sure we need to call super() here.
Just curious, why do we need to change the access qualifier to protected?
so if you make this private that would prevent subclasses other than Some, right?
Why does a utility class need a protected constructor?
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
The code can be simplified to rely on autoboxing.
if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
casting to Integer is redundant. IDE shows warning
not so readable. looks like good candidates for parametrization
We need to check offset + length <= arr.length?
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
@njhill just to be 100 % safe should we better use: ?  System.arraycopy(array, index, copy.array, copy.arrayOffset(), length);
We usually don final local variables.
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
I think it is better to throw exception
I thought you wanted to end this practice, Adrian?
Even if this was copied, we should fix the this.m_ references here :)
You should use assertNull.
Use Guava hashCode function
Yeah this should be return set.get();
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
!reason.isEmpty() can be used
They are mutually exclusive? Or is that a micro optimization?
The 'if' check isn't needed here, right? replaceAll will only match if these are true?
can be delegated as: putByteProperty(key(key), value)
can be delegated as: putCharProperty(key(key), value)
can be delegated as: putBytesProperty(key(key), value)
use a constants in PicsConstants for page.png
Is this an artifact or intentional? It's not in the interface.
Should it be internationalized ?
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
Should this return the AzureTable?
is there a reason why this method isn't implemented?
This should stay final
Should this method be final?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
This check is redundant because you check this in handleSelection()
I'm pretty sure we use IllegalArgumentException for these everywhere else.
backspace (bracket should be one tab back)
space
1. openHistoryPage() method should be named like openFileHistoryPage() 2. method looks better if parameter consist only from one variable e.g. historyPage.openHistoryPage(URLsContent.fileName);
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
@ILikeToNguyen Why the change in visibility here?
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
@slubwama provide an error message description of what has failed in addition to the stack trace
some other Executors wait here and see if the task exits immediately. Maybe we should do that too?
Should we be concerned that the expireTask can be reset after this synchronized block completes? Whose cancels the Future in that case?
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
nitpick: just return <cond> sufficient
Why is there a fromByteArray method? Why not call the constructor directly?
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
But existing rows use null not "" for the parentUuid.
Could we reuse instances? Perhaps justified if getCoder is frequently called.
static imports
static imports
This should say "LocalTime".
This should say "OffsetTime".
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
You need to add a check: if (!(selection instanceof IStructuredSelection)) { return null; } This will also make sure that selection is not null; Also, usually we cast to IStructuredSelection instead of StructuredSelection.
we don't use curly brackets for single line bolocks
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
what's the intent of this change?
please fix whitespace
Huh? :-)
I think this should have its own integration test as this is nth_value specific stuff only
Would you mind improving this test to use executeFile() instead of executeString()?
have a look [<LINK_0>](here). This class should be deprecated and no longer be updated, at all.
Same here, with respect to bad exception handling.
quit can be made public, to be more explicit.
return symbol != null ? symbol.qualifiedName() : "";
It is useless to test before marking as ignored, as only the symbol which are already known could be marked. Note that to be known the symbol have to pass the "isSymbolRelevant" test, which is equivalent.
This can only happen if semantic is not present (symbol method is not annotated as returning null). As such you should test if semantic is present and not raise an issue if it is not the case.
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
This will create a new instance every time. Cache the instance in a member variable?
It would be cleaner to have this set as part of the UnitTestModule() at the guice level so people don't need to remember to do this themselves.
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
why not just return it directly?
Can you replace IDs with names in this log message?
I think you want to do this in the reverse order
empty finally block
why we don't swallow exception here for close?
Can we have a message assert on this? I think the point here is that the exception thrown by the runner close isn't the exception that happened inside the shutdown operation
You should use deadline. Furthermore what the interest to change it ?
Does it still work on Windows?
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
Remember to revert this file, it should know about the transport class.
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
final
"Path validation" instead of "Request validation"
RuntimeException will be sufficient
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
> In Java the / operator has a higher predence that the cast operator. actually, no, [cast has higher precedence than division](<LINK_0> <LINK_1>
Maybe Ints.checkedCast() for sanity
Should this have output partition too?
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Camel case here too
Consider Arrays.asList("xxx","yyy", "zzz");
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Why this change?
filter could still be null when this line is reached - we should check it isn't null
Generic type not used, remove.
StringPool.EMPTY instead
- log warning that option is not supported by SNMP
Based on how it's used, it's more like a listener not callback.
suggestion recommendedLayout.keySet().retainAll(newServices.keySet());
nit: remove brackets to be consistent with 2 lines below.
I think you missed updating the parenthesis on this one
do we care to check for the length to be positive here?
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Should check if errors contains error with key "Concept.conceptClass.empty"
Should check if errors contains error with key "Concept.datatype.empty"
To increase readability of this test I would just drop this statement, and move ifCond block inside if condition
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
this could be secret, if we support armored strings, you do NOT want to print it. The ClientConfiguration class could have two properties one for File, and one for the parsed string, logging the file name isn't an issue, but the PEM string would be
isInfoDebug
Why change the name the property? Accident due to mass refactor/rename with IDE?
Technically setting closed = false isn't needed since this is the default for a boolean
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
INITIAL_SIZE is misleading because this constructor creates a fixed-capacity queue. So this value is actually the maximum size.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
rename
rename 'listeners'
not all listener
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
cannot be null.
We can directly use updatedVolumeList instead of copying it to a local variable.
But we have already clicked the button in the command before, haven't it?
What we are waiting here on?
just reuse this method where you need  public void selectAutocompleteProposal(String item) { seleniumWebDriverHelper.waitAndClick( By.xpath(format(AUTOCOMPLETE_CONTAINER + "/li/span[text()='%s']", item))); }  <LINK_0>
If you instead call this lastItemPositions and subtract 1 here, does that save you from having to subtract 1 from the final return? I think it reads clearer not to have a "- 1" on the last return.
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
I'd rather use Money here.
Let's adjust the formatting :)
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
I would recommend an else if here to avoid comparing against a string unnecessarily.
Args.notNull
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Not sure that it's good. If path is not setup - this.dir will be still null - and we just pushing NullPointerException one level down.
think you should add it as method somewhere
FindBugs finds this line not to it's liking it seems: Exception is caught when Exception is not thrown in org.jboss.weld.probe.Reports.getDesc(ConfigurationKey) ["org.jboss.weld.probe.Reports"] At Reports.java:[lines 78-370]
Nitpick: Can probably remove both the if and the else (saving three lines) by starting with description = MoreObjects.firstNonNull(description, "") right at the top.
I don't think we need this catch - this is handled by the boolean return value.
This should be handled by the nodeDelete return value, so we don't need this catch.
Revert back to sessionFactory.getCurrentSession()
same here. In case you want to open an ErrorScreen, you can do so by using one of the reportError() methods from <LINK_0>
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
log the exception ?
can you make all of these as just Query and not org.hibernate.Query?
Please use the positional parameters.
We can't filter by closing time?
return ImmutableSet.of();
Actually the underlying objectExpr could have free variables.
If an implemented class uses this default group method, does it work with returned null or it has to override with some implementation?
studentsWhoRespond -> studentsWhoResponded
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Don't we have to say that this is uniqueId JDBC?
This should be removed - it's absolutely fine for entity data to be empty. It's only during serialization to native format that it should not be empty (ie adding the EntityType field)
You can static import the checkState method.
return this.toInteger() == 6;  Since toInteger never returns > 6, I find the >= a bit confusing (even though it's more future-proof).
Use same order as the field declarations.
that class would be better with a builder, though I wouldn't ask changing it now
This line is redundant.
does this need to be calculated on the fly each time or can we save the iterable?
Should we throw an exception instead if a DimFilter was null?
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
We should call the init() method first, instead of letting the KerberosAuthenticator do that for us.
I don't think we need this catch - this is handled by the boolean return value.
Is it for sure targetName will contain @. I mean in case of serverName null, and when targetName is not under server control entirely.
Unsure this addition is useful.
Is there a reason that allocationPools, dnsNameServers, and hostRoutes are missing here?
Omit nulls or not?
Remove all "null" cases. There is a default case for that.
If this should never happen throw an IllegalArgumentException instead.
Gson doesn't run on these versions so I don't see any reason to include them.
static
The null check is now redundant since now we do literal.equals(variable).
remove
ctx.close()
replace with ReferenceCountUtil.release(msg)
maybe log an error message here if numConnections ever goes less than zero
is the server name mandatory still ?
assertNull? And the withTx... though I know you've just moved this code from another test.
Could you please use Map interface here (and not the implementation)?
replacing this with helper method would be great
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
You could probably use the same URL as in getResultById here.
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
It should be "path".
Add a blank here, please.
I think it is better to add this to the generic 'Request' interface. To make it easier to use I think also that we should have several 'header' and 'query' methods in that interface, at least two: one to set just one header/query, and another one to set a map (I'd consider this optional), that way the user can do the following: vmService.start() .header("My", "header") .query("my", "parameter") .send(); We should also probably have a new 'BaseRequest', or similar, implementing that interface and providing the implementations of those methods.
Same, 4 spaces.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
I guess I'm out voted on using this. :-(
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
Avoid the intermediate variable and directly assign selfID.
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Just think it would be nice to see **queries.add(query)** in for loop and then logg that it was added. What do you think?
Try pushing methods such as getAuthorization().getViewConfig().isAdmin and getAuthorization().getAdminsConfig().isAdmin to Authorization class
Any reason for logging and throwing the exception. Normally, we log or throw.
Should be externalized.
Externalize
Externalize
Which tests fail if we don't have this line?
I think this should be replaceFailed = false instead.
Silly think but can we call this workbenchPage, wPage and Ctrl+K lands frequently on the method sho(wPage) and I like to use Ctrl+K to follow a variable
use log's parameter here
Fix logging level here (error)
suggestion logger.warn("Failed to do decode hash using base64! " + ex.getMessage());
hmm, why don't you verify the type ?
None of the tests in CaseDbQueryTests handle the condition where this Lookup is actually valid (and neither of the other two tests cover this code path)
Minor nit on the phrasing of the message. Can we rephrase to "Workflow {}; Instance {}; Entity {}, killed manually by user. Will not retry."
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
to get variable replacement you need to use the idiom: if (!validate(isClusterSwitchTypeOVS()) && !validate(...)) { return false; } where the predicate methods return a validation result instead of a boolean (which will encapsulate test+result nicely) there are lots of examples in other commands
Please use StorageDomainValidator.isDataDomain()
this is 3.3 feature, not 3.2
This should be as it used to be, no need to convert to lower case as that should already be part of the "value()" implementation of SELinuxMode.
This should be 3.6, even if the "quota mode" concept was available sinnce 3.2.
This check feels a little weird for a few reasons. It behaves like a factory (in that it returns new instances) but sLock is not assigned here. It also initializes a static field from an instance method and that feels strange. I suspect that if the lock is not being acquired in one method and released in another, and there aren't any waits involved a more primitive synchronization technique may be sufficient (such as a synchronized method or block, without the use of a ReentrantLock) -- I'll leave this up to your judgement but this looks dodgy
Please remember this ctor changed.
ooh! I ...Connector, here!
Can this be private, or is there another use case for default attribute outside the builder's call?
should the message include "command _with options_:" + this.options ?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Don't need toString()
Can you add getId() and mark id() as deprecated?
Missing StringUtils.isNotNullOrEmpty() check
unused field
the attribute is not used
Can this be private, or is there another use case for default attribute outside the builder's call?
It's beeter to used int type.
Would be better to have all these methods return a primitive long rather than an Object Long.
I propose to log the actual timeout used if it differs from the default.
Maybe catch Exception? Otherwise propagation stops.
if target is already updated or expiration time = -1, in either case we can skip update
For debugging: Would it make sense to log the exceptions here?
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
Can you please move the Preconditions up to the constructor? Also perhaps check for matching with " projects/(projectId)/instances/(instanceId)/clusters/(clusterId)"?
Just return checkNotNull(id, "id").split("/");
Let's have these conditions one below other:  if (parts.length != 2 || parts[0].trim() .isEmpty() || parts[1].trim() .isEmpty()) {
it needs to be protected against concurrent modification
again I think you can use the diamond operator
There must be a more succinct way of doing this using streams.
why not replace these two lines with return (getState(key) == State.SET)
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
OPTIONS could be more suitable here, since we don't want to transport the whole value
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
Can you assert the container has the right name?
Doesn't List as a Collection have a defined method to check whether it's empty or not?
throw e will never be executed.
Why do we need this change?
is this needed?
Should this return the AzureTable?
is there a reason why this method isn't implemented?
These two lines probably can be combined into one.
Remove by dn/key.
We need configuration property persistence-manager-remove-count: 1000
final
please use String.format to concatenate strings
whole expression should be wrapped into toIntExact not only rebase( index ) % entriesPerPage
shouldn't it be- (index +1) % numberOfMacsInRange ?
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
Maybe rename idToChildResource or something along those lines.
Why are you changing to patient 7 here too?
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
Using == for object comparison? :)
Log debug - not info.
method can be protected now (private if not isolated in tests).
Another option would be to use  log.debug("This is the execution root? " + result) to replace the lines 532 to 539.
could we check this without throwing an exception?
Resources is itself part of Guava, and is marked @Beta. Why not use GuavaCompatibility.class.getClassLoader()?
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
I think a special case should be made for an anonymous principal, to disallow the API in such a case.
this method is @NonNull, throw UnsupportedOperationException until we implement this ?
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
Maybe remove the package name as it is already in the import statements.
Use a builder method from TestNG Collections
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
RuntimeException would be better. Typically SI components check the exception and wrap it to MessagingException with "guilty" Message. If it is MessagingException already we lose the "guilty" Message context.
setErrorMessage
This field is written here but never read, can be removed (Findbugs)
I don't see any change that is related to elapsed-time, why is this change needed?
super.getVm() will do dao call...
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
is this necessary?
these error messages should use the name of the expected property. keyField
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
Please, use text "Project directory permission" (Name was fixed after sending this pool request) thank you.
Use "Mail" instead of "Mails". There is only one trusted mail.
This can be made static
You can chain this like  java return ImmutableList.<String>builder() .addAll(currentSeeds) .addAll(newSeeds) .addAll(oldSeeds) .build();
This can be simplified to:  java return ds3Requests.stream() .filter(this::isGetObjectAmazonS3Request) .map(this::toGetObjectCommand) .collect(GuavaCollectors.immutableList());
no need for an ArrayList
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
nit: ~Square formatting
