Is this order guaranteed, ie ls-refs before fetch?
The MySQL says that > This function requires MySQL to have been compiled with a compression library such as zlib Should we follow that ?
you can pass null as err if you do not use it.
These are magic numbers for zoom level. Pull out 12 and 13 as MIN and MAX zoom level constants.
is there a reason for the FQNS here, rather than import android.os.Process; ... Process.setThreadPriority(...?
any reason you're not using for( Title tile : tiles ) { here? I believe with a LinkedList it's a more efficient iteration (since LinkedList.get(index) is O(n)).
It's better to introduce a new variable this.request, like it's done in other classes (for example RtIssue)
aren't you getting a warning about collapsing these 2 lines? #Closed
incorrect message "url cannot be null"
Here is also that unusual check.
Using a boolean as abort condition for the parsers main while loop is also a deprecated pattern. Instead replace this line with outerloop: while(true) {.
Minor, but "extra".equals(tagname) would make this more concise. Java and its endless checking for nulls...
Please remove an excessive space character.
suggestion return (ModelAdaptor<? super T>) adaptors.get(attributeType);
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
wait, am I missing something, or would encrypted passwords no longer work with this change? The password used to be  password = new PropertiesLoader().parseValue(password);
httpAuthenticationUsername can be null. Should use Strings.isNullOrEmpty().
java.lang only required here
hmm can we just use: java executorService = MoreExecutors.listeningDecorator( Executors.newSingleThreadExecutor());  ?
getAllStackTraces() is quite expensive. Given that we have a cache in place, we should soften the actual impact. We should be able to optimize for the default logger arrangement. Typically, log handlers are called on the same thread as the logging happens. Therefore, we should call Thread.currentThread().getId() first to inspect whether we need to obtain all threads or whether we can resolve the thread without further do.
it should test all the possible patterns IMO
rename the method to createResourceIdAttributeStatements
Consider to use StringUtils.hasLength(str) to check
Don't construct a list return either Collections.emptyList() or ImmutableList.of();
why not public?
Why not pass the paymentAccount and avoid the extra lookup and null check in paymentAccountManager.removePaymentAccount?
IMO they should both call the other methods. They shouldn't make the request themselves so that there's only one path to a call to request
in 3.0, the external tables are created inside warehouse directory. context.warehouse.getDefaultTablePath .. takes if the table is external or not as a parameter.
Change this to an assertion that node.getSources() is empty.
helper.validate() ?
Actually the underlying objectExpr could have free variables.
it looks like agents map is not modifiable at all, so what do you think about using instance of ImmutableMap instead, then you don't need to wrap keySet() with a new unmodifiableSet instance each time getAgents() is called
this doesn't look like it needs to be public
ERR_DELETE_ERROR, add if there isn't one already
Loader can be hided twice <LINK_0> and <LINK_1> What does happened if call hide method in loader twice?
use the optional, luke!
map - confusing name
Can be Arrays.asList(new StringFirstAggregatorFactory(fieldName, fieldName, maxStringBytes)).
for(PostAggregator agg : Lists.reverse(postAggregatorList)) ?
in what scenario path list will be empty with copy error set to true ?
This is File copy error not file system retry case.
if not blank
We try to avoid returning null to express absence. Could this method be refactored to return an Optional<URI>?
No need to log here: return binary.getLong();
I prefer ", not "+(l == null ? null : l.getClass()));
I am unclear on the extensibility of the code in future. Will we add more selectors and cascade them in future, for example versionBasedSelector/Pruner?
java final List<Double> means = IntStream.range(0, numSegments) .mapToDouble(s -> new Mean().evaluate(Doubles.toArray(getCoveragesInSegment(s))) .collect(Collectors.toList());
Cache _timeRangeMSToSegmentSearchTree into a local variable in case it is swapped during this method
check to make sure notificationUUID is not null
This should check to make sure that notificationUUID is not null before attempting to delete it.
It doesn't look like you are doing anything with the bucket here. This can be removed.
nit: might be clearer as: return involvedTables.stream().anyMatch(this::isValidationNecessary)
static
Was thinking about collisions here, <LINK_0>, theres about ~1% probability of collision in 10k tables, but we are fine I think (except for the large internal product that is creating and truncating tables). We can take a 16 character substring?
I'm slightly worried about doing the shorten here. It may start to come up ambiguous against other branches. We won't expand a shortened name like "review" to "refs/notes/review" because RefDatabase doesn't consider the "refs/notes/" namespace as one of the search prefixes. This should be a different method, maybe in the NoteMap class?
how about the following ? I find this easier to read : while (selIterator.hasNext()) { Object sel = selIterator.next(); ... }
Style-nit: Braces aren't necessary here.
Seems like there's a spacing issue here, two spaces instead of 4.
Don't you want to give count as the capacity hint?
Wouldn't it be easier to just use "return false;" and at the bottom use "return true" this will save you having to declare a variable for it. <layout,logic,performance
this is a test... better to use Assume.assumeThat(j.jenkins.servletContext, Matchers.isInstance(ContextHandler.Context.class)); as that way if you run the tests on another servlet container they will be skipped rather than fail
Shall we use a ternary operator here? Lets check and fix other places where applicable. suggestion return isAPIProduct ? apiProduct.getContextTemplate() : api.getContextTemplate();
can jsonAsString ever be null, seems like you create a PhoenixJson object you it will always have be from a string
This is not correct. The link is inserted in the user json object so "self" must refer to the user href. Suggestion: return a LinkBuilder here and use the method .withRel("confirmMobileNumber") in the UserResourceAssembler.
Shouldn't this message be changed to "Should be 500"?
Rename into addEditLink, as that is what's added.
Should this be part of VM's equals()?
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
shouldnt this use the vmRefresher.timeToRefresh() ?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
same as previous: compile error
We could just return true here and let auto-boxing take care of the conversion.
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
we have lambdas for this now.
The final was there so that the user can't override the method.
this.redisTemplate
Nit-pick for the variable name. It is really not file, so just entry would be good. The new HashMap() is bad code too. Must be with generics
Should add the rule to config file?
Maybe IOException since it's supported here?
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
Thread name should use actual port.
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
Missing final
Should we import the class like we did for the others?
i just started to merge this and i think that change might have been an artifact from your rebase at some point as i see that style in tp34. sorry about making you change that. i will probably go back and add that change to tp33 after this merge is done.
Please use Objects.requireNonNull(businessSearchCriteria)
Crazy thought, what if Replica had an isLocal or something?
Should this be String.valueOf or is cnn the way to go?
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
This textView can be named accountText
This is different than the one in InputPortInfo. Why? Should they? If not, you might wanna extract this code to a static method in PortInfo and call it from both this method and the one in InputPortInfo.
I think pNode.getClass() doesn't have to be in the loop, you can move to above and return empty is the condition is true
I would suggest moving pNode.getClass() == PointNode.class before the for loop
Why synchronised here? The previous code already synchronized and also checked if it is ready and the queue is empty.
I think there is a concurrency issue. Multiple threads can insert the same query in this line and DefaultOperatorChainImpl 145 line.
Why didn't the sharedLock used in here but did used in addNextEvent?
This is not a related change... if you can move it to a separate patchset. Also, as per discussion, I think that rather than cutting the mark functionality in the middle here, we should zero it out in the config and leave the logic. If we really want to do this then we ought to remove the logic wholesale (which I'm reluctant to do). For now, maybe let's just set it to 0 in the config?
If we use reflection to create instance, the standard way is to create the object using no-arg constructor through reflection, and call a configure method with the rest of the arguments.
You need to compare with both null and empty string
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
why is this needed if whole transaction is rollbacked, then table should be dropped as well, am I right? Also JdbcPageSink has not created this table, it looks fishy that it drops this.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
Please replace that 1 by a constant indicating what it is.
final
According to which rules do we throw and InvalidSyntax or an IllegalArgument or an IllegalState exception. Sry, but this looks quite randomized to me
Seems like after OSGI it should be a period instead of a comma, but a nit and may be just how I'm reading it.
Remove stack traces
Possible copy/paste bug in the order by clause.
Why does this need to be ordered by the synthetic primary key?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Was seconds an intentional omission here?
Can you use the dateTimeService instead?
This is one of the points we should use Zulu Time, but do use the configured default Timezone.
Hash code
whitespace/style
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
assertThat(violations.isEmpty()).as("Violations are not empty!").isTrue();  =>  assertThat(violations).isEmpty();
This method and the ones below could be static
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1);  =>  assertThat(violations).hasSize(1);
no need to create a set here..
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Maybe it's just me, but I would find a simple if-else clause more readable.
this part looks similiar to #validateAuthenticationState consider extracting the common code into a shared method
return immediately, no need to store it in a local var
fail
don't need to throw exceptions - just return null.
if (!cloudDestination.doesBlobExist(blobId))
null or empty list?
I think these subprojects are still target 6 so diamond doesn't work: <LINK_0>
I would highly recommend to subscribe only when the returned Mono is subscribed, otherwise you're creating a hot publisher
just return "" instead of new String()
Maybe we want to keep something similar to what id was before
The this. in getters are unnecessary too.
we should check that the last character is also a quote. We should factor out the logic with MessageTypeParser.Tokenizer.getName()
Why does getData() not make a copy of the array but this method does?
final params?
What's the scenario in which in could be null at this point? if the file doesn't exist, getInputStream will throw a FileNotFoundException per FileResource.java. Maybe add a catch with FileNotFoundException? Then, you could get rid of the null check, yes?
please extract as constant
Should this result in all active connections being discarded? During runtime this may happen if the configuration is cleared by the config admin. disclaimer: I have only moderate knowledge about OSGi and this is more of an assumption.
to connect to secure nimbus
Could use the Apache CommonsIO FilenameUtils.separatorsToSystem(String path) to be safe & cut down on verbosity. Also, that same utility has a lot of other useful methods that we could be leveraging throughout: A few: normalize(String filename) //normalize unneeded relative paths to simplify the path. ex: a/b/../b becomes a/b getExtension(String filename) //gets the extension wildcardMatch(String filename, String wildcardMatcher) //allows you to compare extensions or file names easily via wildcard
instead of multiple return we can store results in a variable, and then have single return.
Oscars began in 1928 seems leftover because of copy/paste
As above, I'd use String.valueOf here.
grammar nit: 1, not one, and no :
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
a workspaceitem should be returned
OperationFailedException never thrown and it can be removed
This should be PathAddress address = context.getCurrentAddress(); The result is the same but ^^^ is more efficient and is the preferred idiom because it's simpler.
It seems to me that the only cases where first and last will be null is when there is no children being ELEMENT. In such case, we are not reporting anything through checkChildrenLine. Instead of having @Nullable first/last I would simply not create the object if both are null, and return null.
Question: in the normal login scenario, reuseSession is called right after setSessionId. As both reuseSession (using getSessionId) & setSessionId are async now, I think we should utilize result callback when doing setSessionId, and only after setSessionId completes (result callback executes), we should proceed with reuseSession. This complicates the current code a bit, I can help with modifications/testing here.
Hm, to avoid duplicating code, I suggest to create small methods: void processSessionId(String sessionId) { assert sessionId != null : "Session ID must not be null"; RestApiSessionAcquiredEvent.fire(eventBus, sessionId); scheduleKeepAliveHeartbeat(); } void processSessionIdError(Throwable t) { RestApiSessionManager.logger.log(Level.SEVERE, "Session ID is not available, this might break UI plugins", t); }
instead of setEngineSessionId - why not having it at ctor?
May be you do not need another submonitor conversion here?
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
We prefer have single statement if's without brackets.
i would split this line into two for better readability. also gameUser.getAchievements() could be puted to variable
discussed and decided to let it lie
put call of this method to appropriate place in each method that requires it
@Serranya The same here. See above.
@Serranya The same here. See above.
@Serranya Please, add the name "body content" into the message to be more clear and specific. It's too much generic.
can be refactored into commcare task
It would be simpler to have a dependency collection Task (like base code) after each event tasks instead of making a long dependency list. It is more readable too. Also, it is confusing how the dependency is set if parentTask already have a child. So, it is better to have the tail of parent task chain to add dependents.
Could WRITE_DELAY and MAX_DEFERRED_PERIOD be made user configurable so users can decrease write cycles to flash memory?
minor, is it method scope for Visible For Testing? If not please change it to private.
Why create ObjectMapper on each invocation, instead of having ObjectMapper field that gets initialized via (package-private) constructor?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
I think it might be easier to create a list and compare that?
This could use Collections.singletonList
expectedChromsomeList can be declared using Collections.singletonList("11"), inside the assertEquals (or outside if you prefer for readibility). This is an small method and is not really necessary here, but in bigger test methods reducing the number of lines improves the readibility.
I don't see why the newMonitor methods need to be synchronised.
May want to get rid of this System.out running loose here in this test case.
Probably we should log the exception here (debug or trace), just to help with troubleshooting
We need to change the method names to be more descriptive.
For readability sake, can these two increments use the same atomic method call?
computeIfAbsent?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
suggestion
This could be set in the constructor instead of checking this on every request.
We shouldn't ignore an invalid enum value.
Immutable?
@essobedo once used variable can be inline
SyncNetworkParametersBuilder contains those logic in labelAdded() & labelChanged() perhaps it could be reused ?
Shouldn't you update the glusterNetwork member here as well?
what guarantees getParameters().getNetworkId()) represents a real network ?
Use StringBuilder please.
I would rather use a constant such as com.splicemachine.primitives.Bytes.UTF8_CHARSET
there is no need for using FQDN because only one Base64 is imported now
@Nadahar Isn't "**oga**" already there ?
I continue to think that **aifc** should to be here...
Can use the already defined Constants
SetAdministrativeStatus should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetActivityCalendar should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
SetAlarmNotifications should be tested on an E-meter DEVICE_IDENTIFICATION_G_LABEL -> DEVICE_IDENTIFICATION_E_LABEL getDeviceIdG -> getDeviceIdE
doing += on a Long object causes boxing every time. It'd be better to have sum be a "long", and return Long.valueOf(sum) at the end. Or simply return a long in this method.
License please.
Can be static.
This could be null, we should probably handle this if the JIRA api changes again
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
do you need to select et_name here?
I think you should also adjust saving of event-type. Because with current implementation it will not be possible for user to delete event-type and then create another one with the same name (method with throw DuplicatedEventTypeNameException)
declare throws please
More accurate error message
Lists obtained from a message are immutable. No need for extra copying.
one backspace too much
defensive copy?
Collections.emptyList()
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Just a note that FetchSessionHandler is used by the consumer too, so we will either need two separate implementations or make sure it works just as well for the consumer too.
This doesn't seem right. lastAckedSequence(topicPartition) may exist.
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
It should be possible to drop the DefaultDataSourceProvider Service interface and simply replace with with serviceLoader.onlyOne(DataSourceProvider.class, JndiDataSourceProvider.class). That will use JndiDataSourceProvider if no other DataSourceProvider is found
why? let's format it properly, it was ok before. annotations and method definitions on different lines
Note: There are *two* updateDatabase() methods (with different params) in this class, and it seems you only removed the synchronized from one of them. Is that on purpose?
Actually this is largely unnecessary for RecyclerView adapters since it has lifecycle callbacks for when it is attached/detached. The reason this (ugly) code is part of RealmBaseAdapter is because standard ListView adapters do not have these callbacks so we are forced to use weak change listeners. Also the change listeners on our collections actually have better granularity currently. I would remove this code completely and just use realmResults.addChangeListener(listener) instead.
I don't think this is needed
Shouldn't we move all existing objects before populating Dog object?
final
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
Can we make ObjectMapper instance static final and reuse it instead of new instance for each execution?
minor: don't need this. qualifiers
This is working Ok.
I think this is unnecessary => "profile =" + this.profile is sufficient.
There should be an I18n used for this.
fancy name !
Remove empty line
Add a message. Without it, you just get a NullPointerException with no message. ie. "'containerName' cannot be null." Same with another usages of this.
Use Camel's ObjectHelper - org.apache.camel.util.ObjectHelper#isNotEmpty
String.format?
Seems like the previous tests should also assert on the length?
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
Is replacing separators enough? We should look into something that will work for any special characters.
An create on-demand Direct Debit payment request should always have an agreement ID
suggestion return Optional.of("org.junit.platform");
Isn't it possible to use a specific drive letter for WebDAV? Hence, it could use the Custom drive letter chooser
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Maybe check for if name ends with ':' so we don't do a double one?
Why a maximum length? Not necessarily against it, just wondering. If we choose a maximum length then perhaps make it a bit longer (e.g. will for sure never bother anyone, 2048?) and extract it as a constant field. Having such logic in the Marshal might be the wrong place though. Should probably be validated upon reading the setting. Perhaps there is even some helper classes to aid this in the configuration-framework. Otherwise we could validate in CausalClusterConfigurationValidator. I would be totally fine with skipping a check altogether.
Why do we register onDestroy?
This doesn't need to be "re", as it's just evaluating stuff once, not twice.
Do you also need to wait for any handler threads to process outstanding messages?
can just be hash.hashcode()
And this change should be reverted as well.
really minor, probably it can just return value to avoid integer boxing with Objects.hash or use Integer#hashCode.
This is too early: if thread 1 does this check is de-scheduled before line 238, thread 2 could run the entire stop() method and then thread 1 would create the spliterator even though running == false. I think the only safe place to do the check is after creating the spliterator.
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
I'd use a different name, e.g. doStream
Is this really sufficient to test your WCheckBoxWebElement? One check box is sufficient if it is exposed through a getter so the tests can set properties on it.
30 might be a bit short for quite a few types.
"Save board as ..."?
We should validate that's non-null (to fail sooner).
Why did we make this public?
This looks suspicious. If it didn't work in the two lines before, why should it work here?
Should not this method create a copy of the set just as getStages()?
The keySet is a view... So, the caller could run into a CME using the returned Set it the Map changes. Wouldn't it be better to return a new set created by the content of the view set?
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
reset compensation?
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
use put instead of offer
@magicDGS Sorry, I didn't notice this before, but this would probably be cleaner as a try-with-resources instead of a try/finally, could you change it?
Perhaps try-with-resources? And there are also tabs here that could be fixed.
Could this be a single try-with-resources block with two resources and a single statement in the body?
how about  java return method.isTestMethod() || method.getTestMethod().isAfterClassConfiguration();
static here and later
nit: missing curly braces around one-line blocks
Do we want to expose this to researchers? I don't think they have any need or reason to be looking at uploads
This pattern happens very very often throughout the code base and takes significant amount of space to articulate. I think adding a checkStateResumable might be in order. For example: java ... } else { checkStateResumable(progress == null, "There is already an upload in progress that was started elsewhere with upload id %s. Aborting local upload.", progress.getUploadId()); }
I stumbled upon this line with my basic knowledge: Why do you call log.e here instead of log.d? AFAIR log.e will stop the app in case debug mode is active. So for this informative logging log.dshould be the right choice...I might be totally wrong though.
When do you ever use the above service? And if you do, is it more than once?
Can we remove these empty new lines?
shouldnt this method be static?
+ desc
The description is incorrect. Should be something along the lines of "clean up empty pubmed id entries"
...if you do not provide...
Map
I think this should be headers.get(name).
Debug leftovers? ;-)
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
I see a default value for version in PartitionLayout but not here. Is this on purpose?
StorageException is a runtime exception, no need to catch and rethrow it (several occurrences).
for the us one could also let BasicController handle this by simply throwing the exception... (addd throws Exception to the signature of the method)
Are we sure that getAsInt will not throw?
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
what is this needed for ? why need to create one on every invocation ?
brokerRunning.getConnectionFactory() instead? I also think if that would be useful to expose CachingConnectionFactory from the BrokerRunning directly to avoid such a bean altogether.
No need to use ConcurrentMap.
is this the right check?
YOu can remove the syncrhonized block.
Can this method return void instead? I feel it's a bit funny to return the same thing we just provided as input.
minor: I personally think that 'this' is redundant here.
Please add TODO item that says that this should be removed before merged into the master
Not really that big of a deal, but a group matching seems safer. If for what ever reason this property changes to something like 11.0.0_02 this would return 0. Below is essentially what is used for determining the version for domains.  private static int getMajorJavaVersion() { int major = 8; String version = WildFlySecurityManager.getPropertyPrivileged("java.specification.version", null); if (version != null) { Matcher matcher = Pattern.compile("^(?:1\\.)?(\\d+)$").matcher(version); if (matcher.find()) { major = Integer.valueOf(matcher.group(1)); } } return major; }
@erimerturk let's rename this to ex
Just return checkNotNull(id, "id").split("/");
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
This, too, will now always create new configs and load them. Not what was intended. Again, the former code of openUserConfig has to be done here now.
Can we show that this method is not supposed to be used directly by consumers of this class by making the method protected?
We still need to start with the "Network Interfaces:" header here.
What are key/value types ? Map<String, String> ?
what guarantees getParameters().getNetworkId()) represents a real network ?
Should this method be final?
A slightly different behavior. Before a null parameter (byteArray) raises NPE, now it return null.
Not a big deal but we have a custom implementation for the toString: <LINK_0>
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
With these changes, the test should fail as no exception is thrown anymore. The only reason this still passes is because there is no fail call before the catch block. Can you adapt the test to make sure it tests what was tested before?
Why is this not singleton?
why is this unsuccessful ?
I think it should be return true, as well as in sqlCompatible, because returning different in non-sqlCompatible and sqlCompatible in fact makes this method dependent on this config, that you mentioned during the previous round of review shouldn't be the case .
Constructors can call other constructors in Java, so this should also work:  this(name, signature, ImmutableList.of())
no need to include _random as an argument since it's already an instance variable.
add requireNonNull for clazz
you can just return false here, even better : return trace instanceof TmfExperiment && super.canExecute(trace);
In the plugin.xml, you said TmfTraceStub and now you make the check for CtfTmfTraceStub, that is not coherent (even though I think it will fail elegantly).
Iterables.any(trace.getEventAspects(), aspect -> aspect instanceof ITmfCounterAspect); ?
what else? any warning or exception should be there?
assert name != null;
I see no reason for the setters to be public.
Unknown file name and known line number? Should that be an error?
cannot guarantee that these are non-null, so cannot simply construct this. IMO, it's reasonable to do:  StackTraceElement element = new StackTraceElement( getClassName().orElse("UnknownClass"), getMethodName().orElse("unknownMethod"), getFileName.orElse(null), getLineNumer.orElse(0));
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
suggestion if (server == null || server.getUrl() == null)) { return this; } if (servers == null) { servers = createList(); } for (Server existingServer : getServers()) { // If a server with the same URL is found, merge them if (server.getUrl().equals(existingServer.getUrl())) { ModelUtils.merge(server, existingServer, true); return this; } } // If a server with the same URL doesn't exist, create it servers.add(server);  reduces complexity
Try to avoid conditionals like if (condition) return true else return false. Just return condition.
WSTUtils.LIVERELOAD_SERVER_TYPE.equals(server.getServerType().getId()) is even safer, as it covers the _unlikely_ case of having a null id.
We don't need to minus LOCAL_TZ offset for TimestampData, the millis is already an epoch milliseconds.
((Number)objectValue).toDouble()
you can use Minutes.between(currentTimeLocal.withTimeAtStartOfDay(), queryDateLocal) to compute the difference or use a.isAfter(b)
isn't the currentRow the instance of RowBuilder which was just added?
why delegating
ts appears to be in microseconds, putDate() expects millis
Wouldn't it be better to do this in the constructor and have a final variable with it?
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
should the message include "command _with options_:" + this.options ?
Typo: a**c**quire Also, shouldn't we iterate in this method until we don't obtain the lock in DB? Or do you mean that TX guaranties the blocking wait for us?
Should it be an error to call this method if you can't actually get the result set? Feels like it strongly indicates misuse / coding error.
Could change to ProcessInstance.STATE_ACTIVE ?
I see a problem with this error - user doesn't know where the expected type comes from (it is already added from other task).
similar here, append correlation key only when it is running in case context
Do a detection.  if (e instanceof RuntimeException) { throw (RuntimeException) e; } else { throw new RuntimeException(e) }
I tend to think that this should just return - I think it's totally reasonable that I as a user might first close the writers independently (they do implement closeable after all) and _then_ close the pool which is going to call these methods again.
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
we should also check for n <= 0 here
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
it would be easier to understand, and way easier to see whats going wrong if something breaks, if youd also compile a expected and actual list and then compare them with arrayEquals
should this be in a finally block to release in the case where an exception occurs?
please create a more specific exception that extends this one.
IOException comes from API signature, so there's nothing we can do there. You can add a release() with the LightblueException.
Not sure whether worth doing, but since the only usage is "DownloadImageManager" (that is in the same package), it is possible to remove "public".
I think we need something like: if user specified initial size: set initial size So vdsm will get the initialSize argument only when user specified the value. A bad use case is when user did not specify anything, so getActualSizeInBytes() returns 0, and we send 0 to vdsm when vdsm should use the default initial size. initialSize=0 is valid input in file storage when you want to avoid prealloction. I'm not sure it is valid input for block storage and if vdsm will reject this.
check if not null
<LINK_0>
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
Overdid: "foo" is String already :smile:
Don't we need to fix up the ID and timestamp, like is done in read() ??
Will the exception thrown also contain the message contents/headers that could not be extracted for logging?
Here return getName + '=' + formatNumber(getValue(), base); // trailing space it would be nicer.
How about using a domain something like javatest.realm.io?
If we continue to use a StringBuilder here, we should use it in a way that makes sense.
Use MethodType.DERIVATIVE.getCode() and MethodType.MAINTENANCE.getCode()
Might give this a shot, if the type parser is indeed fixed?
Please use the fully qualified name java.util.Optional instead of using Optional.class.getName(). Main reasons are: - We usually don't want do add external dependencies (even if in that case Optional is provided with java8), in order to guarantee compatibility - If Optional changes its location in a future version of java, our check is not going to react the same way.
Please use the URLUtil methods here as well.
java.net.URI has an isAbsolute() method might be better to use that.
suggestion return (endpoint.startsWith("s3.") || isAwsAccelerateEndpoint(endpoint))
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Expose Map if you can
nit, Collections.EMPTY_MAP?
Can we adhere to the coding style of this file and not have multiple return statements?
+ desc
Does this code need to verify that the activeAwardAccounts collection is non-empty?
do we need to check for nulls here?
the else is not really needed here since the code after won't be called if the if condition is true and the method returns.
Is a plain "else" block also needed here to at least log the cases where no PaymentWorks processing is needed?
kind of curious what these magic numbers are
So we basically use this to bypass hostname verification?
You're testing two completely separate features of the class: 1) closing of environment, 2) converting environment to string. There should be two separate test methods. This anti-pattern is sometimes called "Test it all" (<LINK_0>
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
synchronized can be removed.
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Does this mean that new null handling unconditionally adds overhead in groupBy query processing?
Could use Double.BYTES
This null check should be done in line 274
OSGP code conventions are not followed (missing this. before referencing a field).
Use Optional here to avoid NPEs for caller, I think we introduced an option at some point, ask Edgar pls
Same here: include context in the log message (e.g. which instance we were connect to)?
Can you include context in the log message (e.g. which instance we were connect to)? If someone is running multiple MongoDB instances then need more info in log.
Is it an exceptional case for ConfigLoaderFactory to not be present here?
Can be private, I think
revert formatting change?
line length
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
Recheck some of these please. In Java, all non-primitives are just references, so these lines will not be making deep copies unless you do something like .cpy() which you have done for relativePosition. width, height, relativeAngle and relativePosition will be deep copies with this code. texture, drawableLevel, and tint should all have clone() methods
Can an ArrayValue ever equal something which is not another array and thus an instance of SequenceValue? I would assume that this row always returns false.
I think the granularity should be 1 seconds instead of 5 seconds here.
We should add a check to make sure the end time is not in the future by comparing it with the current time.
getNextTimeAdjustedByDay -> DateTimeUtils.getNextTimeAdjustedByDay
should have public modifier, for consistency.
Could avoid this local variable if you store fHeight inside the if clause, if you feel like it (also, this. unnecessary).
The method is "getItemFromRegistry", not "getItemTypeFromRegistry". Shouldn't the error message read "Unable to get item for item name {}" ?
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
The field state should be read into a local variable outside the loop.
For future PRs, we use /* package */ to designate package protected methods.
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
should this be transforming the list of InputRow to TransformedInputRow?
ArrayList.remove() internally moves the positions of remaining elements and this will happen for every row in this case which could be expensive. Since parsedInputRows won't be large in general, I suggest to use an iterator on the list instead of modifying the list. java public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; }
Please close client at the end.
restore might fail with exception => client should be closed in finally block
I suggest to clean up the client in the same class where it is created - in the parent AbstractMessagingTestCase.
This is nice to see. We should have done this to begin with.
Please change message to: >We detected that a machine exited unexpectedly. This may be caused by a container in interactive mode or a container that requires additional arguments to start. Please check the container recipe.
not needed, can't happen (don't trust your IDE on this one ;))
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
@robbavey don't we have to release this ByteBuf after we've deserialized its contents?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Seems redundant to have both static factories and public constructors in the public API. Especially when there's multiple overloads such as in some of the other processors. Can we choose one and expose only it?
I'm having some troubles understanding why do we resuse the sampleRowKeysAsync RetryableRpc, but create new ones for mutations. Could this be made to match, say, checkAndMutateRow? Oh, I see, it uses createStreamingAsync. But should we reuse? why not for the others?
nit: UnaryOperator<Transaction> across the board might save a bit of repetition
Let's rename "ignore" to "ignired" Please use fail(): <LINK_0>
Let's rename "e" to "ignored" Please use fail() <LINK_0>
Let's rename "ignore" to "ignored" Please use fail() <LINK_0>
If a filter is applied directly to the TimeGraphControl, the listeners won't be notified. In that case, perhaps the TimeGraphViewer should be the sole owner of the listener list, and the one to fire the events. Otherwise, the TimeGraphControl should fire the events when addFilter() or removeFilter() is called.
requireNonNull?
Should this be a CollectionUtils.isNotEmpty check instead of a != null for efficiency?
Same as above - log or throw the weird state.
This line should be removed or change "stuff" to something more meaningful.
you have already got listView as parameter, so no need to call "getListView()"
To be safe, should check gerritTrigger.getJob() != null first.
StringUtils.isEmpty from apache.lang3 I think
Not true!
Isn't nextInt(0, n) the same as nextInt(n)?
why do we use this. on getters but not on alpha? I would skip this. all together here and use getAlpha()
I think this is unnecessary => "profile =" + this.profile is sufficient.
Why new? There does not seem to be anything "old" here.
Could be simpler to use [StringJoiner](<LINK_0>
I'm concerned about this lock.. it doesn't seem necessary as each operation invoking this private method is guarded already, and whenever a thread needs to acquire two locks I have an alarm bell ringing in my head.
Let's please have this throw an exception if a null predicate is given. Something like: java if (allowedHostnames == null) { throw new IllegalArgumentException("allowedHostnames cannot be null"); }
Do you want to hash allowedOrigins.hashCode or just allowedOrigin? The latter is more consistent.
Same as above. this is deprecated and should no longer be used.
Add final keyword.
Is this a "silent" operation, if the configuration didn't exist at all?
Hey, would you mind changing the name of this logger to lowercase? Everything else looks great and you can proceed with self-merging it after this minor change request.
log and throw anti patttern
Don't do log and throw. Just throw is enough. Also wrong formatting ",e", must be ", e"
log tenantDomain and idp name if possible
also check this
If we're going to abandon focus, should we pause automatically? still giving the user the option to stop?
Causes NPE in requestAudioFocus(). Remove audioFocusRequest != null and audioFocusRequest = null here to always reuse one audioFocusRequest. I guess, just Log.d() if AudioManager.AUDIOFOCUS_REQUEST_FAILED.
Assert.notNull(expiry,..) checking might make sense here
why add to one list and then addAll to the other? why not add directly to the target?
Nit: you can use Duration.ZERO;
we should not throw an exception here, simply ignore
I can remove and update. (from all the references.) These were just to let you know what was changed.
I see NPE's here...
<LINK_0>
<LINK_0>
Why are you catching and ignoring? as above, if you catch, you should do something, if you wish to ignore an exception, please say so. Typically using the word "expected" as the variable name. <LINK_0>
Fixed. Passing style as argument for setUpDepthFillLayers() and setUpDepthNumberSymbolLayer()
Not sure what this do/while statements doing here.
use style provided with callback instead
Whoops, this needs to be the other way round (the first block is for ExecutionException and the second is for InterruptedException)!
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
Make it a static method in ExecutionExceptions or similar class?
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
not sure that the outerType is needed as we are trying to compare two Host instances
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
Could you add an assertion on one of the associated props? Just to be sure...
(nit) Simplify into the same string? suggestion String query = "SELECT count(*) FROM " + getTableName();
This is already logged at INFO by the caller, so let's remove this log line
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
Good note. I think USER_PORTRAIT would be better so it works upside down too
This is considered a bad practice. You should only retain a fragment for a dialog that returns no view, so onCreateView should return null. Anyway you already use a DialogFragment (they don't leak on rotation), and RN in manifest also says that do not destroy the activity so you do not need this line.
This method is only called by popAndRedirectMessage() right? Would it be better to move the logic into the upper class?
Does this Listener mean we can only process one event at a time from qpid? I.e. we can't get another event until the EventManager stores it? Hrm maybe this is why registers are slow.
In popAndRedirectMessageToStore we return false if a message is not received. Shall we do the same here?
@apc999 This needs to be public or reflection will not work
This is already initialized by super class.
Can you override the Command#close() and close this client there?
Any reason in particular that it shouldn't give the effect to players?
Can you make this mod be disabled by default?
java looting = getLootingLevel((EntityLivingBase)target, cause, looting);  This code is already in ForgeHooks class.
It looks like drain is expected to throw an exception. If I am right then you missed to call fail just after drain to make sure that drain thrown exception. Alternatively you could use: org.testng.Assert#assertThrows or  org.testng.Assert#expectThrows
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
We don't use final for local variables unless some lambda execution demands it.
submit?
why ConfigurableApplicationContext, not ApplicationContext?
Collections#emptyList could be better.
Don't use printStackTrace() and instead write to the logger using log.error("<Appropriate message>",e);
By the way, name the reporter thread.
If storeThread == null concurrent tryCommit() or deregisterVersionUsage() may change its value between get() and set(), they are not synchronized like this commit() method. It looks like compareAndSet() should be used here too instead of set() or something else should be changed.
can this just be collapsed into a single writeAndFlush() call?
is this required ?
@kachayev one question... isn't this assuming that we are talking HTTP/1.1 ? I mean for 1.0 we would need to add the keep-alive imho
please add new HelpTag and HashName (as in StorageListModel)
consider a ternary statement instead...
same consideration
suggestion processInstanceIds.forEach(processInstanceId -> {  You dont need to use _.stream_ to access _forEach_
Could change to ProcessInstance.STATE_ACTIVE ?
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
This should check to make sure that notificationUUID is not null before attempting to delete it.
check to make sure notificationUUID is not null
It doesn't look like you are doing anything with the bucket here. This can be removed.
Noooooo!!!! this needs to be configurable. At least the admin password needs to come from the pom, or any installation of Quadriga will always have an admin account admin/admin. SECURITY (to channel Abhijith...) ;)
dont put username and password in exception ..add it as a debug log
Maybe have an overload that doesn't require this since it isn't used.
can be replaced by List.of
can be replaced by the use of List.of
You could instead have a storeTTL option taking a string and parsed using DurationUtils, for more readable config. Actually I see other places already using storeTTL and using that so something is inconsistent.
Per IRL, I meant to say uploadApiBase. This is fine too, but unrelated.
This should probably be builder().build() instead of new Builder().build()
The "agent" field needs to have something in case the underlying consumer library makes setting a custom User-Agent infeasible. The URL-encoded custom UA would be fine for the "agent" parameter.
the default one should be fine, isn't it?
Why do we return the parents name instead of the name we store a few lines above?
Please use the Spring's Asserts for that, for consistency with rest of codebase
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Does a type-hint work instead of casting? return ofAll(toList().<U> zipWith(that, mapper)); (Probably not, just a question.)
No lambda param type needed, we use the simple form result -> ...
don't catch, but instead allow the ExceptionMapper to handle it
Unnecessary.
Should we return here?
You can look at using a joiner: <LINK_0>, which will join this iterable of string
consider doing this in a loop, till the user have entered an input which isn't null?
again a loop?
don't forget default case
Left over from debugging?
Having a try/catch block here makes the code harder to read and duplicates the error handling code. I suggest creating a new method that gets the recipients from a message and handles the exception.
Please log this exception, maybe with a WARN level
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
If a test is going to disable the table (or do things that would interfere with other tests), I'd prefer a new one were created. Though, I am aware of wanting to limit table creation.
Add requireNonNull
I'd rather not synchronize it here. It sounds better to check in the constructor whether config is null and instantiate the default object with new ZKClientConfig() in the constructor, in which case we can remove this if block from here, or at least keep it here just to assert that clientConfigis never null. If we do it, then we can also make clientConfig final.
Could you explain why you change config key name from "kubernetes" to "agent..." ? I guess original code is better. Because Docker has same configuration naming. And "agent..." is longer to define in WF definition.
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
We normally don't include the m_ prefix in the toString labels. While we're changing this, consider using MoreObjects.ToStringHelper.
suggestion "\narmed=" + m_armed;
Worth initializing to raw.length+32, to save in-line expansion when writing out the byte array?
content.getBytes() doesn't use encoding in this case. In method writesToFile, line 132, encoding is used content.getBytes(StandardCharsets.UTF_8). I suppose it doesn't matter to use or no encoding for ASCII symbols, but lets use one style (everything with encoding or everithing without encoding).
You're not closing DataOutputStream. Check SparseVectorCodec too.
You need to check in the set\* methods that the custom attribute name doesn't clash with a common attribute name to prevent users from producing invalid XML. Throw an IllegalArgumentException if so.
Actually the two cases (wrong flags and wrong regex).
I would prefer constant there.
nit: style wants newline
It would be great to cover the util method with tests.
There should not be a need to set this to public. Perhaps private would be better.
Do you need the fully qualified class name here?
You should throw a WebApplication exception with a JsonError as entity for the client to receive a valid JSON.
This should just return 404 HTTP error code (not found).
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
add the instance size/object overhead of MergingPageOutput
return Long.compare(sizeInButes, other.sizeInBytes);
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
consider fail-fast with checkNotNull(serverContent)
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Why we removed final?
This will not work on a runtime-system
You actually don't need a whole Project Object becaus you only work with lists of project, please change the functionality to only work with lists, by now
I suggest you reset colorPreviewImages to null after that.
JFYI, there is a org.eclipse.jface.resource.ResourceLocator.imageDescriptorFromBundle(String bundleSymbolicName, String imageFilePath)
This is not equivalent.
Likewise don't need the if statement since the optional value will return empty.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
Do we have the sitting key value for wolves? IF it's just a key, you can: suggestion vanillaValues.add(this.angry().asImmutable()); this.getValue(Keys.WOLF_SITTING).map(Value::asImmutable).ifPresent(vanillaValues::add);
Since I'm suggesting creating the Response with the input stream this could simple return it now
@fabriciofx Here also, we could return the body() of our decorated object directly
Please use TIME_FORMAT instead of "HH:mm:ss"
Maybe remove the .method("POST") here as you are calling it on create() method
Is there an effective difference between awaiting 0 or just not awaiting?
Given that one of the main goals of this code is to be as fast as possible, I believe this should not use a regular expression but a startsWith or something similar.
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
If this has to be a GroupReference, just take that as an argument.
Minor - unnecessary explicit type argument declaration for the HashSet initilization. Suggestion Set<IProject> projectSet = new HashSet<>();
brokerRunning.getConnectionFactory() instead? I also think if that would be useful to expose CachingConnectionFactory from the BrokerRunning directly to avoid such a bean altogether.
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
should we do the same as in the original implementation and log that we use the JDK implementation ? java InternalLoggerFactory f = JdkLoggerFactory.INSTANCE; f.newInstance(name).debug("Using java.util.logging as the default logging framework"); return f;
static import sizeOf (also in other stream readers)
This method is unused
ditto about getRequiredBytesForSerialization
No need to use UriBuilder
No need to use UriBuilder
No need to use UriBuilder
No need to cast, a ServiceProvider has the method you need
hmm, do you test the rest service for update? What about if you try to update a given provider (without to change the name)?
This is already checked via enabled() and does not need to be checked twice.
I would not call the leaderContender under the lock because of the risk of introducing potential deadlocks.
Again, we shouldn't do this.
Yikes. I didn't see this before. Is it in master?! We shouldn't unwrap ExecutionException like this. It makes it look like the exception happened in this thread, rather than in the other thread. For example, if the other thread was interrupted then ExecutionException.getCause() will return an InterruptedException. Rethrowing the cause make it look like _this_ thread is being interrupted (and looks like the interrupt is being handled incorrectly, because it is just caught and wrapped without marking this thread as Thread.interrupt().
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
Asserting the exception type is sufficient.
Same goes for this one :)
you can just return 'Collections.emptyList()' - permission check is unneeded as the command is executed only internally
sorry i missed that before, you should send "getActionType().getActionGroup()" instead of specifying the actionGroup here, and specify the correct action group in VdcActionType enum (where currently it is wrongly MANIPULATE_USERS it should be the new EDIT_PROFILE
make permissionList private variable, permissionList should be created only once
you can actually use the returned boolean value to nullify astroDiscoveryJob and print the log.
This is wrong, because this will try to cancel *all possible* dispatcher jobs, not the jobs of the current dispatcher.
We should not force all of the refreshes
This isn't needed. Actually I think that one constructor is enough, put everything here: super(ClusterFeature.class, ...); this.clusterId = clusterId; Also consider using Guid instead of String for the type of the "clusterId" field. The caller of this constructor will probably have converted it already.
all services are closeable, so use IOUtil.cleanupWithLogger() & let it handle null checks and exceptions
call forEach at once, without stream()
agentDisconnect also sets this state.
sgtm
Let's use the new NETWORK_FACTORY permission that Paul is building in aosp/1099096
ImmutableSet.copyOf(Iterables.filter(...)) ?
ImmutableSet.copyOf(Iterables.filter(...)) ?
why the newArrayList? Iterables.filter already returns an iterable.
Can this happen ?
You can remove the unchecked warning by doing:  T service = clazz.cast(services.get(clazz));
I would expect this to obtain the version rather than assume emptyVersion. I would consider adding an IProgressMonitor to force getting the version if it hasn't been cached.
Same here, using a process containing a user task would allow to check the variable valued after the connector execution.
Usually we let the test throw the exception.
You can skip the process clean up here as the processes are already being deleted in @After method.
Mid return may worsen readability
Do you need the inOrder here? You're checking for a never and then for a single call. Wouldn't it be the same if they were not in an inOrder?
suggestion this.downloadService = requireNonNull(downloadService);
else is rendudant
You can use StringUtils from the commons.lang3?
This should also include int, boolean, and any other types that are supported in the CSV conversions.
ditto, here and in other places.
this will have additional cost even if tracer not enabled. i see in the code withContext is doing Map creation etc. we should short circuit this if tracer is not enabled.
Why decryption is excluded?
assertThat(element).hasTotalSize(6)
assertThat(result).hasId("analysis")
s.o.
having wallClock = 4 for atlasTs = 4 is potentially confusing (ditto below with 6/6).
The mixtures of thorough and conservative are confusing here - I can't tell what each step is supposed to do.
The name is very confusing, assert equals seem to indicate it should take 2 parameter and make sure they are the same. I know you mean to assert symbols from Expression and RowExpression are the same, but you really can't tell from here. Maybe just call this assertSymbols.
Because there is only one argument, we can pass workerMetrics instead of an object array.
This mechanism is a bit different from other apps; the number of push/pull requests are done numberOfUpdates times numberOfKeys in one iteration. On the other hand, Dolphin apps (e.g., NMF, MLR) update models by sending push/pull requests in one mini-batch. Could we go with the same semantics?
please have intellij auto-indent this.
how can a clusterName be null?
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Is it required for the upgrade?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
super.init() method never throw an exception.
Please rebase develop and use the argument constants from class JobParametersNames.
shouldn't this be: donorRepository.findDonorByDonorNumber(donorNumber,true); since we're including deleted donors
in latter days we use org.assertj for assertions :)
style: extra parentheses
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
We don't need this. There is each method in AbstractMatrix class that has the same logic. And we can't do it better than there.
We don't need a separate implementation of each method for CRS matrix. We already have it in AbstractMatrix.
Mappers can be stored in static final variables instead of rebuilding these each time.
I wonder there is a better place for these 2 methods. If I was looking for this functionality. I wouldn't think to look to AbstractFragment. I don't really have a suggestion though, just thinking out loud, I guess. Edit: I just noticed that these 2 methods are the only static ones we have in AbstractFragment, which I guess can be a good reason to think about moving these elsewhere.
remove public
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
Pattern.quote, note that we shouldn't change stringPayloadPattern itself, this should be used only when compiling it otherwise in the UI we show something different than what was specified by the user.
why have you removed the static?
since we have done the same logic in multiple places, shall we move this logic to some common place, like mappingUtils?
Can you remove "identifiers" and use "registryList.getIdentifiable()" as part of the enhanced for loop?
Should there be another method for instances when you already have the MetricRegistry? I am using Dropwizard where a metrics registry is created by the framework and I would like to make that instance the default. As proposed:  java SharedMetricRegistries.add("default", bootstrap.getMetricRegistry()); SharedMetricRegistries.setDefault("default");  With the overloaded setDefault method.  java SharedMetricRegistries.setDefault("default", bootstrap.getMetricRegistry());
please add setSoftLimitInterval() setter and use it.
as this is not interactive command, I suggest you do not call getDbUser twice, drop the canDoAction entirely.
The parameters may be modified by the command. So, if you need to pass parameters to a subcommand, you need to copy them.
@fanifieiev Let's put this in a constant.
@fanifieiev Why not use the constant here too?
... remove the final modifier from the method. It will be easier for future tests.
retrieve
Does getEmails2 always return a collection? Take a look at code to be sure. Concerned about possible NPE.
We get to rename this variable to prefix it with is I guess
Returning false seems fine, you could also return (enable == modifier.isEnabled()) to make it clearer.
This should always be read from the configs.
I suppose this should be true ?
Code for this method could probably be taken out into a separate method - with a Consumer parameter for the particular view method call - and reused in the next few methods.
This can still return HistoryReferencesTable.
I think we should consider the case sensitivity here.
Needs to consider the new custom fields.
shouldn't we also consider the name?
should we consider label as well?
it would be nice to assert here that the actionBar is displayed. (so if it is not visible, and onActionBar() is called, it already breaks here with the error that the bar isnt there instead of later that eg. the title doesnt match)
same as above with the actionBarWrapper
maybe sth like content.avro.deserialization? so in the future we might add content.json.* metrics, it would be weird to have .json as root metric
@agentgonzo I don't think there is a need to keep this synchronized anymore is there?
Would be simpler as: return Arrays.asList(Action.RELOAD);
Could change the return type on method to Collection
What is the reason for appending 1 to the variable name?
What is the use of the nullEncounter variable?
include creating visit in ITs
user.get() can return null
This is going to fail in case we get an empty list (yes, an edge case, but still... a check on the size would probably be safe). Or perhaps an empty list has a special meaning?
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
are these setters used anywhere?
Please make the constructor private (see Invalid).
I wonder if there's not a reason to just let it auto-box?
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Same variable names (change to senderVouches.
remove this local var . It is not needed realy. In the next line just write "general"
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
On START_DATE, the discount factor for start date should be 1.
Do we need a tolerance here?
tolerance?
What made you to wrap, when you still use a simple long afterwards?
The integration tests are failing every time in TravisCI. I think this is because this line is allocating a Transactor ID which changes the numbering expected by TransactorIT.  Tests run: 4, Failures: 3, Errors: 0, Skipped: 0, Time elapsed: 9.323 sec <<< FAILURE! - in io.fluo.core.impl.TransactorIT testTransactorAndCache(io.fluo.core.impl.TransactorIT) Time elapsed: 2.131 sec <<< FAILURE! java.lang.AssertionError: expected:<1> but was:<2> at org.junit.Assert.fail(Assert.java:88) at org.junit.Assert.failNotEquals(Assert.java:743) at org.junit.Assert.assertEquals(Assert.java:118) at org.junit.Assert.assertEquals(Assert.java:144) at io.fluo.core.impl.TransactorIT.testTransactorAndCache(TransactorIT.java:50)
Can't we use newly introduced AbstractMessageListenerContainer.getRabbitAdmin() here ?
can be String::valueOf
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
There's no way to use constants for those ugly hex values, is there?
minor suggestion: It is perhaps simpler to set a local variable for storing the exception value. Inspect its value in finally clause and then, take action.
Make this "info". there's relatively fewer operations scheduled on the executor, and would be good to log their completion status
Operation operation = snapshotTable(snapshotName, tableName); if (operation.isDone()) { return; }
Get the service registration reference and unregister within the deactivate method
we shouldn't commit this change
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
Let's re-word this to a forced shutdown
Did you intend to leave this if test here? How do we get here with the above return?
one param per line; leave the first line empty
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
There's a possibility that - if this test group is executed in parallel with another - the post created above will not be the newest on the list. So the assertions below would fail. Do you think we could find this particular post by first getting to a page with posts by this user?
The StringBuilder is not necessary here. Just do this:  java if (url.contains("?")) { return url + "&user=" + googleId; } return url + "?user=" + googleId;
getUsage(...) expects a localization key.
Pretty sure this is also supposed to just be the localization key.
getUsage(...) expects a localization key.
Our standard convention is to prefix with this for instance members - return this.context
this.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
How do you know that tableName is not, itself, an SQL injection attack?
Hmmm... This pretty tightly couples SQL string with the prepared statement in terms of parameters. I'd go with approach that schema creates the statement with given parameters (aggregateIdentifier, and sequenceNumber in this case). What do you think?
Should this be similar to other parts of the API where if connection == null get call get Connection and if not we use the instance?
You get it right. Per code conventions, I like to see brackets around if and else clauses.
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
Can be rewritten with Arrays.asList().
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
Perhaps you can remove the temporary variable entirely and use map to make this method a one-liner?
Should probably be declared final.
0 -> 1
Please fix formatting.
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
withMillisOfSecond(0) is not necessary here if it is used above.
~~The tests are not covering the bug that you fixed. I can change back this line and your tests still pass successfully~~ nvm, i realised my mistake.
Similar
Similar
Verify the injector has been set before using the delegate here
Please remove this line
Could this just be a plain getActivity() call? Any reason you need a BaseActivity for startSupportActionMode?
Can be transformed into an if statement.
In the original code, we throw a runtime exception if the native snappy is not found. Should we follow?  throw new RuntimeException("native snappy library not available: " + "SnappyCompressor has not been loaded.");
Is it the 'native snappy library' that is missing or the java-snappy jar?
If we are changing this code, then relying on Optional could be a good move.
Use braces for all if statements. Alternatively you can use one-liners, but braces are typically preferred.
If from can't be null don't declare it @Nullable.
Why *NodeStartTime* changed during it's request?
I think this should be > 0 since a value list item of 1=One does not work.
If the input string is "(123(456)" this approach will strip the middle bracket and parse when it shouldn't. You'll need to use substring()
Is this still needed after removing the download stuff?
I think isConnected() would be appropriate here since you're saying "active" network connection. If we allowed the "connecting" state then we would need a BroadcastReceiver to delay the (re-)try until the network connection has been established.
you can collapse these 2 lines
It doesn't seem that you did what I asked for. It should be checking the toggle in addition to networkinfo. If the toggle is set to offline then it should return false. If the toggle is set to online then you can check network info and if there's no connection set the toggle to offline and return false, otherwise return true.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
should this count be parameterized?
For loop?
Needs to be in finally - we might get interrupted.
should this only be set if the latch.await above returned true? in the current impl I don't think it would make a difference since clientTimedOut is checked prior to clientHasReceived in the if/else below, but that order could be a fragile assumption
finally?
Redundant with the e.getMessage? May be something like "Wrong class path: e.getMessage"?
This is a safeguard in case the operation fails and the user won't have a potentially corrupted file, correct? If so, would we want to log a message here stating that the operation wasn't able to successfully complete, cleaning up resources.
I believe this can be simplified to java catch (OperatorNotFoundException e) { throw new OperatorNotFoundException(...); }
I don't understand why do we need to call hasNext() here? we can just use this.iterator.next() and let it throw if there is nothing left
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
Adding this to a field is good manner.
I think these will crash if there isn't an app successfully seated yet. Usually good to wrap these reporting helpers in a try/catch so that we guarantee we get the report
You shouldn't depend on AWM just for this. The application index is not an AWM app. You should use directly getUtil().gotoPage().
This is another behavioral change that I don't want to see in an unrelated PR.
please use java.util.Objects.toString(username, "") instead
Any reason using full class reference instead of importing it and using just a class name afterwards?
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
suggestion muteButton.setColorFilter(ContextCompat.getColor(getApplicationContext(), isMuted ? R.color.white : R.color.gray)); }
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
Maybe diving to deep into the state machine pattern but to me it would feel more consistent to have all these methods use a switch. In my head that makes it easy to skim through and see what states the method cares about and what it does in the default case.
I think this also should not change if the accuracy isn't better, since otherwise we are updating the location in the background but not changing the reflection of it
Maybe we could spice this up a tad to throw in another nice aesthetic change?
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
need to change as well
Same here, keep the order consistent with BenchmarkSuiteConfig
Removing the interceptors removes logging.
Mock this also.
Marking this as a high-priority functional correctness issue.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
... remove the final modifier from the method. It will be easier for future tests.
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
Use this.key
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
return data.stream().mapToInt(CurveParameterSize::getParameterCount).sum();
This makes it illegal to select index 0... should be >= 0
return sum here instead
No big deal, but if you modify anyway, you can add a break here.
rename to entry
rename to container
I'd recommend using <LINK_0>
speces before and after "+" :)
Its worth adding a null check here too.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
!fEventsQueue.isEmpty() would be clearer
remove the "this."
If this fails, it would be good to include "security.refresh-period" somewhere in the exc msg
we should skip this if the config file doesn't exist otherwise this throws a NoSuchFIleException
you could put the check for config==null into isNfsSupportEnabled. If config==null then isNfsSupportEnabled would return false
Simply return the id. It's either a ticket id, or a JWT. Right?
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
Can we refactor both of this if else if into one condition ?  java if (!accessToken || (accessToken && expiresIn() <= 0)) { accessToken = generateAccessToken(); }
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
Please use {} for every if/else/for/etc. block.
this just calls abortBuild with a null editor, so why not just delete the if and call abortBuild(build,editor)
Optional makes the JS API less intuitive and cumbersome. Hence let's remove Optional.
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
This is the one place we should crash and burn.
fos can be inside try ()
I think try with resources should be used.
As written, this inputStream will only be closed if any of the code above does not throw an exception. Normally to solve this, you would add a finally block after the catch, and close it there, so that it gets closed no matter what. That said, [whoever opens a stream is typically responsible for closing it](<LINK_0> Since the customer will be opening the InputStream, I think we should leave it up to the customer to close it.
We don't need super here
This should have been changed to: this.market = m;
redundant ";" character
For loop?
@fchauveau there is no null handling of source, is this intended ?
For each?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Should we use .getMessage() as in the remove() or .getLocalizedMessage() as is done here?
What should be the expected order? Is there any concerns about this in the API definition?
Just return the if case statement
Would it work to drop the iterator and just execute  operations.forEach(this::add);
The count should have a consistent data type in all signatures. That way, we use strong typing in the compiler to eliminate the possibility of a runtime error on the cast. The design should have specified long throughout. Apologies for that design error.
Do you have time for this? We talked about it on Slack.
It's not a _really_ expensive computation but how about using orElseGet?
I think we should leave getClassName() and getMethodName() as is but _only_ pass them to PojoStackTraceWriter to "optimize" the stacktrace.
how often is this method called? Why not cache this computation like you did the others?
Oo now that this takes a stream, can we just remove the collect above?
Actually the underlying objectExpr could have free variables.
this can also be .map
You don't need to call .getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
Better to return "";.
Should this refer to a platform-relative constant?
Should invoke object.toString()
you don't really need to populate the builder if expectedTypes contains actual.
Change to use this.jsonAsString.hashCode().
use use java.util.Objects
return (id == null ? 0 : id.hashCode());
Could you update this method to include "AbfsPerfInfo" introduced by HADOOP-16612?
Should this constructor one just delegate to the new one with Function.identity()?
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
This looks like testDataFormat(COMPONENT); Please see other tests for sample
this one should be testing against EAP_7_2_0_TEMP too
I wonder if the subfolder "with_sample_data" is necessary. Couldn't the test app be placed just under direct?
You should use assertNull.
As mentioned earlier, these calls might need to also regenerate the iterator. Please double-check.
Arrays.asList(metrics) is simpler
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
loadClass(type) will throw ClassNotFoundException if not found. Better to just catch that rather than generic Exception? e.g. if bundle name was invalid then fine to throw exception rather than just returning Maybe.absent().
same as above... why not use simple if/else here?
I understand that this popup works only for VM and not for pool, so the fact that model.getModel().getVM() returns null for pool is not handled here. But still, it is an invariant for this class that it works only for VM and it should guard it. Maybe for easier debugging in the future I would start this init method with something like if(model.getModel().isPool()) { throw new IllegalArgumentException("The console popup can not be used with pool, only with VM") } or something like this.
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
This anonymous block is redundant. Also, please use the constants in Version: VDSGroup cluster = new VDSGroup(); setcompatibility_version(Version.3_5);
Likewise.
Copy pasted exception messages need to be adapted
I'd do: if (log.isDebugEnabled()) log.debug("Node {} added to Cluster {}", member, getClusterName()); And similar for onEntityRemoved.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
I think we should just return created property here wihtout any extra logic
Only except for compatibility issues, using the system time zone could be more dangerous. At least for our own use-case (as treasure-data ... this plugin is under github.com/treasure-data/), I believe it's okay to set the default to ZoneOffset.UTC. How about : * Check the system time zone in the beginning of transaction. If it is not UTC, dump a warn log that the default time zone has changed. * Explain the change in README and/or CHANGELOG explicitly. * Then set everything based on UTC (or configurable).
You may simplify:  actionsFactory.createAction(seleniumWebDriver) .keyDown(CONTROL).sendKeys("/").keyUp(CONTROL).perform();
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
I would retain the existing indexOf body to to avoid indirection in the most common case.
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
What do you think about making this method final? Just to be sure that descendants will override the correct method (validateImpl()) instead of validate().
those are hidden APIs, can we try use below mechanism to figure out firstboot? return Settings.Global.getInt(context.getContentResolver(), Settings.Global.BOOT_COUNT) == 1;
Is it possible to get rid of this?
A LinkedList is better since you don't seem to access specific indexes anyways.
why orgX ?
We can do disruptor().setDefaultHandler().handleExceptionsWith(), so, maybe, not "mixing", but something like "callToDefaultExceptionHandler is not supported and useless after exceptionHandler has overridden by EventHandler specific ExceptionHandler using handleExceptionWith()"
Could you change your code so that super.getHandler() is called only once?
Could you maybe look if this could be removed? I mean the new DefaultVariableNameFunction().apply(this). It's already handled in the other constructor.
use "1.0".equals(version) to avoid possible NPE
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
minor: this not required.
should we also lower down maxConnectionsPerDestination ?
Please remove this field.
shall we rename this as brokerUrl ?
merge else if?
how about doing it a bit different: change #1259 to something like: devices.stream().map(VmDevice::getId).forEach(vmDeviceDao::remove) and this method to something like: removeVmDevice(devices.subList(...))
don't need to wrap safeFormat
can simply to return period != null || cronExpression != null; If you use IntelliJ, it automatically suggests these refactors.
Nitpicking this change here - isn't this antipattern?
sed 's/value == STRICT.value ? true : false/value == STRICT.value/' (Redundant inline if)
no!
This is good, this thread does not cause the bad failures and dealock anymore. But it should mark the analysis as failed. And for very large traces, I think some failing mechanism should be put in place, to cancel the analysis. For instance, the waitForCompletion could wake up from time to time and make sure the analysis has not failed in the meantime. While this works perfectly fine, resources on a computer _are_ limited and it is better to avoid dragging this thread, and the request thread, and the threaded backend thread and some more view threads waiting for this, imho.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
Removed -> NotRemoved?
Why not <T>?
this looks like debug code
since its always called with true, would it make sense to have a kill() method instead?
Need not be initialized here
don't you want to log the exception on finest here? if something went really wrong then you might not be able to send even the exception. and then you would lose it.
Adding this to a field is good manner.
Shouldn't this just return true? I thought force meant unconditionally use RESTbase.
@stanislau-strelchanka - Why is this wrapped in a try/catch?
And BTW all Eclipse resource implementations are immutable so you cannot alter the hashcode in any way.
Need to add the else clause which fetches the Hibernate-persisted Project and replaces its updateable values with the passed-in project.
BTW a tip for minimizing diff lines in a PR: avoid changing indentation of long blocks of existing code if it can be helped:  boolean upgradeIfNecessary(AbstractProject<?,?> job) throws IOException { if (isUpgradeNeeded()) { int i = projectName.lastIndexOf('/');   return true; } else { return false; } }  This practice makes the PR easier to review, makes history easier to follow (especially from git blame), and makes merge conflicts less likely.
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
I think, it's better to transfer a method parameters and keep a name at a previous position.
Can be rewritten as: java return findAnnotatedClasses(annotationClass) .stream .map(Class::getName) .collect(Collectors.toList());
FileNotFoundException is a subclass of IOException
we can use try(BufferedReader...) {}
Use try-with-resources, to make the code more concise and to ensure that the reader is closed even if an exception is thrown.
Do you mind extracting 5 into a constant with a name like BANK_ID to improve readability?
Shall we mark this as deprecated?
suggestion
This shouldn't be needed as StatementClient.close() should be idempotent
You have yo use compareAndSet
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
Why going for semantic here ??
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
there is no need to convert to map. can we directly print headers ?
Would be better to validate the error message as well as that is what we will use to debug issues. java StepVerifier.create(collectRequest(httpRequest.setHeader("Content-Length", "4"))) .verifyErrorSatisfies(throwable -> { assertTrue(throwable instanceof UnexpectedLengthException); assertTrue(throwable.getMessage().equals("Request body emitted 4 bytes, less than the expected 5 bytes." }); StepVerifier.create(collectRequest(httpRequest.setHeader("Content-Length", "6"))) .verifyErrorSatisfies(throwable -> { assertTrue(throwable instanceof UnexpectedLengthException); assertTrue(throwable.getMessage().equals("Request body emitted 6 bytes, more than the expected 5 bytes." });
final here and below?
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Could we somehow get the name of the source into the log lines? I think that would tremendously helpful in cases where there are multiple sources (which are common).
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
Shouldn't it be return !isFromWire();
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
Use junit5 instead we are thinking about removing Junit4. There is a way in junit5 to write nested tests <LINK_0>
Why is this removed?
Could we prefer a proper logger instead of System.x - we already have a logback.xml in the module.
assuming this was for debugging, should remove.
Debug still needed?
Take a look at how shouldChangesRequireResponseDeletion is called. Do you need cast operation here?
- Test case for two references to the same question details? - Test case for null input? Basically, try to cover every statement for equal() you introduced.
I think MCQ/MSQ also have other weights which we need to hide
You can remove the inheritance from translator and make this method static. So you won't need to create any instances of EnumTranslator.
suggestion return format("metadata[%s]", key);
suggestion if (eventData !=null) {
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Let's call this method reset() or clear().
check for null
Request.State.OPEN
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
wait.. couldn't this be much easier by just making a request?
should be named resource
should be called resource
should be named resource
This needs to be changed to support locked stream syntax now.
I might be wrong but vValueHoder may itself be a null, if there was no mapping for the key.
Maybe: "keyFunction for partitionBy should not implement TimerFunction or WatermarkFunction."
Should we not assertOpen _before_ we readValue?
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
I know this is not introduced in this PR, but could we consider not allocating the buffer multiple times (here we would allocate three times, each in different levels of the object's serialize() function).
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
**Issue:** We are passing a snackbar error notification in params here which means any server call error will be shown in snackbar that is not according to design. Also we are not implementing new offline error design in CourseDetailFragment at this time. Replacing it with DialogErrorNotification might fulfill the requirement.
you can use Minutes.between(currentTimeLocal.withTimeAtStartOfDay(), queryDateLocal) to compute the difference or use a.isAfter(b)
can we check for value equality and not reference? equals. thx!
nit: you can do mLGNames = Sets.newHashSet();
checkState instead of checkArgument
It's safer to call getProperty("replicatorFactor", DEFAULT_REP_FACTOR). You should validate the arguments as well.
In my opinion it is not a right place to show internal representation of subscription name. It will be better to do something like: new SubscriptionName(subscriptionName, TopicName.fromQualifiedName(topicName))
logger.info("Skipping creation of topic {} on brokers, topic already exists", topic.getQualifiedName())
This code can be called from RefreshVdcOptionCache() method too, instead of it being written there also.
I would consider rewriting as: if (values == null) { values = new HashMap<String, Object>(); _vdcOptionCache.put(option.getoption_name(), values); } values.put(option.getversion(), GetValue(option));
why not using addAll?
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
finals all around.
Since the data set is the same for JobRecoveryTest (and because it is interesting to always test both JobRecoveryTest and NodeRecoveryTest on the same data set), maybe we could share this data set through a dedicated class, for example RecoveryDataSet?
why change the readability status here?
Use Logger or remove try-catch and throw IOException
Never use printStackTrace. Here there's no need to catch at all as the method already throws IOException.
How about:  int size = Math.min(b.height, b.width); setMinimumSize(new Dimension(s, s)); setPreferredSize(new Dimension(s, s)); setMaximumSize(new Dimension(s, s));
cant we just always pass 1, or -1, so it calculates the right size?
See earlier notes about code style with if statements.
Please add the 'can not recover' back? It clearly tells why we must abort the region server.
Does it display the stacktrace? We will need it
suggestion "part of a group or is participating in a rebalance right now. You should first call poll to complete " +
given/ execute/ assert
I would add in reindexing at least one ref tag to show if it updates correctly.
This is a nice test. Demonstrates how simple and clean it is to create and submit a job.
Not worth debugging for this QS
player state setter mag niet public --> zie branch #145 (clear DB als player gewonnen is en removeCurrentPlayerFromDB als player verloren is)
missing ,
Might make sense to use a RowMutation here and have the PutAdapter take a MutationApi interface
I don't know if we ever call put twice for the same key, but null effectively removed the previous value in the method's "before" form, and now it doesn't.
This is really good. Thanks.
This does not have to be deprecated because a new method was added. Also, do you want the method to be removed in the future? Starting with Java 9, two parameters were added to the deprecated annotation since and forRemoval. The default for forRemoval is false. If deprecating, it may also be good explicitly set these. Not sure if my syntax is correct below, I have not used these yet. suggestion @Deprecated(since="2.1.0",forRemoval=false)  Personally, I don't think the method needs to be deprecated.
suggestion "Table name is longer than "+ MAX_TABLE_NAME_LEN +" characters");
The implementation of this uses zoo cache. So it may return stale information. Before getting the table state, could call Tables.clearCache(). This will force the table state to be read from zookeeper.
Thanks for this clean-up throughout the code! I should probably start enforcing fcrepo4 code style rules sooner rather than later...
minor thing, but this doesn't need the throws clause
I don't think this works. We're swapping out context with a different instance. We should probably use a constant as a monitor.
I think configurable makes sense
One more - this will be 3
Where is this magic number from?
If it is meant to only check syntax, do we need to return model? I'd rather have it return true/false.
why not use the logger for this?
[minor] Why single-quoting the id?
any particular reason why this method doesn't require an IJavaProject ?
Would replace that with: String fullBranch = head.getObjectId().name(); and rename fullBranch to objectId, to make it clear that this is an ID, not a branch name.
style: extra parentheses
I'd make these constants, just to make it clearer.
Where do the constants10 and 20 come from? it would be better if they were final items in the class with meaningful names.
yeah, I think definitely add a numberOfHosts field, that's @Value.Derived on each of the impls.
given that specificity of this SV is exception type I would add the exceptionType in this.
code format
Should this method be final?
This function **always** returns null. It appears to be an error.
can we change this variable name to rawId? because you're creating an id from a variable called id right now. It would be clearer to create an id from a rawId imo
this class could hold a downloadFileId
Can you change to static variable ?
Why did you change to public?
Need a metric for ignored large messages rate. Should also log them, not ignore them silently.
if you want to make this threadsafe synchronize this copy on fValues. synchronized(fValues){return new ArrayList<>(fValues.keySet());}
Just declare a short-lived variable where the assignment happens, in the if loop
these 2 for loops should be replaced by a single entryset iteration
I'd still prefer to have the operation for generating the 'key' for a muted topic to be a separate function, or even embed it into the Message object. for example:  mutedTopics.add(message.concatStreamAndTopic()); ... // in Message.java private String concatStreamAndTopic() { return getStream().getId() + getSubject(); }
return void
Racy. Maybe just chuck a synchronized on.
This is now hard to read since it combines two multiline expressions. Please break it up into separate expressions and use suitable variables for each value.
would _getMatchingConstraintValidatorClasses_ be better? _Applying_ sounds strange
add braces
instanceof Dataset is redundant
Use getJobDatasetName instead of UUID since it's already unique, and makes it easy to debug.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
Why is this necessary?
The getStore() method returns null when the store is not in the running state. This is up to you, but do you want this method to return that disabling was not successful when store.isStarted() is false?
All other Store.Provider do some level of accounting - same should be done here.
nit: public abstract void
Can we print the full http headers here, so we know what exact request is coming here when it happens? May be good indication to know more about why this is happening...
Collections.<String> emptySet()
There is no need to set the local scope reference to null, but if you prefer...
Why is it public?
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
This should return 1 if the time difference between start and end is > 0 (in any unit), to ensure we never round something to nothing.
This will crash if the dateTime has no time zone (I didn't have Optional back then) like it's the case for all-day tasks.
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
if you don't specify the **this.user = null**, it will be null when the class is instantianciated, so this line is redundant
This "this" is not necessary after we change the name to _zkClient.
What's the reason of removing the null checking?
Is there a reason to set the variable in the constructor as well?
Is value == null a valid case here?
function parentheses/braces styling
nit: Same here. Leave the checks in the switch and do the assignment at the end: this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
This should be cached in the constructor.
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
What happens to dst and copier in this case? try-with-resources style wouldn't try the close() again, so should we retry the close to prevent them from leaking?
should this assert happen after the call to start()?
Why uppercase fs?
I remember I made this tests to starts cluster only once. That will improve tests time, You may want to have a look at corresponding ViewFileSystemOverloadScheme test class now.
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
this stream needs to be closed
ok, I don't fully understand the class heirarchy in this connector. It's a bit confusing for me, but if you don't want to change this now it's ok. This review is big enough already.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
For non-public methods checkWidget() is not required.
tooltipText;
I would prefer if you use String.format here. Also, have hyou thought of log.debug the stacktrace?
Is the expected behavior of this function either that it wipes the cache immediately *or* that it triggers a setting that will required the cache to wipe at a later time? Right now i'm not comfortable with the guaranteed execution of that process given the Session exception path here. Let's chat over voice on that.
This should stay as a /. User agents are usually in the form software/version
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
[nit] There is also a cleaner approach using Guava:  java return Enums.getIfPresent(LoadbalancerAlgorithm.class, value).or(UNRECOGNIZED);
Send this exception to the log.
Shouldn't be here a warning log and in else branch the actual code - setNotificationService(notificationService.get()); ?
could we make a constant out of this string?
can we just keep the default constructor that sets this to false?
not checking the value? maybe create an OptionalMatcher that checks the Class and the value
I don't think we want to propagate the exception in this thread. We just want to return the throwable. It wasn't this thread that had the error.
Please use case detection API from Protobuf.
Assert.notNull since shouldFilter will throw otherwise
return this; for chaining.
Please check for null here using something like: java Assert.notNull(beanResolver, "beanResolver cannot be null");
you can use standard java NotSupportedException
Maybe IOException since it's supported here?
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
I think injectionTarget.getClass() does not make sense here. It will be better to simply pass the IT instance. And the same probably applies to extension. Also I think it would be better to log both the original and the new value for all ProcessX events, e.g. something like: ProcessInjectionTarget.setInjectionTarget() called by {0}: {1} replaced by {2}. What do you think?
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
why is this unsuccessful ?
You may also want a test case for a search value that is non-blank but invalid.
I think the indentation is wrong here. Seems like you're using 2 spaces.
createTileOverviewForm()
Can be reduced to throws IOException.
Can be reduced to throws IOException.
Can you explain this please?
Should we add null check?
remove redundant ; it will only cause static analysis to complain
Remove ?
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
Should be removed if empty
I think this cast can now be removed
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Are our current http log files in UTC or CEST?
Do we need the conf here? I don't think it's even being used.
i might be wrong but I think you need a synchronized bit here so all threads will see the new reference. i need to come back to this part.
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
I think we should remove the following events
isn't it simpler to just do: return _minDelayMs + (long)((_maxDelayMs - _minDelayMs) * RANDOM.nextDouble())?
Feels a bit odd that we specify the average maximum but don't really control the actual maximum - I think we really want to control the maximum and have that be 30. You could either cap everything at 30s, or take 30s as the maximum, then calculate 2/3 of this and apply the +/-50% from this value.
typically, you don't use getters when inside the same class
I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block.
Style-nit: no brackets around single-line blocks
Multi return is forbidden.
pls use formatter
Is it an exceptional case for ConfigLoaderFactory to not be present here?
Suggest leaving them as null if not set
move this line before above line, After super.cleanup method couldn't do any of the server requests.
super.init() method never throw an exception.
Need to restore configurations using serverConfigurationManager.restoreToLastConfiguration() and make sure all changes done to configuration files will be reverted.
You should use ThreadContext.putAll() here.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
new HashMap<>() will do
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
<b>Reporter: </b>PMD<br /><b>Violation: </b><a target="_blank" href="<LINK_0>">JUnitTestContainsTooManyAsserts</a><br /><b>Notes: </b>JUnit tests should not contain more than 1 assert(s).
Maybe let the stop() method throw the exception instead of catching and printing?
Bad copy/paste: InMemoryRegistrationStore
I think Long.MAX_VALUE is too long. How about using 1 hour?
Do you need a fail() here?
Please fix the alignment.
This could be even if (dedicatedTransport != transport)
Is it OK to swallow this entirely?
Exception should be logged.
I guess all this (and the finally/close) can be simplified with try-with-resources.
Duplicates JdbiStreams.toStream(Optional<T>). Although I'd be okay folding that method into this class.
This can be done in functional style if you prefer: java return optional.map(Stream::of).orElseGet(Stream::empty);
+NonNull for return type
This method should be invoked before sending the message for processing in the doReceive() method and not here.
can you break up the long line?
Is this the intended message?
Whilst this is tidy, I wonder if it might be a bit inefficient to use a regex. In my simplistic testing using: msg = (super.getMessage().endsWith(".")) ? super.getMessage().substring(0, msg.length() - 1) : super.getMessage(); is around 13 times faster when the replacement needs to be made, and more than 20 times faster in the case when it doesn't. Whilst hopefully we won't be writing exception messages often it might be worth considering.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
delegate=true style would be just fine.
need to remove this print or convert it to log stmt
Shouldn't options be Immutable?
Is it useful to keep the Exception generic, or should we narrow the Exception type on the interface?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Same for other places suggestion _tableConfig = tableConfig;
Can we show that this method is not supposed to be used directly by consumers of this class by making the method protected?
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
This needs an @Override annotation.
style nit: s/if(/if (/
missing @since tag
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
You can use CollectionUtils.toImmutableList
getClients(this, null, null)
Nitpick: startingCounter?
You increment just one of the counters. The total is produced by prometheus automagically. So basically, we could have: starting_attempts.total#debug=false and starting_attempts.total#debug=true and just increment one of them here. We would not have an untagged counter at all.
Would a switch be cleaner here?
There is no need to check the VIEW right, EDIT is enough.
I don't see any protection against concurrent execution of MVMap.append() if MVStore is used by itself. MVMap implements ConcurrentMap so it's not expected that there are any public methods, including non-standard ones, that are not thread-safe. With H2 at least session should be locked, however.
It's really not clear if this is the source or the target.
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
Not for now, but I think every concrete subclass of EpdqPayloadDefinition probably knows enough to add its own operation type as a constant rather than it being added to the data passed to it here.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
checkState
Use same order as the field declarations.
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Are you aware that this very expensive use of String.format is executed every time, not only when debug is enabled?
rename to contribution
rename to contribution
enableEditingButtons(..)
Why do we have this constructor?
Empty line, also it could be better with more fields (use your ide toString generator).
This seems unused.
Need to implement
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Using a static map would be easier?
Use same order as the field declarations.
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
should we make this 200 configurable?
This asserThat will do nothing - you need to add something like isTrue()
seems like this could benefit from using your new flattened method (once moved elsewhere like I suggested) eg. for (plan : plans) { found = flatten(plan).findAny(p -> id.equals(p.getId())); if (found.isPresent()) {return found.get();} }
this doesn't really make the message any more useful, shouldn't we include some info about the plan (id/label)
Can reuse site here.
Else log a warning?
Nit but, can we move the whole line Map<String, Object> properties = new HashMap<>(); inside the conditional to be closer to the code using it? We don't need it outside, right? While at it, and certainly not a blocker, WDYT about introducing a helper method to the enum object to quickly return a prefilled properties map? Something like:  public enum BlockEditorEnabledSource { VIA_SITE_SETTINGS, ON_SITE_CREATION, ON_BLOCK_POST_OPENING; public Map<String, Object> asPropertyMap() { Map<String, Object> properties = new HashMap<>(); properties.put("source", name()); return properties; } }  We can then for example use it as BlockEditorEnabledSource.ON_BLOCK_POST_OPENING.asPropertyMap().
Also, there's no zero comparison covered?
I suggest using "ComparisonChain.start().compare(o1.name, o2.name).result()" - Location.name can be null.
try to avoid nesting IF blocks. I would write:  if (tableScan.getOriginalPredicate == null) { return Optional.empty(); } ...
rename to contribution
Use TasksUi instead of TasksUiPlugin (it's the same implementation, but one is API)
it might be better to use the TaskEditorInput created above - not sure you need a mock.
Is username case sensitive?
Missing Assert.fail().
Should we call that method getUserStoreNames() instead?
what happens if remove() fails (throws an exception)?
Minor: StringUtils.isEmpty?
These should be inline - not required for testing
Add this qualifier: this.data
What do you think about public contains(T item) calls a private boolean contains(ListDataProvider<T> dataProvider, T item) instead of creating the dataProvider itself? This could increase the performance especially if you call containsinside a loop like in addItems, addItemsAfter or addItemsBefore.
trivial: you can remove the isDebugEnabled wrapper
Do not use e.printStackTrace(). Log the exception. > this.logger.severe( e.getMessage()); > this.logger.finest( Utils.writeException( e ));
We can use try-with-resources now. I know this is only a refactoring but we can take this opportunity to clean up code
Ignore?
Now this method does not do as it's named...
Those two methods are similar. Consider using one.
this method suppose to return instance of DiffPagePageObject class, because its redirecting to diff page beginning of the method should be: public DiffPagePageObject goToDiffPageFromHistoryPage() and last step should return new object: return new DiffPagePageObject(driver);
Wouldn't it be better to not mock this ? This way we will test filtering. In ACUnitTestBase you have method to create Patient, so you can build a list and see if the filtering returns proper list.
Why is this necessary?
What about changing createPatient() to set name based on id passed to this method eg "patient_{id}"? This way we can reuse this later :)
We could cover it with some tests.
Wouldn't it be nice to check the path was observablePath rather than _any_ path?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
only EE product can have runtime lineage
This is causing a nullptr in InitialGroovyManipulatorTest. I think it would be better to store a enabled Boolean and have initialise correctly set it and not store the userProperties object
Should we have a constant for this?
Check the env variable before returning true.
Check env variable before returning true.
This should check the environment variable before returning true.
You don't need this, but if you do keep it in it needs to set standardOutOrig before you call System.setOut - otherwise you are just getting a reference to the value you just set.
May make sense to restore these in an after class method.
How about returning the old MessageBufferOutput instance here?
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Instead of using the message, evaluate the topic to generate a good string message
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
Let's use this method on overloading.
Are you sure we need that condition? Are you able to cover it by test case? The null-test was not present before and I can't see any test related to that.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
You can use GenericMath.DBL_EPSILON here.
Does a straight comparison work here? NaN isn't usually equal to itself.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
I'm surprised the server doesn't already do this.
@diegolovison Can you make this happen or are you just worried it might happen? I'm trying to understand how the wrong type of cache would be passed into the HotRod service.
A good opportunity to not hardcode the port here, but rather use findFreePort()
This is the same as downloadBatchMap.containsKey(completedDownloadBatch.downloadBatchId())
How do you know you got the right ones back? Would be good to flesh out, look for off by one errors, etc
So this is good. I have a possible idea of how to make it better, but not sure if it is doable with the rxjava2 API. However I would suggest removing the first doOnNext and just move it into the second one and do a for loop over the list. This gives us one less lambda and should allow the JVM to optimize a bit easier.
test will success in old versions
Arrange, act, assert, please.  java setupFolderWith23Messages(); int result = folder.getMessageCount(); assertEquals(23, result);
Since using assertEquals to compare objects, you can compare the ValidationResult objects: assertEquals(ValidationResult.VALID, validator.networkExists()); here and elsewhere in the file.
Encapsulation
Something else that I missed. I know it's not that important, but we don't have to set the type when creating new objects any more. We can just use the diamond operator new HashSet<>.
Generics, please!
Instead of repeating the addition assign it to a value on the stack.
you should account form previous page too
Debugging? Remove.
Move the logic to configAccessor.
These lines could be in a private check method to reduce duplicate code.
For this exception, is it caused by a server error or a client error? It is good to make sure the response status code is appropriate.
A good opportunity to not hardcode the port here, but rather use findFreePort()
Aren't there any test methods that require compatibility?
Nitpicking, but I'd prefer creating the builder with  org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder(hotRodServer);  and then setting the marshalling. Same in RemoteStoreMixedAccessTest
There is no call to this method outside TableManager, shouldn't we change it to private?
Missing final
s/RemoteTable/RemoteReadableTable
you can remove this
there is no need to execute initElements method, when you're extending BasePageObject
Magic number <LINK_0> Try to use a constant for the timeout. Review the constants in the project.
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Should move this try/catch deeper into the call stack, either the public overload or in the package-private method so that we don't need to put it in multiple locations.
Don't like catching exception in the constructor. use an init method with @PostConstruct annotation.
all these methods can be private
You can use StringUtils from the commons.lang3?
This is normally made so different implementations can override the type() method to go somewhere else in the objectstore - however you have a getType() on BACoordinator so it means no one could ever override the getType() from what I can see, maybe I miss something or maybe its not required but I do need some clarification
Please explain this change and why users need this method public? @romani What is your thoughts? Why isn't writer final? I don't see a reason why users would swap output streams in the middle of execution.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
We're on Java 8, so: IntStream.range(start, start+length).toArray()
For loop?
use Arrays.fill instead for loops
Hm, my understanding has been that the base implementation should look like: Java if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); }
Doing the refactoring of the OH2 bindings, this default implementation does not appear to be helpful. In most cases, the Thing is simply expected to go ONLINE once the bridge is ONLINE. This means that this method needs to be overwritten, so the question arises if super. bridgeStatusChanged() should be called at all or if the logic isn't reimplemented. Both variants are not really nice. I think we should change this line to ThingStatus.ONLINE as this will be the expected behavior in most cases. Whoever needs something else, should override the default impl. @sbussweiler WDYT?
As mentioned in <LINK_0>, I would claim that setting the status ONLINE is many cases a bug. In the example of the hue binding, the handler determines the correct status in onLightStateChanged. So either we do not set a state here at all and wait for the next update (triggered through the regular polling) or we set it to UNKNOWN for the time being. Same should be checked for the other bindings.
Stack overflow? :)
Too few IMO, but :man_shrugging:
Surprising that the constant is refers to is defined after this declaration
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
You could remove method("POST") as you set the HTTP method on create
Havn't we agreed, that this is not needed? This class cannot operate without dest, at least, so the caller must provide it, so it can also provide the opened repo.
Same here, no need a transaction
No need to make this a transaction, its a single insert statement.
switch to regular for to avoid Iterator allocation, ditto for the teams method
Detail: FROM capitalized.
I would have used isBlank here
clause?
Could you please use DecisionTableInputType.XLSX
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
Should SeekablePathStream be used here as well, or does it have to be Files.newInputStream() for some reason?
ZERO_ADDRESS
correct log message, it might be less than not only equal.
This code is almost a duplicate of getIncrementedSegment(), could be extracted to a method.
This check is unnecessary. context can never be null for a properly constructed object.
static.
Use static call. There's no need to instantiate this util class every time.
why not use the passed in editorInput
style nit: missing braces
why not call the new method with null as third parameter?
return tags;
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Why this debug log is removed? Not sure, if it's there for any security issues.
Can we add more context to this log statement as well?
Do we need to handle the interrupt in the consumer poll thread? Existing implementation doesn't seem to handle it and the consumer poll thread is interrupted during KafkaSystemConsumer.stop()
It doesn't feel right. Why it is required?
This got out of sync when I reverted the WFCORE-307 fix. The correct property is "jboss.as.test.disable.runtime".
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
All of these createTable and deleteTable methods should throw UnsupportedOperation permanently; table creation/deletion is outside the scope of async-kiji.
Why now is proper? If whole predicate is pushed down, then I would expect to see TupleDomain.none() here.
nit: I'd make a constant for foo-test-invalid.json too
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
You need to send cookie here.
Add final keyword.
Don't do double assignment, and no need for "return at end of method", and the case indexNames.length == 0 is already dealt with by String.join, so just do: return indexNames == null ? "" : String.join(",", indexNames);
No biggie, but I guess best practice would be to do this(Arrays.asList(columnNames));
I guess I'm out voted on using this. :-(
either use AssertJ or have the assert text provided details on the cause of failure (i.e. the provider name). Goal: a failure on a jenkins run must provide enough information to enable someone to work out what failed
Why uppercase fs?
this should be assertTrue ?
name could be more descriptive
Vague variable name s
This value is used several times in this method, and it could be assigned to a variable to reduce clutter.
Returning a class instance _or_ a null? This calls for an [Optional](<LINK_0>!
Error message should be "Invalid URL format. URL: " + url
are you sure this is the best way to handle this exception?
this check is not needed.
I think the result of this call will not change at any time. So we could improve the code by keeping the Bundle in an instance variable so it is not needed to request it everytime.
change param name to resourceBundleCache
getContentLength() [is nullable](<LINK_0>, so we would either need a checkNotNull or some null handling here.
this change is not correct for other content where Payload is used, obviously it has Base64 encoding there
@JimDeanSpivey no need for this null check. we should never be using nulls, ever :)
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
LinkedHashMap please <LINK_0>
Rather make this FINE, as this PR will by default introduce noise.
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
Why do we need a new CustomerToken here instead of passing the ref back directly? It should be read only
I just realized that this could generate FPs when placed on different lines: java target = +num;  We should check that both token are sharing the same line.
If it's a malformed URL, then it's an illegal argument to the method, rather than an illegal state.
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
RuntimeServiceException is better, as some tools will warn if we use a bare RuntimeException.
Better to return Query<?> than to let shenanigans like this get past the compiler:  Type type = int.class; String result = handle.createQuery("...").mapTo(type).findOnly();
This might be splitting hairs, but it should probably be findFor(t, config) (t instead of type)
Could you add the path /artifacts/ to <LINK_0> and reference that instead? Then search&replace in other methods.
Added because?
Should not be able to submit when there is no question selected.
Just a question, why do we have to test whether the publish immediately button isn't selected? What does the 'original values' here refer to?
Since you're already using Guava, consider using [throw Throwables.propagate(ex)](<LINK_0> here instead.
ExtractedContentPanel.getText.error.msg appears to be undefined. As previously noted, this means that there will an unchecked runtime exception if this code is executed. Please correct the error and use the generated method for the messages instead of NbBundle.getMessage, which moves errors such as this from runtime to compile time. *** While we are in this code, it would be nice to group the catch for InterruptedException with the CancellationException, since they amount to the same thing (even though we do not support cancellation of this task at this time).
What does using a SwingWorker get us here as opposed to passing "true" to the Children.create() call below (which will cause the key creation to happen on a separate thread).
seems like synchonized is not needed here, given increment/decrement already protect
Actually.... what if we avoid using addFileSystemBind (that [creates a mountable file](<LINK_0> but use the bind API directly for the SHM? This ~~hack~~ adjustment does solve the problem too, but I think we're fixing it in the wrong place. WDYT?
I think lowercase l should also be considered
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
return schema.getSubSchema(Ints.toArray(keys));
Would be nice to have something here to check for duplicate schema names. I don't think the base Calcite class does.
Check if value is null.
Should we use UTF-8 instead of default character setting?
Can we add a length check of hexString that it is four bytes?
Since these are run as tasks, do we also want to add the check to confirm the context is still active?
Curious on your thought process behind this vs propagate()?
minor: why not do this in the constructor?
You should go one step more in simplifying the rule: Change this method to return a boolean: hasNoDefault(switchStatementTree)  return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
This could be reworked to avoid having ! in nearly every condition to make the different cases cleaner to read.
Extract classTree.symbol() to a dedicated variable rather than calling it thrice.
status == Status.STATUS_COMMITTED
@Suseika let's clone the list instead assignment
Read, not readed
How does this work for (ridiculous) timezones with 30 or 45 minute offsets form UTC?
SonarLint is going complain about String concat
I prefer ", not "+(l == null ? null : l.getClass()));
Why not just mark the whole method as synchronized?
Since this logic is getting more complex, it probably makes sense to reuse isBindableType here.
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
please leave it that way - it's intentionally referencing the deprecated version.
don't you want to check if session id is null here as well?
Same here, making methods protected allows users to override them.
final
Add message to new RuntimeException
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Why not unconditionally update the SessionData?
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
Is it required for the upgrade?
what about getUniqueId() with some escaping (e.g. URL encoded)? It gives you human readable and unique strings like:  [engine:junit-jupiter]/[class:com.example.MyTest]/[test-factory:parameterizedTest()]/[dynamic-test:#3]
Just return commandName if collection is null. I'm not sure but don't expect the JVM to optimize the stringbuilder away for this pattern.
minor: don't need this. qualifiers
Wouldn't it be better to only show iterations OR epsilon?
suggestion return getClass().getName() + " [policy=" + this.policy + "]";
The two methods above are the same except for the first line...perhaps reuse the code instead?
The two methods above are the same except for the first line...perhaps reuse the code instead?
We should now be using the actionParameter itself
I would insist in having all methods that use a CT* parameter to be annotated as @Internal when they are not private.
No need for sash form here.
there are lots of duplicated lines in these two methods
Seems like the previous tests should also assert on the length?
I don't think you need this new String
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
You can change the 28 case to a default case, and remove this.
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
Gson doesn't run on these versions so I don't see any reason to include them.
please avoid one-letter vars. In java its very hard to follow code if it has obfuscated variables
suggestion return GitHubServerConfig.GITHUB_URL;
The created JDBC URL does include the username and password from credentials. It seems this would be needed for authenticated database connections.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Can you change this.
It can use the URI from the message instead of node name.
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
new String() is redundant.
please create a more specific exception that extends this one.
throw UncheckedIOException(e)?
factor out
nit: put {} around if statement.
Maybe: 'toIME'?
cursor is not captured here. I fixed it locally adding  julLogRecord.setParameters(new Object[] { logRecord.getCursor() });
should this count be parameterized?
For loop?
I would retain the existing indexOf body to to avoid indirection in the most common case.
return queryId
please use this() calls and have real code only in one constructor
An error message could be helpful.
style nit: we don't use braces around single line blocks
Can we use here just i variable?
Why do you pick b as the variable name? It could be model or m. I am just curious.
Apply changes similar to setVisibility.
Simpler to apply the mask after the shift.
It's preferable to sacrifice code reuse for readability and always check memberIndex < MAX_MEMBER_COUNT before calling getMemberRecord.
A message might be helpful
nit: set the probability at the start of the test so we don't have to assume default/look up at the initialised version
Nice, we're now also checking that whether you access timestamp directly or via timelock, the numbers are consistent. Not sure if it makes sense to add an additional check where, after we get one from timelock, if we get one from regular timestamp that's even larger (the idea being that the changes propagate in both directions).
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Maybe check for if name ends with ':' so we don't do a double one?
... remove the final modifier from the method. It will be easier for future tests.
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Is there a chance of a NPE? could be getFile() null?
although this makes the API some how compatible again, it is semantically wrong. GlobalConfigFiles.get().getConfigs(); just returns the global configuration files and none in any folders. So I don't think this is a good idea. The same applies to all the other methods...
I think the SystemReader should server this cache instance. With two static instances, there is a brief interval in which this cache instance will be the old one while the SystemReader instance will already be the new one. Might be simpler if the two methods getSystemConfig() and getUserConfig() were on SystemReader, without this separate class.
Same with "security:groups"
maybe dataStore variable name instead of people?
extract as constant?
What about new File(internalFileDir, fileName.name()).getAbsolutePath()? I think we should not create paths by concatenating strings
Did you intentionally ignore the patientProgram parameter?
Would be nice to leave existing code the way it is that is not related to this ticket
Shouldn't this be done before the patientProgram is saved, instead of after?
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
Is not safer to use Locale.US instead of ENGLISH ?
Great idea! Can we use Locale.ROOT instead, though?
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
Is it worth distinguishing what is null in this case? Is it different if m_txnState or the invocation is null
I'm not sure this is correct from a JPA perspective. JPA says that EntityTransaction is used to "serially ... begin and commit multiple transactions". It sure seems like JPA expects that the same EntityTransaction be returned each time that EntityManager#getTransaction is called: EntityTransaction t = manager().getTransaction(); assertSame( t, manager().getTransaction() ); assertFalse( t.isActive() ); t.begin(); assertSame( t, manager().getTransaction() ); assertTrue( t.isActive() ); t.commit(); assertSame( t, manager().getTransaction() ); assertFalse( t.isActive() ); manager().close(); assertSame( t, manager().getTransaction() ); assertFalse( t.isActive() ); As it stands we create a new EntityTransaction as soon the transaction is accessed after the commit. I'm not sure I can say that the spec requires this (^^) behavior though, and the TCK surely seems to not enforce it.
Okay, but now the label provider is null. What then? We will get NPEs in the places where the getLabelProvider() is called.
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
Why not in combination with above do this: setValue(value, false);
This should be simplified to just: >return value;
assuming this was for debugging, should remove.
Same here. You can use TestHelper methods.
Can you use TestHelper.getTestMethodName() and TestHelper.getTestClassName?
This updates all gauges when any of these gauge is visited. It'll be better to override getValue() instead, and only calculate the percentile for the gauge currently being visited.
Should this be removed from here if this is already being updated in getValue?
should you do a ListGauge<T> for explicit type inference here since the method is parameterized by T already?
Is it better to initialize latch to CountDownLatch(0) instead of null? Also initialize it in line 45, when latch is declared?
don't forget to fail
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
Padding should probably be extracted in a separate method. (I could also argue that getting the int value could be another method, but I sense that there might be some opposition there).
Why do we return the parents name instead of the name we store a few lines above?
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
please create a more specific exception that extends this one.
Please format this as:  command.stream() .map((String s) -> "\"" + s + "\"") .collect(Collectors.toList());
replace this with java return scopes.stream() .filter(this::matches) .map(AuthScope::getProject) .collect(toUnmodifiableList());
I'd prefer to have the unknownFieldSet as the last printed stuff.
missing field qualifier
Why not just use direction == Direction.DESC instead of converting to string?
these can be checked by automated bytecode instrumentation, so there's no need for manual checks - @NotNull itself provides enough compile-time information.
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
The log is a bit confusing. The will look like a table is enabled/disabled. We can say slow request logging to system table is not enable? (Or a better message)
Please only use asyncAdmin for async operations, like createTableAsync. All synchronous operations should remain as they were before.
can you set this to warning level instead of error (Timber.w) - just trying to avoid too much non-fatal stuff in the error logs
Since there are only two values for boldKey (and italicKey), it might be better to change these parameters into a single boolean isEdit, thereby removing the duplication of references to TraditionalRenderingPreferenceConstants.
This statement can be removed as well (same for name), the previous statement ends up doing this.
[minor] What is the notNull() for? Does operatingSystemsAvailable possible contain null elements? And just to check I'm understanding the logic correctly here: the image ID can be a substring of the the ID of an OperatingSystem, and that is what we are looking?
return ImmutableList.copyOf(blockDevices)? Or is the result object converted to an immutable collection elsewhere before being passed to the user?
I think this can be private static?
Something like this.
Same here. Multiple places.
You may find many examples in the existing code base.
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such name. And as a user I would expect them to have higher priority. Maybe it worth checking all TopLevel views first. I would also vote for making a parameterizable method View getView(String name, boolean recursive) and maybe changing only the API calls which are really related to search. Otherwise it it hard to predict the impact of the defaukt behavior change
invert it
I think we are doing too much outside of View rather than finding a good way to delegate to a View. We rely on a view's underlying implementation to work, and in this case we don't even throw an exception if that assumption doesn't work (which we should). I'm fine with this as long as it is temporary, but I think we should be delegating more to the implementations rather than relying on them to follow the standard pattern.
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
Maybe IOException since it's supported here?
This must be supported.
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Might this not cause extra copying of the buffer contents when transferring data between network and storage?
why do you set it twice?
See also DefaultDockerClientConfig::dockerConfigPath field
As an aside, shouldn't this if clause have an else? I'd also add some logging, just like in updateConfig. Could help us see it wait to get this lock. Again, both are not related to this issue, I know.
need to throw the exception
simplify to () -> isLoaded()? Can it just be this::isLoaded? I'm not sure what the interchangeability of bound method references and lambdas is like.
Those two methods are similar. Consider using one.
You can change immplicit before and rever the change after waiting
ConfigurationException?
LinkedHashMap please <LINK_0>
why silent catch?
Since we know we're in ConnectStoragePoolVDSCommand, is the getCommandName() really necessary? also, remove the "to" - "Failed in VdsCommand %1, error = %2$s"
this "return;" statement is of no use.
You don't have to use addCanDoActionMessage for this, since there's a ValidationResult constructor that receives a list or replacements (ellipsis so you don't really have to wrap it in a list or anything). That's the way it is used in most places
same here - call the constructor with 4 args
flip the order of the checks - more intuitive IMO. Something like saying "time is valid and is less than" rather than "time is less than and valid"
can you define a constant for -1 and name it as INVALID_TIME_REF
Same here.. we should not have these checks here.
there are two options here: a. (the better one) if value is not in cache - call addToCach(value) b. return a boolean value - was the value cached or not.
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
suggestion StorageUtils.LOG.FINE("Layer3/FTP: Downloading file '%s' from '%s'", childName, parent);
Since I'm suggesting creating the Response with the input stream this could simple return it now
Should return ReadOnlyArray.
Should return ReadOnlyDictionary.
personal preference (so up to you to take the suggestion into account) but I would go for :  if(cond) { return 1; } return 0;
ImageData for current image needs to be updated in the array?
store ImageData in data[]?
What if fileName doesn't have any .?
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
I think only one impassable entity should be allowed on a Square. Exception otherwise.
should assertOpenBlock(); here, and have a test that fails without it
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
why do you do the substring if you are using contains?
One-line conditional statements without braces are bug prone. Please wrap such occurrences in braces
Woah, just caught this, we should probably just throw a notification for this, not a runtime exception (or throw a typed exception here and catch/raise an notification later). Otherwise I can prevent your phone from ever being able to start up CommCare by sending you an invalid URL over SMS, which will make it crash on startup.
static import joining
use String.format for readability format("transform(ST_Geometries(ST_GeometryFromText('%s')), x -> ST_ASText(x))", wkt)
ImmutableMap.copyOf()
the results changed?!?!?!?!?! this is not good. We need to do a seek before, we cannot rely on a "fixture" that changes depending on the order or the tests.
Why are you calling setUp()? Is there a way to avoid this?
I'm not sure that a shallow copy is enough. Some other class could have a reference to fLocation and could be modifying it. For clone a deep copy is needed.
nit: Change 2147483647 to 0x7fffffff  for easier understanding.
You may want to prevent inlining of those methods too.
This & the other switch removals should be reverted, performance tests show that this isn't any more efficient. The change also increases memory usage, making this a net negative change.
Fixed in next patch set: - Made private. - Added dummy serialVersionUID to prevent Eclipse warning.
Please change appended text to " with no referenced composite specified". So it would result in "Looking up active widget with class type some.package.Widget with no referenced composite specified...."
Should be a constant.
Here you could extract a private method for all of them which takes the type as parameter.
can be !isDisabled()
Hi, I thought about changing back the name because all the classes in the AElement hierarchy use double dispatching mechanism and it looked like a convention, and the double dispatching mechanism is more clear according to Michael. This class is the only one for which the second equals method isn't used anywhere, and I'm not yet familiar with the complete codebase so I thought it was error prone to change the public api of the class, that's why I changed back the name and made the change so that the equals(Object) calls the correct method. I do have the merged equals method in a branch. Should I make a pull request from it?
is logics correct here?
indentation is 4 characters/1 tab length too far and the way this is spanned is odd. Also, when you're chaining multiple calls and you hit the line limit, split it on method calls:  envId = this.getEntityManager() .createQuery(jpql, String.class) .setParameter(...) .setParameter(...) .getSingleResult();
These should be inline - not required for testing
The error message doesn't match the actual behaviour.
Gson doesn't run on these versions so I don't see any reason to include them.
You can change the 28 case to a default case, and remove this.
can move ListVersionView object construction in ViewFactory? this will replace publicBodiesConfiguration dependency by ViewFactory to make it consistent with other resources.
Still this can be a static message as all messages are defined in the beginning of this file
Lets not catch the exception and just let the original exception propagate unto main.
Since this a string, safer to use StringUtils.isBlank
is super.init throwing the parents class Exception? Whats throwing Exception within the init method ?
Not your change - we should actually set this to the saved stdOut - ideally saved around L85 (now L97) System.out
Missing space after if
See ItemMetalNugget
Missing space before (
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
getItems().length > 0 implies menu.getItemCount() > 0, so menu.getItemCount check can be removed. getItems().length is not sufficent, it should be checked that any of these items is visible, e.g. Stream.of(getItems()).anyMatch(IContributionItem::isVisible)
Casting to MenuItem is redundant here
Please keep this.cell near the related fields (previousFamily & cell count) below
Better to throw NullPointerException?
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
This message should be included in our Log class (with a parameter for the service name and a @Cause, you have tons of examples in the code). The message should also probably be something like "An error occurred while loading an instance of service <service class>.".
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
Simple for-each?
Move this else if just after the } above
Have we tested this with a song that is currently being played
check done
This should be in getCache(): private synchronized Map<String, User> getCache() { if (cache == null) { cache = new HashMap<String, User>(); for (User user: getAll()) { cache.put(user.getUserId(), user); if (eventService != null) { eventService.fireEvent(new EventUserUpdate(user)); } } } return cache; }
This should not be changed, you should only be changing search methods
Should we call that method getUserStoreNames() instead?
You should clear the set after the scan to, to be sure that references to the IfStatementTree are not kept for the whole scanning process. Actually, I think I'd prefer to avoid using a set altogether by using the parent to retrieve the else keyword (i.e. if the parent is a IfStatementTree and current if is the else statement of the parent). What do you think?
As you are relying on semantic to raise issue, I would verify before going further that we have access to semantic model. - Look here for how to check if semantic his present: <LINK_0> - And here to check that we are not raising issue when semantic is not present: <LINK_1>
Why not override visitClass() method?
Why do you not return directly the value of condition ?
I think that CSSDOMSemanticElemntHelper should be an Singleton.
Can you repro this on master? If yes - definitely worth filing.
Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?
All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().
Why fromUnfiltered(), if you then filter anyway?
this.
Could you replace the magic number 128 by a constant?
![MINOR](<LINK_1> Make "getKeySize" a "static" method. [![rule](<LINK_2>](<LINK_0>
In assertEquals, the expected value comes first. suggestion assertEquals(1, mtlsKeyStore.size());
Lets not catch the exception and just let the original exception propagate unto main.
typo: conversion
The super constructor throws an IAE, so why not mark this one, that the IAE could be thrown? Wouldn't it be helpful for the caller of the constructor to know that this runtime exception could be thrown?
no need to declare the unchecked exception here.
No need to call super() since it currently doesn't extend anything.
merge else if?
null values should be treated like empty string.
return value == null; I don't see value of Objects.isNull over == null. And there's only 1 place in Presto code that this is used.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
suggestion return Collections.unmodifiableMap(tags);
1. I wonder if this class can instead be made an util / or a function. 2. Should we return an Immutable collection or a copy here? That way, external callers don't mutate the map, and this class is immune to those changes.
Let's make sure that no project uses this resolver. If there is a project using this resolver, let's throw an exception and tell the user, he can't remove the resolver because it's used.
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
a minor thing, but I like to launch the threads in the static method rather than the constructor, which I think makes unit testing a bit easier, if you ever need to test/control things like "return a new value after the thread fires again"
Should be a constant.
Please group mr, ms, and mrs together
Learned something new today... nevertheless, personally I find it clearer to use Pattern.compile(regex, Pattern.CASE_INSENSITIVE) instead.
It seems you have to choose between @sputnikci and @codecov-io complaining :p Could we open a @codecov-io issue instead of making the code uglier?
nit: param doesn't need final
No lambda param type needed, we use the simple form result -> ...
I want to method accessor to be package private :eyes:
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
minor nit (ignore if it isn't worth it ): The name of the activity is My**Courses**ListActivity and the name of the fragment is My**Course**ListFragment, we should either use **Course** or **Courses** in both names.
Add log.info "connecting to ATSD at host:port"
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Instead, I think we should update AbfsOutputStream.close to wrap the exception, short of having the Java implementers fix this. :)
Avoid ByteSource in API. byte[] is ok here
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
Are we sure that we don't audit log in that case but only engine log?
70-75: extract method (see following methods)
i would add additional check to make sure we will never make it to more then 100 :)
just call this percent
Collections.EMPTY_LIST;
this is pretty interesting, why are you using an arraylist here? is it by design? As a naughty dev, I want to now fo SegmentStoreDataModel.getDataDescriptors().clear() or SegmentStoreDataModel.getDataDescriptors().shuffle(); Is this desired? if not, maybe consider using an immutable list.
Could you at least make this return a non-null value?
Either hasNumberOfValues ? numberOfValues : 0 or add verify(hasNumberOfValues)
Unnecessary boxing?
not 100% sure, but this breaks binary compatibility, right?
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
Please add curly braces around the next statement.
Shouldn't it throw some exception when date is not convertable? Lets imagine that at for example endDate String is corrupted (with a single character typo for instance). The user intention would be to have a job that would end at particular time. Returning null, I suppose, would lift that 'stop' condition. I am wondering whether it would not be better to throw some sort of our own custom 'validation/parsing' exception to make it explicit that there is an error.
Stack overflow? :)
Unfortunately, you cannot delete this method. This is how we initialize our Indices when they are created via reflection in the AccumuloRyaDAO.
Replace with constant. It occurs more than once.
I would not print anything to stderr. I would suggest using a logger and use it in both cases (cleanMethod or invokeCleanerMethod)
rename
maybe rename?
not all listener
Why empty? It supports ALL streams!
Why do we return null here?
Use unmodifiableSet() instead?
we never use NULL, it is a bad practice in general.
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
This is wrong.
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
CONFIG_JOB_PREFIX and we should probably change the config constant too
the static modifier could go away
@ivandalbosco No need to change order if we don't rely on visitor for finding "try"
@ivandalbosco This method should be annotated withjavax.annotation.CheckForNull.
check does checkCanceled
Please add ioe to the exception.
Please add ioe to the exception.
Can be reduced to throws IOException.
Please remove.
Same here - you need to close the stream
null != settings
This doesn't honor the contract of an iterator's remove. In fact, i'm not sure you can support this atomically with only a single file.
I like 2. Let's do that. And I like 2 even better if it was a BufferedSource and a length from Okio. But that can come later.
Does this make the check on the previous line unnecessary?
Static string constants
How did this happen?
No tests to cover this method! :open_mouth:
"profile" should probably not be part of the quotes?
You can just put the whole trigger text here instead of calling the super, it'll keep you from having to use setText on the token effect
You can put the whole ability text here instead of calling the super but if you don't you should add a comma after "steps"
Should have a space after add
Another space after add
Have you verified this works as expected? I think the throwable needs to be the last parameter.
context.PROCESSING_MODE => OperatorContext.PROCESSING_MODE (to get rid of "The static field Context.OperatorContext.PROCESSING_MODE should be accessed in a static way")
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
As it is a new behaviour, should this be exposed as a new method in the operator interface? This allows us to identify the operators that actually make use of this feature.
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
nit: import toSet static for consistency with toList (see L46).
WTF is lala
Is it possible that the environment variable is not set?  if (ImplUtils.IsNullOrEmpty(connStr)) { // throw here. }
Why don't we remove Consumer from the consumersByQueue as well, like we do that in the handleCancel()?
make this synchronized.
And BTW all Eclipse resource implementations are immutable so you cannot alter the hashcode in any way.
You're welcome! As you noticed the the wrong error message was a consequence of the wrong comparison. Since isNameValid(name) was returning true when it should be false, the second if statement on enterPressed() was executed causing this bug.
Can you move this functionality to IjProjectPaths?
It would be nice to change the parameters class so that it uses List instead of ArrayList, then you could use just "toList".
this method should return Response
please use asGuid()
collect to a set that can preserve order?
@inverno Why public?
inline permissions and then remove redundant this
Statement can be rewritten inline.
Do same for this one
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
CheckReturnValue?
style: extra parentheses
How is this different from normal repository? What i've expected is to be able to somehow configure the name (and location?) of the meta data repository, say when creating project foo two repositories are used foo.git and foo_meta.git. I don't see, where/how this is done in this change.
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Why is the exception message used to determine if it's a 404 error? You can check if the status code in the response is 404 instead. exception.getResponse().getStatusCode() == 404.
Do we want to include the original throwable so it can be shown in stacktrace as "caused by"?
Optional.map
Optional.map
No necessary. + operator with a string operand (the prefix) performs auto-stringification of the other operand.
validators aren't supposed to return booleans, but ValidationResults.
perhaps have the pair as Pair<Boolean, Guid>, we don't need the entire domain object.
Please use Collections.singletonList()
If the argument selection is a NodeSelection then the method brakes it's contract and doesn't create a new instance. I'd remove the if statement.
How about return ((List<?>) ((IStructuredSelection) selection).toList()) .stream().allMatch(e -> e instanceof RepositoryNode); ?
Even if it's very unlikely in this context, you could test whether the getViewer() return null or not (the return contract is "the EditPartViewer or null") before calling deselectAll()
Restore to original. Also apply to the other similar throws.
Use parameterized logging instead of string concatenation.
exception, output to STDERR
I couldn't understand the need to get templates config and set it back again, is this required?
Is it an exceptional case for ConfigLoaderFactory to not be present here?
Let's simplify this condition
Add not-null check here.
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
@aklish what do we expect if both initializer and injector are defined?
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
How about we switch this to .replace("+", "%20") as it appears the only problematic character is the space.
why ConfigurableApplicationContext, not ApplicationContext?
one backspace too much
Rather than instantiating the view here, I think you should just pass it to the [DatasetSourceTarget constructor](<LINK_0> That way we keep the number of places where views are instantiated to a minimum because we always want to push that as late as possible. For example, support for handleExisting will probably push that until when the job is being committed.
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
Can we check this condition with a framework like Awaitility?
How about remove the property, rather than set it.
Should be hardcoded as EnumSet.class, not getErasedType(containerType)
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Here we should return Polygon or MultiPolygon or create two implementations?
Stack overflow? :)
Use creation date if received date is null?
Do same for this one
Add reasonable toString() method, returning null doesn't seem as proper way.
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
I propose we have accessors getBaseUrl() getRelativeUrl getAbsoluteUrl(). The toString() should call getAbsoluteUrl because that is the most complete representation of the object.
please also add the GUID which is important.
Should this method be final?
This should stay final
Why are we recycling buffers at the end, on close and not on the fly? It can mean GBs of extra (unnecessary) memory usage if we keep all unconsumed buffers from different channels. The ownership of the buffers returned from the iterator should belong to the caller of next() method.
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
Remember to revert this file, it should know about the transport class.
Wow, these are some pretty intricate tests. I've had a look and it _seems_ right, will have a closer look again before we merge
PtExecutors?
How can you be sure this is the remove Service and not a local service that you have been injected with ? The test return the same value for both service so I think something is missing to check that it is actually a remove service.
Just thrown an Exception.
typo: doesn't
as a suggestion you could remove the followup NPE check and use Objects.requireNonNull suggestion org.eclipse.core.resources.IProject project = Objects.requireNonNull(getProject(referencePoint), "No project found for reference point: " + referencePoint);
![Codacy](<LINK_0> Issue found: [Possible unsafe assignment to a non-final static field in a constructor.](<LINK_1>
I think this should be enough:  try (InputStream stream = classLoader.getResourceAsStream("project.properties")) { properties.load(stream); return properties.getProperty("version"); }
We can write this code as, java ClassLoader classLoader = ServerConfigurationTest.class.getClassLoader(); return classLoader.getResourceAsStream(path);  IMO this would be more readable
I'd prefer wrapping it with String.valueOf() or call toString() if it's same, but this is simpler so OK to me.
Missing codes.
Should maybe other countries be added here?
This warning suppression can be removed if the below line is changed to PartitionAttributes<String, String> attributes = new PartitionAttributesFactory<String, String>()
Can we throw an exception here instead of using the fail method?.
Could this hardcoded 3 be replaced with serials.length to ensure that the test doesn't fail if someone modifies the size of serials?
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
Keep this static imported?
Can you avoid duplicate code here? (PreferenceManager.getDefaultSharedPreferences)
you can directly put .commit() at the end of this. Editor calls always return the Editor again ;)
java @Override protected void setUp() throws Exception { super.setUp();
Nitpick: the instanceof check is redundant here.
This API is only reliable when the notifier is known a priori to be of the 'expectedClass' type. Usually we just check whether notification.getFeature() == UMLPackage.Literals.PORT__IS_CONJUGATED The getFeatureID API is usually only employed for notifiers that aren't Objects, such as Resources and ResourceSets.
This will run once every 500ms so there should be a loop sending all messages available at the start of the run. Just one seems delaying message delivery unnecessarily and substantially.
EchoParametersDao.getEchoParameters() already returns a list.
Please change this to  java return new ArrayList<>(failures);
defensive copy?
As mentioned in <LINK_0>, I would claim that setting the status ONLINE is many cases a bug. In the example of the hue binding, the handler determines the correct status in onLightStateChanged. So either we do not set a state here at all and wait for the next update (triggered through the regular polling) or we set it to UNKNOWN for the time being. Same should be checked for the other bindings.
add "this" qualifier
case GREEN: case YELLOW: return ProbeStatus.newSuccess(clusterStatus.toString());
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
use ... between 0 and 100., it's more user friendly
Please add the cause here.
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
The CosemDateTimeDto no longer needs to be referenced to using the fully qualified class name, since the name collision with CosemDateTime from the jDLMS data types no longer is present after the refactoring. Adding an import statement for the DTO class and removing the (now) unnecessary package at places where CosemDateTimeDto is used would clean up the code some more.
missing a final
directly return "" is better
Mock this also.
POST and 202 CREATED is more appropriate here
If this patch gets pushed: <LINK_0> Then you could use NetworkHelper.managementNetwork method and save a couple or repeating lines :)
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
public seems not required
No need to copy here (the class will store an immutable list)
does this have to be a list or can it be an iterable?
Collections.singletonList
Maybe checking with STRING isn't quite enough here. I could imagine a lot of Hive users using the more specific VARCHAR column type.
requireNonNull
I would say that it should return ColumnType.STRING since it's always going to be a String.
we never use NULL, it is a bad practice in general.
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
I think you have an additional "\n" at the end of the new error message.
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
Method could be marked 'synchronized' (to ensure only one caller gets to build the array). Minor issue, because it will work either way, but it'd make it look like we actually look out for these things ;) I guess we'll have to fix IntegerArrayField too.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Thanks for adding the eq() here, good catch
Would it be cleaner to just do this: <LINK_0>
final
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
I don't think this will do what we want though, because new DatabaseConnection("database1") will try to load the db's properties from the yaml. We need that connection to be lazily instantiated.
We are not passing tags, description as arguments in this constructor. So we shouldn't be initializing them here.
Can this be private, or is there another use case for default attribute outside the builder's call?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
Why an array? List<String> is just as fine
I continue to think that **aifc** should to be here...
suggestion private MockClientState getMockClientWithPreviousCaughtUpTasks(final Set<TaskId> statefulActiveTasks) {
I'd just like to say what an awesome tool for optimization this class is. Kudos to you and @cadonna .
Replace direct comparison using nanoTime with differences ie scheduledTask.deadlineNanos() - nanoTime > 0
should be VOT.Storage
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
shouldn't we also have permissions to write to the glance domain?
Be careful of nullable fields!
It's better if you could make a function like getStringWithFormFieldId(String formFiledId). You could call the function getStringWithFormFieldId("clientID"); getStringWithFormFieldId(clientSecret);, ....
Be careful of nullable fields!
Would be clearer to use a variable for the initializer instead of calling this method 4 times.
I would like this instead for simplicity  switch (arity) { case 1: return ImmutableList.of(valueType); case 2: // weight return ImmutableList.of(valueType, BIGINT); case 3: // weight and accuracy return ImmutableList.of(valueType, BIGINT, DOUBLE); default: throw ... }
TYPO !
This variable name is misleading. These bounds are _not_ verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).
This is quite a heavy class and it feels like the last two parts on translating PaxosHistoryOnRemote to CompletePaxosHistoryForNamespaceAndUseCase seems a bit of a separate concern from getting the data which the first three parts here do. We should split this up, though I'm fine with getting this in first as long as we track doing this when we return to this project later on.
nit: Please include e
Couple more static imports here?
Another static import?
More static imports here?
You can make this file File
duplicate?
Can we just use GUID's for these? seems more reliable/consistent than making up a structure.
Assert.notNull() ?
this.m_
Wrong indention for the ctor name
How about narrowing it to ClassNotFoundException and fail with other exceptions?
I don't know what to do about it right now, but I would be a lot more comfortable if the Model lifetime was connected to the PsiElement lifetime. In my ideal world, the models are just a veneer over the PSI. That's not to say it's the _right_ way to do it -- just a gut feeling. I worry that local caches in the model can become out of date as the PSI changes (the user types, and/or refactoring). Maybe my concern is unwarranted. Do your concerns match mine?
If any of the parts are null we'll end up with different strings for id nothing missing -> name/tag/instance/taskhost if tag is null for whatever reason now string is name/instance/taskhost.
Can StringUtils.fromUtf8 be used?
Does this expect product ArrayList not to be null? You can use this instead <LINK_0>
Use EOF in the test.
Revert this
nit: you can do mLGNames = Sets.newHashSet();
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Generic type not used, remove.
1. what if value is not bool? exception? you should be able to recover from it nicely 2. you doing unneeded boxing, by returning class where primitive expected, use Boolean.parseBoolean() instead 3. please cache the value of the header, there might be few queries during the hit calling isFiltered(), - you don't need to preform header retrieval and casting every time.
Nit: I would dispense with the elses since you return in the ifs.
Why are you looping here? Can you give a use-case?
checkState?
I think a foreach loop here would be shorter and easier to read - or a lambda expression in future
please remove TODO and printStackTrace() and use proper logging instead
Could you explain the contract here in a docstring? If two arrays are different lengths why are they equal if they have the same content up to the length of the smaller array?
use Bytes.memcmp()
Can this be private, or is there another use case for default attribute outside the builder's call?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
should this count be parameterized?
Pull this into a static final variable
setSelection takes an ISelection, no need to cast what you get from the viewer. you also do not need a local variable
remove assertion and change ISelection to IStructuredSelection
this change does not seem to be needed it would create 2 lists, where just an array-to-list conversion is needed
I am still in favor of removing this static. I don't think its necessary. I think if tserver wants to keep one instance, then it should keep a reference to it. All the current static stuff we have is troublesome and we would like to move away from it. Could rename this method to newInstance if you drop the static.
This line isn't happening anymore, right?
Do we need to throw the exception here, I thought we are using null as the signal of failed to create?
No need to call file.toString() -> FileWriter can take File in the constructor as well.
This should be part of the try-with-resources block.
logFileWriter
Recently someone told me that booleans are hard to maintain because you don't immediately see what the true /false really means. You could use Order.ASCENDING and Order.DESCENDING here instead.
40?
unnecessary array new: {{true}, {false}} should work here
Should we return here?
dao already present in class field of superclass.
is this still needed?
Is this supposed to be <code>return "Bump"</code>?
I would like more specific catch clauses. catch'm'all is a bit crude (and it will also happen on the ApiServlet level.
The this. in getters are unnecessary too.
@akolodziejski please use hamcrest matchers. They are much nicer. You would write something like assertThat(patientIdentifiers, containsInAnyOrder(hasIdentifier("101"), hasIdentifier("101-6"))); where hasIdentifier returns your own matcher. Let me know if you have any questions.
@vixus0 you left the other TODO in I think, if this is the test for it
I've noticed that some values are not checked, for example patient.display here, is there any reason for that ? I think it would be better to verify all used values
null? why not just a () -> {} ?
I'd suggest returning an ImmutableList or Collections.unmodifiable list here, it's generally iffy to give control of our member variables to other classes. For example, if in the future additional logic is add in to addListener/removeListener then this could give people a way to remove listeners without triggering that logic.
Missing types
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
I don't think we should have a method called validateURL if it just checks the http prefix and if we already have a validateHostname method in DatadogUtilities
Single or double pipe?
Add a new line after the @Override please :)
This code should be:  this.channel.close();
nit: we can add a validation that if streamTask != null then stateMgr.taskType() == ACTIVE.
It should be just an info, since end-user difinatelly can decide to disable asyncExecutor
Why don't you create singleThreadedExecutor as a class variable? Then we need to implement close() method inScaleInManager.
what does compare and hascode mean for datanode if they have different ssl ports?
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
Can you just change the return type of this method?
When mixing hashcodes don't just add values together. Use Objects.hashCode(commit, otherCommit, submitType, contentMerge)
I think the current state of the art is to do something like: int hc = key.hashCode(); hc *= 31; hc += value.hashCode(); return hc; But actually for an attribute there aren't too many that can can be multi-valued, are there? So just using the key's hashCode as our own hashCode might be sufficient here.
You are missing a multiplication to reduce collisions: hashCode = 31 * hashCode + key.hashCode();
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
persistent result set is available for JDBC driver as well. Why are we casting the resultset to InMemoryQueryResult?
+1, and maybe add debug logging as well
We put periods at the end of the error messages which are sentences.
Are the changes to HelixPropertyStoreFactory going into this PR?
In order to increase readability, what about replacing magic numbers with constants with a particular meaning?
What's the advantage of creating the scheduler in the factory instead of in the service itself?
inline?
This isn't really expected, but we can recover from it. I think this would be better using the error level.
can you import the ClassUtils please to simplify the line?
Use strings.xml
May be we should add the title? OH, and what about "Shared from Pumpkin Reader for Hacker News. Download Pumpkin Reader for free here"?
Should be Localized in Android framework.
static imports
static imports
Maybe rename this method to be consistent with updateAllowedConnectionType
does this have to be a list or can it be an iterable?
What about :  names = new ArrayList<>(attributes.keySet());
You can seed the size since it it known.
getCurrentVariables() => currentVariables
why starting from the identifierToken() and not directly from parameterUsage ? You can directly strart from the parameter parent.
Why do we ignore annotations under ANNOTATION_DEF?
just return directly, no need for packageName variable
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Small suggestion to investigate how could we avoid a generic exception since that would be hard to inspect if something would happen if exec will throw any exception like IndexOutOfBounds or buildNameWithIncrementedSuffixIndex throw some exception(bcs it would probably just skipped)
for create session would geoRepSessionId exist in parameters? and there would be no session in db, right?
Feature support check can be done here itself
please format
What do you think about changing to stripContextPath(request)? So stripContextPath ask for contextPath and requestURI internally.
You should possibly prepare a collection of statically compiled patterns and use before the matches() call. That will improve the performance quite a bit. The matches() call is going to compile the pattern for you every time on every request.
This URL creation is a little bit cumbersome, we should have a test for it.
extension can't be empty or /
extension.toString()
This can emulate what is done in org.apache.falcon.resource.extensions.ExtensionManager#getShortDescription. That way AbstractExtension does not have to have a getDescription method.
Unnecessary cast.
what happens when multiple servers starting...is it guaranteed these are not going to overlap ?
What happens on another OS? What happens if you put "toto says hi" instead? If it does not work with "toto", then you should verify the test can run on the system. Junit's **Assume** aims at it.
Remove this line.
Does this really work? That validate method i think expects non hashed passwords, probably you shouldn't validate this, the ticket says changePassword methods. I also think these should delegate to the changePassword method that validates the password to centralize the code
I would prefer to remove this newline and add one after the call to upgrade to separate arrange/act/assert.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
If we ever add an attribute to the ActionType (same for condition and trigger), it is also added to the CompositeActionType because it is a derived class. Shouldn't we use a function that handles the ActionType[DTO] mapping that could be called by the mapping of a CompositeActionTypeDTO, too? e.g. Java private static <T extends ActionTypeDTO> T map(final ActionType actionType, final T actionTypeDto) { fillProperties(actionType, actionTypeDto); actionTypeDto.inputs = actionType.getInputs(); actionTypeDto.outputs = actionType.getOutputs(); return actionTypeDto; } public static ActionTypeDTO map(final ActionType actionType) { return map(actionType, new ActionTypeDTO()); } public static CompositeActionTypeDTO map(final CompositeActionType actionType) { final CompositeActionTypeDTO actionTypeDto = map(actionType, new CompositeActionTypeDTO()); actionTypeDto.children = ActionDTOMapper.map(actionType.getChildren()); return actionTypeDto; }  WDYT?
This won't invoke the additional interceptors, is that okay?
Wouldn't Arrays.asList() be enough here? Arrays.stream seems to have a lot of memory overhead.
it isn't needed since onReturn() already returns CONTINUE_INVOCATION
Use Objects.equals() to handle nulls concisely.
please add braces for the else block.
Why U don't want to consider id in equals and hashCode ?
@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));
Iterate on the entrySet to avoid invoking a get on the map each iteration to get the value (findbugs)
That change definitely didn't have any value :) Please change to entry.getValue()
Could it be constant? Looks a bit cryptic
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Can this be private, or is there another use case for default attribute outside the builder's call?
Hey @oguzkocer , should this array include VIEWERS_TABLE as well?
This uses case-sensitive sorting, so "Nick Bradbury" and "nick bradbury" don't appear next to each other in the people list. I think this should be case-insensitive like the web.
I'm not exactly sure about this, but wanted to confirm just in case - SQL query takes two arguments, and we only give one. Will the query properly execute in this case?
why not list.stream().forEach?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Actually the underlying objectExpr could have free variables.
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
I think it would be suitable if some kind of padding is applied between messages, such as a newline
pls use addStatus(new WarnStatus(message,this)); or addError(...) to report failures
I see that BCECPrivateKey.getS() and BCECPrivateKey.getD() return the same value. Here both of them are used, is it intentionally? I'm also wondering if this is the same matter which just has different names in different interfaces or there is a subtlety?
Update the docs above to reflect the exception.
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
Can we show that this method is not supposed to be used directly by consumers of this class by making the method protected?
Locking the configuration shouldn't be necessary. FileBasedConfig extends from Config, and Config is thread-safe via atomic references. So you just need to determine if either file needs to be refreshed, and if so, run its load() method again to pull it in from disk.
One question, if configuration file is in local, how to make sure such file can also be read in HDFS mode. Like in NNMaster, it is run in cluster, can you read such configuration file from HDFS?
maybe we should add a log here so we know that nothing has been updated to the corfuStore and not that it is complete necessarily.
ACLs
you can call getLocalClusterRoleType
nit: this might look nicer if we collapse the config-building to one line each
I think you want to still use the old form for this test since that's the deprecated version. I would also change all the tests to deserialise to KeyValueServiceRuntimeConfig.class instead of the semi-concrete CassandraKeyValueServiceRuntimeConfig test to ensure we're doing the right thing everywhere
+1, throw so we can figure out why they don't work
I'm iffy on having this here. This is partially because we let the status update handler write to pending tasks, and partially because it means we are reusing a pending task id. Generally we let the SingularityScheduler do all of the work of creating a pending task to keep responsibility for those types of operations separate. We actually removed bits from the status update handler a little while back so that it would avoid mutating the pending task queue. Instead I'd suggest using requestManager to add to the pending request queue. This will let the scheduler do it's normal thing and rebuild a full new pending task with new unique ID from that pending request
Why not create the taskExecutionDAoFactoryBean in the ctor?
The field should be removed as well.
if we continue with this convention, please init to true also here
Need to implement
not sure about that case - the system must make sure it is able to restore the previous state of a stateless vm
This is a good approach IMO.
We should probably still look at where some accounts have different credential types associated with them.
Why not  java logging.setLevel(loggerName, Level.valueOf(newLevel.toUpperCase(Locale.US)));
- static import - why is having no delegates an error?
The configProvider is still required, isn't it? If so, we should still have Objects.requireNonNull(...) as a NotNull check.
Can you return 'this' like the other setters?
wha would it take to implement this for JPA? bit uncomfortable to have new methods only for particular type ...
Why we return AsyncClient here?
This should be used and check the ORGANIZATION_WQP_URL.
Rather than calling run here, make run() call out to a no-args method like this: java public void onClick(View view) { // ... if (id == R.id.button_done) { nextWithEmailAndPassword(); } // ... } // ... @Override public void run() { nextWithEmailAndPassword(); } private voidNextWithEmailAndPassword() { next(mEmail, mPasswordField.getText().toString()); }
Nit: this could be: absoluteUri(DHCPV6_HOSTS, clientId)
Need a space between if and ( like this "if (mSrc..."
Before go through the loop make sure that position and symbol parameters are not null.
"" + x.doubleValue() - is this the most elegant way to get a String from a double...? And if it is a usecase to instantiate a QuantityType without passing a unit, might we want to add a constructor for double as well)?
needs to be named something more relevant like market
What does the magic number 2 mean?
Do you have unit tests? Again you need to use equals
uniqueDiagnoses is a Set and by design it doesn't allow duplicates, all you need to get rid of duplicates is the call below: uniqueDiagnoses.addAll(diagnoses);
Do this check before the for(), because if this.notificationConfiguration.isEnabled() or this.notificationConfiguration.areEmailsEnabled() are false, you don't event need to load the descriptors and so on...
This should probably include the function name in the error message. Also, should the error be logged as well as the message?
This line and the line above is migration code so that no db-script is needed, right? That's fine! Why not doing it in one place (maybe also together with the if-statement), so here or in SW360Utils?
Idem this could be handled with an Optional...
This can be Optional.ofNullable(debugParam).orElse(false) which would be more functional friendly and more readable.
maxDetail won't be null, so you can just do: maxDetailLength = config.getInt("max-detail-length", 0);
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
parentSpanId should be checked for empty, and likely for null
this is dodgy with the default state backend because people may not have cleared their local span and all of a sudden the traces start having random local spans as their parent. I'd make an internal flag that's set when the state store is InheritableServerClientAndLocalSpanState. Only when that's set accept a local parent. While seems yakky, this will insure existing users against the behavior change I mentioned. It is super confusing to try and debug spans that have the wrong parent, speaking from experience!
Call I18N.getString(String) (there are no parameters in the resource messages).
I don't think you need this new String
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
You may want to use ConcurrentHashMap for thread safety when adding classloaders into this map.
should rather be named currentContextClassloader
Not doing getClass().getClassLoader() and just leaving it null would default to TCCL. Not sure which one is best.
It'd be nice to clean this up a bit and have a single constructor.
So I'm a bit afraid that there is a code out there in the while that relies on this giving the old output. Could you also add a method toFastQString() that also calls through to encode so that's there's an obvious way to do what this used to do? I think toString should probably call through to that and produce the same output as it used to just to avoid giving people surprise headaches.
Why do we return the parents name instead of the name we store a few lines above?
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
add support for javax.inject.Scope annotation
non-null assertions.
Instead of FileHandler, you should use the PropertyConfigurationLayout to save it to a FileWriter.
You shouldn't use FileHandler here. You should instead use PropertiesConfigurationLayout: java StringWriter writer = new StringWriter(); pconf.getLayout().save(pconf, writer);
s/local Unix socket/Named Pipe/
A better builder instantiation pattern would be having the Builder constructor private and have a static builder() method in the outer class. The usage pattern is like:  java RestStreamClient.builder(host, port).create();
It seems cleaner to make this private, and add 2 static constructors: ServerFrontEnd.udp(adapter, port) ServerFrontEnd.tcp(adapter, port)
I believe this line is incorrect and should be removed
hasAnnotatedAllParameters is already checked in the super class, right?
These three validations are present in multiple handlers, what about extracting to a validator method?
Why not anyOrder()?
What happens to relative links? Protocol-relative URLs? Tests don't cover those.
make public static
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
I think that CSSDOMSemanticElemntHelper should be an Singleton.
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
Missing finals for all tests in this file
should check if viewer is disposed at some point
this looks like a lot like fSide.opposite()
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
I can't believe I let this line of code get in. Terrible.
Add { and }.
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
I'd need to check, but this might fail in when poolId is null or empty. If so we need to wrap this (and other lookups in similar methods) in a null or empty check.
can we remove this method and simply have the poolsOfString.take() where this method is called?
Is the StringUtils.isNotEmpty() check required here also?
as above for cache
same here for node
super nit: make string task a public final variable.
return id;
this. prefix is not required within getters
these setters should not be public
super.init() method never throw an exception.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Does it make sense to cache the result?
remove ()
Consider changing to InternalInfrastructureException since reaching of this code is possible in case of a developer mistake only
Same as above: I think it is clear enough without the id variable same for below too
The names should be consistent. As suggested, cancelAddInstructorLink is preferred over addIntrCancelLink.
I think can just use the @FindBy defined at the top instead of findElement() againt
Shutdown method returns Future, therefore to respect AutoCloseable it might be better to call as follows:  this.shutdown().get();
While I am not denying the setter is confusing, this is not the scope of this PR to change that.
Shouldn't the cache name be the same as in the standalone.xml (spanChildren)? It may not matter for local cache, but if we decide to change the cache configurations, then it may be necessary to match up with the config in the standalone.xml.
Check command and status null.
Check if address is null.
Not sure if we want to print out the exception.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
Why going for semantic here ??
nit: not typesafe, as above.
I would say that empty response body would be more accurate message.
Let's include the group name and say it's getting the ids that failed.
null != settings
Do we really want this protected?
10
You could use BigInteger.ONE instead.
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Why would you not start with "BigInteger value = BigInteger.valueOf(0);", and leave out the null check inside the for loop? If this is because null should be returned for an empty bitStringValue, that maybe should come first.
this.
the map should also be concurrent
Seems like this should be more defensive, i.e. check for the type before casting.
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Travis is failing due to this empty line. Removing it will fix the checkstyle.xml exception.
Should be here ac.stateChangingCheck(); @zlamalp?
List<User> -> List<Facility>
Please change the return type of the method to Long: suggestion public Long call(ApiCaller ac, Deserializer parms) throws PerunException {
We should not swallow exceptions without at least logging the exception.
Shouldn't this check if ACTIVATE_DEVICE is allowed (instead of DEACTIVATE_DEVICE)?
Missing final
this doesnt do anything
with .inRoot(isDialog()) you could verify that the text/id youre matching is inside of a dialog: viewInteraction.inRoot(isDialog()).check(matches(isDisplayed))
this method is again the same and could be implemented in Base...Activity
we should add the logical types' schemas here
Would be nice to have something here to check for duplicate schema names. I don't think the base Calcite class does.
Extract to a constant?
You could just use Closeables2.closeQuietly(azureBlob);
I'm missing how the snapshot id actually gets used. From what I can tell, BlobClientBuilder (and not in AppendBlobClientBuilder; I haven't checked the others) strips it out and passes it into the corresponding constructor. I don't see a policy anywhere to put it back into the url when we send a request, so I'm not sure how we actually put this on a request. A bigger question is why are we separating it? Yes it is technically a query param but it is conceptually a part of the blob's path. The only reason it isn't on the resource path is because the rules for blob naming would produce an ambiguity if it were.
Don't do this. Consider initializing this helper class with the compute logger instead.
The original version is more precise?
Either null or empty
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
Consider using == maybe?
do we need traceId to identify the object? i think the previous implementation was fine
Should it be logged at the error level?
Strictly speaking, you should make this ApplicationContextAware and check the context in the event matches. We don't want to react to events from other contexts in the hierarchy - maybe not relevant here, but best practice.
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
This is not how you make an [unordered list](<LINK_0> in HTML. Example:  html <ul> <li>Coffee</li> <li>Milk</li> </ul>  produces - Coffee - Milk
This nice plan nesting looks like you mean a specific query plan (joining tree) shape. Is it guaranteed? See com.facebook.presto.SystemSessionProperties#REORDER_JOINS
should atleast check o being non-null and instanceof IdentityExtractionFn .
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
Can we please add limit to the exception message? So it will be much easier to see the problem!
Use checkArgument instead to throw an IllegalArgumentException?
We don't need to cast to int.
If it is a mock user, better to call it "mockUser" or so so that there is no assumptions it is something real
To follow the conventions of Spring Security, please change to "webClient cannot be null".
this should be error and use the constant and below
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
This is a great optimization. Should this point to first character in the ASCII table ? Also lets verify that this for UTF-8 encoding as well.
This is really a nit, but I would _personally_ prefer inverting this if statement:  if (sharedPrefix.length() <= contextLength) { return sharedPrefix; } ...  That way, 1) the simplest part of the code is taken care of up front and 2) the indented line is the short line, not the long line
You could add a package-info.java file to the package
I guess we can use the following instead of both lines? suggestion ensureNotEmpty("hostName", hostname);
Nitpick: use Strings.isNullOrEmpty() as we do that throughout the rest of the code.
@inverno Why public?
inline permissions and then remove redundant this
no need to instantiate this hashset (not being used?)
can we use sysprop or something for url?
lowercase for package names.
Could use '/' and ']' to avoid the need for extra NON-NLS
use 'L'
456L
use Long.valueOf() instead of new Long() - always for performance reasons
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
remove this string
rm public
Think this needs to go right below line 91. parseResponse can return null (line 133), which will cause this future to never complete.
same thing here. double callback call.
Why do we have a 5 minute timeout? We should pull this out as a constant.
Why we return AsyncClient here?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
There is only one form indeed and a Flux read makes no sense but the method can produce a Flux, i.e. Flux.from(readMono(..)), even if it will never have more than one element..
Not sure about coding style, but I wouldn't use an else here ("else after return").
By convention, files in Jenkins home indicate what they were based on class names. Maybe jenkins.install.InstallUtil.lastExecVersion?
+Long.MAX_LONG for not cluttering the JENKINS_HOME anymore!
lets return empty string "" to avoid hypothetical NPE in future code.
Should this maybe be .map(e -> e == null ? "null" : e)?
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
@sznicci do we really need everything after this line? This seems too much of a behaviour change for an issue that is very specific.
Perhaps consider a constant for "NOTIFY" as it is repeated various times.
This is a nice test. Demonstrates how simple and clean it is to create and submit a job.
Hrmm... I understand why this was changed and what the issue was (ID generation is only done on persist), but this isn't correct either -- the implication is the default state is "queued," and we're creating by default; neither of which sits well with me. At the very least, we should move this down to the try block with all the message sending.
if you are synchronizing whole methods on the same object, you might as well use the class's monitor, by using the synchronized keyword in the method signature (public synchronized void ...) This avoids extra sync objects (and saves one level of indentation!)
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Unnecessary?
@weisebrazil all indentations should be 4 spaces, not 8.
@dmzaytsev This is a confusing design. Why are we changing the Github URI? Instead let's pass a fake request that we can check as originally described in #42.
It's an obvious code duplication. We can save this new request with a modified URI into this.request, and use it in all methods. This is how it works in other classes, take a look
is this something like /system/tasks ?
java throw new AssertionError();
__ -> scheduler
why not use @Inject ?
null check should comes first. ie, if (StringUtils.isNotEmpty(userName) && (userName.indexOf(UserCoreConstants.DOMAIN_SEPARATOR)) < 0) {
Can't we use COMPONENT_NAME here?
Doesn't look like we need such an assertion at all.  if (index != null && container.has(index)) { return typedValue(container.get(index)); }  So, we are good to deal with whatever JsonNode we get. Looks like the previous Jackson version was different, but now it is a bit easier to avoid extra checks.
no need to catch exceptions. just let them propagate.
Add markInitialized() after assertion, in case of "-ea" is disabled ducktape hungs while waiting service.
Style-nit: Spaces around operators (=, !=, etc.)
It shouldn't be public
nice maybe try finally?
Too few IMO, but :man_shrugging:
Stack overflow? :)
Please add curly braces around the next statement.
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Seems like there are certain methods that can be pkg local
Same here too, seek, read and continue with read, verify in the second read, we are reading continuing data or not?
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
Check if byte[] b is null.
what about location ? we do not need LocationSerializer ?
this is redundant
Will this have any effect to legacy data (i.e. those existing before this PR)?
Used to be fileSystem.deleteFileOrThrow underneath.
one param per line and leave the first line empty
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
isn't it true by default?
If we can't get a model-set, will anything work? Perhaps this should throw an appropriate exception in that case.
This is not clean. If this method now returns an absolute path, you should also change the method name from "getName()" to "getAbsolutePath()". Also, you will need to change the messages. With your change, the FSOperation_ConfirmFolderReplaceMessage would now say "This folder already contains a folder named /foo/bar/target/file" . Which is not accurate. Instead, the message should now say something like "Folder '/foo/bar/target/file' already exists. Do you want to...' Or you could change the code even more, to say "Follder /foo/bar/target" already contains a folder named "file". Do you want to..." Please make sure that you test the workflow, and validate that your final message makes sense.
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
I think we should at least log this exception here before throwing other one
Is it worth distinguishing what is null in this case? Is it different if m_txnState or the invocation is null
I believe this method should be getServerMetricConf()
Boolean vanished?
this can be static (most likely will need to be)
This is a local variable, should be camelCase not fCamelCase
There's no packet data, this contains partial NRB data amputated by what was read in 28 bytes of packet header (incorrectly).
I think 28 bytes have been read into the packet header (incorrectly...), so it will read too far into the next block?
Sort of believe We should have MetricManager in parameter given this case.
Agreed. Yep - that's why I mentioned it was fine, though it looks weird
Why do we need this constructor?
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
Maybe return a String or boolean to confirm that a path was removed.
I don't think this is needed.
make it final
We don't really need this log string anymore.
What do you think about making more general methods like: verifyTopLeaderboard and decide what selector to pick inside this method? Based on wikiPage object/browser info.
Please remove extra line
Don't repeat 4 lines over and over mainPage -> page ;; -> ;
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
Why include the name in the comparison? fullName should be enough.
Check if byte[] b is null.
Allocating a new byte[] for each integer read is going to be super inefficient. It would make sense to reuse the buffer. This method suffers from the same problem with read not guaranteeing a definite number of bytes.
could use writeInt(Float.floatToIntBits(v)) to avoid code duplication.
This will return an immutable map. Use new HashMap<> instead.
Shouldn't this be warning instead of info message? The message "kieMap not present with compilationID and container present" is a bit confusing Is the kie map not present? Or is it present but doesn't contain complationID? Imagine that you are a user who sees this log message. If the message is good he'll immediately know what's wrong and what and where should be fixed. Otherwise he'll have to look at the source code to understand what's wrong :( Also there is probably duplication of log messages on line 194: getLog().info("Kie Map not present"); - we should probably only log this at one place.
nitpick: I think code reads easier when you put the positive case first rather than negating a conditional
Same as above, this looks like an error.
You can safely remove the file.exists()(implicitly done by isFile
I don't think the process deploy should fail in the case of temp file deletion fail
I agree with your point. Good catch. I want Ravi to review as well.
if we already called clearAsyncTask(), wouldn't we want to remove it from the list regardless of vdsmTaskId?
Let's break this line around ~80 characters or so.
events can't be null
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
we don't need to change the Creation classes.
We can make these methods as private I guess.
should this be fired on job submission?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
- log warning that option is not supported by SNMP
should be edit
why add?
It seems that the HotPlugUnplugVmNic Command is being used for both Plug ("Activate") and UnPlug ("Deactivate") actions. Therefore, I think that the ActionMessageParameters should be set according to the "Action" property within the HotPlugUnplugVmNicParameters class: If getAction() is PlugAction.PLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__ACTIVATE" message ("activate"). If getAction() is PlugAction.UNPLUG, then the CanDoActionMessages array-list should be added the "VAR__ACTION__DEACTIVATE" message ("deactivate"). [worth consulting with an engine-core maintainer about this]
don't return null, we can either return an Optional or fail with a ClassNotFound with a clear message that neither of the two classes was available for cleanup.
Please add a space after (Class<E>).
Are you sure you don't want to pass testClass instead of currentTestClass here? Passing the outermost class with @RunWith doesn't appear to solve #816
The difference of ProcName and StringClassDetails is? The targetServer should add to toStringClassDetails?
getNonEntityNonCollectionRegions creates a copy of all the collections, let's lookup the other maps...
Please remove the "this".
This won't work with generic builders I think.
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
Correct me if it's wrong, but I think the first block with "if (isVoidMethod(method)) {" is not needed anymore
Possibly the better option (not requiring waitForSQSContainerToStart) would be to use different waiting strategy (reference: <LINK_1> java .withExposedPorts(80) .waitingFor(Wait.forHttp("/"));  withe the port exposed by sqs and end the endpoint pointing to the queue we're interested in (<LINK_0>
@Nullable
You're supposed to call super.toContainer() to retain the necessary information such as the data version of this manipulator.
If the Repo fails and is later run again, would this cause it to fail?
log creation on each run() ? that is redundant
this log seems useless, remove it
How about applying this method inside convertColor to avoid duplication and to make sure the same input sanitation is applied? Looks like in all cases color.trim() is desired before calling convertColor anyway.
Maybe wrap exception instead of only copying the message?
If color can be null, make the color parameter of the method @Nullable
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Should this constructor one just delegate to the new one with Function.identity()?
Args.notNull
Why U don't want to consider id in equals and hashCode ?
Again, just return the boolean value.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
Do we need this else block?
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
We don't need to cast to int.
checkState
DoubleMath.isMathematicalInteger?
code format
Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details. suggestion return super.toString();
Should be public.
Should be public.
Should be public.
For consistency, I would also make it so passing -1 results in a nullValue
Should we not assertOpen _before_ we readValue?
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
What if we requested 100 events, only 30 showed up in the timeout period, and the next work item wants 10? This logic will add another 10 credits (making it 80 credits) even though we don't need to add more credits to the link.
remove
Maybe "typeExecutor" rather than "indexWork"?
why is the first parameter a LayerCommand if we only need the resulting Layer?
Is there any way to check that it actually came from the cache?
This and other setters don't have to be public, could be private.
This might also seem like a good case for an executor listener, that could be used to listen to the submitted job ids, but that's maybe a future change.
Maybe use message "Config job.name is missing" ?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
true=>false
note that we should always take the cluster's compatibility version in that case, even if the vm is set with custom one and the cluster's compatibility version is cached in VmManager so we can take it from there instead of using this costly query
You have a getVds() method
Can we either use assertEquals or assertThat. assertTrue or assertFalse are not ideal when they fail, as the usual error messages not telling you what exactly is wrong, whereas the others at least tell you something like actual true, expected false.
Is this for debugging?
Are these mock objects used?
Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ?
I think the code will be easier to understand like that: java Object object = getInstance(); if (object == null) { clazz = getConstructorOrMethod().getDeclaringClass(); } else { clazz = object.getClass(); } ITestOrConfigurationclassAnnotation = getAnnotationFinder().findAnnotation(clazz, annotationClass);
Admittedly IllegalArgumentException isn't the most appropriate type for mapper annotation misuse, but IllegalStateException isn't either: - IllegalArgumentException: _Thrown to indicate that a method has been passed an illegal or inappropriate argument_ - IllegalStateException: _Signals that a method has been invoked at an illegal or inappropriate time_ Between the two, I'd rather keep IAE for the sake of backward compatibility.
@paulodamaso the braces and return are not needed here
@fanifieiev the same above.
@super132 please use Collections.emptyList()
We only set thisReadSequence and mateReadSequence in the ReadHead, right? Why don't we have set(long uuid) for those kmers which aren't ReadHead?
for write and getActiveMessageFields, you can check if the lists are null OR if their length is 0. If either of those cases, don't write/read them.
At a high level this is what I meant.  java // member variable AtomicBoolean shouldRotate = new AtomicBoolean(); ... In the TimerTask shouldRotate.set(true); in save() if(shouldRotate.get() == true) { // do the file rotation ... shouldRotate.set(false); }
should this throw an exception? [the same for all the other similar cases]
Looks like the code that uses empty constructors (Annotation(), Video(), OptimizedVideo()...) is inside the entities package. Could it make sense to mark these empty constructors package-private so that it's clear that these should only be used in that way?
If only for frameworks, please make this package protected.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
Null comparisons can be replaced by UtilMethods.isSet(object)
All actions from
It is the same in this line, leave a blanck space before "+"
Shouldn't the key() and value() method also be renamed? Same in async client too.  return setSetting(new ConfigurationSetting().setKey(key).setValue(value), Context.NONE).getValue();
Could not happen, this block could be removed
I would prefer to use String.valueOf(value)
Same as above. this is deprecated and should no longer be used.
This is deprecated, we should use MoreObjects.ToStringHelper(this) instead.
Unsure this addition is useful.
reuse getAcceptableTokens()
I am a bit confused that this check will be called on almost every line of code.
@romani Should it be possible to specify different naming conventions between parameters and lambdas? If so, this shouldn't be a required field, but be acceptable and default.
Replacing "\" does not require regular expression, use replace("\\", "\\\\\\\\") or replace("\\", "\\x5C") instead of replaceAll().
As discussed, let's use existing JavaMail mime utility for unfoldung and additionally escaping the quote. As MimeUtility.quote(...) optionally surrounds the result with quotations, you'll also need to remove the quotation when using escapeHeader above.  return MimeUtility.quote(MimeUtility.unfold(text), javax.mail.internet.HeaderTokenizer.RFC822);
Why is this needed?
Typo: "visibiltiy" -> "visibility".
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Is there a reason for not using the MoreObjects.ToStringHelper instead?
For increasing stability "wait" is better to use than "Assert":  waitUrlStartsWith(testRepo.getHtmlUrl()); } private void waitUrlStartsWith(String expectedUrlPart){ seleniumWebDriverHelper.waitSuccessCondition(driver -> seleniumWebDriver.getCurrentUrl().startsWith(expectedUrlPart)); }
<LINK_0>
need to remove downloaded package here
could this hide bugs? Would it make sense to throw an exception or simply remove the check? Also because 0x0 is a valid code point this makes this return value a bit ambiguous. I'd be in favor of just accessing the array and let the JVM throw an error if this is possible.
This should be trivial to unittest.
this creates a hard dependency on the outer class and will make future refactoring a bit harder if you want to extract this class to its own file. Perhaps tokenSep should be passed or made a member of this class?
Hum seems we are already setting this listener
Should me make it default and use Objects.requireNonNull? The logic of the setter is a bit unexpected
What is this good for? If the goal of this PR is a refactoring to DS, bundleContext.registerService should imho nowhere be used anymore.
trivial: you can remove the isDebugEnabled wrapper
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
You can make this a bit cleaner by calling data.isData() and data.isHole().
@qeesung: nit you can merge the above 2 lines
This may be absent, so the API should express this. It can either be an Optional<Integer> or a @Nullable Integer
You seem to have duplicated the loop here?
remove 'driver' parameter (yes, a know you didn't write this line, but please change it :) )
I know its not your line, but please remove "driver" parameter. This parameter is not needed here, because screenshot is not needed in verification methods.
Could consider removing the word verify from the logging description.
It's better to restore settings back. java prev = erlangSettings.SPACE_AROUND_ARROW; try { erlangSettings.SPACE_AROUND_ARROW = true; doTest(); } finally { erlangSettings.SPACE_AROUND_ARROW = prev; }
We should mention this default value in the getter and setter
You need to synchronize on cachedSettings while setting as well as invalidating the cache, add double checking too.
use execute i mentioned above
replace (String) js.executeScript(script) with js.executeScript(script).toString()
use js.execute(script).toString()
Looks like both XmlTest and XmlSuite could share this code. Maybe extract it in a common parseParallelValue?
Two "parallel"?
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
We don't need to make this change, do we? Let's try to minimize the changes to the existing code.
Or even better, this.mName = Objects.requireNonNull(name);. To be check everywhere else.
Calling a public method from a constructor is error-prone, could you extract the default implementation of refresh() to a private method?.
Oh yuck. ;)
The convention is to use ',' instead of '\'.
Please put @Override on the standalone line
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
The lock was fine before this change. But after the change, there are two locks to protect the sessions, the lock on SyncManager class and the SyncSessionHolder class. I feel there would be a problem when calling methods from SyncManager and close the Realm. Can we optimize the code to use one single lock instead?
Should we log a warning if the syncSession doesn't exist?
Item dropped should be a hopper
Change this to == and I'll merge it.
unnecessary array new: {{true}, {false}} should work here
I would check getQosOverridden().getIsChangeable() instead of (!getIsToSync().getIsChangable() || getIsToSync().getEntity()) but as you wish...
style - move the '@Override' annotation to a separate line above
Try moving it to the previous line. I think it should solve the tool-tip issue.
Why do we use iterators? I know the base class does, but why in the first place?
I am sincerely asking, which one is clearer. (this one until streams are fixed, is faster, but that does not matter IMO). {ImmutableList.builder b = new Builder(); for(ILayoutToEventName eventNameLayout : fEventNames){ String eventName= eventNameLayout.getEventName(layout); if(eventName.getEventName(layout)!= null){ b.add(eventName); } } return b.build(); }
Get it from the model now that we have one?
Why the change? This is going to cause a memory leak if the SaveSmartLock fragment is rotated since it's a setRetainInstance(true).
This should be done generically in BaseSingleFragmentActivity I guess, instead of needing to have the Fragments query the Activity's launching Intent extras. This would make the Fragments much more modular, as can be seen here.
suggestion Log.i("INFO", "Starting onClick on fab from FragmentDiets");
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Is this an exceptional condition?
Is this already protected by a lock?
Does it make sense to set globalMinimumClock as 0 when workerClockMap is empty?
This also seems kinda pointless and a bit brittle. Just return resource.
null?
We should handle the case where getDAnalysis() returns null
If createParams should always have commonParams and commonServerParams, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.
assertNotNull ?
Removing a child from config while iterating through its children seems like it would cause problems. It would be better to operate on a copy of config and remove things from that copy, then return the copy.
@cvrebert maybe MkIssueEvents.class.cast(?
I don't think that Exception can ever be thrown by this method
this doesn't looks good at all :( let's log the exception using Logger.warn().
Remove useless assert
I would delegate to the new method directly
I'm confused. Which of these catch clauses is the expected one?
Exception isn't thrown by consumer.close(), it should be removed.
socket might be null if an exception was thrown in sendToSocket catch clause.
We may also want to cancel our subscription.
why needs this method to be static?
please change Preconditions to static import.
If both conditions are checked, getWikiTypeFromWikiId is called twice. You should first assign getWikiTypeFromWikiId result to a variable, and then test : String wikiType = getWikiTypeFromWikiId(wikiId); if(PortalConfig.USER_TYPE.equals(wikiType) || PortalConfig.PORTAL_TYPE.equals(wikiType)) { ...
Could you replace the magic number 128 by a constant?
![MINOR](<LINK_1> Make "getKeySize" a "static" method. [![rule](<LINK_2>](<LINK_0>
use same type for instanceof and force casting
Is it an exceptional case for ConfigLoaderFactory to not be present here?
load() not needed anymore, and need to catch RuntimeException.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
This line isn't happening anymore, right?
I don't think this is possible, if the cache is not defined it will be created with the default configuration.
You should probably test with both pessimistic and optimistic transactions, and pessimistic with both RC and RR isolation levels. Also multi-node tests can reveal more issues than single-node ones, I think (testing both owner and non-owner variant).
make byte-ray.new a constant and use here.
remove 'throws IOException'
I think we should TRY to move before we update the file path
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
@ILikeToNguyen Why the change in visibility here?
This could be null, we should probably handle this if the JIRA api changes again
- shorten to assertJtsEnvelope("MULTIPOLYGON EMPTY", new Envelope()); - ditto other tests
I think this could be logged as just debug.
private methods go after public methods; please, move this one to the end of class
can't we just store filename = String.format("%s.%s", filenameBase, "values"); and not have makeFilename called in multiple places?
Probably should crash if bad format string
I'm not sure if we should do this eagerly. Doing so might slow down other use cases. WDYT?
Please catch GroupResourceMismatchException from conversion method here and wrap it to ConsistencyErrorException. Because on input, there is no group and we retrieve groups assigned to resource - hence from the same VO and there shouldn't happen any Group-Resource mismatch.
I'm not sure this is consistent with the rest of our API. Like this you always return all member-group attributes, even if caller specified eg. single group attribute in the outer API call. So you should probably check emptiness only on outer attrNames param and not on filtered values. But maybe you have different expectations for this specific method.
shouldn't this return at least the group ?
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
Why skip removeChild(location)? Shouldn't the location be unmanaged?
Shall we use JSONObject in here rather than building json string by hand?
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
(not related to this issue) Should AutomaticBean issue a warning when a deprecated property is specified in the configuration?
Collections.singletonList
return Arrays.asList(....)
return Arrays.asList(boolean.class, Boolean.class)
Is there a need to have log.debug within transaction scope?
it appears that this change can be reverted.
Why do we need double logging here? One when logException is called and later in 101-102.
Can make this into a singleton as we have with UNSET.
return Collections.emptyList();
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
nit: Perhaps you should show the user how to parse the JSON?
Add a proper log message.
Seems very odd to call onSuccess method in onFailure. May be have a method called onEnd that is called by onSuccess and onFailure
Same thing here, I don't think reset should stop component. What is the difference between these two lines and runtime.getComponentManager().restart(true); ?
I don't think it's easy to read. From my point of view, I will expect to have a proper stop, then refresh and then start. Or if start is just here to ensure a state, I would prefer to have a proper call to another method.
Maybe move this method to a separate ScriptingTests class.
Please keep this.cell near the related fields (previousFamily & cell count) below
scheduleTimes --> scheduleTime
useSSL and sslPropertiesLocation must be propagated from here.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
Encapsulation
return !isNullOrEmpty(string); If the trim logic is important, feel free to update the method.
This is another behavioral change that I don't want to see in an unrelated PR.
You can do this just using what's built in to Java:  return String.format("Notifications [notifications=[%s]]", notifications.stream().collect(Collectors.joining(",")));  But ImmutableLists toString() pretty nicely, so you should just be able to do this:  return String.format("Notifications [notifications=%s]", notifications);
Curious why we want the IBAN implementation detail in the name if we no longer have the createRecipient method?
I'd call new Response(this)
This copyOldResponseToNewResponse method can be error prone because it does not return anything but causes a side effect. It's not immediately clear which object is copied to which. Can we move it to FeedbackResponseAttributes? Or may be make it a constructor of FeedbackResponseAttributes?
Can you add getId() and mark id() as deprecated?
You could probably use the same URL as in getResultById here.
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
not all listener
not all listener
not all listener
@erikdw MESOS_SANDBOX is set by Mesos correct? Wondering if we should override System.getenv("MESOS_SANDBOX") with logdir only if storm.log.dir is configured?
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
unecessary test : less is more.
You missed a check on the type of classes
I do not get the meaning of the message. Also this could be moved to #8263 and merged sooner. Also maybe we should get rid of default implementation of close() in SpillContext interface. If you decide to do so also add it to #8263
Could you please use Collections.singletonList() instead? The combination of using a static import and only passing one parameter made it hard to see that this was Arrays.asList(T...)
You can replace this getArrayProperty().length check with a call to configurationService.hasProperty(). That's the recommended way to determine if a property exists in our configuration.
Since we are using ButterKnife please avoid the use of findViewById. This ensures that the code structure is same throughout the app.
This should not be changed, you should only be changing search methods
This can be java return valueOf(value.toUpperCase(ENGLISH));
nit: Unsupported byte value ' + value + ' for row kind.
There is no default case here. What about longs or binaries or other PropertyTypes?
> return new String[] { resource + "/.default" }; [](start = 7, length = 48) Should this use the DEFAULT_SUFFIX constant above?
Can you remove the ***
Use Optional.getOrElse() here. E.g. String fromState = this.fromState.getOrElse("_")
Maybe for cases like this where the list is only consumed once it would make sense to add a mapLazy that is based on something like this: java static class LazyMapList<I, O> extends AbstractList<O> { private final List<I> list; private final Function<? super I, ? extends O> mapper; public LazyMapList(List<I> list, Function<? super I, ? extends O> mapper) { this.list = list; this.mapper = mapper; } @Override public O get(int index) { return mapper.apply(list.get(index)); } @Override public int size() { return list.size(); } }
what about concurrent closure of statement ?
Could move this also into the if brach below, so that it is not created for KILL ALL
Some proxies may not grok the comma-separated headers; any reason we can't just do Cache-Control: no-cache here?
Seen proxies before that didn't parse multiple entries on a Cache-Control line. Do we need both, or can we just use max-age?
NB: no-cache is a value usually found in requests, not responses. I'm not sure of the effect in this case. To be on the safe side, I'd update this to read private, max-age=0 instead.
Ideally, we should avoid using getProperties(), so the code that does this should be factored out. getMimeType() in SparkStreamingPlugin is exactly what we want, so should convert it to utility code.
Again I could be wrong (which would be the nth time today ;-) )By adding this code will we still hit the filehandle issue they saw before?
After some thoughs, shouldn't we check that the module is a Web module instead of excluding EJB modules ?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
This line can be combined with previous line.
Please call this one time and also check only one time.
I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Those two lines can be extracted to a method createTestMessage or so
remote this
check notNull?
Huh?
It makes sense for this method to be boolean. I am not sure we should be throwing an exception here. The caller can decide that based on the return value.
s/policies/policy
Missing opening "(" before getDescription().
I'd like to see our Throwables.throwingOnlyUnchecked used here
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
That would create a warning. The only safe way to do that is casting from the caller.
I would retain the existing indexOf body to to avoid indirection in the most common case.
2 => field name
this condition can be incorporated into the for loop
I think it's safe to remove the local recovery info in the caller thread and then return the stage. Slightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
I think here we could actually return the new KillableCompletableFuture. Otherwise the call-site has to know that this might implement Killable, that is not very common. By changing the interface to return CompletionStage I was referring to loadNextBatch, but that could probably be a dedicated PR, as it isn't involved here at all.
Static fields should be accessed statically rather than through an instance: Person.PRONOUN_HISHER
We should talk about this one: I think it needs careful thought. The acceptors for example are just going to fail the legacy requests with a TruncatedStateLogException (see PaxosAcceptor.checkLogIfNeeded()) which might affect our visibility into them
This should be able to check if logs.size > 0 and remove the first element to return.
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
Could you use "submit"?
I would prefer if you change the bundleContext member from default to protected. getBundleContext() is used to initialize the bundleContext variable only once (I know the description is not correct).
How about distributionMap.compute instead of distributtionMap.put ?
you could flip this condition around and use it to determine up front whether you need to create a new block. Then you have the actual write logic in one place. Stylistic I guess, but it's another option.
Why this throw? Is it because sources don't produce RLEs?
objectId
NBTExtras.NBTToList should be replaced with call to NBTHelper, we don't have a list one yet but you can just recreate what is there already with getSet and create a new getList method that instead of creating a hashset creates arraylist
It limits the usability of the telemetry to the code which was removed from Java. So we won't be able to discover any issues related to libraries in Jenkins plugins
Default should be false
Default should be false
It could be useful to factor out this constant, which is also used by org.nuxeo.connect.client.jsf.AppCenterViewsManager.shouldValidateStudioSnapshot
Need to check those variables are initialized or not to avoid NPE.
doc
why not deleting inside shutdown hook?
This method is no longer waiting for the refresh operation to complete. Not sure if that is important for the test flow or not.
This will NPE if BundleRevision.getSymbolicName() returns null, I would reverse the equals target to be symbolicName.equals(bundle.adapt(BundleRevision.class).getSymbolicName()) This does not scale well if you have large numbers of bundles. If this is a hotspot of your code you can consider using org.osgi.framework.wiring.FrameworkWiring.findProviders(Requirement) using an "osgi.identity" namespace requirement. If I recall correctly virgo uses Equinox regions. That can end up hiding bundles from a BundleContext perspective. Using FrameworkWiring.findProviders would bypass the equinox region hooks so you need to be aware of that.
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
@komaz maybe for now we can just return empty iterable, there is no need to react so strongly about missing implementation.
This will probably be permanently unsupported.
MemStore is used for tests, so we need to implement this function.
should return false if the validation fails
this should be in super as well.. even first
You can remove all the following code: if (!(.... return false; } return true; With simply : return super.canDoAction() && canRemoveVm()
This method seem to return just two states - boolean would be much suitable here and in the DRL rule when this method is called, we can penalize directly by -1 for each task that does not accept the assigned user.
worth fetching user (in query) via session (if not supplied in parameters for back. comp.), this way you won't have to supply it here (consistency)
merge line 76 and 77
Please use a constant for 194 (like MAXIMUM_STRING_LENGTH)
please use (1 << priority) instead of priority + 1
This virtually the same code as in AddImageFromScratchCommand - can't it be extracted to a helper somewhere?
looking at the gson code base, remove also could return null if element not exists hence we might want to guard aganist NPE here as well.
jsonObject.get(name) can return null if element does [not exist ](<LINK_0>, we might want to ensure it's not causing NPE in JsonNodeUtils
You need null check here, and create a nullNode if from/to is null, instead of a numberNode
seems that this really needs a companion method isVararg() and maybe even throw if not vararg
Frustratingly, this isn't even enough. We need to do likewise above for collections, as on 270.
Would rather be Qubole Spark 2.2 ?
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
Can you extract a constant whilst we're at it?
There is a lack of symmetry here. positionGap should be initialized in both ctors.
rm public
remoteVolumeName passed twice. I feel remoteHost to be passed as second arg
Would this method stop the rebalance as well? I can not see stop call here.
a matter of test - but the return value can be inlined here
Can you just change the return type of this method?
Shouldn't this be member? I think there are a bunch of places below where you have it as session, too.
Should this be false or true?
Just want to double check that the following null check is correct:  if (mScrollDirectionListener != null) { mDetector.onTouchEvent(event); }  I think yes, since mDetector is always not null, and it fires updates on mScrollDirectionListener.
why are you using getAdapter() and not directly mAdapter?
why getAdapter() and not mAdapter?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
This should stay final
Perhaps this should always include the zeros, and be fixed width #RRGGBBAA
Have you considered skipping the line above by having something like Queue<ControllerAction> result = new ArrayDeque(queuedActions);
The control-flow is somehow 'overlapping' because the if-else-block cannot be substituted with a function call. Please use this more 'straight-forward' version: java if (this instanceof PriorityQueue) { return (PriorityQueue<T>) this; } else { final Comparator<T> comparator = (this instanceof Comparator) ? ((Comparator<T>) this) : (Comparator<T> & Serializable) (o1, o2) -> ((Comparable<T>) o1).compareTo(o2); return toPriorityQueue(comparator); }
Should we chain the originating exception onto this or would that just be bloat? Could also preallocate a dummy exception with no stacktrace to avoid log bloat and overhead in times of strife
This should follow the normal exception handling path and let the caller handle the printing of the exception.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Can be replaced with contains()
Please move such updates to separate commit of the same PR, as it is not related to issue
Too much nulls in arguments, please make variable content = null and use it in constructor. Please apply the same for all other test method you changed
do we actually want to trigger a selection when setting a filter as default?
Please use assertThat (result, failsWith(NAME_OF_FAILURE))
I suggest to add validation that disconnect method is never called, but it's up to you.
I suggest to add validation that disconnect method is never called, but it's up to you.
@RomanNikitenko just FYI - com.google.common.base.Strings#nullToEmpty
This branch is not needed
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Multi return is forbidden.
List<BankDto> bankModelList = isBank ? bankService.findBankList(null, null) : bankService.findUmpBankList(null, null)
I guess referenceListView.setItems(...) is a bit shorter ;-)
Why did we make this public?
should probably be getParameters().isUseCinderCommandCallback() && <remove stateless snapshot or create stateless snapshot>
I guess we can remove the unnecessary this. accessor from these getters as well.
please move the isEmpty methods to the scimSchema
I think 15, 11, and 4542278 should be named constants.
Logic: We should not promote incorrect conventions. There should not be a blind cast to Customer in equals().  java public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof Customer)) { return false; } // Its safe to cast here. Then the usual equality checks }
could be simplified: Collections.addAll(refsSpecs, specs);
Isn't this quite ineffective? We are implementing a method which explicitly expects a fully qualified ref name and which therefore does not have to deal with iterating SEARCH_PATH. But the implementation is done by calling the expensive method which does all this iterating over the SEARCH_PATH and to throw away the results if we see the input ref name was not the a qualified one. Maybe an internal getRef() method should learn to use a explicitly given SEARCH_PATH.
can you put braces around if block please.
Formatting issues. Please use appropriate spaces between string literals.
Why are we eating the exception here?
static
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
unneeded throws Exception
since you have to rebase anyway, could you rename this to connectorRestApiClient
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
I'm wondering whether this is something that should be computed once, stored and then reused. The reason being basically 1) stability of the result (is it possible that the name changes between multiple invocations?) 2) performances (there're multiple string concat involved in computing the name). WDYT?
Is it an exceptional case for ConfigLoaderFactory to not be present here?
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Please consider adding an overridden version of the Script(String, int, Logger) constructor that accepts Duration to encapsulate this type conversion.
Minor: From what I can tell, this is only used in one place (JobNodeConfigurationGenerator). Since this is fairly simple now, would prefer removing this class and inlining the generate method there.
question: why do we need the TableImpl class? The only usage of the tables map is in ExecutionPlanner.createJobGraph() and it is only taking the TableSpec keySet. Also, it seems that TableImpl class does not provide any further functions except as a container for TableSpec. Can we remove it?
s/RemoteTable/RemoteReadableTable
Keep an static GeometryType array private static final GeometryType[] ID_TO_TYPE_MAP = new GeometryType[] {POINT, MULTI_POINT, ...}; Then you can avoid the switch branching for better performance return ID_TO_TYPE_MAP[id];
Looks like eventPriority OFF is missing. case OFF: return Level.OFF;
Gson doesn't run on these versions so I don't see any reason to include them.
Is it necessary to call this again?
catch Throwable? When methods shouldn't throw, like where shouldThrow is false here, it's easy to end up with a hang because an exception type changed.
As there is no else branch you seem to allow unknown/unexpected fields. Is this always allowed (i.e. per setting on the mapper/parser)?
Argument name
Argument name
I'm guessing you don't want the name to be null either. Should it be specified or is it assumed obvious?
This will trigger for thread exists also. We should make sure we are dealing with a process using: if (event.getDMContext() instanceof IContainerDMContext)
Looking at the CommandCache#reset() method you pointed me to, it made me realize that we should check here that ctx is not null first, to avoid any risk of NPE.
fCommandCache stores the MI command we sent to GDB for a particular context. My guess is that it can also be associated to an IMemorySpaceDMC. In that case, I believe it should also be cleared when its parent IMemoryDMC resumes. If I'm right, you should be able to trigger this issue by requesting the exact same memory after a resume or suspend; my guess is that a cached MI command will be returned with old values.
Would it be better if we add a logic to check whether the actionMode is null or not to prevent resetting the state of toggled items? if (actionMode == null) { beginRemoveLanguageMode(); }
Can the two sizes here be extracted to constants, since they're referenced in multiple tests?
+ NUM_HEADERS + NUM_FOOTERS;
should this be else if?
Planning on making the number of retries configurable?
LocalizedMessage.cannotViewPipeline(pipelineName) isn't correct. You need to create & use LocalizedMessage.cannotOperatePipeline(pipelineName). You will need to also add message PIPELINE_CANNOT_OPERATE in localize.xml & localize_ja.xml.
Let's avoid raw types, please.
hmm do you think we should rename AirGoogleMapFragment to include Native in the name? I like how this Builder indicates that a native map will be created, but AirGoogleMapFragment isn't as obvious that it provides a native map
Would suggest using another MapID for 006 and 007 to break dependency from 001 and 002 to be successful
This can produce a different module name than what's actually produced by the compilation in the case of sanitisation. Instead, it should just return the precomputed modulePath like so: return ExplicitBuildTargetSourcePath.of(getBuildTarget(), modulePath);
ContainerUtil
Easier to just use ImmutableSet.of() directly here for a singleton set.
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
This would be better as SpecfileLabelProvider labelProvider = new SpecfileLabelProvider(); if (project!=null) { labelProvider.setProject(project); } viewer.setLabelProvider(labelProvider);
the constructor already asserts that
Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.
Check other tests in this class. Replace startGrid(1); by startClientGrid(1);.
this change is no longer needed.
Remove "TestAggregateIdFactory" as this method is already static-imported
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
make this synchronized.
lines should not exceed 80 characters
Assert on proper error message as this will hit any implemenator using the default class generation.
use as loopvar?
I know you just re-factored this code into another method, but I am asking myself why the getItem() method is called on the itemRegistry vs itemUIregistry in case of the basicui.
This sounds clearer:  if (cartItem == null) { addItemToCart(); if (sessionItem == null) { addItemToSession(); } }
How is a loop better than: int count = detailCache.getHandlerCount(); return count > 0 && detailCache.getHandler(count - 1) == this;
nit; offset is not used.
Suggested to extract a static utility function zeroOut(ByteBuffer)
Please add a java Objects.requireNonNull(computation, "computation is null");
Please add a java Objects.requireNonNull(computation, "computation is null");
java Objects.requireNonNull(callable, "callable is null");
Should this method be final?
This should stay final
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Program to interface, not to implementation - please change return type to Map<String, Object>
super.getExclusiveLocks() - can be null map.putAll(null) throws NullPointerException
I would add more detailed information about the sample here:  if (ioSample != null) { parameters.put("Number of samples", HexUtils.prettyHexString(HexUtils.integerToHexString(1, 1))); // There is always 1 sample. parameters.put("Digital channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getDigitalMask(), 2))); parameters.put("Analog channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogMask(), 2))); for (int i = 0; i < 16; i++) { if (ioSample.hasDigitalValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " digital value", ioSample.getDigitalValue(IOLine.getDIO(i)).getName()); } for (int i = 0; i < 6; i++) { if (ioSample.hasAnalogValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " analog value", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogValue(IOLine.getDIO(i)), 2))); } } else if (rfData != null) parameters.put("RF data", HexUtils.prettyHexString(HexUtils.byteArrayToHexString(rfData)));
We could call: java checkNotNull("command", command);  :-)
I guess null is an invalid value for command, if so throw a NullPointerException.
aren't mDispatcher should be syncronized? #Resolved
Can we have a thread name here?
Can we add to the log.info data relevant to the event being processed? I think ReplicationEvent does not have the String annotation or overwrite so it would just print the reference.
I did not understand searchAndGetNextCluster  . Why are we giving the index again ? Wouldn't it be simpler to replace this method with something like:  private CandidateClusterContext getNextCluster(ClusterDiscoveryService discoveryService) { AtomicReference<CandidateClusterContext> currentCandidate = new AtomicReference<>(); discoveryService.tryNextCluster((current, next) -> { currentCandidate.set(next); return true; }); return currentCandidate.get(); }
must be package local
There are keystore types which don't require a password or gets it from another channel (e.g. WINDOWS-MY type).
suggestion this.authentication = new AuthenticationContext(username, password.toCharArray(), null);
suggestion connectionFactoryList.forEach((ldap, connectionFactory) -> connectionFactory.close(); );
Can we configure the application to use a connection pool when creating the connection factory? We recommend connection pooling as a best practice in our docs. The [spring-data docs](<LINK_1> call out [r2dbc-pool](<LINK_0> as a popular option
brokerRunning.getConnectionFactory() instead? I also think if that would be useful to expose CachingConnectionFactory from the BrokerRunning directly to avoid such a bean altogether.
I believe this should be zero
This shouldn't be changed, instead you need to change getAllCount() to return VisitService.getAllVisits().size()
Ah this was meant to use the guava Lists
Should we be 310-ing it up in here?
My bad, I meant to say: "to be able to **change** the page source". I will improve this exception message.
this
use ShellIsAvailable
use ShellIsAvailable
use ShellIsAvailable(this)
DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now
nit: plural naming on list?
The same DEBUG concern is here, too, for otherwise
Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?
Risk of duplicate transactionId. Resolution of currentTimeMillis is very low.
feels like this should be all done within createTelephonePaymentService
getIgnorePrefix, the deprecated one, should just return ignorePrefix() by delegating to the new one.
can you add to Builder as well
The code can be simplified to rely on autoboxing.
This method doesn't need to return anything. When completed, the connection should be considered 'closed'.
seems false is also a valid response.
no qualifier?
We need to check offset + length <= arr.length?
do we care to check for the length to be positive here?
Not very readable. Also, did you consider DictionaryBlock constructor that takes idsOffset instead of copying the array?
It seems strange to test for null in this test, since it is testing the happy path. Can you create a FilterStub?
You should call this right before the line you expect to throw the exception, and have no code after that line.
clean up empty quotes and new line.
Please copy args here too
nit: just read the value from the Map once
Minor: move init to the beginning after the constructor
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
hashCode and equals are inconsistent.
just return directly, no need for packageName variable
Missing space after 1.
return null to make this more explicit ?
can be delegated as: putByteProperty(key(key), value)
can be delegated as: putCharProperty(key(key), value)
can be delegated as: putBytesProperty(key(key), value)
suggestion public @Nullable ImageIcon getImageIcon() {
suggestion public @Nullable ImageIcon getImageIcon(int size) {
Let's also add the storage domain id as an arg or init it in the ctor. We also need to init base/top image id and img grp id; otherwise, if using this ctos and calling id getters, NPE id guaranteed at some point
On iOS I chose to not ignore this error since it makes the data structure useless and should require some action from the API consumer.
don't return null, return an error page
shall we add some message here?
Did you consider returning a File rather than a String here? It looks like you are only using the result in the context of a file, so it might be cleaner to make the File at this point.
should this be named getRelativeDestinationFolder then? But the way it's used in ImportHandler.java is not relative so it looks like it's the field that needs to be renamed.
Ditto, I think destination can never be null.
Visibility missing. Synchronized comes before static Why return an Iterable here? It would be better just to return a List<TerminatlInfoView>
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
Should call super() here.
space
backspace (bracket should be one tab back)
Please use Yoda DateTime.now().getMillis() for a timestamp
initialize() or schedule()
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
Use "JsonSerialization.readValue"
Why introduce a variable here?
One thing to note here is that since shutdownProducer() requires obtaining the lock, this operation can get stuck waiting on this lock. Operations such as flush can take a while (up to 15 minutes for BMM with the current flush timeout). Once concern might be that unassignTask() is called from the onAssignmentChange() threads, right? And have a limited time of 30-60 seconds within which it needs to complete?
@slubwama provide an error message description of what has failed in addition to the stack trace
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
This is a little peculiar - does the index represent the position in super interceptors or executor interceptors? Maybe we should only support 0 as the index here?
I suggest to add an initialization in the declaration, instead of this if and the if in line 148: private List<HttpRequestInterceptor> requestInterceptorLis = new ArrayList<>();
Please add this.
But existing rows use null not "" for the parentUuid.
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
Use the ClientLogger logAndThrow API whenever you are throwing an exception.
static imports
static imports
This should say "OffsetTime".
This should say "LocalTime".
This caused problems in the tests for me. A better approach here (and ultimately more user friendly) would be variable length second fractions. An example of this is here: <LINK_0>, along with adjustments to the tests to make sure they are consistently truncated (H2 supports milliseconds but the tests were comparing it to microseconds on my machine).
Why not just pass null into method? Or is this for clarity?
why not call the new method with null as third parameter?
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
what's the intent of this change?
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
please fix whitespace
Huh? :-)
Would you mind improving this test to use executeFile() instead of executeString()?
at a quick glance this looks contradictory to me: how can we know that Marker is a type annotation and not know the annotation type?
although its nice to use java8 optionals. sometimes its easier to read old fashioned if null checks.
Okay, but now the label provider is null. What then? We will get NPEs in the places where the getLabelProvider() is called.
I don't think these will be the same objects only representing the same date but as one is created from a string it would not include microseconds. This is why i compared the string representations.
![MAJOR](<LINK_0> Make "isSAM" a "static" method. [![rule](<LINK_1>](<LINK_2>
return symbol != null ? symbol.qualifiedName() : "";
This can only happen if semantic is not present (symbol method is not annotated as returning null). As such you should test if semantic is present and not raise an issue if it is not the case.
I'm not sure the name SOFT_LIMIT is proper here. How about just omitting SOFT?
Use CopyOnWriteArrayList for the injectorNames and remove synchronized() statements.
We are moving the exception catching out of the try{} down there and into this area. Is that intentional?
Why are you calling toArray instead of calling the constructor directly?
How many times are we going to visit each field? I have the impression that this recursion will visit attributes multiple times for no reason but maybe I am wrong.
You can use StringUtils from the commons.lang3?
I think you want to do this in the reverse order
empty finally block
You could also IOUtils.closeAll these.
Since the runner is in the same package as the factory I don't see why it should be a String ?
If the path is null it should be set to "/apps/" + name.
StreamApplication app = new WikipediaApplication();
Remember to revert this file, it should know about the transport class.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
setErrorMessage
why do we have sleep instruction there ?
call it processHeartbeat, as it does more than a check
userPointModel != null && StringUtils.isBlank(userPointModel.getChannel())
lock user_point
initialEvalId is confusing to me. How about to change it to evalId?
Unsure this addition is useful.
Actually, it looks like we can just use MoreObjects.toStringHelper(this) now (without the 'getClass'), and Guava will get the class name automatically.
Also let's convert it to string here.
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
Why this change?
Eep, does null actually happen? We should figure out where that's coming from and replace it with "".
filter could still be null when this line is reached - we should check it isn't null
StringPool.EMPTY instead
I think there is some findbugs issue with not using {} not sure.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
throws TaskException is part of the interface, did you mean to remove it?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
nit: this should be "f"
I think you missed updating the parenthesis on this one
We need to check offset + length <= arr.length?
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
Can you also check the error message to make sure it matches the expected one? Otherwise this could be failing for another reason
check the message code
we could avoid some concatenate as it's always starting with "MachineLogMessageImpl{machine=''" or maybe MachineLogMessageImpl should use class.getName so refactoring will rename automatically the toString
Missing a ,  here.
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
isInfoDebug
This will be the name of the first datastream but can be misleading for debugging if that datastream is deleted but is shared with Datastreams. What do you think about a topicName based on source?
I think this solves the problem, but why aren't we removing the processor field from this object? If it's dangerous to reuse it, and the one stored here isn't necessarily the one used elsewhere, then surely we shouldn't store it for later access?
I feel like this switch statement should be part of the RetentionPolicyMgr
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
I do not think you can have a null nested policy.
rename
rename 'listeners'
not all listener
Here we need to check the OMResponse flag also. As for existing acl, we should set OMResponse response to false. And in that case, we don't need anything to be added to DB.
We can directly use updatedVolumeList instead of copying it to a local variable.
Same. Can we pass the userKey from start to apply?
But we have already clicked the button in the command before, haven't it?
What we are waiting here on?
Are we really need to wait 2 seconds if we are waiting on web element anyway later?
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
why not pass this in #init?
Don't change this sample. It's meant to be an indicator of the simple case. We don't want users copy/pasting this into their apps.
I'd rather use Money here.
We have a generic FSM implementation in Shuffle. We should extract it out as a cay common component to avoid duplicate FSM code.
Let's adjust the formatting :)
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
This test checks "get" by using "get" so I would say that it's redundant to check it this way, perhaps it's possible to test it using another method to get an expected entity (say getAll and pick one from there).
no need to chain anymore: queryNetworkAttachments(); queryTLVInformations();
Now we have this constructor , what is the benefit of having default constructor and setPath() method explicitly .
Set.of(...)
this if/else is equivalent to this.path = Optional.ofNullable(path);
Redundant parentheses.
nit: missing curly braces around one-line blocks
This is on the request path and should be optimized to a single map lookup.
Add the original ClassNotFoundException as cause.
this isn't needed anymore after the logging changes made to the app, can just use the normal logger from LoggerFactory.getLogger(ScriptTransform.class)
Can be static
why this double usage of URL? Wouldnt be using URI instead of URL be fully sufficient? (URL is known to have severe flaws and should be avoided if possible)
Do you need to close the input or output stream? WRT: Invoking the close() methods on the InputStream or OutputStream of an URLConnection after a request may free network resources associated with this instance, unless particular protocol specifications specify different behaviours for it.
I'd feel more comfortable if we had a guaranteed timeout on this method, in case something is hanging. Do you think that's plausible?
can you make all of these as just Query and not org.hibernate.Query?
Please use the positional parameters.
I'd imagine HQL should figure out that it needs to compare the database ids so d.patient = :patient would work
a little better to have the Set as final and create it in the constructor, and clear it here.
Minor: there is also a method, Predicates.asSet(In), that exposes the inner set. I think the purpose of that was to mimic the use of Ranges.asSet(Range), which has to be a static method because we allow ranges of objects that aren't Comparable but back the asSet method with a Guava range that requires a Comparable type. I'm fine with changing to use this method everywhere, since this is more straight-forward. But I'd like to either use Predicates.asSet(In) or In#getSet(), not both.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
This method should return RemoteCache<K, V>.
The RemoteCache interface has a getRemoteCacheManager(). However, this method currently returns a RemoteCacheManager (ugh...). I've opened <LINK_0> to rectify this. Once this is in place, we'll need the getCache() methods to return a ManagedRemoteCache decorator whose getRemoteCacheContainer() method returns this instance.
This method should return RemoteCache<K, V>
remove the this.
This should really be:  return (T) new Ehcache<K, V>(storeProvider.createStore(new StoreConfigurationImpl<K, V>(keyType, valueType, capacityConstraint, evictionVeto, evictionPrioritizer)), cacheLoader);  to remove compilation warnings.
convert to private constructor and a static create method
This is another behavioral change that I don't want to see in an unrelated PR.
This results conversion will be applyed also to subclass of StringParameterValue. It would be better applied to exact StringParameterValue.
Is this redundant? Can't you just do: JSONString urlString = mappingJson.get(docTag).isString(); I don't see url being used anywhere.
I think you could use MorePredicates.transformingPredicate(TermporalField.toValueFunction(), IS_PRIMARY_IMAGE) here.
Collections.emptyList()
defensive copy?
This should be created once for mini... it shouldn't really ever fail, since it's always providing its own configuration file... that it created.
can we extract this to a method called getToken?
Use this instead of the two if blocks: Throwables.propagateIfPossible(e.getException(), NamingException.class);
Unsure this addition is useful.
Omit nulls or not?
Is there a reason that allocationPools, dnsNameServers, and hostRoutes are missing here?
Remove all "null" cases. There is a default case for that.
You can change the 28 case to a default case, and remove this.
Gson doesn't run on these versions so I don't see any reason to include them.
if it's mildly unexpected but fine to continue without, should be Timber.w I think. Unimportant in the grand scheme, but just want to either have a good debate on or harmonize on log levels. I consider 'e' to be things where you need to bomb out of an activity entirely, almost completely unrecoverable but not quite a crash.
Should we break the for-loop early if the condition is not met?
suggestion return this.connectionPool.getNumWaiters();
replace with ReferenceCountUtil.release(msg)
ctx.close()
I think it should use Context#executeFromIO and also test handler is not null.
is the server name mandatory still ?
you can use try-with-resources to automatically close the client when finishes. java try (RemoteCacheManager cacheManager = new RemoteCacheManager(builder.build())) { ... }
the build() call is not necessary here
replacing this with helper method would be great
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
It is not enough to judge empty. You should also judge the value > 2.7.0
why is this public?
style nit: we don't use curly braces around single line blocks
space between if and (
Try to avoid using string concatenation, use printf-like instead, like we do in the rest of the code: javaBuffer.addLine( "%s %s = get();", mainTypeReference.getText(), parameterName );
Here we should explicitly import the classes that we are using, otherwise if we move the code around in the future it may become incorrect: javaBuffer.addImport(Response.class); javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
I think it is better to add this to the generic 'Request' interface. To make it easier to use I think also that we should have several 'header' and 'query' methods in that interface, at least two: one to set just one header/query, and another one to set a map (I'd consider this optional), that way the user can do the following: vmService.start() .header("My", "header") .query("my", "parameter") .send(); We should also probably have a new 'BaseRequest', or similar, implementing that interface and providing the implementations of those methods.
This method is only used in the scope of this class, so you don't need a public setter for it. You can use the private field directly.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
Actually the underlying objectExpr could have free variables.
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
I really don't think we need to design this API thread safe. I know legacy Smack code does it here and there, but we shouldn't do it in this case.
I just noticed that this should be updatedSessionData.getAllAttributes(), not sessionData. It's not a big deal, just a minor performance tweak, so I think we can address this in a follow-on PR.
Since we put a log in the app deployment time stating authorizer is null, there is no need for this log.
Please remove diagnostic modifications before merging.
maybe move the hasPermission logic of UserInfo to here (as separate method) and also apply it here)
Should be externalized.
Externalize
Externalize
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
I think this can be set by spring application.properties without creating bean explicitly.
use log's parameter here
Fix logging level here (error)
Is it required for the upgrade?
hmm, why don't you verify the type ?
Very helpful
can just be return pattern.matcher(value).matches();
Why not using getStoragePoolId() instead fetching it from the disk
On both uses of isLeafVolType, there's a use of "!", so it can be inverted. Consider changing it to isNotLeafVolType and remove the ! from all occurences.
can be replaced with: return dbImage.getId().equals(vdsmImage.getId()) ? VolType.LEAF == vdsmImage.getVolType() : true; But it is not a must, just a matter of style.
this is 3.3 feature, not 3.2
Don't we need to 'override' the template watchdog (for the created vm) if the user provided the watchdog info?
Please don't include in the patch things that are not related to the subject of the patch.
suggestion template = getKubernetesCloud().getTemplateByName(getPodTemplateName());
Is it possilbe that the templateContainer is null?
I think an additional MongoDbFactory ctor would be useful too.
Can this be private, or is there another use case for default attribute outside the builder's call?
Not sure I get this - why the restriction from writing compressed output to a stream, and generating the appropriate accompanying index ?
Please keep this.cell near the related fields (previousFamily & cell count) below
I question if the synchronization here is correct. I'd like to walk through it with you to understand it better
Any reason to use an unmodifiable list as the list is already a newly created one?
We can throw the exception to client.
Why not assigning this value in the field declaration?
I suppose we could even have a pass-through singleton instance of LuceneAnalyzerReference: LuceneAnalyzerReference.PASS_THROUGH?
If you remove the condition, the retry analyzer instance will never be null. Better: DisabledRetryAnalyzer should be the default value if clazz == null unless you think the null value is important.
It's beeter to used int type.
Really minor: if it is possible for 0 to be passed through and throw the IllegalArgumentException, the error message should say "must be greater than 0" rather than "must be positive".
suggestion if (null == readTimeout) {
Wondering what's the benefit of catching java.lang.Exceptions for EventListener.handleEvent() when handleEvent doesn't declare a throw in its signature:  public interface EventListener { public void handleEvent(Event event); }  Should we make it more specific to catch java.lang.RuntimeException? Since there is no throw in the signature, we don't lose on any functionality, and it makes the intention clearer in the code itself.
I fail to see any reason why an ImmutableList would be needed here. You know it's just an ArrayList internally right?
instead of != null here, you could do a instanceof ISegmentGenerationListener. There shouldn't be any ClassCastException, but this way, you would avoid any such error
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
This can be dangerous because if someone supplies microsecond resolution it will be 0 ms, thus will trigger an exception. You should rather use getDuration().
Should defaultValue be nullable? Null isn't allowed as the value of a result so it would seem consistent to forbid it here too.
Would be a good spot for warn log entry, since the old value of this.address would remain unchanged on exception.
Shouldn't we specify the encoding here?
Silly nit: space around expression.
it needs to be protected against concurrent modification
concurrency issue too
you can use tasksByPriority.entrySet() here
why not replace these two lines with return (getState(key) == State.SET)
Could you please define this constant in tracer class?
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
You need to verify the recorded request. MockWebServer will return each enqueued request upon _any_ request. You need to verify that the generated request is the expected one: expected request uri, method, headers and body. The same must be applied in all methods in this class.
FYI: You don't need to over specify generics in Java 8 anymore, so:  List<Integer> list = new ArrayList<Integer>();  can simply be:  List<Integer> list = new ArrayList<>();
Can you assert the container has the right name?
throw e will never be executed.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
revert as this code isn't used in this PR
@Override is missing - propose to mark class OneTableJdbcKeyValueStorage as deprecated - it is not used any more
Need to implement
Should only be for the provided keys?
We need configuration property persistence-manager-remove-count: 1000
Could we log it?
There is conditional remove, no need to fetch everything before removing.<LINK_0>
not a big deal, but you can use getClass().getSimpleName() instead of hard-coding the class's name. That way sub-classes that don't add fields can reuse it.
Should be "BarChartEvent" But in fact you can use getClass().getSimpleName(), that way classes that extend it don't have to reimplement it.
To avoid repetition, you could - Make the super method protected - have it use getStartTime() / getEndTime() instead of fSht.getTreeStart() / fSht.getTreeEnd() That way the reimplementation of getEndTime() in this class is re-used.
Everywhere we call entity.getClass - we need to use the EntityDictionary.getTYpe instead.
You shouldn't need to pass transactionCancel as an argument to the supplier. When the supplier is created, it can have a reference to transactionSupplier through closure. Remove this extra argument.
Don't create an entityManager here. Let the transaction create the entity manager.
Why are you changing to patient 7 here too?
Using == for object comparison? :)
I guess we could just assert without the temporary variable.
Log debug - not info.
Detail: FROM capitalized.
also here can be invoked the primary private constructor
Resources is itself part of Guava, and is marked @Beta. Why not use GuavaCompatibility.class.getClassLoader()?
let's not bubble that up - return 404
unused
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
I think a special case should be made for an anonymous principal, to disallow the API in such a case.
@benbosman : I'd still encourage us to start with minimal/basic unit tests rather than waiting for "perfection". As you'll see above, I already have concerns that the UUID parsing is very fragile. So, having unit tests to prove it is working at a basic level would be helpful here, especially since the client using the REST API can literally send *anything* in a text/uri-list...so we need to ensure the parsing works as we expect.
this method is @NonNull, throw UnsupportedOperationException until we implement this ?
What if we have only private static boolean isIncluded(String[] groups, Collection<String> includedGroups, Collection<String> excludedGroups) instead of 2 methods?
Maybe remove the package name as it is already in the import statements.
suggestion String numberOfGroupsInput = numGroups.getText().toString().trim();
I think on reason to wrap into isDebugEnabled() since we don't do any logic with argument to log.
RuntimeException would be better. Typically SI components check the exception and wrap it to MessagingException with "guilty" Message. If it is MessagingException already we lose the "guilty" Message context.
The body of this method looks very much like com.facebook.presto.plugin.jdbc.JdbcRecordCursor#advanceNextPosition. Perhaps there is a possibility to retain reuse? Same applies to other methods too. Even if you need to copy something (i hope you don't), clearly separate copying and enhancements into two separate commits, otherwise I don't know what to review.
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
sorry for saying this only now but endDefaultOps is a pretty bad name (yes, I know it was there before). Should be something like 'updateSnapshotOvf' or 'persistSnapshotConfig' or something (can be a separate patch as far as I'm concerned)
super.getVm() will do dao call...
I think that "close" should be in finally block, just in case.
- [x] Test cases should be implemented independently. You should not change state of bean testSetFallbackTo. There are 2 ways. * Create bean instance in each test case. java @Test public void testSetFallbackToNull2() { SimpleI18nCodeList codeList = new SimpleI18nCodeList(); try { codeList.setFallbackTo(null); } catch (IllegalArgumentException e) { assertThat(e.getMessage(), is("fallbackTo must not be null")); } }  * Define lazy-init bean and get using ApplicationObjectSupport. xml <bean id="CL_testSetFallbackToNull" class="org.terasoluna.gfw.common.codelist.i18n.SimpleI18nCodeList" lazy-init="true"> .... <property name="fallbackTo"> <null /> </property> </bean>  java public class SimpleI18nCodeListTest extends ApplicationObjectSupport { .... @Test public void testSetFallbackToNull() { try { super.getApplicationContext().getBean("CL_testSetFallbackToNull"); fail("BeanCreationException not occered."); } catch (BeanCreationException e) { Throwable cause = e.getCause(); assertThat(cause, instanceOf(PropertyBatchUpdateException.class)); PropertyAccessException[] propertyAccessExceptions = ((PropertyBatchUpdateException) cause).getPropertyAccessExceptions(); assertThat(propertyAccessExceptions, notNullValue()); assertThat(propertyAccessExceptions.length, is(1)); Throwable rootCause = propertyAccessExceptions[0].getCause(); assertThat(rootCause, instanceOf(IllegalArgumentException.class)); assertThat(rootCause.getMessage(), is("fallbackTo must not be null")); } }  And if you need to assert exception other than type, you may consider introducing ExpectedException rule.
give a meaningful name for value 0
Please, use text "Project owner login" (Name was fixed after sending this pool request) thank you.
Please, use text "Project directory permission" (Name was fixed after sending this pool request) thank you.
Use "Mail" instead of "Mails". There is only one trusted mail.
This can be made static
Missing final
When I said 30 I didn't mean hard-code it to 30, I meant page size.
Should we keep "basic" here?
This seems that these objects will be created for each request? Would it be better to create it and then reuse the instance?
From my past experience, new InstanceProfileCredentialsProvider(true) will launch a non-daemon background thread to refresh the credential. It caused my java process never quits cleanly. Just heads up, if you test it, the process can exit cleanly, just go ahead. Otherwise, using the default constructor is good.
clickGallery is not the name of the method
1. make the line shorter, 2. as methods name changed, change parameter from Verify to verify
1. make the line shorter, 2. as methods name changed, change parameter from Verify to verify
"ws" and "wss" must be defined as constants.
nit: public abstract void
It's redundant if makeRequest is used to send request.
UnknownHostException can be removed
UnknownHostException not necessary here
new QueryResult<>() is redundant here
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
@xpdavid is this the right thing to do?
useSSL and sslPropertiesLocation must be propagated from here.
I don't know, but isn't the class also of interest?
Why can't you just return value here?
This is another behavioral change that I don't want to see in an unrelated PR.
It's better to use static import here to improve readability of code.
What about checking running the test from command pallet?
In my opinion, just renaming of variable to something like "testProject" will be enough.
please fix
I think it's best to accurately describe the current behavior, so your solution is good. I don't think it would be simple to fix it up to work more consistently without breaking things.
Can you remove private setters? It's not necessary we have private setters, so we reduce the size of the class
shouldn't print the stack trace from the test
static
just do StreamWriter writer = client.createWriter(streamName)
should be setSucceeded(true)
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
* shuoldn't we call super? * worth adding some log..
Why don't we make inDegrees to ConcurrentHashMap also?
suggestion this.dataStoreMap = new IdentityHashMap<>();
ComStar
Can you replace IDs with names in this log message?
nit: Throwing an exception isn't a criminal offence - we don't need to read the cache its Miranda rights I think this is a bug if we get here?
If you make the EMPTY_EXPIRES, you could use it here.
check formatting
expectedChromsomeList can be declared using Collections.singletonList("11"), inside the assertEquals (or outside if you prefer for readibility). This is an small method and is not really necessary here, but in bigger test methods reducing the number of lines improves the readibility.
What about dumping the missing indices into a file ? The purpose should be creating an upgrade script - that would ease the process for the developer.
Why protected and not private?
nit: Formatting
after changes discussed in individual builders it should be possible to bring all of them under CI and inject here whole RemoveNetworkParametersBuilder and remove other injections here.
You shouldn't depend on the expected value passed by the developer - you should go by MaskValidator.getInstance().isMaskFormatValid(mask).
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
Again, I don't think such an aggregating method is required. You need one to validate whether it's a valid prefix format and one to validate whether it's a valid netmask format. At least in the frontend you'll need this separation.
add Reporter.log(String.format("<br>INFO&nbsp;&nbsp; - Accepted alert <b>%s</b>", alert.getMessage());
Consider adding this in another commit, it's easier to note the (important) change/fix.
suggestion 749, // CWE-749: Exposed Dangerous Method or Function  Or maybe: CWE-676: Use of Potentially Dangerous Function ?
No need for the instanciation, right?  webView.getSettings().setJavaScriptEnabled(true);
Remove this if it's not needed.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
The log is not good, do not have info about the region.
I'd say "block end cannot be before block start"
This could be simplified via StringUtils.stringToInt().
The second condition should be clusterId <= MAX_CLUSTER_ID
return queryId
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
IseException is a REST exception. We should throw something like a ConfigurationException here instead.
to connect to secure nimbus
Why is containerHeartBeatMissSet.contains() call necessary?
replace the early-return with an if .. else
Great catch! Instead of maintaining another Set could you just check processToContainer.values().containsKey(container.getId())? That guarantees that we're always in sync with what startExecutor has started, since it updates processToContainer.
Another %n?
Could we consolidate these catch clauses? Or is HornetQException a RuntimeException?
@bhaisaab I would recommend extracting this value to a variable; the waiting time seems too big, is it really necessary to wait one hour? Thanks.
Maybe check for if name ends with ':' so we don't do a double one?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
want to change this logging also while you are here
This is redundant. You later have a where clause with COLUMN_SORT_ID + " = ?" where ? is oldSort.getId() + "".
If you want to do this in a really neat way, you could extract the booleans for deviceIdentificationValues and deviceConfigurationValues to separate methods. Then you can do: if (this.checkDeviceIdentificationValues(channelElementValues) && this.checkDeviceConfigurationValues(channelElementValues)) {return channelElementValues;}
one is missing here
Could be inlined here by using test()
static import for milliseconds please :)
Rename -> CosmosDbFactory to CosmosFactory
By capturing the Schedulers.elastic() in an instance variable, you are using the same Scheduler with every async API. Just a heads up on not sure how this will behave. Also, Schedulers.boundedElastic() is the preferred way now for wrapping I/O calls. Please see that too.
should return ClientSecurityConfig for chaining.
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
Immutable fileinfo
Logging should be added here, just to ensure that we see if something is wrong...
return a copy please
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement. Alternatively, a more succinct way of writing this method would be:  return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData;
Why does the handler require a zkUtils reference itself? Same for the other one.
Seems listenToProcessorLiveness() only happens when the process knows it's the leader in the synchronous way (return by leaderElector.tryBecomeLeader()). For the other case, where the processor becomes a leader later after the original leader dies, where does it invoke listenToProessorLiveness()?
This guards against no processors change(for some reason processor didn't remove itself) on barrier timeout. On contrary, we could have redundant rebalancing phases (one at barrier timeout, one when processor gets deleted. We can't handle this cleanly until there's pause functionality in SamzaContainer). Let's create a JIRA for this.
Should this do something along the lines of if (optional.isPresent()) throw new IllegalStateException(); in case it accidentally gets used with > 1 value ?
I think this method could be private.
Boolean _final
Do we not want this test to run with segmented true and false?
Aren't there any test methods that require compatibility?
Not a problem of the current patch, but from the old code: the variable name is misleading. We have here either "builder" field or "builders with config", so "currentBuilder" doesn't match and so I would name it "configBuilder".
i wonder if using Pattern.compile() as a static member to hold the compiled expression is more efficient.
can you make those no-arg constructor private?
It would be great to cover the util method with tests.
I see you didn't change the assertions
The expectedErrorMessage seems like a good fit for a constant.
For branch coverage, we probably also want a test for the case where a non-admin calls this API.
I do not like createExtension modify the entry... I think it should be: entry.setExtension(createExtension(entry)) there is no reason to load the module here and not within function... also, I am unsure the function of createExtension is worth a separate function but not that important. the activateEntries.put()... should be after initialization is success as last action, this will enable you to skip extensions that fail initialization. you should catch exceptions within the loop, to allow proper initialization without faulty extensions.
entry.isActivated() &&
there is no change, why have you pushed?
there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.
I would inline error. Up to you.
could be static
Just an observation... might it be more cool to return Collections.emptySet()?... if we have the option to reduce null usage we should do so... imho helps in the long run... but - I may be wrong...
why do you change this?
I think this method has no need to be static
I think you need a null check here similar to the getViewIndexId. If the view index was created by an old client it won't have the VIEW_INDEX_ID_DATA_TYPE and you can assume its a short.
Can you please add a default value for LONG_VIEW_INDEX_ENABLED_ATTRIB to QueryServicesOptions and set it to false and look it up similar to :  boolean asyncIndexBuildEnabled = connection.getQueryServices().getProps().getBoolean( QueryServices.INDEX_ASYNC_BUILD_ENABLED, QueryServicesOptions.DEFAULT_INDEX_ASYNC_BUILD_ENABLED);
this and step should be private
No, I mean take the Log.e() near the return null;.
As you removed the openStream() method (replaced it with the openImageInputStream()), does that mean the BulkData now only works for pixeldata, and no longer for other BulkData like overlay data etc.?
Why this comma is on the next line??
Code will be clear if we use static import of **Asser.assertTrue** here.
just to keep them all the same suggestion final FreeStyleProject p1 = d.createProject(FreeStyleProject.class, "p1"); final FreeStyleProject p2 = d.createProject(FreeStyleProject.class, "p2"); final FreeStyleProject c1 = d.createProject(FreeStyleProject.class, "c1");
We doesn't need to do it if test workspace is been injected.
We should first check to see if this is closed, and if so simply return.
Move the requireNonNull checks to a separate line. Calling them inline looks messy.
Would it better to catch InterruptedException, then catch Throwable?
would be nice to save index.getColumn(column) so we don't have to do the lookup twice if it's non-null.
Also I don't really understand why __time is different with "__time", it seems that they should be equal. I'll run a test as soon as possible.
I would just use ASC and DESC like the standard hive syntax
To avoid the magic number, let's use HttpStatus.TOO_MANY_REQUESTS_429 here.
Was this detected by findbugs?
return Objects.requireNonNull(remoteFuture).get();
suggestion driver.get("http://host.testcontainers.internal:" + port + "/foo");
id is the unique element in a HTML page. Therefore, there is not need to have a chain to locate it. Check if there are similar case in your PR.
return result.isEmpty() ? null : result;
restore empty line.
inputheader => InputHeader.
Why we declare full path when you created the method getResourcePath to make this simple? Lets change this to use the new method.
this line can be removed (variable end not used)
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. There are specially written queries in one of the DAOs to get only appropriate announcement activity because it was a pain. Anonymous users should be able to see activity for public announcements and logged-in users should be able to see all announcement activity.
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
As IOUtils has been imported why not just use IOUtils.closeQuietly()?
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
why retry?
please rebase, arik removed the lock in a different patch.
I'm not sure we want to execute every REJECTED/NOT_STARTED command on engine startup, what if it took 2 hours to restart the engine? think of the following case: host went down and we run a VM that ran on it using this infra, the command didn't start and there's an engine is stopped and started after an hour - on startup we'll try to run the VM, even if no SPM was selected, so the user will see that we try to run the VM without asking and that the operation fails I think it is better no to try again to execute the commands in that case. we should do it only for special cases such as HA VMs
I'm missing an indication that the command failed because of a timeout. 1. for logging/auditing 2. to be able to react differently if the command failed because of a timeout (maybe in this case I'll want to retrigger it again in the future as opposed to command that failed because of permissions)
"valid times" should probably be "setup time" or just "setup"
set if not null or empty
I would remove these Log statements now that the code is ready to be merged.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
should call super: <LINK_0>
Won't this also cause a refresh when canceling the 'new issue' activity with the back button?
It makes sense to introduce ICPPNodeFactory.newLiteralExpression(int, String, , char[] numericCompilerSuffixes) method, use it in GNUCPPSourceParser, and get rid of the setNumericCompilerSuffixes method.
fSuffix is guaranteed to be null at this point, but it's preferable to pass CharArrayUtils.EMPTY as the third parameter to minimize amount of work done inside the getSuffix method.
Redundant qualifier.
Integer.valueOf
i18n
This method is a good idea! I know I'm nitpicking, but may I suggest to skip the contains() call and just do a get() and if null, then return defaultValue? This will skip at least one MultiMap call.
you could throw a RuntimeException to have a better simulation.
This is not time zone?
We require complete input validation here. I miss the validation of the network and an error message if validation fails. Please use NetworkValidator.networkIsSet(), you could create a Validator like UpdateNetworkValidator
why needs this method to be static?
Minor: move init to the beginning after the constructor
I would prefer IllegalStateExceptions in such cases.
I think it's better to use RqHeaders.Smart#single() here (and all methods below)
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
Indeed, that is better than my suggestion. Let's do this.
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
Just curious, why do we need to change the access qualifier to protected?
Avoid doing unrelated cleanup within a different patch. This change should be on its own. In fact, review 84541 does exactly this. If your patch is not committed or reverted, this change would be lost.
prefer == instead of !=: instance.rootWorkflowId == null ? instance.id : instance.rootWorkflowId
This is a bad pattern to follow, for a few reasons: 1. We have multi-catch blocks now, so there's no reason to do blanket catch like this, 2. This will unnecessarily wrap RuntimeExceptions with another RuntimeException, and 3. You should never call new RuntimeException(...); instead, pick a specific runtime exception appropriate to the circumstance.
The null will clear the current start time from the db.
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
here the decryptFields will be null, you should get it from the config. Also, this transform actually emit all the fields from the input schema. If the field is in decryptFields, it decrypt it; otherwise it is identity transform. Should generate operations with these two descriptions.
For this value, we should do something closer to what ProductDTO does. Leave the building of the URL to the actual entity so we don't have two implementations of it floating around. We should also update Pool to be nicer about generating it so we either generate a valid URL or nothing at all (see Product for an example)
You should not change this, it is not backward compatible.
Were the two other if statement just never executed because this is the MigrateVMCmd, which should only be migrating a VM from one host to another (i.e. no storage migration)?
getter
setConfig too?
This should Log the exception to the logger
"line"
Is the  added here intentional?
Consider using i18n instead of hardcoding the string External Components.
please check here isSetPmProxies() otherwise you can get NPE
Perhaps make it private so no one will be able to initialize it outside the class? It makes sense cause regular initialization will not do much without injecting the members
java ProxyAuthenticationType authentication = ProxyAuthenticationType.NONE; if (this.proxyConfiguration != null) { authentication = this.proxyConfiguration.authentication(); }
Great idea! Can we use Locale.ROOT instead, though?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
Ah, this on-obvious to me: why do you switch the zone to UTF?
Good catch :-D
Is this supposed to be <code>return "Bump"</code>?
The map context will call setBoundingBox with null then the method onMapContextBoundingBoxChange will be called. Why this command is necessary ?
Unnecessary parentheses (and an extra line break).
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
FWIW we tend to use Identifiers.makeRandomId(/* length */ 8) instead of UUID -- no big reason but it makes for more easily distinguishable identifiers, shorter and more chars
Please consider adding a Preconditions.checkArgument to check that base64EncodedKeyContent is not blank.
Could the cipher suite be made configurable?
I'm not sure i follow how this works. (maybe it's just me being rusty :( )
Put these two assignments in order so it's clearer
Maybe it is a matter of taste but I think that calling super() explicitly in this case doesn't bring anything to readability of code
I believe we could set initial nextValueIndex right on attribute declaration, to avoid repeating it in all constructors. What do you think?
This is a copy&paste failure: the class should be TextViewerTest.class
the same, add indent please
@apearc03 ASL header is missing causing the build to fail on Travis.
Also wondering why? and how this is related to ASM 6?
Never compare to true, this is useless.
I would rather that this method return "null" when cause is not an Exception, and then call initCause() just below.
Ok, I see .. the clone function is for returned values from the CacheUtil. So no duplication within the cache (which uses the more primitive constructors)
Perhaps nameToDataType.
Check null. The caller might pass an unknown type.
what about location ? we do not need LocationSerializer ?
this is redundant
Will this have any effect to legacy data (i.e. those existing before this PR)?
@sbespalov : Unless you intended this for debugging purposes, I think it sounds like a reasonable suggestion.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
These two lines get called repeatedly in (i.e., 87-88) several of the methods that follow. Would it be worth creating a private method that returns the objAcls?
Name in log message needs updated
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Shouldn't this be in isAvailable()? That's what will prevent the CLI offering the option. Having it here too is fine, but people shouldn't see the command if it's not valid.
does it make sense to send 2 versions of the verb to different hosts in the data center? (if one is older than 3.3 and other is 3.3) i think you should use storage pool compatibility to be consistent with all hosts in the storage pool.
Hi, I would prefer if you will have at base class a method VdsDao getVdsDao (protected method) that returns DbFacade.getInstance().getVdsDao This reason for this as it will help us mock vds broker commands one day.
1. do we need this? if the host is already in the cluster..it means that it's already supported, not? 2. why don't we check just by the storage pool version? do we want different behaviour between the pool hosts?
This looks like testDataFormat(COMPONENT); Please see other tests for sample
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
This conf should have STORM-MESSAGING-NETTY-BUFFER-SIZE 1024000 as test-batch defines, so you may want to define another method for new configuration.
But why do we handle 400 differently than all other errors?
The whole 4xx range (400 until 499) is defined for client errors.
Response is never closed
Is this method really needed? It's similar to make init public
make it fluent
Could this method, and setPurgeTimeout, be package-private? Still testable, and reduces risk of misuse.
I don't think this should be removed, since looking at the setup code the cookieBasedClient isn't the same as account.
if (realm != null) maybe - just to be safe.
why synchronized ?
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
out of curiosity: what meaningful exception could possibly be thrown here ?
The params are so nicely aligned above, how about here and below ;) ?
comma not required
add {},
This looks the same as the V1 version except for the Class of the version. I think you can just use a template here As an example <LINK_0>
from discussion below: can we use imperative statements here? I find this difficult to parse (I read the filter as a top-level thing that rejects versions that were unfriendly, when that's not the case).
Should this return null if version is not a valid OSGI version?
Is this method really needed? It's similar to make init public
same as above, skip public
this should go to super.reset(), shouldn't it?
I am a little worried about the performance of this change here. getTypes can be used quite frequently, each time we will make a copy of existing types. Also changing viewof to copy will change the behavior. Many optimizer rule just call getTypes once and assign it to a member variable, newly added variable in the optimization rule will be missing in the copied TypeProvider. Can we change the TypeProvider to store only Map<String, Type> as well? It looks like we don't need to use Symbol there as well. The only other place copied the whole TypeProvider is areExpressionsEquivalent method. I am not sure if we need to convert the variable to input there though. I think variable name is unique already in TypeProvider, so I am not sure translate it to integer will help much in canonicalize the expression.
nit: use List rather than ArrayList
This test would be useless if the map had been initialized in the class.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Ditto: should be type.getType()
Should this be implemented?
Why not this::refresh ?
If the token is unknown in this case, you're going to get an IllegalArgumentException when the subsequent removal is attempted because this statement says an unknown token -> needsEviction. I would argue that an unknown token means it has probably already been evicted. The following call to getTokenExpiration will already invoked validateToken(), so the up-front isUnknownToken check here is unnecessary (IMO) and the conclusion is incorrect.
nit: I think it'd be better to call this enableInterval
As written before - not that critical but consider set (just to ensure nobody will be making a mistake of adding twice the same UUID - i mean, if they do add , you still should have only one copy).
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
Is sorting necessary? if so, why?
Icky. Can't you pass it in the ctor instead?
Value of object, not type value.
It looks like sparkObject could now be a byte[], so should setSparkObject call deserialize here, the same as the code you added in getLength() ?
Use this.key
Use this.key in place of Keys.SPAWNER_MAXIMUM_NEARBY_ENTITIES
Use this.key
Same as above, let's not instantiate the FBO within process and let's try to use BindFBO in initialize() instead of this bind() line.
Notice how in many cases this line won't be needed once this node uses the SetViewportToSizeOf state change.
General game development rule: nothing should be instantiated in the main loop. Some argue the compiler will optimize all sorts of things, but it's hard to see how it would optimize something so deep in the main loop. So, please move the FBO declaration elsewhere. Same for the new ResourceUrn() statement.
throw exception
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
What is this for? Feels like some unintended checked in code?
Does this truly need to be done in arjunaCore or could it be guarded in XTS alone? It is fine if it is an arjunaCore issue and we should code to fix it but I need to see an arjunacore test case that shows this or reasoning it can't be sole change in XTS
suggestion return podStatus.getContainerStatuses();
Since ContainerPlacementMessage.equals includes statusCode, this step is not needed.
why not use the MessageLevel type?
Add a constant for this
Nit: unnecessary this.
Please consider to extract to a different method (like isInternalManagedDisk)
It should be Memory metadata/dump disk could not...
Use Collections.singleton instead of Arrays.asList
There's an Assert.assertNonNull that can be used
I'd suggest that keeping/removing the debug actions is entirely separate from pin/clone support, so it would be better to do that (or whatever outcome we settle on) as a separate change.
Consider calling WorkbenchUtil.showViewInActiveWindow to make it simpler.
suggestion return (original == null) ? null : original.toUpperCase(Locale.ROOT);
I wonder if it wouldn't be better if we *never* used null as key, and instead use the empty string. Then this 3 LOCs could be removed.
Ok, this is what I don't quite get. Why is this feature being removed here?
you can use return (luceneQuery.startsWith("query_"))?luceneQuery.replace( "query_", StringPool.BLANK): luceneQuery; it is just a style, up to you
replace "" by StringPool.BLANK
Unwanted final?
the resource list will change during resolution if additional resources have been loaded. In this case a concurrent modification exception is thrown. I nevertheless accept the change and fix the bug by replacing the loop with EcoreUtil.resolveAll(rs); This handles the room file as well. Should that cause any problem?
Hello @lukaszlenart. Allowing devMode to disable the exclusion processing makes me a little nervous. For one thing, _it could produce confusion_ when something works fine locally with devMode true and then fails due to default exclusions when devMode is false for a deployed version. It would also make running devMode potentially _riskier_ than it currently is with the exclusion mechanism set/active. If a developer wants to access classes blocked by the exclusion mechanism (even in devMode), they can already modify their local development struts.xml configuration to override/set "struts.excludedClasses, struts.excludedPackageNames, struts.excludedPackageNamePatterns" as necessary for that purpose. Once they are done their testing they can remove the override. Maybe there could be a compromise in introducing a concept of "devMode.excludedClasses, devMode.excludedPackageNames, devMode.excludedPackageNamePatterns" ? When in devMode those exclusion lists could be used instead of the standard struts.excludedXXX ones, with defaults that are slightly more relaxed than the standard ones but still restrictive ? That would allow some flexibility between modes, still allow for explicit restrictions in devMode (as restrictive or permissive as the developer chooses) and clearly show what is restricted. What do you think ?
Never handle exceptions like that. If you can't handle it, request user help, or rethrow it, thel log it via plugin activator.
It should return ReadOnlyDictionary not ReadOnlyDictionaryInterface. Also IIRC, ReadOnlyDictionaryInterface is internal for Java.
I think it should return Array here.
Should return ReadOnlyArray.
@rui-castro why don't you keep skipsOnStream as it was?
@Serranya The same here. See above.
@Serranya The same here. See above.
Does the first part of this statement make sense anymore or must everything be explicitly _marked_ shareable now?
Is there a method for modders to share recipe types? An enum system with our extender or some form of get(ResourceLocation) would be good.
Please test this method properly.
Isn't it also important that adType was async and method was top?
Please add ? and % as well
Also, a test with an aligned with original OA to test the default overwrite will be nice here. Also with unmapped reads with OA tag because the current code won't overwrite them (and I guess it should).
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
Shouldn't this be new Fraction( t.getBitsPerPixel(), 64 ) instead of new Fraction( 1, 64 ) here?
This should be ops().run(Ops.Image.MAE.class, out, reference, test);. That way if someone creates a more specific/specialized MAE op, it could be matched. Otherwise, DefaultMAE would always be used.
Can this be in the layout?
ugh
Would it be better to check AbstractLogger.getRecursionDepth() > 1? The class name check is fragile
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
please use the other methods shorten format: i.e. return ValidationResult.failWith(VdcBllMessages.VDS_NO_UUID) .when(StringUtils.isBlank(host.getUniqueId()) && Config.<Boolean> getValue(ConfigValues.InstallVds));
What you should be sending is the cluster compatibility version, not a constant version.. You could send the host's version but that would be confusing to the users. The norm in oVirt is to restrict version specific features by either cluster or DC - since this is clearly related to cluster (and not related to storage), the restriction should be by cluster level.
This should stay final
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
I would move this to a constant so we can access it from tests as well.
Minor: Would it be better to consolidate all of these "get" tests into a single test so all of the test is in a single place?
Method should be synchronized probably?
You may want to test this with multi-line strings.
Do you forgot to compare items and label?
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
once again, equals/hashcode - does it make sense? please revisit in all value types you created
retain the else condition which is there in the original code. This sets the hilighting of today's date in calendar
java Objects.requireNonNull(runnable, "runnable is null");
I would do: if it's not only SWT.BOTTOM then it's SWT.TOP.
Remove the call to this();
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
this. prefix is not required within getters
should the interface not the implementation suggestion public List<String> getTopics() {
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
new ArrayList<>(causes);
Since you are using this value outside this class, you should define it as a static value in this cl;ass and use it in the other package, i.e. "FixupTableDefaultHandles. These values should also be non nls
How about using NumberFormat.getInstance() here for a locale-dependent formatting?
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
@ivandalbosco Why not using noneMatch?
Extract classTree.symbol() to a dedicated variable rather than calling it thrice.
It seems we don't care about the StatementTree, only about its existence. findSecureRandomInMethod could therefore return a boolean.
It looks like that this catch block is in a dead code path. Because startLogReplicationRuntime will catch all exceptions and input an event to FSM. Remove elements in an iteration over values also dangerous. > If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined.
forEach() is available for Arrays, please remove .stream()
Singleton isn't threadsafe. We're not worried about multiple threads calling this method?
It should be "Then that player shuffles their library", the oracle text in the spoiler file is outdated. I've been dragging my feet on updating all of it.
Use {this} instead of the card name. Add no full stop at the end of effect texts.
Instead of Cruel Deceiver you should add {this}
if OUTPUT is non-null, assert that it is writeable.
Path and File.toPath[] aren't available in Java 5
As before, using metrics.values() would be better here since the entry's key isn't used.
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
This should stay final
@fabriciofx As said above, we could use new TextOf(InputStream) constructor here
As I already said - this should be an immutable set cached in a private static final field.
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
Using something like ImmutableSet.copyOf(contentTypeToTemplateEngineMap.keySet()); would make sense imho...
Wait, this is worse than the previous version. What happened to the assertEquals()?
You can make this method private
Why not make the test timezone-independent by either calculating the correct long value for "00:00:00" based on local time, or changing the timezone of TmfTimestampFormat.getDefaulTimeFormat() to GMT in the test case.
no checking flow when user sets grace period in the action
please verify response on remove()
please verify response on remove()
Cool, so it looks like this _only_ batches blockOnBecomingLeader() operations
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
JUnit has [ExpectedException](<LINK_0> which I think works better than try catch statements. There are some examples in the Geode code base if you want some inspiration
We might want to consider calling the new method from this one so we don't duplicate code isPublishDateInTheFuture(dateCreated, new Date()) wdyt?
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
Aren't you changing the original logic of this method?
No need to override this or the following method if you are not going to handle commands or updates.
Might want to log a WARN if you are going to drop the command due to no myqOnlineData.
unneeded if clause
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
similarly here, if this is general, I've lost updates...
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
This kind of verbage is full of some dangerous assumptions about the nature of the language involved. If we were in a right-to-left language this would be really confusing to put together. Two options that might help: 1) Use the localization keys to do the construction, IE: Localization.get("cancelling.title", new String[] {titleText}) where cancelling.title=Cancelling: ${0} or something similar. Alternatively, you could only use the message view for the cancel message (although I'd put the "..." in the message itself for the same reason)
Perhaps the FileChannelSink should be one per factory, not one per channel?
you call this 'updaters' some places and 'updater' elsewhere ( register method ). make it consistent
Overdid: if null, return null :smile: From other side it can't be null. See ctor:  Assert.notNull(inputChannel, "inputChannel must not be null");
use new Guid(String) - this literal can't be null
Can you use isEmpty()?
I'd add a get from the DB here, to make it was really updated there.
I am not sure if we want to return null here
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
I think there is an issue if the generation suffix has more than 1 character.
"http.url" is the current name, when query parameters are present (which I think this is..)
Either cast to (TypeMirror) and pass to MoreTypes.asDeclared() or just cast to DeclaredType. Can you add this todo for me: TODO(ronshapiro): class literals may not always be declared types, i.e. int.class, int[].class
non-null assertions.
This does not verify the order. (The iteration order over expectedMap is undefined).
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
What happens with an empty string as a value?
Make it static
Maybe we want to keep something similar to what id was before
I still recommend to put here human friendly text.
Same here, making methods protected allows users to override them.
This should probably be reduced to logger.fine.
Java supports covariant return types, so you can make this method return KernelSession without breaking the type safety of the interface. Would be easier on the eye.
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
You may want to use ConcurrentHashMap for thread safety when adding classloaders into this map.
Thinking we should put a IGNORE_RETURN_VALUES flag always for this. We don't return the previous values to the caller, so it should be much more performant.
Same here, this method return void because we don't want to have nuxeo-java-client outside this class.
Would Collections.unmodifiableList(submodels) be better in this case?
you turned around T & I here, it should be declared as:  protected <T, I extends T> @Nullable I getService(Class<T> clazz, Class<I> implementationClass)
This plays the current, not the next station.
suggestion if (this.currentTask != null && this.currentTask.isDone()) checkAndRethrow();
suggestion if (this.currentTask != null) checkAndRethrow();
This println can probably be removed.
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
Can be inlined in the assertThat statement below.
@antonini you can use Matchers.allOf() to combine these two assertions and get rid of one-time variable head
@fanifieiev the same above.
@HDouss Tv.THREE
This is not clean. If this method now returns an absolute path, you should also change the method name from "getName()" to "getAbsolutePath()". Also, you will need to change the messages. With your change, the FSOperation_ConfirmFolderReplaceMessage would now say "This folder already contains a folder named /foo/bar/target/file" . Which is not accurate. Instead, the message should now say something like "Folder '/foo/bar/target/file' already exists. Do you want to...' Or you could change the code even more, to say "Follder /foo/bar/target" already contains a folder named "file". Do you want to..." Please make sure that you test the workflow, and validate that your final message makes sense.
This looks like a leftover and it hasn't any usage. Can we remove it?
I think that may have been an oversight in longSum. Try a query that results in +Infinity at the historical level and you will see why it is needed to deserialize at the broker level
You should put default tenant here if it is single-tenant cluster, similar to addTable() You may extract this part into a helper method
equalsIgnoreCase
nit: precondition goes to the top
does this need to catch all exceptions?
specify charset?
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
These two could be simplified to assertNull.
Could be simplified to assertNull.
Unknown file name and known line number? Should that be an error?
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
Here should contains all the process type which may contains CDP DISTRIBUTION. e.g SPARK_JOBLET,SPARK_STREAMING_JOBLET,TEST_CONTAINER(only spark process related) Please ref to: public List<ERepositoryObjectType> getTypes() { if (ERepositoryObjectType.PROCESS_STORM != null) { // test if spark streaming is available (not the case with TBD license) return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM,ERepositoryObjectType.SPARK_JOBLET,ERepositoryObjectType.SPARK_STREAMING_JOBLET,ERepositoryObjectType.TEST_CONTAINER); } else { return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ,ERepositoryObjectType.SPARK_JOBLET, ERepositoryObjectType.TEST_CONTAINER); } }
Change the getter so you don't need the cast
I'm seeing MySQL use an error code like this: 533 throw SQLError.createSQLException("Unable to unwrap to " 534 + iface.toString(), SQLError.SQL_STATE_ILLEGAL_ARGUMENT, this.exceptionInterceptor);
remark: we name the variable ws everywhere. It's a pity it's named actionTester. I then have to check what it is. I think so even if the name actionTester were better
Compare this and change to what is done in src/main/java/com/salesforce/phoenix/query/StatsManagerImpl.java:132, wrt the sqlE.setNextException(). If an exception occurs now here during finally block, we'll lose the original exception.
I see some improvement can be done here.Is it required to define method as synchronised.Can we use ReentrantReadWriteLock and get write lock here? It will be resulted in performance improvement
return to; is enough.
using Arrays.asList create a fixed sized list, so doing later getTo().add(something) will throw an exception.
use getDiskVmElementDao(), please apply to all the dao calls in that class
Why? You already set the value in each of the three tests that you changed here. I think that this line should be removed.
Let's have the if in the positive branch
This is my favourite part of this PR
Collections.singletonSet(rowNumber)
We should make this backoff configurable. 1 second might be too conservative for a default. We could figure out how long, on average, a leadership election takes, and then wait for that amount of time.
all services are closeable, so use IOUtil.cleanupWithLogger() & let it handle null checks and exceptions
what if cluster is null?
Error message should have zoneId. I think this goes for every message that prints a cluster...
Shouldn't this code run even if mHasWifi is false?
Do we want to keep the method names like this or give it a more general name?
Do you also need to wait for any handler threads to process outstanding messages?
Sorry I don't quite understand the check. How do you know if the outgage mode is turned on in the AuthenticationResult class iteself? If it's not turned on, why we're checking extended expires on?
I just realized that this could generate FPs when placed on different lines: java target = +num;  We should check that both token are sharing the same line.
do you think it would add clarity to move "this::CallRequestAccessTokenEndpoint" to a variable: Function<Client, Response> endpointCaller
Since the menu item click has been handled, return true instead here.
Instead of finish(), you can just set the parent of the activity in the manifest to MITMainActivity, that way it'll navigate properly to the home activity
This can be replaced with return mDrawerToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item);
Just curious but why didn't you stick with just using the context passed in the constructor, I think this is the better approach since the resources you get may be context dependent.
It looks that this should never happen. Would you elaborate more on when this can happen?
don't we have multiple groups?
Can c be null?
Rename to courseIDs?
If this method will be only used in getAllStudentProfiles, make it private. Also, you can consider inline the method in getAllStudentProfiles as there are only two lines here.
Similar change as first(count).
Logic: Similar change to LazyFluentIterable#first()
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
pls use querydsl instead (already in master)
so much boilerplate :\ would this be easier to do with [AutoValue](<LINK_0>
Consolidate this method with its coordinateStringsFromQuery implementation method.
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
- [x] Why need this? Please re-consider based #768.
if it's MySQL you meant to return obj_key, no ? (if key is not allowed)
IOException comes from API signature, so there's nothing we can do there. You can add a release() with the LightblueException.
One more very, very minor point: We should be wrapping these exceptions properly (IE: initializing the throwable source in the new exception) rather than just adding the same string message, otherwise we lose the most relevant part of the stack trace. This is a general habit we should get into with error handling
Please log Bundle ID data here.
Did we want to have this normalize the path also by returning the normalized version from Path?
Can we use [java.nio.Path#iterator()](<LINK_0> here?
move it to be aside of deleteFolder
I think this log is no longer in use.
oldDataSerialized = (null != coordinateData) ? "" : coordinateData.serialize(); could also be final.
extra else statement, please remove
Hm, I think this should probably fall back somehow in its current form, or throw a much more explicit error if it fails. Before we had a guaranteed no-error, since the array was fetched from ID resource. Now it could get removed and our error message would be incredibly vague. Especially since this can now fail due to a change in commcare-core that is quite invisible to the end-user here.
I think you should add proper custom error message in this case.
Typo
Can this be reduced to return equals(FRIEND_TRUST.NORMAL)?
This check can be simplified to: java if (super.isIdProperty()) { return true; }
Consider @Restricted(NoExternalUse.class), I see no reason to make this public API.
This makes it possible for cacheManager to be null. References to cacheManager presume non-nullness.
This isn't the correct way to use the ExecutionService... you need to be pulling the alias from user provided config. This will work in the default case where the service ignores the aliases... but if the user tries to constrain threads in to named pools they need to be able to make sure the set of aliases used within the system matches their pool names.
Tangentially, we should likewise install the backup service as ACTIVE, so that it toggles to NEVER instead of ON_DEMAND as well.
We can push this further up by having these helper methods return the function we build in each of these methods, will help increase readability.
nit: Should we just extract the lock later since we're already returning the TableToSweep? Feels odd to separately extract the lock as well.
This can throw a runtimeException, we should catch it and set Outcome as ERROR.
other places use "error" lower case
For the sake of consistency the response should be built using [ErrorMessage](<LINK_0>, even if it's just a test class.
I'd prefer including the state of lockEntry if it's not null, and/or checking if it was open or not open and indicating that - CheckAndSetException can occur if someone else locked the lock underneath us as well, so it's not necessary that the lock's already open
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
I'd call the variable entityClass
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Sorry, just because it is deprecated doesn't mean we can remove the test for it. We must ensure it continues to work until it is removed.
typo
Blind casting
Will this ever be ok? Not quite sure why this just wouldn't throw a SessionUnavailableException as part of the method signature
getCurrentUser().orElseThrow(this::createMissingUserException);
not necessarily with LDAP. change to "authenticateUser" or something similar.
assertion for channel kind should be added.
Change collectionType to iterableType?
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
should this call SQLUtil. sanitizeCondition instead?
Please put @Test on the line above, not on the same line.
I would have expected the tracing to happen at the writePacket(buf, pos, len) level, since that captures all packets sent (not just packets sent as strings). end() is where flush-pkts happen.
This must be supported.
"return position;" maybe?
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
@vkdrn Thanks for contributing!! Would you mind to add all attributes in toString method too?
Although this is not a part of your pull request, this toString() method looks overly complicated.
The format of the names is inconsistent, also remove duration.
You can use CollectionUtils.toImmutableList
Do we not want to filter on isInstance first? (even just to protect from wierd bundle reloading errors?)
nit: you could add .map(Math::toIntExact) instead :)
Same here when trying to save the context without specifying the script (or when trying to import the context).
I think this should throw an exception instead of logging it. Otherwise, it would only be visible in a log that something was silently ignored.
can you import the ClassUtils please to simplify the line?
I would prefer an unconditional return string, so the string better represents the object value (with empty fields).
return (radius <= maxMeasurementPointRadius && radius >= minMeasurementPointRadius);
Try using StringUtils.isTruthy(this.path)? <LINK_0>
Import org.apache.hadoop.conf.Configuration please.
We can actually simplify by not exposing these properties out. The defaults seem to be good enough. Especially the initialDelay parameter which is only used for test purposes.
Can you add some error handling for the username parameter? Such as:  java if (username == null) { return Response.status(Response.Status.BAD_REQUEST) .entity("'username' query parameter is required for getUser").build(); }
By right, soft deletion should not result in InvalidParametersException
Logic is meant to be a facade class. As such, you should put a method deleteAllStudentsInCourse in StudentsLogic and have this method call that one instead.
Perhaps we should stick to the convention of returning a 404 JsonResult here? Thats what I have been doing in my other PRs.
remove line
consider simplify to an 'else/if' " if (getParameters().getProfile() != null) { profile = getParameters().getProfile(); } else if (getParameters().getProfileId() != null) { profile = getProfileDao().get(getParameters().getProfileId()); } else { // log or something... } "
![MAJOR](<LINK_0> 'Severity: MAJOR') Update this method so that its implementation is not identical to "getSecurityProfile" on line 386. [![rule](<LINK_1>](<LINK_2>
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
I get the feeling this is too simple. What if one index contains an object field, and the other has a non-object field at the same path? We should fail, but we will just execute the predicate for the object field.
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
any special characters to block in webhook name?
you should probably check Item.Configure here
You may want to assign labels to this node; it's marked to only run jobs that are exclusively tied to itself or a label.
we need good docs here
Swap the order of modifiers, like it in all other methods in this class.
CheckReturnValue?
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
This means clockHand will be hot at initialization time. Intended?
You are creating new list each time, why not just forEach(resourceResolversInTryWithResources ::add) instead of collect(Collectors.toList());
Should this be similar to other parts of the API where if connection == null get call get Connection and if not we use the instance?
What's the reason behind referring to an implementation type here and casting?
You could use ReflectionUtils#getTypeClass(Type), I had forgotten about this method.
I guess we could make it more concise as: java if (!parameter.isAnnotationPresent(Auth.class)) { return null; } else if (principalClass == parameter.getRawType()) { return new PrincipalContainerRequestValueFactory(); } else { final boolean isOptionalPrincipal = parameter.getRawType() == Optional.class && ParameterizedType.class.isAssignableFrom(parameter.getType().getClass()) && principalClass == ((ParameterizedType) parameter.getType()).getActualTypeArguments()[0]; return isOptionalPrincipal ? new OptionalPrincipalContainerRequestValueFactory() : null; }
I think we could implement this in a more concise form as well: java if (!parameter.isAnnotationPresent(Auth.class)) { return null; } else if (principalClassSet.contains(parameter.getRawType())) { return new PrincipalContainerRequestValueFactory(); } else { final boolean isOptionalPrincipal = parameter.getRawType() == Optional.class && ParameterizedType.class.isAssignableFrom(parameter.getType().getClass()) && principalClassSet.contains(((ParameterizedType) parameter.getType()).getActualTypeArguments()[0]); return isOptionalPrincipal ? new OptionalPrincipalContainerRequestValueFactory() : null; }
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
need to add more information about dimension/index/length
return HConstants.EMPTY_BYTE_ARRAY; ?
Adding this to a field is good manner.
Adding this to a field is good manner.
Adding this to a field is good manner.
instead of duplicating this would it be less error prone to have a common interpreter test java file to define this?
It is better to check whether sparkInterpreter is null just in case
return it directly ?  return new InterpreterResult(Code.SUCCESS, output.replaceAll("\\.\\.\\.", ""));
What if type is not Class type?
Collections.emptyMap() would be better for performances (not actually created a new object).
Please make the constructor private (see Invalid).
why not use org.ovirt.engine.core.bll.storage.StorageHelperBase#connectStorageToDomainByVdsId ?
why update require these fields? it should not have any restrictions at all. just think of someone want to update 'description', he will have to supply "address", "type", "host" as well ... in api we using 'PATCH over PUT' concept for update, i.e on update pass only what you need to change, all other data reside on the server side and can be completed at runtime (this why you have in all mapper methods 'entity' and 'template' arguments)
I'd protect it with if (luns != null), just in case
style nit: we don't use curly braces around single line blocks
This isn't right given the method signature of the base method -- name should be used in some way. If you want to pass in the full path to the db file, then I think DatabaseContext needs to be redesigned.
Is there a constant you can use to replace the ".done" literal?
Please have a look at org.jboss.as.controller.operations.common.Util.createEmptyOperation.
This condition is hard to understand. Do you simply mean if (addressModelNode.isDefined()) ?
"result" variable is never used so it could be removed too, right? Currently, executeOnMaster(operation) method is called twice ...
Why not public access?
Make it static
Maybe we want to keep something similar to what id was before
Can make this into a singleton as we have with UNSET.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
Please remove an excessive space character.
We should still render as before, change the text size of the button based on the text_size attribute if present
We do not want to throw an exception to be caught by the consumer. Logging it noisily is probably the way to go.
Copying the style might not be what you want. It's nice for configuring a specific TextButton without affecting others, but you may want to use the same style everywhere so a change to the style affects all buttons. By using the style without copying, copying can be done before creating the TextButton, giving the flexibility of both at the cost of some boilerplate to do the copy.
Suggest create local variable Role role = null and use only one return.
This field doesn't seem to be in used either, and may be removed.
I don't think you ever use stack again? Is this class half finished?
suggestion assertTimerEventEmpty(emptyTopEvent.getExecutionSet(), CANCELLING, EMPTY_VALUE);
suggestion assertTimerEventEmpty(emptyEvent.getExecutionSet(), NON_CANCELLING, EMPTY_VALUE);
suggestion assertTimerEventEmpty(emptyEvent.getExecutionSet(), CANCELLING, EMPTY_VALUE);
can this be part of new module as InputSource seems to replacement for firehose related interfaces ?
Please use more specific JSON type names.
I dont think you need the RocketMQ version number in the name here.
Then I wonder if this is the correct behaviour in the case of garbage being returned. Isn't the contract to retry in the case of invalid reads?
question: why not return Integer.compareTo(fBugFixVersion, o.getBugfixVersion());?
what does compare and hascode mean for datanode if they have different ssl ports?
Shouldn't the test be synchronized as in Http1xClientConnection.java?
Suggest to move the 2nd param to a class variable since I see that the other tests are using the same one with the same value.
Suggest to move the 2nd param to a class variable since I see that the other tests are using the same one with the same value.
incorrect.
incorrect.
Can this IllegalStateException be removed? looks like no exception is thrown out of this method.
@vilchik-elena Charset.defaultCharset() should be replaced with a given charset.
@ivandalbosco we could extract path src/test/resources/org/sonar/plugins/python used twice in this file
@vilchik-elena do we really care about that?
suggestion if (rowIdx >= rows.size() && requested > 0)
let's cancel upstream only here and do not do it inside end() method
Would be nice to circumvent the creation of the Text and go straight from String to byte[]. Same applies to the other Step interface methods.
There's a assertEquals(String message, long expected, long actual) method, so we could do something like this: java assertEquals("Check same instance is re-used", gridLayer, control.getGridLayer());
ParkingPositionLayer - delete
The method signature doesn't specify the Exception which could be thrown.
Could you use a format string here:  log.warn("Zookeeper can't be reached, retrying (retryCount = %s out of %s)...", retryCount, this.getN());
Why do we need a retry here? Suggest to nuke the retry-logic and rewrite as follows preserving interruption status  try { Thread.interrupted(); zkClient.close(); } catch (ZkInterruptedException e) { Thread.currentThread().interrupt(); }  or  try { zkClient.close(); } catch (ZkInterruptedException e) { Thread.interrupted(); zkClient.close(); Thread.currentThread().interrupt(); }
Nano time is prone for overflows. Millis should be fine.
cc @highker on these removal
Wait, why can't this just use SYMBOL_TYPES? I'm so confused...
Do we want to move the conversion from Collection<VariableReferenceExpression> to outside the lambda? We only need to do the conversion once then.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
That is not clear, why do we have "Save" is not adding alarm item is enough? Actually, it is saved in Realm but not scheduled in Alarm manager?
Casting to MenuItem is redundant here
Could you please create a new enum for the Menu and Button constants (I don't like magic strings).
This will silently ignore the exception. Should be throw Throwables.propagate(e);.
The payload itself is already closeable. Close the payload to avoid the deprecation warning?
Make method static.
this mapping should happen via public enum and not via mapping backend enum to string
It's a step in the right direction, but it would be best to be uniform with the rest of the application. For full uniformity: 1) Maintain GlusterStatus.java enum in the API, and map Backend values to it. 2) Instead of status string, use the 'Status' object (I didn't mention this before) The easiest way is to follow an existing example. For example, see this from VmMapper: model.setStatus(StatusUtils.create(map(entity.getstatus(), null))); 1) Backend VM status is mapped to a rest-api status (an enum) 2) The enum is sent to StatusUtils.create() which creates a 'Status' object 3) The 'Status' object is set in the rest-api entity (and later the entity is returned) Note that this woule require changing in api.xsd, for GlusterBrick: <xs:element name="state" type="xs:string" minOccurs="0" maxOccurs="1"/> to: <xs:element name="state" type="Status" minOccurs="0" maxOccurs="1"/> And for uniformity, best also make this change to GlusterVolume state.
If you use .value() instead of .name(), you won't have to .toLowerCase() it later (same is true for all places below that use .name())
It seems that the following does the same thing with super.unparse(...).
IF EXISTS should be reflected in unparse
Can you please use static exception instance?
Always called with (null, null) - so method and URI is never taken into account?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes. Does that change your API expectations?
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
Add this qualifier: this.data
Collections.unmodifiable?
why not simply add tcall the error.. we don't need a special logger here.
move depageLock.lock() right before the try statement
Any catch (Exception e) log.. should just use logger.warn.. maybe the inidivualized logger.. but do we really need individualized loggers for everything?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Can make this into a singleton as we have with UNSET.
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
suggestion /* package */ ApplicationInfo getAppInfo() {
I am not sure if we want to return null here
a default value in the middle of the arguments (one c'tor being A, B, C, D, E, the other A, B, D, E) looks strange.
is this a public API? Or do we want to hide it in internal? I understand that it is only for testing purposes.
You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.
Why you do not call it in finally block as before?
Need to set clone.health to replace this
Add a check for platforms not in the map; otherwise throws NPE
is this needed?
nit: maybe ignored? :)
Is there a reason why this method throws InterruptedException?
I thought I already implemented this for the MavenArtifactGenerator...?
Is this change intended? Also, avoid using magic numbers.
Where does the 5 come from? I feel like we should just throw an exception here.
suggestion assertKeyPair(file, null);
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
suggestion assertKeyPair(file, password);
Binary output length can also be calculated.
Looks like this is the only use of expired, it could just be:  return false;
Boolean
Can this just return 0 if length == 0?
Conceptually, this should be readRaf() since querying the length is a "read" operation. (I realize that in practice, it won't matter due to the exists() check beforehand, but the code looks strange/wrong with writeRaf() here.)
What happens when one of these TypedOutput instances return -1 because they don't know their length?
Can header name and value be null?
Class and constructor can be package-private as only used internally.
No need for super()
Not sure whether this will work, If it does, do you think it makes sense to just clear out the offsets for the partitions that got reassigned, This way we will still have checkpoint state for the partitions that didn't get reassigned?
I don't think you need to wrap in synchronized {}. The onPartitionsRevoked and onPartitionsAssigned won't be called simultaneously by different threads.
Sorry i may not have context here. Can you explain why we are changing from using _consumer.assignment to our internal datastructure for assigment. Do you see any scenarios where _consumer.assignment is not returning the right partitions assigned to the consumer?
Instead you could check this.groupingSets.isEmpty()
You can make the return type here more specific so that you don't to cast to SchedulerTask elsewhere
have a default constructor with reasonable default values
Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
This could maybe be done more cleanly with a stringformatter, but this is probably fine too.
when you are on it: add braces
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Please add logging in here for us to have an idea of what is going on.
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
new String() is redundant.
this should probably fail on receiving interrupt
return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty();
Perhaps put the or else in the parameters. More useable  FpKit.findfirst(list, x -> isGood(x), otherwiseThis)  Could be a supplier to make it lazy  FpKit.findfirst(list, x -> isGood(x), () -> otherwiseThis)
This is redundant. If results.isEmpty() then we have empty singleton and can return results
Add reasonable toString() method, returning null doesn't seem as proper way.
I propose we have accessors getBaseUrl() getRelativeUrl getAbsoluteUrl(). The toString() should call getAbsoluteUrl because that is the most complete representation of the object.
I would move this to a constant so we can access it from tests as well.
we can refactor this if and the one below into more compact code by checking nonnullable using ternary operator
No need for final parameters?
should change this to throw an exception. The caller can either choose to catch it and log it (in getLog), or let it go up (configurePipeline)
Why not Set<DependencyMaterialConfig>? Stops casts at places it's used.
Why gobble exceptions?
Why true if key material is null?
Add the original ClassNotFoundException as cause.
Why not simply throw cnfe?
It does not matter if you use == or .equals here
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.
do we use anything else but RuntimeException?
Isn't a HTTP Status 404 just enough? Do we really need to write a json message as well?
This reset all the routes. You need to get the managed route by its id, and then call reset on that guy
I liked it better as it was before. This is not the proper place to handle domain conflicts. It should be done in AbstractJmxRegistration. Also, the error message, mentioning cache manager name is too specific and not really needed. This is supposedly a generic utility method, used even by remote client.
Same as in Alientype2.java (add type of alien)
Same as in DiagonalBulletLeft class.
iteralien -> iterAlienBullets
Shouldn't this also test an Array that is empty, i.e []? Instead of a String that is empty, ""? Also, I am wondering about multi-dimensional arrays which is kinda the point of deepToString... If the array contains other arrays as elements, the string representation contains their contents and so on. <LINK_0>
Should maybe other countries be added here?
Should look into having a ConnectionStringParser class in Azure Core, I've been seeing this functionality in a lot of places.
See if this can be done in one line. ... ? ... : ...
Could also assert that it is the solr alert here.
The types could be removed.
maybe sth like content.avro.deserialization? so in the future we might add content.json.* metrics, it would be weird to have .json as root metric
I don't think you need this new String
Can we use url building here, to avoid problems with / at the end of the server.
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
![MAJOR](<LINK_1> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_0>
does this need to catch all exceptions?
why do you need config temp variable?
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
Is this a _good_ value for this property? Will the Api work if users don't override it? Should this value be passed as the credential?
cosmetic: move the catch line to prevous line following }
Do we need these changes to build on windows? Can you test this once more? A few problems should be fixed by now in master.
You might want to move this into a shared helper method for other tests which need a temp file with random data.
Should this be two separate tests, since it's two separate conditions with two separate asserts? Also, is there an associated negative path test (i.e., testing the behavior when passing in a random String or a null value)?
intentional to remove the shutdownClientOnClose?
This method should also behave like getConnectionFactoryClass, throw Unsupported exception and not create a default factory builder as it is a getter. The convenience methods below setUser etc may not be able to use this method then but their functionality is correct.
you should probably cast to a string or call toString also could be shortened to return (String) get( key );
Possible NPE here unless I am mistaken -- there may be no defaultValue.
I don't know, but isn't the class also of interest?
minor nit: can we check mSavingContentProgressDialog == null and only create a new ProgressDialog in such case? something like this:  if (mSavingContentProgressDialog == null) { mSavingContentProgressDialog = new ProgressDialog(getActivity()); mSavingContentProgressDialog.setCancelable(false); mSavingContentProgressDialog.setIndeterminate(true); mSavingContentProgressDialog.setMessage(getActivity().getString(R.string.long_post_dlg_saving)); } mSavingContentProgressDialog.show();
Problem je context koji se menja, zato treba izbeci ovaj if. public void showProgressDialog(Context context) { if (!mShowDialog) { return; } if (TextUtils.isEmpty(mDialogMsg)) { mDialogMsg = "Loading. Please wait..."; } if (mProgressDialog != null && mProgressDialog.isShowing()) { return; } mProgressDialog = ProgressDialog.show(context, "", mDialogMsg, true); }
This change to be removed!
I think this isn't necessary here since getStatistics() doesn't need the configuration
Instead of returning Repository, maybe we should return a Git. That way the Git object is ready to be used by the caller.
It throws an IAE when workDirTree is null. Not more, not less.
Missing @ Override
Why not a for each loop?
Simple for-each?
Its probably a matter of preference, but you can just do return getDelayTime(ingestTime) > TRACKER_DELAYED_METRICS_MILLIS
It seems weird to me for the ConvictionPolicy to dictate when to reconnect. I think it would be much easier to manage if it was only responsible for whether or not to mark the connection down, especially if we ever intend to expose this.
Use threadlocal random
commit currently checks these locks, so I'd expect two refreshes. Can we confirm the call explicitly after the get and commit calls?
I think we also want to check that the status is equal to 404 as well...
This one will always use the default timestamp table (though looking at atlasdb-jdbc it doesn't even use AtlasDbConstants but uses its own "_timestamp"!) I'd actually suggest doing a Preconditions.checkArgument here, this one seems a bit more dangerous than the InMemory one in that it can actually have surprising consequences!
that should be inside an else clause, no?
This should be renamed with camelcase: allOvfStoreDisksCreated
Would it be possible to pass only the id as parameter? I guess that the backend is already retrieving the storage pool, so we are retrieving it twice in this case.
move it before synchronized
This is like double lock checking. You may also want to check it before synchronized which also improves performance. Considering namespace is not changed, you don't have to check it in within synchronized block.
> NoSuchElementException
Why does next have to be invoked here?
Should use XmlUnitUtils.assertXmlSimilar(), so that slight changes in the XML serialization do not trigger the test.
I don't like the density here. I would prefer if all arguments of the constructor are declared as local variables.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Too lax imho, should be .equals("org.apache.commons.logging.impl.Jdk14Logger")
I would just get of any semblance of support for Apache.
Consider replacing both of these with a private utility function to getSafeLogTag that will truncate (and warn) and could potentially be extended in future to do other sanitizations. That way your code reads more clearly: java String safeTag = getSafeLogTag(logTag); // Or sanitizeTag or normalizeTag, etc ...
Actually the underlying objectExpr could have free variables.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
return authentication.getUser(username);
you can refactor this in a different patch to make less noise
merge line 76 and 77
this seems like it should be a try() with resources
Can you make a separate test case to test this functionality instead of modifying an existing one?
Ditto: use SamReader.Type.BAM_TYPE.fileExtension()
The title should be HTML escaped here if it's going into an HTML constant (which is presumed safe)
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
Please use ApplicationTemplates instead of constructing the SafeHtml.
@fchauveau there is no null handling of source, is this intended ?
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
use arrays.copy? or system.copy?
Revert this.
Add null checks to all the constructors, as callers rely on this being not null
Like the SFS this won't be backwards compatible as the HEADER_SIZE has changed, however in this case we can't workaround this using the MAGIC array as it does not exist. So I think we might need to add a magic field, and read accordingly depending on whether it is/isn't present.
Should this return 0 or -1?
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
You need to return single[0] & 0xff. The result has to be unsigned.
Does this need to be public? Please do not introduce new public members without cause.
Possibly shorter to just write java env.applyConfig(this, hasTag("reindex"));  but this is ok
The configuration is confusing it's similar to number of mutations but it's actually a timestamp. It can be something like INDEX_FAILURE_HANDLING_REBUILD_PERIOD?
We can do without final here since the whole class is final.
Add the original ClassNotFoundException as cause.
I would prefer do not fallback to the getClass().getClassLoader(). The Assert.state() in this method should be great compromise.
here too, can this be done with computeIfAbsent?
Why do we ignore effectively ignore this message if back pressured?
I think there are still race conditions here in some (potentially rare) conditions. If the records have different sam headers ( and you're not pre-initializing them with the now deprecated constructor) than the id is dependent on the order that getLibraryID is called in which is a race condition. Maybe we don't care about that case since we don't expect to have different headers given that you've deprecated that constructor. What happened to syncronizing populateTransientAttributes? Using a ConcurrentHashMap.calculateIfMissing is a good idea.
getTotalTimeout makes more sense.
You will not need this after putting it at the class level
such constructor should not be exposed to user. User should use ChannelConfiguration class
Does a straight comparison work here? NaN isn't usually equal to itself.
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
The new term and self vote still have to be persisted before transitioning to leader, i.e  raft.setTerm(raft.getTerm() + 1); raft.setLastVotedFor(raft.getCluster().getMember().memberId());  Without this the raft is in an invalid state, that is also why the test are currently failing on this branch.
minor: can be final
We might make the LeaderElectionDriver a bit easier if we instantiated it here. Then we could save the start method. Of course we would need to add a LeaderElectionDriverFactory.
IllegalArgumentException for consistency, needs 2 _arguments_
Same as above. Can also move this common block into a method of Function and use at many places
needs 2 _arguments_, plural
Should this be delegating to a different method than encodeLink, above?
Stricter check. Given that this is in 3 places, is there a better method that we can override that would only require a single path check?
I think it is easier to read if you don't use nested ifs. Same for the other method.  if (item == null) { return null; } else if (item.getLink() != null) { return item.getLink(); } else if (item.getFeed() != null) { return item.getFeed().getLink(); } return null;
Looks like approach proposed in line 92 would help here too. The less code duplication, the better :)
store variable
please add line above to separate 'block'
Nitpicking: would have been more compact with a constructor KeysSupplier(Collection<Object>, boolean).
Make it consistent with other two.
what's the point of doing this?
Using the error message in the metric could get really messy. These are arbitrary strings, and could be very long. For Error, we're using the error code-a _very_ different thing, since these are well known, and short. The exception type name is enough for Exceptions.
My preference would be to remove e.printStackTrace() altogether and let the 'error' filters determine if they want to log the error.
Why the errorCode checking (null != errorCode) here is not the same in HttpEvent.java (!StringExtensions.isNullOrBlank(errorCode))?
Might as well add a comma
technically "status=" should be "state="
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
complexSlug is not used in this context.
Shouldn't you rather log directly?
The value for this test in the develop branch is the correct value. Changing to this value is a bug.
I think that if there is more than one stereotype on the annotation (which is allowed), then this will override the variable and you will only inspect one of them which is incorrect.
nit: suggestion if (CookieParam.class.equals(annotation.annotationType())) {
AnnotationTypes are classes, so using == should be safe
Yep, what Leo says is what I meant.
Too many "if" here, it's better extract a method. For example: Bitmap getImageFromCache(string imgLocation) { ... }
Why this check?
change variable to something more meaningful
pvk should not be visible. Please remove it.
Bad variable name! Variable names should be clear enough. Rename it.
![MAJOR](<LINK_0> 'Severity: MAJOR') Update this method so that its implementation is not identical to "getParent1" on line 135. [![rule](<LINK_1>](<LINK_2>
There's a StructuredSelection.EMPTY for such cases.
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
Should we reduce the scope and do an earlier return if bulkOptions is null?
Thank you ;)
Why not initialize them at construction time instead of lazily on request?
shall we add some message here?
Are result and errorMessage not applicable for workflows?
This isn't "Done".
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
Oh, right, that was me. Sorry!
I'm not sure the sorting should be in ArenaImpl. The reason getNonreadyPlayers() returns a List rather than a Set is likely because of its original call site in the notready command, where it is fed to a utility method that stringifies a List. So it's probably past laziness more than anything :P I think it makes more sense to do the sorting at the caller site rather than in here. If nothing else, it reduces the blast radius of the pull request and keeps the changes "collected" in the signs/rendering code.
Remember to revert this file, it should know about the transport class.
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
no need to break long strings... check-style has an exception for lines that are just strings
do you have anything against making the longtext fields bytes instead? I'd prefer to keep character encoding issues in the code and not in the db...
Can you make the query (adding some filter) slightly more complicated to show the effect of more rules. For instance "select \"store_name\" from \"foodmart\".\"store\"\n" + "where \"store_name\" = 'Store 1'\n" + "union all\n" + "select ename from SCOTT.emp where sal > 0"
Just seen this... Would it be more convenient for this method to be named assertPredicate? The current name seems to mean that it will perform arbitrary assertions...
Maybe we can create a variable with a meaningful (requiredExtendSize) name for this expression? Let's also explain than extend size is limited by virtual size, hence the Min
please use "else if" since only one option can be valid at a time. Please also format the code according to the Eclipse coding standards.
To clean up properly, please place the Builder in a try-with-resource block java try (Builder b = new Builder()) { // test }
I guess null check is also will be nice to see here. Like java assertNotEquals(a, null); b.setDefinition(null); assertNotEquals(a, b); assertNotEquals(b, a);
Should there be some keys that are tested to not be contained? doesNotContain?
Code style: Always use curly brackets, and space after if.
Code style: Always use curly brackets, and space after if.
Since total is used only once for int remaining = total; We can remove total and: int remaining = dst.remaining(); Then it's perfect!
/dataset/commons-lang/ will not pass the CI test since this repo is present just on your local machine right now and hence an error will be thrown on the CI server. Make it repogit4testv0 maybe.
I have a different opinion on this. I would like to see mockito fail here. It indicates that the dev made something unintended and it is easy to fix.
test name does not correspond to the test class name - unsure what are testing here?
This is not thread-safe, right? Someone can increment the _pendingCount after this block and have you tryExecuteLoop() again.
Should we clear highlight on error as well?
Use same order as the field declarations.
This line isn't happening anymore, right?
Please io.druid.java.util.common.ISE for IllegalStateException, which under the hood uses StringUtils.safeFormat for error message printing.
private? like getCachedHeader and the other methods?
this method can be made static
This method can be implemented as return a - b;
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
static import DataSize.Unit
add null information
suggestion new HashMap<>(Map.of(unit, transportToLoad)));  Pretty sure that works
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
why not use AddressUtil.getAddressHolder instead? Does this method support ipv6?
nit: you can merge both lines above as checkNotNull will return the given argument
This should return the PDataType for an element of the array
Perhaps nameToDataType.
Do this check in the constructor instead (or a static factory method). You'll want to be careful in how you calculate the baseType and you'll definitely want to throw if you can't find a baseType for which all elements are coercibleTo. You basically want to find the common base PDataType. Something like the first loop in CaseExpression:  private static List<Expression> coerceIfNecessary(List<Expression> children) throws SQLException {
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
This will throw NullPointerException if parsedPath is null. We can do:  return toStringHelper(this) .add("rawPath", rawPath) .add("parsedPath", parsedPath != null ? Iterables.toString(parsedPath) : null) .toString();
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
Could we add this to util class so that we don't need to specify StandardCharsets.UTF_8.name() all the time? Maybe two versions throwing original UnsupportedEncodingException and RuntimeException wrapping UnsupportedEncodingException.
For this, and all other xxxAttributes classes, are there well defined map key name constants we could use? If not, then I would be in favor of adding them as public constants to the xxxAttribute classes, to avoid raw string constant usage in consumer code.
I would change the message to: "The resume() method was called more times than pause()."
Throw IllegalStateException is pauseDepth becomes negative.
Throw IllegalStateException if pauseDepth becomes negative.
nonexisting are two words. So, nonexisting -> nonExisting
maybe, would not be keeping the map null better, to ensure uninitialized mapper will not be used accidentally? (even NPE is better then complex debugging why roles are not mapped...)
why not with stream API? will be cleaner
Hmmm. The process() method should be as lean as possible. This calls for a DisableMaterial() class to be used as default instance, in which the process method is just shaderManager.disableShader();
I think you missed a {}
GET call should not change the state of the system. Also, this will delay reporting by 30min everytime someone invokes this API. Split this into two things - regular GET, and then another call to mark the beginning of update.
Entry transformer can be static value, no need to create new on each call
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
Collections.EMPTY_LIST;
This code could also be written like the following, and then maybe the map in the superclass does not need to be made visible. java for(CacheType ct : CacheType.values()) { //not sure if values() is the correct enum method name ((LruBlockCache) getBlockCache(ct)).shutdown(); }
can this throw any exceptions?
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
I don't have strong preference here. - Shall protected or package-private enough here? - Or, on the other hand, with these two methods made to the public, we can avoid several test codes using INSTANCE_DN_KEY and RESOURCE_DN_KEY directly. Not a must in this PR, though.
Nit: not much point declaring SLASH if it's character counter-part is a local variable.
why are there two public constructors?
Never call onNext while holding a lock.
As returns always null and result is used nowhere I think we should change the signature: private void inputOnBlur(final Event event) {
Can we use isValidPosition() here instead?
do you need to check for nulls on paymentWorksNewVendorDetailDTO and paymentWorksNewVendorDetailDTO.getRequesting_company()?
the else is not really needed here since the code after won't be called if the if condition is true and the method returns.
the part where the pmwVendor fields are updated could probably be extracted in a separate method
Ah, this on-obvious to me: why do you switch the zone to UTF?
~~The tests are not covering the bug that you fixed. I can change back this line and your tests still pass successfully~~ nvm, i realised my mistake.
The method RassStringToJavaShortDateTimeAdapter.parseToDateTime() is already returning a DateTime, so extracting its Date value and re-wrapping it in a new DateTime seems redundant.
Should this method be final?
This should stay final
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
As above, assertions the wrong way around?
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
This line should be removed
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
magic number
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
this is a public method so better perform some null checks, or at least use assert statements
this can be done simpler using a sorted stream of param entries to produce output string
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
It seems that cfg.isClientMode() can be used there.
Let's refactor this to cfg.setClientMode(igniteInstanceName.startsWith("client"));
this can also be made a static method.
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
Using something like ImmutableSet.copyOf(contentTypeToTemplateEngineMap.keySet()); would make sense imho...
minor: can remove this and directly initialize it at line 41
This sould be retrieved from the plugin, not instantiated here. Only the plugin should instantiate this class (which should be called ModelDependencyProviderRegistry)
The problem with this.... While it is quite ugly to just create a new thread when you create this, but the loading will start immediately. Now instead the loading is governed by the framerate. Well, not really that big of an issue. But what if you load the app minimized or alt tab away. Loading basically never starts because it waits for the screen to draw.
Likewise..
Likewise..
Likewise..
Lists.newArrayList
Remove the one of the available ids (1 or 2)
Can be rewritten with Arrays.asList().
nit: this is a filter function, might be better to use filter replicaIds.stream().filter(r -> replicaAndState.get(r) == state && (dcName == null || r.getDataNodeId().getDatacenterName().equals(dcName))).collect(Collections.toList());
This can be a stream - filter - collect expression.
Wondering if we can combine the two get methods and have it return Collections.unmodifiableList(replicas).
Need to implement
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
is this problematic for cycle detection?
In the page, projects are sorted by a comparator, so that projects.get(0) may look as a randomly chosen project. The same problem was solved in NewApplicationWizardModel.getDefaultProject() by applying the comparator.
Since the method is simple public synchronized Project removeProject(Project project, User deleter) throws ProjectManagerException { projectLoader.removeProject(project, deleter.getUserId()); projectLoader.postEvent(project, EventType.DELETED, deleter.getUserId(), null); return project; } Would using mockito to verify the internal calls be a better test? This will cover for example the user parameter is passed correctly.
Alternatively, you can consider this method: <LINK_0>
how about using String.format - it's much cleaner than string concatenation and you don't have to worry about "
Moving assertion to test will actually make test more readable - reading the assertion gives you an idea about _what is the expected behaviour?_ Hiding an assertion is a bad pattern, I know it's used a lot in legacy code, but I wouldn't like it to be used in new tests ;)
Is this assertion is needed?
I couldn't understand the need to get templates config and set it back again, is this required?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
pls use formatter
@fanifieiev it isn't the correct way to calculate hashCode. Please, look the others Cactoos classes to know how can do it.
Suggested getClass().hashCode() as something "more random"
not safe. what if ntCall changes?
Please replace the following 2 lines with return failCanDoAction(VdcBllMessages.HOT_PLUG_IS_NOT_SUPPORTED);
that check is not needed anymore as osrepository reflects the support per architecture and version.
pls replace with return failCanDoAction(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED);
Can be simplified to: java results.stream().anyMatch(entry -> value.getK1().equals(entry.getKey()) && value.getK2().equals(entry.getValue()))
This could be made static
value already is a String, so we do not need String.valueOf(value) here.
Instead of assign and return, just return the last statement.
Remove this "if" statement. That said, here are a few things for future reference: 1. You use "is[Level]Enabled" to check that specific level (e.g., if you're going to log trace, you'd check "isTraceEnabled()", not "isDebugEnabled"). 2. There is no "isErrorEnabled" -- unless you disable logging altogether, it's always enabled. I suppose you could use "isEnabledFor(Level.ERROR)", but you'd only be checking if logging is on at all. 3. As a rule of thumb, unless the logging operation is extremely heavy (e.g., transforming a large object for the trace logs), you don't want to check if "Info" level or lower are enabled, only higher (debug, trace).
Declared but unused.
Since State is an enum, we should use == here.
We can throw the exception to client.
Looks like spurious changes with no changed behaviour in this file. Necessary?
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
These should get saved in a data structure so that repeated calls with the same name return the same map.
Although we require JDK8, we must remain JDK6 compatible so you must specify the types here.
Let's static import the assertions inside org.junit.Assert so we don't need to prefix them with Assert.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
suggestion }
maybe some kind of separator would be nice here?
Is this supposed to be <code>return "Bump"</code>?
I believe fullyQualifiedName.isEmpty() will do the same thing and is a bit cleaner. Also could you use curly braces even for single line ifs please? I'm not keen on omitting braces for single line if statements because when adding a second line in it's so easy to forget to add the braces back in!
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Please move the validations to a separate method called validate() or validateName()
Who uses CR as a line delimiter nowadays?
I agree to Robin's proposal
Wrong way round.
I don't understand why localMediaId is a string in several places when it should be an int, but as long as it's being passed around as a string we need to play it safe and catch any potential NumberFormatException if it fails to be parsed as an int. The simplest way to do that is use StringUtils.stringToInt().
Maybe we can consider failedMedias or failedMediaList ?
yeah I get what you mean. I was thinking if the event comes rapidly after the cancellation, then we can disregard it. But if it comes say, after 2+ seconds then we can assume with some level of confidence that this may be treated as a "new attempt". So we'd have to record the time when the user cancelled it along with its id, instead of it being a HashSet it could be a HashMap that links the time of cancellation to the localMediaid as key, then when onMediaUploadProgress is called we'd check if this is contained in mCancelledMediaIds.keys, and if yes we check the time elapsed before deciding to remove or not. A proper signal would be to check when the user inserted the image in the first place, but I'm not sure we have a signal for this through the bridge. It may be appropriate to add a bridge method, but it also may be overkill for a corner case bug anyway. I think adding the time check adds extra security and is not that much code to add, without going for the full blown solution, wdyt?
Minor: since locateMember has been renamed to locateMainArtifact, maybe downloadMember should be renamed, too?
Nit: You should check the return value of mkdirs and throw eventually.
maybe something like this instead?  File file = new File( directory, targetFile ); if (!file.exists()) { fail( "Could not find file " + targetFile ); } return file;
I thought we had agreed that to preserve idempotence the local operator would always overwrite any existing view definition?
remove
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
I think we can revert this change already since AnonymousQueue is now Base64 by default.
Sorry forgot to mention to change the read to access here too
It's a good update
Change to: > Unsupported DMN asset
why do we need this new method?
Let's avoid raw types, please.
This will return an immutable map. Use new HashMap<> instead.
please consider verifying if map is deleted here as it is quite important, I know it is not a test, but it can be hard to detect in the future if this method is broken
Use nbrDim instead of min.length here
What if values.length is longer than COEFFICIENTS.length?
redundant
defensive copy?
Like PvaluefromZscorePostAggregator, this should recursively decorate the post-aggregators from fields.
Better to use Comparator.naturalOrder(). BTW above in similar situation null-aware comparator is used. I'm not sure if null-awareness is needed.
you could use: prefix.ifPresent(prefix -> if (isBogon(prefix.toString())) ...
Use RS_MAINTAINER instead of ALLOC_MAINTAINER ?
LIR == OrgType.getFor(originalObject.getValueForAttribute(AttributeType.ORG_TYPE)) is a bit cleaner..?
Can make this into a singleton as we have with UNSET.
should it not pass true as third parameter? the definition of createExecutableExpression conveys that
Does this sound good? 'Create a new aggregating set expression using a backing TreeSet using the given comparator'
This can be replaced with  java return newName.isEmpty();
Same here, we can just return the result of the predicate.
use stripWildcard(refName)
It's nice to have expression lambdas, but using node.findFirstToken(TokenTypes.IDENT) results in evaluating the same node twice. Assign to a local variable.
not null
This error message should be updated. From what I can see in the code, there's nearly zero chance for this catch to hit. Perhaps, this will only happen in case of some connectivity issues with Dropbox. I suppose the best we can advise user in this case would be to just try again and that's probably what should be in the message.
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
If you make the outer a proper class, it can implement Disposable and dispose() can call cancel() on the field inner.
This will forward the child's requests and will hang because the child doesn't receive an element and nobody is requesting more. I'd instead write this:  java Subscriber<T> result = new Subscribeer<T>() { ... } child.add(result); return result;
be backwards compatible
it seems, that filterBondsWithoutSlaves is not interrested in 'host' and neither in commandContext. we can make at least the method static - that's easy although ugly and goes against CDI. Better would be to move this method to different class. Please notice, that this class requires commandContext although it's only usage is this fake one. So doing this change will simplify this method, heal NetworkConfigurator, simplify this class constructor, and all descendants.
Do you consider this(hostId, 1, 1); nicer here?
These catch code blocks seem to be very repetitive, should they be factored out into a utility function/lambda?
You should check if jobsId is empty or not.
Why the change? This now creates a temporary collection just to stream it.
(Rather than a bunch of IF statements, you could do this all as one return statement w/ && for above.)
Non-standard equals?
return obj != null && getClass() == obj.getClass()
Use a constant for this path.
Move String values used more then once to a constant.
Move String values used more then once to a constant.
Why setting Token or MID imply sent = false ?
I think we want the is\* methods to just check the token type and nothing else.
Please keep this.cell near the related fields (previousFamily & cell count) below
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
Should be- setTitle(text.asString()) not setText.
This one seems too broad
We don't need to merge internalExchangeInfo and exchangeInfo. Remove the merge from WebserviceProxy, ExchangeManagerHelper and all related code.
return Arrays.asList(....)
Recommend to use ToStringBuilder
please also add the GUID which is important.
Recommend to use ToStringBuilder
See below (return copy)
shouldn't it rather throw? If we're here it means someone wants some memory back and we're giving none. It's an error.
This can be "package-private", i.e. no access modifier.
The last assert is different from the first 2
Assert.areNull
1. are we showing what we observed or we expected? it looks unclear to me. 2. given that this is only used once, is it better that we just use assertTrue in l.108? 3. static?
Is there a more specific exception that can be caught?
If you want to keep the long variable name for the Statement arg then please wrap this line to make it readable:  ExpectException expectException = new ExpectException( statementThrowingAssumptionViolatedException, AssumptionViolatedException.class);  But I really prefer delegate or delegateStatement because that is what the role of the Statement is for the sut. The variable is declared one line up, so the long name isn't needed and makes the code harder to scan IMHO.
Redundant assertion
Another place where the name should probably be updated
Should be "InstaPost" actually.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Should make a differentiation of the name and id.
package-private? Only used by AbstractJmxRegistration
If this is intrinsic, needs to be prefixed.
suggestion thrown.expect(containsCause(new ValidationException("Option 'csv.quote-character' must be a Character.")));
Damn, what have I done
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Detail: FROM capitalized.
I would split the extended check into a new line with a regular if statement.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Seems like debug code.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Why is this necessary?
Why not check isEmpty()?
This code can be extracted to a general "run & check" method
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Should we add: Objects.requireNonNull(record)?
This should be >
Doesnt it has to be aup = pointA.y * (pointB.x - pointA.x) |It would calculate the lower rectangle. Using pointB.y would calculate the upper rectangle. Maybe i am wronng here, please correct me :) ![pointexa](<LINK_0>
Avoid calling getOverload twice.
like line 63 but this is setFeature, so should be removed?
I have some doubts about the change here. In this case, the attempt is exactly to alter the current ResteasyProviderFactory instance (yes, I agree, that's not a best practice at all). By creating a new instance and not setting it in the singleton reference within ResteasyProviderFactory, you're altering the test. I suspect this is not spotted by Travis CI because the test here is likely not running due to the exclusions for RESTEASY-1935.
Please fix the alignment.
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
The value only from partition column, use Unsupported partition type to make it clear?
Instead of instantiation via string name, we could pass the class name here and use reflection to load the dialect like a plugin.
why is it adding null?
Perhaps you can remove the temporary variable entirely and use map to make this method a one-liner?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
@shelan so no need to declare every method as final
ImmutableMap.copyOf()
can we add here more descriptive name instead of element? Maybe parameterInput or input or field?
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
nit: maybe replace } with a blank line? There is no such code style in druid. The same for the { and } below.
Shouldn't this also test an Array that is empty, i.e []? Instead of a String that is empty, ""? Also, I am wondering about multi-dimensional arrays which is kinda the point of deepToString... If the array contains other arrays as elements, the string representation contains their contents and so on. <LINK_0>
unused
Can you pull this out into a property?
Why don't you do this at the end of the running phase?
shouldn't this be an assert rather than just a log message? do you expect InterruptedException to be thrown during a normal run?
There are quite some AccessResultCodes beside SUCCESS. If the result is included with the exception this could provide useful information about what exactly went wrong.
Also wondering why? and how this is related to ASM 6?
Wondering why? how this is related to ASM 6? I'm asking because we had some improvements and quite some nasty regressions/missed cases of exception handling exactly here.
This asserThat will do nothing - you need to add something like isTrue()
Can this call return null?
Please use StringUtils.equals
Mark as static.
Needs to be updated to Configuration.LIBRARIES_DOWNLOAD + "/JPushBullet"
Catch exception.
Use '<' for character-based searching.
String.valueOf()
Cant it loop?
suggestion assertNull(r.jenkins.getNode("foo"));  since it is not otherwise obvious that the node's name did not change somewhere in here.
Since we are creating a fresh new index, we might as well add the "cts" field, so then later on we don't have to worry about updating the mappings via rest call.
this is rather arbitrary... why the limit? we are always going to be able to get up to the basenode given that the childNode is guaranteed to be a descendant
I have noticed a few occurrences of catch (Exception e). According to <LINK_0> we should catch the most specific type we can. Can we catch more specific exceptions here?
formatting ?
try-with-resource can use here as well
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
It is not necessary to test REPLICATE region in this test.
size could be set to 2.
Use assertEquals
compare object instead of reference? Why don't we just always wrap it since it is cheap now?
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
you've defined constants for these keys in another class. Why not make them public and use those constants here, instead of using the string?
Should never use /tmp hardcoded. Use System.getProperty("java.io.tmpdir") instead. It will be set to local container directory.
why referenceName is null ? would this cause any issue @albertshau ? also is there any issue with using the same reference name from the config ?
To be safe you should read the bytes before assigning into data: byte[] d = new byte[len]; IO.readFully(in, d, 0, len); data = d;
Don't we need to the close the streams?
I don't think this method is really necessary. If this is just about initializing the transient map, just do it in the field declaration
return Collections.emptySet(); ? BTW, it seems that class DummyGroupMapping is never used now, do we need scrubbed it off?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
It would be better to use... suggestion public @CheckForNull Hashtable<String,RangeSet> getUsages() {  Nullable is a soft requirement which does not trigger warnings in static analysis tools
Add stack trace to exception.
Work is generic, so add <?> at least
Why WARN? INFO would be enough I think.
declared exception isn't thrown
nit: can be replaced with readNetworkStatsDetail()
what guarantees getParameters().getNetworkId()) represents a real network ?
use StringBuilder instead. StringBuffer is thread safe (and slower)
In this case, and please consider if this can applied also in other *Handler classes, i think we could avoid using $ to build again the objects for the XML and use, instead, String message = element.getTextContent(); to get the value.
suggestion message += "\n WARNING: There are uncommitted changes to the script definitions. These will be lost if you update.";
We may also want to cancel our subscription.
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
Should this return 0 or -1?
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
This should not be public, we only construct via the factory.
this(...,..., LogLevel.INFO);  apply the same pattern to other constructors.
please remove or decrease log level to TRACE
could be changed to  try { channel.close(); } catch (IOException e) { //ignore } try { connection.close(); } catch (IOException e) { //ignore }
Follow setUp().
should only append if gtidStr is not null
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
Why is csrf disabled in general?
Customizer#withDefaultslooks more readable to me.
The original code was there to demonstrate the syntax, even though all paths are locked down by default. I think you still need to permit everything but /restricted for this example to work properly. I will double check as a UAT step.
Why are you keeping the conversion-less method?
Why is hard to read generic coding used here?
.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?
shouldn't you close this stream? Use a try with resources?
lets make sure we don't get npr in these exceptions
The Exception message should contains the original IOException ?
I'm updating this PR since I would like to merge it before tagging the next release. Thanks for the fix btw!
Better be cooperative-sticky? cooperative is too general I think.
This method could be protected.
Better to use immutable ValidationResult
Running the operation in a Validate method looks a bit weird even it can do the stuff, ComponentDriverInitialization<ComponentProperties>.runAtDriver seems more appropriate but it's ok.
I'm not sure what Java version is allowed to use in Daikon. If java 8 is allowed we may use java streams feature to make this method shorter
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
I'd prefer we not import the icu.util.Timezone and make java.util.TimeZone the default in this file as it's returning this thing. The icu.util.Timezone is an internal impl detail. Alternatively replace all uses of TimeZone with the new icu version throughout the system (if we really want to replace it). Mixing the two seems bad
"formats" is an ImmutableList, you don't need to synchronize on it directly to iterate. Here you probably want to make sure only one thread is modifying the time zones at a time though. I'd suggest putting the method itself synchronized instead, or using another lock at TimeGraphScale's level.
Same thing about calculateInvocationTime
minor thing, but this doesn't need the throws clause
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
Don't log here. Exception is re-thrown with all relevant information and mutations could be verbose.
This didn't use to block, so the flush method it's part of didn't block either. We should not change that, since it might eat up threads that are used in other places. It also blocks under the BigtableMutatorImpl#lock Lock, which is used to queue up new mutations and is in the direct write path. To work around this, we can either use a nonblocking API (if available), or spin up another thread pool with queue to deal with this here.
We should not be throwing RuntimeException
These tests might be a bit brittle since they depend on how the writer is verifying the existence of the header. If the tests did: java String value = new String("value"); this.response.setHeader(CONTENT_SECURITY_POLICY_HEADER, value); this.writer.writeHeaders(this.request, this.response); assertThat(this.response.getHeader(CONTENT_SECURITY_POLICY_HEADER)).isSameAs(value);  Then it would verify regardless of the way the writer implemented the check.
Typo: Ant**P**atchersPathVariablesCa**mm**elCaseVariables should be Ant**M**atchersPathVariablesCa**m**elCaseVariables
Can this be private, or is there another use case for default attribute outside the builder's call?
@gaurabdg interesting approach, but can we store this depth inside object to avoid unnecessary calculations
@romani > Classes which are missed in Cobertura coverage report: com/puppycrawl/tools/checkstyle/api/LocalizedMessage It looks like either Comparator.nullsFirst or Comparator.naturalOrder forces cobertura to ignore the entire class like we have seen with streams. @Luolc Please rewrite this class not using those 2 methods and figure out which is causing the problem.
Change to use this.jsonAsString.hashCode().
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
please, remove System.out
etc. for the rest
For Max + Min Size, I think synchronized should be removed from the setter methods and just make the variables volatile instead.
OSGP code conventions are not followed (missing this. before referencing a field).
If VM's custom compatibility version is set, cluster's compatibility version is ignored. That means we don't need to display any warning, because nothing was changed for the VM.
why not to compare with the standard java way for enum comparison (== VMStatus.Suspended) ? and don't you need to check whether it is different than Suspended?
why not switch/case?
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
Using an Observable in all these callbacks is wasteful in both allocation and performance. I don't see any advantage over  java if (activity == activityToMonitor) { subscriber.onNext(LifecycleEvent.CREATE); }  which is allocation-free.
Is it okay to only checkForDecideUpdates() in onActivityResumed()? I think with the current logic, only one call is necessary now since we register the listeners.
Best to leave super() to avoid empty block complaint from Sonar.
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
indentation is not right here
Can restore Path installDir = Files.createDirectory(tempDir.resolve("install")); too, e.g.: Java Path installDir = Files.createDirectory(tempDir.resolve("install")); Path xmlDir = Files.createDirectory(installDir.resolve("xml")); Files.createFile(xmlDir.resolve("log4j.properties")); zapInstallDir = installDir.toAbsolutePath().toString();
Maybe we should start using java.rmi.server.UID instead.
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
nit: throughout this test suite, the WKT strings are not consistent. For example, there are LineString, MULTILineString, MULTILINESTRING, etc. Would you take a pass and make them all align. Perhaps, uppercase all the WKT type prefixes? 'POLYGON...', 'POINT...', 'LINESTRING...'
Throws AIOOB exception when called with index = line count.
Would you mind changing it to a single line? I.e. return lastChunkIndex - substitutedLine.length + originalLine.length();
I think you can use freezing instead of pausing to have the player automatically save the playing state.
It crashes because lastSearchedText is null on first launch. check for isEmpty?
Hi @rezita, I think this should be isSHREnabled
Lets use super.cleanUpUsingRest() here
Lets have the cleanUp() at the end as a practice
Lets use the previous cleanUp method as discussed.
What does the constant mean?
What does the constant mean?
Isn't that the normal situation (as by default nobody should have to set a timezone)? If it is, I would expect no logging at all (as all is fine), so you might want to set it to debug instead.
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
Please add braces surrounding the for loop block. Otherwise this is confusing to read.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Do we need this to be public?
This could cause a NPE, instead resolve Optionals by checking present() first
@johnou this is not thread-safe... You will need todo this in the handlerAdded(...) method as CharsetUtil.encoder(...) looks up its encoder via a thread-local. So we need to ensure we call this from the same thread as we use to encode later on.
Should this not be by.css as well?
please add PageObjectLogging.log method here
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
Added code to print an error message and exit.
Would file.getName().endsWith(".java") work OK? And I guess if the case is a concern, maybe file.getName().toLowercase().endsWith(.java).
What happens when we have a file named "pack-1234idx" in that directory. No '.' but ending in a well known extension. Such files would be deleted, or?
probably also worth to rename callback to ruleManager.
The cast is not necessary, we are not using generics for nothing ;-)
Don't create an entityManager here. Let the transaction create the entity manager.
I think can just indent 8 spaces from [t]his
What event is being waited for here?
public PostsListPage and return this for chaining purpose
a workspaceitem should be returned
I don't think we should suppress this exception, especially considering methods in this class, e.g. buildRequest, throw it so usages should already be handling it.
final URI uri
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement may execute just a tiny bit quicker as Enum comparisons are sped up by the compiler. Other than that this is looking good to go!
consider extracting local variables, this is hard to read, or early exit
Would that actually kick in for interfaces, too? I don't think we need keep the two cases apart, interfaces are just a form of abstract type. In the error message we could say "result type may not be an abstract class nor interface".
I suppose there is nothing wrong with this, but there is no need either, is there? (other cases of the same marked with ditto3)
Is this the correct monitor to do the "worked" on? I missed this in PS1 review.
May be you do not need another submonitor conversion here?
Could you maybe look if this could be removed? I mean the new DefaultVariableNameFunction().apply(this). It's already handled in the other constructor.
We need to have a backup plan here if type isn't a TypeVariable.
Maybe getUncapSimpleName could be deprecated and the transformation done outside of EntityType?  java String variableName = variableNameFunction(type.getSimpleName()); if (JavaSyntaxUtils.isReserved(name)) { variableName = variableName + "$"; }
Shouldn't this be < instead? if the end of the time range of this request is before the time range that has been updated in the traceRangeUpdated signal handler?
you have to get the current range from the new trace manager not from the signal
should this be return?
From PR it appears that you want to display a different error if the plugin is not loaded vs when the plugin doesn't implement plugin-settings. If that's the case, there are more straightforward ways of finding if the plugin has been loaded up instead of iterating over all each extension everytime. Its very easy to track that kind of information in DefaultPluginManager and ask it for it.
Do you need to use the "text" constant?
This could just be Boolean.parseBoolean(string);
I think would be better to follow other components on how to set configurations, meaning that to configuration properties mutable and let Camel do the job of binding the parameters via setProperties(configuration, parameters);.
This shouldn't be done, we just need to setProperties on the endpoint, so the second one should be sufficient, take a look at the other components.
I just realized that setProperties should be done on the endpoint not on the configuration in order to avoid reflection, is that correct @oscerd ?
You should test for both instructor and student?
Why are you accessing courseId from instructor?
Can correct the typo accessable since you are changing the code
Is it possible to get rid of this?
Also verify that the unassigned ip is no longer there?
Is this really needed here and in the next state-change methods?
BaseForm class provides a constant value for this faces-redirect=true. Please use this constant.
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
Checking a non-checked (RuntimeException) usually requires a special reason. What is the special reason here for checking NPE?
can u extract a final constant with a readable name out of "<[ ]*/[ ]*%s[ ]*>" ?
Let's not include the %n  header here.
So I'm a bit afraid that there is a code out there in the while that relies on this giving the old output. Could you also add a method toFastQString() that also calls through to encode so that's there's an obvious way to do what this used to do? I think toString should probably call through to that and produce the same output as it used to just to avoid giving people surprise headaches.
lastFlush is never updated. Am I missing something? Also I wonder if we should update MessageFlushPredicate.shouldFlush() for this new lastFlush argument as well.
-1 would be more correct. AFAIC you can skip this.
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
This should be written this way. We also have to keep the code readable.
You can do this just using what's built in to Java:  return String.format("Notifications [notifications=[%s]]", notifications.stream().collect(Collectors.joining(",")));  But ImmutableLists toString() pretty nicely, so you should just be able to do this:  return String.format("Notifications [notifications=%s]", notifications);
See if you can change things like this to just return "Invalid response";
File. createTempFile takes prefix / suffix, not dir / Filename. That makes this confusing at first glance.
we cannot do this. :(
I think FileOutputStream should be created with try-with-resources, just in case.
move 5 and 1000 to variables. Its used in so many places
Right now it will never return false - in case votedMessage is not visible, this method will throw exception after reaching timeout. So please: - make sure to catch this exception and cast it appropriately to bool - decide whether you want to call it and expect false - in this case we probably don't want to wait 30 seconds (or whatever default timeout is)
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
static ?
ArrayList should be constructed with fixed capacity.
ArrayList should be constructed with fixed capacity.
Do we really need to check anything here? Surely the enterprise edition supports all constraints?
Should this be onReplicationPutRecord?
almost empty line, and any specific reason for initial capacity to be 0 here?
I see this method does something similar to execute minus the optional processing with the rowProcessor
....and then you don't need to call it on every other method
As far as I can tell, since this immutable set is always constructed via its builder and there are never additions, there should be no case in which the set will be inflated -> this line should not be executed. Maybe throw an illegal state exception instead?
Add a checkNotNull check here.
OperatingSystem.equals(String)?
This may be a reasonably common return value so error logging isn't appropriate. I think perhaps we should make this method return boolean (and return false if the update fails), and just do debug level logging here.
Map
You forgot this!
We can avoid creating a new HashMap on every call here.
You want to use assertEquals instead?
You may want to use assertEquals directly?
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
this mapping should happen via public enum and not via mapping backend enum to string
It's a step in the right direction, but it would be best to be uniform with the rest of the application. For full uniformity: 1) Maintain GlusterStatus.java enum in the API, and map Backend values to it. 2) Instead of status string, use the 'Status' object (I didn't mention this before) The easiest way is to follow an existing example. For example, see this from VmMapper: model.setStatus(StatusUtils.create(map(entity.getstatus(), null))); 1) Backend VM status is mapped to a rest-api status (an enum) 2) The enum is sent to StatusUtils.create() which creates a 'Status' object 3) The 'Status' object is set in the rest-api entity (and later the entity is returned) Note that this woule require changing in api.xsd, for GlusterBrick: <xs:element name="state" type="xs:string" minOccurs="0" maxOccurs="1"/> to: <xs:element name="state" type="Status" minOccurs="0" maxOccurs="1"/> And for uniformity, best also make this change to GlusterVolume state.
If you use .value() instead of .name(), you won't have to .toLowerCase() it later (same is true for all places below that use .name())
calling endAction here is dangerous, I don't think we have it anywhere else. it is problematic because the execute phase was not finished and there is all the infra in CommandBase that handles it. Please call endSuccessfully directly instead (and need to verify that the 'log' method is called)
I prefer a different approach that would comply better with the commands framework - not to disable the auditing here
don't we need compensation here in case the removal fails?
nodeID could be null
app = getApplication(appNameOrId) if (app == null) { app = getApplicationByName(appNameOrId) } To avoid calling getApplication and getApplicationByName twice.
Pretty minor but would you mind adding some parentheses around the arithmetic? :) Is it possible to have a divide by zero error?
Maybe move it to "buildIoTune" method, where the cache is actually used. That way when the method is called there is no chance of it falling on null cache.
that's always true
please rename to numOfScsiControllers
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
This looks like it will result in getPathInfo(..) executing and calculating the storage path of this storage path...I think we need to pass in the logical path here (the getPath() output).
I think line should be pulled into buildSupervisorInfo(). It appears that the intent is to create as many supervisorInfo records as there are Config.SUPERVISOR_NUMA_META entries with any leftover creating another SupervisorInfo(). And private buildSupervisorInfo() method is never called with validatedNumaMap of null. Each of these supervisorInfos creating a heartbeat-er.
Can we make this a list since it should be sorted.
I would expect the instance returned to be in under the IonList type hierarchy here. Otherwise if we are always to use a datagram then I would push this method up to BaseIonSequenceLiteTest and have it in one place instead of 2 places.
Or use a volatile long with AtomicLongFieldUpdater?
call it processHeartbeat, as it does more than a check
suggestion throw new IllegalStateException("Cannot get process ID. Not a UNIX system?", e);
nit: can we use a Executors.newSingleThreadScheduledExecutor() and .scheduleWithFixedDelay(...) instead? Feel free to ignore, not sure what's the idiomatic way to achieve this.
~1 minute & ~3 minutes respectively?
you can also test for number of attributes.
You're probably making this public for test purposes. Instead of making such methods public, we should be having the tests in the appropriate package so that we don't need to use the access modifiers inappropriately. I say inappropriately because this method shouldn't really be exposed to applications, it should not be public.
naming s
Meh: you could use rs::close instead of a lambda. They're semantically equivalent--I just like the way method handles look. Not critical for merge, obviously.. :)
Very minor, but our code style conventions are to have a space after if and before the (
Style issue: @Override shuld be on line above the method declaration
new ArrayList<>(causes);
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Should return the empty list, not null
Could move the validation of the coordinates to the LatLon object to make it reusable
How about using guava utilities here?
We are setting this unconditionally, not just for "FOR UPDATE" statements. Is it possible to restrict it?
> Sorry @javornikolov but I didn't understand what you would like to test. These are all the rows that exists in query 2 but not in query 1, so they all are marked as error (missing) and are chained to each one, and the first is chained to the last rows processed. > How can I help here? Sorry. I think I described it the other way around. I'm testing with following and I'm getting only 1 missing row, when 3 are missing:  !|Execute|create table TESTTBL (N int, TWON int)| !|Insert|TESTTBL| |N |TWON | |1 |2 | |2 |4 | |3 |6 | |4 |8 | |5 |10 | !|Store Query|select * from TESTTBL|q1| !|Store Query|select * from TESTTBL where n in (1, 2)|q2| !|Compare Stored Queries|q2|q1| |N |TWON?| !|Execute|drop table TESTTBL|
compare object instead of reference? Why don't we just always wrap it since it is cheap now?
Add the @ConstructorProperties annotation here and in all other domain objects, for consistency?
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
Can you cover this class with unit tests?
isConnected = false;
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
s/getValue/getId
Hmm, why did we do this? I thought we'd have a try/catch block.
StringUtils.toUtf8
Make method static.
"Cleaning all in memory locks"
Other places in this module handle buffer == null.
Could we add a check on the OS actually being Windows before looping like this?
Will * <LINK_0> * <LINK_1> work as well?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
you can either remove else or add pair of curly brackets
Per our discussion, we need to delete any removed custom data properties before saving the account and its custom data changes.
use {} for all if statements, even single-line ones.
This one is already done on line 816. Do we need it again here?
tracef
can be info
you need something like: recoveryXids = new Xid[1]; recoveryXids[0] = xid; in here. As this class is serializable it will be saved in the basic action during save_state. Don't forget to remove the Xid after commit is called.
nit: this definition looks really awkward
Hmm, this feels like premature optimization. The offsets map is more likely to be a problem. Also, I'm not sure we should restrict the usage. It is possible today to send offsets for multiple groups. Is there a good reason to restrict this even if it doesn't make sense in streams?
Why we want to return a clone of the groupMetadata? If we can declare all the fields as final, and whenever we update we always create a new ConsumerGroupMetadata object, then I think we can safely return the cached object directly.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
IWorkspaceRoot and IContainer both implement ISchedulingRule so odds are you can replace setRule(ResourcesPlugin.getWorkspace().getRuleFactory().createRule(ResourcesPlugin.getWorkspace().getRoot())); with setRule(ResourcesPlugin.getWorkspace().getRoot());
events.isEmpty()
Can we have a null check at this line?
Same, can remove the wrapper.
throws TaskException is part of the interface, did you mean to remove it?
It is not possible to change field after instance creation. Why you create unmodifiable map each time this method is called? I would prefer use it once.
@ILikeToNguyen Why the change in visibility here?
Let's make this private and introduce two factory methods known(String, UUID) and empty()
Make the map immutable with ImmutableMap.copyOf.
technically if leader == LeaderInformation.empty() and we still have time, then we should retry and see whether a leader will be elected later.
pattern should be constant, so as not to compile it every time.
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
This should stay final
Should all users be able to delete?
why change this?
Maybe write the record.getMatchingRecordReaderWriterId() here, just as it is read in Records#readRecord.
Could you change your code so that super.getHandler() is called only once?
This doesn't look thread-safe.
endHandler must be read in the synchronized block
Use the immutable value cache
Is the value also always the default value?
You can use this.key.
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
Is it possible to close this one and the ones below on the same method where it is created? To avoid further problems such as when adding new methods. I see some code paths also close it, e.g. YamlClientConfigBuilder#build and  YamlClientFailoverConfigBuilder#build but not YamlConfigBuilder#build
I would tend to make the first two Preconditions.checkState (they're not arguments to this function) and the latter two as is. Also, put the field name in the call (like Objects.requireNonNull(schema "schema");) in order to give some insight into the problem without looking at the source?
Assuming data can be null? Is there an annotation used by the project to mark such nullable parameters?
This is an API breaking change.
Is it better to initialize latch to CountDownLatch(0) instead of null? Also initialize it in line 45, when latch is declared?
Hm... Migration feed is where it probably does not make sense to have Archive URLs. Maybe we can make these methods no-op?
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
I think this method can be final with addition of extra "hook" (overridable) method to register handlers: public final void setEventBus(EventBus eventBus) { this.eventBus = eventBus; if (eventBus != null) { registerHandlers(); } else { unregisterHandlers(); } } /** * Override this method to register custom event handlers as necessary. */ protected void registerHandlers() { // No-op, override as necessary }
private, should only be called from the builder.
Do you want to rename the fields, too?
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
I'm not sure this is correct from a JPA perspective. JPA says that EntityTransaction is used to "serially ... begin and commit multiple transactions". It sure seems like JPA expects that the same EntityTransaction be returned each time that EntityManager#getTransaction is called: EntityTransaction t = manager().getTransaction(); assertSame( t, manager().getTransaction() ); assertFalse( t.isActive() ); t.begin(); assertSame( t, manager().getTransaction() ); assertTrue( t.isActive() ); t.commit(); assertSame( t, manager().getTransaction() ); assertFalse( t.isActive() ); manager().close(); assertSame( t, manager().getTransaction() ); assertFalse( t.isActive() ); As it stands we create a new EntityTransaction as soon the transaction is accessed after the commit. I'm not sure I can say that the spec requires this (^^) behavior though, and the TCK surely seems to not enforce it.
Is this needed? Looks like we are just assigning a constant to a local constant
Does the output stream need to be closed?
Should these go to logcat?
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
Presumably the method getAllGroupsSize in KeycloakUtil was written so that it could be used here?
Either hasNumberOfValues ? numberOfValues : 0 or add verify(hasNumberOfValues)
Why is it returning null? Shouldn't it be getting the configuration from the client?
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
Another place where the name should probably be updated
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
just for consistency, can we use final int?
Add PageLogging
nitpick; could be replaced with return maxY + (maxY % 2); if you want to get tricky ;)
rename to f
Here should also be org.apache.dubbo.xxx.UrlUtils
What happens to relative links? Protocol-relative URLs? Tests don't cover those.
Same here, make destroy() call disconnect() and move the code over. Otherwise, you're breaking things. Also, there's a missing space between ){. Please enable automatic code formatting in your commit dialog and fix the 3 occurrences in this PR.
Would it make sense to add something this.caches.clear() to the stop ?
When the view is closed you need to stop the build thread
we don't need to change the Creation classes.
Would it make sense to change this comparison to the relevant Duration method as well? Not sure how much it will provide us, but maybe it would prevent regressions later?
I think the granularity should be 1 seconds instead of 5 seconds here.
don't we want to remove the place holder in case of failure?
please also call the vdsNonOperational event (you can see how this is done in the virtMonitoringStrategy
this variable is not used, did you forget something?
I think you want to call the new method which gives servers based on glusterPeerStatus
should be private. Also, move it below the executeQueryCommand() - it's not the "public contract"
Please add here this(vds, null); and move rest of the code into 2nd constructor. Using this approach we can get rid of FindBugs error.
Spelling
Message could be better - reference currency: {} is not one the currencies in the FxIndex: {}
Could this be  return reportingCurrency.getCurrency().flatMap(function.naturalCurrency(target));
call notFound
Consider switching this to List<Object> instead of the unspecified List type.
Did you still want to put this off?
is there a reason why this method isn't implemented?
Shouldn't this be transactional?
Why would the old password be null in the first place, this seems like an invented scenario
Collections.singletonList
java.util.Collections.singletonList() should be prefered for singleton list. (always a better practice to rely on JDK classes rather than libs).
Better to use Collections.singletonList rather than guava for this.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
Missing opening "(" before getDescription().
Can we define a final CONSTANT for the MD5 ?
Can be static.
Same here, bubble up I think
Stream closing?
Error occurred while using SAXParserFactory to create a SAXParser.
Should be final.
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
This should return a builder with the current options set.
This method should be static and need not pass this as an argument to the constructor.
It is file, not url. how about "file cannot be null"? that would be a completed sentence
how about "stream cannot be null"? that would be a completed sentence
Minor, but we could avoid creating new timer_s here if we detect that we already have a non-null one? Or just delegate the responsibility of construction to the ChunkOutputFrame class, and make it a final member?
add this.endpoint.setBaseUri(baseUri) ?
can jsonAsString ever be null, seems like you create a PhoenixJson object you it will always have be from a string
The created JDBC URL does include the username and password from credentials. It seems this would be needed for authenticated database connections.
does this have to be a list or can it be an iterable?
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
new ArrayList<>(causes);
Why not just "else"? Also, please add a space between if and (. There should also be a space between { and else
We should return after lobCreator.setBlobAsBytes
The current implementation doesn't really make sense to me. Can I suggest something like this instead? java public void cellValue(ByteString newValue) { // Optimize unsplit cells by avoiding a copy if (nextValueIndex == -1) { this.value = ByteStringer.extract(newValue); nextValueIndex = newValue.size(); return; } Preconditions.checkState(nextValueIndex + newValue.size() <= value.length, "Cell value is larger than expected"); newValue.copyTo(this.value, this.nextValueIndex); nextValueIndex += newValue.size(); }
Let validate throw exception instead of throwing same ErrorCode for all validation failures
Move this to beginning of the method
Better way to do this using slf4j: <LINK_0>
add brackets to make this expression more easy to understand
can we store a single static instance of the DisabledIndicator and return everywhere?
Consider using i18n for "Loading Export Wizard".
better use a ? b : c here
we should only handle non-transient values, or?
You can replace this getArrayProperty().length check with a call to configurationService.hasProperty(). That's the recommended way to determine if a property exists in our configuration.
Could we please use <LINK_0> ?
cache keys should never be mutable
There is possible deadlock with the doChangeMasterKey method in order of locks acquire
Not an exception
This should really not be public.
do you need to check for negative values too
If you used try-with-resources, you would not need IOUtils at all:  try(ByteArrayInputStream input = new ByteArrayInputStream(data)) { ... }
Change collectionType to iterableType?
Mega minor: for both of these methods, consider just changing the flags that matter, InputType.TYPE_TEXT_VARIATION_PASSWORD and InputType.TYPE_TEXT_VARIATION_VISIBLE_PASS WORD, via bitmasking and getInputType().
As I suggested in another patch, we should consider having a version for persistAsyncTaskPlaceHolder with one argument (parentCommand) which by default uses a DEFAULT_TASK_KEY. Same goes for getTaskIdForTaskKey - we should have a "getTaskIdMethod". This is not mandatory, it's a suggestion.
please change to isEmpty
Use Guid.isNullOrEmpty
contains() would read more naturally here, is the performance gain here sufficient to justify not using it?
Maybe lets rename to REPOSITORY_INFO?
@Override public boolean equals(Object obj) { if (this == obj) { return true; } if (!(obj instanceof JobSubjectEntityId)) { return false; } JobSubjectEntityId other = (JobSubjectEntityId) obj; return Objects.equals(entityId, other.entityId) && Objects.equals(jobId, other.jobId); }
why? for debugging purposes? sure, but don't keep it in testsuite by default it just messes up with CI servers
This test uses the same jboss-all_fine.xml file as FineWebFailoverTestCase.java, what about using a new one for covering the reference to an existing server profile from a jboss-all.xml file? (at present we have it from distributable-web.xml file in testsuite/integration/clustering/src/test/java/org/jboss/as/test/clustering/cluster/web/persistence/distributable-web.xml)
why changing it to static?
How about returning the old MessageBufferOutput instance here?
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
this method should be changed to private
this method should be changed to private
Generics on the right side are redundant since Java7
might be useful to print it, no?
vmNames
just wondering, what force means here?
If the Deserializer is named, Deserializer. The Serializer should be call Serializer!
I don't think we use final for functions in our code base
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
propertiesPath = "etc/app.properties";  vs  private static final STRING APPLICATION_PROPERTIES = "etc/app.properties"; [...] propertiesPath = APPLICATION_PROPERTIES;
This shouldn't change and won't work if the default is left at ${basedir}/feature-pack-build.xml. It would essentially result in ${basedir}${basedir}/feature-pack-build.xml with the defaults.
are these setters used anywhere?
Please make the constructor private (see Invalid).
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
isn't there dupContext() method in CommandBase ?
please declare it in #163
I think this is wrong since this command is not set to be parent command of the internal commands above so their tasks should not be added here. can you please see if it is really necessary?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
set the true value in the field declaration.
I would recommend to use this(in, null). It would be less error-prone.
listeners are not notified?
The outside check is for listeners but passed transactionalListeners. Need to check for both and need to notify both.
Noticed txnIds is passed like List->Iter->NewList->Iter->NewList to several methods. This model have several copies. Instead, can we pass the same list (txnIds) all the way down to build openTxnMessage?
I would rather choose to have a while loop to implement this rather than a recursive call (call stack can grow quite big unecessarily because of this call depending on the level of nesting of the file) and moreover, I believe a while loop would be more readable.
style nit: remove curly brackets
Why not relying on streams? java return switchStatementTree.cases().stream() .map(CaseGroupTree::body) .allMatch(body -> hasSingleStatement(body, THROW_STATEMENT, RETURN_STATEMENT));
This seems unused.
shall we add some message here?
Can you make all of the accessors final?
this can be 'long' instead of 'Long'
The empty string in the constructor is redundant.
should we return a default here? anyway, like using the first sample offset?
You need to check that conceptUuid is not null and blank
you have the batch service already as a class attribute
Can't we use COMPONENT_NAME here?
Please use style instead of getStyle(), as this is more consistent with the rest of the code base. I.e.: if ((style & SWT.HORIZONTAL) != 0)
paranoia: can we first set it to false, and *after* that call GTK.gtk_widget_queue_draw(widget);
I don't get this: does the result of getInitialSize() change after the first invocation or why is it called twice?
And then else if this
I prefer use of Optional to null
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
![MAJOR](<LINK_1> 'Severity: MAJOR') Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_0>
Is it really necessary to set prototype scope for EVERY Provider ? I do believe it can kill some logic if some bean of Provider.class should have singleton scope (in custom code for example).
Why not to use the constant: Charsets.UTF_8 as on the line 111 above.
@ekondrashev Same here, let's declare Exception being thrown.
@ekondrashev Here too, let's use throws Exception as per our [coding standards](www.yegor256.com/2014/04/27/typical-mistakes-in-java-code.html#test-method-names).
@ekondrashev Let's declare throws Exception as per our [coding standards](www.yegor256.com/2014/04/27/typical-mistakes-in-java-code.html#test-method-names).
-1 since the interpreter is only used with JMX now.
This can be private again.
counterManager?
Does your custom inline parser not need to know about delimiterProcessors etc? I think the create method should get a InlineParserContext (similar to HtmlNodeRendererContext), that looks like this: java interface InlineParserContext { Map<Character, DelimiterProcessor> getDelimiterProcessors(); }  (The other two, specialCharacters and delimiterCharacters can be derived from the delimiter processors and are just an optimization, so don't need to be on the interface.)
What's this 4 bytes? Can we refer to a static field for it so it's more explanatory and gets updated if it changes?
Feels odd to be assigning empty char here given we know empty char will always return false in the subsequent check. Admittedly the alternatives would require more code but this is abit random IMO.
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
suggestion return super.isEntity() && isAssociation() || (super.isEntity() && isEntityInRelationshipWithProperties() && !isComposite());
Would it be possible for a key to be null? Do we need to add a check for that?
if (!selectedItemList.isEmpty()) { selectedItems = selectedItemList.stream().filter(o -> o instanceof Integer || o instanceof Long).map(o -> (Long) o).collect(Collectors.toList()); if (selectedItems.isEmpty()) { return null; } }
what do you need this 'if' for? There isn't supposed to be any indication in the model that the vm is in the system before the user starts importing and you're checking here in a loop for all VMs marked for import.
Can use OvirtSelectionModel#getSelectedObjects.
Why not public access?
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Maybe also this could be public and rest could be private?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
return getForecast() != null ? getForecast().toString() : "FORECAST IS NULL";
in this case I think return isRunning() ? this.ssl ? "https" : "http" : null; reads cleaner
It does not look to be a good public API. Why would you need it here? Could it be just moved to the storage?
It still needs some kind of fingerprint identifier in the message, e.g. just its ID/hash
add prefix to "About to invoke" message too
Should we add null check?
The code sets in to null to indicate close was called. This make all the code that's trying to sync on in go through a rigmarole. I think it may simplify the code if a boolean that tracks the closed state was introduced and in was never set to null. Then the code can always safely sync on in and check the closed boolean after syncing.
I would recommend to use this(in, null). It would be less error-prone.
there's formatting issues here
You should use ThreadContext.putAll() here.
minor, is it method scope for Visible For Testing? If not please change it to private.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
here we'll also have changed from ConfigException.BadValue to IllegalArgumentException I think; a toBytes that takes the origin/path could solve.
Missing bracets {}
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
analyzer should be extracted into a separate method
why public?
These APIs aren't great since the method has no effect when called after controls were constructed. We use that in other places as well but so it seems okay but it's better to either fail when this is called after control creation or dynamically update the UI.
The name of the method showRightView is kind of misleading in this case, because I would expect to set the details view in this case, because it is the most "right" view shown to the user. I would suggest to rename it to something else.
Since this List is a Java object, returning it directly allows the end user to modify it and that would effect this object directly. The way to handle this is to make a copy of the object with defensiveCopy before return it (like what getThumbnails does).
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Why is this throwing Exception? Should usually not throw anything.
why are the throws on the next line?
Maybe IOException since it's supported here?
for the case where the file is being thrown away (abort is called rather than commit) we could get away with not calling force. (that is the ATF.commit could call a force method which does a flush, force, and then subsequently call close)
Maybe just throw new UnsupportedOperationException()? Current message reminds me of ThisShouldNotHappenError :)
What do you think about removing all the "set" prefixes from the fluent API?
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
types --> type
This wouldn't take the precision into account so if the other method would return a fully qualified host name, this would always return that instead of a substring of it.
toLowerCase should be on both sides
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getComponentId"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getBaseComponentId"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
I would prefer to rename no_effect_... to should_not_fail_..., because it does not contain asserts. (or to add asserts, of course)
Yes, it shouldn't be cached in memory.
Is supporting unsplittable Firehoses future work?
please final
Version 3 I think ?
2? Besides this should be a constant, at the beginning of the class, not lost on line 152
Have you intentionally omitted index check?
what if quota object is set?
This should be Integer, not int to match the type on line 57. If this tries to return null an error will occur because int can't be null (but deleteByUserId can)
Same issue here, double delete user.
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
Can we change this to setValidator() given that Jwt is implied with the generic
One more thing, if we consider the part between the [] to be the event name (that an eventual UST-JUL-TC parser could eventually even interpret as the event name (and same thing with fields, everything separated by '=' could be assigned to a fieldname+value)) then we should use a consistent naming pattern. UST events usually use names_with_underscores, but that's very C-ish. Since we're in Java, should we use CapitalziedCamelCase for event names?
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
I think a good old for loop is more readable for (int i = 0; i < size; i++) less concise but easier to understand (to me at least)
Does it have to be public? Couldn't it be package visible only?
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
Same as tapSource != null
isTrue()
Don't we want to keep this?
@vilchik-elena Shouldn't we also test tree.element()?
We're still violating encapsulation principles here. We don't want to modify the collection and assume that's going to be retained. We should be building up the content and then throwing a new collection at the DTO, or figuring out a way to return the addContent method back to the OpenAPI DTOs.
Should be originalContent.
Please make this constructor private to force users to use the builder, thus forcing the validations
lets cache interruptor instance. If JIT leaves double de-reference inside the loop - its bad
why using StringUtils, while we can use String.startWith()? Manifests.read() never returns null
we have more naughty places that trigger branch issues, but we should stop their proliferation
Users get very scared of WARNING messages, especially vague ones. Consider adding whether things will continue on or not and removing the first sentence.
Your suggestion sounds good: "An operation was reported to be complete multiple times. It's likely due to a communication glitch and a retry."
if we don't need "operationId" outside of try{}, move both "long operationId;" and "mutationsToBeSent.add(new MutationOperation(mutation, operationId));" into try {}?
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
THREAD-SAFETY This is a poor construct to use for a thread-safe class. It doesn't save (that much) memory, and can be solved by using a volatile boolean set to false as a default value instead.
What about items and label?
you didn't use methodName here, is it intended?
I think you need to add a null check; code in SourceFile assumes content can be null
I'd make this return long and rename to getTotalPendingBytes so we don't have to keep going back and forth.
To make the tests more resilient to future changes, please pick values that are unlikely to ever be the actual defaults. For example 234MB and 11MB.
Based on how it's used, it's more like a listener not callback.
Be careful of nullable fields!
Be careful of nullable fields!
It's better if you could make a function like getStringWithFormFieldId(String formFiledId). You could call the function getStringWithFormFieldId("clientID"); getStringWithFormFieldId(clientSecret);, ....
Wouldn't it be better to redirect the user to wondergem root in this case? I seems to me that this triggers a user being logged out instantly.
Should we call that method getUserStoreNames() instead?
In this use case there are some improvements to realize: - An UseCase should not invoke to PreferencesState.getInstance().setUserAccept - UserAccept is a concept of the user then we should be in UserAccount and in database - The logic to set UserAccept to false should be inside UserAccount entity because is a Bussiness Rule logic and the values to decide are inside UserAccount and we should create a unit test to validate the logic - An UseCase should not execute the repository first with LocalFirst and then with NetworkFirst - UserFilter should be passed from outside to UseCase
Shouldn't this just return true? I thought force meant unconditionally use RESTbase.
Adding this to a field is good manner.
This whole method should just call getSecretWithResponse(secretBase).flatMap(FluxUtil::toMono). Try to leave the duplication to a minimum.
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
unnecessary null check
A couple notes on this: * Compare the repeat count to TimingWindow.REPEAT_FOREVER instead of directly -1 so that it is clearer what is going on * If the duration == TimingWindow.WINDOW_REMAINS_OPEN_FOREVER (which is just -1), then there will also be no end
This is better way to fix SwipeRefreshLayout issue.  private View getScrollTarget(View target) { return mScrollTargetCallback != null ? mScrollTargetCallback.callback(target) : getSupportedScrollTarget(target); } private View getSupportedScrollTarget(View target) { if (target instanceof SwipeRefreshLayout && ((SwipeRefreshLayout) target).getChildCount() > 0) { SwipeRefreshLayout parent = (SwipeRefreshLayout) target; View child; int n = parent.getChildCount(); for (int i = 0; i < n; i++) { child = parent.getChildAt(i); if (child instanceof NestedScrollView || child instanceof RecyclerView) { return child; } } return ((SwipeRefreshLayout) target).getChildAt(0); } return target; }
This this. should no longer be necessary here - could you please remove it?
I think it worth adding a field on the template to indicate it is sealed
I really never understood why these aren't Math.min'd
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
you could use the executors service's InvokeAll method instead? It clean up some of this code: <LINK_0>
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
Is it intended to not compare the size of the stack here? (FluidStack doesn't take size into account normally for equals, though it does for hashCode)
once again, equals/hashcode - does it make sense? please revisit in all value types you created
mobile tests will be executed on chrome, so please use scrollAndClick()
editMode is used once, please use this: > new ArticlePageObject() > .open(articleName) > .navigateToArticleEditPage() > .mobilePreviewArticle();
you can create article name in new line to increase readability so:  java String timestamp = base.getTimestamp + prefix base.navigate...
Shouldn't we return "super.getCell()" here?
Please add the /** {@inheritDoc} */ for this method as well or delete it from the one below.
For objects we provide human readable NullPointerExceptions. Please add a  java Objects.requireNonNull(clazz, "clazz is null");
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
getLastSibling == parent.getLastChild(), no reason for new method here.
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
ofNullable maybe, no?
the ofNullable makes no sense because you called profile.getId() on it at the beginning of the method: if it was null we wouldn't have arrived here in the code. The profile parameter is meant to be non-null.
Looks like the above block is repeated. Could we extract this bit out?
again - encapsulation
I think we should use leftOperandList.containsOnlyConstantAndParamNodes() here just to be consistent with the right.
Nit: this.verify to be consistent with other accessors
The error message doesn't match the actual behaviour.
Less error prone to iterate over values().
Please, try to omit changing files only for formatting.
Could we get a deadlock now in some cases? #reset holds a lock for the outer ProxyWhitelist, and when this is called it will also acquire the lock for the delegate ProxyWhitelist. Do we know that the locks will always be acquired in the same order? I would be surprised if there are cyclic references between instances of ProxyWhitelist, so my guess is that it should be fine, but it would be good for someone to confirm.
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
I don't get why you had to change this test case. The behavior of how we are handling fields should not have changed with your changes. Moreover, class Random is not imported, so it's an unknown method call, which changes the meaning of the test.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Seems no other callers, make it private? In that case, no need to make it unmodifiableMap
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Same here for doing empty check instead of non null check.
Super minor but no conditional needed here since properties is either null or non-null.
Can be simplified using Hamcrest.
does setBrickPosition do something different than brickPosition in all other brick tests? if not, please rename to brickPosition
position is not necessary, just add them in the order you want to have them there: startScript.addBrick(new SetVariableBrick()); startScript.addBrick(new AddItemToUserListBrick());
please no abbreviations in variable names. give it some meaningful name
Perhaps it doesn't mean that rows are really identical to each other, but only that they have the same place in sorting order or I'm missing something? If this method will be used wider someday this may lead to usage of old values with NUMERIC, VARCHAR_IGNORECASE, TIMESTAMP WITH TIME ZONE, or may be some other data type that has distinct values with compareTo( ) == 0.
> Sorry @javornikolov but I didn't understand what you would like to test. These are all the rows that exists in query 2 but not in query 1, so they all are marked as error (missing) and are chained to each one, and the first is chained to the last rows processed. > How can I help here? Sorry. I think I described it the other way around. I'm testing with following and I'm getting only 1 missing row, when 3 are missing:  !|Execute|create table TESTTBL (N int, TWON int)| !|Insert|TESTTBL| |N |TWON | |1 |2 | |2 |4 | |3 |6 | |4 |8 | |5 |10 | !|Store Query|select * from TESTTBL|q1| !|Store Query|select * from TESTTBL where n in (1, 2)|q2| !|Compare Stored Queries|q2|q1| |N |TWON?| !|Execute|drop table TESTTBL|
Since this is not really activity related, I think we should have this in the ViewModel. We shouldn't really need to clear the adapter and manually handle the empty view. This creates an inconsistency between the view and view model. If the search will go through, we should remove the current data in the view model and post an update and let the observer pattern do its thing. I've already made a suggestion about how to handle the empty view previously. There is an example of this which starts [here](<LINK_0>
lambda?
Should be "Activity" since it's embedded in the task editor so it should be clear that it's task related activity.
this should return parent2
I have some concerns about this. 1. Wouldn't this make crashlytics run in debug mode as well? The old Crashlytics didn't "ignore" things in debug, but we definitely don't want them reported. That was why it was in the if...else in LoggerStarter. 2. The reason for crash logging to be initialized in LoggerStarter is b/c if the content provider is accessed through a Context which is not ours (like if we export our data), then our Application does not get launched so crashes would not get reported to us. LoggerStarter is initialized in the content provider, which circumvents this limitation. 3. Does this create a Twitter singleton that we keep around for the lifetime of our app? If so, that seems like a waste of memory since we only use it for the login stuff and even then only for vendors who actually use twitter.
If in debug mode, can we throw an exception? That would be a good test case for manual QA.
why is this necessary here?
Check if inputStream is null.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
This creates a copy of the data, which means we are copying the data twice. Since this code is part of the inner loop of IndexPack I would like to avoid that copying by properly allocating the output buffer and writing into it directly. That might mean a variant of ByteArrayOutputStream has to be written and put into jgit.util.io.
To be consistent with the rest of the Essentials codebase, I suggest reverting this back to not using a fully qualified package name.
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
You can do something similar to what I did for the [Give command](<LINK_0> (in order to keep the same behavior as vanilla)
Might this be clearer as: java if (capability.equals(CAPABILITY_OFFHEAP) && isSubscriptionBasedLicense()) { return capabilityLimitMap.getOrDefault(capability, UNLIMITED_STORAGE_AMT_IN_MB); } else { return capabilityLimitMap.get(capability); }  This captures the logic of subscription licenses having unlimited offheap by default quite succinctly I think.
you don't need the check for null here
As there is only one element, we don't need to use an object array.
Should this be marked as deprecated as it is in Page?
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
Same question about returning a null instead of an empty collection type.
SINGLE_THREAD_FOR_AUTOBATCHER?
let's make a meaningful constant for 5
one small caveat here, this method is called by AwaitingLeadershipProxyso this will not get logged until we are the leader - might want to move this into createTimeLockServicesWithAsync
Can this be within the if statement above?
Maybe a static utility to see if we can do an (unsafe) cast to SamplerConfigurationImpl to avoid an unnecessary object creation?
I think row sampler could be removed and the checks could be made stronger like the following. java SamplerConfiguration sha1SamplerConfig = new SamplerConfiguration("com.mysampler"); sha1SamplerConfig.setOptions(options); NewTableConfiguration ntcSample2 = new NewTableConfiguration().enableSampling(sha1SamplerConfig); assertEquals("com.mysampler", ntcSample2.getProperties().get("table.sampler")); assertEquals("5", ntcSample2.getProperties().get("table.sampler.opt.modulus")); assertEquals("murmur3_32", ntcSample2.getProperties().get("table.sampler.opt.hasher"));
This is unnecessary
Largemessage can be concurrent accessed and used. In case of topic with multiple queues. Remember how we had to fix loads of concurrent access issue on core message the other year
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
Why result size is not checked here?
Let's merge both validation with message "Invalid job results. Expected exactly 1 result, but was " + results
Should there be anything in the catch block?
"Cleaning all in memory locks"
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
the ConnectorTopology.NONE is one of the supported connectors of the this component. So i don't understand this filter here.
This doesn't look right.
NotAliveException, AuthorizationException can be removed
this
UnsupportedOperationException would be better
Why we want to return a clone of the groupMetadata? If we can declare all the fields as final, and whenever we update we always create a new ConsumerGroupMetadata object, then I think we can safely return the cached object directly.
Why is this necessary?
the problem is that the setConversionMap() call is associated with the factory. What does that mean when new MockStoreKeyConverter instances are created?
super(); not needed
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
please validate ledger id
I would suggest we add putAllAsync in IMap interface, wdyt?
Maybe we should cache the BluetoothManager in onCreate instead of the BluetoothAdapter. Or both.
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
shouldnt this method be static?
It probably makes sense to set up a timer to get some metrics about the download times. Similar to: <LINK_0>
Nit: would you like to say "flow pause requested by user"? It's not given that it will be paused at this point, right?
Checkstyle violation:  [ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-integration/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpSession.java:157: 'if' construct must use '{}'s. [NeedBraces]  You can verify yourself locally using gradlew clean :spring-integration-ftp:check
this lambda will alway return true if at least one representation is present in the resource. That is also the case in aird resource. we should get the first element in getContents() and next check that is element is instance of DRepresentation
From an API standpoint, shouldn't the lookup method have throws IllegalArgumentException? I am not quite sure how this works with the Java 8 constructs you are using here?
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
copy/paste
Are the last two lines of this test necessary? Let's go ahead and remove any unnecessary lines of code.
This could be private to prevent instantiation. If sketch classes are loaded statically, it can be probably be empty.
this constructor feels wrong now... I think it should be a Module and a Definition and then the constructor calls getCombinedGrammar.
Explain.
Maybe a bit smarter: java if (!isStringNotEmpty(context.getSuite().getParentModule())) { return null; } ...
I know the method is invoked only from 'plugToExternalNetwork', but to make it complete I would check 'getNetwork' is not 'null' and 'is external'.
if getExternalNetwork() returns null, you'll end up with NPE.
Consider inlineing this. Most of the users are in test code and it *might* be nicer to force callers to decide on the lifecycle explicitly
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
return is unneeded
No need for getInstance(), the container can be passed
@Nullable
Can we make this configurable?
throw new RuntimeException("Node removal failure: there is no '"+nodeUri+"' in the render graph!");
Rather than chained if-else-ifI would prefer to have a switch: java switch(node.getType()) { case PythonGrammar.CALL_EXPR: checkQuestionableHashingAlgorithm(node); break; case /*...*/ : // ... break; default: // do nothing - reacting on all the registered nodes }
@ivandalbosco super minor: no space before !isDocStringsAndNotImplementedError(node)
Can use EntityPredicates.attributeEqualTo(Startable.SERVICE_UP, true) Note that will also avoid the strange NPE that you might hit if there is a router with SERVICE_UP attribute still equal to null.
Remove the toString or give it a more descriptive result?
Whats the lightblue project standard on tabs v space? On most of esb we do 4 spaces for a tab almost everywhere. I dont care what it is as long as its consistent within a project. One standard across everything would be great, but ill settle.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
no qualifier?
It is permitted, but discouraged as a matter of style, to redundantly specify the public and/or abstract modifier for a method declared in an interface.  <LINK_0>
Check for the existence of the file to delete?
The error message should be more detailed. How about The supervisor task[taskId] didn't create any sub tasks. Was it executed in the parallel mode?
clause?
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
break the line
given that specificity of this SV is exception type I would add the exceptionType in this.
code format
please use org.apache.commons.lang.StringUtils IsBlank()
@adietish we should consider throwing here/providing an indication that the path doesnt exist. If the path doesnt exist for a given property then it needs to be added to the map IMO.
Should maybe other countries be added here?
style nit: we don't use curly braces around single line statements
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
Application context isn't required, we should be giving it the fragment's.
dispatchDepth > 0 ? dataLoader.dispatch() : completedFuture(emptyList()) You dont need this. dataLoader.dispatch() does nothing and returns an empty list if there is nothing to do So just return new DispatchedBatchLoader<>(key, dispatchDepth,dataLoader.dispatch());
nitpick: don't need keyword public
Use .substring(1) so that we don't have to allocate a new String instance.
not sure, but just thinking should isContentResponseOnWriteEnabled add here?
Why not initialize them at construction time instead of lazily on request?
List<Throwable> list = new ArrayList<>();
style nit: remove curly brackets
I know this is not from you, but can you change to use arrayList, there is no good usage of linked list.
The core version doesn't actually process capabilities, but I can't think of a reason it shouldn't. A JIRA should probably be filed to enable it. Also we should process the attributes too.
This should be PathAddress address = context.getCurrentAddress(); The result is the same but ^^^ is more efficient and is the preferred idiom because it's simpler.
This should not be a lambda.
Is this correct? Based on the definition of the special day entries in the DLMS Blue Book I would expect a long-unsigned value (newUInteger16Data).
These errors here should be sent to the logger (<LINK_0> so they are easy to find and filter
Change log level to debug
Please close the stream in finally block.
Please have a default value (unknown-development?)
Please use a instance-variable for the version, this way we can configure it for each service instance separately. Also extend the service-descritor to support the version-field (and add a default-value)
@Happy-Neko Same here, let's throw IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
Consider using something like this: fail("expected ApiException");
The expected file path here is very long and contains generated making it difficult to realise what the file is. Generally we want to have such files in the resources folder so generateFilePath can be something like "/resources/generatedCodeForTest" + generatedTestTableName.
Which operating system are you using to run these tests?
Move String values used more then once to a constant.
Move String values used more then once to a constant.
Use a constant for this path.
Label should be reporting.parameter.onOrAfter
The labels for these date parameters are wrong. They should reflect the parameter names (eg. reporting.parameter.startedOnOrAfter"
This location parameter should be renamed as in other methods I think
nit: you could also move all the setUpServerChannel() calls
why does this test need to change ?
why does this test need to change ?
Use subtract to implement intersect?
Actually the underlying objectExpr could have free variables.
Can we have this return Set :)
Map
Use entrySet()
You forgot this!
false is the default so you don't have to set it explictly
The parameters may be modified by the command. So, if you need to pass parameters to a subcommand, you need to copy them.
detach?
please use NotImplementedException()
please use NotImplementedException()
please use NotImplementedException()
suggestion assertThat(got).contains("Description");
Should the 3 contains be replaced by isEqualTo ?
Please use the correct "assert" versions. To check for equality, "assertEquals"
All these are going to be invokes every minute. These may be expensive for a cluster that has many resources.
suggestion assertNull(r.jenkins.getNode("foo"));  since it is not otherwise obvious that the node's name did not change somewhere in here.
suggestion assertNotNull(r.jenkins.getNode("foo"));
HashMap should be good here I think.
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
use getOrDefault()
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Need to add an overload which also takes keyOps
nit: Will be useful to add a log line before Line 77 to indicate that the shutdown has been invoked on this scheduler instance.
see in Volt how to properly shutdown an executor service
you're right, not sure how I missed that thanks!
'em.persist(member);' should be enough, you only need to wrap the EntityManager when needing to access methods which are not exposed on the JPA API.
Shouldn't this already be set?
any reason to change this? Not sure what /:denied does compared to :/denied
I also can't understand it, but now result is always empty. will try to debug it.
maybe this should no longer be named pliList
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
can be private? or at least package protected access?
This goes below next method :)
This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance (to clarify see the surrounding diff since this preview gets confused)
Apply SLAP principle here: extract this block to a private method, no matter how simple it is.
studentsWhoRespond -> studentsWhoResponded
Why the indentation is odd here?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Use the solution in the large Overall/Manage PR instead, please.
Better revert.
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
Assert.notNull()
can be omitted
checkNotNull(source, "source") Qualify with this..
Since we are improving this code anyway, I think we should switch to using [StringUtils.containsIngoreCase](<LINK_0>, java.lang.String%29) instead of toLowerCase+contains, since lowercasing a string is not always the same for non-ascii characters.
rename to segment
I believe val here will always be either a non-empty string or null, but never empty string, since Indexed<String> returned by getDimValueLookup, which is either an Indexed<String> based on a NullValueConverterDimDim or or a GenericIndexed<String> will already map empty to null.
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
If you check for Collection wouldn't it be better to work on the collection interface (and perhaps create a new list) instead of rely that the collection will always be a list on this place (if it is the case, then use instanceof List.
Use Iterators.transform from Guava?
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
Let's rewrite it with the regular F.iterator F.iterator(dataSupplier.apply(filter), rowFunc::apply, true);?
10 is a magic number here, please extract it into a TIMEOUT constant
To be consistent I would remove the "this." in front of bridgeHandler (it is also missed in the if clause already).
getHueBridgeHandler() could potentially return null, couldn't it?
Doesn't this also trigger on Byte, Short and Long rather than Integer?
Redundant qualifier.
Why not in combination with above do this: setValue(value, false);
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
Is there any reason to do that here rather than encapsulate the logic in the constructor of NewExternalSubnetModel? Especially when as far as I can see, it has to be called whenever the dialog is instantiated.
There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.
Assert.notNull() ?
this.m_
The generic type information is lost at runtime and the XML only declared TemplateRegistry, I am not sure if this is always correct
You are creating new list each time, why not just forEach(resourceResolversInTryWithResources ::add) instead of collect(Collectors.toList());
What's the reason behind referring to an implementation type here and casting?
No need to call stream() here.
Not sure this is right unless it's only supposed to work on *nix.
Re-use temp file
why change the readability status here?
You don't need to make a variable here since you're not using it again. You could just do <code>new PhoneNumber("21234567890").getNumber()</code> :)
This looks wrong, it needs to be a core version, not a plugin version, right? I think it should be replaced with new VersionNumber(p.requiredCore).
In general, we want to do single responsibility design. So every module, class, and API (like this one) is only responsible for 1 thing. This makes the code clean, compact, and easy to understand. By having checkGroupBalance() fire within this method that seemingly only calculates a string given its name, this almost feels like a side effect and violates single responsibility design. I feel like we should fire this in the onAfterTextChanged() block for each of the EditTexts. It will lead to redundant calls, but this operation is cheap and code readability is more important.
Looks like the ListRejectAttributeChecker could be used here instead.
That does not seem correct, the version chain goes from the oldest to the newest ("current version excluded"). It should be:  chainedBuilder.buildAndRegister(registration, new ModelVersion[]{ VERSION_2_0, VERSION_3_0 });
Something feels off here. AIUI we've actually had a "3.0" (imagine some air quotes) since WF 19, and it looks like we've had a proper 2.0 since some time in 2017. And now you're officially creating a proper 3.0. We need transformation for hosts using 1.0 no matter what. We need the missing 3.0 -> 2.0 transformation unless the admin disabled it. If the admin disabled 3.0 -> 2.0 with the system property, then we must do 3.0 -> 1.0. Maybe rename registerTransformers_2_0_0 to registerTransformersFrom_3_0_0 and then make sure it's invoked no matter what. What differs is the target version provided to chainedBuilder.createBuilder. BTW I think names like registerTransformersFrom_3_0_0 are better in general. When I review these classes I usually waste time trying to figure out what these version # in these methods represents -- source or target.
I think we should have the same condition as we have in getMergedCellsCount: java cell.getMergedCellCount() == 0 && currentIndex >= 0
please put sensible error messages every you use a Preconditions function.
I think this condition makes sense. Can you update the code to match the surrounding formatting (hard tabs, and use braces)?
Are there any const that can be used instead of duplicating strings like this?
Move to update please. < layout
linebreak style is inconsistent here
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
This is unsafe, since attributeType is protected and can be set to null, but the contract is to return supplier only on non null values. This must be rewritten to check for the null value first.
You need to change content of this method too (while changing the name).
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
{ }
I don't really see a need for constructing a File object with the path to an URL here, just split it yourself
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
return workflowExecutors.getWorkflowExecutors().stream().map(executor -> converter.convert(executor)).collect(toList());
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
This needs to use justOrEmpty as the response value can be null which is an illegal value in a Reactor stream.
Shouldn't the key() and value() method also be renamed? Same in async client too.  return setSetting(new ConfigurationSetting().setKey(key).setValue(value), Context.NONE).getValue();
Where is the the RuntimeException being thrown from? I'm surprised that the withContext( ) or underlying RestProxy isn't bubbling this to downstream.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
I think this code should be moved into ehcacheStateService.destroyServerStore(name); It would be better to have all the code within the same class and classloader
Maybe check for if name ends with ':' so we don't do a double one?
You should use the annotations field here too, not the wrapped reference.
suggestion private <A extends Annotation> Optional<A> getAnnotation(Class<A> annotationClass) {  Avoids the "suspicious call" warning on annotations.get.
Did not try this myself, but I believe you should use Equal.equal(a1 -> a2 -> a1.equals(a2)); to take advantage of the type inference. This applies in lots of case below where the type parameter gets more complex.
Please log the bundle ID here.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
shouldn't we log something here?
Same here, would be better to leave it on the previous line
I think there's a method in Runnables that returns a do nothing runnable
I'd increment a counter and assert its 1.
Should this return Flux.error instead of throwing?
I think try with resources should be used.
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
Why can't you just return value here?
@dalifreire is this enough? What e.g about class name?
firstDigitsCardNumber is already a String
they both disposing the same trace. Keep the second call
this seems like it's going to be incredibly verbose. Can we nix tihs?
technically, you should null check here
Are result and errorMessage not applicable for workflows?
shall we add some message here?
Can you make all of the accessors final?
something is wong with the indentation, please fix.
Does this also require a null check similar to setcontentType() ?
I think this should be protected, not package access.
Do we need to delete task mode mapping wherever this is being called? In general, would it make sense to get/put/delete them together as a complex value?
Also, when you do that, you'll be able to return directly from the try block, reducing the size of the method by nearly a third.
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
output.append("STATE").append(currentState.toString()).toString?
@vkdrn Thanks for contributing!! Would you mind to add all attributes in toString method too?
Re-entrancy is probably not important for this class, but fInput could be modified while this method is running, which could give weird results. An easy fix would be to use getInput() here instead of 'fInput'.
You could do the same thing by doing @Test(expected = BluefloodServiceStarterException.class) I would say checking for exit code equals -1 is not that important to do.
Can use @Test(expected = ...), see above.
We can simplify this test method this way:  @Test public void testRollupModeEnabledShouldNotFail() throws Exception { Configuration config = Configuration.getInstance(); config.setProperty(CoreConfig.ROLLUP_MODE, "true"); String[] args = new String[0]; BluefloodServiceStarter.main(args); }
This should be delegated to the DAnalysisSessionService. As it is, there is a risk of inconsistent behavior: DAnalysisSelector sel1 = ...; DAnalysisSelector sel2 = ...; session.setAnalysisSelector(sel1); assertSame(sel1, session.getAnalysisSelector()); assertSame(sel1, session.getServices().getAnalysisSelector()); assertSame(session.getAnalysisSelector(), session.getServices().getAnalysisSelector()); session.getServices().setAnalysisSelector(sel2); assertSame(sel2, session.getAnalysisSelector()); // FAIL assertSame(sel1, session.getServices().getAnalysisSelector()); // PASS assertSame(session.getAnalysisSelector(), session.getServices().getAnalysisSelector()); // FAIL
This is being cast to DimensionSelector at call sites, so you might as well cast it here and change the return type back to DimensionSelector. Generifying it isn't buying us anything if all the call sites cast anyway.
Could be Framework.getService(LibrarySelector.class);
Should those hashcodes be hardcoded ? They depend on HashCodeBuilder.toHashCode() implementation.
Only test it is a new instance. Maybe it should test other rules of clone contract ? Maybe assertTrue(jdbcRuntimeInfo.equals(clone)) ? <LINK_0>
use ShellIsAvailable
I am not following here - why do we want this in sync block?
You shouldn't be modifying EventRefs in place even the model allows for it. We want our models to be immutable and someone could change content.events() to return a copy of the internal collection. Instead get the events collection, modify it and set the value back in Content
why do we need this new method?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
Please encapsulate the impl. details into RecentHistory class, as we discussed vocally.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
Can you please add a WARN log stating an attempt to stop the driver when it was null.
http2Client.map(stopClient)
Add a proper log message.
Better to organise this in a double empty try-with-resources idiom: java try (Closeable ignore = level1; Closeable ignore2 = level2) { // Just for closing }  To delegate boilerplate exception and suppression handling to the Java construct. If it appears unnatural, you could extract this in a utility method, e. g. called  void closeBoth(Closeable, Closeable) throws IOException
Remember to revert this file, it should know about the transport class.
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
not 100% sure, but this breaks binary compatibility, right?
Hi @hijklmno. This looks good overall. What was your reason for not setting this.accountNumber to stringOrNull(accountNumber)?
In general, we want to do single responsibility design. So every module, class, and API (like this one) is only responsible for 1 thing. This makes the code clean, compact, and easy to understand. By having checkGroupBalance() fire within this method that seemingly only calculates a string given its name, this almost feels like a side effect and violates single responsibility design. I feel like we should fire this in the onAfterTextChanged() block for each of the EditTexts. It will lead to redundant calls, but this operation is cheap and code readability is more important.
Might be worth having a displayName?
Make it localizable?
Nice2have: make it localizable
Even if core.worktree wasn't set in the configuration file, it might have been set by the caller of Repository. We have like 8 forms of our constructor that takes various arguments... one of those is the work tree path, which could have come from an environment variable.
With all of the logic in the constructor, I wonder if we can simplify this method down to: public boolean isBare() { return workDir == null; }
This should be 10 << 20 so that the default is 10 MiB. That allows users to specify configuration with standard suffix units e.g.: [merge] inCoreLimit = 10m for a 10 MiB limit.
For loop?
nit: what about java nulls[i] = i % 7 == 0  ?
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
Should we also have the same tests for the email template?
Don't you need to add the Hibernate-managed StudyType before saving?
Instead of running select and update, create an update query to update all sites with one query. See the jdbc query for example.
Now in addition to clearing indexes, we do this:  clearMapStore(); clearLockStore(); clearIndexedData(true);  Here we clear the lock store even though it might not yet have been collected by the LockService. I'm not sure if this is ok.
just partitionToStore.get() should return null if the element is not present.
All other Store.Provider do some level of accounting - same should be done here.
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
This can be replaced by Logger.debug(this, () -> String.format("listing languages %s", request.getRequestURI())); Using the supplier avoids the string creation when the logger is not in debug mode
I think field can be declared final
Consider adding a BusyIndicatorView for this call.
Good to add a null check since it's required.
Is the deployProcess() method doing something? if not we should start getting rid of dead code.
We need to get out of the habit of returning null when bad things happen. It's a SUPER bad practice. ANd it leads to exactly this kind of defensive null checking that clutters up code is distracting.
We should not catch generic Exceptions. Can you make this more specific?
Wouldn't have been possible to override the afterFromProto in the ForwardNatRule class, adding there any initialization code as needed?
After thread sleep, I think need to continue the loop. Otherwise, consume messages from the consumer. Code snippet for if condition be as follows: if (wrapper.waitForReplay) { Thread.sleep(100); continue; }
Should you use the old logic: 'message.getOffset() != lastSeenOffset +1' here?
Still getting the compile error in Eclipse and code is still littered with type warnings.
Add reasonable toString() method, returning null doesn't seem as proper way.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
return Status.BACKUP_FINISHED.equals(status) || Status.RESTORE_FINISHED.equals(status);
Could use a switch statement rather than a series of ifs here.
probably this is an exceptional situation
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
No key for encryption? ;-)
please throw UnsupportedOperationException isntead
You could probably use the same URL as in getResultById here.
This can be a stream - filter - collect expression.
remove exists variable and just return !tuples.isEmpty();
Strictly saying, this should be new ArrayList<>(count);
I don't think sleeping makes much sense here, either return immediately or throw an UnsupportedOperationException.
suggestion new HashMap<>(Map.of(unit, transportToLoad)));  Pretty sure that works
No, this one was correct... We want to convert the internal delay (expressed in milliseconds) to whatever unit the client asked.
use ShellIsAvailable
use ShellIsAvailable(this)
use ShellIsAvailable
throws
nit: throws for consistency and clarity.
how about throw QueueFile.<Error>getSneakyThrowable(e);? then we don't need the unreachable return statement.
Maybe we should use ordinal and values()[offset] instead of writing the entire name? And actually do you find the Externalizer for enums, are they worth it still?
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
output.writeObject(collection.iterator().next());
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
This.
This.
URL Encode
![MAJOR](<LINK_0> Define and throw a dedicated exception instead of using a generic one. [![rule](<LINK_2>](<LINK_1>
Is this a method to be used in production? Or is it more for developing/debugging purposes? If the latter, we could create the webrequestMap HashMap within this method instead making it a field in the object. It would be slower for tests because we'd have to recreate it with every print, but would be a lot lighter for production (I guess the heap and garbage collector would feel it, given that we create a WebrequestData object for each web request). Also, it's likely that for each webrequest we do only 1 print, right? In that case, speed would be the same. Also, being annoying :P, I agree that we do not need the {"webrequest": <json>} wrapper, just the json object will be fine, no?
The concern with this change is that it would be a breaking change for anyone currently relying upon the existing behavior. What is your use case?
This error msg (and similar for times and minus) seem to have copy paste artifacts.
@solemabrothers What will you do for values which have decimal points in some indicators
you could use a newly added utility to get the color based on the state color to avoid "white on yellow": Color stateColor = gc.getBackground(); gc.setForeground(Utils.getDistinctColor(stateColor.getRGB()));
OPAQUE
Original code does not have these increased bounds? also, spaces
I find it more readable as: if (vmCustomCompatibilityVersion != null) { return vmCustomCompatibilityVersion; } if (vdsGroupCompatibilityVersion != null) { return vdsGroupCompatibilityVersion; } return defaultVersion; please consider
Please check if this method really should be public in a private static final class. The parent method is protected.
Here group.getSelectedVersionGroup() is not checked for null, though in other cases the check is used.
can you simply call onEditorOpened()?
Use config.getBinder().withDefaultDomain(domain) ... Maybe the ConfigBinder ctors should be package private ... :)
be careful - this will not work after logout-login cycle as the models are re-created but the presenters are singletons, so this presenter would still listen to the old model. You need to listen to UiCommonInitEvent and do it in it. Look for example at SubTabVirtualMachineGeneralPresenter.
change to List
Default size not necessary.
This empty check can be removed if you add one element to values in the constructor.
Why is it public?
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
I would prefer to use System.nanoTime() for such time, as it is independent of the system time and cannot be corrupted by time changes.
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
Above I had asked about whether we need to validate at least one answer is provided. Could we better describe this use case where we can search licenses *without* giving any answers? Is this to lookup the types of answers allowed? If so, we should enhance this test to check the response includes info on the types of answers alllowed.
I believe the Auth system should remain on in this method.
Why are you blocking here? this should be async throughout.
Why add ignoreElements()? Is this more or less similar to the sync implementation?
If there are no messages that are received, this will still pass. you should validate the number of messages.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Can't we just set without compare?
#close() could probably be called instead of this if statement
Can we avoid creating the thread altogether if asyncRefreshing is false?
This retry loop could be pushed down into the doFateOperation implementation, to get it closer to the RPC. That way, if you add a new enum type to TableOperationExceptionType, you can check it before it is wrapped. This also prevents the thrift types from spreading too far away from the RPC code. Something like the following in doFateOperation would work: java boolean retry = false; do { try { // ... do fate RPC calls here } catch (ThriftTableOperationException e) { switch (e.getType()) { // ... existing code case BULK_WHILE_CONCURRENTLY_MERGING_SO_RETRY: // pick a better name for the enum // log msg retry = true; break; // ... existing code } } } while(retry);
suggestion "Namespace is longer than "+MAX_NAMESPACE_LEN+" characters");
Redundant assertion
is this the right check?
Is this idempotent? PUT should be idempotent. What happens when we call failQuery for a query that's already failed?
This method should be static and need not pass this as an argument to the constructor.
unnecessary array new: {{true}, {false}} should work here
Please add ? and % as well
unnecessary new Object[], and there shouldn't be a space around the contents of an array initializer, e.g.  public Object[][] getLinearIndexFactoryTypes(){ return new Object[][] { {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed")}, {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed.gz")} }; }
Overly complex. Just say: Repository repo = repoManager.openRepository(...); try { ... } finally { repo.close(); }
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
I think we shouldn't allow it to be null. This should be @NonNull, same goes for field value as well.
Map.put already returns the previous value, so this can be simplified.  public int setExtraData(int index, Vector3i pos, int value) { extendExtraDataTo(index); Integer prevValue = extraData.get(index).put(pos, value); return (prevValue != null) ? prevValue : 0; }
If metadata was not already 0, the old bits are not cleared. Also metaData should be range checked (or just & 0xF'd).
Shouldn't the return type be int?
can directly return without storing in valType local variable
Please add {}
Constructor that throws an exception is pretty ugly. Especially because it is created and injected via Guice.
suggestion return Objects.equals(this.getName(), actionParameter.getName());  The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getName() returns null the previous implementation would crash
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
Why remove this? This makes is a shortcut when you check against the same instance.
suggestion timer = getMetrics().timer("file-read");
I think ex should be rethrown in else.
I think this logging doesn't belong to this method. it should be kept at initialize method.
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
whitespace/style
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
please use: runVdsCommand(VDSCommandType.UpdateVmDynamicData,..) so it will be sync'd with monitoring updates
super.getVm() will do dao call...
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
This should be false right? since the ordering does not change the hash.
This can be just return ... + ... + ... right?
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":{\"bar\":0}}}"
!isEmpty ?
minor: the replicaList.size() > 0 check isn't really needed
Are we guaranteed to always get a list of strings? A safer approach might be metacardValue.stream().filter(String.class::isInstance).map(String.class::cast)...
Should we add return here?
Loader can be hided twice <LINK_0> and <LINK_1> What does happened if call hide method in loader twice?
I would prefer to have the splashscreen immediately hide when the error occurs, so you are only left with the exception.
Is there any particular reason why you split of the callbacks from runSynchronousPart()? You still seem to call them together in every location
Let's change Iterator.equals(Iterator<? extends T> that) to Iterator.equals(Iterator<?> that) and then  final HashMap<?, ?> that = (HashMap<?, ?>) o; return this.iterator().equals(that.iterator())?  this reduces duplicate code and may be also used in other collections.
suggestion private void next0() { if (listIt == null || !listIt.hasNext()) listIt = mapIt.next().getValue().iterator(); row = listIt.next(); }
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
Why include the name in the comparison? fullName should be enough.
name should also be checked.
This class has Constructor and getter/setter which are never used.
This should use a constant instead of "status". If we are dynamically monitoring the db pool or the queue state in the future, items outside of this call will need to evict the entry.
Update this method to also return true if status is HALF_OPEN?
Remove final please.
This one will always use the default timestamp table (though looking at atlasdb-jdbc it doesn't even use AtlasDbConstants but uses its own "_timestamp"!) I'd actually suggest doing a Preconditions.checkArgument here, this one seems a bit more dangerous than the InMemory one in that it can actually have surprising consequences!
is there a need for this method? how will it be used?
Could we extract this logic into a separate class? I'm worried that the BuildView is doing quite a few things already.
Should not this method create a copy of the set just as getStages()?
Actually the underlying objectExpr could have free variables.
Here we want to extract the tumor alt allele _fraction_ from the genotype field, not the population allele _frequency_ from the INFO field, right?
Now that we use the number of passing alt alleles, we can get ride of that +1
Don't we want the normal artifact lod of the alt allele with the highest tumor lod? Say we have two alt alleles: A->C and A->AC, where A->C is a real somatic mutation and A->AC is just an artifact. Let's also assume that A->C has a higher tumor lod. Then we do not want to filter this site even if we get a high normal artifact lod for A->AC.
Inside the class, do not use setter to set value, simply use assign(contestId = null).
suggestion: Paging fields have been added
types --> type
Shouldn't we return the interfac IBinarySourceBuilder instead of the concrete class here?
Interesting fix. Can you explain how this prevents the RuntimeException? Is the upgrade to 2.3 needed for this change?
This should be done in the constructor. Then you can also make the member final.
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Maybe check for if name ends with ':' so we don't do a double one?
Missing space after 1.
Please do not use magic number here - actually, you can use http error codes for this or at least a constant.
Is there a more specific exception that can be caught?
Capitalize Thrift (or remove the word)
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
This method should be static and need not pass this as an argument to the constructor.
Shouldn't this be public? Also, if we need the getter methods (and I don't think we do) could we put them right after the setter methods?
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
This test checks "get" by using "get" so I would say that it's redundant to check it this way, perhaps it's possible to test it using another method to get an expected entity (say getAll and pick one from there).
no need to chain anymore: queryNetworkAttachments(); queryTLVInformations();
Should use ToStringBuilder.
toString() formatting.
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
Use this(...)
requireNonNull
refer to the const.
please move to static field. suggestion return "PROCESS DEFINITIONS";
Small typo: YubiKey? I think The K is capitalized elsewhere as well.
Is this supposed to be <code>return "Bump"</code>?
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Instead of catching NullPointerExceptions, it's better to check if session.getRemoteAddress() returns an object (and only call .toString() in that case).
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Nit: Why public?
these could even go into the constructor. Test classes get instantiated for each individual test.
remove
Do you want to accommodate value merging here? I don't believe we have a case at present where two different rules produce the same key, but in that case the implementation above would cause the latter to overwrite the former. Merge semantics would be preferable. On the other hand we can say "don't do that."
What's the purpose of this change? Seems unrelated to the task at hand.
we should not care about LOC metric. We should care about expressions without side effect. ~~ Ideally if test should not have modify anything, unless actually needed. Please update result variable, and only after that proceed with testing it.
Does this cope with the case "The previous session ended in a crash. In other words, one session can only have 1 crash at most." in the project definition? Should we also check if there have been unhandled errors?
rename variable to "hasOpenSession"
You should see it from the side of the user, not of the implementation
This is unnecessary, its called via canFillFluidType() in super.fill().
wouldn't it be easier if you do this in the tank? also you can just return null here as nobody uses this as far as i know
Formatting
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
public is not needed. Please remove.
Do a fetch following the delete to ensure that it was actually deleted.
This this isn't needed. Generally, we only use the this keyword where it makes code unambiguous.
shouldn't it interceptSrc and remainingPath follow same pattern to intercept as they both split from src path only? Whats the issue if I use same interceptSource method? Do we have some concerns? Could you explain me if I miss something here?
Shouldn't we use super.hasPathCapability(path, capability) here? It would delegate to FileSystem's call, so effectively no difference (including the supportAcls() call there), but would be cleaner.
This is actually the session request body, not the cookie body.
also escaping?
UpdateRequest should be immutable.
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
I don't think it makes sense to try to recover from this exception, we should just log and fail in the sensor (i.e. skip analysis)
Extract this from modules. "final" is not necessary on private methods
catch IOException and rethrow to avoid wrapping an IOException with an IOException
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Cache temp file string.
code style
this.
Should this check Collection as that is the super type for List and will capture Set, Queue, etc.
Could use Objects.hash()
fullName should be enough here too.
Or maybe just the following?  return HashCode.compute(principal,privileges);
add it to finally? Otherwise ZIP stream may be corrupted if cf.open() or copy fail
it seems strange not to write a zip entry when the pathname refers to a directory. Maybe it's how it's supposed to be, or automatically done when children files are added, but what about empty directories ? I guess they would be skipped
Better to move closing resources to finally block
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Passing two arguments to a log format string that only has one variable {} in it. Also the message is inaccurate since you're not passing in the root path. Let's do something similar to the above. Also since we're not calling out _ddf.home_ specifically, let's change this to debug:  LOGGER.debug("Root path is blank. Resolving relative path [{}] to: {}", path, absolutePath.toAbsolutePath());
File separator
What about the previous mImageReader instance ? It should be closed when detached .
Repository should be a dependency inject it in the constructor
@kishorekasi Generally wondering if this will increase the latency of the operation since we are not failing and retrying connection?
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
Why not just use " " + System.lineSeparator() ?
I would prefer to make the test even more explicit, by using:  assertThat(issues) .extracting(Issue::line, Issue::author) .containsExactlyInAnyOrder( tuple(1, "user1"), tuple(2, "user2"), tuple(3, "user3name"), tuple(4, "user4name"), tuple(5, "user5@email.com"), tuple(6, "user6@email.com"), tuple(7, "user7scmaccount"), tuple(8, "user8scmaccount"), tuple(9, "user8scmaccount"), tuple(10, "") );  (and on line 142:  assertThat(issues) .extracting(Issue::line, Issue::author) .containsExactlyInAnyOrder( tuple(1, ""), tuple(2, ""), tuple(3, ""), tuple(4, ""), tuple(5, ""), tuple(6, ""), tuple(7, ""), tuple(8, ""), tuple(9, ""), tuple(10, "") );  )
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
was this line moved on purpose or by accident?
Please use style instead of getStyle(), as this is more consistent with the rest of the code base. I.e.: if ((style & SWT.HORIZONTAL) != 0)
You can remove the super();.
Should make a differentiation of the name and id.
Why do we return the parents name instead of the name we store a few lines above?
not insecure - but no need to clutter the workspace. use [WorkspaceList.tmpDir(workspace)](<LINK_0> If you can not bump a version to that write a helper that does the same thing.
lowercase for package names.
revert this string
consider saving the value of group 1 and group 2 here rather than the whole matcher
consider being paranoid and prefix with "line.length() > 0"?
Use Logger instead of System.out.println
Why static?
Can't remember, isn't there a childNode.getJSONObject(index) method?
suggestion return Optional.of("org.junit.platform");
but this doesnt solve the issue, even if the events are disabled in the config eventsRefresher will be created because it will pass the first 'if' statement (above) why not adding the check for events to the line above?
no need for the extra '()' and missing space before '{'
Please add here this(vds, null); and move rest of the code into 2nd constructor. Using this approach we can get rid of FindBugs error.
Fully-qualified class name not needed.
As someone running these tests, I don't want this file to show up in my home directory when I run them. Put it under /tmp (use the Java function to auto-generated a file under /tmp)
Is there a reason not to clean this up in a finally block sooner?
Safer to check if entry already exists for the given table. If yes, re-use else put new one.
Usually we don't pass / accept nulls. Please either use Optional, or better just simply pass the TuppleDomain.all() predicate.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
"" + x.doubleValue() - is this the most elegant way to get a String from a double...? And if it is a usecase to instantiate a QuantityType without passing a unit, might we want to add a constructor for double as well)?
y - other.y would cover both not equal cases.
To be more precise, shouldn't it be "atLeastOneIsQuantity"?
Style-nit: We don't put {} around a single statement.
Please use a 2-space indent and braces around the throws block.
@drcrallen I tried a hadoop batch ingestion job with this patch applied, and the task didn't pick up my hadoop-client jars. Passing in the directory:  new URL[]{extension.toURL()}  doesn't seem to get the jars picked up, I had to change the URLClassLoader creation back to the original implementation with a url for each file to get the task to proceed.
How about checking numberOfEntries != 0 instead?
you probably don't want ID to be editable anyway. Even more, I think only task name should be editable in the new row
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
hmm for node based traversal the traversal id is the node id so I think getTraversalId makes sense (more general) ? But yes, let's replace the edge parameter with the adj node id.
For now I just hardcoded this. But we should have a way to access these properties.
Sorry, already removed this :flushed:
This is only valid because the empty version is defined as "0.0.0". But AFAIK it could have been "0" as well. So I'd rather use a "0.0.0" (or "1.0.0") constant here.
please replase MojoExecutionException for a new generic DeploymentExecutionException
This will suppress the warning for update site and category mojos, where I think the warning is justified.
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
line-lenght ok?
You can replace the full class name with an import.
I don't understand why we are looking at a VARIABLE_DEF? Shouldn't everything in the start of the enum be the ENUM_CONSTANT_DEF? If we hit a variable def, that means we are going past the end ; for the list of enumerations.
It's nice to have expression lambdas, but using node.findFirstToken(TokenTypes.IDENT) results in evaluating the same node twice. Assign to a local variable.
Consider using AnnotationUtil.getAnnotation(...)
brokerRunning.getConnectionFactory() instead? I also think if that would be useful to expose CachingConnectionFactory from the BrokerRunning directly to avoid such a bean altogether.
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
I would say use a flag  @garrettjonesgoogle thoughts?
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
I think it would be suitable if some kind of padding is applied between messages, such as a newline
To keep same format, could we use Timber.e(message) ?
here it should use super.getHostId(). It's obviously the same thing now, but if we ever change how TmfTrace defines its host ID, then clock-less CTF traces should follow.
Is there any specific reason for wrapping this exception here?
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
checking at least the important fields like chromosome and position and alleles would be nice. just in case we are returning an object will all fields as null. Applies to the other test class too.
ga4ghBeaconResponse as variable for more consistent capitalization.
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
decrease to DEBUG
Use parameterized logging instead of string concatenation.
please remove this generic log statement to decrease to level to trace
Its best to just do one atomic "test" per method in this class. I'd probably break this up into - testAssignVariable - testAssignVariableMultipleAssignment - testAssignVariableNotDefined Also note that junit has some built-in exception checkers <LINK_0>
if 'v' is not a member of enum why return it in upper case?
Why do you need to lazily create the variable instance? I think our convention so far has been that the get*Instance() methods always create a new instance and tests that require the same instance multiple times just hold a local copy.
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
Why do you need a TypeReference? Why does retriableHttpGet need to be generic? It's a private method, used once, and its logic and logging makes it specific to fetching tasks.
We're just swallowing this?
I think it is unnecessary to use synchronized here
throw exception
this should be catch (Throwable t)
Why is this removed?
I think we can rename stop to tearDown or something.
Should reset the previous version of the global callback.
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertErrorEventExecutionSet(emptySubprocessEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
suggestion assertEscalationEventExecutionSet(emptySubprocessEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
Does it add an error message?
This looks weird
Put this string in a final static so it can be updated in a single location?
Declare as final static..
Make static
I propose in my PR a more dynamic way to check the extensionPoint, what do you think about it ? I like the fact that if you do change it in the descriptor this code will automatically follow.
Same here, this can be boolean
No extra (clutter) please.
- [x] I know you're just copying what I did, but then again I was copying the tutorial, so that doesn't make it good. It seems like we could just call ElixirFileType.INSTANCE.getDefaultExtension and ElixirFileType.SCRIPT.getDefaultExtension, leading to  java public void createFileTypes(@NotNull FileTypeConsumer fileTypeConsumer) { fileTypeConsumer.consume(ElixirFileType.INSTANCE, ElixirFileType.INSTANCE.getDefaultExtension()); fileTypeConsumer.consume(ElixirFileType.SCRIPT, ElixirFileType.SCRIPT.getDefaultExtension()); }
This should check whether the id is already registered. This should also define a locale for the lowercase method.
You can combine the cast with the call below, like .map(stat -> ((Statistic) stat).getStatisticFormat()...
You could bypass this and use the ItemTypeRegistryModule itself.
should we also rename this.blockSize to be this.rowGroupSize ?
Add assertion to prevent negative values
Could this method, and setPurgeTimeout, be package-private? Still testable, and reduces risk of misuse.
unrelated: this can do 'super(msg, cause)' now that we require Java 7.
It might be better to override toString rather than append ValidationError because now you will get org.voltdb.exception.ValidationError: ValidationError: MESSAGE when toString is called or the stack trace is printed
nit: extract the logger into a constant
Is there a reason to not make it protected ?
Please don't hold onto the database connection for 12 hours, open and close it during the run method each time you execute. These are borrowed from a small pool, and keeping it tied up for hours with no use isn't friendly to the other threads in the JVM.
This doesn't look like INFO.
rename to signature
change to List
same here, maybe using Streams may result more readable.
We could create a new ChatMessage with messageData and remote
It appears I was unclear with what from(Message) should do: Instead of creating a new MessageCorrect, it should extract the extension from the message if there is one. The body of the function should be return message.getExtension(ELEMENT, NAMESPACE);
POST and 202 CREATED is more appropriate here
Please put the hardcoded string in the strings.xml file and call from there.
& let's not forget about this.
You don't need to check for null because the Task which triggers this callback should have been canceled anyway. If the problem still exists, Crashlytics will tell us.
this line was probably copied from somewhere else but I think the message could be improved, for eg Charge with charge_external_id={} was updated from <old status> to <new status>
same here, the test name reads like a question rather than a statement
I'm not convinced having this variable is really buying us anything; I think it will be clear what's going on if we just repeat ENTERING_CARD_DETAILS each time
you should mock external components, not the one you are testing
new line after this
As an improvement over current state of this test, could initialize config with smallInstanceConfig() (also use the same in MemcachedMultiendpointTest)
Sorry to be a pain, but we should use uk.gov.pay.logging.LoggingKeys.PROVIDER here, similar to how <LINK_0> does it.
Shouldn't answer be null if response is null?
only add to responseObject
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
Isn't this going to throw even if one of the ids is bad? Do you want to change that to continue processing valid blob ids?
addAll or stream?
There are cases were other versions might show up in the future, so this behavior could be confusing. While I like the idea of having static defaults available, it would probably be a good idea to allow any string as the version.
suggestion throw new IllegalArgumentException( "Versions should be from the same major version" );
Please check if this method really should be public in a private static final class. The parent method is protected.
Is this reload really necessary?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Are consecutive reloads necessary or will be one reload at the end sufficient?
Why isn't this protected like in the master patch?
there is no need for this.
I personally like to have the RunQuery and create the call back anonymous class all in the same statement, that way you can see right away which query is executed instead of looking after the callback to see what happens, matter of style I guess but you might want to consider it
you return Mockito.mock(SlackUtil.class) if there isn't any customization going on
@tmarzeion This code crashes the app. You got NPE in getPatientID method due to asyncs problems probably.
Please use parametered log as much as u can for performance
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
Do you mean s.length() > len?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Subscribing to METHOD is only introducing confusion, and cause problem with the rule. Subscribing to METHOD_INVOCATION should be enough. When hitting a method invocation, you can then look into the map if something exist for that symbol. If it's not the case, retrieve the parameters names and add a new entry on the map. Then you check for parameter names.
Better to use Collections.singletonList rather than guava for this.
Collections.singletonList
We know it is Host. please use proper type.
Why do we want to return it if we have methods to manage it. It seems like encapsulation issue.
Do you consider this(hostId, 1, 1); nicer here?
I'm missing the new field in the toString method.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Please keep this.cell near the related fields (previousFamily & cell count) below
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Can this happen ?
ArrayList should be constructed with fixed capacity.
ArrayList should be constructed with fixed capacity.
Shouldn't this close the iterator before returning the list?
Any shot of breaking this up a bit so that someone can understand what we're looking for?
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
Please group mr, ms, and mrs together
Is there a reason for not using the MoreObjects.ToStringHelper instead?
as I said, I think $i=1 should be part of this block (thus elem = 2)
If you have commons-lang3 in your classpath, you can use ToStringBuilder
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
I see you're against anonymous classes :) I don't care either way, but maybe you could make the toIndexFieldConverter and fromIndexFieldConverter methods consistent with each other?
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Can make this into a singleton as we have with UNSET.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
Isn't it possible to extends this one instead of creating a new constructor?
quasiIdColumns and infoTypeNames  should be inlined
Constantes? Suggestion: EVENT_ID ou AN_EVENT_ID
missed to implement
What does it mean when we return null?
The this. in getters are unnecessary too.
This can be replaced with  java return newName.isEmpty();
Replace with Util.threadLocalRandomUUID()
This should be connection.getFullyQualifiedNamespace()
try ... catch with resources would be cleaner
delete on exit?
It would be safer (for preventing some race conditions) to give the permissions when files are created. Static methods Files.createDirectories and Files.createFile support a second argument for defining permissions. Below is an example:  Files.createDirectories(progressFileDir, PosixFilePermissions.asFileAttribute(EnumSet.of( PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE, ...)
Can you make it synchronized?
err... didn't realize this was java, we should at least be consistent with usage of this.
So, this method now looks a bit odd: it invokes just obtainConnection() independently of this.isSingleUse(). I can guess that synchronized(this) makes sense in case of !this.isSingleUse(), but how about to move the synchronized(this) to concreate implementation of AbstractClientConnectionFactory#obtainConnection() ? From other side it looks like we should use ReadWriteLock around theConnection. Let me know your opinion and I'll push polishing
suggestion .parse(StringUtils.isBlank(metadataLanguage) ? metadataLanguage : "en");
Can the loop be replaced with a call to removeAll() instead?
Can use validatePrimaryLanguage here and below.
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
Now that you're encoding the ID are you missing decoding it somewhere? I don't see it anywhere
Nested strip invocation seems unnecessary. But maybe I am missing something?
use a constant
you can also write this as return sql.replaceAll(TRIM_SQL_PATTERN_STRING, " ");
Is this needed?
Will the volumeId not be set in the constructor from parameters?
ACTION_TYPE_FAILED_GEOREP_SESSION_ALREADY_RESUMED
We should also check the servers which we want to update the hook content is in UP state.
I think we should remove a pair of parens:  mSession = new Session.Builder(this, mApiKey, mSessionId).build();
Maybe we can move the null check on mGoogleApiClient a level above so to protect also the access to stopAutoManage. wdyt?
There is a race between checking if getActivity is null and it actually being null on the secons call, causing a NPE. Probably store the getActivitiy value in a variable.
Make this method static - it doesn't access any object state.
it is not the best solution. Try use getDetachedField to retrieve roles object
Where is this being called from in the new code that is requiring a user to be logged in when it's called? Could the place that's calling it just go to the DAO instead of the manager?
Too broad a catch. IndexOutOfBoundsException should be enough.
I suggest: "The settings defined in config/sonar.properties are read-only and can't be changed. HTTP status 400 is returned in this case."
You should not remove addSearchQuery but replace it by createSearchQuery in order to use .setMinimumLength(SEARCH_QUERY_MIN_LENGTH) on it
judgment.getJudges().stream().collect(Collectors.toList()) could be replaced by simple judgment.getJudges()
This is changing the behaviour. Previously it would add the result as DATA_CTX_RESULT.
Unused variable?
suggestion super(() -> name);
can you make this final?
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
FileNotFoundException is a subclass of IOException
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
This doesn't do anything.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
same as above... why not use simple if/else here?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Ideally there should be a test verifying all separators and their combinations. e.g. en_US|cloudBeers
Do we need to change line 71 too?
wha would it take to implement this for JPA? bit uncomfortable to have new methods only for particular type ...
UnsupportedOperationException ?
Minor: can remove throws
It seems compareAccountMetadata method does an exhaustive check periodically. Any specific reason to do a sampling check?
I think we just want the name and not the email in the message. But username is always null to us (for example), you need the DisplayName.
getFullName()
i think this might need to encdoe the name and bitmap type too.
suggest putting 0xFF byte after a string as a terminating indicator.
Should place 0xff between these guys, in the event that a fieldName is used that matches a fieldExpression but should have different results.
This must be supported.
ServerSocket implements AutoClosable, so try (ServerSocket s = ...) {} might be stylistically better?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
I advise inflating the ExpandableListView from a layout so you can apply the styling there, instead of hard-coding style values into the setListAppearance method. Then, you could get rid of the Utils.getPixelFromDips() function too.
are these models implemented on the backend yet?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
When using a byte[] buffer, I believe we need to capture the returned byte count because it will likely be less than the full array on the last read. As in: int byteCount = 0; while ((byteCount = in.read(byteArray)) != -1) { out.write(byteArray, 0, byteCount); }
read() always moves the stream forward, so you don't need these seek/seekPos++; they can only slow things down
the requestBody shod look like : {"person":"some_uuid","base64EncodedImage":"soemstring"} right now instead of uuid there is the whole Person object in POST. To make it work you have to do it manually before posting or extend the Resource.class so it will be done automatically by ResourceSerializer. Let me know if this answer is enough :)
static is missing
Please move isMethod(MethodInvocation, ...) above isMethod(IMethodBinding, ...). This helps in reading the code top down (See Clean Code book by Uncle Bob). And will also make the diff look better.
These 2 extraneous whitespaces are introduced by your change. Also if you did happen to fix the pre-existing ones (line 115, line 142) I don't think anyone would fault you for it as you're already making changes to parts of the code that are nearby.
Static import the assertion methods
why ((String) null)?
Put each on a separate line java .setMetastoreUris(null) .setHiveUserName(null));
Could get rid of lines 439-441 and make this map.put(contig, ++val);
There should not be a need to set this to public. Perhaps private would be better.
It would be great to cover the util method with tests.
Should we be reusing the walk we've already setup? Why create a new pool of revision objects when we can just reuse the one we already have? On the other hand, a walker could dispose of object bodies, and a reset and reuse might confuse the caller because the bodies are gone. That's actually a bug in RevWalk that we should probably address and fix there rather than forcing an entire new pool to be created for a second invocation. Likewise, RevWalk discards the starting commits when it resets. We probably should allow those to be retained somehow, so the same walk can be executed again without needing to maintain our own copy of the starting points (RevWalk calls them "roots" inside of itself.) Finally, RevWalk's implementation of Iterable is probably wrong. It only works once. Creating a 2nd Iterator fails. So we probably should fix RevWalk first so its iterator() method resets the walk and starts it over again.
Actually, any use of ObjectId as a parameter probably should be AnyObjectId instead. This permits the mutable variant to be passed in. Normally that might be a problem, since the caller can change its value after we return. But it shouldn't be an issue here, because we're doing a lookup of the object in the RevWalk and holding onto the located result. So we're copying the value we were given, which makes it OK to take the MutableObjectId variant.
I think handling fetches from a server that has its own shallow commits will take more work (see v1.9-rc0~3^2~17, "upload-pack: make sure deepening preserves shallow roots", 2013-12-05). Are the above two lines needed here?
Throw the proper exception if something is not supported: - NullPointerException if status == null or command == null. - IllegalArgumentException if frameID < 0 or if frameID > 255.
I guess null is an invalid value for command, if so throw a NullPointerException.
parameter string might be null, avoid the NullPointerException, since null seems to be a valid value for parameter.
Same as above for otherNonCodedConceptUuid
Same as above for otherNonCodedConceptUuid
You need to check that conceptUuid is not null and blank
we need to reset this property in a @Before block
Don't you need a super.tearDown() call here at the end?
I think we can just call factory.stop and don't expose LoggerContext as a field. The factory will close the context.
java case "trackingOff": default: return TRACKING_OFF;
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
This should be synchronized.
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
I would move this to a constant so we can access it from tests as well.
Add reasonable toString() method, returning null doesn't seem as proper way.
MemStore is used for tests, so we need to implement this function.
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Usually we don't pass / accept nulls. Please either use Optional, or better just simply pass the TuppleDomain.all() predicate.
add this selector to UI mapping at the beginning
verify if it really has to be By instead of WebElement
Those two methods are similar. Consider using one.
You don't need to call .getValue() here, since the method neither does anything with the value, nor does it return it. You can invoke the API and leave it at that.
FYI: using a map here would have given us: .map(voidDigitalTwinsResponse -> null) Even though Mono<Void> is the same as an empty Mono -> Mono that doesn't return anything, I feel Mono.empty() is a better representation of the transformation we are doing here. However, I want to point out that the end result from both would still be the same.
this can also be .map
Shouldn't options be Immutable?
please see the contract of Map.entrySet(): by invoking put() during the iteration the result is undefined.
nit use Joiner directly to format the list
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
I would prefer if you change the bundleContext member from default to protected. getBundleContext() is used to initialize the bundleContext variable only once (I know the description is not correct).
I think the result of this call will not change at any time. So we could improve the code by keeping the Bundle in an instance variable so it is not needed to request it everytime.
How would you feel about using more descriptive column names? For example, day(shipdate) as ship_day and month(shipdate) as ship_month? These 2 will give you values within TINYINT range and will have meaningful names that are easy to understand.
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
virtualColumns and descending go in different order elsewhere in this class
I would separate the message that should be logged as info from the exception that should be logged as debug as we don't want to pollute the log with a stacktrace at all times.
tree.symbol() reused 3 times, make it a variable.
![MAJOR](<LINK_1> Change this comparison to use the equals method. [![rule](<LINK_2>](<LINK_0>
hope you know the diff between ceilingKey() and higherKey() and you are using higherKey intentionally
entryId is not used, please remove
this.jsonKeyFile = serviceKeyFile;
Inconsistent Upper and Lower case in description
You can change the 28 case to a default case, and remove this.
Gson doesn't run on these versions so I don't see any reason to include them.
Now the commit action is not enabled when I select a non-project resource. The method getRepositories does only work for projects.
Should be OBJECT_ID_STRING_LENGTH.
Let's keep the boxing as is please and focus this PR on the new API. If you want to go through the whole code base and consistently use one boxing style that's a different PR IMO. But: I prefer to know when boxing and unboxing takes place since it is not free; this gives the compiler the opportunity to flag unintentional boxing and unboxing and let the programmer decide that's really what should happen.
This should not be registered on an HC.
The super implementation is a no-op by design.
create new ReloadRequiredWriteAttributeHandler(ATTRIBUTES) outside the loop, to lower memory footprint and most of all GC pressure during boot.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
nit: Will be useful to add a log line before Line 77 to indicate that the shutdown has been invoked on this scheduler instance.
see in Volt how to properly shutdown an executor service
You can use is = InventoryUtil.itemOrEmpty(is)
suggestion console.warn("Usage: \"changeShip module:shipName\"");
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
I think we will have to discuss whether or not to include the fromKafka functions in this class.
Missing StringUtils.isNotNullOrEmpty() check
these setters should not be public
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
I believe we should use ThreadPoolExecutor#shutdownNow() to stop all actively executing tasks and the waiting tasks as well.
A scenario that needs to be checked - 1. Create a mac pool that allows duplicated. 2. Add duplicate mac to the pool. 3. Change the mac pool to NOT allowing duplicates (is it possible?) If point 3 is not possible we are or. But if it is allowed then 4. Stop the engine. 5. Start the engine. If I understand correctly, you will get an exception here since you're trying to add duplicate mac address to a mac pool that doesn't allow it.
I would additionally check that it's isDefault is true
Maybe wrap in an immutable map.
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
You should be able to use the diamond operator here, i.e. new ArrayList<>()
Why not make implement Closeable rather than this private close?
I guess EhcacheActiveEntity should never be getting any PassiveReplicationMessage since execution strategy prohibits that, right ?
Maybe we can just return this since we are not doing anything else in the if statement anymore.
+ desc
This description should mention TC and SC, I guess.
real and bigint still applies for qdigest right?
You may be able to use something like org.eclipse.tycho.p2.tools.impl.Activator.createProvisioningAgent(tmpDir).getService(IMetadataRepositoryManager.SERVICE_NAME).loadRepository(repository, new NullProgressMonitor()).getReferences() to check whether repository references are properly added.
Redundant with the next assertion
static importa
{ }
possible exception
Why do we return the parents name instead of the name we store a few lines above?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
nit, Collections.EMPTY_MAP?
Generics on the right side are redundant since Java7
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
nit: orElse("null") is clearer.
We don't include the underscores in the field names.
Does not match conventional toString implementation.
This will throw redundancy warnings in IntelliJ
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
why is it adding null?
suggestion this.licenseKey = licenseKey;
![MINOR](<LINK_1> Make "getKeySize" a "static" method. [![rule](<LINK_2>](<LINK_0>
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
Please change the line 38 to also use EnumMap<> for consistency.
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
whitespace/style
Same here with Throwable.
Just as a note: If the ResourceManagerDriver tries to run something on this executor while the ResourceManager has no leadership, then it will simply be ignored and not executed. Is this ok with the current behaviour of the ResourceManagerDriver?
AFAIK this class does not exist. Chromium is used with the class org.openqa.selenium.chrome.ChromeDriver and changing the Chromium binary path with options.
Must be with this. Also how about addAdvices(Advice... advices) ?
I guess this won't affect compatibility with previous deployments (when reading/writing to ZK), but it would be nice if somebody can confirm.
You could replace this for: java !delegate.canHandle(unitOfWork.getMessage()) ? interceptorChain.proceed() : delegate.handle(unitOfWork.getMessage(), target)
please reuse the constant
No worries... we have all done it a bazillion times. :smile:
multpart -> multipart
see below re: spaces
It looks like this isn't really what we want - the !! is character content, not an image. I'm thinking that since an image with no src can't be represented in Confluence, that we should just leave out the !!. What do you think?
It would be good to survey the world and see if there's a more popular heading style (since there are four: setext-style with hyphen underline, setext-style with equals underline, atx-style, and closed atx-style).
@dmzaytsev ThreadInfo can read currentThread in Ctor, no need to pass static
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
Could be just package accessible, just for tests.
Should this be protected, or do we really want to allow to call it outside this class?
please import java.util instead of explicitly writing here
should be : this( clusterId, volumenId, false);
Can't we throw here something more meaningful? Where are you using this query? how does it feel in this case?
Simple for-each?
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
For new API I'd prefer to return an java.util.Optional<T> instead of null to avoid potential NPEs.
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
minor thing, but this doesn't need the throws clause
This is one of the reasons I didn't create a PR yet; not sure what the answer is yet but was going to explore it (possibly using ApplicationContextInitializer and creating ContainerMetadata earlier). Earlier (current master) we had a static method being called to publish the container started event from a context (static so SingleNodeApplication could also call it), but that definitely needs to change. We need a bean, with a managed lifecycle.
also use a map here (this is likely to be extended I guess)
Typos?
You can change the 28 case to a default case, and remove this.
One minor suggestion. Make this a private final variable, and create the runnable once. Then return the variable instead. The outcome is the same, with the advantage of not creating an object every tick.
I'd increment a counter and assert its 1.
I think there's a method in Runnables that returns a do nothing runnable
Missing final
can we set this default as a constant? (private final static Charset)
getter
This produces a warning because new GenericType(...) is never null. Which is actually the symptom of a bug: token.getComponentType() can be null, this must be handled. I'm fixing it directly.
remove @Ignore ?
Since there are two places using "tree-item", consider replacing it by a constant just like you did on the other classes.
should probably be named m
should probably be named m
should probably be named s. But then it's conflicting with the subscription s. So I guess ss would be more appropriate.
how can a clusterName be null?
suggestion this.className = requireNonNull(className);
We should throw an exception here too, saying the cluster is invalid.
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
Log the exception to error.
Don't forget to update this
please extract as constant
Generics on the right side are redundant since Java7
No, need for close here as you use try-with-resource?
@fabriciofx Here also, we could return the body() of our decorated object directly
I think it's better idea to have the default throw OperationUnsupportedException than to have it call toFile() which will work most of the time but sometimes fail.
please move list initialization to where it is used.
please remove newline
please instantiate the list right above the check where it is used.
Is it possible to get rid of this?
A LinkedList is better since you don't seem to access specific indexes anyways.
WSTUtils.LIVERELOAD_SERVER_TYPE.equals(server.getServerType().getId()) is even safer, as it covers the _unlikely_ case of having a null id.
we can actually print the unexpected key type here
Actually, there's a stupid bug here: the test was supposed to be if (!channelId2Creation.containsKey(partitionKey)). The goal was to avoid creating a new ChannelCreation if the entry is already there. And you don't gain anything here with using computeIfAbsent instead of putIfAbsent because the lambda would be capturing, and that the key usually exists. Could you please revert your change and fix the if test?
Is it OK to catch all exceptions?
nit: public abstract void
This seems to be a recurring pattern. Should we pull up into an abstract parent and then let subclasses merely handle serve(req,res,true/false)?
child
Same here regarding the messages.
before:-20160923, timeFormat:YYYYMMdd is misleading as the reader may think the value for before should match timeFormat, while in reality a value starting with a - indicates number of days and timeFormat is not used to parse it. Something like before:-10000 would be better.
timeFormat:null is unnecessary
Either call getComputedValue(buffer, ...) here or remove the second signature of getComputedValue since I don't see it used anywhere.
@Sami32 You removed result.append(", Sample Frequency: ").append(getSampleFrequency()).append(" Hz"); - I disagree. Remember that even though you already have the sample frequency from DLNAMediaAudio they are separate values and one can be used one place and another another place. We should see both values when debugging, if they are different that would be a bug.
I don't think these are mutually exclusive. The manual shows them here: <LINK_0>
Absolute or just path?
child
StandardCharsets.UTF_8
Can we compute this lazily only once hashCode is called, then cache it in an instance field?
This allows null values, though that may be fine.
@Serranya Lets use ListOf here
Replace method body by return any(input.getRefines(), instanceOf(MultiplicityElementChange.class)); and add the static import of Iterables.any
The name of the predicate method is misleading as it doesn't check for resource attachment changes of type move.
use the constant here instead of a magic number
I'm not a reviewer but FYI  CredentialModel.PASSWORD.equals(credentialType) in that order can't throw a null pointer exception, usually always the constants first because equals accept "null" but null don't have equals function.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
There should be different ways to compare the type, based on the given type expression: 1. Check for equality with the fully qualified type name (including the namespace information) 2. If no namespace is provided in the given expression, check for equality with the type's display name 3. Check for equality with the fully qualified XML element names (including the namespace information)
local variable e is never used.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
Doesn't this mean you'll have a single reporter for the whole life of the worker (and a single reporter means a single task I think?) I thought it had been talked about having a new task every hour or similar?
Style: bump closing paren to next line with no indent.
checkNotNull(p.registrationDomain, "registrationDomain")
This is bytecode equivalent to using the for-each syntax on an array.
Patameterized logging please.
For loop?
There is no need for creating a new storageManager instance; getStorageManager() returns an instance valid for all the synchronization process.
You may use FileUtils.contentEquals instead.
can we use the result from the cancel attempt earlier?
could we just initialize targetgroups = new HashSet<>() at the top of the file?
Check first that target is not null.
should be ...object instances can be deleted"
Don't rely on the JRE platform encoding here. Use a specific encoding, like Constants.encodeASCII(). This also applies to the other getBytes calls below.
Verify that at least returns one element?
the order of arguments in assert*() is counter-intuitive... it's (expected, actual). Technically the 'result' variables should always be second.
Aren't there any test methods that require compatibility?
Technically this is another lambda and out of scope of this PR imo.
I would personally prefer to add a 'copy constructor' that takes a CacheConfigurationBuilder as parameter. Not a huge problem but I find that approach a bit simpler.
lowercase for package names.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
Remove throws Exception
Why not just replace Platform with Job? Same below.
I would refrain from using static imports. The problem I see is that another person needs to know that this belongs to Optional when looking at this code.
Let's use static imports for all the Assert.assertFoo calls as well to improve readability.
please leave it that way - it's intentionally referencing the deprecated version.
Is this for debugging?
It would be also good to set the content length here, if known.
"This method is not actually very useful and will likely be deprecated in the future."
no need in passing the size here
Any worry about case sensitivity wrt to scopes?
Missing generics
cause -> e please
no need to include _random as an argument since it's already an instance variable.
Please throw NullPointerException instead (also, use braces for the if statement)
seems like a string that should be stored as a constant and defined only at the side who returns this message to prevent breaking this assumption - unless it isn't doable
non -> not
Could be a try-with-resources.
The code sets in to null to indicate close was called. This make all the code that's trying to sync on in go through a rigmarole. I think it may simplify the code if a boolean that tracks the closed state was introduced and in was never set to null. Then the code can always safely sync on in and check the closed boolean after syncing.
You can use try with resources here so the Input stream is closed automatically.
If we are going to loop over these, no need to make it another variable. Doing it this way will end up setting an extra variable that will be unused. Can add the list instead as another getter and loop over it in the template functions to avoid duplication/unused vars
Collections.singletonList
I am still a little bit concerned about getOutput here can have random order. It might be ok during optimization, since we will always lookup by variable name. But during execution, all the variables will be changed to inputChannel (i.e. the index in the list returned by getOutputs), so a change in order will cause mismatching. HashMap's keySet order can easily change. Also, the old code  ImmutableList.copyOf(assignments.keySet());  is cheap because ImmutableList.copyOf smartly utilized underlying data structure, so no copy actually happened. But, we will do copying now each time. Here, probably let's save it to member variable during construction and return this list instead. We will need extra memory but it is not as bad as unexpected behavior and GC.
Should this equalsIgnoreCase() be changed to equals() as well?
Why would we be ignoring the case here? Do we get back inconsistent capitalization? That seems strange
It looks like this should already be taken care of by the setScreenStateUponResult() implementation.
@lmontrieux Wow... Strange. I think in this manner you need to add addional {} to log message.
ex.getMessage() VS "Feature is disabled"
ex.getMessage() VS "Feature is disabled"
I don't see why is isConnectionSetup() necessary. Shared in SharedPubSubWebSocket client means it is shareable and must support concurrency. It should be the responsibility of SharedPubSubWebSocket to ensure that its state is properly managed and if setup() can't be called concurrently, enforce it.
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
Just a thought is the contract for running that its fully started? As Camel has a state called .. starting which is the phase it do when it startup. But I assume running is after all the startup stuff and its really running.
We should configure the layer name here and not in the factory. See org.eclipse.sirius.diagram.description.impl.DescriptionFactoryImpl.createLayer()
We can also move this up to the declaration and remove the meaningless initialization.
java8-isation [forEach]
deserialize can return null.
@Description on L138 needs updating
What's the behavior when the input is not between the min/max values?
Quelques lignes plus bas: User mockedUser = mock(User.class); when(mockedUser.getEmail()).thenReturn(email); when(mockedUser.getPassword()).thenReturn(password);
getById
return authentication.getUser(username);
Is the sort field used at all? I see it being set but don't see it used anywhere.
are the left over agencies in fact the unsorted ones? I am wondering if there is a better name for what goes in this list
Same here suggestion HazelcastSortAccessor hazelcastSortAccessor = new HazelcastSortAccessor(); KeyValueQuery<Object> keyValueQuery = new KeyValueQuery<>(RevisionSort.asc()); Sort.Order sortOrderA = Sort.Order.asc("Cannot resolve nest mates of a latent type description: "); Sort.Order sortOrderB = sortOrderA.ignoreCase(); keyValueQuery.setSort(Sort.by(sortOrderA, sortOrderB));
UOE instead of ISE (x3)
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
Should it not be new HttpCookie instead?
Is this an error condition or just timing? When will it happen?
assignedPartitionIds can get large. We may want to log the whole set only in debug mode, in case addPartition gets called many times on startup.
suggestion Objects.requireNonNull(partitionId, "'partitionId' cannot be null.");
This & the other switch removals should be reverted, performance tests show that this isn't any more efficient. The change also increases memory usage, making this a net negative change.
How about using constant COMPRESSED_BUFFER_SIZE here?
LocationUtil static methods should be public.
Make private Disposable disposable = null and add a null check here, just to be sure.
super.onDestroy(); must be called here
just call clearGeoJsonLayer for code reuse?
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
suggestion info("Consistent ID: " + ignite.cluster().localNode().consistentId());
Could you make this package protected? We are not exposing JSONs anywhere in the SDK
<code>Downloadable.get()</code> may return null. It is a mistake in the original code, but it makes sense to fix it.
object->array
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Tokens are somewhat sensitive. Don't think we want to print them.
repeated ...
Is this used? If not, make private.
UnsupportedOperationException is intended for this situation (also at some places below)
Is this really needed? There is a chance that there are two HTML elements with the same id in the DOM.
in here I think default filter is an attribute of the filter itself. You should continue using just _loadSavedFilters_ and that would set the default filter automatically.
filter manager should handle the default filter.... if one doesnt exist it should consider creating it, based on the default filter we already apply.
do we actually want to trigger a selection when setting a filter as default?
Once 'httpAuthenticationFactorySupplier' is final, you know you've validated it in the constructor and you don't have to do it here. And that means the try/catch can be removed.
Would it be better to, instead of mix secureServerCnxnFactory in getServerCnxnFactory, add a separate method getSecureServerCnxnFactory? This also maps well with existing set method setSecureServerCnxnFactory. Caller now has to explicitly call both, which is more work, but makes semantics more clear.
can't these throw exceptions ? shouldn't it be guarded to not prevent stop ?
Would be nice to have something here to check for duplicate schema names. I don't think the base Calcite class does.
this method is now repeated in 3 or 4 separate places. is it time to remove this duplication somehow?
Hmm, thinking about this I'm not sure it's quite right. It might work for the /item resource at the moment, but for the /records (or later /items) resource, we need a single schema that will work for arbitrary records (or items). This means we need to include all possible fields in the schema, even fields which aren't present in a particular item. So, for example, if a country doesn't have an end-date, I think we should still have an end-date column in the CsvSchema.
@jomarko Are you sure about removing that line? I remember times ago I put it there for some reason, not sure if it is still needed; anyway, the point at that time was that if ScenarioGridCell.editingMode is "true", the editing does not start. When you press "enter" or anyway end editing, the "flush" method gets invoked, and after that the cell must be editable again.
Should we not assertOpen _before_ we readValue?
Please include a translation text here indicating that attribute value cannot be null.
extract private method boolean waitForOperator(Operator operator, Duration timeout):  try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; }  and build assertions around this method
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
This exception is not ignored, so can you fix the variable name?
I think the following would also fix the leak and will not call the removeAction twice in any code path java @Override public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) { synchronized (removeListenerActions) { if (destroyed) { callRemoveAction(removeAction); } else { removeListenerActions.put(registrationId, removeAction); } } }
This handler is at the application level. That means with multiple windows, you need to return the build action for that window and also add a window listener so that you can clear a window entry if that window closes.
good practice: usually actions go before WS as they are injected into it and so they are grouped together
redundant this qualifier
redundant thisqualfier.
Should this return 0 or -1?
Why not use Binary.copy?
I would probably rename this as well to binarySearchTree because I find that clearer. That's just my preference though, feel free to leave it as it is if you prefer it that way :)
can we switch to the CommonUtils asserts?
I don't think the process deploy should fail in the case of temp file deletion fail
Absolute or just path?
I think you're missing getDefaultConfigurationFile() here.
Please use @BeforeMethod(alwaysRun = true) insted of init() inside of test body
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
space before trailing {
it's unclear whether this is invalid because 0 is not valid or because it's a string. I'd recommend being a bit more specific here or potentially having two tests if both are invalid to make it clear what our expectations are.
nit: no space around quotes
more than 120.
I don't think we need to repeatedly assert isJsonObject in all the tests. After the first one, we've proved the point. Let's only have it for the first time it's demonstrated.
Thanks, can we also give a test case for Join relational expression ?
Need to remove codec from here too, right?
We don't want to restrict 5 min of wait time by updating CLOSE_WAIT_TIME ?
Is this change correct? I see header is getting set with format(secondcol,2)
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
There's no need for an "else if" since you are returning from the "if" above.
This check can be simplified to: java if (super.isIdProperty()) { return true; }
you don't need the variable. you can inline
Possible candidate for bind() if that method is created.
getSelectedPattern().getCommand() ?
I think that CSSDOMSemanticElemntHelper should be an Singleton.
Can you repro this on master? If yes - definitely worth filing.
Missing finals for all tests in this file
Unsure this addition is useful.
Could we use a simple string concat here instead? this avoids unnecessary goggle common dependencies.
same here, pls use string concat instead.
Please include a log statement that reads something like "Received request to shutdown Myriad Framework.."
By default, do we expose an HTTP port that allows for any client to shut down a process? What exactly does this do? System.exit? Do we anticipate (at a minimum) requiring some sort of authentication in the future?
why is toString defined here? Also, it is using a method that is expected to be used only for testing. It doesn't seem to provide any benefit other than debugging, perhaps? Even for that , we should stick with package private methods as opposed to public one. Can we please remove this?
this triggers a findbugs error since it blindly casts and assumes non-null
without sWrapper being volatile, even though the method is synchronized, sWrapper could be thread-local.
instead of != null here, you could do a instanceof ISegmentGenerationListener. There shouldn't be any ClassCastException, but this way, you would avoid any such error
FYI All instances of HardSoftLongScore.ofHard(1L) may be replaced by HardSoftLongScore.ONE_HARD,
code style: space after //
typo
Why do we need to first slice and then also duplicate ?
Changes to this file should go in the previous commit
static import EMPTY_SLICE and remove Slices. here. Same for other places.
I haven't tested this, but what happens if the user is running init on an existing site, which already has the Verified label, and he selects "yes" on this option?
My reading of WindowCacheConfig is that the default is 50MiB, which should usually be less than 1/4 the heap size. What am I missing?
This should be a Boolean instead to indicate that it is a dry run.
does this need to catch all exceptions?
Why not add a 'catch' clause that looks for MatchFoundExceptions?
Nit please alphabetise.
This line appears to be obsolete ?
This is outside of the CLI code now and into core, right? Maybe we should accept the version string and device ID as arguments and/or continue keeping a CLI specific version that overrides these as abstract methods?
Please move this to DBUpgrader. Also, use oldVersion < 1090001. Users might skip AntennaPod versions. When checking for equality, this skips the migration when coming from, say 1080100 instead of exactly 1090000.
Optional: this could be done without the index variable: for (int i = 0; i < emailPick.getItemCount(); i++) { if (value.equalsIgnoreCase(emailPick.getValue(i))) { return i; } } return -1
Code conventions: we don't use curly brackets around single line blocks
Format this file using our code style.
use the interface here
That's good to know.
this.
I don't think the logic is necessary. We can have the default visibility as GONE.
Should this be a CollectionUtils.isNotEmpty check instead of a != null for efficiency?
I'd prefer to not use this reflection things. They have introduced issues elsewhere.
Please bring the braces back.
Please bring the braces back.
revert this unrelated formatting change
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
use ShellIsAvailable
use ShellIsAvailable
Another place where we could note that the boolean is unused.
This one will always use the default timestamp table (though looking at atlasdb-jdbc it doesn't even use AtlasDbConstants but uses its own "_timestamp"!) I'd actually suggest doing a Preconditions.checkArgument here, this one seems a bit more dangerous than the InMemory one in that it can actually have surprising consequences!
Discussed offline: I had a concern with the Invalidator not using the custom table. However, we don't expect or require automatic cross migrations between a custom table db-persisted timestamp and a paxos-persisted timestamp on timelock (at least in the short run), so this is probably fine for now.
This does not verify the order. (The iteration order over expectedMap is undefined).
Should be removed
actualEntry should be a better name
Shall we move this to a common method.
add server.setStopAtShutdown(true); to prevent leaks <LINK_0>
This could also probably be optimised. At least by using selectorHandlers.headMap(selectorStr, true).entrySet() to trim the range to iterate over.
point here is to clear entries if some were removed compared to previous state, would selectedIds.containsAll(fSelectedIds) remove more clear cases? (replace the selectedIds by a hashset in that case) Also, the actual clearing / update happens at org.eclipse.tracecompass.tmf.ui.viewers.xycharts.linecharts.TmfCommonXAxisChartViewer.UpdateThread.updateDisplay, should this code be there, to avoid the clear/update pattern in child classes?
why null check here? ... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
wouldn't it be cool if it uses itself getMembers(Predicate) here?
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
can replace entire if statement with: java final Set<T> newMutableSet = oldValue.size() == 1 ? new HashSet<>() : oldValue; newMutableSet.addAll(oldValue); newMutableSet.addAll(newValue); return newMutableSet;
We can use the createResponseEntity() helper method like you did below.
GetCommitResponse is no longer used anymore. We can remove this class and replace its occurrences in the tests with the Commit class.
throw RestException with Status.NOT_FOUND instead
We can't do this - breaking change for anyone that has subclassed and implemented destroy(). I suggest we use // NOSONAR TODO: remove throws in 5.2, which removing it from our subclasses.
Name in log message needs updated
Not necessary?
Technically we could return value at the end sich we return null if it is null. (i.e. you don't need to keep the compiler happy)  if (value == null) { env.flop(String.format("%s within %d ms", errorMsg, timeoutMillis)); } return value;
This seems like a good direction for an integration test of whether the metadata server is responding as expected. However, tests with variable expected behavior makes the definition of a passing ambiguous. Maybe the test could log the context around metadata server existing?
env.defaultPollTimeoutMillis()
why changing it to static?
I notice a bunch of tests that use camel-undertow have been switched to WAR. Are we now mandating WAR for any camel-undertow consumer usage?
@hkalina The host and port can be overridden with some properties, so this is not guaranteed to be correct always. Do <LINK_0> instead
Shouldn't this be wrapped in a try... finally block?
This seems rather incongruent to me - should we define a dedicated filter for managing request-lifecycle MDC keys?
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
What if the user changes the selected Chinese variant while the app is running? Is this really so expensive that it needs to be cached?
Please, try to omit changing files only for formatting.
How about remove the property, rather than set it.
Please remove that
Not necessary. See quality rule : MITRE, CWE-397 - Declaration of Throws for Generic Exception
can we use sysprop or something for url?
Generally, it's a good idea to have throws Exception rather than a more specific one in the signature of test methods.
Add final keyword.
if an empty set of permissions was passed in does this work as expected? (permissionsDisplayName would be an empty string) - so would the error message be correct?
Code Style: Always surround blocks with curly braces, even one liners.
Huh? Item implements AccessControlled.
I think this will still not do what we need. :( MaterialUrl does not remove the password. HgUrlArgument does. It needs to be used in combination.
This should be changed back to forCommandline()
This is the replacement for [this](<LINK_0> We might want to consider --non-interactive at least.
Is this change related to supporting commit validation by plugins?
It may be worth expanding this to include say: + "who also have 'Push' rights on " + GitRepositoryManager.REF_CONFIG
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
The message is missing.
I would try to cover simple cases where the add method is invoked directly as well.  list.forEach(s -> otherlist.add(s));
I know it's specified that way, but I think it would be more interesting to only highlight the parameter.
In order to simplify the code and as we are doing this for start and create we could add a method hasProcessDefinitionIdOrKey directly in ProcessInstanceBuilder so that your condition becomes: if(processInstanceBuilder.hasProcessDefinitionIdOrKey()) What do you think?
I think CancelNodeInstanceAction is used in multiple cases, boundary escalation and boundary error events, not sure I grasp the meaning of TIMED cancel type in this context?
processInstanceKey.isValid() == false -> !processInstanceKey.isValid()
Size + speed - size = speed
Is there a chance of a NPE? could be getFile() null?
please make this private or protected,
You might want to use the more ugly path.toUri().toString() because the path.toString() tends to drop the scheme.
You can use a try resource here try (Writer writer = new OutputStreamWriter(new FileOutputStream(file), charset);) { writer.write(content); }
Would be nice to expose to the command line the option to not concatenate all the merged interval names. In the use case which prompted this, a TON of sites (think whole genome gvcf with bp resolution) are often merged into a single interval, which then has an outrageously long concatenated name. These concatenated names often don't carry any useful information, and can make the resulting interval list extremely large.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
@dmzaytsev let's extract this into a private final String variable.
@d-molotchko use String.format instead of '+'
you might want to make 10_000_000 a constant
You can replace the for loop here with values.forEach(result::add);.
I missed this, this should be using a StringBuilder. While no more correct, it may be more obvious to write: java StringBuilder builder = new StringBuilder(); for (int i = 0; i < array.length; ++i) { if (i > 0) { builder.append(","); } builder.append(array[i].toXmlString()); } return builder.toString();
What happens with an empty string as a value?
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
Note that all message parameters to the assertion functions are really just error messages displayed on test failure. Thus I do not think "Returns an empty map" is descriptive enough to assist with troubleshooting. Perhaps something like:  format("Expected the returned map to be empty, but got %s", entries.toString())  Also with assertThat and Hamcrest matchers, this assertion no longer needs a call to Collections.emptyMap() because the test conditions can be better communicated.  assertThat(entries, is(empty()));  Much more concise! And readable!
Usually for this it's reasonable to have a hasMessageContaining(...) to make sure the exception is what you want it to be.
extract as constant?
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
nit: you can merge both lines above as checkNotNull will return the given argument
nit: you can merge both lines above as checkNotNull will return the given argument
nit: you can merge both lines above as checkNotNull will return the given argument
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
Checking this is probably redundant now when we return an Optional<LabelMeta>?
Can you raise the log level here to warn? If the user tries to update a meta that is missing it might be nice to give a bigger splash about it being missing.
Can you make all of the accessors final?
should this be assigned to a field so that the same instance would be returned if invoked multiple times?
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
You don't need this null-check, the getJavaElement method already does that.
I think that CSSDOMSemanticElemntHelper should be an Singleton.
Missing finals for all tests in this file
This error message is kind of confusing. Perhaps replace it with, "Error in accessing DB.".
I don't think it's efficient to call "split" here, as all you care about is the last segment. You could instead call keyName.lastIndexOf('.') and then call substring using the index
Use key.getLength() everywhere here (instead of key.getSize())
Suggest unindenting for clarity: if (!Objects.equals(mIfaceName, route.getInterface) { return false; } int i = ...; if (i == -1) { return false; } mRoutes.remove(i); return true;
This will need to check the destination instead of checking for equality. See removeLinkAddress for an example.
I don't think we can change the behaviour of equals() like this. This class is part of the public API and changing equals() to no longer consider fields that were already in the object is a breaking change. Instead, I to handle this case where the route objects are "the same but with different properties", I think we should add another method such as isSameDestinationAs(). This is consistent with what we have done in other classes such as LinkAddress, where everything is checked in equals(), but there is another method that checks whether an object is "the same as but with different properties". (In the case of LinkAddress that is called isSameAddressAs.) Also, this should check the MTU.
~~The tests are not covering the bug that you fixed. I can change back this line and your tests still pass successfully~~ nvm, i realised my mistake.
We should add a check to make sure the end time is not in the future by comparing it with the current time.
missing value to replace {}
Probably we should log the exception here (debug or trace), just to help with troubleshooting
Probably we should log the exception here (debug or trace), just to help with troubleshooting
Are you sure you don't want to pass testClass instead of currentTestClass here? Passing the outermost class with @RunWith doesn't appear to solve #816
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
nit: extra line after if
Remove empty line
This has nothing to do here. You're invoking blocking code during plugin activation and wasting this instance
Can you replace this with the actual method name in the DiagnosisService?
Can you use the real method in the ConditionService?
I think Oleg meant that this code only takes into account AbstractProjects, it doesn't take into account, for example, FreeStyleProjects.
can you make the name more explicit? array doesn't indicate anything.
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
minor static import isWhitespace for readability
Met List:  @Override public boolean inputsAreConnected() { return inputs.stream().allMatch(ConnectionAnchor::isFullyConnected); }
this _could_ be shortened to Optional.ofNullable(jmxServer).map(JMXServer::getPort);
are spaces OK in namespace strings?
java ProxyAuthenticationType authentication = ProxyAuthenticationType.NONE; if (this.proxyConfiguration != null) { authentication = this.proxyConfiguration.authentication(); }
I think curly braces are missing and the formatting is wrong in the subsequent if (one step too indented)?
parentStepMap.containsKey(step.getId()) seems a better fit here.
why not use long and System current time?
We shouldn't use class names in JSON serialization. These are serialized permanently in the file metastore and thus can't rely on current implementation details like the Java class name. It's probably also a security hole. Anytime you see a remote exploit for Java and wonder how that could possibly happen, it's some deserialization feature involving class names. Since we only have a small, fixed set of classes, using @JsonSubTypes with logical type names should work.
Now that there is a need for only 2 types of evictions (size, time), I wonder if we could just do evictions inline on add? We wouldn't need a separate interface then. This would be the preferable approach. If you still think we need an interface for a pluggable eviction policy, it could be something on the lines of:  public class EvictionPolicy<T> { void evict(Iterable<TimestampedValue<T>> currentElements); }  instead of  public class ListGaugeEvictionPolicy<T> { public void elementAddedCallback(); }
Should be cached.
- new String(byte[]) without specifying a charset is dangerous. Although the default charset is supposed to be UTF-8 on Android, I would feel more comfortable specifying the charset explicitly. - JSONTokener is superfluous as JSONObject can construct itself from a String.
just curious why here returns new JSONObject, however, in previous test, null is directly returned?
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
Would be better to move this resolution to the afterPropertiesSet() if we can't inject an errorChannel from the @Configuration level.
IMO the logic that is now in the configure method of the properties class should just be here instead.
Why is the StepScope newed here? Why are we not just passing in the existing one (assuming you could pull the instance from the beanFactory...)?
Why absent?
Cache this value.
This can be static
suggestion
Nit: do you need these two lines?
this smells... never use NULL, never ever :)
Isn't errPct already a percentage? No need to multiply by 100?
won't this log bearer tokens?
this should use the redisRateLimiter variable in line 71
it looks like you have to adjust this one to your recent changes -> see pr build on travis.
static import array
Add PageLogging
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
If using Function<ClientBuilderImpl, T> for the build function type, instead of a custom interface, this method becomes return builderFunction.apply(this);
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
I think this is the same as this.newValue = newValue; ??
Why not check the flag directly on symbol then ?
Should not be public
Since Java 9 there may be [private](<LINK_0> methods in an interface definition. Now the difference between a class and an interface is that the default access modifier for the class is package and for the interface is public.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
return descriptorToImageData.get(descriptor);
ImageData for current image needs to be updated in the array?
this.
should be able to just call getValueGetter().
Return ImmutableSpongeListValue<Text> not ImmutableSpongeValue.
Please remove the maverick ";"
Check if parameter is null.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
extract to constant
We should add blank behavior here directly. A blank value should be identical to an absent one.
same here - result should be null
Wenn super.close ne Exception wirft, wird der Export-Job nicht geschlossen :( suggestion try (Closeable c = super) { exportJob.close(); }  Das try with resources macht intern ziemlich viele coole Sachen: <LINK_0>
This job appears to run forever
edit? We already have public <T> T configure(Callable<T> body), did not noticed when this sneaked in... Anyway, if you need different signature please stick with the name configure.
isEmpty here as well.
Use jobs#isEmpty instead of jobs.size() > 0.
How about just context since we have it?
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
Can you please also refactor file with name layout_list_item_with_menu.
The @SuppressWarnings can be avoided via: suggestion return convert(sourceType.cast(source));
this.sourceType and this.sourceTypeDeep
Qualify with this.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Is this needed?
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
This method was meant to stay internal. I know that from the perspective as the author of this class. It's re-used as part of other computations, it is not intended to be used by the UI.
Changes made on the returned scan object will be effective and visible beyond the caller. Clone and return?
Why JobContext here? And why not public?
Switch the order of getting the mean and filtering:  java segments.stream().mapToDouble(ACNVModeledSegment::getSegmentMeanInCRSpace) .filter(x -> Math.abs(x - 1) < 0.1)
replace this with java return scopes.stream() .filter(this::matches) .map(AuthScope::getProject) .collect(toUnmodifiableList());
nit: this is deprecated. please use throw new RuntimeException(e) instead.
Check for null
I'd rather not synchronize it here. It sounds better to check in the constructor whether config is null and instantiate the default object with new ZKClientConfig() in the constructor, in which case we can remove this if block from here, or at least keep it here just to assert that clientConfigis never null. If we do it, then we can also make clientConfig final.
Add requireNonNull
You can use e.ordinal() instead of e.value, and remove the value field.
I would suggest to change the name of skipRemoteGet() to something like skipFetch(). Also, change the name of the internal flag and the setter :)
I'd put the above line in the below method. The below method should only be used when a runToLine op is active, so it is better to check inside
Logging using standard output
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
Can you also verify the order matches
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Do we need to limit this to .in/.win for Makefile as we did before?
again accept boolean value
The method is "getItemFromRegistry", not "getItemTypeFromRegistry". Shouldn't the error message read "Unable to get item for item name {}" ?
Logging and throw is imho an anti-pattern since the caller will most likely log an exception that he catches.
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
Error message should be "Invalid URL format. URL: " + url
You don't need a local variable el, you can just do return TransitionTest.this
Not necessary
Not necessary.
Can replace with forEach.
foreach?
Is this still needed? If not, PanelControl no longer needs to know about the stage.
Should this be protected, or do we really want to allow to call it outside this class?
use equals instead of !=
I would suggest to add the overloaded method with accepts Bus bus, there are many places where it could be provided from context. What do you think?
Looks like these two typeTextIntoEditor commands can be united into the single command:  editor.typeTextIntoEditor("\n\nobject = MyClass()\nprint(object.");
from the readability point it's better to divide verification by given/when/then sections
**WebDriverException** is too general here. So, it would be useful to have exact error in logs:  fail("Known permanent failure <LINK_0>", ex);
use: import static org.hamcrest.CoreMatchers.instanceOf; ... assertNotNull(result); assertThat(result, instanceOf(ClassName.class));
Avoid superfluous calls to super(); like it is used here.
F... can you rename pair -> triplet real quick. This looks terrible.
Wouldn't have been possible to override the afterFromProto in the ForwardNatRule class, adding there any initialization code as needed?
Verify the generated body
Shouldn't this mean new rules get the lowest position (highest priority)?
Can just return this overloaded method's result rather than requesting the record twice.
several things: - never catch Exception unless it's explicitly thrown (always be specific) - why are you catching a QuadrigaStorageException if all you do is throw a new QuadrigaStorageException? - NEVER EVER swallow exceptions (once this is thrown, nobody can see from the log what the actual issue was because you just throw ex away).
I think with "L"ong (as opposed to "l"ong) you should use .equals instead of ==. Not 100% on that but I feel like I've been burned before by using ==.
The this. in getters are unnecessary too.
Maybe we want to keep something similar to what id was before
just return "" instead of new String()
onLowMemory is public, not protected
What do you think about using a telescoping constructor since one is a prefix of the other?  @Inject public LocalMemoryManager(NodeMemoryConfig config) { this(config, Runtime.getRuntime().maxMemory()); }
I would write it this way:  // We call memoryPool.getQueryUserMemoryReservation(queryId) instead of queryMemoryContext.getUserMemory(). // // Calling the latter would result in dead lock: // * A thread doing user allocation would acquire locks in this order: // 1. monitor of queryMemoryContext.userAggregateMemoryContext // 2. monitor of this (QueryContext) // * this thread would acquire locks in this order: // 1. monitor of this (QueryContext) // 2. monitor of queryMemoryContext.userAggregateMemoryContext
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Ditto here, if we have swallowed all possible exception inside close, then it is unnecessary to have another swallow here.
Capitalize Thrift (or remove the word)
1. Shouldn't it be new RuntimeException(e.getCause()) ? 2. Does this handle if e is IgnoreTransactionRollbackException and e.getCause() is null?
s/executed/execute/g or maybe even simplify this to "An exception was thrown by a Executor"
Use try-with-resources, to make the code more concise and to ensure that the reader is closed even if an exception is thrown.
System.identityHashCode would be more consistent than reader.toString in terms of making sure that the name never contains a massive chunk of information if toString serialises the entire Reader to a String
An abstract class shouldn't create instances of its subclasses. Could the static constructors be moved to a factory class eg. ByteRangeFactory?
ImmutableList.of
We might use a NavigableSet instead if a TreeSet is used, I assume.
defensive copy?
why public? Are we planning to use it outside of this class?
Please use CanDoActionAssertUtils.
If you have a parameter, caching the validator doesn't make sense - the API seems as though you can pass a DiskImage and get a validator for it, when in practice you'll get the same validator regardless of the param.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
do not remove checkClosed()
Can header name and value be null?
I think we should replace our new ArrayList<>(...) constructs with List.copyOf(...) especially when the list is immutable.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
null? why not just a () -> {} ?
should this count be parameterized?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Pull this into a static final variable
Would a constant Long.BYTES fit here?
Since you are using a PreparedStatement below, it would make sense to move this loop to migrateUnitsToCodedValue() method so that you prepare and close the PreparedStatement object once, it also means you can do the update once by turning off auto commit and commit/rollback everything in one go.
Instead of creating a new RateLimiter for each file deleted, we can guard the rateLimiter.acquire with the null check.
List#isEmpty()
List#isEmpty()
List#isEmpty()
if (!(value instanceof Object[]))
I would suggest reference.getEReferenceType() here, for pedantic correctness.
new Object[] is unnecessary.
There is already a string defined with the name dialog_action_ok
"our" => "out"
Can we add this to string resources?
This should be moved below the LogContext.checkAccess().
Add a constant for this
Add the check here.
I don't think we should call abortWorkItem here as the work item most likely won't be there as it failed to execute.
I think maybe job migrations can be moved into TaCoKitImportHandler.java? and we only need to add RepositoryUpdateManager.updateDBConnection(connectionItem, version, false, false); here?
Hi, you need to try to test this as well. otherwise looks good.
suggestion return Optional.of("org.junit.platform");
should be ofNullable
synchronized -- this class is thread-safe and guaranteed happens-before between producing value and consuming it
This changes logic paths for SSLD devices as well. Some time ago an UnregisteredDeviceException was thrown when a device was not _activated_. The change in behavior to throw an InactiveDeviceException in such cases has been discussed with @kevinsmeets. Now with the check on whether a device is _active_ the logic for throwing any exception does not take _activated_ into account. Updating and keeping a proper value (and meaning) for all these status fields (here isActive and isActivated) has to be clear (and tested) across all domains.
I think this works the way we would like to see the equals work, but take a look if you'd prefer the shorter: return Objects.equals(this.deviceIdentification, device.deviceIdentification); over all the null checking to see if the result is false, followed by returning true.
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: com.alliander.osgp.domain.core.exceptions.UnregisteredDeviceException, com.alliander.osgp.domain.core.exceptions.InactiveDeviceException, com.alliander.osgp.domain.core.exceptions.UnknownEntityException [![rule](<LINK_2>](<LINK_0>
should this say throws PatternSyntaxException ?
wouldn't this fail if pattern was null?
You must not init here the command. You configuration page should configure the pattern provider and it will instantiate the command on demand.
extract as constant?
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
maybe dataStore variable name instead of people?
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
Message may be null, add a guard check
add an import instead of using fully qualified name
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
should not be part of this patch
They are all TimeEvent instances in current implementation so TRANSPARENT can never be returned (it should for filler 'multiple' events)
Could be protected instead (and it could be defined before the nested class).
Can be static.
Why do you use the qualified name here and not a standard import ? You could also call Path.fromOSString(path)
ContainerUtil#getFirstItem
And  GoExpression expression = expr.getExpression(); GoType type = expression != null ? expression.getGoType(null) : null;  more readable
Could be static.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Can't really understand what's going on here. We multiply by 1,000,000 a millisecond unit and add it as a nanosecond? (it would _probably_ make sense if we divided instead of multiply, but then why not just do now.plus(resyncPeriodInMillis, ChronoUnit.MILLIS))
Upstream is already thread-safe, so this isn't needed.
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Why is this not return this.kind == kind ?
Better to use HitPolicy.getDefault()?
Please verify the returned can-do-action message is VdcBllMessages.GLUSTER_TASKS_NOT_SUPPORTED_FOR_CLUSTER_LEVEL
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
should we place the created command entity in coco?
Just for consistency, please use final boolean actual
Why assert here rather than assertTrue(..., message)?
you can simplify the code a bit... we don't need ok and forbidden results...  Just do a check Mockito.verify(ninjaDefault).getForbiddenResult(context)  or  Mockito.verify(filterChain).next(context);  assertNotNull and assertEquals is not needed imho... That makes the code a bit shorter...
my sense of beauty tells me that this code should look like the following:  guard(); try { verifyReadOnlyModeSupport(); ctx.state().changeGlobalState(readOnly).get(); } ...  Perhaps, verifyReadOnlyModeSupport should be a part of ctx.state().changeGlobalState(readOnly) method, I am not sure here.
You can also use IO.close(bb) as IO.close will not throw any exception.
should this be in a finally block to release in the case where an exception occurs?
What's up with this last one? Should it be in the finally block?
Maybe consider: suggestion final CountDownLatch latch = new CountDownLatch(1); kafkaStreams.setStateListener((newState, oldState) -> { if (oldState == KafkaStreams.State.REBALANCING && newState == KafkaStreams.State.RUNNING) { latch.countDown(); } }); kafkaStreams.start(); try { latch.await(IntegrationTestUtils.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS); } catch (final InterruptedException e) { throw new RuntimeException(e); }  Then, this method won't return until Streams is actually started, which we've seen can increase test stability.
Shouldn't you reset the interrupt flag after catching this?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
Please return time logging.
useSSL and sslPropertiesLocation must be propagated from here.
Does this method need to be synchronized?
Maybe we can explicitly ask Topic if it should be validated...
nit: not from this patch, but topicPartitionBookkeeper.topicPartitionBookkeeping is really annoying. Maybe we could rename the field to just partitions?
Use a concurrentHasMap, then you can remove the synchronized on the public methods.
I think each of these two constructors should provide examples of the querystring's they construct.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
You're conflicting with #631 :-O Shall I go pull some PR's?
I think JPA requires this to return a Long
Should use Long.class
suggestion return !root.getParameters().isEmpty();
Maybe this package symbol can be factorized.
![MAJOR](<LINK_0> Make "isSAM" a "static" method. [![rule](<LINK_1>](<LINK_2>
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
I would prefer to use String.valueOf(value)
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Can we not verify that the text boundaries are correct? Verifying that we simply set the boundaries on the text decorator is better than nothing but can we not ascertain the values that should be being set?
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
It just occured to me that good old Integer has a bitCount method which does the same, probably. Maybe that could be used? (It doesn't mention what it does with negative numbers but I assume it treats them as any other number.)
rename to dialogField
Please make the methods in Calculator non-static and rework the examples accordingly. I think it's fine to create the calculator as the _SUT_ in a field (in all affected test classes) as follows. java private final Calculator calculator = new Calculator();
Why do we need those lines? Unit tests are still green if I remove them.
Same trouble: what about this.myField = "";
Just "annotation", without nested "statistics".
I found this code called so many times during app execution. What are your thoughts about using a pre-compiled regexp to split the strings? private static Pattern languageSplitter = Pattern.compile("_"); and then use it with String[] opts = languageSplitter.split(languageCode, 0); Do you think that this will improve performance?
We have the two letter codes here only for backward compatibility and changing it will break it. I suggest we remove the two letter code for Japanese.
We need to mention some ref why we need to skip some of these languages.
This is not needed anymore... now you can just return id
Why can't you just return value here?
String.valueOf is only needed when the parameter isn't already a string, both Build.Manufacturer/Model are already strings.
Well, it'll work but, as I understand, it will hide an error if there is. I think the issue is in other place. Agree?
Consider 'not'
The original code is actually wrong. It should have returned false ^ fNot. There is also an error in the TmfFilterAndNode. It returns true when there are no children. It should return false in that case (^ fNot). I guess the unit tests of both these classes should be improved to test: - No child (expect false) - No child (fNot=true) (expect true) - All children don't match (expect false) - All children don't match (fNot=true) (expect true)
I agree hashCode() and equals() should be done same way, it should be changed for PackageMaterial as well
Please implement toString() to provide debugging state information for debugging purposes.
Please implement toString() to provide debugging state information for debugging purposes.
if service is not present it should throw error? same question to the other methods
each param in its own line?
Seems like just sending an empty Map here would avoid all the null and isPresent checks later. Thoughts?
Create your own session to make the property to be true.
I'd just use a lambda here: (rowExpression, level, session) -> rowExpression
Pass the result of buildFunctionTranslator(getFunctionTranslators()) into JdbcComputePushdown. The translator is a generic row expr translator. Create RowExpressionToSqlTranslator inside JdbcComputePushdown as the filter translator.
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
How about putting the condition in the 3rd param to avoid duplication?
suggestion if (build instanceof AbstractBuild) { // no expansion for pipelines expandedTargets = environment.expand(expandedTargets); }
suggestion assertSignalEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
suggestion assertErrorEventExecutionSet(emptyTopEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
should probably test for null delimiter and either ignore or preferably interpret null as "no delimiter" (the empty String)
General rule: no magic numbers. You might want to turn 0.01f into a static final class variable. This concept also applies to the 0.5f factors below, even if it's easier to figure out they are halving coefficients.
Could you keep it as it were? Thx
nit: consider testing st_centroid on a non-polygon shape ditto other methods which apply to a restricted set of shape types
nit: perhaps, test floating points as well: st_point(122.3, 10.55) Also, consider testing invalid WKT strings.
This looks like testDataFormat(COMPONENT); Please see other tests for sample
you can refactor this in a different patch to make less noise
unneeded else
The password value is also in the named constant above. Please use that instead.
I don't see the point of having a cancel action in a subtab.
are you sure that == (as opposed to equals) is OK here?
Consider changing it to "command.getName().equals("OnRemove")" so it will fit the 'else if'
we should log a warning here so that users who have wrong permissions on ~/.gitconfig by mistake have a chance to detect the problem
Here we should do the same null check.
> * git-for-windows seems to rely on XDG_CONFIG_HOME also on Windows Indeed it does (implementation of that function is in path.c). But I wonder if that is not a bug. I have yet to see a Windows system on which that environment variable is set :-) But OK, let's use it on Windows, too; with the same fallback.
Shouldn't this be !=?
response.status().code()
Update this method to also return true if status is HALF_OPEN?
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
Does not make sense. It should be @Nonnull, and the weird code in launch should be cleaned up.  java try { result.setStatus(procStarter.quiet(quiet).cmds(args).envs(launchEnv).stdout(out).stderr(err).join()); return result; } finally { try { result.setOut(out.toString()); out.close(); } finally { result.setErr(err.toString()); err.close(); } }  can probably be simplified to  java result.setStatus(procStarter.quiet(quiet).cmds(args).envs(launchEnv).stdout(out).stderr(err).join()); result.setOut(out.toString()); result.setErr(err.toString()); return result;  (If join throws an exception, there is no point adjusting result. If it returns normally, we can assume stdio has been flushed. And a ByteArrayOutputStream need not be closed.)
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
![MINOR](<LINK_2> 'Severity: MINOR') Replace this lambda with a method reference. (sonar.java.source not set. Assuming 8 or greater.) [![rule](<LINK_1>](<LINK_0>
I'd have thought "Case Management" was more akin to PROCESS than MODEL
log
Use a constant.
Should be originalContent.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Usually we use this. prefix only in constructors and setters, please remove if possible.
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
why not pass this in #init?
Is there a more descriptive name than element? if so lets use it if not no worries
This will throw redundancy warnings in IntelliJ
Local variable could be declared List instead of ArrayList. Is this worth caching?
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Consider using i18n for this title.
i18n
I realize that this was like this before, but can you make this title localizable like all of the others?
null case should never happen, since a chapter indicator must be there, please remove this.
Maybe a more descriptive Exception like UnsupportedOperationException?
Two tests in one method? Same for testFloatParseDefaultSuccess.
ObjectMapper is fully thread safe, we can have it as a single static variable inside this transformer class (also because we do not configure it differently per method usage)
Make this as a log.error statement. And needs to have space after the ","
Since stream is only a string this is not needed. This is required only when serializing List,Map, objects etc as Json strings so that it can be stored in a DB column.
Pass the FeedbackQuestionAttributes inside the UI template class and use.  feedbackQuestion.getQuestionDetails().getQuestionSpecificEditFormHtml(qnNumber);  > ---- Polymorphism :D
I think MCQ/MSQ also have other weights which we need to hide
Take a look at how shouldChangesRequireResponseDeletion is called. Do you need cast operation here?
We should either make sure that we use registerSticky() to receive the last posted status during initialization (and also ensure that the initial state is always posted during app initialization), or we should call this explicitly from onViewCreated() or some other callback for Fragment initialization.
style nit: no braces around single line
Listener not Listner (typo)
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
I wonder if it should be LFU or LRU.
Should be an == and throw.
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
And this one stays "display_name", not?
Oops!
Don't call row.getDimension(dimension) twice. Please extract a small class, don't inline. It's unreadable.
Why do we need null first? If null happens, we should just crash.
Better to use Comparator.naturalOrder(). BTW above in similar situation null-aware comparator is used. I'm not sure if null-awareness is needed.
For consistency, this should come from the Builder
Shouldn't this come from the builder?
I don't think this is required. Given that it has a no-arg constructor. Guice should be able to inject this.
Please remove printing to stdout
Let's please avoid code duplication:  public String toString(boolean shortenTypes) { String type = getType(); if (shortenTypes) { type = shorten(type); } return getName() + ": " + type + " = " + getValue(); } @Override public String toString() { return toString(false); }
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
use static import.
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
Is this going to be shown to the user? In that case, you may want to say 'Error in filter'.
Use StringUtils.isNotEmpty instead
just return directly, no need for packageName variable
need log parameter in your string
this can be replaced by getGroups().forEach(group -> cache.flushGroup(group));
What is the point of having _both_ these statements?
When we call stop this map we might wanna empty this map. WDYT?
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
I don't know about the prior art much, but it seems more idiomatic to use Message for everything and rely on headers to convey correlation data. Maybe a custom implementation of MessageHeaders would be better? Or just a helper that knows about specific sleuthy header names.
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
this should be private static function.
Why are you changing this constructor to public? We have a PosDataCode.valueOf(byte[]) factory method. I'm OK with the null validation, but don't understand why we need the public constructor.
It might be faster to use Math.min and Math.max here.
Why is this returning null?
and returning based on an interface rather than impl class?
create an Immutable copy of the clientMetadata and assign it. java this.clientMetadata = Collections.unmodifiableMap(mutableClientMetadataMap);
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
Generally with these kinds of constructors you'll end up calling the other constructor directory, passing in null for the ignored param.
No need for this.
I'm pretty sure BasePanel also has already the dialogServie object
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
maybe test first char for empty letter as well to reuse s if possible?
Get the service registration reference and unregister within the deactivate method
Should this method be in the account object instead? Something like isRegistered():boolean?
nit: might want to rename it as signalShutdown or something to indicate that this method will be called before shutdown.
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
isn't writeFlags a thing of PendingAddOp? if so, it should be passed in when constructing PendingAddOpss.
should this count be parameterized?
This line could merge with the next line, making the next line return new UID(requireNonNull(v));
Or judge null place here ?
the 10000 looks like a wrong digit.
declare throws please
it also throws other runtime exceptions
for me it's too long. Maybe Result.wrap() ?
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
@prondzyn Let's use UnsupportedOperationException instead, to avoid importing from commons-lang library.
Why does it return void?
You can remove this since hasNext will call checkInvariants
this class should probably also init current in the constructor, then we can just do if (current == null) { throw new NoSuchElementException() } here
Lack of synchronization on hasNext() whereas next() is synchronized looks looks very suspicious for me.
warn maybe? and not sure if we want the exception. maybe just the message?
tried to add blacklisted host {}
Very often this is TimedOutException or various Thrift-based things, though I don't know if this one is still useful for debugging?
can we avoid passing null here? and introduce constant like IndexOrder.NONE for that instead?
This is fine but I would prefer iterators[i++] since that is a much more common style in the code base
maybe it would be simpler to handle this case right after #927 - if numOfPinnedCpus then then block of #930-#931 is irrelevant and #933-#934 is not interesting.
no need to change at here, because it is only for Date type
constant or lineseparator from system?
missing @Override declaration.
does this need to be calculated on the fly each time or can we save the iterable?
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
:+1: Seems like a reasonable strategy here.
No parens on condition.
IMHO, for things like variable naming, local consistency is arguably more important than global consistency, so naming this e is best. If we make a global change, I would prefer to rename variables of type Throwable to e
Use logger?
Cosmetic: Our loggers across the codebase are lowercase. Could you please change this? Thanks! :)
Why is there a fromByteArray method? Why not call the constructor directly?
this class doesn't have tests?
this class doesn't have tests?
What does the above line mean?
Since the event is really a resource rather than a model, it would make sense to me for this to return the event resource instead. You can get back to the model in other places if needed by calling .getModel() on the resource.
better use a ? b : c here
... two non-equal objects can have the same hashCode! :(
Use Objects.equals() to handle nulls concisely.
(Rather than a bunch of IF statements, you could do this all as one return statement w/ && for above.)
I'd guess that findbugs (the reason for the build breakage) is complaining about the unsynchronized access to diskLruCache here.
You can also use IO.close(bb) as IO.close will not throw any exception.
Avoid printStackTrace. At first glance you can just throw a ResourceException. However you can avoid all of this by changing the base close method - does it really need to throw Exception? It looks like it doesn't need any checked exception thrown - which means it won't need any override in extending classes.
We'll probably need to move this return out of the catch-block if we're going ahead with this. I'm guessing currently we get an NPE that blows up, so the change makes sense in general.
Let's use custom exceptions instead of RuntimeException.
This will silently ignore the exception. Should be throw Throwables.propagate(e);.
Not sure if this is supposed to be a Long instead of long?
should we return a default here? anyway, like using the first sample offset?
This iteration is not protected against ConcurrentModificationException. At least 3 possible solutions: 1. synchronize on fOtherProviders 2. only iterate if fIsLoaded is true (the list won't change anymore) 3. use a CopyOnWriteArrayList (iterate on old copy if it's being changed concurrently)
Why should we need this logic? The logic, including the null check and duplicate check have implemented in org.apache.dubbo.config.context.ConfigManager#setApplication. Why should be added it again? So as the other change in this file.
Usually @Override is on the line before the function
"Magic" here was just a quick and dirty way to assure modules and stuff are loaded before running the tests - could you check if it is still needed and remove it if not?
What do you think about keeping "<LINK_0>" in class variable also?
private static final for magic numbers
@manuelplazaspalacio a domain should protect its invariants and throw exception when an action is not allowed according to current status. So if login is disabled and addFailedAttempts is invoked should throw a domain exception, for example: new ActionNotAllowed("Add failed attempts is not allowed because login is disabled")
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I see that we use this in other methods like getGeneralSettings but there is another get method that doesn't require params, I think we should be using that. Creating an extra map like this doesn't feel good.
sb.append(item).append('\n');
return getCodecA() != null && ("ac3".equals(getCodecA()) || "a52".contains(getCodecA()));
Nice, but AFAIK MediaInfo is not able to parse it...
If i remember correctly, getCodecA is now set in lower case so IgnoreCase is not need anymore.
can be inlined
it's a bug, we should throw UnsupportedOperationException when a method is not implemented
I think CancelNodeInstanceAction is used in multiple cases, boundary escalation and boundary error events, not sure I grasp the meaning of TIMED cancel type in this context?
please leave it that way - it's intentionally referencing the deprecated version.
Could we provide a more informative message here?
Based on my understanding, calling getOrCreateSession on StreamInitMessage or IncomingStreamMessage is guaranty to return a StreamSession and calling getOrCreateSession on another type of message would throw an UnsupportedOperationException. By consequence, it seems that this null check is useless. Am I missing something?
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
Instead of comparing the types via toString() it might make sense to let the Eclipse IDE generate the hashCode() and equals() methods.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Forgot to set set concept on this order
You need to check that other retireable related fields at are not null and that they were null before i.e dateRetired, retiredBy, retireReason
Same here, you need to check that retireable fields are not null and null after
You may use FileUtils.contentEquals instead.
Don't put any logic in the descriptor, it should be pure data. Do everything in the caller.
When we are on it: The catch(e) throw e is unnecessary here.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Why there are things that are irrelevant to this PR? Although we need sanitise field here.
This mean anyone can get anyone else's student profile? Should have a check if it is the same as userInfo's ID.
The student can be an unregistered student so googleId can be null or empty.
Seems this can be simplified to just call super.clusterConfig and then invoke jmxStatistics.enable().
I believe we have to set the storeName when using shared store, otherwise data won't be shared properly.
Ouch, default MAX_RETRIES is 30??? To me even 2 is excessive in a test :)
Can we stick to just probes? So name it scheduleProbes?
Wrong class (TaskService?)
Why are you synchronizing on FilterService.class and not on ImageService.class as you are inside ImageService class?
Shouldn't we add the Transmit options field here?
Could be reframed using Collectors.toMap(TParameterDTO::getName, TParameterDTO::getValue)
Did you mean to remove this println?
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Not sure if you noticed, but you can use a different notation here: suggestion return Optional.of(path).filter(Files::exists);
lowerCase variable
could shorten this to  java return numInFlight < parallelism && replicaIterator.hasNext()
Again, just return the boolean value.
Binary output length can also be calculated.
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace "maxLength + 1" with just "maxLength".
use return ... ? ... : ...?
Should this return getDefault(); instead, so have the default specified in fewer places?
Why not reuse existing? public static Type valueOfIgnoreCase(String name) { if (name != null) { return valueOf(name.toUpperCase()); } throw new IllegalArgumentException("Invalid value null"); }
Modifier 'private' is redundant for Enum constructor - needs to be removed.
This could all be replaced by java return ExtensionList.lookupSingleton(OldDataMonitor.class);
I'm confused by this. Why don't we convert it to the TypeMap once in a private static method? So change jsonData to typeMapper and have a method like this to get the initial Ds3TypeMap object:  java private static Ds3TypeMapper initTypeMapper() { final ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new GuavaModule()); final InputStream inputStream = Ds3TypeMapperParserImpl.class.getResourceAsStream("/typeMap.json"); return toMap(objectMapper.readValue(inputStream, TypeMap.class)) }  Then the constructor becomes:  java public Ds3TypeMapperParserImpl() throws IOException { this.typeMapper = initTypeMapper(); }
Sure, but the only function called in the constructor does not throw an IOException.
nit: I'd make a constant for foo-test-invalid.json too
Please only use asyncAdmin for async operations, like createTableAsync. All synchronous operations should remain as they were before.
For consistency: Could you please remove "this", or add "this" to other calls to instance methods?
Isn't this a bit dangerous? If we're in a network without dns "Unknown" will be all over the place?
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
I don't think this check is relevant
Why is this check necessary?
better to return an Empty Map, otherwise callers would need to check
Did you mean to remove this println?
suggestion .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
But for this case, it will lose numbers under a decimal point.
Could this (and other occurences in tests) be changed to Jenkins.get?
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Gson doesn't run on these versions so I don't see any reason to include them.
You can change the 28 case to a default case, and remove this.
I think the underlying registry/restClient will return SchemaRegistryClientException instead of SchemaNotFoundException in this case.
It should be more general I think, e.g. entityNotFound. What if the exception will be thrown during getting other object types from db?
You'd better use a logger here to ignore the exception or propagate the exception using Throwables.propagate
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
Should we return here?
Is there a reason you can't use the strings.xml file for this?
It's better to introduce Pull.STATE_OPEN and Pull.STATE_CLOSED and use them
I don't think that Exception can ever be thrown by this method
Maybe you didn't commit it?
Should be "InstaPost" actually.
If you have commons-lang3 in your classpath, you can use ToStringBuilder
Is there a reason for not using the MoreObjects.ToStringHelper instead?
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
style nit: we don't use braces around single line blocks
Please remove isEmpty() check. Null check should be removed too, but the comparisons should be made null-proof.
Shouldn't these methods be on the ResourceCollection?
lets address this as well.
Here, we need to check value also along with key. A case like createBucket, DeleteBucket, we will have the key in the cache for that bucket, but with the value null. And also is this isExist will be called with the lock? As someone can modify the same key while checks are happening.
suggestion blobSoftRef = (BlobSoftRef) field.get(accessPath.apply(descriptor.getReferenceInstance()));
I'm confused. Which of these catch clauses is the expected one?
In Druid, I see us throw RE which extends from RuntimeExceptions why did you choose to throw that here instead of RE? I don't know which one is the right one to throw...
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
Weird sentence structure. Why not Illegal choice for parameter foo: bar?
IllegalState?
This should be synchronized for reliablity as there is no AtomicReference.
this _could_ be shortened to Optional.ofNullable(jmxServer).map(JMXServer::getPort);
Collections.emptyMap()?
using Arrays.asList create a fixed sized list, so doing later getTo().add(something) will throw an exception.
one line this --- getData().add(toAdd);
This from field appears to be redundant, as this is an inner class.
It is the same in this line, leave a blanck space before "+"
IllegalArgumentException?
Not a big deal, but Preconditions class would be cleaner.
Extra space after synchronized.
make function synchronized. Res: done with syncronized block
Does this need to be a singleton?
The same Arrays.stream() can be applied here as well.
These two guys, can be replaced with a single toArray(Queue[]::new) The map() above can be also a method reference: map(Queue::new)
map(Queue::getActualName)
Wrong event name and bi value is getting passed here. It should be **VIDEOS_UNIT_DELETE**
remove ;
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
Why wasn't this left as-is? I'm fine with it, but it just didn't follow the pattern of the rest of the PR.
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
Can we just pass this in via an additional constructor parameter? No need to introduce a mutable state.
Please update this string to say "developer mode" instead of "debug build".
BasicMessages have no type property, so just use empty string for logging the message type (the second parameter in this method call)
Do we really want to move this from trace to debug?
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
Should check that the environmentTracker is not null
Is this ever actually reached? It seems to me we only have a lambda declarator associated with CPPImplicitFunctions, and CPPImplicitFunction overrides isConstexpr().
Since DeclarationKind.METHOD is a enum, I would compare it simply with == or directly != in that case.
Missing final
This will throw redundancy warnings in IntelliJ
Seems to be a compilation issue here, new ArrayList<>() should be new ArrayList\<String\>()
There should be a null check on the identityProvider, prior to calling its getRoles method. Maybe something like... List<String> roles = (identityProvider != null) ? identityProvider.getRoles():null;
Minor thing: please use "something <operator> null" convention.
Minor thing: please use "something <operator> null" convention.
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is != locale.
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
suggestion return fileSystem;
I would move this log.info out of if/else let it be logged :))) What is wrong with ENV variable? currently you can set the DATA_DIR in your auto start script and it will work forever In case of applicationContext.xml it has to be patched after each upgrade ....
please decrease or remove this statement
please remove this statement or enhance it to something more context/meaningful
please decrease log level to trace or better remove statement
This should make a defensive copy of the list.
this.clientTags = Collections.unmodifiableSet(requireNonNull(clientTags, "tags is null"));
nit: I find this one easier to read  requireNonNull(clientTags, "clientTags is null"); this.clientTags = ImmutableSet.copyOf(clientTags.orElse(ImmutableList.of()));
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Again, perhaps I don't understand the Java API, but IIUC client.flush(...) is explicitly telling ES to flush all memory associated with an index to storage, and that ES tries to do this automatically. If we have to do this, then commit() is definitely the place to do it. But is it really required? Do we want to force a flush to get the durability of the write to disk?
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Should be externalized.
label should be externalized
label should be externalized
please remove or decrease log level to TRACE
remove
remove
> It's a 32 bit signed integer, so any value of retries exceeding 31 will cause the value to overflow. Yeah you're right on-I was raising a question around the implementation of the back-off in general. (EDIT to add quote)
Why do we have min() within max()?
Nano time is prone for overflows. Millis should be fine.
For DTLSConnector this is configurable. I do not know whether you have given configuration of the TLS connector much thought yet ...
I'm not sure that we should reuse UnauthorizedException for TLS handshake failure as well as for actual login failure. The Python driver uses ServiceUnavailable here but that doesn't seem quite right either. Perhaps we should have something separate such as SecurityLayerUnavailable?
No reason to get the cause.
Might be worth having a displayName?
please move to static field. suggestion return "PROCESS DEFINITIONS";
Is this supposed to be <code>return "Bump"</code>?
I think this can be set by spring application.properties without creating bean explictly.
H-m. Why don't call ThreadPoolTaskScheduler.shutdown() in the actualShutDown() instead?
??? Does it work? Really it has to be super.. IDEA shows the recursion for me
I guess this will overflow maximum instructions per method before FIELDS_PER_CLASS is reached? Again, I wonder if it would be good to generate multiple companion classes.
INITMETHOD_ACC works here, as the JVM ignores everything beside the ACC_STATIC flag. What about a separate CLINIT_ACC constant?
Pass a new Properties() file here.
looks like you don't need these three variables at all. Just use this at line 41?  java List<String> boardNames = TestController.getUI().getPanelControl().getAllBoardNames();  You can probably follow it up with this (not sure)  java assertEquals(boardNames, Arrays.asList(new String[]{SAMPLE_BOARD})
Is this still needed? If not, PanelControl no longer needs to know about the stage.
This better be inside of the createPanelFooter method? Since it's a subcomponent of the footer.
Should also include context and suspend
Should be "InstaPost" actually.
Lately I've been generating toString() with the "String concat (+) and super.toString() template in AndroidStudio - that way we'll get the Id field logged as well which can be pretty important for debugging
Should use the log, maybe a warning.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
I believe the Sanitizer call is not needed here.
Sanitize the text here instead? Can also consider using sanitizeForSaving() if you would like to keep the sanitation process in the build() method.
It seems like we already have the function for this purpose, after all. See if this function differs from the newly defined sanitizeForRichText, and if we can decommission one of them (i.e just use one function for all purposes).
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
I think that you need to use integration test helper to create and cleanup shared test bucket.
How this else block is possible?
If you build string at runtime, you need to wrap into the logger.isDebugEnabled() condition.
Ok, but shouldn't this be somewhere earlier - possibly as a classvar or static so it gets reused?
why is the first parameter a LayerCommand if we only need the resulting Layer?
This and other setters don't have to be public, could be private.
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
Position position position.position. Hmm maybe there's a better name for some of these :thinking: Just thinking aloud, not the end of the world :+1:
As mentioned in Slack, you send the CloseDoorEvent in both logic branches, I assume one should be open?
I think this class is a better place to convert the prefabs/entities to readable names, i'd expect little to none logic in events but in systems instead. Move the two conversion methods from the event to this system.
better to set it to the default and log a warning
Really minor: if it is possible for 0 to be passed through and throw the IllegalArgumentException, the error message should say "must be greater than 0" rather than "must be positive".
Can't we have a confirmTimeout initialized with DEFAULT_CONFIRM_TIMEOUT by default? I see there is a logic where if (this.confirmTimeout != null) though, but why then just don't return that null with an appropriate @Nullable on this method instead? I think that way we would have a consistency with the current logic and what is possible with this getConfirmTimeout() in the inheritors.
why callback is null
replace PutBlobOptionsBuilder().build() with PutBlobOptions.DEFAULT?
I hope you plan to work on logging and metrics in a different patch. We need lot of trace logging in general.
Unnecessary, booleans default to false.
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
These begin events should probably follow argument validation, not precede - if an exception is thrown on the line below, your observer will be left in the begin state.
Minor inconsistency: Return type is Boolean and not primitive boolean
don't need to wrap safeFormat
These are only used by Group. What's the motivation for defining them in Control? Will they be used by other widgets also?
This fails for me, I get 25 visible rows. I don't think you can be sure how many rows and columns are visible, we only set a fixed size for the Shell. Then how many cells fit depends on the OS and graphical toolkit (probably due to different system font sizes). So we also have to be careful that whatever cell we interact with is always within visible bounds. For example in this file we use up to row 14, we don't know exactly how many rows are visible but it has to be at least 14...
Should this throw IllegalStateException? Seems like bug case.
run already called tally, so do you need to call it again?
here originally TASK_ID was being passed, now null
I'm iffy on having this here. This is partially because we let the status update handler write to pending tasks, and partially because it means we are reusing a pending task id. Generally we let the SingularityScheduler do all of the work of creating a pending task to keep responsibility for those types of operations separate. We actually removed bits from the status update handler a little while back so that it would avoid mutating the pending task queue. Instead I'd suggest using requestManager to add to the pending request queue. This will let the scheduler do it's normal thing and rebuild a full new pending task with new unique ID from that pending request
times(1) is unnecessary (verify(taskList) implies times(1)).
nit: public static void But public here is irrelevant. Its only as visible as the inner class, which is package access. You can skip the public keyword.
may be we should assert on get() > 0
Shouldn't it be priority - Thread.MIN_PRIORITY (which is the same as priority - 1, but just by accident)?
I'd like to see our Throwables.throwingOnlyUnchecked used here
If we are not implementing, can we throw upsupportedoperation exception ?
I think this should just return null, similar to the default MyFaces implementation of InjectionProvider.
what about putting this in the default: case of the switch (switches without default, you know...)
what happened to handling of nullables?
I'm surprised this is necessary. The regular check: if (!lhsDataType.isComparableTo(rhsDataType)) should cover this. Why doesn't it?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
return tags;
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
I haven't investigated what exactly this does, but it looks a bit weird. I can understand if by default the logging level should not be DEBUG or so, but I would definitely like to see errors and probably also warnings by default (i.e. without having to investigate how to change this manually). Please disregard if I missed something.
Add .omitNullValues() before the toString() call
Style-nit: We don't put {} around a single statement.
We can replace this with: return date.getTime() / TimeUnit.DAYS.toMillis(1);
any clue on how this number was chosen? Is it an absolute or relative value? I think we should preserve the existing behavior by default, since most production deployments are constantly adding new data anyway, in which case it doesn't necessarily make sense to stop rebalancing. Also, even a small number may cause very large clusters to completely stop rebalancing because the incremental improvement is typically very small.
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
It worth to check which mocks were executed. Use when(modelMapper).should()....
Should this be userRep.getUsername()?
Matchers.is
Sort of believe We should have MetricManager in parameter given this case.
Needs a fail() after this statement, otherwise test will pass even when metricsRegistry.collect does not throw AssertionError. Also, annotate the test with @RequireAssertEnabled to ensure assertions are enabled.
Because there is only one argument, we can pass workerMetrics instead of an object array.
add a message in case it ever fails
add a message
It seems like this happens even if there is no filter. Is that right?
> "When providing an 'async-rest-template'... Correct? To properly reflect the reality.
In this case, and please consider if this can applied also in other *Handler classes, i think we could avoid using $ to build again the objects for the XML and use, instead, String message = element.getTextContent(); to get the value.
Why change from the constant to a literal here?
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
suggestion assertNull(migrationService.getMigration("fake"));
M-m-m. Doesn't it work for the particular StreamClosedEvent type?
I don't think this is correct for nested object structures. Suppose we have the following class structure:  java public class Person { private String name; private Address address; } public class Address { private String city; private String zip; }  Translating this to JavaScript/JSON should look like this if both, Person and Address use the JsonToStringStyle for their equals method:  JavaScript { "name": "Peter", "address": { "city": "New York", "zip": "10026" } }  If we apply this fix, the result will look like this:  JavaScript { "name": "Peter", "address": "{ "city": "New York", "zip": "10026" }" }  Note the additional double quotes around the address object.
'\t' is used more than once. Create a constant for this.
@chrisgioia64 Pls use StringBuilder, which is faster!
You can make this a bit cleaner by calling data.isData() and data.isHole().
Should we clone this? In other APIs we usually make a copy of the byte[].
Rather than signaling this condition via an exception, maybe a better approach would be to have a globally unique instance that signals a hole.
similar as for migration service ... throw the not found exception from within the service
Mhhh .. not so nice ;) Can you fail the test in that case? Or rethrow the exception?
this method still only supports one layer of children.
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
The implementation of this new method now depends on a deprecated method... I usually use already the new implementation and delegate from the deprecated to the new one... (I know, we'll change the impl of isArrayType() in 7.0.0 to use the other AST nodes).
Think I like the camelcase better here. When they're different words, it's easier to read.
can this be readSafely instead of readBuffer so that read uses readSafely
We could shorten to one line return Optional.of(new Context());
we were supposed to transfer taskBytes only, but we transferred everything
Missing final
I don't get it. Does this just silently proceed when the user is removed?
Why the errorCode checking (null != errorCode) here is not the same in HttpEvent.java (!StringExtensions.isNullOrBlank(errorCode))?
Better to create a new set, rather than update the super set. The super set might (and should, I think) be immutable.
Good to specify a constant field externally in a Constant class, rather than use a String constant directly; easy to trace and understand.
This isn't right; requiredFields should be the names of fields that this aggregator is going to read, but makeFIeldNamesFromFields returns the output names. I think switching that to getDimension instead of getOutputName would work.
Can be static.
This check is in twice
can't you just use "scriptFile" instead of the second call to "huntForTheScriptFile"?
Unfortunately that will not work in the BATCH mode we will introduce shortly. In BATCH mode the currentMainOutput will ignore all watermarks. At the same time we should still emit MAX_WATERMARK in the BATCH mode.
Do we need to change these? The AscendingTimestampsWatermarksTest should test the AscendingTimestampsWatermarks class, and not be coupled to the WatermarkStrategy class. An indicator that the scope of testing is off here is the () -> null lambda needed to instantiate the class to be tested, even though it has nothing to do with the tests.
This class is not thread safe. Using synchronized here is unnecessary and I think it is also misleading.
Since we never try to recover from the error later on it would be best to let exceptions be thrown from the init(). That way the ActionHandler is not available for use by the frontend and we don't need to check if the services are initialized correctly for every request on preProcess().
I'd prefer to log a more descriptive error (again e.getMessage() can be null). Maybe this should be: log.error("Error deleting Relationship specified by ID:" + id, e);
When you bind here, you can hold a reference to the service so that this can be non-static. Also I'm not sure all the static access to the service is needed (regarding MigrationDownloadServiceBinder), you can check how is done here <LINK_0>
Is there any other ID we have in relation to an envelope? Why do we need a longer name in this context?
This and other setters don't have to be public, could be private.
I don't see the point of having a cancel action in a subtab.
Indeed, that is better than my suggestion. Let's do this.
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
Isn't this a bit dangerous? If we're in a network without dns "Unknown" will be all over the place?
Gson doesn't run on these versions so I don't see any reason to include them.
You could save a few lines by moving the return null into the default case instead of break.
You can change the 28 case to a default case, and remove this.
Bad variable name! Variable names should be clear enough. Rename it.
This should probably go to System.err, as goes e.printStackTrace()
it's better to show any API call with this access_token
That 3rd one is a weird condition: I cannot add an attribute "0" (the tid) as a subattribute of "0" (the cpu) it throws this exception. Since the asserts did do nothing, I never noticed before.
newVmStatic ?
Please move it to "else", it is better to have one return point.
Hey @mjsax . Sorry, but I didn't follow this change. How does this test pass when it expects the value to be 7, but it's now 3?
Since you don't need to check anything in the exception, you can use @Test(expected = SamzaException.class) and then you don't need the try-catch.
Better to do ((ManagementContextInternal)getManagementContext()).getBrooklynProperties(). It effectively does the same thing, but we know we can always cast to the "internal" version (whereas casting the return value of a getter isn't guaranteed moving forwards). Also, you can use .put("foo.bar.baz", "quux") rather than needing the map.
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
Probably want to assert the behavior of the iterator as well
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
these should be 2 separate tests
This is also a problem on linux. When leaving /dev/null it works.
maybe add log here
@manstis I don't understand the Range details, just suspicious to me why we do not return result of selectHeaderMerged.
Should there be a way to query this state without relying on an exception being thrown?
Why does this throw an exception for the filtering mode? The reader mode doesn't matter to this. It either has a starting index and row count or it doesn't. I think a better API would be to avoid throwing an exception by using Optional, Long/null, or -1 to signal that the page can't report this. Throwing an exception can cause a runtime error when an expectation isn't met, while returning an Option forces callers to handle the case where the option is empty.
Is that down-cast required?
It seems asymmetric to allow returning a null Integer for getMaxConcurrency, but setMaxConcurrency only allows a primitive int which cannot be null. Is it meaningful for the max concurrency to be null? If so, how do you clear the max concurrency?
Because the failureCounter is incremented at multiple places, it would be easier for test fixing to use a failure log which you push a message to. It doesn't matter much for the completeness of the test though.
This should be obtained from the i18n file in case there is a language specific reference. The solution should actually provide some guidance, this CS could be added to the references.
This should be obtained from the i18n file in case there's a language specific reference.
If this is not used you might want to throw an UnsupportedOperationException
ConnectivityManager should not be modified on this issue, please merge with <LINK_0> branch again that has this changes and resolve conflicts
Optional (and I know we're inconsistent elsewhere): createObject().cast().
use the helper method for enum ancestors here
vus always has lastEdit?
It's better to catch each expected exception type here I think. Or, maybe move the exception catching logic to strategy.validate() to keep this code simple.
Should it be Map?
I think what we want to use here is base64url without padding (defined in RFC 4648). General base64 uses / character. = in base64 is padding which is OK to remove. You can build this variant of Base64 using Guava: java import com.google.common.io.BaseEncoding; BaseEncoding.base64Url().omitPadding().encode(projectName.getBytes(UTF_8));
We don't want hostnames\IP's in the labels. So need to cut URL either until any IP or first dot in case of custom DNS.
Better to add checkNotNull for the arguments.
This should be synchronized
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
isDebugEnabled
does eventTypeService.get throw other exceptions?
Symmetry (throw)?
you do not need InternalNakadiException on line <LINK_0>
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
Same as tapSource != null
Nitpicking this change here - isn't this antipattern?
suggestion bean.setSourceList(new ArrayList<>());
IMO the logic that is now in the configure method of the properties class should just be here instead.
What is the nullness contract here? Also missing docs.
The onInsertRow*(..) methods differ only in the index on the last line.. Might be better to extract the common code.
a message would be good here.
a message would be good here.
You can call this.setTimestamp(timestamp) from here.
Should we keep the same coding format and change it to: if (enabled) { ... }
Unrelated to this patch. Again this is a good change, but it adds diff noise.
remove when the export button is implemented
Don't throw the exception. It causes a lot of exception stack traces printed on the screen and stored in the .log file. It would be easy for the user to miss the usage message that is printed as well. I suggest, to find a different way to exit the application. Can't you just call CliParserManager.getInstance().parse(Platform.getCommandLineArgs()); in Application.java and exit if needed? I don't see the reason why it's done in the activator class.
please add activator ID in error message or a description of the conflict
No need for super()
How about sticking following the Optional orElse( ) pattern? Staying with Java's names and Optional idioms gives more flexibility and it's a bit more familiar to users.
For HSB and Percent type you already call the other constructor. Perhaps we could use this(""); here
java "MetadataImpl{name='" + name + "'}";  would be simpler
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
Consider overriding equals and hashCode as well.
remove !
(minor suggestion) I think this func along with projectLeafTypes can be combined into one to make it more clear: private static GroupType buildProjectedGroupType(GroupType originalType, List<String> groupPaths, String currentPath) { .... }  Perhaps return null if none of the group fields get included.
Maybe this should be getOrDefault to avoid null returns.
Not sure this is right unless it's only supposed to work on *nix.
What happens here when mergeOldAndNewHistory() returns null. Looks like it will fail in writeHistoryToFile() later.
I think we should TRY to move before we update the file path
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
Are there mandatory parameters which require validation?
do "getEntity(id);" here to throw 404 if this is not existent entity
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
I would make that example a bit more evolved, getting the TTL and only if different than default above set it.
Did you consider assigning the cache field to a local variable and return it instead?  Cache result = cache; // Do double checked locking return result;  According to [1], perf gain can be 25%, wonder if this still holds for modern JVMs [1] Effective Java 2nd Edition Page 284
What do you think of adding some errorMsg in the page if a user without ADMIN permission tries to access this page?
Const.ParamsNames.ERROR was previously used to colour the status messages red, is it still used?
I barely understand how this is working, Content-Type is a header present in the response how can this affect cache negotiation?
And ATMOS ?
isSecure() return true if "coaps is used and false if "coap" is used. The naming is not so good with the OSCORE addition (so maybe we need to rename it but later.) So in this case isOSCORE should not impact isSecure()
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
pls format (>120 chars)
so do not resolve groups and no recursive as you going to search it anyway.
it is not the best solution. Try use getDetachedField to retrieve roles object
Looks like this toString() got generated before the tags field was added :P
bad selector
this only needs to be package visible
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
I think we don't need to change this.
Bolt and Neo4j could probably share most of this implementation by using RemoteStatement but I suppose you thought about it and preferred this approach?
.event() is might be better
This seems unused.
Empty line, also it could be better with more fields (use your ide toString generator).
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
We could compute this only once in the constructor right after setting mRootDirectory.  mRootDirectory = rootDirectory; mIsExternal = isExternal(rootDirectory);   private static boolean isExternal(File directory) { ... }
Nit: coding style, add spaces around keywords
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
Use Enums.getIfPresent like in the previous enum or change that one, but make the code consistent using the same pattern when addressing the same thing.
Could use java.lang.Character.MAX_RADIX
There are different ServiceId objects with the same serviceId field? e.g. that contain different aliases?
space line
suggestion
Could we remove the need to cast CallContext by changing the field and its getter and setter to use CallContextImpl? That way, we could make a guarded cast when assigning the field. On an unrelated note, could all getters and setters that don't override an interface method have package instead of public visibility?
This method should handle the callContext field, not the callContexts (aka callContextQueue) field. The while loop could be simplified to: CallContext callContext = getCallContext(); // a getter for the single field and not for the queue while (processOutput(callContext)) ; While BulkIOEndpointCallerImpl has a getter for the callContexts (aka callContextQueue) field, I believe it's missing a getter for the single callContext field that subclasses could use as in the revised while loop sketched above.
The aforementioned "never return null" rule would be good for all the string getters here.
we prob want to default to something generic
I think the code style suggests the annotations should be above the methods.
@Before / @After could overwrite System.out :-P
This looks like testDataFormat(COMPONENT); Please see other tests for sample
I wonder if the subfolder "with_sample_data" is necessary. Couldn't the test app be placed just under direct?
id is only used once; simplify to just return <expr> "" + x is more concise than Long.toString(x)
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
The this. in getters are unnecessary too.
Should make a differentiation of the name and id.
suggestion this.className = requireNonNull(className);
duplicate logic in getPrivateKeyAlias method().
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
That is small duplication. If you add extra parameter key then you can replace two methods with one
optional suggestion: since we're extracting helper methods... it's mostly "false * 4" or "true * 4", so consider adding e.g. whenEverythingIsInitialized and whenNothingIsInitialized.
I think this part is redundant with the settings in setupModuleExportsOnly below, isn't it?
Should follow Fluent pattern.
You don't really need to return this;. It doesn't really make sense for any verification method to have a return value. P.S I know the others have, and I'm quite itching to fix them :p
Please add a space after the cast.
correct signature is @Override public ConnectionFactory getConnectionFactory() throws JMSConnectorException {..}
String can be externalized.
The Console view and the Debugger Console view can contain multiple pages, one per console. There is only one showing at a time. Looking at the ConsoleView code, it seems to activate the participants of the console page that is at the top (the active one), while disactivating the participant of the page that is now hidden. We should do the same.
In the typical use-case, there will be a single session / console, so this will be disabled. The user might wonder why this button is there. So I wonder if it would be less confusing to enable the widget even if there is a single console? The caption "display selected console" doesn't shed much more light on the situation, since there appears to be nothing to select, in the single session case :)
No need of this. Its marked as @NotNull.
I'm thinking if we could provide an automatic way to call these method by set annotation on the field just like those IoC frameworks do
You could simply do super.setClazz(CommonLog.class)... You don't need to have a vaeiable pojoClass.
IntelliJ says the type parameters are not needed
Nice optimization. We should retain the check for pipelining/transaction via checkResult( ) ending in something like:  entries = hashOps.entries(); checkResult(entries); return entries.entrySet();
The code should be protected by doWithReadLock, we should do same thing for isEmpty containsValue, etc.
Please, express if it is permanent or random in error message:  Known permanent failure <LINK_1>
projectExplorer.waitAndSelectItem(PROJECT_NAME); projectExplorer.openItemByPath(PROJECT_NAME); projectExplorer.openItemByPath(PATH_TO_GO_FILE);  Can be changed to "ProjectExplorer#expandPathInProjectExplorerAndOpenFile(String path, String fileName)"
WTF is lala
please use Assertion class
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
Uhhh I think this uses the local default filesystem to resolve that filename, which isn't necessarily what you want.
@pwillworth why not use File#separatorChar ?
Is replacing separators enough? We should look into something that will work for any special characters.
Won't fix.
Nothing to cleanup?
Would it make sense to add something this.caches.clear() to the stop ?
don't return null, return an error page
This could be null, here see createPage
![MAJOR](<LINK_0> 'Severity: MAJOR') Update this method so that its implementation is not identical to "getParent1" on line 135. [![rule](<LINK_1>](<LINK_2>
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
use namespace instead of DEFAULT
The pattern we're using in StreamDescriptors is to have the extending classes also override the toConfig method from the base class and call super.toConfig as the first step. Might be a simpler interface for extending classes since there is one less config related interface method. If we do that, you might also not need to call addTableConfig to mutate the passed in tableConfig map in generateConfig.
MessageQueue.RegisterBankAccount_EventMessage
can you make those no-arg constructor private?
mMessageQueue not in use, please remove
From @blickly I think this should be Fingerprint2
So it turns out this is a bit more subtle -- using a java9+ compiler to target java8 this works as expected, however the java 8 compiler cannot compile this output! Not recommending that we revert since everything will be 11+ soon, and it's rare enough that I'd rather suppress.
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
should we close the connection before throwing the exception or connection close is going to be handled some place else?
Is this intentional? ProducerFencedException doesn't inherit from RetriableException, so unless I'm missing something, this will still kill the thread. Same for below as well in StandbyTask.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Am explanation would be nice
Use new Hashtable<>
Don't know what this converter does, but it is used here whereas a plain toString was used in the Shell. On purpose?
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
If the buffer isn't reused, then it is safe to cache a copy of the bytes and use it each time unsafe is called rather than copying all the time.
return HConstants.EMPTY_BYTE_ARRAY; ?
should this filter out null resources? (ie. bad paths)
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Use method reference
What about testing with ALTER FUNCTION sin ... instead?
static imports
should not be message looked like: Schema 'rename' not found?
Minor: Maybe remove the type bound if it's not used?
change
Why is this needed here?
The error message doesn't match the actual behaviour.
Did you intend to make this public?
This list needs to include soul lantern.
just minor thing, but all these methods are duplicating code... probably you can create a common function that takes the shape and a Function<Bounds, Double> and does the different null checks etc, and then the methods xOfShape, yOfShape etc would be refactored by using as a second argument the function (bounds) -> bounds.getX(), and so on...
You could either use a constant for the id name here or use something like: java @FindBy(id = "export-form") private WebElement exportForm;
Unneeded cast
So, would the PII information be provided as plain text? If so, isn't that a security concern?
@JonathanGiles, was there guidance in the past to use Iterable or Collection instead of List as it is more flexible?
it would be nice to have several languages inside. Empty list is useless
Same here, better in the constant class.
I dont see any reason for adding this to string.xml. It is not really a string resource, it is more of an id. We wouldn't want this to change if we decide to translate the App strings later. A better way would be to move it to the Constants class.
let's rename final PromoDialog asyncPromoDialog to final PromoDialog gbInformativeDialog
suggestion return Objects.equals(caseRoles, other.caseRoles) && Objects.equals(caseFileVariables, other.caseFileVariables);
Help me understand the change below more. The one on the left seems simple.
The implementation then looks like this:  java @Override public boolean equals(Object o) { return Sets.equals(this, o); }
I would prefer to avoid any dependency from UriComponentsBuilder on UrlPathHelper. The latter is more of a Servlet API specific component while the former is more general. Even if the re-use in this case doesn't touch on anything Servlet specific, it seems very minor and not worth the gain.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
This is hacky and might be error-prone. Since it is always a leaf node, it makes more sense to parse the string with path splitter "/" and return the last section.
You should determine if you need a regression model in the scheduler
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
You might want to get and ACK about the execution of the operation, because otherwise it is really complex to control the behaviour of the distributed system.
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
Unnecessary null check since the variable is Object typed?
this (also below)
This branch is not needed
So is there value of having a whole class that just does such a simple thing? Perhaps a static method in a utility class is easier and adds less to the heap?
Do not assign to n. Let the compiler verify we set n in both branches below.
Tag @leeyimin here, I'm not too familiar with sanitization so I'm not sure if this is okay.
Aren't just 3 asterisk enough? :-)
Instead of calling "replaceAll" three times you could call it one time with a regex as (\\[|\\]|\\s).
nit: suggestion log.error("User [%s] had role [%s], but role object was not found.", user.getName(), roleName);
I don't think the realm could ever be null.
maybe, would not be keeping the map null better, to ensure uninitialized mapper will not be used accidentally? (even NPE is better then complex debugging why roles are not mapped...)
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
If it is clearer then method name clear looks more natural for me than remove
you're not the author of this code but still, it may be useful to add exception or message to logger.
nit: put {} around if statement.
Maybe: 'toIME'?
cursor is not captured here. I fixed it locally adding  julLogRecord.setParameters(new Object[] { logRecord.getCursor() });
You can also use IO.close(bb) as IO.close will not throw any exception.
typo: s/got/get/
It's a compatibility loss as well
"0"?
"0"?
Consider Arrays.asList(
In accordance with similar changes maybe better to use Optional?
Why do we need it? :smile_cat:
I question if the synchronization here is correct. I'd like to walk through it with you to understand it better
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
better to cast to string instead of using toString()
better to cast to string instead of using toString() .
I would change this to if(url == null) { return null; } less indentation, code looks a lot cleaner
Need to implement
I don't think we use final for functions in our code base
Do we want to make the change inside mkAssignments(String scratchTopoId) so we can count errors during the rebalance command as well?
Do we expect this to happen "normally" or is this really a problem indicating a bug? If it's going to happen "normally" it shouldn't be log.info as that will be too noisy in the logs. If it indicates a bug, please bump it up to log.warn.
This method should be static
These should refer to constants rather than the string literals.
else is rendudant
This should also include int, boolean, and any other types that are supported in the CSV conversions.
We can give some more time, like 30 seconds.
After shutting down the Executor, we should explicitly set it to null which is more friendly to the GC.
For debug, it may be good to add more information (this or port it listened to) about the buffer server. There seems to be a missing call to super.unregistered() (even though it is currently no-op, it may change). The message should say "unregistered".
Why not just use fixture?
Nitpick: promote magic literals to fields, construct body field with reference to them.
Hmm, I'm not too sure that we should export a GSON type as part of our public API. What do you think about making this a more opaque data type (like you did with []byte in Go)?
We need to throw a BriefcaseException here. Returning null doesn't make sense in a ValueObject
do we want to keep this message?
This one needs to check only for id, URL is covered in following method.
isRemote(command.getKey()) instead of false
leftover from debugging?
From the point of async store, it is not necessary to have the *function* serializable but the resulting entry. So the check does not belong here. The same holds for compute commands.
Should be "InstaPost" actually.
String.format
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
I think this could be a lambda (if you're editing it anyway).
Switch to LOG.debug
I think this can be private. Also it seems that its only use immediately makes an ImmutableList, so maybe it'd be better for this method to just return an ImmutableList.
Can we get the root class as a generic parameter of the aggregate class or, more straightforward, the repository class? If we can, we won't need to accept it as a constructor parameter.
Please add a space after (Class<E>).
AggregateRoot is not an Entity.
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
Since Date instances are mutable, the this.endDate should be a copy of endDate to avoid side-effects.
Do same for this one
This is a private class used for tracking, won't change super fields, time is the only changing variable here, so only need to hash time here.
Just don't override the method instead of hashing the hash.
This isn't correct; it defers to the default implementation of Object::hashCode, which will be different for different instances, but the contract of hashCode requires that two objects' hash codes be the same if equals is true. It would be better to return a constant.
Continuation of the comme?t on line #242 - Please notice 'messageLabel' and 'externalLabel' doesn't have representation in the model. The fields you're manipulating in 'onPhysicalNetworkChange()' do have, so please move this logic to the model.
Maybe it would be better to move it to localization
Why this needs to be hidden?
should we log a warn in an else block here saying that the task failed to describe the table? It's hard to follow "absence of logs" when these connectors are typically running against a large number of tables.
I think we should consider the case sensitivity here.
why needs this method to be static?
Why it's "EXTERNALVIEW"?
I don't have strong preference here. - Shall protected or package-private enough here? - Or, on the other hand, with these two methods made to the public, we can avoid several test codes using INSTANCE_DN_KEY and RESOURCE_DN_KEY directly. Not a must in this PR, though.
Why do we return the parents name instead of the name we store a few lines above?
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Please change the left side to Collection.
You can use Layout.INVALID_CLUSTER_ID
remove local variable
Remove the if check and simply return getFirstElement
Okay then I will apply a patch for your proposed bug report.
could you provide a test for option(null) also, I'm not sure how that should behave differently from some (I guess it should represent a none intuitively)
Yes, unless there's something I'm missing the constructor could be private.
Check arg?
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
suggestion Path path = tempDir.toPath();
This is a little hack for me. Could we avoid these kind of hacks?
No use checking if the list contains() before remove(), let's avoid double iterations.
The ListenerList implementation already takes care of this. Remove the "contains" test.
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
Again, I'd prefer more descriptive errors here as to why the group cannot be deleted.
e.getMessage() can be null, which would make this RuntimeException uninformative. Please replace e.getMessage() with a more useful error message.
revert this
Simplify this to one line.
no! let OSGi do its job.
Since this is a String, perhaps you could use Collections.nCopies
What about return new UUID(random.nextLong(), random.nextLong()?
StandardCharsets.UTF_8 (static import UTF_8)
remove this extra line
The problem should be somewhere else :-)
Can be removed now
@fanifieiev the same above.
try this: new Href("<LINK_1>").path("c").path("d").toString()
@ikhvostenkov why not codec.decode(codec.encode(identity)) ?
no reason to explicitly set to null, its default behavior
Should'nt the getter name be getClusteId if the field name is clusterId?
You added this to the ctor's signature, but forgot to save it in a data member.
Probably this should return 0 when doubles[index] == null && NullHandling.replaceWithDefault() == true? Otherwise it probably should throw an exception.
unnecessary array new: {{true}, {false}} should work here
Why do you pick b as the variable name? It could be model or m. I am just curious.
Can you reduce the nesting depth here?
The pattern is to have the init before the try: AdminClient client = AdminClient.create(getDefaultAdminProperties()); try { ... } finally { client.close(); // no need to check for null if the factory never returns null } But if AdminClient is AutoCloseable you can just use try-with-resources.
Okay this is better where it can self-heal and reconnect. Fix checkstyle issue however!
Maybe pull this into a static method that pgm.Archive can invoke without having a BundleContext. Then we don't need to maintain this list in two places.
Do we want to check both getProjectId() and getJobProjectId() here?
we might here just get rid of the String result declaration and combine these two lines into return percentFormat.format(value);
code format
Due to consistency I would just return "skadi" here
You can do this just using what's built in to Java:  return String.format("Notifications [notifications=[%s]]", notifications.stream().collect(Collectors.joining(",")));  But ImmutableLists toString() pretty nicely, so you should just be able to do this:  return String.format("Notifications [notifications=%s]", notifications);
Agree with you. We will probably test this on different level.
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
Need to filter for null entries in the attributes set: .filter(Objects::nonNull).
I think it is unnecessary to use synchronized here
Is try-catch needed here?
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
Same here. Simple call to filter() is more readable
Just calling this out as another place it would be helpful to log the zone
this will be written every 5 sec (by default) i think its better in debug
You don't need to change this method signature. I would leave this method private
It would be much clearer if lawJournalEntryCodeExtractor had a method like isCorrectLawJournalEntryCode(lawJornalEntryCode) that could be used here and at the beginning of each extract method.
why can't the mDBs.values() also add the DBInfo entries?
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
Could this be private or at least package private?
No need for public setter as it's set in the constructor.
Shouldnt we have this defaulting to the common namespace (ICommonAttributes#COMMON_NAMESPACE) so that we can tell the user what this defaults to?
casting isn't necessary here, is it?
You could set connectionFactory to default, and then create the connection in the return statement.
I would change is back to 50 for consistency with CDT.
Result of replaceAll is ignored. Please, assign it to a variable. suggestion maxUploadSizeString = maxUploadSizeString.replaceAll("\\s+", "");
I'd use << 3 to match MemoryAddressHash
nit, Collections.EMPTY_MAP?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
What's the point of adding a copy here?
I think its safe to inline this var
I think there are 2 approaches instead of just ignoring the FileAlreadyExists exception: 1) we can just validate whether the existing Trash path is a directory and validate the permissions and not throw FileAlreadyExists exception itself in DistributedFileSystem.java#provisionSnapshotTrash 2) If the trash path already exists with right permissions, we can check if the path is an encryption zone as well and throw FileAlreadyExists exception only if its not an encryption zone. Similar change will be required for making an snapshottable dir an encryption zone. I am ok with either of the above approaches. I think just ignoring the exception here will not work in case. the existing path is not a directory or has right permissions.
Here the SnapshotStatus contains parentpath as well, the path will be the one wrt the actual namespace not with respect to mount table. You need to replace the parentpath with path corresponding to the mount entry. if mount entry is : /mnt -> /dir in ns0, then if you trigger call on ns0 the path would be something like /dir/sub.. that you need to change to /mnt/sub.. In case of InvokeConcurrent you would be able to get Src and Dst from the ret and maybe something like this may work -  response = ret.values().iterator().next(); String src = ret.keySet().iterator().next().getSrc(); String dst = ret.keySet().iterator().next().getDest(); for (SnapshotStatus s : response) { String mountPath = new String(s.getParentFullPath()).replaceFirst(dst, src); s.setParentFullPath(mountPath.getBytes()); }  For the invokeSequential one you won't be having the detail on which location did the call got success, For that you have to get it returned back from RouterRpcClient#L858, I guess to get the location returned you would require a new InvokeSequential method which returns the location as well, may be can refactor and reuse this one... This problem would be there I think in getSnapshottableDirListing() as well. If you want, you can put a TODO and handle the location stuff in a separate follow up jira for both API's.
would it be better to use isNotBlank here?
Can we just return the boolean expression?
@dskalenko when line can be null?
100 seconds is 1 order of magnitude more. It seems a lot. Would doubling to 20s be enough? Or could we instead use org.jboss.as.test.shared.TimeoutUtil#adjust to adjust the time of this test?
It is completely implausible that compile returns null if it didn't in testPattern01. So this check is redundant and should be omitted.
Will look into it; is there an existing test whose structure I can copy?
static
This message could be less snarky :) Could also recommend using AtlasDbConstants.GENERIC_TABLE_METADATA?
We can push this further up by having these helper methods return the function we build in each of these methods, will help increase readability.
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Seems like there are certain methods that can be pkg local
Is this method really needed? It's similar to make init public
Please use Java's local variable type-inference var where possible
Looks a bit suspicious. Why are we catching any exception and throwing SqlException? Is SqlException caught somewhere?
As long as you're touching this code, this could be a nice, clean stream-based one-liner.
I think these will crash if there isn't an app successfully seated yet. Usually good to wrap these reporting helpers in a try/catch so that we guarantee we get the report
should be secction // Then and add verify sentences
extra newline
this two things are special afair cc @lanwen
Update this method to also return true if status is HALF_OPEN?
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
40?
Please add ? and % as well
unnecessary array new: {{true}, {false}} should work here
Why doesn't the following method fit this test suite?  public static TestCommandFactory newInstance(Class<?> testClass)
Please adjust the code to fit 120-symbols-per-line.
only in America
This can now be deleted.
Set the httpclient in pipeline instead.
Shall we move Client initialize to BaseLiveTest to re-use in other test classes?
add this (also below)
does it have to be public?
We can use TextUtils.isEmpty instead of directly checking for empty string. We also need to localize the string. I suggest adding a new string resource, probably something like wordpress_as_site_title to make it clear how it's used to give information to the translators.
I suggest dropping the "final". It is not required and I personally dislike this style. Unnecessary code should be avoided.
Using String.valueOf(myBundle.getBundleId()) would make more sense than .valueOf.toString
Why is this called cxfBundle?
Please chain the method calls: java return new URIBuilder(BASIC_SEARCH_URL)) .addParameter("query", query) .addParameter("sort", "score") .build() .toURL();
# This will fail We are no longer sending the authorization, from line 43 in the deleted section. There are tests (that weren't migrated to the unit test suite) that are failing.
Remove log statement. Let's consolidate logging into fewer (more complete log statements).
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
It is more a coding style question but I think it would be more readable to simple have the implementation here in the enums instead of adding new static methods. If you like it more as is I'm also fine with it.
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
analysisMetadata.setOrganizationsEnabled is already called on line 117 and it really does not belong to a method called toOrganization which really should be static
Should be done before opening a db session - for to fail fast.
I'm not sure it's worth sharing this method checking permissions: 1. the call to checkLoggedIn should be the first call in method handle so that we don't do any SQL when user is not logged in 2. this leave method checkQProfileAdminPermission with a single method call which is hardly useful to factor
Maybe use an uppercase in the text: 'Thread sleep was interrupted'.
:astonished:
FYI, TimeUnit.SECONDS.sleep(seconds.longValue())
I see 3 proposals: A) Leave as is (bad idea, fromUniquePair(..., Joiners.filtering(...)) doesn't work for CS-D and CS-B) B) Put lessThan() before filtering() - Is it a regression for Bavet? does this break any of the existing Bavet working examples? C) Like B), but add Bavet syntactic sugar to support filtering() to avoid any regressions of B.
Is it guaranteed that these two String literals are represented by the same String instance? I think they are as a result of JVM optimization but I wouldn't rely on that. If I'm correct, this should be changed to assertEquals() or java String v2 = "secondValue"; memberAccessor.executeSetter(s1, v2); assertSame(v2, memberAccessor.executeGetter(s1));
I think that you can do the same by using Stream.concat(). That will allow you to get rid of the List.
Why do we return the parents name instead of the name we store a few lines above?
nit: don't need this on either of these
Make it private and refactor the tests to invoke it indirectly through createFile*()
Now that you've implemented the reporting functionality, this log statement can be removed.
Can this just be inlined? Is it really unchecked?
Perhaps the '104' could be a constant?
Hmmm. You sure you want UNKNOWN here? IIRC, UNKNOWN is what should be there if the job has been deployed but the agent has yet to act on it. Though it may be that by the time verifyHealthy is called that if the agent hasn't acted, it's probably time to call things off.
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
java return this.name.equals(a.name);
you should also check that log contains GIT_COMMIT is
You need to use a RunListener or similar to ensue that any locks acquired by a build are released when it exits even if the user forgot to use the release step (or forgot to put it in a finally block, or the CPS VM crashed and the build did not exit via the Groovy call stack).
For fix tests on Jenkins you need to create project directory, like here PerformanceTestBuildTest#testFlow#L38
why is this return null??
Can make this into a singleton as we have with UNSET.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
just one more thing. Can we add a metric here to track this issue?
should this be public? It seems like an implementation detail of the config file format.
Please put @Override on the standalone line
WTF is lala
It should also validate that the content is valid JSON, otherwise it will fail "silently" when trying to create it.
where is assertion for this test?
Should remove, and use similar functionality in CoreAuthenticationTestUtils
Should remove, and use similar functionality in CoreAuthenticationTestUtils
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
I think we have some constraints regarding the target URI? (e.g., exactly one? at most one?)
These could NPE now, but without a local default value to use this gets a bit awkward. Maybe set to -1 and then don't apply a value later if it is <0 unless you can think of something better, or we just doc that neither supplied TimeoutOption should be null.
also always true
Make secrets an immutable list if present.
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
better return a null object (new Pair(this, null)) or throw UnsupportedOperationException
There seems to be an output change here: original: Base32.encode("a".getBytes()) => "ME" new: Base32.encode("a".getBytes()) => "ME======" We might need omitPadding() to ensure this is an exact drop in replacement.
@ikhvostenkov this variable can be inlined
Just return checkNotNull(id, "id").split("/");
This should always be read from the configs.
Since the preference is only checked in the constructor, does it mean that toggling one of these checkboxes will only take effect for newly opened editors? Is that consistent with other checkboxes in the formatter preferences?
We usually want the config default specified in properties file, there is no need to provide a default in java code.
on failure we should try and delete the disk we added, see the current handling in the task handlers.
I don't know which pr will contain the final setting for this, but the 2 FAILED statuses should be here also. cc @hreeve-cloudera
Hm, my understanding has been that the base implementation should look like: Java if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); }
How about reverting negation?
I'm missing the new field in the toString method.
Make final
These calls are very hard to understand. It can be more clear like this: return (Pair<StorageDomainStatic, Guid>) runVdsCommand( VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters( getVds().getId(), getStorageDomain().getId())) .getReturnValue();
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
defensive copy?
That's weird. How will you fetch the conversion error from the outside?
Why are you setting the cause of this exception as the cause of e? Shouldn't it just be e same as the next constructor?
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
This is redundant.
Remove redundant assertions.
Is there a smarter way to do this?
@vzool one more printStackTrace ?
Please don't print stack trace like that. Either log it properly or ignore if the information is useless.
close the stream in finally block
would be helpful to record the date/time here as well.
If you never need the stack trace, consider calling super(message, null, false, false) to avoid some overhead.
To keep same format, could we use Timber.e(message) ?
There is no need to recheck equality if isExceptionIdentifierUsed is already true
variable name is not good. Can you rename it to identifierSource?
Is performance something we care about here? If so we could use the shortyapi. It does this lookup and also caches the result. Usage would be shortyAPI.getShorty(contentlet.getIdentifier()).isPreset() && shortyAPI.getShorty(contentlet.getIdentifier()).get().shortType==ShortType.Identifier)
Unnecessary call to super
Unnecessary call to super()
IntelliJ IDEA tolds me to remove this unnecessary boxing.
this should go to super.reset(), shouldn't it?
i do not think we need to save this line better make it more readable
I think there is a bit of a race condition here. If the config is reset and a log happens before the configuration is loaded, unexpected behavior could occur.
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Is it possible that the same project is added to the list twice?
IDEA says that using toArray(new String[collection.size()]) has no performance improvement over toArray(new String[0]) so the second call is encouraged.
Should be "InstaPost" actually.
should this have a ,  to match the rest of the pattern?
Please put @Override on the standalone line
Please remove the maverick ";"
This looks odd. The contract for unsafe access to the bytes backing another Binary is to use them immediately and forget about them so it doesn't matter if they change. But in this case you create a constant Binary that signals the bytes won't change. So this is taking something that might change and passing on something that won't. What we need here is the ability to get a slice of the original v that inherits whether it is reused or constant:  java Binary slice(int start, int length);
mvn clean verify fails with checkstyle. Fluo prefers using braces, even for one-line if blocks.
Consider getting this value once, and save it, instead of calling it twice.
the same, why not use method reference?
perhaps vds load blanacer
The link member should be removed and this line may be replaced with:  java return this.baseStyleGuideLink + this.name;
checkNotNull(pattern), too?
I think getExtras() is nullable, so we should handle that case.
![MAJOR](<LINK_1> Refactor this method to throw at most one checked exception instead of: java.io.IOException, java.util.concurrent.TimeoutException, org.osgp.adapter.protocol.dlms.exceptions.ProtocolAdapterException [![rule](<LINK_2>](<LINK_0>
The method getConfigurationObjectDto(DlmsConnectionHolder) can get called from both the GetConfigurationObjectCommandExecutor and the SetConfigurationObjectCommandExecutor. The description that is set on the DLMS message listener starts with "SetConfigurationObject", which would be confusing when called getting the configuration object.
You can remove 'throws ProtocolAdapterException'
Will this always be this value?
test will success in old versions
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
another log that can be removed (I know it's not part of your commit, but please do it anyway).
Why was if (!CameraManager.getInstance().hasCurrentCameraFlash()) not enough?
You have to add a synchronized block here. If not, there is a chance it will be registered multiple times and we can get InstanceAlreadyExistsException.
Should one of the following happen in case contentType passed is null? - throw an exception, or - set this.contentType = null
Change collectionType to iterableType?
Why allow a nullable input here? Users wanting a null content type can just call the String variant, no?
why 40 as a limit?
adding analysis_uuid column in the migration called "make ce task uuid column nullable" is not wise, imho at least, it is highly misleading
This is fine, but a stronger assert would be verify no "UPDATE TABLE" command was sent to the database.
this does the same thing as createTransactionalBatch(). why do we need to have both as public? If createTransactionalBatch is the public method then this one should be package private.
suggestion this.licenseKey = licenseKey;
Validation logic should be either in the constructor, or in the builder, but not in both. I recommend validate these only in the constructor.
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
I'd add a checkState to every one of these methods to make it clear how it lines up with the switch case above
use error message as in startMemoryRevoking
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorizationWithoutAuthentication(PROCESS_DEFINITION, ONE_TASK_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
Could change to ProcessInstance.STATE_ACTIVE ?
You want to use FormField.getFirstValue() here and everywhere below.
To avoid NPE, could we use: java Objects.equals(field.getFieldName(), fieldName) || Objects.euqals(fieldName, field.getFieldBinding())
- indentation to fix - I think the second null check is nor necessary (the type can never be null and event if if was, there is no null value in widgetTypesToFocus)
You can change immplicit before and rever the change after waiting
super(userId, username)
pattern should be constant, so as not to compile it every time.
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
Please no, let's not have compactedChain being null legal. What is it buying us exactly?
So we can't know it's really an alias until it's wired , or runing, or ?
we don't need it here as it already called in super method.
Use Logger.
![CRITICAL](<LINK_0> Possible null pointer dereference in org.carlspring.strongbox.providers.storage.FileSystemStorageProvider.getArtifactPath(String, String) due to return value of called method [![rule](<LINK_1>](<LINK_2>
Please use P.lazy(u -> f.f(a)
could be final.
could be final.
BbUserUnassigned is about a user, while we speak of a Project aggregate. So probably this is BbAssigneeRemoved.
or a more readable :  List<UserMembership> organizations = userMemberships .stream() .filter(userMembership -> userMembership.getOrganizationName().toLowerCase().contains(query.toLowerCase())) .collect(Collectors.toList());
You can replace the upper block by:  return identifications.stream().map(userAndCredentials ->{ ListeningUser listeningUser = userAndCredentials.getListeningUser(); UserIdentificationImpl user = listeningUser.getUser(); return new SchedulerUserInfo(user.getHostName(), user.getUsername(), user.getConnectionTime(), user.getLastSubmitTime(), user.getSubmitNumber())) }).collect(Collectors.toList());
suggestion ((WordPress) requireActivity().getApplication()).component().inject(this);  This getActivity() can be requireActivity().
I know it's a legacy, but I'd like to kill that kind of unnecessary methods, like we started to do last year setUpBindings, setUpToolbar, setUpDetails
Are both of these lines required? I'd have expected we'd only need the attachBaseContext
I think the granularity should be 1 seconds instead of 5 seconds here.
We should add a check to make sure the end time is not in the future by comparing it with the current time.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
"your _thing handler_" doesn't make sense then, right?
Minor: move init to the beginning after the constructor
This method should be private or default as otherwise it is API addition.
I fail to see the difference to the previous test. Is there any?
Would you mind improving this test to use executeFile() instead of executeString()?
Can you use an anonymous name for the maintainer? Not something from production
Shouldn't this be set to true as daemon threads do not prevent the JVM from exiting when the program finishes.
Here an exception should be thrown if we have a conflict
can we make 10000 configurable?
Perhaps we could avoid obtaining mBoundedWidth both here and in the next constructor by simply calling this(context, attrs, 0); here?
"==" to "="
While we're renaming, might as well remove that extra _.
You can use mapToLong here and then sum()
I'd make this return long and rename to getTotalPendingBytes so we don't have to keep going back and forth.
static import?
The orchestrator will pass down a connected client (i.e. it will have a layout ready) when it creates a workflow, why is this needed?
this override is useless
what will happen after I will add new elements to enum?
+ desc
real and bigint still applies for qdigest right?
Maybe remove references to versions here? You could change this to: "Migrates pom.xml files to format compatible with KIE Maven build." @porcelli WDYT?
This and other setters don't have to be public, could be private.
here you should get the selected pattern and get the command.
getSelectedPattern().getCommand() ?
This is not correct, orderGroup and sortWeight need to be copied too, this should stay unchanged instead you update Order.copy to copy over these fields too
do it in one line
Copy this value from the previous and ensure the previous' value isn't null
click should not be in this method.
The solution looks weak. I understand that all these classes are the part of the infrastructure and everything is called in the right order, but this filed can be null, if we don't call configureListenerAdapter
Call charAt instead?
WDYT about wrapping the returned map into a special access updating wrapper? In that case we will avoid double iteration while sending results to the client, for instance.
What about declaring more examples here on what happens by using a data provider? that would be more expressive in terms on which cases this will/won't fail. What do you think?
should we return a default here? anyway, like using the first sample offset?
this whole thing can be replaced with Stream.of( args ) .filter( StringUtils::isNotEmpty ) .toArray( String[]::new ) right?
I think we should actually set this to "--only=constant-naming,constant-k-prefix", and with that syntax the "--" on the following line may be removed.
Change this to "--only=function-whitespace" and remove the "--" on the following line.
Do we really need 10M ? Isn't 1MB or 500K enough for the sake of the test?
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
Same concern as below, please use try-finally
I thought this was to be debug to prevent unwanted data from appearing in the log.
should this have a ,  to match the rest of the pattern?
Shall we include all new fields like invalidateNearCache to the toString method?
this c'tor implies the entity is immutable. Please let have same assumption for SubjectEntity class and introduce a c'tor there which expect both entityType and entityId and use it here instead of the setters.
Might throw an IndexOutOfBound if no the storage domain is not attached to any storage pool
Isn't there a way to first of all get the first item and only if present return the idea? Can save the mapping of the complete list just to return the first one (IIUC)
probably worth using a linkedlist here as well, although I doubt allocating 10 ints makes much difference though compared to other stuff we do
suggestion return Collections.emptyList();
Collections.emptyList()
I know I'm being a bit petty, but reading this and taking a while to realize its a variable starting with capital letter triggered me a bit :D
Why not implement this method  protected String getAuthorizationBaseUrl() { return "<LINK_0>"; }  and remove getAuthorizationUrl here. It doesn't have any difference with overrided impl in DefaultApi20
What's driving the change to increase visibility here? These are intended to be used only by subclasses.
Same as previous PR review: Sonar Lint should complain if you don't at least log the exception
Looks like with some generics on Field, we could eliminate all the redundant null checking and decode calling here. Also no point in handing null and readBuffer from every method.
I think it's more common to throw a NullPointerException if a parameter is unexpectedly null
Need to add @ConditionalOnEnabledEndpoint("filters").
This is problematic (or at least ugly). It is very dangerous to call an overridable method from a constructor, because if it gets overridden in a subclass, then overridden method can be called from the super class constructor, without the subclass constructor completed. See the following example:  public class Main { public static void main(String[] args){ Bar bar = new Bar(); } } class Foo{ Foo(){ foo(); } public void foo(){} } class Bar extends Foo{ final int a; Bar(){ a=10; } public void foo(){ System.out.println(a); } }  It will print 0.
Would it be better to use the getEndpoint() getter and thus maintain the access to the endpoint in one place?
This code to get the feature is used here and in the remove method. I'd suggest to create a new BackendClusterFeatureHelper class and put this code there. Then you can call it from these methos. Look at BackendDataCenterHelper for example.
What if the result is null? Should we check it?
This should be addLinks(map(...))
thanks for renaming these vars to reflect _output_ stats :) looks like you missed one var here-- inputStats should be outputStats.
As it is, it may product a NPE
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
hmm, really not sure about a cache. The aspects are not necessarily "immutable" for a given event. Calling resolve at one point may not yield the same result as calling it later, so I don't think we should cache them. Every class that calls .resolve() could only call it once and "cache" its value though. About possibly merging the two methods: If we look at the use case here, for example the classes using a TmfCpuAspect, basically what they all do comes back to: "Go through all the aspects of this trace, find me a TmfCpuAspect that returns a valid non-null value, gimme this value". Couldn't we have one utility method that does just that? It could even be specific to a TmfCpuAspect (and derived classes) too!
Would it be better to have one static private NullProgressMonitor that is passed here instead of creating a NullProgressMonitor for each event?
getTrace() being a UfTrace you are painting yourself in a corner here. Like for the TraceEventEvent thing, this provider works only on UfTrace trace, not uftrace-like events implementing the same semantic. But it does not need to be fixed right now. But it should be kept in mind for later.
Could you use hamcrest matchers please? Thx
Should be !socket.isValid()
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
This should be able to remove a membership that matches the patient, if there is multiple for the same patient then you can ignore it
I guess we could just assert without the temporary result variable.
I guess we could just assert without the temporary variable.
return ?
There is a better way to do this, WorldServer holds a Map of 'entitiesByUuid' which you can use to directly lookup the entity.
You cannot @Override this method to implement the method from the interface because after obfuscation it will get the srg name. Please consult [the mixin examples](<LINK_0> for how to deal with conflicting methods with the **same** signature/name. _EDIT: actually never mind, I just noticed that the MCP name has an uppercase "ID" while the sponge method has the Pascal-cased "Id" so it's all fine._
How is this expression different from "this"?
I have found a bug in this latest patch. The line 107 should be modified so it considers the RefRight.ALL value is "refs/*" but a RefControl instance to "refs/*" would have its refName member value equals to "refs/". So, the correct code to 107th line would be: if (!RefRight.ALL.substring(0, RefRight.ALL.length() - 1).equals(getRefName()) && getProjectControl().isOwner())
This should use the GitRepositoryManager.REF_CONFIG constant. I'll fix during cherry-pick when I submit this topic, thanks.
Why don't instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
defensive copy?
getActionType().getActionGroup() can be used (once it will have to correct action group:))
shouldn't we also have permissions to write to the glance domain?
what about setting the permissions for that?
This is just completely broken. I think I meant to do if (filterConfig != null) in the first place.
IseException is a REST exception. We should throw something like a ConfigurationException here instead.
You're welcome! As you noticed the the wrong error message was a consequence of the wrong comparison. Since isNameValid(name) was returning true when it should be false, the second if statement on enterPressed() was executed causing this bug.
code formatting is still inconsistent with rest of the code. This isn't the only line.
return value is used by WriterMaintenanceJob to throttle threads
I don't think it's necessary to keep this in a field.
@komaz maybe for now we can just return empty iterable, there is no need to react so strongly about missing implementation.
This will probably be permanently unsupported.
Please add a note why this cant be implemented right now
The object passed as the last parameter of MethodRule.apply() needs to be the test instance, not the test class. The only way to get it is to have the caller pass in the test instance into the TestRuleAdapter constructor.
Unfortunately this method is protected. Changing the signature may break someone. @junit-team/junit-committers how should we handle this? We could not add the new feature without breaking the extension point. I'm in favour of modifying the methods signature and making it private. Users should create a new rule instead of extending Timeout. They could use the builder for creating the statement.
This is not equivalent.
Can't we throw here something more meaningful? Where are you using this query? how does it feel in this case?
No need fail the query if the volume doesn't have any task
Extra new line can be removed here and other places.
Maybe better to return null
Remove empty line
fancy name !
?? why this and the following ones could be left empty?
factory must close its cursor (which is closeable)
the ArrayList of languages to translated could be cleared.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
index < arguments.size() ?
I would use a regex for that: java private static final Pattern RTRIM = Pattern.compile("\\s+$"); public static String ltrim(String s) { return RTRIM.matcher(s).replaceAll(""); }
Do you hate static imports? :)
possible exception
why is this logic different than for .zip?
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
It should also validate that the content is valid JSON, otherwise it will fail "silently" when trying to create it.
WTF is lala
We should use the spring.application.name boot property instead of the applicationContext.getId.
Why not create the taskExecutionDAoFactoryBean in the ctor?
Collections.emptyList.
I would say use a flag  @garrettjonesgoogle thoughts?
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
Create a new connection every time you send a ShuffleControlMessage?
Now it's <code>@CheckForNull</code>
code style
DRY use <code>this(parameterDefinitions != null ? Arrays.asList(parameterDefinitions) : null)</code>
Similarly
Should the override annotation be on a separate line (not sure of the convention in this codebase)?
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
"No provider is registered for the service '" + service.getName() + "'", service" (this is the current errore message). Shouldn't this thrown a ProvisioningException ?
Could you rename variables to make the purpose more obvious? Like: newHandlers = handlerMap.merge(address, handlers, (oldHandlers, h) -> oldHandlers.add(h.first())) At least do not use current for the second var of the remapping function.
In which scenarios would a single plugin register multiple handlers for the same type?
Same here. Consider just propagating the current exception.
No need for this variable. Pass the value directly.
why not pass blobDataType here?
I would say use a flag  @garrettjonesgoogle thoughts?
should be able to make this private.
magic numbers. Some explanation would be good.
typo in method name
Should we continue with the flow here?
Why are creating a JMSConnectorException and creating a RuntimeException with that? Can't we directly create the RuntimeException?
We don't use the statisticsAwareService anymore.
any reason for explicitly invoking super.toMap() ?
Could this repeated logic in message tasks & member-side map proxy be hidden within MapOperationProvider eg:  MapOperation createPutIfAbsentOperation(String name, Data dataKey, Data value, long ttl, long maxIdle) { if (ttl == DEFAULT_TTL) { return new PutIfAbsentOperation(..); } else { return new PutIfAbsentWithExpiryOperation(..); } }
since this happens before canDoAction, getVdsGroup() can be null
actually Yair reminded me that we do have the method isInternalExecution() that is true when command calls another, because it (should always) use runInternalAction
It get lock on the georep session in one case. But in else case, it will get the lock on the cluster level. Is it the expected behavior?
use getDiskVmElementDao(), please apply to all the dao calls in that class
Why? You already set the value in each of the three tests that you changed here. I think that this line should be removed.
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
throw exception
is this necessary?
Why do we need null first? If null happens, we should just crash.
You're not making defensive copies of the Set, how do you know that it's immutable?
Was this forgot?
Change this to PDataType.VARBINARY, as that's what the evaluate method returns.
Shouldn't we specify the encoding here?
what about getUniqueId() with some escaping (e.g. URL encoded)? It gives you human readable and unique strings like:  [engine:junit-jupiter]/[class:com.example.MyTest]/[test-factory:parameterizedTest()]/[dynamic-test:#3]
Please use append instead of "+" for performance gain.
should this be public? It seems like an implementation detail of the config file format.
No key for encryption? ;-)
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
Should the context be passed in?
can you assert something more - contanins some string, minimal length? it relies on the serialization and when it's broken you wouldn't catch it.
I think we want to reverse this sort, or the skip() below will keep the oldest n entries instead of the newest.
I think we should depend on the fact that this is an instance of EmptyByteBuf... just check it's not readable and release it
please call inChannel.finish() and outChannel.finish() as well and assert return value
nit: assertThat(e.getCause(), Matchers.instanceOf(ClosedChannelException.class));
We need to have a backup plan here if type isn't a TypeVariable.
I don't think we use final for functions in our code base
Should be hardcoded as EnumSet.class, not getErasedType(containerType)
Reason should be optional.
Add character limit check - #2105
I think this should return Collections.emptyList() if args.length is over 1 (this will remove player auto-completion, which is not necessary here)
only not null check?maybe it's better to check at least once a value with reachedStateDate != lastUpdateDate
static import
Interesting; what happens to a node in maintenance mode, but switched off? or dead? Does that become a dead node? I think I agree with your conclusion that it is not a dead node, but flagging for others to consider.
Part of this method throws IllegalArgumentException and another part returns the error message. Please make all branches throw an exception.
Can we use [!StringUtils.isBlank(versionSTring)](<LINK_0> to increase readability?
Sorry, being picky: return StringUtils.isNotBlank(version) && version.contains("SNAPSHOT");
As I see that in the other method, the parameter is also in the log. Consider adding pinDescription into the log?
This method is used only in another method, why did you make this encapsulation?
You already logged query in typeQuery()
we don't need to change the Creation classes.
+/- 1 confusion: suggestion this.startDistance = start;  that was the last one.
This way the startTime property is mutable. Looking at the diff, it was correct before..
I guess we will also need a matching input type strategy such that the validation can work properly.
Wouldn't it be better to do this in the constructor and have a final variable with it?
I think it should be: tType = ((ParameterizedType) tType).getActualTypeArguments()[cDept] BTW: In a separate branch I'm working on strategic solution to compare generic types. Will refactor this code to use the common feature.
Verify you can delete stale segments in the scenario of bug #16009
we might just follow the pattern how ArrayList works. throw ArrayIndexOutOfBoundsException when requesting an entry is out of the range.
This is an expensive call. Is it really necessary? Maybe we can get the session ID cheaper by a direct call to zooKeeper.getZooKeeper() - (checking for nulls)
Could this method be implemented with return addToByteCount(super.read());
Check buffer null.
Why that read() has to be under lock? We only need to protect usage of the "position" field (or even make it atomic instead) and let actual read() / write() concurrency to be taken care of by underlying FileChannel.
This should return a BitSet.
minor: the put-if-absent-then-add idiom can be substituted with more succinct memberPartitions.computeIfAbsent(owner, k -> new ArrayList<>()).add(partition);.
healthyWritablePartitions
+ desc
This description should mention TC and SC, I guess.
real and bigint still applies for qdigest right?
nitpick: don't need keyword public
What do you think about Comparator.naturalOrder() instead of null ?
Above check can be done against Collection instead of List.
Rogelio's above suggestion applies here as well: > I think we could modify the code a little to call one time ImageUtil.getInstance().getDimension(getFileAsset()) and store the dimension in a private variable, so that way you don't load the file twice to get height or width in the same instance. > Just check if dimension is not null and get the proper value
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Change to unmodifiableSet if we switch to a set. suggestion return Collections.unmodifiableList(tags);
return tags;
suggestion return Collections.unmodifiableMap(tags);
nit: For list with just one element, I think we could just make it in one line (unless it's too long..)
Static import fromTypes.
nit: Maybe more explicit:  Only function definition classes (classes annotated with @ScalarFunction) can define SQL functions via non-static java function. Function set classes can only define SQL functions via static java functions. Thus constructor in function set classes is used to define SQL functions.
Why to return false in this case? I don't expect this to happen, but if the cfg is deleted (by deleting the refs/meta/config branch) then the default submit type applies which could be different than the submit type that was set in the old config. This is why I think it should rather return true here?
If I correct, we could replace this by if (cfg.isClientMode()) and remove 'client' field at all.
Let's merge creating cache configuration and passing it to ignite configuration.
Redundant else.
It's a little more concise and easier to follow like this:  if (other instanceof Principal ) { if (other == this) return true; if ( this.getName().equals(everyone)) return true; Principal that = (Principal)other; return this.getName().equals(that.getName()); } return false;
other != null is redundant with other instanceof Module, which already returns false when other is null.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
Is threads.isEmpty() necessary ? I think the foreach loop can handle the same case.
with break statement here the process will get outside of the "for" loop after the first round. So only one element of threadList will be considered...
When will the write mode be DIRECT_TO_TARGET_EXISTING_DIRECTORY after the change?
Why not get the TableHandle from the CassandraTable that you create in line 98?
put an empty line after
Not that it matters but it would be "sourceFile"
Not sure this is right unless it's only supposed to work on *nix.
This method publicly exposes a field that is otherwise lock-guarded. Would be good to avoid that, or at least not in the production scope. You can do the following: - pass this directly to the constructor of SortMergeSubpartitionReader - reduce visibility to package-private and annotate it as @VisibleForTesting.
One more thing, if we consider the part between the [] to be the event name (that an eventual UST-JUL-TC parser could eventually even interpret as the event name (and same thing with fields, everything separated by '=' could be assigned to a fieldname+value)) then we should use a consistent naming pattern. UST events usually use names_with_underscores, but that's very C-ish. Since we're in Java, should we use CapitalziedCamelCase for event names?
not a field
This is not equivalent.
Can you have an @After method that unbinds this connection. This is more reliable.
Should remove, and use similar functionality in CoreAuthenticationTestUtils
Negative check on an early return?
I am reading the class again again and I think we do not need sourceColumnIndex to be class variable. I think we can keep its scope just in the for loop. Then I think the only usage of sourceColumnIndex can be replaced by columnIndex.
You touched it, you own it... Final! :)
Code for these (updateColumn(..)) could also be shared.
Hii @ribhavsharma, this extra brace over here is causing the build to fail, kindly correct it :)
Do same for this one
What happens, if the onsetDate is null?
please move it to resourceManager.resetVmAttributes
since saving-state and restoring-state cannot be reported after MigratingTo, I guess we can simply change isRunning to isRunningOrPaused
you can't get here with vm == null, so it should be removed from here.
this.
Could be just package accessible, just for tests.
Could you replace the magic number 128 by a constant?
getCells() can never be null
nit: remove "if (!familyCells.isEmpty())"
Did anything actually change here? If not, maybe we could keep the original version of this method to keep the diff smaller?
new HashMap(delegates) - don't keep a reference to the caller's map - he might change it.
Do we have to make new instance of MLRCodec every time?
Do we have to make new instance of NMFDataCodec every time?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
space after + :)
I think Local.ROOT is probably a better choice.
Why are you calling toArray instead of calling the constructor directly?
Should this check Collection as that is the super type for List and will capture Set, Queue, etc.
this.
I'm not sure if we should have a reference in every exception to the CircuitBreaker instance. I would prefer if we just add the name to the CallNotPermittedException as a field.
it is not better to use Clock.systemDefaultZone() instead ?
Can we use return new CallNotPermittedException(message, writableStackTraceEnabled); instead?
Might be worth checking that the script extension is actually loaded, and that getExtScript returns non-null.
Just a matter of preference, but I like the way regular control look better when there's a lot of nesting. You could also move the noEngineForScript check at the end, and you'd end up with something like this:  ScriptEngine engine; if (metadata.language().isPresent()) { engine = scriptEnginesByLanguage .computeIfAbsent(metadata.language().get(), scriptEngineManager::getEngineByName); } else { engine = scriptEnginesByExtension .computeIfAbsent(metadata.extension(), scriptEngineManager::getEngineByExtension); } if (engine == null) { throw log.noEngineForScript(metadata.name()); } else { return engine; }
this can be private, and just call it getCompiledJavascript, since we don't support anything else yet
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
We have a numeric pattern in PatternUtils, would be best to use that here to avoid formatting issues.
Not sure i'd go with events (yet). Model upgrade was not emitting events either, and Status flags with this change would be properly set. Let's go with baby steps, and not introduce events for these yet (unless some other good reason mentioned for it's need)
SonarLint is going complain about String concat
Soft suggestion: UnsupportedOperationException could be more suitable in this context.
Could use '/' and ']' to avoid the need for extra NON-NLS
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
Any reason not to use return type Collection<Report> here, then return reports.values()?
it is more readable to use only one return statement in method
Can this just be inlined? Is it really unchecked?
This whole block can be replaced with functional style Java, as per example given in Epdq.
This whole block can be replaced with functional style Java, as per example given in Epdq.
Should getGatewayStatus a little further down return Optional<ChargeStatus> since it is called by canBeCancelled() within DiscrepancyService as: !gatewayStatusComparison.getGatewayStatus().toExternal().isFinished() && which has the potential to NPE if getGatewayStatus() returns the possible null?
Should close this even if lineIterator fails to close.
there's no need to call super.close here
Other places in this module handle buffer == null.
Same here, add deprecation flag.
I think super implementation is correct (size == 0). Nulls are still considered part of the list, they just take no memory in internal structure.
You should see it from the side of the user, not of the implementation
System.clearProperty can be used instead.
can we please avoid copy & pasting the test ? Just extract a common method which is called once with "docker" and once with "registry" from each individual test. Helpful would be also a test that ensures that "docker" has precedence over "registry" to keep the default behaviour.
Mixed tabs and spaces. Also return userProperty != null && "1".equals(userProperty); :P
Have you tried this with an existing stream with applications deployed? I wonder if we can use the explicit streams/logs/{streamName} endpoint for this.
It's better to introduce a new variable to complex stream operation and use string format for a final message
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
A flip != 180 rotation
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
We will need to also add the new light-emitting blocks here. That consists of Crying Obsidian, Respawn Anchor (when charged), Shroomlight, as well as the various soul fire blocks.
could we change to List<Properties> or is this API fixed?
I suggest to change this signature to Iterator. Currently we use listDDFs() in a loop condition: for(ddf : listDDFS()) { ...} so it's better to return Iterator here.
What about the cases where the region is PARTITION and parallel is false, or region is REPLICATE and parallel is true? Do those need to be covered?
Why are you assigning 0 to numElementOnPage, as you assign some value again in the next line?
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1166)
take driver.manage().timeouts().implicitlyWait(timeOut, TimeUnit.SECONDS); and move it to finally statement
alias is count but the function is sum
please use StringFormat and %n instead of \n, so we're less platform dependent.
This nice plan nesting looks like you mean a specific query plan (joining tree) shape. Is it guaranteed? See com.facebook.presto.SystemSessionProperties#REORDER_JOINS
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
Public? Does not seem this method is used anywhere else
Did we want to have this normalize the path also by returning the normalized version from Path?
There is no need to call super.close() on InputStream. It is a no-op method. Instead you just need to do is.close();
AFAIK Writer::close throws IOException, so there is posibility that exception is thrown by flush method will be suppressed.
Should we use org.apache.kafka.common.utils.Utils.closeQuietly ?
let's update all the includeTextDetails references to includeTextContent
Same here. No need to train, if we are not going to use the training result.
No need to train if test is to check for null model Id?
- [x] What does this do since this is not building Java? Is this just copied from another project that this code is based on?
Extract a method for this. (You now have two 'ends with ".erl"' checks in your code)
Please, reuse your extracted method for checking if a file is an Erlang source file.
Cosmetic: Our loggers across the codebase are lowercase. Could you please change this? Thanks! :)
Same here. At this point we shouldn't be checking if our input was null.
As a nit, should have a null guard here.
suggestion Validate.notNull(dialect, "Unable to create instance of class: %s", dialectClass);
@stanislau-strelchanka - Why is this wrapped in a try/catch?
I guess you could reuse the method in ForwardingGridDialect
UnsupportedOperationException (same with others)
Use Slf4j API: log.warn("Error while closing tcp stream {}:{}", serverName, port, e);
Please explain this change and why users need this method public? @romani What is your thoughts? Why isn't writer final? I don't see a reason why users would swap output streams in the middle of execution.
possible exception
Why do we return the parents name instead of the name we store a few lines above?
Implement this
I'd say "block end cannot be before block start"
Can the current implementation of SimpleInterval represent an unmapped interval? If so, how?
Use EOF in the test.
Definitely use parameterized logging here instead of string concatenation, because otherwise this method will be generating garbage objects on every call!
delegate=true style would be just fine.
I am wondering where is it better to add this check here or inside RexBuilder#makeFieldAccess. Clients who call RexBuilder direclty will still get the NPE.
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
The persistence framework throws an exception because you should return a string here, because it can't convert a list that easily. Look at this for example: <LINK_0>
How do we deal with readonly ledger handle?
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
In any event, since we're on Java7, just: new HashSet<>();
This doesn't work as it should (and neither does the old code). If I create the following rules: Owner +1 refs/* Devs Owner +1 refs/tags/qa/* QA Submit +1 refs/heads/* Project Owners Unfortunately the group QA has Submit rights on refs/heads/*. The problem is we aren't filtering the RefRight to only the refs/* lines.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
Please change this to  java return new ArrayList<>(failures);
Add PageLogging
return element.getElementByTagName(tagName).item(0).getChildNodes().item(0).getNodeValue.trim(); Looks very long for standard text node extraction...
copying and rebuilding the list everytime an element is added to the chain? Maybe chains are not long to see the adverse impact of this now. But when long chains are build this could be seen as inefficient. Something to think about in future refactorings.
I think you mean "Liquid Glass"
Magic numbers?
Don't add 300 here or its inconsistent with the melter and smeltery recipes which use Kelvin in ModTweaker. There is a Tinkers Construct config option to show all temperatures in Kelvin so they match the ModTweaker recipes for pack makers, which is why its different from whats shown in the GUI/JEI.
Similarly use the Java 7 template
Probably enough to have Longs.hashCode(pointer) which should be a little faster.
HashUtil.combineHashCodes
why not use getVmDeviceByVmIdAndType ?
it could be nice to cache the result since you call it twice in remove
after you changed that dao call the if condition is no longer neccessary the loop can be removed completely - replace it with use of Entities.businessEntitiesById
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
done for patch3.
Nit: Unnecessary extra level of indentation.
I don't know what has been @sjka intentions and I agree that this could be removed... ... but didn't we have a discussion in another topic where you / Kai argued that we cannot rely on correct usage WRT to the nullness annotations for code that is called by third party ones (e.g. binding developers etc.)? So, if we don't trust non ESH framework developers that he uses annotations classes correctly, isn't that exactly what you want?
Having a builder instead of a public constructor is usually better
Activity state util check before starting any of this, maybe?
Even if we have currently only a 2 state discrimination here I would maybe use an enum (like SitePickerMode). Wdyt?
Can we move this logic to the task trigger handler and make it one transaction there?
Can be simplified using Hamcrest.
great if we got rod of the magic flag :+1:
I think this solves the problem, but why aren't we removing the processor field from this object? If it's dangerous to reuse it, and the one stored here isn't necessarily the one used elsewhere, then surely we shouldn't store it for later access?
This allows null values, though that may be fine.
A redundant else statement
Can you repro this on master? If yes - definitely worth filing.
Does this work? There is no import for the builder nor the DefaultMetaData.
Is this really necessary? Isn't the base class method working?
Same here mapper can be initialised in constructor
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
are these setters used anywhere?
This should be simplified to just: >return value;
This binding is redundant if the AutoscaleParserModule already adds it. Remove it from here?
Shouldn't this come from the builder?
Call super first.
Please keep the indentation consistent.
This should also test that the value matches one of those considered acceptable.
The directory must be readable.
The return type should be IEclipsePreferences so as not to expose an internal implementation in a public API. Curiously, I don't get a warning here, only in EMFCompareRCPPlugin. Don't know why, but must be changed anyway.
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
Should me make it default and use Objects.requireNonNull? The logic of the setter is a bit unexpected
Add reasonable toString() method, returning null doesn't seem as proper way.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Pager builder can be replaced by Pager.single().
this.stashedStarts.isEmpty()
nit: parenthesis are extra
We're just swallowing this?
Maybe use message "Config job.name is missing" ?
Should this fire regardless of if the prior delete succeeds?
I think it's nice to do checkNotNull(item, "item") so the NPE message says what was null. Otherwise one has to go to the source code line to check what was causing the NPE.
why public instead of protected ?
Perhaps you could extend these branches with log messages why we are using a certain url.
Lol! I just realized this message has always been incorrect. If a user's rule is configured as: xml <rule name="MyRule" language="java" minimumLanguageVersion="8"> <!-- Java 8 rule! -->  We are printing something such as: > Unknown minimum Language Version 8 for Language 'java' for Rule MyRule; supported Language Versions are: java 1.3, java 1.4, java 1.5, java 1.6, java 1.7, java 1.8, java 9,   So, a user would understand, that instead of 8, they should write java 1.8 as: xml <rule name="MyRule" language="java" minimumLanguageVersion="java 1.8">  which would not be valid. We should probably just do: java language.getVersions().stream().map(LanguageVersion::getVersion).collect(Collectors.joining(", ")));  to produce: > Unknown minimum Language Version 8 for Language 'java' for Rule MyRule; supported Language Versions are: 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 9,
Is there a reason for not using the MoreObjects.ToStringHelper instead?
This might not work as the Db version is changed to 3 and the check for old version is 2.
nit: remove this extra line
This should be handled by the nodeDelete return value, so we don't need this catch.
Would it better to catch InterruptedException, then catch Throwable?
This would be safer if rewrite it in the following style: java return getMetadata() == null ? null : getMetadata().getName();
Is it really filter name?
I know this default is here for backwards-compatibility but I'm not sure about the value. If I create a factory - "OffsetDateTimeFactory" - I wouldn't want that to be the logicalType name. In other words, what do you think about the default implementation being: default String getTypeName() { throw new UnsupportedOperationException(); }  This way it is required by any new LogicalTypeFactory to implement it?
waitUntilContainerStarted is executed by .start(), no need to do it here
See #3128 suggestion .withNetwork(network)
maybe this change is not needed anymore
there is already some escape method/utility/lib so take a look if this can be reused here
Use enhanced for loop here: for (Header header : headers).
For loop?
Need to add if (capacity != null) capacity.incrementAndGet(); here.
Isn't this better done at the beginning of onResponse() instead of here?
Remove newline
just return "" instead of new String()
check for null before referencing?
I think we will have to discuss whether or not to include the fromKafka functions in this class.
rename to clusters
I think you should use this value from FixturesTool FixturesTool.VDS_GROUP_RHEL6_ISCSI
I think (or want to believe) that the .toString() is implicit when formatting, hence can be removed from here.
I think we have a race here with close.  T1 check assertOpen T2 close() T1 factory.apply( slot )
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
Does it make a difference whether slotStatusUpdateListener.notifySlotStatusChange is called before effectuating the state change on slot? I am asking because transitionSlotToPending and transitionSlotToFree do it in the different order.
I think this solves the problem, but why aren't we removing the processor field from this object? If it's dangerous to reuse it, and the one stored here isn't necessarily the one used elsewhere, then surely we shouldn't store it for later access?
Can be simplified using Hamcrest.
Alternatively... java Properties properties = new Properties(); if (inputStream != null) { properties.load(inputStream); } return properties;
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
It's better to assertInstance(value, CStringValue.class) first. This way, if the value is of the wrong kind, the test fails with an assertion failure rather than an exception.
I think this is the same as this.newValue = newValue; ??
Could use a StringReader instead of a ByteArrayInputStream here.
Maybe update this to work the same as is implemented in GeoserveRegionsService ? i.e. features.getJsonObject(0)
Now when we change handleException method in commcare controller we should also change getting message value from response in javascript handlers as you did below for other ones. Please find all handlers that can be affected by your changes and fix it
Looks like we need only keys of the map, not the whole map.
This class has no superclass, so I'm not sure we need to call super() here.
I think !isNullOrEmpty(stream) can be removed
What is this log statement for, exactly? Seems like a trace?
One small change after running. Add "0x" to the beginning to drive home that people are looking at hex values.
How do you know you got the right ones back? Would be good to flesh out, look for off by one errors, etc
nit: You could have a private method that takes a preparedStatement and invokes executeQuery() on it. That way you can also put the metrics logic in that method.
should we make this 200 configurable?
Use same order as the field declarations.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
synchronized?
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
Can we just check that the customProperties is not null?
What are key/value types ? Map<String, String> ?
i'd prefer returning a new instance DownloadParams when downloadParams is null
isFiltered()?
I would prefer "refresh" and "filtered" without the ?
I can't decide if StringBuilder is overkill. Seems like String concatenation is enough. What do you think @christiangoudreau?
Before and After annotations are redundant here since test class is extended from testcase, I suggest to remove inheritance and keep using annotations here.
Seeing that the 'Edit Button' patch is already in master, I'd suggest rebasing this patch on top of master to avoid any possible merge conflicts.
we typically write the annotations on separate line
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
Integer.parseInt
It'd probably be worth logging if is an invalid value rather than silently ignoring the input value.
Files.asCharSource(file, UTF8).read()
I think this should be null as well
Do we want a space here before the brackets?
This can be made final
why not use @Inject ?
why rename it from slubdd to slubhh? ruleset_test, like in the other place, is way better
Note that I asked one of the authors of the "one sql to rule them all" paper. The only reason that they use wstart and wend was because of the layout for a paper. I got suggestion to use window_start and window_end. I also believe in a JIRA or an email (sorry I cannot recall which one it is) we agreed to switch to window_start and window_end. So I will suggest we keep window_start and window_end, which can be understood easier than wstart/wend.
We need a condition check/assert here or somewhere because VoltDB should not allow for 0-column table.
I'd liked to have seen more of this type of code move to the View rather than be in the Presenter.. even if it's as simple as moving all of this to the View and do something like view.expandSubType(subType) and have all the Element manipulation in the View. Would you agree.. Happy to consider as a new JIRA/work for the incremental/agile development.
why ConfigurableApplicationContext, not ApplicationContext?
Better to not use a list here: Queue<Type> next = new ArrayDeque<Type>();
So that this aligns with the rest of the codebase, let's remove the final keyword here.
This needs to be synchronized because of fSources
Should mark @Nullable here.
can't you use CollectionUtils.isEmpty?
Should call the equivalent for Chrome. It should also check that Chrome (and Firefox?) is really available (and return or not in testBrowsers).
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
change please :(
Nit: this could be: absoluteUri(DHCPV6_HOSTS, clientId)
Include the exception e in the logging message
please leave it that way - it's intentionally referencing the deprecated version.
If the expectation is that this always get built from Bugsnag.buildReport we should remove the public here to make this package protected. This will enforce the API usage which will make it easier to maintain and refactor in the future.
Comparing with [TestExecutionResult](<LINK_0> shouldn't this Constructor be private?
you can have a private base constructor, and have both call it with different parameters.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
This whole block can be replaced with functional style Java, as per example given in Epdq.
This whole block can be replaced with functional style Java, as per example given in Epdq.
Avoid the use of swtDefaults(). fillDefaults() and explicit alignment makes the layout logic easier for others to read. applyTo() is preferred over create(...) when attaching to a control since it's easy to generate a ClassCastException if you mistype this and omit the ".create()". The applyTo version is also shorter. Change this to: GridDataFactory.fillDefaults().align(SWT.BEGINNING, SWT.CENTER).applyTo(l);
Should this variable be renamed to control?
this should return parent2
good multi-thread catch
What if fSelectionProvider is null? NPE will be thrown.
not a field
Embedded headers will never work with native encoding/decoding - so I suspect we can do away with the separate setting for native deserialization.
This payloadTypeCache must go to the MessageSerializationUtils directly. I see you have something similar in the JavaClassMimeTypeUtils for the mimeTypesCache. So, why don't be consistent?
What happened to this method? Why isn't it a private anymore?
Just use inCoreLimit here. Don't convert units to MiBs.
Don't we need to the close the streams?
this stream should be closed.
as this is not handled (it will always return null), I think it would be better to return a UnsupportedOperationException or to handle it (but it will take some time : db, rest mappings)
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
Why do we want to return it if we have methods to manage it. It seems like encapsulation issue.
This method doesn't need to return anything. When completed, the connection should be considered 'closed'.
Why support amend during bisect?
I'm unsure if singleton is the best option here as the asterisk connection is created and managed by the endpoint so if you declare it as singleton you may have conflicts if different producer/consumers do a login/logout/addListener
This and line 59 can be a global variable to clean up tests a bit
nit: can use ImmutableMap.of(...)
Are x_forwarded_for values actually encoded in Hive?
@fanifieiev the same above.
@dmzaytsev let's replace this with a try-with-resources - JsonWriter is Closeable, so I think it might work. If not, let's close it in a finally block
You're not closing DataOutputStream. Check SparseVectorCodec too.
Can use Objects.requireNonNull instead.
This is used by tests only ? Do u want to create ImmutableScan over a new Scan()? Or direct new ImmutableScan is enough?
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
Add reasonable toString() method, returning null doesn't seem as proper way.
I would move this to a constant so we can access it from tests as well.
this.type == address.type, do we need it?
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
shouldn't this be: return setAddress(null); ????
Do we really want to sleep for 1 sec? Also, with a constant sleep time it is possible that one thread gets starved of locks, if other threads keep jumping in. Might be worth sleeping for a random amount of time, say between 50 and 300 ms. Also, you're not converting time to ns here.
This should probably be removed
method is always null so this is dead code.
NoSuchElementException is more accurate
log() so that log.html viewer knows what image was chosen
What happens if there is an element without an image?
Why iv.removeValue(i, this) and not iv.removeValue(i, aCause)?
This implementation looks correct to me, but I think it should have its own unit test, to be sure, and to prevent regressions. I think testing all the boundary cases for arrays of length 1, 2, and 3, would be sufficient to cover all possible cases. (i == 0, i == a.len-1, and 0 < i < a.len-1)
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
This code repeats in multiple places. Until we replace Slice, please keep the code in SliceUtil or another central place.
This should be "else if" to avoid redundant checks. It can't be both, so if the first check passes there's no point doing the second.
How does this work when an item is evicted from the underlying cache, but is still in locker?
this shouldn't have been here either, format is required.
need to handle case where fieldMapping is a macro, so output schema is not available in configurePipeline
style: should have something on the previous line besides just return. Also, indentation for a new line should be 2 spaces and not 4.
Is there a reason not to initialize this where it's declared?
Should we make this private and remove the @since tag?
I would prefer to make this public since otherwise it's impossible for clients to correctly initialize the class. Mark it as @noreference to hide it from the API.
nit: the return true; statement could be moved inside the try block.
Same as above: if we change CONFIG_WITH_KEYSPACE to have KEYSPACE, we should also fix the tests in this class.
nit: don't you want to check that it's not initialised soon after? although I suppose that's a tiny bit racy/flaky
I don't know what to do about it right now, but I would be a lot more comfortable if the Model lifetime was connected to the PsiElement lifetime. In my ideal world, the models are just a veneer over the PSI. That's not to say it's the _right_ way to do it -- just a gut feeling. I worry that local caches in the model can become out of date as the PSI changes (the user types, and/or refactoring). Maybe my concern is unwarranted. Do your concerns match mine?
instead of setEngineSessionId - why not having it at ctor?
just noticed... the key cannot be soft limit if session id is null, please remove condition. anyway, even if so, this condition is unneeded complexity as bellow the key is set anyway.
Should be "InstaPost" actually.
Can put the closing single quote as part of the subsequent String
I don't like to define code as a String. This looks quite ugly and hard to maintain. Is there another way to set this?
These local variables can be final.
As for the previous tests, the two assetions above can be removed I think. But I'm happy to open a new issue for that if you prefer That applies for all the other tests below as well
expectedChromsomeList can be declared using Collections.singletonList("11"), inside the assertEquals (or outside if you prefer for readibility). This is an small method and is not really necessary here, but in bigger test methods reducing the number of lines improves the readibility.
Consider using i18n for this title.
i18n
I realize that this was like this before, but can you make this title localizable like all of the others?
I don't see you overriding this in your Bounded implementation, why make this protected?
This can be made package private (no modifier) instead. The same applies to generateSendFailure().
we're checking _kafkaProducer outside the lock. _kafkaProducer may change by the time shutdownProducer() is called. Can we instead have a shutdownProducer(producer) that does this comparison under the lock and calls shutdownProducer(), or something along those lines?
The incore merger works in memory without a working tree. Does he need attribute handling?
This isn't necessary. When you need the inserter call getObjectInserter(). Your super class manages allocation and release for you.
Use Calendar.MINUTE.
In this case we ALSO want to include the "if it keeps happening, talk to the person who asked you to collect data" message. I think just concatenating the two with a space would be fine (and concat does the right thing with LTR languages, I believe)
Minor thing: I'm generally not happy with reassigning method parameters.
Also try to refine 404 errors to a ResourceNotFoundException to let the 404 fallbacks work
There's no need to compute the error message in the general case when there's no failure, so please move this (duplicating if needed) a few lines down to where it's actually needed.
I believe some of these exception deserve to be given the jboss logging treatement
Nitpick: space
unused result variable. We could remove that I guess.
can you make those no-arg constructor private?
Will the exception thrown also contain the message contents/headers that could not be extracted for logging?
Use hasToString assert
nit: ROUND_ONE
May want to add a failure message to this assertion that includes the expected value. Otherwise the failure message will just say that it was false when it was expected to be true and we'll have no idea which value it failed at.
[minor] It could use (slightly) better naming - ie hasCancellationSucceeded or something (more along the standard naming). handle is a bit generic for me and in this case the method determines whether something has been successful or not.
Was this detected by findbugs?
This whole block can be replaced with functional style Java, as per example given in Epdq.
You almost got me right now. :-) There is no need to test the injection point. You only inject instances of this interceptor to the injection points where it should do its work anyway. Because of that it is unnecessary to provide and check the injection point. Just delete this method and the field and constructor parameter and change java private void invoke(IMethodInvocation invocation) throws Throwable {  to java @Override public void intercept(IMethodInvocation invocation) throws Throwable {  and you should be fine. :-)
Why is secondary always false here?
We need to check that the interceptor was executed.
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
Just a thought is the contract for running that its fully started? As Camel has a state called .. starting which is the phase it do when it startup. But I assume running is after all the startup stuff and its really running.
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
Unreachable code. The button is only visible if the user is signed in and the action is defined.
This should be in the update() method below, ensuring that we save preferences even if we were invoked by the key binding to "Enter", setup in our constructor.
If it's likely that we'll ever want to do something with the event in onCancel, it would be better to pass e here rather than null.
For loop?
This breaks isDestroyed().
should this count be parameterized?
IF EXISTS should be reflected in unparse
It seems that the following does the same thing with super.unparse(...).
This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this
Same here. It's more readable when part of deserializeValue
You could move this line between 121 and 122
I think it was more readable with try-catch was part of serialize
You no longer need to pass 'driver' object
Change to assertion
again - encapsulation
This assertion could be removed as it seems to test the Java type system rather than our code
Can you use the assertThat(..) syntax.
nit:can we flip the l-value and the r-value here, everywhere else in this file constants are on the right side. #Closed
Should there be a ITimeLineEvent interface?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
This is a very costly operation finding the event size every time, can't we do any other optimizations
This validation provider still uses JSR-346 string in problem's message.
Wrong JSR number in validation provider.
Are you sure that this class contains all that is needed/changed/new in cdi 2.0 specs? Aren't they any different?
Follow the same order of argument definition. Always add requireNonNull unless we are sure it is not needed (@Inject) or the value can be null (usually annotate by @Nullable).
s/v/memoryManager
Let's use StandardFunctionResolution for the constructor; so it's more general
no need to say "public" here, it is always public in an interface. "static" is important though.
replace with fType.add(DescriptorType.STRING); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
We need to have a backup plan here if type isn't a TypeVariable.
Collections.emptyList()
See below (return copy)
.getValues() is deprecated use .getValuesCollection() (same result)
can potentially return null if both are. is that ok ?
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
This method can be implemented as return a - b;
Use ServerUtils.isMainThread() etc.
@orhan89 the transmitLatestState() was created for this cause already. I think it's better to store the latest callState, you get here: <LINK_0>, and send it in transmitLatestState()
make it static
why not public?
TypeElement.class::cast
working with prefetched columns should be faster (and more stable) than using findElements every time
The exception possibly thrown here should be caught - there are no known cases of non-integer values being used here but JsonToken.NUMBER is not guaranteed to be an integer. The minimum handling should be to still send the report, though the maximal handling could be to create an internal report for it.
builder never used
These tests are OK, but I think we should have tests like the ones that you did for JSON, checking that the result is correct, not just that the cursor is positioned correctly.
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
If we are adding mChartboostBannerto a container view (e.g. the bannerContainer from initBanner()), then I think this should return that bannerContainer.
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such name. And as a user I would expect them to have higher priority. Maybe it worth checking all TopLevel views first. I would also vote for making a parameterizable method View getView(String name, boolean recursive) and maybe changing only the API calls which are really related to search. Otherwise it it hard to predict the impact of the defaukt behavior change
Optional: this could be done without the index variable: for (int i = 0; i < emailPick.getItemCount(); i++) { if (value.equalsIgnoreCase(emailPick.getValue(i))) { return i; } } return -1
since getTerminalAtIndex can return null there should probably be a null check here (realize that it's vanishingly unlikely given the current contents of the panel!)
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
Should it be logged at the error level?
and doing the instanceof check here instead (trace instanceof TmfExperiment)?
you can use containsKey()
keep primitive, it's not used in JSON and can't have null?
Update this method to also return true if status is HALF_OPEN?
If the values are empty, shouldn't we return true rather than false?
Would you please explain why clear() need to call ?
Another minor note, any reason not to merge this into a single check? if(values == null || values.isEmpty()) return true ;
this is the exact context of the AbstractJpaDao.em() - shouldn't it be only the responsibility of the interceptor to set the entity manager to the dao ?
well, the probability is very low, I know, but shouldn't be >= ? in terms of readability I would prefer to have if (fetchTime.compareTo(vmManager.getLastUpdateDate()) > 0){... } else {.. } - but that's subjective I guess, so for your consideration
@highker typeManager member variable can be removed now
be a good citizen and call System.exit too :wink:
@inverno We have 2 times "Second argument" :)
add a System.exit(-1) after the usage output
We should add a check to make sure the end time is not in the future by comparing it with the current time.
This will crash if the dateTime has no time zone (I didn't have Optional back then) like it's the case for all-day tasks.
This should return 1 if the time difference between start and end is > 0 (in any unit), to ensure we never round something to nothing.
same logging here as in perform next operation
In separate line ?
Not needed, please leave the method empty
The AppCommand is supposed to notify the desktop when its state changes. This happens here: <LINK_0>
shouldn't we check for if (_closed) before we check for if(_next)?.
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Could you replace Arrays.asList by Collections.singletonList ?
To make this more testable (not depend on the COPEPlugin in the test) you can set the SnapshotManager to take in its parent directory. That way the test does not depend on other things which are not under test. And you can perform test cleanup easier (like deleting test files). And this way the SnapshotManager has one less dependency.
Are you going to reuse this method?
defensive copy?
Lists obtained from a message are immutable. No need for extra copying.
Shouldn't this close the iterator before returning the list?
the return here may be either Version or VersionOrdinal, do we want to upcast or downcast to ensure returning a single type? Doesn't appear to be a problem currently though
inst -> dialogue
Is there another way to get the number of channels? This seems sketchy.
Gary, it must be opposite:  public interface Closeable extends AutoCloseable {
Try using StringUtils.isTruthy(this.path)? <LINK_0>
Who does the datatype conversion from Hive to Phoenix?
return checkAndRequestPermissions(activity, EnumSet.of(type));
Why is hard to read generic coding used here?
It looks like you are returning an empty ArrayList keys
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
You don't need the ternary operator: the parenthesized boolean expression is already the result. Also, probably it should also be checked that the collaboration is a <<Protocol>> to start with.
one param per line and leave the first line empty
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
So that is getting a thread that is local so as to get the classloader?
How about rephrasing? e.g. Skipping start of eslint-bridge server due to the failure during first analysis
I think we could add a final here: suggestion final HTMLElement element = typeSelect.getElement();
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
Can you repro this on master? If yes - definitely worth filing.
It would be much better if you declare ActivityScenario variable globally and initialize it before the start of the test inside another method named setup which should be annotated by Before keyword.
You can remove this to simplify it to getActivity().finish();
The method says afterComputeAggregates, but computeAggregates is not called. It's safer to do so, as we might some day not call resetAggregatesComputed if the aggregates weren't computed.
return queryId
if this is hit often, the String concatenation may slow things as opposed to using a StringBuilder. Also, would it be better to not append/concatenate the empty string "" if the treeId is null? Maybe do it like this: java StringBuilder sb = new StringBuilder(indexId.toString()).append("."); if (treeId != null) { sb.append(treeId.toString()); } return sb.toString().getBytes(Charsets.UTF_8);
why not pass blobDataType here?
return optional.isPresent() ? Stream.of(optional.get()) : Stream.empty();
This should probably be static
NITPICK: Can you indent this in to make it readable
Remove throws Exception
if (realm != null) maybe - just to be safe.
Just use UUID.random().toString() as user name, it should be safe enough.
Should be- setTitle(text.asString()) not setText.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
style nit: we don't use braces around single line blocks
Is it required to have doScan(...) both for producer and consumer?
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
Clickhouse has a different rename syntax (<LINK_0>
Multiple method(*) methods
[Checkstyle] INFO: '200' is a magic number.
You should leave gender here.
K **is** comparable because K extends Comparable<? super K>. We can't use natural comparator here. I believe this is correct fix:  java final Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo); RedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);
.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))?
Let's have this enforce that hasher is the equality hasher.
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
Here group.getSelectedVersionGroup() is not checked for null, though in other cases the check is used.
reusing the variable here seems a bit confusing to me. It's creating a new versionRange object so why not declare a new local variable "newVersionRange" ? this way you could clearly name it "(old/original)VersionRange" and "newVersionRange"
@Suseika how about to check PsAll.enter() returns Identity from 3-rd Pass?
@xupyprmv please join these lines
@piddubnyi back 4 spaces
please move setText and icon into OpenPluginDependenciesAction and remove it from PluginsView
Add here collapseHandler = new CollapseAllHandler(getTreeViewer()); IHandlerService handlerService = getSite().getService(IHandlerService.class); handlerService.activateHandler(CollapseAllHandler.COMMAND_ID, collapseHandler); to handle the standard key binding for the collapse all command.
You'll need to split the multi-catch blocks since the classpath is set to use Java 1.6.
The empty string in the constructor is redundant.
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
We can remove this null check (we already check for null after createTurnRelation and the 'default' is 'nothing is null').
Should add a method calculateSettlementDate on ResolvedCdsIndex that takes the valuation date and reference data. Like calculateSettlementDateFromValuation on ResolvedCapitalIndexedBond.
Do same for this one
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Preferably have one call the other?
Nit: unnecessary this.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
Would we want to preserve the previous selection (before archive radio was selected)?
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
A LinkedList is better since you don't seem to access specific indexes anyways.
suggestion if (server == null || server.getUrl() == null)) { return this; } if (servers == null) { servers = createList(); } for (Server existingServer : getServers()) { // If a server with the same URL is found, merge them if (server.getUrl().equals(existingServer.getUrl())) { ModelUtils.merge(server, existingServer, true); return this; } } // If a server with the same URL doesn't exist, create it servers.add(server);  reduces complexity
There is already a getServerNames method in GerritManagement. Moving that to PliginImpl would make it so that you don't need to implement it twice.
nit: missing space after if
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
This could be combined with the previous line.
tiny bit more efficient:  private List<ColumnWriter> getLeafWriters(GroupColumnIO group) { List<ColumnWriter>() writers = groupToLeafWriter.get(group); if (writers == null) { writers = new ArrayList<ColumnWriter>(); groupToLeafWriter.put(group, writers); } return writers; }
You can use the IntObjMap here as well
maybe same logic can be addressed in less lines by using Streams, it would also help to read this method faster... Eg: Streams.stream(groups).filter(...).map(...).collect(...)
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Calling getPostListAdapter() will create the adapter if it doesn't already exist, so instead we should use mPostsListAdapter != null here.
check for READ_ONLY style is missing?
Please String.format() this.
Let's include the giver and recipient here too
return queryId
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
no need to change at here, because it is only for Date type
This may produce incorrect results if the name of the service contains the "Resource" word, and we do have one of those: ExternalComputeResource. As what you want to do is to remove the "Resource" word only if is at the end you can use the following: String name = node.getName().replaceAll("Resource$", "");
return array == null || array.length == 0
This should be static technically.
Looks like this inserts the element in ALL null fields of the array. Also, docs.
Maybe add || delegate.isNull()
This should not be public
ignoreNullScoringCandidate
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Typically we use Map on the left hand side rather than HashMap
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
This is the same as isSMimeEncrypted except for checking for a different value of Content-Type, so you should create a common method that takes APPLICATION_PKCS7_MIME or MULTIPART_ENCRYPTED as a parameter
Please add a space after if
Should one of the following happen in case contentType passed is null? - throw an exception, or - set this.contentType = null
It would be slightly better to check that project is opened first instead of letting it throw CoreException in hasNature().
style-nit: we don't use curly brackets around single line blocks
submonitor?
this shoud be executed here only if the operation is "copy" (which is possible only for template disks now, is the disk profile even relevant for template disks?). for a "move" scenario it should be validated on MoveDisksCommand
The null check should be in the canDoAction(), not the executeCommand()
shouldn't this be "!=" ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Could you also add a check for static explain whether the table BIG is the picked as the left table of the cross join? Thanks!
Why we update our code with AND while the test case sql is with OR, i kind of confused.
IMHO, what you propose is only a workaround. Users might encounter this error if he wants to merge the project in RelBuilder. Instead of changing RelBuilder#shouldMergeProject to false, I am wondering if we can find the root cause and fix it.
Doesn't DroolsAbstractBiConstraintStream have getAPattern()? If Tri's have getAPattern(), getBPattern() and getCPattern() then Bi's must have getAPattern(), getBPattern() - but not getLeftPattern() and getRightPattern() and Uni's getAPattern() and one day Quads will have getAPattern(), getBPattern() getCPattern() and getDPattern()
You must not init here the command. You configuration page should configure the pattern provider and it will instantiate the command on demand.
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
I don't think this check is relevant
Indeed, that is better than my suggestion. Let's do this.
Put the logger invocation in the "if" block. Otherwise, when reading the logs, we will not be able to determine whether the IP address was updating or not.
please move the isEmpty methods to the scimSchema
is it not empty if for example type is an valid empty string?
You can check if there was anything spilled with spiller.isPresent (however, now, once this is true, it will always be). Let me think about that, ok?
Why we declare full path when you created the method getResourcePath to make this simple? Lets change this to use the new method.
inputheader => InputHeader.
Indentation is very special as it does alot of extra checks and balances because of it's complexity. Please change verify to verifyWarns to turn these checks on. You should be asked to change the input file with this.
I'd like to see the code further simplified if possible please. If calling Thread.interrupt() on an already interrupted thread is a no-op, then I'd suggest the following instead...  if (exception != null && !currentThread().equals(testThread)) { testThread.interrupt(); }  ...and remove the testThreadInterrupted field and the separate interruptTestThread() method. Note: this is common practice to move the possibly-null variable to the argument of equals so that a null value returns false for equals without requiring the extra != null check. For example: "nonNullString".equals(nullableString) instead of nullableString != null && nullableString.equals("nonNullString") Note: also common practice to put the cheap-check first in an if condition: if (exception != null && !currentThread().equals(testThread)) ... instead of if (!currentThread().equals(testThread) && exception != null) ...
shall we use PrestoException for StreamingJsonResponseHandler?
Replace with Objects.requireNotNull.
... and below.
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
Remove entire wrapper finally block
The string should have SystemPurposeComplianceStatusDTO instead.
Should use newGson(), otherwise it's not actually going to exercise the ServerJsonDateAdapterFactory
Use proper encapsulation techniques here. The facts collection this object holds should not be shared by other objects, nor hotswappable like this.
Curious why login logic has been changed here also.
Why do you use sleep ? It is highly discouraged, wait for an element instead
As you noted this should be resolved once we're mocking the network requests, but for now this sleep is causing the test to fail for me. The upload happens faster on my end and so by the time the test moves on the snackbar is already gone from the screen. I'm hesitant to spend too much time on fixing this as-is since we plan to set up mocking before we start really using these tests, though.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
Why is hard to read generic coding used here?
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Is there an alternative to SHA1PRNG? SHA-1 is considered insecure.
Make this private again and add a method int generateRandomNumber(int digits) instead.
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Since the method is simple public synchronized Project removeProject(Project project, User deleter) throws ProjectManagerException { projectLoader.removeProject(project, deleter.getUserId()); projectLoader.postEvent(project, EventType.DELETED, deleter.getUserId(), null); return project; } Would using mockito to verify the internal calls be a better test? This will cover for example the user parameter is passed correctly.
any particular reason why this method doesn't require an IJavaProject ?
I would replace " " with ' ' since there is only one character.
Recommend to use ToStringBuilder
suggestion return getClass().getSimpleName() + '@' + this.id + '#' + this.version + ' ' + toJson();  IntelliJ thinks this is better
You might as well use <LINK_0>
If there is no match the exception should not be discarded, we should probably have some kind of fallback handler for any exception type that is not explicitly listed.
can't we use Util.checkNull(handler, "handler"); simply?
Use _Objects.hashCode(name)_ instead of _(name != null ? name.hashCode() : 0)_ And the same for other similar code
If you change hashcode, how about backward compatibility?
Minor: we usually delegate to Objects.hashCode to simplify these. And Objects.equals for the above. (The guava ones because we support java6).
Please use CanDoActionAssertUtils.
remove 'Assert.' (there's already a static import)
Optional: consider using assertTrue(EXPECTED_EMPTY_CAN_DO_MESSAGE, canDoActionMessages.isEmpty())
Spuild we ise IDType here instead?
Remove this message, or set it to something more appropriate
@tmarzeion you should start PatientDashbordActivity here with the created patient :)
we don't need to change the Creation classes.
I'm concerned about the stopTimer method. My thoughts: - the get() method of optional generally should be avoided. This is a pretty good article on optional usage: <LINK_0>, it sums up a number of similar points. I think one to help this is to mark startNanos as @Nullable and just use a null value and do a classic if( null )  type of check. Though, we still have a lot of internal state going that route. Even if we allow for disabled timers, assigning startNanos always to System.nanoTime would not hurt that much (we are still talking a ns operation, that is not a place to make performance improvements).
This needs to be System.nanoTime converted to microseconds. Otherwise we loose precision.
Multiple threads can call updateAlarm at the same time, so we need to make sure that the usage of the outstandingAlarms map is thread safe.
Simplify method to: m_associatedAlarms.removeIf(associatedAlarm -> associatedAlarm.getRelatedAlarm().getId().equals(alarm.getId()));
We should use the alarm that was retrieved within the transaction i.e.: suggestion OnmsAcknowledgment ack = new OnmsAcknowledgment(alarmInTrans, DEFAULT_USER, now);
The synchronized block needs to include this read from the map: - Thread 1 reads eventNameToListenerMap, gets null - Thread 2 reads eventNameToListenerMap, gets null - Thread 1 enters critical section, creates new HashSet containing listener 1 and stores in eventNameToListenerMap - Thread 2 enters critical section, creates new HashSet containing listener 2 and stores in eventNameToListenerMap Listener 1 has been lost.
Currently you're parsing the message JSON twice: once in extractDataFrom and once in getMetaData. This could be improved by modifying extractDataFrom to use the output of getMetaData perhaps.
As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency.
Let's keep this config. Use URI dataDirectory as the only source of truth to determine the FS: 1. In FileSystemModule, Use dataDirectory.getScheme() to decide what FS module to install. Local file should be configured as "file:///raptor" (<LINK_0> 2. Get the value of dataDirectory and convert it into Path baseLocation. Use it everywhere. Ideally we should avoid using File as much as possible.
For each of the returns in this method, I would return the canonical file, just like it previously returned the canonical path.
infinitest.filters, i see that you are using only one time now, that's a good thing. What do you think to extract it in a constant? something like INFINITEST_FILTER_FILE_NAME
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Note that the Format.toString() case statement only needs explicit cases for those formats that are not a single word; otherwise it defaults to the enum string with first letter upper case. Please remove these 2 lines, rebase and let me know pull request is ready.
This should stay final
I would go with if-else as this is NPE vulnerable. But if you want to use a switch-case then please add a null check before it and return if he selectedProtocol is null.
same as with get name
ignore if you'd like: Bookmark bookmark = getModel().getSelectedObjects().isEmpty() ? null : getModel().getSelectedObjects().get(0); BookmarkModelProvider.this.getModel().setSelectedItem(bookmark);
Can make this into a singleton as we have with UNSET.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
This can be static
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
This is unintuitive - why not return the number of characters you need and allow the calling function to decide what to do with it?
did you forget to close this one?
You shouldn't need to specify it. I guess that Kubernetes API is the default mode.
This method was added in java 8. It will fail with java 7. Note that it might compile on Gerrit because we compile with java 8.
I don't quite understand why the Keys of this Property Map are localized Strings; if these Properties are meant for being processed programmatically, I would expect Strings that don't change when the UI is localized.
instead of != null here, you could do a instanceof ISegmentGenerationListener. There shouldn't be any ClassCastException, but this way, you would avoid any such error
Hardcoded list of locations have to be removed before merging.
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
Do you think we need sync control on all the map operations here?
Can you get just the crn from the database?
Can you get just the crn from the database?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Sorry I missed this in the first review, but in AnkiDroid we don't like to use if / else without curly braces; we prefer the one line form: double denominator = (mSum == 0) ? 1 : mSum;
This doesn't handle when the timeout occurs you probably want to handle acquiring the semaphore differently than timing out waiting for the semaphore.
suggestion var service = getCandidateServicesToMatch(serviceId)
what's the use case for a service that doesn't want to implement Scoped?
suggestion LOGGER.trace("The service with name [{}] is not found in the cache, try to find it from [{}]",
This doesn't work as it should (and neither does the old code). If I create the following rules: Owner +1 refs/* Devs Owner +1 refs/tags/qa/* QA Submit +1 refs/heads/* Project Owners Unfortunately the group QA has Submit rights on refs/heads/*. The problem is we aren't filtering the RefRight to only the refs/* lines.
I don't see a reason to return an Iterable here instead of the more specific return type Set. The result is very small and a lazy evaluation is not necessary (which could justify returning an Iterable). Returning Iterable instead of a more specific type unnecessarily limits what the caller can do with the return result.
Should probably throw if the user doesn't have read access since they shouldn't even be able to ask for this set if they don't have project access
sorry... forgot... if multi value we need to create a collection.
not sure why we need this conditional. if I put no_argument as default False, value True and converter Boolean I can achieve the same in properties file without anything in special in implementation, no?
I'd rename this method to isTypeOfAny and introduce isSubtypeOfAny for the following two lines. Also I tend to no use !(a || b || c) when it's too long, use !a && !b && !c instead.
Unnecessary whitespace.
Use constants in airlift SizeOf.
ditto -- use constants in airlift SizeOf.
You want g.add(null, checkBox) and put the display name onto the CheckBox widget. This way it shows [x] Foo instead of Foo [x] and users get a bigger click target (the label text) to mash with the mouse.
check here, seems like result must be returned, but new new CheckBoxFieldDefinition(); is being returned instead. Wondering if it makes sense to also setStandaloneClassName inside the constructor since it's seems to be a "fixed" class.
Since the only two places that call this method already check if there is a duplicate key, you don't have check here again.
Similarly here, exec. should not be necessary.
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
i think you can replace browser.driver.findElement(By.id(id)) with inputBox?
connector belongs to Constants again
Since you already started improving the code, replace it with assertThrows() as well
Okay, but now the label provider is null. What then? We will get NPEs in the places where the getLabelProvider() is called.
Need to take a copy of the context to isolate it from changes to the global context that may come later. It should be, current style:  this.context = ARQ.getContext.copy() ;
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Are Operation objects immutable? Otherwise you'd have to copy them as well
I think the ServerTaskRegistry should not be obtained here, but it should be injected by the runner during construction. Also, a cache is optional paramater in the TaskContext and you should not rely on its presence here. Because of a current limitation in the DefaultExecutorService, it is not possible to have a distexec without a distributed cache, but @wburns is adding a new implementation which changes this.
please remove the new line
Why do you fetch the task again?
I presume you want to have all those line in .gitattributes? I think you need to do a single writeTrashFile with the four lines: writeTrashFile(".gitattributes", "[[]] bar\n" + "[\\[]] bar2\n" + ... );
won't need this
equals!
I can't remember, is there some protection to make sure names are unique
A little sanitization here would make a lot of sense, if nothing else make sure no ' ?
"expection" -> "exception"
Aren't we also prioritizing savepoint barriers here? Or are they guarded by using NO_ALIGNMENT_TIME_OUT on creation?
Remove NETWORK_STACK, since apps don't have it.
I don't know what to do about it right now, but I would be a lot more comfortable if the Model lifetime was connected to the PsiElement lifetime. In my ideal world, the models are just a veneer over the PSI. That's not to say it's the _right_ way to do it -- just a gut feeling. I worry that local caches in the model can become out of date as the PSI changes (the user types, and/or refactoring). Maybe my concern is unwarranted. Do your concerns match mine?
The bit is either set or not, so != 0 is a faster test here.
According to the current way how those methods are implemented, it should be return false
how about return unassigned.isEmpty() ?
There could be other cases where STDIN is referenced and an issue should be raised
I have the feeling that we should be careful and also check for interfaces and annotations (Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, as both of them are ClassTrees). It would however be pure defensive programming, because I can not manage to write a compiling example.
@inverno You can skip element.is(Kind.IDENTIFIER_REFERENCE) here as it will be done on line 67
This will throw redundancy warnings in IntelliJ
Nit - just return Arrays.asList("createSockets", "getInsecure") instead?
Can't this be further improved to just Arrays.asList(values)?
It is preferred to use the getResource method for tests instead of regular relative paths due to potential issues with the classpath.
will this method ensure that etc/conf/conf.yaml is absolute ? If etc/conf/conf.yaml is provided then etc/conf/conf.yaml is returned which is not absolute
is it commons-lang3 in classpath? Then you can use Validate.notNull(...)
Ternary ? true : false. ;)
1. Not sure if its ok to error on failure to get engine time stamp. 2. Failure to touch base with engine might essentially mean that the subsequent commands also fail and there's no use of asking for user intervention or things of that nature and somehow attempting to proceed with normal flow of snapshot creation. 3. Given 1 and 2 I still feel handling the failure manually in code is better atleast in order to close any other previous window(ex: snapshot create window) Let me know what you opine
Does this work for named JP-QL queries, too? As per its docs, createNamedQuery() can create both, native and JP-QL queries.
Again, use IOUtils.
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Duplicate getAbsoluteFile()
It shouldn't be an error. We have warn log tracking in many places now, so would pick up if this was frequent.
For ignored exceptions I prefer the variable name ignore (so we know it is by design).
Assuming batching is enabled, shouldn't it take the runningTX from the batchContainer even if there is a transaction defined ?
You can just do Slimefun.getLogger()
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
ah, I get it now, you were just preparing for this invocation...
Why are you putting the annotation on the same line as the method name. Normally all annotations are on their own line
remove public
Would be nice to circumvent the creation of the Text and go straight from String to byte[]. Same applies to the other Step interface methods.
please change Preconditions to static import.
This variable is very badly name if it's supposed to be the serializedUserReference.
this doesn't look like it needs to be public
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
have a default constructor with reasonable default values
package-private? Only used by AbstractJmxRegistration
should this be wrapped in some sort of a loop, which breaks when path == objectName? I'm thinking of the ../../somethingSomething case
This will NPE if no convertor was registered
you don't need this function, you can use constructor directly
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Can't this be further improved to just Arrays.asList(values)?
The image attribute is not supposed to be the text of the node. I'd rather keep it separate (the previous @Text attribute was fine). A practical reason for that is in the future, other languages may have a way to get the text of their node, in which case that wouldn't be fetched with getImage, for compatibility, but probably with a getText method, or getSourceCode like in #1728. Also we *may* deprecate or otherwise put getImage out of use as soon as 7.0, given its contract is super loose.
Is there a reason that the GapBuffer is initialized with a buffer size of 1 by default? I know this is a very vague question, but 1 seems like a weird choice to me. It reserves ram in anticipation of future insertions to save computation time, but still only allocates so little buffer space that the array size will have to be increased after one insertion. And if the first action is a deletion, this one additional character of buffer size won't make much of a difference. But I have no experience with gap buffers, so maybe I am missing something (or am overthinking this).
I think it's better to do the escaping at the point where the message is going to be converted to HTML. If not maybe rename this message to getTextAsHtml.
use same language as above "cannot be null". dont express the same thing in different ways to the user. be consistent
Does this line even compile? I don't see an end to this statement ...
This cast seems error-prone. If someone interacts with the Delivery interface directly and then this deprecated interface, then it will crash.
no need to check for null again...
:+1: this is a lot nicer than before
The last null is interpreted as a null Flag, not as a null Flag[], and is causing some NPEs in the test suite: <LINK_0>
This makes me very sad since it brings back bad memories of us trying to make super calls happy. How about we move the diff callback creation to the options builder and let devs overwrite it if needed?
should these all be this.variable instead of just variable?
I prefer the ?: syntax, also I think isLight is a leftover from the merge, because it is not needed suggestion mSwitch.setIcon(mLinear ? R.drawable.ic_apps_white_24dp : R.drawable.ic_list_white_24dp);
This is never returned.
constant or lineseparator from system?
We should use IdentifiedElementQuery.getLabel Do not forget: * @not-generated
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
Implement this
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
how can a clusterName be null?
Should this be above "isColorTeamMatch"? For example, on line #755.
Want to show values if they exist. Consider: String activityId = Strings.isValid(workPackage.getActivityId()) ? workPackage.getActivityId() : ""; String activityName = Strings.isValid(workPackage.getActivityName()) ? workPackage.getActivityName() : ""; result = String.format("%s - %s", activityId, activityName);
it sounds like an infinite loop, I don't understand why you throw a rejected exception
Maybe extract locating the Visualization.Factory into another method as it is used in getVisualizationInternal as well?
Could you at least make this return a non-null value?
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
WTF is lala
I wonder if it wouldn't be better if we *never* used null as key, and instead use the empty string. Then this 3 LOCs could be removed.
replace manual copy with collection copy Collections.addAll(mTagsList, tags);.
better to cast to string instead of using toString() .
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
better to cast to string instead of using toString()
return a new linkedhasmap here I would say
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
This method is only used in the scope of this class, so you don't need a public setter for it. You can use the private field directly.
should add some context in the exception message here
Unnecessary.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Maybe return an empty map instead?
Remove new line.
why declare and initialise with an empty string that immediately gets overwritten by the system property?
This means TestHiveClientInMemoryMetastore won't run the statistics tests. Do we implement this in a later commit?
Is this supposed to be true?
How come this is not a polling receiver? This polls messages from a queue right (ref:SQSTask.java)?
ClientLogger.logAndThrow all exceptions. Please search for all cases because soon Shawn will check in his CheckStyle rule and it will break the build.
ConnectException is not actually thrown by anything... it shouldn't be declared in the throws
are you sure this is the best way to handle this exception?
unnecessary
I wonder if we could simply go like this:  TableType type = table.getType() == null ? TableType.TABLE : table.getType(); return "DROP " + type + " " + tableLabel;  Oh, and I would maybe rename tableLabel to qualifiedTableName or something.
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
I also can't understand it, but now result is always empty. will try to debug it.
this does not handle the empty 'lists', it will throw an exception
No need to call the decoder if part is already of type 'type'
Did you think about using [appendQueryStringToURL](tests/blob/master/src/test/java/com/wikia/webdriver/common/core/url/UrlBuilder.java#L71) method for appending URL params to URL?
Is it required for the upgrade?
please add curly braces here
It isn't possible for ctx to ever be null here is it? Also checking whether ctx.patternInitializerList() is null should probably also be done before line 175 as well.
I think it would be enough to check if affectedKeys is not empty, either on the originator or on the owner. After all, the invalidation will be done only if there are requestors for a certain key, and that will only happen on the owners. But that still sounds a bit expensive, couldn't we use the same L1WriteSynchronizer approach as for non-tx caches and invalidate only from the primary owner instead?
Why are these static methods?
Hmm...while at first look this looks ok, I think we should 'harden' it a little bit to prevent cases of leaving compensation context uncleared in the DB. I'd suggest doing the following: boolean clearCompensation = true; try { endSuccessfully(); } catch (Exception e) { clearCompensation = false; } finally { if (clearCompensation) { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } } else { if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { compensate(); } } The code can be improved, but this is the direction to go to reduce leaving compensation trace in case of a failure during the end action.
It appears that we can incorporate this logic better into CommandBase.endActionInTransactionScope() The finally block of that method is: if (TransactionSupport.current() == null) { try { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } catch (RuntimeException e) { logExceptionAndCompensate(e); } } else { try { if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) { getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand(); } else { compensate(); } } catch (SystemException e) { logExceptionAndCompensate(e); } }
should be setSucceeded(true)
This should return a builder with the current options set.
When subclassing the builder one might want to subclass the builder as well. Let's make it protected?
requireNonNull(arrayBlock? Or checkState?
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
check notNull?
Please don't change API visibility. Thanks!
You added this to the ctor's signature, but forgot to save it in a data member.
You actually don't need a whole Project Object becaus you only work with lists of project, please change the functionality to only work with lists, by now
I don't understand why both the parameters here are fieldName and both the parameters in getCombiningFactory are name - I see this pattern used in all the aggregators
suggestion list.setSourceList(new ArrayList<>());
Same here when trying to save the context without specifying the script (or when trying to import the context).
instead of setEngineSessionId - why not having it at ctor?
don't you want to check if session id is null here as well?
why not factor out this code ? It's repeated in quite a few places.
Should be outside the if
This is not a robust test. The number 24 will change as soon as we change the vocabulary.
Style issue: @Override shuld be on line above the method declaration
@garg-anuj Yeah doing that only.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
LOG_WARN should be the first argument
You probably want to pass the exception as the second argument to the logger. If it is in the message all you get is the result of ex.message() but if it is the second argument you get the message and the full stack. Often the message is almost worse than useless and for some exception types it is null
I would ignore empty notifications and would log warning.
This is kept for backward compatibility, we need this when users upgrade from 0.6.2 to newer versions
minor: can replace lines 89-94 with java return storeKeyToMockStoreMap.computeIfAbsent(storeRootPath, path -> new MockHelixPropertyStore<>);
fyi, the reason that we have a couple of fields like "version", "latency" here is just to give an example of how to migrate system properties to Helix manager property. A "TODO" should have been added here for completeness in future work.
Hm. This would prevent the player from disabling flight if they aren't allowed to fly in the first place. This packet could also contain other information than just flight status, so returning here would break that. I think the logic should look something like this: 1. If the flying flag is the same as the current flight status, don't do anything. 2. If the flying flag is different, and i. The flying flag is set to *true*, and the player is allowed to fly, then fire the event ii. The flying flag is set to *false*, fire the event 3. Check if the event is cancelled. If i. the event is cancelled, send the abilities to the player and return (sync) ii. the event is not cancelled, call the setFlying method
@erdemedeiros let's remove all the system outs
Cool, didn't know about DeadEvent. When you switch to slf4j, make sure to use playerholders {} instead of string concatenation and follow the [logging format guidelines](<LINK_0>
this method should be refactored to use the new attach(ServoListener) .. rather here is is calling addListener in this method.
should be refactored to call detach. also isEventsEnabled should go away.
why does this servo listen to itself when it starts up?
you can use your find method here also
this whole method could be a oneLiner: return find(...) != null
Consider @Restricted(NoExternalUse.class), I see no reason to make this public API.
I think this can return null if there is no timeout. From what I see, a null SocketConfig is supported and what occurs normally (if you have no customizations).
No need for the double (( and ))
synchronized is harmless but superfluous here
Does this really work? That validate method i think expects non hashed passwords, probably you shouldn't validate this, the ticket says changePassword methods. I also think these should delegate to the changePassword method that validates the password to centralize the code
do not assing parameter! nowhere!
Why would the old password be null in the first place, this seems like an invented scenario
can we change a return type to int ?
assertNull? And the withTx... though I know you've just moved this code from another test.
else if?
Either hasNumberOfValues ? numberOfValues : 0 or add verify(hasNumberOfValues)
Unnecessary boxing?
maybe we could query this somehow from JobManagerMetricGroup but I am also wondering whether the JobManagerMetricGroup registration/query code belongs to scheduler and not to a separate e.g. SchedulingMetrics or so component.
Using == for object comparison? :)
Why are you changing to patient 7 here too?
Can you also check the error message to make sure it matches the expected one? Otherwise this could be failing for another reason
Seems for me this would be enough:  java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return (String) template.findOne(query, Map.class, collectionName).get("value");
The same is here for that include("value") and Map result
You have missed oldValue in the criteria. See the replace contract in the ConcurrentMap.replace
should it be escaped, just in case if header values contain comma?
You could change doTransform to default to "true" and remove "setting it to true" and from the "if test". Only set it to "false" when the no_xslt_flag is in the header.
ApiAuthenticationResult casting redundant
You are opening a stream but closing it inside a other method. Is this a good way? Would it not be proper way to open and close a stream inside the same method?
If we keep this approach, encoding should be a module option
is it possible that we don't pass enough arguments to this array?
s/any(List.class)/anyList()
As Allon stated: physicalVolumeIdsOnStorage is a List<LUNs> while what the etPhysicalVolumesFromLunsList is a List<String> thus this condition will never be true and the operation will never be blocked
This should be: if (!getStorageDomain().getStorageType.isBlock()) You are duplicating the logic in StorageDomainType.
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
github is unnecessary variable
I'd use equalTo() here
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
please remove else, code will be more readable
You could put a cast to Iterable<Integer> here to make it explicit.
this used to bail after this call if it wasn't the root, does returning v. not returning from onCreate() in that case affect anything?
If you set wasExternal here then remove it from processFromExternalLaunch
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
We can't use the concrete HashMap.of here because it is an abstract Map test, the base for _all_ Map implementations. Please use the methods empty, of and ofAll which are implemented by all AbstractMapTest implementations.
If we're demonstrating to the user how to do something with our async client, it feels unnatural to suggest that the best approach is to block. Thoughts?
It looks like HashBiMap#inverse creates a new object in a not thread safe manner, but the object is pretty light weight. Due to the nature of lookups this might cause a thundering of racy objects, which should be benign since the map is immutable, but annoying. Would it make sense to create the inverse map as a Map<String, String> eagerly, and null the object if not one-to-one, then in the unapply simply check for the eager inverse map being non null and do a Collections.singletonList on the result, if it exists?
Mock this also.
How can you be sure this is the remove Service and not a local service that you have been injected with ? The test return the same value for both service so I think something is missing to check that it is actually a remove service.
this.expiredObjectColumnName = getKeyColumnName(configurationService); Then we calculate it one time during SqlPersistenceServiceImpl creation and then re-use in all other places.
Is the super class implementation not working?
Somewhat inefficient here.. is it getting used at all? You could get the bounds of the original collection, turn into a polygon, intersect with the clip, and return the bounds of the resulting geometry.
does description need to be part of equals?
I prefer to keep the static import.
It seems that we don't need line 50 and 51. If we can verify the pool size, it be nice.
Why this move? If closeStatements() throws a RuntimeException, or some subclass of it, the finally will not be executed, resulting in the connection not being released back to the pool.
unmodifiableList(...) is unnecessary.
Whoa, this looks wrong. The query doesn't have a native query and it returns an empty result set. I think that probably, this query should return an error, because it represents a kind of query structure Druid can't do right now (aggregation on top of a non-aggregating subquery).
It's sad we had multiple params per line before. Let's fix it by having one param per line.
The method can be static, and the "standard" implementation is: return PlatformUI.getWorkbench().getDisplay().getCurrent() != null;
Magic number. Also I don't think I understand how this method is supposed to work. You may need to explain in person and that is cool.
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
oo fancy!
In their naming, these are the "Account Id" and "Application Key"
capitalize and change by a text describing what the identity is?
I'd suggest simplifying this block to (and for the similar cases below):  return super.getConfiguration(igniteInstanceName) .setIncludeEventTypes(EventType.EVTS_ALL);
Let's refactor this to cfg.setClientMode(igniteInstanceName.startsWith("client"));
let's make atomicityMode() method that return TRANSACTIONAL to make life easier for the one who wants to extend this test.
Math.max
The getExpirationTime getter is missing, isn't it?
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
This doesn't seem right to me. What if this view is in a context where its parent doesn't have MarginLayoutParams? It is still highlightable, no, just perhaps not with this new margin highlighting?
Yeah, you would need to do something like that since the text color will be white now always, what will change is the background.
mutate is needed only once
Probably we should check here for the class loader of the exception class, if it's the class loader hosting the test cases it should be GuardianException, otherwise we should transfer the exception using com.hazelcast.test.starter.Utils#transferThrowable.
use borrow method bellow?
Replace with specific exception types.
use getGuid(rs, "disk_id")
please verify that the amend function is actually executed
please verify that the amend function is actually executed
null check
It would be nice to have an option for disk caches. Just using the builder with different option <LINK_0> It would require a new flag coming form configuration
I think by keying the cache by a Credentials object, that we'll end up with a cache miss on each new request, since each object will be specific to a particular request (since it has a timestamp, signature, etc.). I wonder if we should instead key it by the apiKey that is in the credentials?
plase fatcor out that hardocded path segment
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
We don't currently expose any configuration via environment variables, so I'd prefer to do this in a separate commit (and potentially do it for all of robolectric's configuration).
X and Y are primitives, so should the %s be %d here?
Should have a period on the end of the string for consistency.
I don't know, but isn't the class also of interest?
final
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
No need to log here.
Remove else statement here. It's unnecessarily
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
What if fileName doesn't have any .?
UnsupportedOperationException seems reasonable here.
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
suggestion return new CheckConstraint<>(name, mapper.apply(expression), expressionStr);
suggestion return new CheckColumnConstraint<>(name, columnName, mapper.apply(expression), expressionStr);  Please take care of generic warnings. Don't ignore them
same ...
actually, MessageContent could have this as a static method.
Use constants without using magic numbers
Please, consider to use only AssertJ assertThat().
You can replace the qualified name with import
Need to check for more than WHITE_SPACE here, too.
Shouldn't the aggregation node also have symbols for group id, hash, and an aggregation mask?
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
The logic here could be structured like this:  java if (driver == null) { // chromedriver process killed } // driver != null from here on else if (driver.getCurrentUrl() == null /* extra null check */ || driver.getCurrentUrl().isEmpty()) { // unable to read url from browser }  Also, is it possible that getCurrentUrl() may throw WebDriverException? I looked at the docs and there was no mention of it, but then WebDriverException is unchecked, so...
let's add: LOGGER.debug(e)
With the new out-factored structure, hopefully we can get rid of the "backreference" to the workbench here.
This is more like isNotBlockAlready
We still need to call to deactivateParticipants()
Remove?
Remove else clause.
> NoSuchElementException
if you use a second client instance and do this remote operation, the test can be easily duplicated by non-java clients as well.
How about using snaeService.wait(500); instead and calling notify(); in the event handler?
Add ignore casing.
I think lowercase l should also be considered
Seems for me this would be enough:  java Query query = Query.query(Criteria.where("_id").is(key)); query.fields().include("value"); return (String) template.findOne(query, Map.class, collectionName).get("value");
better to cast to string instead of using toString()
don't need getName() just this.oldSelectedVersion.notEquals(newSelectedVersion)
Move the add into AtsChangeSet so 201 and 205 are un-necessary.
I'm curious why this change was made. The repositoryStatistics should be thread safe, so the lock should only be needed to update changesReceivedAndDispatched.
Every time we change a JSON test using JSONPath a cute kitten is born.
Ditto formatting.
Ok, but in the future, you might consider constructing these w/ JSONObject or GSON.
Isn't this constant and shared across all producers? Then can't it be static?
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
Can we get rid of the inline Json please?
Use faster methods, should not use data processors when possible.
Could you at least make this return a non-null value?
This can be "package-private", i.e. no access modifier.
We may not need this method and can use gatewayResponse.getError().map(s -> s.getMessage()) instead in CardCaptureMessageProcess
Are result and errorMessage not applicable for workflows?
shall we add some message here?
nice meter
nit: uneeded line
is this going to result in a null reference exception? I think you can mock something for this.
selectedElement for better readability
java if (next == null) { return fromIterator.next(); } else { final TYPE result = next; next = null; return result; }  I find this better to read.
dyno_scan(int, String) calls dyno_scan(null, int, string) so should be ok to drop the if statement and always call result = client.dyno_scan(result, count, pattern);
assert name != null;
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Modifier 'private' is redundant for Enum constructor - needs to be removed.
No need to call stream() here.
clear aliases is wrong in case of nested namespace using curly braces. Exiting from a child namespace context should restore the parent namespace context from a stack. Let's discuss about the following code: php namespace N1 { use A as B; namespace N2 { use C as D; new D(); } new B(); } // fullyQualifiedNames: C, A  And the following code: php namespace N1 { new A(); namespace N2 { new B(); } new C(); } // fullyQualifiedNames: N1\A, N1\N2\B, N1\C
uncessary call to super. No need to visit further.
I noticed only now this fact: don't we have a rule to forbid the usage of "Assert.xxxx" and force the usage of import static "org.junit.Assert.fail" ?
This one can also be final.
typo: continuously
You can use getFieldValue(Long.class, getLayout().fieldLen()) here and then null check to be safer.
switch/case (saves one check at most) also, why is incrementValue() in the method above? Why aren't they all handled in one place, would be clearer? There is a ss.incrementAttribute() now.
cab we invert this? it feels like a gratuitous negation
is this needed for the test?
since this persist is triggered by the maxRows config, would it make sense to persist the one having the maxSize ? as the oldest one may have very small number of rows.
This check needs to be done in hasMore(), not nextRow(). hasMore() can block, nextRow technically cannot and just because there is another from hasMore() doesn't mean that it will be within the minTime.
seems worth throwing an exception if the file isn't found, no?
Don't branch on the exception message, let WindowsFileOperations.readSymlinkOrJunction throw the right exception instead.
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
Style fix suggestion public long getIgnoredPlayerTimeout(UUID uuid) {
What's the intent behind this? Generally we want to allow this to be changed at any point. Is there something in particular that requires this with the update?
Maybe we should compare contents of JSON objects instead of their String serialized form because such a comparison is sensitive to field ordering and white symbols... Any modern object mapper should be able to do that. With that being said there is a library dedicated just for this: <LINK_0>
Why have you updated this test instead of writing new one?
suggestion }
Could be just package accessible, just for tests.
No key for encryption? ;-)
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
are spaces OK in namespace strings?
as above: are spaces OK in namespace strings?
suggestion return Optional.of("org.junit.platform");
You don't really need a null check here, using "auto".equals(objectValue) is enough, if true return objectValue.toString(), otherwise continue on to normRangeValue. This can be important in case we decide to handle null values differently, and then we won't have to fix it in both places.
This will produce a sequence of 1, 2, 3   Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 1, 2, 3   Looks like a bug. Why not just keep the old implementation?
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Remove the if check and simply return getFirstElement
you can use IStructuredViewer::getStructuredSelection
style-nit: remove curly brackets around single line block
I think the granularity should be 1 seconds instead of 5 seconds here.
@bhaisaab as the _completedTestCount_ is incremented at the _oneMoreTestDone()_ method, I think that this log could be moved to "_com.cloud.utils.testcase.NioTest.oneMoreTestDone()_"; this would remove the need of _Thread.sleep(1000)_ and let the log clean.
We should use RemoteServiceInterface.FAILURE here as well. Also, we should create a contstant for 100 as well and use int respective tests.
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
I'd prefer we not import the icu.util.Timezone and make java.util.TimeZone the default in this file as it's returning this thing. The icu.util.Timezone is an internal impl detail. Alternatively replace all uses of TimeZone with the new icu version throughout the system (if we really want to replace it). Mixing the two seems bad
shouldnt this be a little against design of unit-test to assert one or another?
You need to check that conceptUuid is not null and blank
How to do ensure that by requesting .getConceptNameTagByName(null) for should return null if No concept nameTag is found?
Alternatively, i think it should be okay for one to pass in a null locale and then in ConceptSaveHandler you set it to what is returned to Context.getLocale(), we could also add a constructor that only takes a actual description and the locale would still get set by the save handler
Either set type here or on initialization
Prefer not to have a null environment from start.
you don't need to do that if you're already calling loadProperties in the public constructor, right? <LINK_0>
Maybe the number of 5 should be a setting?
do not assing parameter! nowhere!
unneeded else
Please use English.
This method and the previous one are very similar, the common code could be extracted to a private method: time, API version, queryOptions
Exposing the server stack traces to the client might be a security issue. Better to hide that information.
I think the setter would be a more appropriate place for this defensive logic.
HI, Is this being used by frontend? If so, shouldn't it be a concrete class, and not List? (See many other place in code), as GWT has issues with dynamic types/inheritance?
If you are just checking for equality to null, you can avoid implementing the equals method and replace  processingDetails.equals(null)  with  processingDetals == null  Note that not implementing the equals method is only if you don't need the equals method for other checks of equality.
We have a feature called "rolling upgrade" which means that at a certain point, a cluster may consist of members of different minor versions, one minor version apart. In another words, this operation and all other objects that are serialised and deserialised may be sent and received by members of different versions. In the case when this object was sent by a 4.0 member and received by a 4.1 member, this may cause an exception. This is why we have to introduce additional safeguards. It starts by adding the Versioned interface to this class. After that, you can add checks in the writeInternal and readInternal methods, like: java @Override protected void writeInternal(ObjectDataOutput out) throws IOException { super.writeInternal(out); out.writeObject(mapEntries); if (out.getVersion().isGreaterOrEqual(Versions.V4_1)) { out.writeBoolean(triggerMapLoader); } } @Override protected void readInternal(ObjectDataInput in) throws IOException { super.readInternal(in); mapEntries = in.readObject(); if (in.getVersion().isGreaterOrEqual(Versions.V4_1)) { triggerMapLoader = in.readBoolean(); } else { // old behaviour triggerMapLoader = true; } }  Same goes for PutAllPartitionAwareOperationFactory .
How stable is the ordinal? We usually assign byte IDs to each enum so it's more stable (see WanPublisherState#getId and WanPublisherState#getByType).
Looks like index type is not persisted and not taken into account in hashCode/equals, so basically all deserialized index configs are of SORTED type.
Can't we tell spring which bean to use?
Can it be anything else than an int ?
I don't believe you ;)
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
null =
Float.max() is since 1.8 so it won't work on Android and GWT. Use Math.max() instead.
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
synchronized is not needed we're using a concurrent collection
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
explain a bit more in the message please
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
Extract notification to own method notify...
Should it be logged at the error level?
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
I am not following here - why do we want this in sync block?
Remove final.
We use small d doubles for simple calculations.
I'd inline result variable: DOUBLE.writeDouble(out, strategy == null ? Double.NaN : strategy.calculateEntropy());
explicit real ref?
With #487 this assumption may not be true anymore.
The above cast should be done after the if (entry == null) check to avoid a potential ClassCastException. My mistake.
suggestion if (rowIdx >= rows.size() && requested > 0)
same thing here. double callback call.
same. Could be called back 2x
As requested in another pull request, please have a utility method for building a CommandRequest by command and context. There should be such a method already.
Please test it using spy() or mock(). Sleeping threads does not scale well for testing.
I would make this protected and mark as @OverridingMethodsMustInvokeSuper. The reason is that in the test cases there may be more actions before the Bounded Context is created, such as setting up the mocks.
Can use Objects.requireNonNull instead.
nit: either use this. for both assignments here, or for neither of them. Consistency is good :)
suggestion BloomFilter bloomFilter2 = new BlockSplitBloomFilter(BlockSplitBloomFilter, MAXIMUM_BLOOM_FILTER_BYTES + 1);
This equals implementation should include attributes from the Command super class.
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
This equals implementation should include attributes from the PingCommand super class.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
Implementing this as a loop suggests that you intend to support multiple dots, which is not what we discussed. What's your thinking here?
Still this can be a static message as all messages are defined in the beginning of this file
No need to call super() since it currently doesn't extend anything.
Couldn't you just to do: setXyz(0)? Like many other config classes? Also if you just want to initialize the value to 0, wouldn't you simply default the field value to 0 instead?
I mean, this constructor is used only in Type. Its modifier doesn't have to be public, and it will also reduce contributors' mistakes.
We should not generate the watermark if the source uses PunctuatedWatermarkGenerator.
SourceImpl?
You're invoking generateEvent twice (101, 102)
May as well reduce the visibility of the method if it's only exposed for testing.
This should be synchronized.
The ImmutableGameModeData class isn't supposed to be used here, it's supposed to be the Sponge equivalent implementation, in this case ImmutableSpongGameModeData.class.
This doesn't need to be "re", as it's just evaluating stuff once, not twice.
Maybe we can move the null check on mGoogleApiClient a level above so to protect also the access to stopAutoManage. wdyt?
Why do we register onDestroy?
it would be great to preserve the boolean flag that toggled between new GooglePromptReceiver() and new LocalServerReceiver() somewhere - the java-client needs that one
I suggest removing the try-catch from this method and create another test case to verify that getting a non-existent code system will throw a NotFoundException. The other test cases seem to always expect the codesystem to be not null. This case you will get a nice NotFoundException exception with a nice message instead of NPEs.
should be logged.
add call to validateParameters() method and list the mandatory parameters.
HostMapper? Isn't this if branch for StorageDomain? Maybe that map method should be moved to a new "ExternalStatusMapper" class?
consider extracting the code which creates the parameters object to a method, so that add() method stays short and readable.
Should all the VoltDBL* relations assert the presence of the VoltDBLRel.VOLTDB_LOGICAL in the input trait set like VoltDBCalc does?
Should we be consistent with the assert assert VoltDBLRel.VOLTDB_LOGICAL.equals(getConvention()); vs assert traitSet.contains(VoltDBLRel.VOLTDB_LOGICAL);
Always use create instead of new directly.
I think the underlying registry/restClient will return SchemaRegistryClientException instead of SchemaNotFoundException in this case.
This method returns null for unknown schemes, why an exception is required for a null name?
Is this call expensive? Does it involve remote RPC? this schemaRegistryClient.getSchema() was happening multiple times in this routine.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The string needs to be made translatable in a messages.properties file
can we define a constant with a semantic to describe what "30" means, e.g. DEFAULT_WMS_RESPONSE_TIMEOUT_IN_SECONDS: public static final int DEFAULT_WMS_RESPONSE_TIMEOUT_IN_SECONDS = 30; In addition, is it possible to Start uDig with another default (overwrite in configuration) and how? @nprigour Could you add a screenshout to docs and improve WMS Preferences page (content of <LINK_1> or [Catalog Preferences](<LINK_0>
These strings need //$NON-NLS-1$ annotations.
This local variable appears to be shadowing the field variable
This is called in the init method. Why is it needed again here?
better to remove if if statement, just set the value, the user of the entity can than use the getUseFreemarkerTemplate function to choose to use the template of not.
null? why not just a () -> {} ?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
Use CommonImages.getImage instead of createImage so that we don't have a memory leak.
Can just return true if it's incoming and fall through to returning false.
I don't think isBootstrapped should be a flag. The 'bootstrap' method is a misnomer, it should be called 'refresh' or something. It's meant to be called multiple times, once before each use, to get the latest stream state.
Just a thought is the contract for running that its fully started? As Camel has a state called .. starting which is the phase it do when it startup. But I assume running is after all the startup stuff and its really running.
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
<3 Better, but formatting :)
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Ideally this would be the previous value of context, if i just toggled the button on and off.
negative logic
negative logic
Is it needed here? Doesn't line 764 do it?
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
This doesn't need any kind of null check if they don't use Paper?
Cloning after calling getEyeLocation is unnecessary
Why not use null instead of ""?
this doesn't look like it needs to be public
ImmutableList.copyOf() creates an independant copy, whereas Collections.unmodifiableCollection() returns a wrapper on a collection which itself may be modified later.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
move the mull check under the null check for thread to ensure we not change behaviour.
Is threads.isEmpty() necessary ? I think the foreach loop can handle the same case.
To always be safe please use context.getApplicationContext()
Use context.getApplicationContext() to ensure the class can't leak any shorter lived contexts that might be passed to it (it's always fine to hold onto the application context, since it's expected to be around for as long as the process remains alive).
this could be a static method because it doesn't rely on any state from its parent class.
Should be outside the if
Why can't the action be stop?
The trailing curly brace is missing here. && action != Action.REJECT && action != Action.RETURN) {
Good idea. Will do.
Maybe add @Nullable to taskExecutorManager.
Could use buildAndStartWithDirectExec#buildAndStartWithDirectExec instead.
There are different ServiceId objects with the same serviceId field? e.g. that contain different aliases?
suggestion var service = getCandidateServicesToMatch(serviceId)
What I was thinking of is that we had ServiceInstance<ZookeeperInstance> and now we have ServiceInstance<Object> I'm curious why did we go from ZookeeperInstance to Object?
This collection type is not thread-safe. Without synchronization such logic will likely fail at some point
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
Why don't we make inDegrees to ConcurrentHashMap also?
no need for concurrent
suggestion this.dataStoreMap = new IdentityHashMap<>();
app = getApplication(appNameOrId) if (app == null) { app = getApplicationByName(appNameOrId) } To avoid calling getApplication and getApplicationByName twice.
Is this required (here and in onFailure)? Seems like the reference will go away when the listener reference is removed from the set.
log entire exception object, than just message. you can use {} with e. logger will log message as well as stacktrace.
So simple! I like it!
Since I started the dogfood task, I know, that this EmptyCatchBlock will be flagged. If you are sure, that the exception can be ignored, then use ignored or expected as the exception variable name.
this seems like a leftover from debugging, please remove it
You've overridden this method but dropped the @Nullable annotation.
Seems this is optional and later on you do a != null so this might be better returning Optional<String>
rename to type
getFirstName() considers empty getNames(), getConcatenatedName() doesn't.
similar to other place can we check that the lists have the same size?
specify array length (based on codecs.size) to optimize. <LINK_0>
Minor: can we check if the number contains the decimal point instead?
Possibly compiled away, but + 'f' ought to be more efficient in principle.
Do we want to add Enum handling here as well?
Likewise..
Likewise..
So this would leave the View in an inconsistent state with the Presenter? Should you not show an error in the View that the value was wrong? Or default to a valid value and update the View? etc
Wonder if it would be more informative / useful during debug to add "ForwardingOs{os=" + os.toString() + "}" rather than delegating straight through.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
So this would return the class name + the hashcode of the array? Perhaps it is more useful to return the md5? What's the use case for this?
can you add mountPath here
Instead of sleep, what about replacing with CountDownLatch? We can unblock through the code rather than depending on the timing schedule.
Although we need to figure out how to propagate interruptions, this will now cause a problem as it this method is called from within tryUpdate which is recursive and propagating here means the next attempts will also fail for the same reasons. We need to figure out how to retain the fact that we were interrupted and propagate the interruptions outside the whole thing.
If you"ll use generics you won't need this cast.
Let's please avoid code duplication:  public String toString(boolean shortenTypes) { String type = getType(); if (shortenTypes) { type = shorten(type); } return getName() + ": " + type + " = " + getValue(); } @Override public String toString() { return toString(false); }
Double assignment to scroll is bad style, and the toString is implicit when concatenating to a String. Just use: IDontKnowTheType requestScroll = request.scroll(); String scroll = requestScroll == null ? null : "&scroll=" + requestScroll;
It looks like that this catch block is in a dead code path. Because startLogReplicationRuntime will catch all exceptions and input an event to FSM. Remove elements in an iteration over values also dangerous. > If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined.
Is isOnline a time-consuming method? It seems like we should change this to check every 10ms rather than spin-lock.
very minor but I think using _sourceClusterName is clearer. and maybe "updatedDarkConfigMap" or "latest..."?
Don't you need a super.setUp() call here?
I think it is an overhead. I believe you that you have had a good testing around there. Although I'll recheck test tasks with IO during merge.
AnnotationConfigApplicationContext is Closeable, so should be close()'d in the end, independently of test result. At least STS barks here :smile:
Why was this removed?
It is not unheard of for a connection to db server to fail. Should it attempt retry rather than failing?
what about setting db isolation level to serialization?
Replace by Objects.requireNotNull()
Can this ever fail? It seems to only log something in case of problems. We should verify that it actually does something that we expect.
don't think we can require this as per your earlier email saying that initial uri lists may be empty
add the Throwable t as the cause of this exception
as is in 718
Why do we have a 5 minute timeout? We should pull this out as a constant.
To follow the conventions of Spring Security, please change to "webClient cannot be null".
don't forget to shutdown your executors
No magic number, please. Can we just define a DEFAULT_PARALLEL_COUNT = 10?
canConnect( server.address(), clientGroup ) can be extracted to a no-params method
can't be null?
There's no way to use constants for those ugly hex values, is there?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
We shouldn't use this error type, this is expected to be thrown by the JVM >Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory
@mkambol I don't think checking the newCapacity against the limit is the right thing to do. Let's assume the limit is set to 1M. Suppose you have a list of 700K tuples and you need to just add 10 more tuples to this list. Lets also suppose that the array's capacity was exactly 700K and now we need to increase it by 1.5x to accommodate the additional 10. However, as soon as we increase the capacity of the array to 700K+350K=1.05M, this will hit the 1M limit and error out. As a user, I know my query should have only returned 700,010 tuples which is well under the 1M limit. I think the right fix would be to cap the newCapacity at the limit and only error out if the array was filled beyond this limit.
Instead of using the context class loader, use the class loader of the first aggregate factory provided.
Use target's class loader instead.
Actually, I would expect the default to use the class loader of the object being inspected. One can expect that all classes used by that class, must also be resolvable by that class' class loader. Note that the context class loader may be null. Also, instead of using a constructor, consider using a static factory method. That makes it possible to add caching (similar to what ParameterResolver is doing).
This is not an issue specific to this patch. But I think the class hierarchy needs some adjustment. Currently: PipelinePlacementPolicy<-SCMCommonPolicy<-ContainerPlacementPolicy Should we change to have the SCMCommonPolicy as the base for both PipelinePlacementPolicy and ContainerPlacementPolicy, if there are common pieces between PipelinePlaceMent and ContainerPlacement, we can move them to them to SCMCommonPolicy.
Separate change, so should not be in this patch.
Can we throw an exception instead?
Why do we need it here?
You should call super.visitReturnStatement(returnStatement) before leaving the method, or you won't catch cases such as :  Optional<String> s = getValue(); return (s != null) ? optional.isEmpty() : s; // Noncompliant, the null check on s is wrong!
Message should be more expressive, e.g: Dynamic filter cannot contain two DeferredSymbolReferences.
add () to group && conditions for clarity
extract actual.getModifiers() to a local variable.
same thing, extract method to check suffix
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
use this.size()
use isEmpty() instead of size() == 0
Please create a single instance as a constant and reuse it
use simple thenApply(...) instead.
I changed this on purpose to make it simpler: completedValue should never be null.
Assert values
This is not used
unnecessary line break
Please create a separate subclass for test mode if it is really needed.
This check should better be done by the constructor of CountBitsArray. Moreover, you need to have a blocksize of at least 64 for the same reason as in the case of FindPositionArray.
I think, the correction with maxPaddingSize/2 is not required here.
Looks like everything in the append(...) can fit one line.
Use map.forEach
Seems like this condition is "No table manager found"? Should this log be on a null check for tableManager.getTable?
Should use the log, maybe a warning.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
should be logged.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
This test would be useless if the map had been initialized in the class.
wouldn't it be more flexible to allow to set the authenticated flag instead of always returning true in the MockEndpoint?
I'm unsure if singleton is the best option here as the asterisk connection is created and managed by the endpoint so if you declare it as singleton you may have conflicts if different producer/consumers do a login/logout/addListener
I'd say if the entry is present, the command is not successful.
Instead, start with bot.checkBox("SWT.READ_ONLY").select();
Checking whether text is null seems properly defensive. If text is not null, I believe that text.getData() is guaranteed not to be null, so that part of the check is unnecessary.
I believe the Sanitizer call is not needed here.
DateTimes will not always work... because of daylight savings time: <LINK_0> doing a toLocaleDate should solve this issue.
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
Why depend on all DiscoveryServices and not require extended services to register specifically under that interface? Ok, this might be breaking, but as ExtendedDiscoveryService does not even extend DiscoveryService, this simply feels wrong here.
Hm, is it allowed that the extended discovery services still use the callback if this component has been deactivated (e.g. because a mandatory reference gets lost)? Shouldn't you unset the callback?
Why doesn't the background discovery do an initial scan anymore?
Same here, you need to check that retireable fields are not null and null after
You need to check that other retireable related fields at are not null and that they were null before i.e dateRetired, retiredBy, retireReason
same here, don't set fields, just call save here
nit: should the last 3 lines be a separate test?
You are only locking and unlocking a single lock, I assume from the name you actually wanted to use multiple. Otherwise, this is a strict subset of the test above.
Is this first line needed?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
This will cause the eventLoopGroup to leak. We need to be sure that ownChanelFactory (or ownEventLoopGroup) is set to true when we are the ones that create the eventLoopGroup.
Shoudn't this be unregister? and as a nit I would expect that we would want to unregister first and then shutdown afterwards.
Why not "return argList.toArray(new String[argList.size()]);" so the String array with the appropriate length is preallocated?
not needed
nit: wondering if we should use the same IllegalArgumentException if property is missing as with getString. Seems like we always encode a default.. I am not terribly sure which is a better model, but this will keep it closer to existing behavior at the least.
We should move the naming of the threads to common configuration as well. It is just easier from debugging point of view and production support can easily make sense as well.
![Codacy](<LINK_0> Issue found: [Use explicit scoping instead of the default package private level](<LINK_1>
Might be a perf issue, not sure thought.
Not sure why this needs to be a shared/pluggable CoordinatorService. Looks like this is just some utils for working with ZK?
Maybe missing {}? Regardless of that let's add space between exists and udf.
returnTypeName should be capitalized: StringUtil.capitalize(returnTypeName )
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
Use if here instead. We don't nest LazyBlocks
Similar question here, though as it's not a string it may be different.
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
Better, but use logger.logAndThrow(new ...)
Same here. Add e as an argument to the IllegalArgumentException constructor.
Could you add some log message here? It is not good practice to ignore exception
If it can return null - the method should be declared as @Nullable, and it should be properly handled in the places where it is called. The other possibility here will be to use orElseThrow(...) instead.
If it can return null - the method should be declared as @Nullable, and it should be properly handled in the places where it is called. The other possibility here will be to use orElseThrow(...) instead.
This is not necessary, the client is already created in the parent
I think that you should do the backup first, and only then start the server.
I think new File("target/jboss-as") will work exactly the same.
Better to add checkNotNull for the arguments.
Can you get just the crn from the database?
This isn't right. It shouldn't return a lock if acquire returns false.
The reason for the NPE in doStopJobExecution(org.springframework.xd.shell.command.JobCommandTests) comes from here:  final String startTimeAsString = this.configuration.getLocalTime(jobExecutionInfoResource.getJobExecution().getStartTime());  The JobExecution startTime can be null.
The method RassStringToJavaShortDateTimeAdapter.parseToDateTime() is already returning a DateTime, so extracting its Date value and re-wrapping it in a new DateTime seems redundant.
Can use your new method TimeHelper#parseLocalDateTime?
I think you need to assert that the return value is 0.
assert more than this, like that it's not null?
Understood. IntelliJ does however suggest this small change: return new HashSet<Location>( asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE));
replace the if with checkIndex(toIndex)
I would retain the existing indexOf body to to avoid indirection in the most common case.
In the #valueOf(int,int) method, we could simplify the resulting bytecode slightly by eliminating i and using fromIndex as the index variable within the loop. As in: java for (; fromIndex < count; fromIndex++) { ...
Do not close the buffer (see #5400)
This is unnecessary
This method should throw an exception, not return a ByteBufferSharing with a null buffer.
that can be null? This means all the locks above can throw NPE? Also accessing this object here without synchronized lock? I don't get what is the strategy is here. Again: object that can be set to null CAN'T BE USED FOR SYNCHRONIZATION. Please either make sure they are never null or use different objects for synchronization.
shouldn't that be return retriesOnFailure.decrementAndGet() >= 0;? It returns the updated value, so retriesOnFailure = 1 would lead to no retries
You can drop this boolean and use !prefixes.isEmpty(). If we have prefixes, we need to look deeper than the root.
should this count be parameterized?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Pull this into a static final variable
Maybe we should start using java.rmi.server.UID instead.
Can restore Path installDir = Files.createDirectory(tempDir.resolve("install")); too, e.g.: Java Path installDir = Files.createDirectory(tempDir.resolve("install")); Path xmlDir = Files.createDirectory(installDir.resolve("xml")); Files.createFile(xmlDir.resolve("log4j.properties")); zapInstallDir = installDir.toAbsolutePath().toString();
Can we append cause so admins has a chance to identify the cause and fix?
check NPE and make SITE as a Constant
Never use getBytes() without setting the default locale. Please always pass <LINK_0> object into that function. Actually we have to check that we do not use cases where this stupid getByte() is done.
I think we are mising a test here, when contentlet.isDotAsset() is true
this line doesn't do anything
The icon that is set is the same as the archive menu entry found above. This is only relevant to Android 2 devices, but it is worth choosing something other than ic_menu_upload. Maybe stat_notify_chat ![image](<LINK_0> or something else from <LINK_1>
Variable not used; please, remove this line.
Noticed txnIds is passed like List->Iter->NewList->Iter->NewList to several methods. This model have several copies. Instead, can we pass the same list (txnIds) all the way down to build openTxnMessage?
The outside check is for listeners but passed transactionalListeners. Need to check for both and need to notify both.
listeners are not notified?
I wonder if it is better to pass the admin label here in getSystemAdmins()?
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
s/vmId, null, deviceEnabled/vmId, deviceType, null, deviceEnabled
please remove alias setting (should be encapsulated in addManagedDevice
can we use the os-repository to prevent unsupported configuration?
to avoid a crash on orientation change in tablets we should add: if (handler != null && runnable != null) { handler.removeCallbacks(runnable); }
Since NoteSQLiteOpenHelper is currently a singleton, it's dangerous to close the database from here. Theoretically, it's possible that another objects still wants to use the database. Hence, I suggest to remove this.
Please move super.onDestroy to the end of the method.
Can't we use COMPONENT_NAME here?
Use assertNull
suggestion var service = getCandidateServicesToMatch(serviceId)
When the view is closed you need to stop the build thread
Would it make sense to add something this.caches.clear() to the stop ?
This is unnecessary. The super method doesn't do anything
This should be: if (info.status() == Status.MERGED) {
might be better to split on \\s+ to cover any white space.
Need a fail() here. Otherwise, this test passes if getAccountId() doesn't throw.
this could all be one line i.e: return criteria.list() > 0
Can we have an order group without an encounter?
Can we have an order group without a patient?
suggestion LOG.warn("listOffsets request failed.", e);  Thanks! (minor suggestion to make the log message more typical)
Should we return emptyMap if we are SUSPENDED as well?
is this the only line that requires KafkaOffsetsRepository to return a mutable map?
no if (initialized) check and exception if already initialized?
Wrong log message stating about geronimo which is removed in this PR.
I would prefer these returned a DateTime to improve the model and instead used Jackson annotations to control the render format. Thoughts?
oic, didn't realize. Thanks for clarifying :)
Could we use form binding instead? suggestion return req.bindJSON(SlackUserProperty.class, formData);
Is this a safety check? Whats the case where this would be null?
Removing test because you can not fix it is usually bad idea
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
There's a Map-specific assertion class:  assertThat(results.get(0)).containsEntry("name", "eric");
defensive copy?
null? why not just a () -> {} ?
Collections.singletonList
I meant  try (InputStream resourceAsStream = getClass().getClassLoader().getResourceAsStream(resourceName)) {
use -> throw Throwables.propagate(e); and remove the last throw statement
Why not Resources.toString(Resources.getResource(resource), UTF_8)? Also I don't think there is much value in throwing IOException, you can just catch it and throw an UncheckedIOException.
This supplier can be Suppliers.ofInstance(config).
Shouldn't this return a Page<T> instead of a List<T>?
let's break lines here to make the formatting a bit nicer, and not have such long lines below.
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
I think it is better for performance to get the member first, check if it is not null and perform deserialization. Also safer.
Since there are already multiple exit points, refactoring as (something like) below would make it much more easy to read:  if (jsonObject != null) { if (jsonObject.has("aggregations")) { return new Aggregation(jsonObject.getAsJsonObject("aggregations")); } else if (jsonObject.has("aggs")) { return new Aggregation(jsonObject.getAsJsonObject("aggs")); } } return new Aggregation(new JsonObject());  Other points: - getAsJsonObject instead of casting - the "aggs" passed to Aggregation seems like a magic value without any function, so I'd suggest creating a single argument constructor for Aggregation where the name is determined in that single point.
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
dont think a setter type function should return the "this"
This is not right. You need to pass a new new ArrayList to setCollection() since values() is not a List and any call to decorated() will crash.
Declared but unused.
Change collectionType to iterableType?
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
Do we need this? All it does is assert that the message is equal
The old code was building a new WebTarget on each invocation. To have the new code do that, you could use then() instead of thenReturn(), and use a lambda expression or method reference accordingly.
I've been meaning to ask you if there's a class I can actually instantiate, thank you!
I haven't tested it, but I don't think this will compile.
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
Not in spec.
This is not appropriately thread safe. Whenever you require synchronization you must make sure all atomic operations are performed under the lock. In this case, it would be possible for two threads to race associating the same async pretty printer with the request id and both would report that the key was not already there and then both would attempt to add it. This is solved in one of two ways here: a) use a different locking object and synchronize on it for the entire method body or b) take advantage of the fact that put returns the old value if it was present and throw if it returns non-null.
> requestid [](start = 59, length = 9) requestId #Closed
WorkItemLifecycleEvent does not belong here. This class should be agnostic to WorkItems
externalize
externalize
externalize
Could use this::updatePartionInfo
This needs to be System.nanoTime converted to microseconds. Otherwise we loose precision.
Is the (Runnable) needed?
Local variable: no final needed. Is your IDE configured differently that checkstyle?
I prefer shorter method names, when the important information can be said by the argument type - which is the case here. LGTM.
Wondering what's the benefit of catching java.lang.Exceptions for EventListener.handleEvent() when handleEvent doesn't declare a throw in its signature:  public interface EventListener { public void handleEvent(Event event); }  Should we make it more specific to catch java.lang.RuntimeException? Since there is no throw in the signature, we don't lose on any functionality, and it makes the intention clearer in the code itself.
Maybe just setVisible(false)? I believe setting the value and the indeterminate properties won't have any effect here...
We didn't use the custom action bar before. No need to use it now.
It would probably be worth ensuring these colours are in keeping with [PatternFly](<LINK_0> and even use PatternFly/BS3 "alerts"?
Why not use assertNull and assertNotNull?
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
antipattern: using getBytes without character encoding
was the system.out meant to be removed?
We usually use LiteralExpression for this. Also, the nameExpression can be an Expression directly
nit: you can do mLGNames = Sets.newHashSet();
null checks?
Can header name and value be null?
I think it should return Array here.
The cast is not necessary, we are not using generics for nothing ;-)
log this instead of printing
This log message is not correct. The line above dir.mkdirs() actually tries to create the directory. This log message is in the event that you can't create the directory... one such example could be a file permissions issue. please revert this log message as it's incorrect as to what is happening here.
this doesn't belong here
why not use @Inject ?
Why you need this synchronized?
unused variable
extracting a value to a variable is a great move where the input and output need to agree. this larger number forces us to use IntStream.range() to generate the list (and applying an operation on top of it; here sorting). If we start with a smaller value, we could _start_ with the transformed value. Example: java final List<Integer> list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8); final List<Integer> reversed = Arrays.asList(8, 7, 6, 5, 4, 3, 2, 1, 0);
use Arrays.asList(...) for short lists.
log or throw. Don't do both.
Probably we should log the exception here (debug or trace), just to help with troubleshooting
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
This method could be put to parent class and called in each test class. Or some ResourcesUtil class can be created that will contain handling various resources. Or KieUtil can be used.
I don't think you need to change this class.
AsyncSerial again?
Can use curSelectedIndex.orElse(-1) + 1 here.
Will this be safe if currentMilestoneIndex is empty? Maybe cover it with a test as well.
userInputWords should be renamed. queryWords?
Send this exception to the log.
So you trim here when you validate but you don't trim when assigning the variables above. Either you should do trim there too or just not trim here.
Nice! (times n)
[FindBugs] WARNING: SA: Self assignment of field KafkaSingleThreadedMessageReceiver.subscription in pl.allegro.tech.hermes.consumers.consumer.receiver.kafka.KafkaSingleThreadedMessageReceiver.update(Subscription)
Perhaps for cleaner code, we could check whether this consumer is consuming from the outside when updating subscription and avoid null checks. Also, the private method startConsuming can use the field instead of a parameter.
I believe this call is useless when we have 150 instances
Does this work if transactionCallbacks contains multiple callbacks? If previous code causes recursive call, I would think ConcurrentModificationException would be thrown.
Ditto about breaking.
einfacher: for(Team t : teams){...
This local variable appears to be shadowing the field variable
better to remove if if statement, just set the value, the user of the entity can than use the getUseFreemarkerTemplate function to choose to use the template of not.
This is called in the init method. Why is it needed again here?
It's always used with join(), so I wouldn't return CompletionStage here.
<LINK_0> handled the case when metadata was null, does that check need to go here also?
similarly here, if this is general, I've lost updates...
You used a lot of "Success", maybe try to replace them with a static final string.
Add the error as a cause also?
what if we determine the non-matching character with e.g end() and give it back in the validation result? The methods start() and end() will give the indexes into the text where the found match starts and ends. Actually end() returns the index of the character just after the end of the matching section.
Instead of printing a stack trace to standard error, why not throw a SlimFixtureException with message that date can not be parsed and e as cause?
This is one of the points we should use Zulu Time, but do use the configured default Timezone.
If rebuilding this date format on each invocation is causing too much slow-down, then I would suggest moving this date format to an instance variable.
Replace it with the ArrayUtils#isEmpty.
final
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Why not in combination with above do this: setValue(value, false);
Also called twice here.
include the unit here. e.g. value_size_bytes
I think we don't need to create a table for this test. Just call the procedure and see if it fails.
shouldn't it be > 1
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Please remove System.out
This will probably be permanently unsupported.
I think we might want to separate out the concepts of hasIndex and isQueriable. In gatk we have a datasource that has no index but supports random access. I also think supportsRandomAccess might be clearer name. I'm not sure how granular we want to go though, you could potentially imagine a stream with an index that supports fast forward skipping but not rewinding, which wouldn't be easily described here either.
What happens, if the onsetDate is null?
Hii @ribhavsharma, this extra brace over here is causing the build to fail, kindly correct it :)
Do same for this one
from withLabels name, I would assume to use only given labels. However, this adds given labels to existing ones. There is very similar method withAnnotations that behaves differently. What do you think to rename this to somethink like addLabels? Or is there even a reason why to putAll instead of replace everything?
Hi CD, This is a Sonar violation; <LINK_0> . Sample fix is below. Please fix other places in the PR too. /** \* @param features Sets features of a cluster point */ public void setFeatures(double[] features) { if (features == null) { this.features = new double[0]; } else { this.features = Arrays.copyOf(features, features.length); } }
I think this should be stripe_account_id ? as per PP-4302
unneeded check
unneeded instanceof check for same reason as above
:art: Personally I would lean toward using a guard statement. java if (entity == null) { return null } ...
Could you use one check of CoreUtil.isNullOrEmpty() here?
I think I prefer "Invalid key" as exception message
Just in case, please make this method synchronized
remove the public
Hi @hijklmno. This looks good overall. What was your reason for not setting this.accountNumber to stringOrNull(accountNumber)?
UnsupportedOperationException would be better
consider saving the value of group 1 and group 2 here rather than the whole matcher
consider being paranoid and prefix with "line.length() > 0"?
> ~~~Thanks for your patience!~~~ No - on the contrary, thank YOU for your patience.
It is up to developer how to do it this check, but here we can avoid creating a list by using allMatch.
needless else ;)
can be just diamond new ArrayList<>();
Consider assigning some of these expressions to local variables to reduce nesting.
could use a more meaningful variable name
Lists obtained from a message are immutable. No need for extra copying.
I think this is the same as this.newValue = newValue; ??
This isn't worth a warning - probably trace, maybe debug. I don't think there's any need to special case String either.
Can't you push the null check for nodes[ESCAPE] into your new hasEscape() method?
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
Should this also handle the suffix 'es'?
Qualify this.uri
Maybe use message "Config job.name is missing" ?
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
Shouldn't jobName and jobId be always available? Would prefer to throw if not instead of defaulting to arbitrary values.
Is it Novoda style to have this Exception in a new line? If not, could be better to have it in the same line.
Would a switch be cleaner here?
is more readable to have only one return statement
Preferably have one call the other?
just return "" instead of new String()
Modifier 'private' is redundant for Enum constructor - needs to be removed.
assertFalse(...);
assertFalse(...);
IMO it's better to use CrashReporter.storeUnhandledException in both tests instead.
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
I am wondering if we could initialise the minPoints maxPoints to other special value 0/-1. It is a bit confuse to initialise to a valid maxPoints value while requireMax is false.
Assuming this is noting completion of initialization, perhaps "Finished initialization."
shut down one word; i.e. shutdown
I think it's better to use compareAndSet just as what you did in start()
Make sure you have a mutable details field here.
<LINK_0> handled the case when metadata was null, does that check need to go here also?
use this.mandoc to be consistent with setCtags() ?
can you please also add method ok(TimePeriod waitForJobs). TimePeriod.LONG may not be enough for all cases
use ShellIsAvailable
You should make sure that ProjectExplorer is open
Should you attempt Path.toFile() here?
Can you explain this please?
maybe something like this instead?  File file = new File( directory, targetFile ); if (!file.exists()) { fail( "Could not find file " + targetFile ); } return file;
I believe that the BackendUserResource.getUserByNameAndDomain method is only called from here. Can we check if it is reasonable to move that code to this class? And then, instead of implementing it with 'performGet' we can implement it with 'getEntity', and check if the result is nil instead of generating and then ignoring the exception.
I'd suggest to check if the returned user is null. That can happen if the user has been removed from the users table but its name@domain is still in the vm_dynamic table.
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
Since we're tracking this event after the user taps the next button and only when the email is valid, maybe we shouldn't call it "email filled", as it may be misinterpreted as the user just filling in the email input. Does that make sense to you? To be honest, I'm not even sure why we need this event. What's the idea here?
200 -> HttpStatus.SC_OK?
What happens if the email is updated but the updatePublicationOwner fails? Admins should probably have a notification on it.
Style-nit: We don't put {} around a single statement.
It looks like Eastwood was briefly mayor of Carmel-by-the-sea, California, which is a city rather than a county. Recommend replacing changing county to city = new HierarchicalMap(state).
Should't we check also floatingBodySelections != null ?
I'm not convinced we need this extra complexity. Could we just call logger.error("", runtimeException) without changing level or modifying any of the other code?
If the wildcard mode is higher than the registered mode (which can be achieved by setting the wildcard mode after a register call), this method will only return the registered mode. I think in this case this should return the merged mode instead, e.g. return wildcardMode.merge(level);
If the level is set to "" in the activation key, it will unset the consumers value (from a prior activation key)
You don't need the else statement here. You can remove it leaving the LOG statement and the code will be exactly the same.
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
I think you should start the transaction before retrieveTeam(). Otherwise, the getter to retrieve the team from the cache will happen outside the transaction.
"creator" and "lastModifier" should be added to STANDARD_ALIASES instead of creating the aliases here
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
creator may be null, this needs a check.
This change should be made also for DiskListModel
why not use disks.isEmpty()?
check if not null
you can make it public for not to use generateArtifact(packageId, packageVersion, 0) method calls below
Please follow our official log pattern (also automated in Eclipse via code template): <LINK_0> However, IMHO "impl test" was not supposed to be committed at all...
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
stream & collect
use Guava lists for consistency + throughout code
flatMap that stuff
this.
Better do this as a static variable
read or consume?
pvk should not be visible. Please remove it.
Bad variable name! Variable names should be clear enough. Rename it.
please use line number of lamba in argument of method , it is really cool idea to make it more visual.
We still need to call to deactivateParticipants()
This causes now editor not to open (sometimes) on BP hit if the debug view is hidden - all in a single window. Open Java perspective, start debugging, close editor, hide view, resume after few times editor is not opened...
It should check that the part being deactivated is 'this'.
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
no need for an ArrayList
Hm, I would expect that if I call build on a fragment and I change the fragment after that, that it does not change the previously build reference...
nit: could you collapse all of these into fewer lines?
Perhaps nameToDataType.
This field definition seems strange. Why are these two interchangeable?
Isn't this condition inverted? Juno and Kepler are the only versions for which we can *not* support the dynamic tabbar.
isSecure() return true if "coaps is used and false if "coap" is used. The naming is not so good with the OSCORE addition (so maybe we need to rename it but later.) So in this case isOSCORE should not impact isSecure()
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
if you remove the property, why aren't you removing this method as well?
Isn't encodedLength zero if the thing isn't encoded?
I think we should change this to package scope.
Wouldn't it be better to give the names as part of the enum constructor?  Java STRING("String"), LIST("List"); private final String _name; private RemovedMatchesType(String name){ _name = name; } @Override public String getName(){ return _name;}  The less logic, the better. We get the added bonus of not having to change the _if_ to _if-else_ or a _switch_ if other types are added.
return index == 0;
merge else if?
@jjl014 User id is optional, unlike client id and session id, which are required for user info
Why do you use package-private access for this constructor?
Matchers.is
This is really expensive to do every time.
we might here just get rid of the String result declaration and combine these two lines into return percentFormat.format(value);
Why do we have to reset it here? Is it because the standard, GZIP compression is not supported? How hard is it to simply support it?
capturePageScreenshot is more appropriate - capturePage could have a lot of different meanings
This one is using a default timeout, (thath is 30 sec) - maybe 5sec is enough?
The super() returns "" on null. Why should we differ?
Instead of sleep, what about replacing with CountDownLatch? We can unblock through the code rather than depending on the timing schedule.
:astonished:
30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.
Is it safe to let the else case fall through? Perhaps the entry display type should be the first thing checked in the method and return immediately if it's not DISPLAY.
If the event doesn't have a style, we should try to use the default style from its entry. This can be used for entries that want a specific style for their gaps.
a new array list will be created per event here. Even with the best garbage collector in the world, he will be overwhelmed by the quantity of objects after a while... Cache the list as well
Gson doesn't run on these versions so I don't see any reason to include them.
This needs to be in an else block, this code is always called.
Looks like eventPriority OFF is missing. case OFF: return Level.OFF;
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Could this method be implemented with return addToByteCount(super.read());
Check buffer null.
Check if buffer us null.
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Are Operation objects immutable? Otherwise you'd have to copy them as well
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
You could remove "verify that the" from the logging description.
remove empty line
Global listener catch each click. You don't need to log it.
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
I'm not a big fan of asserts in production code
Dito about Math.min()/Math.max().
Formatting issue
Seems to be more than 120 characters long
Put the cast on the same line
Should use the log, maybe a warning.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
That was exactly what I want.
Does it make sense to throw an exception here? It would probably be better to log the fact that there is no exchange and then ignore the response. WDYT?
Do you think if better handle the status code here: <LINK_0>, because that is the method sole responsibility to produce the correct HTTP response and thus you won't need any further logic elsewhere
I am wondering whether it wouldn't make sense to move the resolution logic out of the TaskManagerLocation class in order to make more like a simple data transfer object. For example, we could have a method fromUnresolvedLocation(UnresolvedTaskManagerLocation, ResolutionMode) which either resolves the hostname or not depending on ResolutionMode. As a second step we could think about whether we want to support laziness. If this is the case, then we could provide a Supplier<String> fqdnHostNameSupplier which we call to give us the fqdn hostname and then store it in some field. Separating the TaskManagerLocation from the way it is resolved might simplify the individual classes a bit.
ImmutableList.of
All of those continue statements are redundant.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
IOException?
file might be a directory - message will then be misleading
don catch exception, better fail than return ""
The code can be simplified to rely on autoboxing.
Don't you need a cast to byte: "byteBuffer.get() == (byte) 0"?
can you add to Builder as well
See the Headers class.
I'm really not sure about this. All existing Remove* commands in Creaper just do ops.remove, letting the command fail if the resource doesn't exist. Do you have any specific reason for doing ops.removeIfExists?
Sorry, I forgot about one thing! This will no longer be enough, there's VERSION_1_8_0 now. I think a better condition would be: ctx.version.lessThan(ServerVersion.VERSION_1_7_0) || ctx.version.inRange(ServerVersion.VERSION_2_0_0, ServerVersion.VERSION_2_2_0), but feel free to write the condition on your own.
The TimeBudget should have been created before the call to ConnectionFactory.connect(), otherwise you are just timing getting the lease, but the budget is supposed to cover the whole connection. Ideally there would be a way of passing the TimeBudget into the ConnectionFactory.connect(), but as it is the first call, it can manage its own TimeBudget.
Can't we use connection = super.createConnection() instead? That's way we do not have to pass null parameters?
@kishorekasi Generally wondering if this will increase the latency of the operation since we are not failing and retrying connection?
I'd add a get from the DB here, to make it was really updated there.
suggestion throw new IllegalArgumentException("maxPoolSize must be greater than corePoolSize");
For executors that have a queue, we set the core size to be the same as the maximum size, so setting the maximum size should also change the core size. Maybe we also need attributes for the queue size and the maximum queue size.
needs 2 _arguments_, plural
Could be extracted to a private static final constant.
Same as above. Can also move this common block into a method of Function and use at many places
Any reason to create doSave ? Shouldn't extenders be able to override 'save()'
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Should be Refreshing_X and use NLS.bind()
Interface can be used here.
Can you remove this catch Exception?
Use a constant.
We can give some more time, like 30 seconds.
Might be my math skills, but 5 + 20 != 35 ;-)
Is there an effective difference between awaiting 0 or just not awaiting?
@erdemedeiros we should stick to only tasks that we as an authenticated users can see. That is what the default findAllByWebQuerydsl() should do. We should add the check in the getTaskById() method to make sure that the user making the request is allowed to see the task. Does it make sense?
Wouldn't Assert.hasText() be more appropriate?
instnaceId -> instanceId
Cosmetic: Please, change this to lowercase: suggestion logger.error("Before execute failed for [{}]", r, e);
Workbench.getDisplay
this will crash on non UI thread. Please simply use Display.getCurrent != null.
can you use the onSuccess / onFailure lambdas to improve the test ?
could we directly reduce this to debug level?
Should we also bubble up this exception or solely log it down?
We could use resource delegates instead, right?
Thanks for checking, have you considered the trade-off of toggling the timeout to be something very short, like 5ms?
Can be simplified using Hamcrest.
can we use CSS?
Upon ValueChangeEvent<String> you would want to fire a ValueChangeEvent<T> to represent the change in the T value, so you have to know how to translate from String to T. ListModelListBox does it through GWT's ValueListBox, which translates according to index. You don't have indices, so you would need some sort of Map<String,T>. I would do that by implementing setAcceptableValues() in this base class, and in its implementation construct the map using renderer.render() for the map keys. The renderer for ListModelSuggestBox should just cast. Then when a ValueChangeHandler<T> is passed here, I would add a ValueChangeHandler<String> to the SuggestBox that calls handler(map.get(value)).
You know what, never mind, it is a matter of personal taste, I don't really mind.
"amount of columns was typed: " + columns
s/Css/CSS and space after comma
OSGP code conventions are not followed (missing this. before referencing a field).
Same here, a constant can be used instead.
Missing Assert.fail().
assert get account null
Any reason for doing the instanceof check in add but not subtract?
Is this method used?
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
new ArrayList<>();
List#sort usage.
This will throw redundancy warnings in IntelliJ
You are not supposed to access usernameEditText.getText() from the network thread. Capture the username and password into final String variables right before scheduling the action.
doesn't setTitle have a version which uses the resource id directly, just like setMessage?
I think @damithc meant this instead:  java if (panelList.isEmpty()) { return true; } // everything else  Makes the logic a bit simpler to read.
Remove the public modifier from the constructor and remove the null check.
Please check if this method really should be public in a private static final class. The parent method is protected.
This could simply return the enum itself couldn't it ?
Take a look at <LINK_0>
If it is clearer then method name clear looks more natural for me than remove
There are enough mock objects in here that it's worth using @Mock annotations instead.
LinkedHashMap? Does it matter here? I'm not sure it does (on mobile).
Local to this package? If so, remove the public?
nit: I think you can just declare Set<LockRequest> here
What if it's absent? In my account it may be absent, for example
This line should be shifted 4 chars left.
!keys.isEmpty()?
Just do this at the root of the database every time so you're sure nothing else is happening: mref.getRoot().removeValue()
If we are adding mChartboostBannerto a container view (e.g. the bannerContainer from initBanner()), then I think this should return that bannerContainer.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
It should validate that the siteNode is not null otherwise it will fail later (and seems to break the panel).
Check first that target is not null.
Is this intended?
should this be more strict ? i.e. require at least one character inside the parens ?
Pattern.quote, note that we shouldn't change stringPayloadPattern itself, this should be used only when compiling it otherwise in the UI we show something different than what was specified by the user.
Just minor thing. Both setupPatternList methods do a slightly different thing. I would rename the first one to something like view.clearPatternList();
If it's an application component, you should get it using Application.getComponent(). Makes things less confusing.
I assume it's false because you expect the Permission schema to be populated?
Isn't there a timing issue involved here, e.g if the server is slow returning the access token? I'm not sure how to solve this though
Can you also capture stats on the hit ratio, load time and total weight.
Shouldn't this comparator be "<", which means we can only add new item to logSet when it's size does not exceed LOG_MAX_BUFFER ?
Can we use computeIfAbsent to optimize this?
Why did you add the round braces?
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
Raw type List
This should not be static. The choice of whether to use BMX should be per apache server, not per agent.
Please also delegate to setDnsConfigurationEditor
There's no way to use constants for those ugly hex values, is there?
nit: you can do mLGNames = Sets.newHashSet();
Use .getOperator() in place of m_operator?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Use ImmutableDataCachingUtil.getValue(ImmutableSpongeValue.class, Keys.IS_SNEAKING, this.value, false); instead so that the value can be cached.
Use the immutable value cache
Make this a final field - it never changes once the data is created, so there's no point trying to find the data each time.
No need for null check.
You don't need the null check, the analyzer method accepts a null without issue.
No need for null check.
Maybe use the orElseThrow method of the Optional here
Shouldn't it be just type here? Or perhaps extractedType. After all, it can be the constraint type _or_ the validator type.
We need to have a backup plan here if type isn't a TypeVariable.
What is the deal with the type converter?
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
Wouldn't it be better to get backend's current context, store it in a "previousContext" variable, and do a backend.resetContext(previousContext) in the finally clause.
Assert not required if field is final
Can you use getBeanNamesForType ? Then maybe you don't need to do any type checking
It might be worth creating a base class for Plugins that takes care of this (now that we have several doing the same thing). That would allow us to hide the commonApplicationContext and BeanDefinitionAddingPostProcessor for common cases, instead exposing a simple addBeanDefinition method to sub-classes.
On reflection, I suspect that this was done for backwards-compatibility reasons, since overriding and delegating to base would be a behavior change whereas this change is only a performance optimization.
does this method need to be public?
static.
checkOne can be used or is unused?
I see this code is from other classes. But for read(ByteBuffer dst) implementation here, it is not necessary do it in a complex way like this. Temp buffer is not necessary Since it is backed by a byte array underlayer, why not simply check and do a copy once like, what you do in positioned read (or actually you can actually call directly the positioned read and increment the pos according to the return value.)
Call next constructor this()
Use Iterators.transform from Guava?
you should just return backing.hasNext() here
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
Then this one could become java return ImOption.apply((Focus) getValue()).map(f -> f.getStringValue()).getOrNull();
Maybe just: java setValue(new Focus(string));
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
It seems like you are expecting a certain exception here. Can it be made more specific than "Exception"?
@pynicolas let's add  assertThat(symbolicValue("42")).isEqualTo(symbolicValue("45"));
responseStr might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
We probably want to hold on to a reference of the mapping context ( MappingContext<? extends ElasticsearchPersistentEntity<?>, ElasticsearchPersistentProperty> mappingContext) in the instance.
we can't change this logic: it is essential for traversing a changed tree.
suggestion assertNull(r.jenkins.getNode("foo"));  since it is not otherwise obvious that the node's name did not change somewhere in here.
It shouldn't be there. ProfileView should be shown in onActivityCreated of relevant activities in which we have to make it appear.
If we try to switch to the other app and back, the app will crash. void android.view.ViewGroup.removeView(android.view.View)' on a null object reference
Should we cache the size inside the for loop? for (int i = 0, size = recyclerView.getChildCount(); i <= size; i++)
Nit: would you like to say "flow pause requested by user"? It's not given that it will be paused at this point, right?
Same as above for toString(): <LINK_0>
useSSL and sslPropertiesLocation must be propagated from here.
Think using switch just adds noise here  return this == PERIOD_END ? period.getEndDate() : period.getStartDate();  is simpler whilst there are just the 2 possible values
These two lines can make use of a nice ArgChecker feature:  ArgChecker.inOrderNotEqual(startDate, endDate, "startDate", "endDate"); ArgChecker.inOrderOrEqual(valuationDate, startDate, "valuationDate", "startDate");
return of(index, currency, fixingDate, endDate, sensitivity);?
please remove this statement or enhance it to something more context/meaningful
please decrease log level to trace or better remove statement
please decrease or remove this statement
pvk should not be visible. Please remove it.
change variable to something more meaningful
Bad variable name! Variable names should be clear enough. Rename it.
This should check that repository is not null.
I'd prefer to remove the field itself. Feels a bit unclean to have a field which is only valid during the execute method. It should be a local variable in execute and passed as an argument to getTagTarget. What do you think?
The field should be removed as well.
This isn't a job. Please rename the object to match what the object actually is.
If we are not implementing, can we throw upsupportedoperation exception ?
Minor: can remove throws
This can be defined as Lambda
Similar
Similar
Return value of the method is never used.
Return value of the method is never used.
I believe these 3 lines should be moved to BMT, it's his logic
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
Sorry but I did not find where we call the close method?
This shouldn't declare throws Exception.
inline
Don't we need to use .toLowerCase()?, I thought the keys where saved lowercase in the keystore.
you can create a temporal file by using FileUtil.createTemporalFile instead of handling by yourself. If you need to do this way anyhow, you could probably add a delete in a finally sentence
Should you call analysisReady(false) here?
Check for null here: ScheduledFuture<?> f = handle; if (f != null) { handle = null; f.cancel(true); }
@Gr1f0n6x , please use ExecutorServiceManager.shutdownGraceful there
This isn't the listener I was worried about. This should be fine, as the main tab model is probably destructed soon after its view. What I worried about was the systemTree listener, because the system tree stays there and will keep trying to send events to the disk main tab view (which will not exist anymore). So basically, I think instead all is required is CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().removeListener(systemTreeChangedEventListener).
Unnecessary newline, and I would just inline (i.e. CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent().addListener(systemTreeChangedEventListener)).
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
containsExactly oder isEqualTo verwenden
If possible, it would be nice to test also the expected result of a call instead of just that the response is not null
This whole block can be simplified, no? You're effectively checking for negative health twice now.
Sorry, I missed this completely on my first review. Having a public class but a package-private constructor is slightly problematic from an API point of view. As it allows everyone to see the class, but not to use it. I'd suggest to make it public or the whole class package-private...but I'd need to do some more thinking about that one, so I'd go with public.
What are key/value types ? Map<String, String> ?
i'd prefer returning a new instance DownloadParams when downloadParams is null
Use try-with-resources so you don't need to manually close the session.
Use try-with-resources so you don't need to manually close the session.
You don't need to commit when only reading.
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
Don't we also need to interrupt a thread if it is interruptible? (to cause calls like Thread.sleep() to be interrupted).
I thought format used "%s" and "%d"?
please use try with resources as in ConfigurationHolder
Use Files.newInputStream() instead of creating a FileInputStream directly. This delegates the creation of the FileInputStream to Java NIO, which is a bit more efficient. In particular, it does not have finalizer.
you can put FileInputStream stream = new FileInputStream(fileNamePath); to the try as it is AutoClosable, I guess..
There is an INVALID_NAME type you can use instead of OTHER. (Same for the NAMESPACE validation method).
Could use constant in this message
if this is the case it is just not clear for me why this error was not caught by the pre-release tests..
Missing <>, this is a raw type.
Should use Long.class
This can in theory throw a NumberFormatException. This is caught in similar case in ListBoxByteSingletonDOMElementFactory, might be good to catch it here too.
This line is too long, I'd suggest to use some local variables, it helps with step by step debugging as well.
why this is not in getBackendCollection()? it would solve this in generic way...
why this is not in performGet()? it would solve this in generic way...
Listener which does nothing, looks weird for me. Is it okay?
{} may be ommited for single statement
I think we should register it with the default (part it). We might be generalizing this change up to the AbstractTimeGraphView level soon, and there if we use the default id we wouldn't want to break the extensions that add to the Call Stack view context menu.
Change to just the remove call -- the contains key call is unnecessary (as remove will do that check anyway)
What is the designed way for user to get the PermissionManager? through this API or the constructor? It is confusing to me if the close() should be called on the return value of this API.
Is this the approach we're taking for remote clients? Since we keep counters in the same module (infinispan-hotrod-client), it might make sense, despite the asymmetry with embedded approach. In any case, sync with @karesti and her multimap (maybe post on infinispan-dev about it).
ExceptionResponse is not a ValidResponse, so the validResponses field name is no longer accurate.
Just like how the error occurred in the issue, won't this fail to get the responses of the session? Edit: oh I get it, it won't matter.
this needs to return responsesObject (converted to Map) or responses depending on null status of the two. see how this is achieved for responseSchema and schema in response
nit: redundant
To always be safe please use context.getApplicationContext()
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
This is bytecode equivalent to using the for-each syntax on an array.
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
You can replace the for loop here with values.forEach(result::add);.
s.a.
Consider wrapping with Collections.unmodifiableList(...) or calling a copy constructor so that callers can't inadvertently mess with the entry contents (unless that's desired?).
use interface instead of concrete class
secretLabels = Arrays.stream(labels) .map(l -> l.split("=", 2)) .collect(Collectors.toMap(p -> p[0], p -> p.length == 1 ? "" : p[1]));  ?
@essobedo once used variable can be inline
specify array length (based on codecs.size) to optimize. <LINK_0>
assertThat(topic).isNotEmpty();
I don't want to return null from getApprovals(). It shouldn't be that hard to modify ChangeNotes.onLoad to handle a null revision.
assertThat(related).hasSize(2); the same for several occurances below
Remove public. Also let's reformat all the ctor to our latest code style.
Clean the "public" as well
rm public
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
Check the longitude of those lines, some of them can be more than 120 characters.
What if the storage domain was inactive and you moved it to maintenance and failed.
As we discussed before I would simply add an audit log as been done in line 133
You should report this failure out on getActionReturnValue()
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
A more robust assertion would be to check that the list _contains_ the created Lan. Just to avoid race conditions if at some point we create something else in this datacenter.
This is redundant.
unused variable
Lambda could be replaced by the method reference Attribute::getAttributeName
There's no reason to change this into returning a Set. We can still return a Stream here, by the x-java-response: type: to java.util.stream.Stream from Iterable (check other examples in the spec file)
Objects::nonNull instead of a -> a != null
possible NPE
CheckForNull
CheckForNull
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
I am not sure if we want to return null here
Just return commandName if collection is null. I'm not sure but don't expect the JVM to optimize the stringbuilder away for this pattern.
Arrays.asList?
Nit: Can use the empty map matcher here to be more explicit about the match criteria.
similarly
why Object?
I think we should handle both numbers and strings here properly.
int ?
this could be done by a stream right? Like types = list.stream().map(e -> e.getName()).Collect(Collectors.toList())?
Is this superfluous casting?
I guess that this test cases should also be with intervals only.
This makes more sense as it's forcing the consumer to think about the empty case.
Maybe just one thing when I looked at this the second time. Is this check really needed? If the currentNode is null, then we can immediately return null because given that nodeId is unique, it won't match any of these conditions more than once, so it will eventually reach return null;.
This is nice to see. We should have done this to begin with.
This setting should be in the initiateDriver method.
I think driverPool.forEach(d-> d.getDriver().quit()); would look neater :)
if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe(); then there is no sense in if (driver instanceof AppiumDriver)
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
Is this the intended message?
Have you intentionally omitted index check?
any reason why a dummy digest manager needs a 8 bytes here? can't we just make it 0? the digest here is anyway useless, no?
If you have to cast here then you probably should have casted when reading the value from the data array.
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
Shall we use the constant - APILifeCycleState.PROTOTYPED.getState() here?
Shall we mention the exact cause in the assert message. In this case Error in scope creation with duplicate key?
Lets use the lifecycle status constant here
antipattern: using getBytes without character encoding
Don't we need to the close the streams?
pass the whole exception to logger.errror
Add Pagelogging
put method contents into private method with WebElement parameter
Add Pagelogging
this doesn't look like it needs to be public
The local var is useless, you can remove it.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Would be good to move this contstant to this file and name it something like WIDGET_ANSWER_STANDARD_MARGIN_MODIFIER.
We don't want to any of the select widgets as we need the select options to spread from edge to edge. This change should be reverted.
Ideally this would be the previous value of context, if i just toggled the button on and off.
userRepository and modelMapper invocations are not verified
Shouldn't it be handled as NoResultExcpetion? I think it worth to change the service implementation to be consistent in these situations.
It worth to check which mocks were executed. Use when(modelMapper).should()....
what's the motivation, why you need to update the layout? FD is in charge of doing it, not sure if it safe to update the layout here
This should at a minimum restore the thread's interrupted status with Thread.currentThread().interrupt(). Throwing an exception is typically poor form, but it depends on the thread's context. There is a chapter in Effective Java with specifics if you are interested.
The orchestrator will pass down a connected client (i.e. it will have a layout ready) when it creates a workflow, why is this needed?
this needs to be called for all configs
Is this call necessary? It is called on line 109.
This could actually be backward compatible with the existing API if this method (and the monitoring equivalent) simply replaced the first notifier.
use namespace instead of DEFAULT
Do we need to remove this? I have no idea how this can be exposed to users, but it looks useful. If this should be removed, the code computing the INVALID_ROW_COUNTER in HadoopDruidIndexerMapper should also be removed as well.
assert.NotNull ?
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
You can use CollectionUtils.toImmutableList
This will throw redundancy warnings in IntelliJ
I think this should be in GerritGlobalModule, which requires moving this type to the gerrit-server package. But if we ever support editing permissions over SSH (which git-store enables!) we need to run this logic in a context where the gerrit-http code might not be visible.
This should be declared in GerritGlobalModule.
Please fix the alignment.
This is redundant.
A more robust assertion would be to check that the list _contains_ the created Lan. Just to avoid race conditions if at some point we create something else in this datacenter.
How about a String consisting of entirely spaces? Like this: java String empty = " ";
Shouldn't this be wrapped in a try... finally block?
please do not return at middle
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
Why this check? This method will not get called unless performRuntime is called, and performRuntime has no such check.
The WFLY-1069 stuff should tie into this.
Just thinking out loud here, should we add a debug or trace log if the value was previously defined and is being replaced? Something like debugf("Value '%s' for key '%s' being replaced by value '%s'.", oldValue, key, value);.
Won't fix.
Nothing to cleanup?
Would it make sense to add something this.caches.clear() to the stop ?
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
why?
Extracting the lambda into a private function would increase readability.
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Missing opening "(" before getDescription().
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
You could empty the buffer at this point and reduce memory overhead.
As a read-only view of an existing buffer, some users might expect to be able to still read past the initial capacity if the source buffer's capacity increases after this was created. This buffer would end up in a kind of weird state where buf.capacity() > buf.maxCapacity()...
Extract the "USER_ID" to a constant and make it more unique. The HttpSession can be accessed "everywhere" in a servlet container. For example: "org.everit.jira.timetracker.plugin.user.id.hash".
break out if you find the user?
This should be Integer, not int to match the type on line 57. If this tries to return null an error will occur because int can't be null (but deleteByUserId can)
Missing generics
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Request.State.OPEN
configuration should be injected, not read from system properties in the constructor.
Instead of doing the string replacement, we could also use suggestion final String randomID = new AbstractID().toString();  this would be a bit simpler.
Unnecessary parentheses (and an extra line break).
Why not <code>return ExitStatus.COMPLETED</code>?
This line will always evaluate to false as we are comparing ExitCode with String?
I don't remember if you can do this but could be a bit more clear: java public boolean isJobExecutionComplete() { return BatchStatus.COMPLETED.equals(execution.getStatus() && ExitStatus.COMPLETED.equals(execution.getExitStatus()); }
(Alt) Can we move the skip condition to the testSetup method just above.
new line after this
Style-nit: Space before {
nit: these patterns can be made private static final and reused.
@Lars Do you think that for consistency (and maybe another slight performance enhancement) this line should be changed as well?
Will look into it; is there an existing test whose structure I can copy?
@overquota Should not #close do #closeConnection and #shutdown do #shutdownConnection?
Somehow orthogonal to this change, we could add the check for the isProcessingOff -- similarly to DefaultPersistentBus#initQueue
Should this method return null if the buffer was not yet created or the buffer was released because of an error? Right now, it may throw an exception upon calling retainedDuplicate()
Add __TS("content: hide filter") also
Not a big deal, but can make use of a proper wait instead?
1. openHistoryPage() method should be named like openFileHistoryPage() 2. method looks better if parameter consist only from one variable e.g. historyPage.openHistoryPage(URLsContent.fileName);
Did we want to have this normalize the path also by returning the normalized version from Path?
I would create a private static checkArgument method for these checks
You could also use path.endsWith("/")
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
@ILikeToNguyen Why the change in visibility here?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Should we check that provided viewer has type ITextViewerExtension4?
WTF is lala
Better assign it to a local variable than having the same call three times.
we should also check for n <= 0 here
Is it the same as this?  java final StringBuilder sb = padding(element, length - back.length()).append(back);
typo "should", also "In case".
Might be able to get away with protected
I think you need to check for a null fetched user; could be an incorrect id.
I find it more intuitive if the @Auth User user is @Auth User authUser and this one is just final User user because the 2nd one can really be any user if the first one is an admin
In updateChart(), the collection fModules is updated first, then this method is called. So you don't have anymore the old modules to be able to recreate the old series that need to be deleted. How about getting the series set directly from the SWTChart and delete them one by one using their own id provided by ISeries?
hmmok, might as well do it right, I'll push another version in a few
Maybe use THREAD_0_SEPARATOR instead of a literal "_"?
off topic: I've been writing this as "client == null". I think this conveys just as much information in fewer characters, so by Shipley's law I should switch over. The drawback is that "client == null" is a boolean expression, and is consistent with "limit < 0" etc. . .
FYI, proper English grammar is "must not be null" or "must be non null" (I'm not sure if grammar requires a hyphen in "non-null").
good catch, the missing job name was resulting in quite a few unnamed jobs in the progress view - reported by QE, found out via jstack what it was
@lautarobock Same here, let's declare throws Exception
@lautarobock Here too, let's declare throws Exception.
@vkuchyn didn't get, why these 2 lines are still here? I thought they were added to cover "happy path", no? If yes, they should be removed
Maybe you can use .putAll(map) method to simplify this code.
Should be this:  return Collections.<Method, MessagingGatewaySupport> unmodifiableMap(this.gatewayMap);  We may reconsider when will come to Java 8 finally :smile: Will fix on merge.
Why do we want to return it if we have methods to manage it. It seems like encapsulation issue.
trace
trace
log.trace
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Please use Optional.ofNullable()
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
Indeed, that is better than my suggestion. Let's do this.
Slight wording change - the "by searching" bit is unnecessary and also irks me because you never say what or where you were searching suggestion logger.log(Level.FINE, "Could not find an appropriate address, falling back to local host");
This may be absent, so the API should express this. It can either be an Optional<Integer> or a @Nullable Integer
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
Pretty sure this is a Nonnull field. Just make it a Chest or Empty.
Isn't "Access Denied" a constant in ResponseStatusFromPayloadHttpCommandExecutorService?
This could be changed to return void now.
You can set the Constants.PROPERTY_MAX_RETRIES property when building the context to a lower value if you don't need all those 5 retries.
There is already logging for that in the EncryptionUtils.encrypt catch block
throw ConfigurationException instead
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
I don't really see a need for constructing a File object with the path to an URL here, just split it yourself
ah, there it is.
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
Good to add logger.logExceptionAsError(new Exception....) logger can be used from azure core Ideally, would like to use a better Exception class than just Exception, like InvalidArgumentException. Plus, IOException will need to be handled separately, and should be bubbled up as it is.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Use equals - there is no guarantee that it's the same Guid instance.
let's change the order in the ctor - its clearer when the source is before the dest :)
please consider to create the parameters using the constructor with less arguments and then set the actual size (if needed) using its setter in order to reduce the lines of code (see CreateAllSnapshotsFromVmCommand#buildLiveSnapshotParameters)
2xx
This text can be added to the previous logging, no need for a separate line.
final
Might be worth having a displayName?
Should this be "Upstream Committers"? Also, it might be good to move this to a Messages.properties file so it can be translated.
This should be I18n'ed
I think you need to do this and the next line in a finally
close in finally
Nice. The intent is more clear than using a file in the previous version.
shouldn't this be done.setValue(true)?
Is it really necessary to pass the AlertType to OpenDialog?
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
This will produce a Number Constructor FindBugs warning. Please use Integer.valueOf(0)
Isn't this check is redundant?
casting to int here is redundant now..
Why do you need to return the metadata? You are updating the own object, it should be part of the method getMetadata if you want to obtain this data after an update on it.
Maybe this is thinking too far ahead but is it possible that we have a metadata initializer which for some keys and values will return null but might return non-null for other values?
If you throw an exception for metadataoptions not being there, you should put MetaDataOptions in the default for the attribute. I can show you.
This should stay final
Should this method be final?
return getForecast() != null ? getForecast().toString() : "FORECAST IS NULL";
this is typically done by having a LoadSpec implementation that wires up the json config to the puller (see io.druid.storage.azure.AzureLoadSpec for a good example)
Is there any way to tie this to LoadLocalSpec ? parsing the loadspec and calling getPath seems a little extreme for here, but can "path" be put as a public static final String in the class or something?
Do new Yaml(new SafeConstructor())
This is not correct.  select distinct a, b*2, c from (select a, b, c from foo order by a, b, c limit 100) t;
We also need to replace childTraits with enumerable convention. also hashjoin.
should be assert?
The only change I think we should make here is use our Util.UTF_8 constant for consistency.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
This closure API is quite odd, but why not have a new var superTypeCtor?
@paulodamaso the braces and return are not needed here
@super132 I think it is better to use Collections.emptyList() method instead of static field
@fanifieiev the same above.
ARRAY_ELEMENT_DELIMITER is also a single character in CsvValidator.
The community recommend to use List ConfigOption for list values, framework will handle the parsing. This will also change to use ; as the separator, but this is more align with other list options. You can declare a List ConfigOption by : java public static final ConfigOption<List<String>> TOPIC = ConfigOptions .key("topic") .stringType() .asList() .noDefaultValue() .withDescription("...");  Then you can call return tableOptions.getOptional(TOPIC).map(t -> t.size() == 1).orElse(false); here. Sorry for the late reminder.
suggestion throw new ValidationException(String.format("Option '%s.%s' must be a single character, but was '%s'.", IDENTIFIER, option.key(), tableOptions.get(option)));  Use 'csv.xxx' to be more align with DDL options. And use character instead of Character because this is not in Java language.
throw CucumberException and give the user a clue what was wrong and what he needs to do.
what about putting this in the default: case of the switch (switches without default, you know...)
Same recommendation for using a constant for the content.
RuntimeException?
RuntimeException?
What should be the expected order? Is there any concerns about this in the API definition?
Please keep this.cell near the related fields (previousFamily & cell count) below
lastFlush is never updated. Am I missing something? Also I wonder if we should update MessageFlushPredicate.shouldFlush() for this new lastFlush argument as well.
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
extract variable
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
You can put the whole ability text here instead of calling the super but if you don't you should add a comma after "steps"
You can just put the whole trigger text here instead of calling the super, it'll keep you from having to use setText on the token effect
Unwanted final?
Sorry for not providing all the details. Please propagate the methods to the TargetNodeComponent as it was done for isPerSyscallEventsSupported(). The methods of TraceProviderGroup will just query the parent.
indentation is wrong. Please run $ mvn clean install -Pqulice to see what is wrong
"{}", e.getMessage() stack?
Maybe, debug would be more appropriate then?
please don't use assertTrue(empty) but assertEquals(..., emptyList) since this gives a better error message
instead of e -> e there is a Functions.identity()
I thought this line is wrong until I realize that you changed what done means. I would add a second variable, and make done a local variable in handleException. I would also prefer that handleException be inlined due to the tight logic relation with run.
Now that you're at it...
Maybe, this is final?
Do we need the empty constructor?
Do we care if the form was completed or not? I think reportFormExit is called even if the form wasn't completed or even saved.
createTileOverviewForm()
Catch exception.
Mark as static.
Why do we have a 5 minute timeout? We should pull this out as a constant.
I am leaning toward moving this back to requiring Jenkins.ADMINISTER
Better revert.
I don't really like mixing Optional with old-style nullable parameters, so I'd rather use null for both. (Or Optional for both, of course.)
partitions.length is final, because partitions is final, so this doesn't need the lock. Are you adding this to get a code analysis tool happy?
As far as I understand it's just refactoring? There are no usages of the new method and it's not related to the ticket, let's keep it as is.
I know this is code correct, but maybe I would rename the local variable writeLock to avoid any confusion with the class variable?
The condition should be replaced with !TextUtils.isEmpty(assignmentId)
The condition should be replaced with !TextUtils.isEmpty(assignmentId).
Wrong event name and bi value is getting passed here. It should be **VIDEOS_UNIT_DELETE**
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
Item dropped should be a hopper
Maybe type.value.equalsIgnoreCase vs. just lowercasing ?
This is early exit, so you can move the else part unindented below.
Should use requireNonNull if we want to throw an NPE otherwise checkArgument if IAE is required.
Remove a nesting level by inverting this if-statement.
Just a small micro-optimization here: If you swap the ItemSetting and the Material check, then this statement may execute just a tiny bit quicker as Enum comparisons are sped up by the compiler. Other than that this is looking good to go!
You could add an empty line between function declaration and content if content is more than one line, much like SDN (where I like it a lot)
is the VM null too perhaps? maybe just move the condition from line 63 up?
perhaps it'll be better to aggregate the list of problematic vms and populate the message with all of them.
sorry if i missed that before, but all the other methods here are retuning ValidationResult, can you please align with the?
Rather than put this in every test, you can just put it once in the setup() method.
hard to find a device without cameras what happen when you throw? can an user get this error using an ErrorBoundary? 0 is always the first camera? won't break the current behavior?
checkState(mPut != null) ?
I don't think args can ever be null, can it?
Should be create, not label.
it doesn't seem right to do this here.... why a getter triggers node visitation? Aren't we visiting twice these nodes by doing this?
remove double a valid from test & implementation
With this pattern, it is difficult to guess exactly which line throws the exception. Normally we try to capture the explicit call in a try/catch. This also means that using the @Test( ....) pattern is usually a bad idea.
Why this listener is triggered? shouldn't the local commit trigger any listeners previously registered without posting to the looper?
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
Does readCursors contain null entry? if not, another map lookup can be saved by calling get() first.
truck is unused
autoboxing
is this call necessary? it is being called only validateControlPointShape() is **false**
I wonder if we shouldn't finish the writing of the history before we add the new terminalControl to fTerminalPageControls? Couldn't we get new output written to the page by OutputReadJob before WriteHistoryJob is finished?
feedDisplay is a strange name. I had to look at the xml file to find out what it actually is. How do you feel about feedDisplayContainer? I know it was like that before and the guidelines we have come up with say that it is not necessary. How do you feel about this? Should we update the guidelines?
Shouldn't errorContainer.setVisibility(View.GONE) also takes care of notificationButtonView since it's a child of errorContainer (Not putting this for other use cases, but should get corrected for install and update as well if we do it here)
emptyTextView can be made View.GONE?
use .getUuid instead of getArtId, which will go away
use .getUuid instead of getArtId, which will go away
use .getUuid instead of getArtId, which will go away
Looks like we have unnecessary parenthesis here.
Suggestion: extract a util method this.senderCopyMessageSingleton = SingletonUtil.setValue(this.senderCopyMessageList, senderCopyMessage)
Curious: doesn't it make sense to call the ResultValidator expectExceptionMessage(Matcher<?>) function from this ResultValidator expectExceptionMessage(String) function? The only real difference is this function does an equals and the other calls matches().
Please add a space after (Class<E>).
Codecov reports that one branch out of four is not covered by tests.
you turned around T & I here, it should be declared as:  protected <T, I extends T> @Nullable I getService(Class<T> clazz, Class<I> implementationClass)
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
should this count be parameterized?
Pull this into a static final variable
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
Rather than extract body and headers from HttpComponentsClientHttpRequest, we should have a toRequestProducer on that class instead, which contains all this code together with createReactiveEntityProducer below, and which returns a BasicRequestProducer. That way, all we have to do here is invoke that method.
return this ?
If there's an overload the result should be (overload is noexcept) && (arg1 is noexcept) && (arg2 is noexcept).
If fOperator is op_throw, we need to return true :)
(overload is noexcept) && (argument is noexcept)
for readability, consider extracting it to a method..
It's better to return a message upon canDoAction failure, something like "Cannot ${action} ${type}, this operation is supported only for image disks"
This is done either way now, which looks logical. Just making sure not by mistake.
Why do you need "this." ?
I'd prefer using streams here
what guarantees getParameters().getNetworkId()) represents a real network ?
It would be nice to have these new methods unit tested. Also String#replaceFirst is calling Pattern.compile internally. Based on how often we're expected to call this method, wouldn't it make sense to pre-compile the pattern in private static final field of this class?
This value is absolute BS, should fix this tomorrow
Maybe do a null check.
And when isTryStatementResource is static, this one can be static as well.
@vilchik-elena what if parent is a parenthesised expression?
@ivandalbosco CheckUtils.parent(parent) would avoid the cast.
Because the length (the second parameter) is always null navigation did not work and Quick Outline was basically useless. I provided a simple fix in commit d90ea00390076f38d982d68df1adb37623698b2e which selects the entire first line of an element: <img width="680" alt="screen shot 2016-08-11 at 4 21 53 pm" src="<LINK_0>"> @ghillairet please review update my fix and update if needed.
null guard
I think that using the start of selection was just wrong. I would have no problem to use the caret position for this one too as part of the bug fix. Then the implementation could just be to call cursorPosition(false).
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
as this is not handled (it will always return null), I think it would be better to return a UnsupportedOperationException or to handle it (but it will take some time : db, rest mappings)
Why do we want to return it if we have methods to manage it. It seems like encapsulation issue.
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
suggestion } catch (CancellationException | InterruptedException | ExecutionException e) { this.isClosed = true; final Throwable t = e instanceof ExecutionException ? e.getCause() : e; throw new RuntimeException("Exception while writing records asynchronously", t);
Precondition to check page Offset is positive?
Wouldn't we want to unify these names and pick either onReady or onDataChanged? Other than that, LGTM!
Hmm now I see what happened here. Having init be protected and called by the super class definitely "smells" and makes me think we got something wrong. Seems like the problem is the circular reference between the adapter and the array, even though it goes through the SnapshotParser interface. Any thoughts on how we can make this better?
Using e.getLocalizedMessage() seems a bit dangerous here. Could we define some error messages in the library instead and choose between them based on the exception subclass?
should call tx.close() not tx.commit() I suppose this it where unit test w/ EasyMock would be good.. could verify that tx.close was called on a mock transaction
nice maybe try finally?
We need to close the reader here, right?
If we returned a proper object here, we could have a constant placeholder such as EmptyExpression or so.
unnecessary array new: {{true}, {false}} should work here
return collection ? to avoid to create array
This branch is not needed
I would argue it is ok if name is empty, so the contract can be loosened a little.
Nit: delegate to other methods to avoid duplicating logic: isDatasetUri(uriOrName) || isViewUri(uriOrName)
This method is used only in one place, so it could be removed, and the logic centralized here.
maybe it should be in a checkState as currently it would mean that there is a bug somewhere, no point of having parallel sort without a merge
Alternatively... java Properties properties = new Properties(); if (inputStream != null) { properties.load(inputStream); } return properties;
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Constructor can be package now.
Please remove the public modifier
Is there a reason not to import java.util.UUID? e.g a conflict with a similarly named class?
I'm not sure what exactly append here :wink:, but it seems to me possible to generate the same synthetic name both if we call this function two times in the same millisecond. Why not use an increment based on Context like with closure and decorators synthetic names?
How about removing the whole cluster deleteRecursively("/CLUSTER_NAME")?
I didn't know the string "null" would become an actual null!
Niche!
I think we probably want to assert on it not being there with any value.
do we really need to return true/false from this method? is the contract here that you should always call beginTracking() and then endTracking(), or do you only call endTracking() if beginTracking() returned true?
My understanding is a 'synchronized' block will be slower, but I cannot really say how much in case of AHC.
getDefaultTracker is called every time an event is reported. It is worth thinking about setting up the default tracker in a manner that doesn't require you to set the user id every time getDefaultTracker is called. Like if you setup that part of the tracker every time a new user logs in, you don't need to do it every time you call getDefaultTracker. That said, it might be a more complex implementation that isn't worth the effort. I'll leave it to you to decide.
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
Instead of sleep, what about replacing with CountDownLatch? We can unblock through the code rather than depending on the timing schedule.
30_000 sounds too long here. What if the shutdown method fail? Will it take 30 seconds to fail this particular test? I'd like this combination: Thread.sleep(5000) and islessThan(1000). If JVM can not interrupt the sleep thread within 1s, there must be something seriously wrong.
suggestion if (castSource.toLowerCase().startsWith(clobReturningFunctions[i])) {
in what situations will srcs have blank strings?
How about checking numberOfEntries != 0 instead?
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
Collections.unmodifiableSet()
Please extract this string
nice catch, I just recently wondered about our handling of singleTop
Minor nit: this can be shortened to if (multiSelect && Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2)
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 006 and 007 to break dependency from 001 and 002 to be successful
Would suggest using another MapID for 004 and 005 to break dependency from 001 and 002 to be successful
I didn't even realize that we have logic in otj-server that also copies conserved headers to responses, apart from what already happens in otj-conservedheaders. Would the be any way to consolidate this logic in one place?
again, this cannot be, there cannot be unconditional chaining... the nego should be able to stop the chaining, please see current implementation of nego.
Is "Resource not found" the correct response during a rejoin? If so I am OK with these changes so long as they work and pass tests.
Could you keep it as it were? Thx
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
You could just call the other ctor
should not be this private?
could be warn as @kuujo suggested?
The SSLContext should be exposed for configuration so users can set the keystore, truststore, protocol, etc. TLSUtils has some examples for doing that, used by SSLContextProvider for the internal HTTP client
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
nit: throw new RuntimeException(e); so if this ever happens (unlikely), the error will be more obvious in the test
If you really want the o option in the query string to work here you need to setup an @Option() annotation above to have it be parsed and passed to the GroupJson.
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
If you want to keep a StyledText, you may want to override org.eclipse.eef.ide.ui.api.widgets.AbstractEEFWidgetLifecycleManager.setLabelFontStyle() instead.
This code repeats in multiple places. Until we replace Slice, please keep the code in SliceUtil or another central place.
Add a method: inactiveBucket(Bucket<IN, BucketID>)?
I think we should use the bloom filter at the first get call.
it would be better to reuse:  <LINK_0>  to construct PagePosition iterator.
Are we sure of the impacts other than related to the PaginableAdapter?
Why not keeping "asc" as the object onto we call equals method?
I think you mean (d<=0)
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
Looking at the docs for Future, I think this should throw TimeoutException if !done.
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
suggestion @Override public void onSaveInstanceState(@NonNull Bundle outState) {  Can we move the @Override annotation to a separate line for code style consistency?
"isSearching" should be a class level string
It would be preferable for the PutHammer to keep putting data until the main test method has verified that rehash has completed instead of using a fixed-size loop
Did you mean to make it a constant?
should this count be parameterized?
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
Mmm actually I spoke too fast, it still fails on the command line...
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
enum is not the place for this. Move it to VoltDB
Are all recipes groups uppercase?
Tor - Should our default proguard-rules.txt be changed to have a .pro extension?
This method should be private unless there are plans to use it elsewhere.
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
I don't think consumer can be null since you already guard against that prior to calling getConsumerMetricValue(). The suppliers/lambdas are bound to the consumer param.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
Shouldn't this be set to true as daemon threads do not prevent the JVM from exiting when the program finishes.
I would extract "weld-workers" to a constant on the DaemonThreadFactory.
could just return null by default
If the fields are set to final, here you'll probably have to do } else { fEventList = null; } or fEventList = new ArrayList<>() for an empty list?
Do we need to wrap this in applyResults()?
The first if is superfluous. instanceof is always false for null, therefore a null value bypasses the instanceof checks and returns null from the end of the method already.
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
Our standard convention is to prefix with this for instance members - return this.context
this "return;" statement is of no use.
I think it is better to set the return value at the topmost level i.e. in executeQueryCommand() So I would suggest to remove this method, and rename executeCommand() to fetchAdvancedDetails(). And the code in executeQueryCommand() can look like: @Override protected void executeQueryCommand() { String volumeName = getParameters().getVolumeName(); if (StringUtils.isNotEmpty(volumeName)) { getQueryReturnValue().setReturnValue(fetchAdvancedDetails(volumeName)); } else { getQueryReturnValue().setReturnValue(getServiceInfo()); } } This also means that the methods getServiceInfo() and fetchAdvancedDetails() will return GlusterVolumeAdvancedDetails.
This is redundant, please remove.
uncessary call to super. No need to visit further.
I am really doubting about this call to super: What about something like :  return new Foo() { //some stuff closing };  The new ClassTree will be checked twice, once with the override of visitNewClass (via the call to super) and once with the checkUsageOfCloseable of the expression of the return statement.
Rather than using expression.toString(), I would prefer to use the more explicit ((LiteralTree) expression).value().
This line is still backwards. Please don't use "Yoda conditions".
Hi @ashrko619 What about For(List.range(startYear, endYear + 1), List.range(1, 13))? :)
Having a hard time following this, can we just make it "return dayFloor(dt.minusDays(dt.getDayOfWeek() -1)"? Sorry if I'm being dense, but I can't understand the reason for the withMonth/withDay/withYear code.
name should also be checked.
ha! this is a new construct for me. I thought that.id is a private field ...?
is this because of the inheritance?
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
Slight wording change - the "by searching" bit is unnecessary and also irks me because you never say what or where you were searching suggestion logger.log(Level.FINE, "Could not find an appropriate address, falling back to local host");
Probably best to make a copy of the clientConfig.attributes and wrap it in an immutable map so: 1) you are protected against accidental modification. And you don't need to make ad hoc wrappings. 2) if a user would make mutation on the client config after he has created the client, it will not lead to funky behavior.
this constructor feels wrong now... I think it should be a Module and a Definition and then the constructor calls getCombinedGrammar.
can you please factor this one step further and make a parseWithGrammar function that takes a CharSequence, a Grammar, and a start symbol? And then factor out the code which generates a grammar from a Definition. In particular, for performance reasons it is going to be necessary that the grammar only be computed once for multiple executions of krun.
Explain.
Just do this at the root of the database every time so you're sure nothing else is happening: mref.getRoot().removeValue()
checkState instead of checkArgument
Wouldn't it be a serious bug if m_activeSegment != null && m_segments.isEmpty()?
We'd want to use Collections.unmodifiableList() here also with null check
Better: '|'
Why don't you instantiate the builder here?
EndOfStreamException is never thrown in this method, as far as I can see.
This can be defined inside the try block.
Platform encoding again, on name.getBytes().
nit: you can do mLGNames = Sets.newHashSet();
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
This returns true if the code is not success and not one of the above errors. I would think the caller would expect an error to be returned if the error code was not success except for maybe the case where node already exists
Same as above, why not use try with resources?
Same as above, why not use try with resources?
Can be move into the try block.
this can also be .map
do add a null check for options before invoking the getter for ifMatch.
FYI: using a map here would have given us: .map(voidDigitalTwinsResponse -> null) Even though Mono<Void> is the same as an empty Mono -> Mono that doesn't return anything, I feel Mono.empty() is a better representation of the transformation we are doing here. However, I want to point out that the end result from both would still be the same.
You should see it from the side of the user, not of the implementation
this is potentially costly, depends on what asMap is doing. Maybe getIfPresent and check for not null result?
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
can't this be defined as a List<DiskImage> ?
any difference between this test and the previous one?
No.
The date string format should probably be a protected static constant. Also do we need the temporary variable? (This method is called many times a tick.)
Is not safer to use Locale.US instead of ENGLISH ?
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
>byte[] [](start = 11, length = 6) DecryptResult
In sync client, context is passed using an explicit "Context" argument. [This](<LINK_0> is a good example. Need that for all sync Client methods.
this can call the method on L290
Shouldn't isPolled be false irrespective of whether it is a poller partition or not?
The check for "windowId > windowDataManager.getLargestCompletedWindow()" in the next line is now redundant.
Why catch Throwable?
Is there a reason why the equals method is not fully implemented? It's returning false for separate object instances that contain the same description and value, but it should return true. Your IDE should be able to generate it for you.
Use Objects.equals() to handle nulls concisely.
Instead of this, check if the String values are equal.
instanceof
instanceof
I wouldn't static import these calls as the code loses readability with that -- setLong sounds like a setter in this class, but it's not, etc.
Files.write is deprecated. Please use Files.asCharSink: suggestion Files.asCharSink(toFile, Charsets.UTF_8).write(moduleInfoJson);
try (JarFile jarFile = new JarFile(srcFile)) {...}
(non-blocker) under the hood this does Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); for every jar file. Is it possible to simply have a static Matcher, or Pattern? Note that Matcher instances are not thread safe but Pattern is.
this variable assignment may be a 1-liner, but I don't insist.
This code is common for all is*Enabled() methods. You can extract this out to a method to reduce duplication.
Is this load operation necessary each time this method is called?
shouldn't be setDaemon(true)
add an import instead of using fully qualified name
Maybe it'd be useful to have a log message here saying that it was successfully stopped
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
Entity#getTags returns the original set. While I don't see any vanilla code that makes use of the fact that the backing set is mutable, mods very well might. It would be stupid for them to do so, but they might. Thankfully, there is a really easy way to sidestep this: make this method return a Collection<String>! While Java doesn't let you vary only by return type, no such restriction exists on the JVM. That way our method and the vanilla Set<String> getTags() method can co-exist peacefully.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
this can be private static because it doesn't depend on any member variables from what I can see.
Can be inlined in the assertThat statement below.
What do you think about: suggestion return Objects.requireNonNullElseGet(apiVersion, APIVersion::latest);
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
Uneeded String.valueOf() in arguments to String.format()
use ObjectUtil.checkNotNull(...)
What is the purpose of "jobId" when it's never used in the method? (also applies to the two following methods)
wrap this line (column limit 100)
Do you need an "and cr.deleted = false" type of statement as part of the "IN" clause? Maybe not but I can't tell just from thinking about it.
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
You can change the 28 case to a default case, and remove this.
Gson doesn't run on these versions so I don't see any reason to include them.
Gson doesn't run on these versions so I don't see any reason to include them.
Inconsistent Upper and Lower case in description
Unsigned types are not used in the current implementation. So, you can omit them.
Please move new instances to field's declaration. Change these 2 lines to clear.
please cleanup belongsToRangeValues. All class fields (except user defined properties) should be cleaned, to clear state completely for next file processing.
this.
nit: public static void But public here is irrelevant. Its only as visible as the inner class, which is package access. You can skip the public keyword.
SetLevel method isn't implemented,
same as above, skip public
No need for super()
calling super not needed
are these setters used anywhere?
I don't know, but isn't the class also of interest?
Why can't you just return value here?
Neater: String.valueOf(value);
Not sure if you wanted to leave this hardcoded?
@hugeox There are unused imports in this class and you are leaking resources IIUC.
[Java-8 try-with-resource](<LINK_0> try(PrintStream ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(outFileName, append)))) { ps.print(name); }
run already called tally, so do you need to call it again?
No extra synchronization needed here because rowCount is already AtomicLong. Unless the intent is to not let shouldStop, rowCount, isRunning get modified concurrently since you are guarding accesses to them by doing synchronizing on "this" .
If this fails, it doesn't mean that the SWTBotNatTable (that we are testing) is wrong, it means that the test setup is not correct for a particular graphical setup. If the font is really small, it could happen that the visible row count is equal to the preferred row count. So here I would just check that rowCount <= 32, and columnCount <=2. If we don't see 14 rows, I think it's better to let the other test (that reads row 14) fail.
The WFLY-1069 stuff should tie into this.
.split("[,]") and trim() to support multiple interfaces within single extension, please. return List<String>
Cant this be done using java Optional class?
You could seed the array with dataSize
Can be O(n), move fast exit up or remove, and set to 0. or some equivalent number. Maybe 1000, to avoid the initial resizes?
Not convinced, I think it belongs in setup as waiting for the analysis is setup: preparing the workspace for it to be in the expected state?
For loop?
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
nit: what about java nulls[i] = i % 7 == 0  ?
- This method shouldn't be public, instead make it default. - Add a space between method-name and braces.
- Will suggest not to apply Ctrl_BackSpace feature for Passwords Text field, instead return. For this include PASSWORD in above if condition: if ((style & SWT.READ_ONLY) != 0 || (style & SWT.PASSWORD) != 0)
- Use getText (0, getCaretPosition()) directly to get the task done in a single call.
Right, the transactionManager.shutdown() call is redundant with the if () block below.
If storageManager gets a value in constructor, then we don't need to check null.
doc
I think its better to rename the function deleteResultsByID to deleteResultsCollection. It should take Collection<AsyncQuery> as an argument. All of the iterator logic can be then moved to the function implementation. The reason being in our database interpretation we have to delete each row one by one but for a filesystem-based, we can delete multiple at the same time.
It's possible for this test to fail because of a 1ms gap between when this date is calculated and when the delete filter is generated. We'll need to find a less brittle approach.
This is too broad and is swallowing exceptions that need to be propagated.
was the system.out meant to be removed?
Assert.notNull() - just for fail fast, since we really don't support null for this property.
This is a bit too strong. You should perform the verification of the true and false expressions only if the type of the expression is Optional. With the current state, the following code will trigger an issue, and it has nothing to do with optional and is perfectly valid:  public Optional<String> bar(booleab b) { Object myObject = b ? null : new Object(); return Optional.empty(); }  With the following, it should work:  if (conditionalExpression.symbolType().is(OPTIONAL)) { checkNull(conditionalExpression.trueExpression()); checkNull(conditionalExpression.falseExpression()); }
We can shorten this condition: java (StringUtils.nonEmpty(value) && constraintType == null)  FQN for StringUtils is org.kie.workbench.common.stunner.core.util.StringUtils
This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item.
This should be public
Again, use IOUtils.
these should be 2 separate tests
Please use [IOUtils.toByteArray()](<LINK_0> from Apache Commons IO. You may have to adjust the file pom.xml, which I have not checked. (The same one more times two lines lower.)
Change this to PDataType.VARBINARY, as that's what the evaluate method returns.
This should return the PDataType for an element of the array
I missed this before, but you'll want to: - use PDataType.BINARY if the child expressions data type is fixed width, otherwise use PDataType.VARBINARY. - implement getByteSize() and getMaxLength() by having them return getExpression().getByteSize(). The PDataType.BINARY is for fixed width data, so the expression impl has to tell Phoenix what the fixed width is through those methods.
This implementation looks odd: Don't you want to check that obj is an instance of NotLoadedFragmentMatch? Here a list with the same elements will be equal to this object, it seems dangerous.
Same feedback as other classes. check equals(), equalTo() methods in the changeset
I still think that this implementation of equals, together with the implementation from the parent class (PluginData) is broken. For example, it is not transitive. Take the following 3 instances: ssd1 = SecureStoreData(name="a", version="b", pluginFile="c", className="d", storeName = "e") ssd2 = SecureStoreData(name="a", version="b", pluginFile="c", className="f", storeName = "g") pd = PluginData(name="a", version="b", pluginFile="c") then the following it true: ssd1.equals(pd) pd.equals(ssd2) which implies that the following must be true ssd1.equals(ssd2) but actually it is false.
This is a bug! The requested interceptor might not be in the list, so we should decrement only if true from remove().
This should simply invoke the new method.
I suggest to add an initialization in the declaration, instead of this if and the if in line 148: private List<HttpRequestInterceptor> requestInterceptorLis = new ArrayList<>();
This method recursively calls itself, which will result in stackoverflow. Is that ok?
please try to line wrap lines longer than 80 columns why not the more direct: ClassLoader parent = PluginLoader.class.getClassLoader(); new URLClassLoader(getPluginURLs(jarFile), parent)?
Why are we using reflection to make this? new URLClassLoader should work.
Can make this into a singleton as we have with UNSET.
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
we need hostName only to log error. Please call it there.
The above code is needed because you do this check here. There are more than one notification when we start or stop a vm. We need to be smart when to remove the client from the map.
What if client is null?
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
You need also to do configureConsumer(consumer)
You meant a consumer here I guess?
I see this method does something similar to execute minus the optional processing with the rowProcessor
Missing types
nitpick: e -> e.getKey() could be replaced by CacheEntry::getKey. the same for the change below. ps. not sure which one is more efficient.
although the runBllAction was introduced in earlier patch, i fill the sequence of this method is not clear: you perform runBllAction() and somehow the current command status is updated. I think referring the return value of the command here will be clearer to understand.
I see that one method above you check instancof ArrayList. Is it ok that you check here instanceof Collection?
Initialize advancedDetails too?
I think we probably want to validate that userAgent is a valid form
The existing code works with null options (as we can see from inspecting UserAgent#getAgent), but this will throw an NPE if there is no currentRequest. Should we pass null here if currentRequest is null to preserve existing behavior?
I'd be tempted to go with return currentRequest == null ? userAgent : UserAgent.getAgent(currentRequest.getClientCapabilities(), userAgent); or the equivalent "if"
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
1. Not sure if its ok to error on failure to get engine time stamp. 2. Failure to touch base with engine might essentially mean that the subsequent commands also fail and there's no use of asking for user intervention or things of that nature and somehow attempting to proceed with normal flow of snapshot creation. 3. Given 1 and 2 I still feel handling the failure manually in code is better atleast in order to close any other previous window(ex: snapshot create window) Let me know what you opine
Just curious: why checking 'isClosed' ? Can't we call 'close' multiple times?
What about giving a meaningful name to the thread and making it a daemon thread?
This shouldn't be needed as StatementClient.close() should be idempotent
Erm, well there's no need to map launcher to itself suggestion return model.getLauncher();
CheckForNull
I prefer ", not "+(l == null ? null : l.getClass()));
Should be static
use getDiskVmElementDao(), please apply to all the dao calls in that class
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
Very nitpicky, I'm not sure if we gain much by verifying the parameters of this test, we could make this more flexible by just asserting that any arg is passed to connect blocking.
You switched the order of cores and read replicas here.
Define a constant variable and use it.
This is not enough. Look at the method DecoratorAdapterFactory#dispose(). You have to iterate on the values of the map and dispose them propery
I think you should dispose the ShapeRenderer here.
I would call super.dispose() at the very end of this method.
new ArrayList<>()
Local variable is not necessary. Instead, here we can just do: return true;
Any reason to use newHashSet rather than new HashSet<>? Alternatively, would one of the Guava Collections methods do this job for us?
!droplets.isEmpty()?
!keys.isEmpty()?
!sizes.isEmpty()?
you need to * actually verify the data * assert that the source file is stil there
Not that it matters but it would be "sourceFile"
why change the readability status here?
you set the prestarted to zero so VMs won't be start again after stopping them right? so you need to lock the pool because stopping the VMs might take some time and the user can update the prestarted VMs count in the meantime
although I don't like it, I think we should lock the template in the database so there will be an indication in the UI for the ongoing operation. I would prefer to use a mechanism as we now have for VMs to expose in-memory exclusive locks for the UI instead though
don't we want to remove the place holder in case of failure?
Simpler: ArrayList<T> result = new ArrayList<>(collection);
If response contains result (which it should contain) then you are creating new HashMap instance for no reason. Wouldn't following code be better: Map<String, List<String>> namespacesMap = (Map<String, List<String>>) SSOOAuthServiceUtils.getAvailableNamespaces( getSessionDataContainer().getSsoAccessToken(getParameters().getSessionId())).get("result); if (namespacesMap != null) { namespacesMap = (Map<String, List<String>>) response.get("result"); for (List<String> entry : namespacesMap.values()) { Collections.sort(entry); } } else { namespaceMap = new HashMap<>(); } setReturnValue(namespacesMap); Also if namespaceMap is read only, then even better would be to use Collections.emptyMap();
Better to return Query<?> than to let shenanigans like this get past the compiler:  Type type = int.class; String result = handle.createQuery("...").mapTo(type).findOnly();
Please implement equals() method either. This will remove the potential problem when working with collections.
The monitors list was added to the hash code here, but not for BasicTimer. I don't think it will change the result in this case, but any reason it isn't consistent for both?
Objects.hash()
A create card payment request should always have a return URL, so I don't think this should return an optional
Let's just make this @Nullable instead of using Optional
Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having extension, dateformat, and frequencyOverride be Optional<>s (in both their member variable types and their getter types). Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty Optional<> in the resulting Java object.
This should have an ensureProperFile(false) at the beginning...and actually all read methods, even non-absolute ones need that in case they are called when the current file is at EOF.
Why that read() has to be under lock? We only need to protect usage of the "position" field (or even make it atomic instead) and let actual read() / write() concurrency to be taken care of by underlying FileChannel.
Should this return 0 or -1?
These empty implementations can be removed I guess
I think we don't use 'final' in this place anymore.
hook != null ? hook : PostReceiveHook.NULL
The synchronized block should include stopThread = true and close.notify() before thread.interrupt.
Is threads.isEmpty() necessary ? I think the foreach loop can handle the same case.
with break statement here the process will get outside of the "for" loop after the first round. So only one element of threadList will be considered...
Don't manually track the cancelled state for cancellable events - fire(event) does that for you.
The call to super dispose should probably be at the end.
This class has no superclass, so I'm not sure we need to call super() here.
Which exception do you ignore here? Is it DuplicatedStorageException ?
Is there any problem if an exception is launched here?
nit: I'd suggest including a SafeArg indicating what the value of storagePath is
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
magic number
Some of the strings used in here are constants, some are just local variables in the methods themselves. Is this OK? Should we have all the strings as constants?
delete
java return (bundle.getState() & (Bundle.INSTALLED | Bundle.UNINSTALLED)) != 0;
CopyOnWriteArrayList would be a better alternative as it provides optimized functionality for thread-safety and good for maintaining list of listeners that will be updated occasionally
fmt (there should be   after ...)
Entity#getTags returns the original set. While I don't see any vanilla code that makes use of the fact that the backing set is mutable, mods very well might. It would be stupid for them to do so, but they might. Thankfully, there is a really easy way to sidestep this: make this method return a Collection<String>! While Java doesn't let you vary only by return type, no such restriction exists on the JVM. That way our method and the vanilla Set<String> getTags() method can co-exist peacefully.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
I don't think we use final for functions in our code base
Possible NPE if the interface doesn't exist.
how about adding constraint for assuring networkName isn't null ?
Is this supposed to be <code>return "Bump"</code>?
finish() is called in case of an exception but the callback.close() is also included in the finally clauses of the top level methods. This leads to closing a callback() twice which is probably not intended.
Always called with (null, null) - so method and URI is never taken into account?
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
Why negated? couldn't you just flip the branches?
"camelize"... that's flowerly...
Is this still required? Seems like we might want to prefer exploding instead suggestion this.packageName = Objects.requireNonNull(packageName, "packageName == null")
These line is proof you don't need QuotaConsumptionParametersWrapper
if missing storagePool, the flow has errors. return false?
I'd fold this up to the previous line
Maybe more informative like so:  "Unable to get build host, skipping " + BUILD_HOST + " value..."  ?
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
Could have @VisibleForTesting annotation. Also could public be removed?
Should the name of the thread be maxwell-kafka-producer-worker instead?
Consider replacing these similar constructors with a Builder. It can make the client API easier to use. Also note that making constructors public can make future deprecation or removable very difficult. Something like:  java /** * Use a single private constructor. */ private FStatelessNatsServer(Connection conn, FProcessor processor, FProtocolFactory protoFactory, String subject, String queue, int workerCount, int queueLength) { // set up instance } ... public static class Builder { // settings for instance to build private final String queue; public Builder(Connection conn, FProcessor p, FProtocolFactory proto) { // this.blah = blah } public Builder withQueue(String queue) { this.queue = queue; return this; } public FStatelessNatsServer build() { // call private instance constructor return new FStatelessNatsServer(...); } }  Then the client has a fluent interface:  java FStatelessNatsServer server = FStatelessNatsServer.Builder(connection, processor, protoFactory) .withSubject("my-subject") .withQueueGroup("new-group") .build();
Could just do new CleanupThread(..).start() here
I see this method does something similar to execute minus the optional processing with the rowProcessor
Maybe clearer to use AND and no NOT.
Seems like you should use some filter-converter to drop the values before going over the wire.
Should we use pushInlineDeployments here ?
why not use @Inject ?
Are we assuming that there will be exactly one instance of GrillService within the server? if not we should add instance id to file name
remove tabs
This seems to be causing NPEs on shutdown for me.
GuidingFeedbackEditor. I guess writing it out probably wouldn't hurt.
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
A new ArcGISScene already has a Surface, so you can just add the new elevation source to the existing surface.
can be assigned inline in class member definition
Please String.format() this.
CoreUtilities.noDebugContext
Why don't you use String.format?
toString() formatting.
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
If this is called before recomputeDigest(), we will get a different description string than the original implementation. Is that you want?
null checks on key and state are redundand
We decided to use Objects.isNull
Consider Objects.hashCode(object) instead of the ternary (but only consider, do not consider this a normative statement).
parentheses please ;) return (number == null ? null : Long.valueOf(number.longValue()));
I definitely understand your thinking here. However, we want to match the errors returned by Redis, which is why we are returning the not integer error. We had to use a Java long here instead of an integer because the integer's storage capacity was not large enough, according to the Redis [INCR docs](<LINK_0> the string stored at the key is interpreted as a base-10 64 bit signed integer.
use 'L'
Nit please alphabetise.
it would be nice to catch runtime and rethrow them as is instead wrapping in them in another runtime.
I think you can simplify this method via replacing  public WorkspaceEdit organizeImports(String path) { return doGetOne(Commands.ORGANIZE_IMPORTS_COMMAND, prefixURI(path), WorkspaceEdit.class); }
For consistency, I would also make it so passing -1 results in a nullValue
Why are we doing double math here? This should be: return Math.max(1L, nano / 1000L);
This is not valid when not aligned.
We cannot just delete package name from each class. It's required to test that a check supports fully-qualified names. In this exact case probably it's better to move this class to new line
Can be replaced by X.hasCause(): not 100% precise, but will work for this very situation.
Same with using Log.x().
Why is this call needed for getting the skill level? Isn't the team's skill level stored already so the calculation isn't necessary?
The print mentions fortune, but this would still be called for all enchantments.
getLable.setHeaderLevel(headerLevel) then
Maybe check if batch update exception has nested SQLTransientConnectionException?
I am thinking if we can move this to caller method and use separate metrics for AccountService and AccountStatsReport. Thus, we have a clear view that how may QPS from AccountService, how many from Account Stats/ Quota Service.
It might suffice to check if e instanceof SQLTransientConnectionException as above. Are there cases that wouldn't handle?
Suggest throw new RE(e, "Unable to get scaling status from [%s]", coordinator)
styling: needs space between if and (, it has to have the same space on the left of the condition than on the right (before the {
Was this detected by findbugs?
Why would you not start with "BigInteger value = BigInteger.valueOf(0);", and leave out the null check inside the for loop? If this is because null should be returned for an empty bitStringValue, that maybe should come first.
Not related to the specific change in this PR, but shouldn't this do something like:  java return new BigInteger(value);  So the value doesn't have to fit within a Long?
You could use BigInteger.ONE instead.
This doesn't look thread-safe.
This doesn't seem quite right. If the logger.setUseParentHandlers(true) is set elsewhere this could override it.
Could you change your code so that super.getHandler() is called only once?
style: unnecessary blank line
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
pageStore is final.. it will never be null
synchronized is harmless but superfluous here
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
most -> must
This means that get method tests use the test subject's own get method to generate reference data. Should pull the user directly via Hibernate (sessionFactory) instead
return authentication.getUser(username);
you can refactor this in a different patch to make less noise
Should allowedValues be considered for object equality?
please format
please add brackets to all of these ifs
Changing the region should also invalidate the client like above.
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
Nit: For defensive programming, I would prefer String.stripToNull(region); Please update for similar invocations.
_verify
_verify
Can you add an additional assertion about the response message
createElementNS(...)?
Why are we declaring strings of white space characters to be the same as requesting the default pool?
Missing finals for all tests in this file
Please use here also java Objects.requireNonNull(partialFunction, "partialFunction is null"); return filter(partialFunction::isDefinedAt).map(partialFunction::apply);  (Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).
No lambda param type needed, we use the simple form result -> ...
Does a type-hint work instead of casting? return ofAll(toList().<U> zipWith(that, mapper)); (Probably not, just a question.)
Please replace all the occurrences of AbstractTree.this. Indeed, the code style we are using does not recommend to add this as a prefix of a function call when the function is in the current object.
it's a bug, we should throw UnsupportedOperationException when a method is not implemented, please fix it
This must be implemented.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Let's log the retry count aswell
Missing opening "(" before getDescription().
Would a reset or init method on reader help?
Wouldn't it be a serious bug if m_activeSegment != null && m_segments.isEmpty()?
Identification of the PBD hitting the error might be useful for troubleshooting.
@exper0 no need for the extra indentation here
ImmutableList.copyOf() creates an independant copy, whereas Collections.unmodifiableCollection() returns a wrapper on a collection which itself may be modified later.
This is backwards, you want the expected condition to be here.
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
If this is not used you might want to throw an UnsupportedOperationException
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
we should validate (and the feature support check) it in the validate() method.
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
it would be better not to set succeeded to true before flow is over, for example in an error will happen inside endVmCommand() the command might still finish as succeeded. please set the succeeded only at the end
why is this return null??
This assignment is redundant.
Do you really need the word fake here? I'm imagining other cases where it could be useful?
Please change to externalSearch =
suggestion return getInstance();
I propose we have accessors getBaseUrl() getRelativeUrl getAbsoluteUrl(). The toString() should call getAbsoluteUrl because that is the most complete representation of the object.
I don't think it is right to return always return true for two different AuthorizationContext instances.
Why U don't want to consider id in equals and hashCode ?
Is there a reason why the equals method is not fully implemented? It's returning false for separate object instances that contain the same description and value, but it should return true. Your IDE should be able to generate it for you.
logging here is redundant, since we throw the exception
I'm not understanding the logic here. If isHTTPSForwardedProtoResolver returns true, why would we want SecureForwardedProtoAwareResolver to return false?
this should go to login I think... 1. redirect to external 2. apache takes over 3. user press escape 4. we reach here 5. we should present login and not redirect to 1 and loop
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
Now the commit action is not enabled when I select a non-project resource. The method getRepositories does only work for projects.
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
I think the test on the parent should be improved. The code example on the [ticket](<LINK_0> itself still exhibits a FP because the parent of the compound assignment is a return statement.
@m-g-sonar I would move isMethodInvocation(tree.body()) inside isUsingLambdaParamAsArg method because right now the cast to MethodInvocationTree happens inside isUsingLambdaParamAsArg which makes the rule a little unclear.
I am not quite sure whether we still have race condition here. abortCheckpointOnBarrier might be called from CheckpointBarrierUnaligner after triggering checkpoint into mailbox. After aborting, we did not remove the checkpoint action from mailbox, so the checkpoint might still happen afterwards. So how to guarantee that #getAndRemoveWriteResult would never be called after aborting?
nit: usually we add task name to front, also it would be nice to use %d > %d for the comparison values.
It's correct but it might be easier to do  cancelledId > currentCheckpointId || (currentCheckpointId == cancelledId && numBarriersReceived > 0)  So either it's a future checkpoint, or it's the current checkpoint and not yet canceled.
static (same for isMap).
Please run build with sourcecheck profile
'map' name may be problematic. e.g. following line results in an error : a = load 'a.txt' as (map : [chararray]);
Please use Yoda DateTime.now().getMillis() for a timestamp
you should log method name: openTOCPage, not "openTOC"
one again, some sort of URLsContent Class
final missing. Same for the other ones.
does this need to catch all exceptions?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
I think it would be good to allow the old behavior (assign to ALL). we can use 0 or -1 to indicate that
FYI, i have confirmed this equation is correct.
This method should be static and need not pass this as an argument to the constructor.
This should return a builder with the current options set.
In general, not a good idea to pass a mutable map around. ImmutableMap.copOf()?
I ask myself if SUBSIZED can be omitted here because there is at most one element in a single-valued type. It cannot be splitted anymore. But wait... Java 9 added Optional.stream(). I will ask jshell: java jshell> Optional.of(1).stream().spliterator().characteristics() & Spliterator.SUBSIZED $3 ==> 16384  Ok, we need SUBSIZED :)
This method should be private.
assertion .isTrue() missing
This is very fragile, and will break when we add new storage type. Better check for the storage types (block or file?). Also, this change is possible only when creating volumes with vdsm supporting deferred preallocation, or it may cause very bad performance regression when creating big raw images. This is probably not the place to do these checks, we probably need to modify the code creating new volumes, or the code creating and copying volumes.
why you not using performCreation()?, i can't see anything special in performCreationMultiple(), note performCreation() has blocking caps.
replace the "new' with createVolumeValidator() Thanks!
also here. if true.remove(element) returns the same instance, we may test with == instead of size and length
This is more obvious code, thank you
why not list.stream().forEach?
since there is an exception being thrown, there is no need to log an error. Otherwise, there will be double logging.
Why cast dataSize to int? Not possible to be long?
These usages of IllegalArgumentException and DataCorruptExchange make sense to me. As stated before, could also imagine using an "InvalidDataException" in lieu of IllegalArgumentException here. I dislike the re-use of "DataCorruptException" in the catch (Exception e) clause. I'd prefer a more vague "DeserializationException" or some such. I'd also like the caught exception to be used in construction of re-thrown exception so cause-chain is clear. Actually, comparing deserializeBlobProperties with deserializeDeleteRecord, the exception pattern is differnt. deserializeBlobProperties has an outer try/catch re-throw that seems unnecessary and that converts inner exceptions that are (re)thrown to DataCorruptExceptions. I like logger.error messaging before (re)throwing. Any way of making this automagic? I dislike having two distinct strings in this code, one for the logger and one for the exception and prefer a single string. I cannot think of any clean way of mkaing this a one liner though. Adding a logException method to each class that logs an error than throws is awkward. Adding the logger to the exception's constructor also seems awkward. Maybe we just code review for consistent usage. Once we decide on a pattern for logging and (re)throwing exceptions, we just need to use it consistently.
should have a space before null.
space after =
better to have fail(); in the onSuccess()?
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
This method looks horrible to me (and to whoever is a sane engineer, I should think).
braces
suggestion
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
simplify: return ...
why not peek()?
The if-condition is now a bit hard to read, these conditions could broken down and refactored into helper functions to improve readability.
@ivandalbosco super minor: no space before !isDocStringsAndNotImplementedError(node)
remove this
Do we really want to create a new client each and every time we call getClient? should we cache this into some sort of singleton, or alternative?
Collections.emptyMap()?
Same here. Get files with fileNameFilter and if it returns non-empty array, throw exception.
What do you think of using one of the filtered version of listFiles() rather than getting all the files in the directory? For example, using with FilenameFilter: <LINK_0>
Would file.getName().endsWith(".java") work OK? And I guess if the case is a concern, maybe file.getName().toLowercase().endsWith(.java).
My expectation here is by the time the code is JITted the JVM will be able to predict ConverterHolder#getBestConverter() is both monomorphic and returns the same value for every invocation. There will be a bit of extra code to typecheck and branch (and de-opt) if the prediction fails, but I believe the branches will have the right prediction hints. The generated code will have the same performance characteristics as previous. If this is a concern, a jmh-based microbenchmark could confirm.
shouldn't you do a defensive copy?
We need to check offset + length <= arr.length?
The this. in getters are unnecessary too.
Should make a differentiation of the name and id.
If you have a translation use that if possible.
my understanding of the initial interface was that this method was for returning the token-stored-on-disk, if any but in general, I don't think you need locking here.
We do the exact same thing twice? Why?
modelVar can be renamed to model
can't you just return null ?
You can just put the whole trigger text here instead of calling the super, it'll keep you from having to use setText on the token effect
style nit: we don't use braces around single line blocks
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
Should it really return null here?
Lets not catch the exception and just let the original exception propagate unto main.
Possible to log only one debug line here?
Drop this empty block.
please decrease to TRACE
isUnauthorized 403
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
Above I had asked about whether we need to validate at least one answer is provided. Could we better describe this use case where we can search licenses *without* giving any answers? Is this to lookup the types of answers allowed? If so, we should enhance this test to check the response includes info on the types of answers alllowed.
@idelcano I think that OrgUnit Preference should be remove only for myanmar but not for Lao and Cambodia
You should rather directly go the way to Settings.getGcCredentials() (perhaps first checking with Settings.hasGcCredentials()) instead of this more complicated and harder to understand way through the preference.
Delete this.
I'm a bit confused by this test and shouldFailWitNoSchema test, especially the following part: java AvroItemWriter<PlainOldUser> avroItemWriter = new AvroItemWriter<>(output, plainOldUserSchemaResource,PlainOldUser.class); avroItemWriter.setEmbedHeader(false);  Why should I provide a Schema if I can set embedHeader to false? For the reader, we can read PlainOldUsers from an avro file not containing a schema without providing a schema. In the same way, we should be able to write PlainOldUsers to an avro file without embedding any schema. In that case, why is the schema mandatory? To be specific, having a mandatory schema and an option to not embed it is confusing to me.
The start method repeats this code, wouldn't it be possible to call the log method from within the start method? (Like log("SCRUMBLEDORE LOGGING FILE");) <organisation
This should not call log.error(t). It should return ExceptionUtil.getStrackTrace(t);
else if?
Why not throw an exception here if we didn't get the right cache?
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
What happens if saving to a file fails? Memory will have been updated making it work for now and upon restart, the system wouldn't work anymore ...
I'm surprised that getRequestParameter does not return an Optional :)
take advantage of flatmap to avoid calling isPresent and get
Why do we return the parents name instead of the name we store a few lines above?
{ }
possible exception
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
huh? please inject a TimeSource that enables you to simulate time - that sleep needs to go
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
we at least need to trim user provided string before trying to figure out what is inside of it
maxDetail won't be null, so you can just do: maxDetailLength = config.getInt("max-detail-length", 0);
Not all announcement activity is public. I think there might need to be a separate manager method to have the right permissions. There are specially written queries in one of the DAOs to get only appropriate announcement activity because it was a pain. Anonymous users should be able to see activity for public announcements and logged-in users should be able to see all announcement activity.
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
Hii @ribhavsharma, this extra brace over here is causing the build to fail, kindly correct it :)
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
How is this going to work if there are multiple test classes using this and they are run in parallel?
different value 50 versus 1. Is that intended?
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
{}
This will now recursively process all subdirectories from services. Is this intended? You may just call internalProcessConfigFile here to restore the original behaviour.
"Modifier 'private' is redundant for enum constructors"
Can you call CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, symbol) instead?
super() is not necessary
@CTI777 this is ok.. because it is private.. we shouldn't expose IdentityLinks in our APIs, so no action needed.. just for you to know
@CTI777 we need to change this.. here you are an admin already.. so you can do it even if the task is not assigned to the admin.
IMO, there is no need to catch this exception here to rethrow it with a different message. What do you think?
Adding this to a field is good manner.
Adding this to a field is good manner.
I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on. However, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.
Why public?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
no need for concurrent
This is easier to read as: return type.getClass().isArray() || isList(type);
You probably could reduce it to return type.isPrimitive() || Number.class.isAssignableFrom(type) || Boolean.class.isAssignableFrom(type) || Char.class.isAssignableFrom(type)); (PrimitiveTypes is not really needed in this case).
Isn't this just type instanceof Class<?> && ((Class<?>) type).isPrimitive()?
duplicate assert
beware that prefixing integers with 0 usually means that the number is base 8 -- ie an octal.
Why postSetUp isn't called from applyInlineDeployments, especially here as postSetUp belongs to super class
consider changing "alt text" to "link text" in the markup, since "alt text" could easily be confused with HTML "alt" attribute.
as with bold, better to assert html.contains("<p>normal <i> italic text</i> normal</p>") since it's more obvious what we're looking for and whitespace behaviour is included in assert
should reverse order as follows: assertEquals("",html)
Are we sure WDateField is the only input element which has a div wrapper? It may be safer to limit in some other way too - such as a check on the outer element's class attribute containing wc-datefield. I am pretty sure a WDateField in a readOnly state is wrapped in a time element and a WPartialDateField in read-only state is wrapped in a span element (the div for editable WDateField is only necessary because of the need for a calendar in the polyfill). Therefore this will fail if trying to get the component in a read-only state and the other input extensions do allow getting read-only components.
capturePageScreenshot is more appropriate - capturePage could have a lot of different meanings
While the method looks like a generic one fetching value of a given tag, the variable "hostName" sounds too specific, as if the tagName will always be HOST_NAME. So you can either change the method prototype to not take a tagName argument at all, or change the variable name to something more generic, say "nodes"
OperandTypes.VARIADIC indicates a parameter list with varying length. But it looks like JSON_TYPE is designed for processing a single input value. Is OperandTypes.ANY enough for that?
Could it be better to make the precision bigger? For instance, you can use the VARCHAR_2000: <LINK_0>
It seems like this would be more appropriately placed in the NUMERIC category.
We have special constant for Maven PType ID: <LINK_0>
We have special constant for Maven PType ID: <LINK_0>
log the project name as well.
This also seems kinda pointless and a bit brittle. Just return resource.
you can either remove else or add pair of curly brackets
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Objects.hashCode could have been used here
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
Where did 31 come from? Why not use *=?
I think this should be stripe_account_id ? as per PP-4302
Why do we want to return it if we have methods to manage it. It seems like encapsulation issue.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
replace with ReferenceCountUtil.release(msg)
do we need to unvoid..?
final
isn't it always 1 or 2 arguments?
Same here, I think this should be limited to 1 or 2 arguments
This can be removed.
...the sysfs ~~; message~~ : {}
This method gets called if you press the ESC key or click the [X] widget. Then it closes the dialog even if you have pending changes to the model.
Can you add the exception as the second parameter? Otherwise we won't be able to tell where the error happened from just the message.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
this.
Why are we configuring drawer in this activity. This activity shouldn't have it.
suggestion ((WordPress) requireActivity().getApplication()).component().inject(this);  This getActivity() can be requireActivity().
Not required
Isn't it more readable to use "isNotEmpty()" instead of "!isEmpty()"?
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
You can remove this line, this will be done automatically if the user saves the changes.
latest from today's discussion: return URL
This should return a URL
if you're gonna rebase this patch, please consider dropping those this. prefixes from getters.
Did you mean to remove this println?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Typically we use Map on the left hand side rather than HashMap
this("Safety Command")
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
getSelectedPattern().getCommand() ?
please update - should we keep this or format to remove ====
is there a race condition? since runParagraph is a loop, what if we abort para 1 but there threadpool thread runs para 2?
I wonder how we enforce note authorization values here, for example someone without owner/write privileges does a call via rest api.
Any idea what this wait is for?
should be in separate PR i think
Let's import StaleElementReferenceException and use it directly without its fully qualified name
install button was not visible\* :dancer:
This can be a class variable instead, using the @FindBy annotation; especially since this same element is used in another method.
add wait condition for shell
It feels like this logic should be refactored into a utility function since we have multiple copies of it. I generally also prefer to wrap compound clauses in parentheses to clarify that the second & third components are paired:  java if(ignoreHiddenFiles && (System.getProperty("os.name").contains("Windows") && Files.readAttributes(dir, DosFileAttributes.class).isHidden())){
private static long Sorry, missed that one.
This doesn't really need to be in an else clause. It might be more readable to invert the logic of this block, i.e.: if (e != null) { throw e; } Files.delete(dir); return FileVisitResult.CONTINUE;
No, no. Remove this logic (that checks whether the provider exists).
Use NewOperatorEntity.class
This is too complicated...
add this (also below)
This is nice to see. We should have done this to begin with.
Great catch! Instead of maintaining another Set could you just check processToContainer.values().containsKey(container.getId())? That guarantees that we're always in sync with what startExecutor has started, since it updates processToContainer.
This might throw exception
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
I'm missing the new field in the toString method.
You could do a contains here like you do with the ACCEPTED_ENTRY_PIDS.
s/B/b/
This test would be useless if the map had been initialized in the class.
how does a MockHelixPropertyStore know that it for a certain path?
Optional: Can we use Try-with-resource here
1. Is the writer required if we use SamzaObjectMapper? What happens if we use SamzaObjectMapper directly? 2. Can we save the ObjectWriter as a static field?
Deleted @NotImplemented return getCellTypeEnum().getCode();
Types shall be created via builders. All the other public constructors are already deprecated. Could you please leave it package protected and use the builders in the caller side?
I think switch-case is a more appropriate/readable construct for such things.
I think we should try to be in the case where we have violations. Otherwise, it's difficult to see if anything is working at all.
I think it's safe just to call iterator.next, because we know that the violation is exist.
Have you checked if IterableAssert could be sufficient as a base class? It would avoid this conversion.
We need to synchronize this with #322 @simon04 can you keep track of this change in you PR, depending on what we merge first.
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
Add a single quote around the metadataAlias?
Should you attempt Path.toFile() here?
This is probably giving you a raw-type generics warning. Suggest replacing Class with Class<? extends InputKind>. This will create some ripple effects though that might be a little tricky... Since this is SDK-internal for now, I'll leave it to you whether you annotate this type fully.
Note that our code style is to final variables where possible...could you please add those where necessary?
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
java Objects.requireNonNull(runnable, "runnable is null");
Better: '|'
Could you keep it as it were? Thx
Why don't you instantiate the builder here?
May be its safer to assert that it exists before and then assert that is doesn't after delete.
I would extract "weld-workers" to a constant on the DaemonThreadFactory.
Could you give the thread a name? It makes it easier to identify it in a thread dump
Use saveDetails() instead of multiple addDetail() so that it is transaction consistent
I suspect this isn't dealing with the ErrorHandler in the usual way? The org.hibernate.search.exception.ErrorContext is able to highlight a single failure our of a group, where the group usually was meant to be "all operations from the current transaction". It's probably not easy to apply the ErrorHandler in the usual way as it normally would handle a failure as something like "out of operations [A, B, C] we failed on B " somehow suggesting that C wasn't executed. In this case the various operations might have been applied out of order so you should collect all success/fail operations to forge a new kind of error state.
Seems better to use AUTO_SEND_TAG?
Actually _all_ components have a distributable flag, so you shouldn't filter on analyzers here.
BTW class cast to Job should not be required here
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
You can safely remove the file.exists()(implicitly done by isFile
This should be part of the try-with-resources block.
StandardCharsets.UTF_8
The theory behind CompositeName is that each segment is meant to represent a name within a namespace, so it's supposed to be able to support having a single segment that is a name-within-a-schema (e.g. "foo/bar/baz") which is used to navigate to a single naming store. That said, I will extrapolate that this change means that the naming server is not coping with parsing a name out of a CompositeName component, which is definitely a bug, but one that we can't really grapple with because legacy servers will always have this bug. So, I think the solution should be to introduce a new method, e.g. toDecomposedCompositeName or something like that, which creates a CompositeName where each name segment is equal to the name segment in the source name. Connecting to (at minimum) the legacy server should always use this method of conversion, while we still maintain the method which converts a Name to a single-element CompositeName as before. WDYT?
I think this won't work right because the name might be a compound name using a different scheme than the CompositeName parser can support. I think the source name components have to be added one by one to the composite name to function correctly for name types that work differently than SimpleName (i.e. maybe right-to-left or using a non-slash separator).
What about a function which is defined inside another function? What would be its fully qualified name?
This should incorporate the standard clock skew accommodation: <LINK_0>
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
Could this and the next logger statement be reduced to debug?
Get the service registration reference and unregister within the deactivate method
It doesn't feel right. Why it is required?
Fully-qualified class name not needed.
SA == SERVICE_ACCOUNT? avoid abbreviations
google style is to not use final on local variables unless it's required
We'd better not fail here and just return null.
what happens if one passes SHA1 here?
I think you could use MorePredicates.transformingPredicate(TermporalField.toValueFunction(), IS_PRIMARY_IMAGE) here.
Could you put the code that's a duplicate of lines 721-728 (setting the callback) in a method, and call that method from both locations? I could see having the duplicate code causing headaches down the road, of someone changing the code in lines 721-728 and then trying to figure out why the behavior isn't changing.
nit-pick: No good reason to check if view is already GONE, as there is no harm in setting it to GONE when it's already GONE.
FIXME: Don't cast getActivity(), use an interface.
i18n too
What does it mean when we return null?
Not a big deal but we have a custom implementation for the toString: <LINK_0>
Cache the call here and above.
What is your reasoning behind automatically signalling that the output is ready? I don't want to accumulate a lot of unused files in the signal directory. Does it make sense to add a configuration option to signal the output when it is completed?
Check first that target is not null.
If we do not write options unconditionally, we will not validate them on the server-side. Consider a user who submits IndexConfig{type=HASH, bitmapOptions=<not null object>}. This is an invalid config, but how do we know what was his real intention - to create a hash index or a bitmap index? I would rather read/write the object as is, and throw an exception on invalid config, rather than ignoring invalid state silently.
To be safe you should read the bytes before assigning into data: byte[] d = new byte[len]; IO.readFully(in, d, 0, len); data = d;
Might affect the performance if we would do frequent DNS requests here. Not sure how frequent they are in fact.
A defensive copy of the list would be safer IMO
Is there reason behind how you access this wrt to property or accessor function? Perhaps we should change all these uses to getters/setters?
Use Constants.TAG
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
You can change the 28 case to a default case, and remove this.
Gson doesn't run on these versions so I don't see any reason to include them.
It might make sense to have this support the usual search using PaginationFilter.parse, but I'm indifferent.
This will default to returning HTTP 500 (Internal Server Error). Include Status.BAD_REQUEST as second constructor parameter to return HTTP 400 instead
return Platform.getOS().equals(Platform.WS_WIN32)
Can you reduce the nesting depth here?
I would log warn here and not rethrow unchecked exception, especially since closed will never be executed (could be wrapped in finally block).
this line should be followed by: java fail("Should throw exception");  like we don't expect that sendAndAssert to actually work, right?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
I'd say if the entry is present, the command is not successful.
Shouldn't this return true?
I think we can use a pooled bytebuf
does this bytebuffer potentially need to be released as well?
Use buffer.remaining() when allocating the copy buffer. Set bb.position(0) and don't touch bb.limit().
change message and status code
please use short names as apRequest
The TypeLiteral is unnecessary use a simple List
Should return type CorsConfigurer<HttpSecurity>
Would Collections.unmodifiableList(submodels) be better in this case?
Shouldn't you pass something like the size of the list? checkQueue assumes you are going to add 1 item. I mean something like checkQueue(tasks.size())
Add check on null
Should be updated to use getSupportActionBar() instead of getActionBar() as in the [guidelines](<LINK_0> to ensure backwards compatibility.
Don't inflate it. Use the same paradigm as ListViewInitializer where the layout must include the View for the empty view.
The relaxedTrust should not be negated, we want to use all cipher suites when relaxedTrust is true.
Take it or leave it: Mild preference for "HTTP/2" in the error message.
Is forEach better that putAll? I suppose we also need to take care of the case when params are null.  if (params == null) { namedParameters.clear(); } else { namedParameters.putAll(params); }
Simple for-each?
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
I still don't understand why the key cannot be the session id
here you can get the token from the 'querystring' and issue an initial HELO message
I'm confused -- under what circumstances would IllegalStateException be thrown? It must be pretty distinct from the URL-syntax-related exceptions, so it probably belongs in its own try block. Or, even better, if we could check for that condition explicitly -- IllegalStateException is broad enough that the meaning of such a catch block is pretty much doomed to be unclear. As long as we're tweaking exception behavior, I'm also wondering if it makes sense to throw IllegalArgumentException. Throwing it from getSolrUri makes sense only if the argument to getSolrUri(that is, List<NameValuePair> params) is illegal. But it looks like this can also be caused by getting a bad value from runtimeConfiguration.getSolrServer().
Just an observation that this code looks strange. You used to call a build() on a builder but now build() is never called.
I see that address.getHostString() can return null, at least in theory (although it seems to be a pathological case). Do we want to defensively prevent against NPEs here?
Wouldn't this implementation apply to all cases? It looks like a generic utility method. Should it be defined as a default, perhaps even a static, method in the interface?
Where all is the outer setAddress method used? The AMQP Properties section is part of the immutable bare message so we shouldn't in general be setting the 'to' address in it or creating the section if they weren't present. Exception might be made during cases like protocol conversion, but it seems like it should be explicit rather than a side effect that might see unintended use as here.
Use target's class loader instead.
Instead of using the context class loader, use the class loader of the first aggregate factory provided.
I wouldn't change the behavior of this constructor. Instead, leave it to the AnnotationEventListenerAdapter to choose a default HandlerDefinition. That would allow it to create an instance based on the listener's class loader.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
Why is the base abstract class using YamlClientFailoverConfigBuilder()? I would expect an abstract method instead.
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
It is confusing to have unrelated asserts in one test method, please split those into separate tests.
do we need to specify content type here?
This assertion may fail if there is more than one public key on the repo you are testing on. I don't think that's a safe assumption. Better to use Matchers.hasItem() here I think.
Why not use Collections.singletonList ?
ObjectUtils.objectsEqual(a, b) may help here.
minor: Maybe you can create constants for the pid and mntOptions as well, similar to blockSize. Or remove blockSize and directly use the hard coded value here, if all these are used only once.
This method is only used in test code?
Use a stream.
Use a Visitor.
Doesn't seem like we need to throw Exception here as shutdown() doesn't declare a checked exception.
Is shutdownNow more appropriate (which would interrupt running tasks)?
I think you might need to flush too? Or is someone else taking that into account? Would be good to have an explicit test for this: - start a backend having an extremely high refresh time - send a write operation to the backend - verify the index change is not visible - close the backend - verify all changes had been stored
This try-catch can be moved to the @Test annotation as well.
I recommend using @Test(expected = EvaluationException.class) for these tests.
Consider using something like this: fail("expected ApiException");
CalDavConfig has no super class (except of java.lang.Object). Do we need a super() here?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
You can put the whole ability text here instead of calling the super but if you don't you should add a comma after "steps"
In all the other nodes, all the constructors call the most specific constructor to avoid constructor spaghetti. That would mean the this-call gets "null" at the end for example.
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
HTTP_HEADER_CSP
Some tests are using @Before others a method like this, worth normalising that.
Can be private and static.
This query returns no data. Is this intentional? If so, perhaps, use assertQueryReturnsEmptyResult.
this query is not necessary as there are SELECT * FROM lineitem_ex queries in other tests
I expect this query to fail because ship_day_month_nulls column doesn't exist
ins't KEY2STRING_MAPPER missing?
isn't it missing KEY2STRING_MAPPER attribute?
the connection configuration is never serialized.
you can return List<? extends GonamedElement> and don't cast definittions
Since this is recoverable, can it just be info?
To avoid NPE, could we use: java Objects.equals(field.getFieldName(), fieldName) || Objects.euqals(fieldName, field.getFieldBinding())
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in isDeleteHorizonSet below.
This probably will be replaced by <LINK_0> ?
Just to be sure, we are reusing the code, but not changing the behaviour for backoff right?
You forgot this!
quasiIdColumns and infoTypeNames  should be inlined
StringUtils.isBlank
We have a numeric pattern in PatternUtils, would be best to use that here to avoid formatting issues.
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
reusing the variable here seems a bit confusing to me. It's creating a new versionRange object so why not declare a new local variable "newVersionRange" ? this way you could clearly name it "(old/original)VersionRange" and "newVersionRange"
Should be Multibranch not workflow specific type
Note that this will exclude other AbstractFolders such as multibranch projects and GitHub organization folders. May or may not be what you want.
nit: space between if and (
Please move such code to UI abstraction.
I believe this method should be private
I don't think this is correct for nested object structures. Suppose we have the following class structure:  java public class Person { private String name; private Address address; } public class Address { private String city; private String zip; }  Translating this to JavaScript/JSON should look like this if both, Person and Address use the JsonToStringStyle for their equals method:  JavaScript { "name": "Peter", "address": { "city": "New York", "zip": "10026" } }  If we apply this fix, the result will look like this:  JavaScript { "name": "Peter", "address": "{ "city": "New York", "zip": "10026" }" }  Note the additional double quotes around the address object.
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
Why so complicated? Why not LOGGER.debug("Could not process citation", e");?
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
no nede to re-parse, use one parser result always.
I think there is some findbugs issue with not using {} not sure.
I wonder if we should not put this not_touch in first position or at least before the EObject type filter
Run formatter
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
please remove TODO and printStackTrace() and use proper logging instead
Please use Optional.ofNullable()
minor: don't need this. in both lines
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
This is a weird place to add a listener.
return Arrays.asList(boolean.class, Boolean.class)
return Arrays.asList(....)
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this switch case number of lines from 10 to at most 5, for example by extracting code into methods. [![rule](<LINK_2>](<LINK_0>
Should be moved with other not treated cases
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Shouldn't that be List<ClientEntity>?
We are silently failing here, should we log or add a server health message?
Maybe it would be good to create a utility class for the client messages.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Why not throw IOException and let caller handle and log etc.
This will throw redundancy warnings in IntelliJ
nit, Collections.EMPTY_MAP?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Does it really need to be 'public static'? Is this method used from somewhere outside?
please put "permissions.txt" somewhere in constants
Remove this if block - this is a static final String and not null.
not really needed to verify it
why we need to check for getVm().isInitialized() ?
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
create a variable for the set
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
I do not think that it is part of the responsibility of the validator - what is the benefit of moving the check to the validator?
this imply hostedEngineVm may be null. shouldn't other flows consider the same ?
why we need to check for getVm().isInitialized() ?
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Can you please use the key aMHOf2rfzUt3fuKkb7DXX8pkBv1AmcBWwwoSfwpt8CMhdUdxXscB4ESOmBPs4NlmYJmFtcSZ3Q5kMxzb. This is a sandbox key that should work (for the build server and for local testing)
Should we really throw an exception here, instead of simply returning empty?
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
It's unfortunate that we have to make assertions based on output
import and use the method directly
We should at least resolve the Type at construction, so that exceptions are thrown as early as possible. The qualifier lookup can still happen in the build method though, and satisfy the purpose of this refactor.
That's good to know.
This can be static
I missed at the last review, but could we put this return true in else?
This else if block can be removed. We only have information about the saved request URL, so that is all we can really compare.
Is this for debugging?
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
warning: The static field AbstractProcessor.logger should be accessed in a static way.
warning: The static field AbstractProcessor.logger should be accessed in a static way.
You can check with something like StringUtils.isBlank(getName()) since all the getters will return a value, specifically in this case it will return an emptystring which is bad given name is essentially the identity.
notEmpty check?
why is toString defined here? Also, it is using a method that is expected to be used only for testing. It doesn't seem to provide any benefit other than debugging, perhaps? Even for that , we should stick with package private methods as opposed to public one. Can we please remove this?
This is bytecode equivalent to using the for-each syntax on an array.
We can use internal fail method instead of throw new Illeagal...
toList() should return only JSON object. I understand that getObject(i) can return CBL Array() or CBL Dictionary() ?
This does not need to be changed.
Should there be validation that skipBytes.length < value.length?
Maybe we can reuse BinaryDecoder?
Replace with specific exception types.
Actually, any use of ObjectId as a parameter probably should be AnyObjectId instead. This permits the mutable variant to be passed in. Normally that might be a problem, since the caller can change its value after we return. But it shouldn't be an issue here, because we're doing a lookup of the object in the RevWalk and holding onto the located result. So we're copying the value we were given, which makes it OK to take the MutableObjectId variant.
Rewrite as try-with-resources: try (ObjectReader reader = db.newObjectReader()) { return forPath(reader, path, trees); } ?
this is unused.
suggestion bannedColumns.add(COL_ID_ACTIONS);
I thought this line is wrong until I realize that you changed what done means. I would add a second variable, and make done a local variable in handleException. I would also prefer that handleException be inlined due to the tight logic relation with run.
Please add braces surrounding the for loop block. Otherwise this is confusing to read.
toMap() should return only JSON based object. I think getObject() can return non JSON based objects.
I'm personally not letting this kind of exception to be caught. Handle null correctly because this may falsely catch.
Same here, you need to check that retireable fields are not null and null after
You need to check that other retireable related fields at are not null and that they were null before i.e dateRetired, retiredBy, retireReason
same here, don't set fields, just call save here
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
Should be "InstaPost" actually.
Do not add the check here. Add the check just for dateuploaded.
The this. in getters are unnecessary too.
You should not do this. The unsanitized name only presents problem when displaying as HTML, but not when storing in DB.
Is this supposed to be <code>return "Bump"</code>?
what's the point? The method is always false for DefaultDebugExecutor.EXECUTOR_ID without your changes.
"return DebugPage.PAGE_ID.equals(pageId)" ?
"return DefaultSessionEditorPage.PAGE_ID.equals(pageId)"?
LOG.error("Failed to getattr {}: ", path, e)
LOG.error("Failed to unlink {}: ", path, e)
LOG.error("Failed to read {}, size {}, offset {}: ", path, size, offset, e)
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
Maybe extract the admin and 'instructor' string to a variable/const if possible? suggestion if (!userInfo.isAdmin && entity.equals("admin")) {
The use of false here seems un-intuitive, in that we never update set the hash - even for new objects. Is this because we rely on the id being null in these cases in order to detect it is dirty? In any case I think it needs some tests around it.
Would this be a good place for some debug logging?
what happens if one passes SHA1 here?
Any reason why this pattern is different to the one used above, where we needed Iterables.getLast? And same question: any reason for picking the _last_ one here?
why is this if statement inside the function but checking whether snapshots are allowed is not? basically if it's not of type IMAGE then snapshots are not allowed so I'm not sure why we'd even get here (looks like the 'if' is redundant unless AllowSnapshot doesn't report correctly). In addition, personally I dislike a function with all code inside an 'if' statement. Also the name does not reflect what it does this way (it only updates if ...)
I would consider to rename the parameter diskImage to oldDiskImage just that we will still have an indication which disk are we updating...
Again what reason for that line. Lets think: line before we update entry at DB, why I need to update an object which is not updated at DB any more. Why? These is example of dead code. Dead code should not be written
Again, just return the boolean value.
this implementation is not effective, you will call both hasNext() methods always, even when the first call is sufficient to return true. should be return hasNext() || hasNext()
As this method modifies countDown, which is important to make decisions about state transitions that are guarded by a lock elsewhere, I think this method had better be synchronized. Now with other modifications in the class this method could at some point be called without holding the proper lock.
I would actually recommend removing the throws IOException from the interface. Any checked exception can just be dealt with by calling callback.onComplete(null, ex). I think that this helps unify the failure handling paths that the caller needs to deal with.
This code should be:  this.channel.close();
This addition is pointless
Could we log in the constructor rather than here? getBinding() can be called many times over the lifetime of the EvalBinding, so we'd just be getting many warnings for the same instance of the problem.
This early clearing may cause the same binding to be resolved many many times when resolving other names. Instead of storing promiscuously resolved binding directly in the name we can store in a new field of ProblemBinding. This way we don't need to re-resolve anything after turning off promiscuous resolution and even after turning it on again.
This change seems to mean that symbols unresolved due to missing includes will become resolved as a side effect of Organize Includes. It is preferable for Organize Includes not to have side effects.
Integer.toString?
Neater: String.valueOf(value);
![Oh Hell No!](<LINK_0>
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
"isSearching" should be a class level string
generally we like to keep the super as the first call on methods unless there's a need to switch
Wouldn't it be better to use the transitionMap to group by from state?
You can do this just using what's built in to Java:  return String.format("Notifications [notifications=[%s]]", notifications.stream().collect(Collectors.joining(",")));  But ImmutableLists toString() pretty nicely, so you should just be able to do this:  return String.format("Notifications [notifications=%s]", notifications);
Should we just use MoreObjects.toStringHelper() for this?
Use parameterized logging instead of string concatenation.
I agree with @pfink, the follow profile will forward state updates from an item to the following item as commands. Please revert.
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
could this be static?
As it is deprecated, please use TableDescriptorBuilder instead.
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
suggestion this.className = requireNonNull(className);
suggestion return componentName == null ? "Unknown" : componentName;  If this goes to the UI, we're gonna need i18n for that.
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
Formatting
[Checkstyle] ERROR: '{' is not preceded with whitespace.
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
For simplicity, this can just be return getChildren(inputElement);
Maybe return a String or boolean to confirm that a path was removed.
Thoughts on changing this from using withContext and a String constant in Storage Common to making this a helper method in Storage Common?
We should continue this with monoError(logger, new NullPointerException("'index' cannot be null."); This will throw rhater than return that mono error we want.
I would prefer to have the try/catch here in the public api instead of in a private method that gets called from here. We may cause some exceptions here that are thrown directly before calling the private method.
The Exception is never thrown.
Maybe mention it was a query by id. Something like Error while querying by ID. Nice to have the sanity check instead of relying fully on stacktrace line number. It also help differentiate this exception from the one thrown in the other query method.
hmm for node based traversal the traversal id is the node id so I think getTraversalId makes sense (more general) ? But yes, let's replace the edge parameter with the adj node id.
This is a great optimization. Should this point to first character in the ASCII table ? Also lets verify that this for UTF-8 encoding as well.
If you remove the parameter it won't be there for the test and it will always pass ;)
I would feel more comfortable with this if you did something like throw an IllegalArgumentException if !ref.startsWith(oldPrefix)
You can put VALUE_1 directly to the assert.
I think we should undeprecate AbstractAttributeEditor.dispose and have it dispose both the control and the labelControl. Then we just call dispose here.
use an enhanced for loop, the iterator isn't necessary.
this.
A create card payment request should always have a return URL, so I don't think this should return an optional
this.
Consider to use an ImmutableList here
Style issue: @Override shuld be on line above the method declaration
Is there a reason this is a list instead of just a CaptureConfig? From a usage perspective, it only makes sense to issue a single config.
This means clockHand will be hot at initialization time. Intended?
looks like it only allows feeding one SSP. why do we need a set?
nit. Just a suggestion, should metadata store api have method for deleting multiple keys? May be more efficient for some types of storage.
* CME? * Isn't that exactly what remove() does? Removing on equals()...
I thought for '-as3', target should be FLASH
Check first that target is not null.
Run-on sentence; does not explain WHY user should use other api. Preferred: "This method is deprecated and may be removed at any time. Please use ..."
This shouldn't return 204 no content, it should return 200 with a description of the member the way PUT /groups/{id}/members returns a description of the new members.
IMO they should both call the other methods. They shouldn't make the request themselves so that there's only one path to a call to request
You should add a convenience method that takes in an IReducer and wraps it in ReducedMetric
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
could metric == null?
Check if buffer us null.
Check buffer null.
Unsafe cast to int, may lead to exception, suggested Ints.saturatedCast(numBytesToPutInFile)
consider change to return validate(validator.isDomainExistAndActive()) && validate(validator.isDataDomain())
why public? Are we planning to use it outside of this class?
perhaps have the pair as Pair<Boolean, Guid>, we don't need the entire domain object.
I guess this could blow up...
this seems wrong. now you keep track of the last one and not the first one.
nit: So, Record.NO_TIMESTAMP constant is removed? I thought that is more readable than -1L.
I assume that's eyeball & plug? I can't make out the plug part it just seems like a black blob. If it can be made more clear then great, at the same time I realize this isn't a gfx design project so go ahead with it, we can always replace it later I guess...
It'd maybe use a little more generic name here. There's a good chance that this icon could be reused for other warning-level problems later.
You can use fall-through cases to clean this up:  java case DisplayMetrics.DENSITY_280: case DisplayMetrics.DENSITY_XHIGH: return "xhdpi";  etc.
You might want to move this into a shared helper method for other tests which need a temp file with random data.
Note that the simpler idiom (which also converts more cleanly to Java 7 syntax) is  InputStream inputStream = new FileInputStream(file); try { return IOUtils.toByteArray(inputStream); } finally { inputStream.close(); }
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
any clue on how this number was chosen? Is it an absolute or relative value? I think we should preserve the existing behavior by default, since most production deployments are constantly adding new data anyway, in which case it doesn't necessarily make sense to stop rebalancing. Also, even a small number may cause very large clusters to completely stop rebalancing because the incremental improvement is typically very small.
Isn't this... just a re-implementation of natural ordering? I don't think you actually need this.
Could you avoid these awkward blocks by making numerator and denominator an AtomicLong?
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
Iteration over bits set to false is better: for(int i = exception.nextClearBit(0); i >=0; i = exception.nextClearBit(i)) {
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
Don't set statusCode in this class, just delegate to the appropriate super that takes a statusCode.
200 >= instead of <=
Very strictly speaking, not 2XX is isNotSuccessfulStatus, e.g. I won't really call 1XX or 3XX errors.
This block can be omitted as it will always return false (id cannot be null here) and behaves the same as id.equals(null)
Proper equals implementation so that it does not leave itself open to class cast exceptions
whitespace/style
This line isn't needed. It's already tested elsewhere to be working.
susceptable to various XXE injections by the looks of it...
(domains) -> domains
I recommend this approach instead: java @VisibleForTesting Subject cacheAndReturnSubject(ServerSession session) throws SecurityServiceException { UPAuthenticationToken usernamePasswordToken = new UPAuthenticationToken(session.getUsername(), session.getPassword()); try { return AccessController.doPrivileged( (PrivilegedExceptionAction<Subject>) () -> securityManager.getSubject(usernamePasswordToken)); } catch (PrivilegedActionException e) { if (e.getCause() instanceof SecurityServiceException) { throw (SecurityServiceException) e.getCause(); } throw new SecurityServiceException(e.getCause()); } }
Do we need this else block?
Put the close() into a finally block so that an attempt is always made to close the session, even on rollback fails. If closing the session fails, there's not really anything we can do -- log and move on.
I have recently created AssertionUtil a class that provides shortcut to test assertion error, you can replace assertThatExceptionOfType(AssertionError.class).isThrownBy by assertThatAssertionErrorIsThrownBy.
either use expectAssertionError or static import AssertionsUtil.assertThatAssertionErrorIsThrownBywhich is a shortcut to assertThatExceptionOfType(AssertionError.class).isThrownBy
replace all Arrays.asList by org.assertj.core.util.Lists.list and static import it for readability.
Same issue here, double delete user.
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
Is this needed? Removing it should work as well
We're on Java 8, so: IntStream.range(start, start+length).toArray()
i++ is generally the convention unless you explicitly need to preincrement.
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
This is called in the init method. Why is it needed again here?
I think it's better to remove this redundant prefix (VmTemplateHandler::setVmTemplateStatus:) ?
we use IO.readFully to read file content and RawParseUtils to decode the bytes to a String, see e.g. Repository.readCommitMsgFile()
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems to me like the removal of the slash has no effect because its dealt with here no?
Should be able to do a multi-id query using something like criteria.add(Restrictions.in("groupId", groupIds)) Current method allows for nulls to be included in the returned list too I think
There's a way to avoid that n+1: doing a query searching for all questions in (:ids) and, after that, using session.load to get the questions in the specified order as you're doing (the hibernate would get the questions from the first level cache once you already selected them before). (yeah, its not pretty, but works)
Likewise: can this be static? That said, I think it might be simpler to do inline at the call site: objIds.stream().map(ObjectId::name).collect(toList()); Or maybe we can make a custom matcher, something like hasObjectIds("4624442d68ee402a94364191085b77137618633e", "f900c8326a43303685c46b279b9f70411bff1a4b")
Is this still required? Seems like we might want to prefer exploding instead suggestion this.packageName = Objects.requireNonNull(packageName, "packageName == null")
Could we avoid using dollar signs in variables names? This is not a common practice.
Is it really filter name?
Would be nice to check different lengths and empty.
we need more here, at least fd. It would be impossible to match timings to a query without these that. Perhaps logging sql text again will help too
Use Unpooled
Objects.requireNonNull(buf)
These are more readable if they are inline'd into the assignment. I'm not sure if this worked for Guava Preconditions, but the Java requireNonNull returns the reference, so it does work for that. Example: java this.buffer = Objects.requireNonNull(buf, "buf argument was null");  But, we should stick with whatever minimal change merges to master easiest.
shouldn't you do a defensive copy?
Implement this
Could possibly do an assertion using StringUtils.hasText()
Perhaps nameToDataType.
Empty catch again? :) AssertJ or suppress will work better for us I think.
Is there any Jira for this one? Should there be such tested feature? If not, I would vote for erasing this test.
I am not seeing this assigned anywhere. Is this needed?
we could add an assertNotNull here to detet as soon as possible potential problems
to remove
This method returns an Option<DRepresentation>, so the API clearly says it can be null. You must check 'if getRepresentation().some()" before.
put lock() before try
If you'll eliminate the lock, accept method will contain just "this.value = value;" statement
I would make queryResults final and remove the method.
remove extra empty line.
No reason to get the cause.
I'm not sure that we should reuse UnauthorizedException for TLS handshake failure as well as for actual login failure. The Python driver uses ServiceUnavailable here but that doesn't seem quite right either. Perhaps we should have something separate such as SecurityLayerUnavailable?
rename to pack
rename to root
Use a LinkedHashSet to get predictable order (useful when the result of this is shown to the user).
so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:  return highest.isPresent() ? highest.get() + 1 : 0;  also we might have a test for this method to be sure we don't break it in the future
I suggest inverting these two calls, so that the instance no longer is in the created collection.
rename to clusters
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
Initialize this in the field declaration
Will this inject all instances of Task on the classpath?
If I understand this right, the state machine cleans itself up after it disconnects?
Do you really want to double start it if it already exists?
no need to do this. At this stage setSpeakerphoneOn(true/false) should not be called as this only applies to in call state. Hall, Why was it called in the first place? Is it a way to reset speakerphone state before starting the call?
ValueNodeList.comparable() is only used here, I'd rather make it always return a boolean and explicitly raise an exception here (instead of adding the extra boolean parameter), to me it's surprising that comparable() would raise an exception instead of returning true/false
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
@vilchik-elena copy-paste issue
I would add a Precondition for Result being an instanceof RowResult so that we know if our assumption here is in correct
What else can this be?
Again, please don't catch Exception. Code compiles fine without the try catch but you might want to replace it with catch for NumberFormatException.
progress.split(1) ? Interestingly, the counts seem to off quite frequently. Here only 2 of 3 ticks are consumed. I wonder if that was intentional?
Would it make sense to have some common interface like ToolingApiRunnable for this? Then we could have CorePlugin.run(tapiRunnable), which would take care of getting a token source for you.
Not needed, delete.
name.substring(ext) is equivalent and shorter to write.
Qualify this.uri
Should this also handle the suffix 'es'?
No shallow copy as it was the case before?
this is public API, we can't lower the visibility without deprecating first
isNullOrEmptyWhitespace(), please
Does this need to be public?
Let's make it public.
requireNonNull
I'm in favor of just using the iterator and remove during the iteration..that's unneeded.
please revert the changes here - it'll cause to issues. the spms should be moved to prepare to maintenance last, so in case that we move to prepare to maintenance few hosts from the same pool the spm role won't be taken by any of those hsms and will start "flipping" between hosts, causing to many unneeded operations, therefore the spm need to change the status last.
/s/else/elseif
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Why do we ignore annotations under ANNOTATION_DEF?
Shouldn't this be a switch?
Be careful, this method is probably used by core plugins
you might want to check here that keyQuery is not null
What about returning a Set to emphasis that there is no specific order in the returned collection?
I think it would be OK not to throw an exception here; if someone has a description and a line number, that's fine. And then we could again just rename setLineNumber to withLineNumber. If we do throw an exception here it should be ConfigException.BugOrBroken, but I think it's simplest to just not throw one.
Number -> Integer
I think curly braces are missing and the formatting is wrong in the subsequent if (one step too indented)?
still relevant?
Sorry for not noticing earlier - but shouldn't we also check actionReturnValue.getSucceeded() ?
Please use Set instead of the concrete implementation
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
in this case we can and schould work with the constants!
is it worth adding if it's null to return REQUIRED, to prevent old persisted items from returning null here? or have an explicit @Nullable
remove this too if it is not used.
Why make it public?
Style nit: Curlies not needed
Since RuntimeEnvironment is shared between all runs of tests, usually I have noticed a reversion of original settings - e.g. env.setHistoryEnabled(originalIsHistoryEnabled) in @AfterClass. I see tests passing but wonder if it should be done anyway for correctness.
Is this running on the swing thread?
After some discussion, the team would like this to be opt-in via configuration. The new behavior could surprise users and it's only a single property on config server, not clients. So  if log errors = true log error else rethrow
This can be private again.
Potential NPE, check for null "cacheManagers"
address.toString() uuh... why?
This method should be static and need not pass this as an argument to the constructor.
Same for other places suggestion _tableConfig = tableConfig;
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
Why have you added this line here? This will automatically choose first local address and then switch to remote address if the ping to local address fails. Adding this dissolves the purpose of having Local and Remote mode explicitly.
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
CheckForNull
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
might be worth having a "categoryIsVideo" method somewhere, so we don't have to have the string around.
Use CommonImages.getImage to prevent memory leak.
We could remove this switch by using an enum and having each part of the enum a value (-2, -1, etc.) that returns the proper ImageDescriptor. This would simplify this function to: return CommonImages.getImage(ReviewsImages.valueOf(reviewsScore.toString()))
Use CommonImages.getImage instead of createImage so that we don't have a memory leak.
constructModel already called merge up there.
It should be unique across maven repo. Please change it to org.openmrs:openmrs-sdk-server-{serverId}:1.0.0-SNAPSHOT.
ignore if you'd like: Bookmark bookmark = getModel().getSelectedObjects().isEmpty() ? null : getModel().getSelectedObjects().get(0); BookmarkModelProvider.this.getModel().setSelectedItem(bookmark);
application.size() -> application.isEmpty()
Can we custom the message to reflect more specifically that the application has reference to no domain?
@fuss86 it seems that previous implementation not assumed to return null, is there any reasons to do it now?
Same here: should be Branding, not ProductBranding
java return new String[]{JcrConstants.NT_FOLDER};
Why change the name the property? Accident due to mass refactor/rename with IDE?
Tokens are somewhat sensitive. Don't think we want to print them.
repeated ...
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
Instead of checking for action!= null, i'd suggest to simply change the order of equals, e.g. return ACTION_PROVISION_MANAGED_PROFILE.equals(action) || ACTION_PROVISION_MANAGED_USER.equals(action);
here you should get the selected pattern and get the command.
getSelectedPattern().getCommand() ?
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
new ArrayList<>(causes);
defensive copy?
We might use a NavigableSet instead if a TreeSet is used, I assume.
Sometimes I also try to protect internal collections, but normally it only complicates things later. Can we return it as-is?
Can this return a List<JsonPatchOperation> instead?
Should we set a boolean like: boolean successfullyProcessed = updateAgencies(); successfullyProcessed &= updateProposals(); successfullyProcessed &= updateAwards(); return successfullyProcessed;
Are locks needed in Build and Merge Aggregators alike?
I don't think that creating Thread is necessary because UI must be shown in Swing thread and subsequent download must run NOT in Swing thread. SwingUtilities.invokeLater should do the trick.
Can you please add the name of the VM to the message, so that message will be more informative...
OK, so maybe at least just write it to the log in backend. If we are changing the allocation type in engine and not libvirt so at least logging it should be easy and I guess helpful for users and future debugging.
vm name is more readable than vm id (see line #552 as an example), but other than that it looks ok to me.
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
isn't it copy paste mostly of another assertException method? why not reused that?
Add the original exception as cause.
java @Rule public TemporaryFolder tmp = new TemporaryFolder();
Re-use temp file
is this 10000000000l or 100000000001? Use upper case 'L' a lower case 'L' should not be used for Longs or variable names.
can wrap and unwrap be called simultaneously by two threads, if not here you really need one pair of byte buffers
For DTLSConnector this is configurable. I do not know whether you have given configuration of the TLS connector much thought yet ...
where are the corresponding cleaners for these direct byte buffer allocations?
we don't need to change the Creation classes.
You don't need to take a copy if it's already immutable.
When can this be null?
The upgrade method should run all changesets from liquibase-master.xml...
Use Arrays.copyOf() instead of doing this manually (the whole cropValues() function can be removed)
Please add ? and % as well
Why initialize this to a new OkHttpClient instance that is not being used?
Not in prod, no way!
Not in prod, no way!
This should have stayed camel case
please prefer !a.equals(b) to a.equals(b) == false.
lines 76-81 can be replaced with the new method from line 85: getVnicProfile(Guid vnicProfileId) need to consider the possibility or a returned null value.
Consider switching this to List<Object> instead of the unspecified List type.
Please extract the for each loop to a separate old school for each loop, it's better to read
Remember to remove this
In cases like this I would expect it to throw an exception instead of returning null. For error handling it's okay to diverge a bit from the canonical data (I believe they're trying to remove most error cases from the canonical data for this reason) since it can vary a lot from language to language how you'd want to handle invalid input. In my opinion it's better to throw an exception in Java than to return null since that forces to user to deal with the error instead of relying on them checking if the output is null :)
Could we add a check on the node being replaced having a null parent?
Please use TestException so we don't mistake them with any other RuntimeException failures.
Need to implement
You've overridden this method but dropped the @Nullable annotation.
Seems this is optional and later on you do a != null so this might be better returning Optional<String>
1. We cannot use 0 here (even though it makes sense) because internally, Concourse uses it as a special code to refer to the present state. I'd suggest using -1. 2. When you return the Timestamp use fromMicros instead of calling new Timestamp. Even though we aren't doing it now, in the future we may do object pooling for Timestamp objects, so its best to funnel everything through one static factory in case anything changes. I realize I didn't do that for the other static factories, but that was bad programming my part :(
Again, this is where you should clear out your stale events.
OK. I don't suppose there are significant gains to do away with current altogether?
Is there any specific reason of choosing NoSuchElementException over NPE?
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
Same as above wrt "logging protection"
This is a reason why I got 2 receivers.. The variant information is added to PushMessageInformation in the MetricCollector#updateExistingMetric: <LINK_0> Since it is already added in the NotificationDispatcher, it re-adds "existing" variant metric. By removing this line it starts to work correctly
This should be done once in the constructor instead of doing it every time getMessage() is called.
directly return "" is better
Can the processor name be null?
How about narrowing it to ClassNotFoundException and fail with other exceptions?
Please replace empty string with a proper error message
I think this should be pushed higher in patch chain.
Did you mean valueBuilder instead of valueBilder?
I think that empty string is different from null and is a valid value.
why is this public?
Duplicate getAbsoluteFile()
I don't like that we must first call "getSelectedFile" and then additionaly "confirmFileSave". Could we have a method that merges the logic of the two above? It could be named "getFileWithConfirmation".
@fanifieiev the same above.
@fanifieiev the same above.
@fanifieiev the same above.
The fact an AvroMessage contains json bytes is super confusing.
filters method argument should be passed to isMessageInLogFile as an argument
This is fine during initialization, but sounds strange at runtime. The notNull() throws IllegalArgumentException which doesn't reflect reality for the current message. We should use here Assert.state(), because it is really IllegalStateException during handling message. OTOH I have changed my mind and decided to have this code after one more review:  private volatile Expression expression = EXPRESSION_PARSER.parseExpression("payload"); ... private volatile EvaluationContext evaluationContext = ExpressionUtils.createStandardEvaluationContext();  This isn't Spring Context aware, but lets do not have these asserts at all. Plus such a change reinstates the previous behavior. Therefore the next 4.3.5 will let you to upgrade without issue here :smile:
intentional to remove the shutdownClientOnClose?
Would it be better to, instead of mix secureServerCnxnFactory in getServerCnxnFactory, add a separate method getSecureServerCnxnFactory? This also maps well with existing set method setSecureServerCnxnFactory. Caller now has to explicitly call both, which is more work, but makes semantics more clear.
With the AtomicReference, we could remove the synchronization and just close the previous value we get from the getAndSet(V) method.
Who is calling cleanup? Better if it is done by Junit after/afterclass annotations.
Re-use temp file
catch a specific exception here
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Is it possible to throw a more specific exception?
Why setting Token or MID imply sent = false ?
Should be pulled up to AbstractItem.doCheckNewName-it is not specific to Job.
Is this really correct? ASCII characters would include all 128 defined ASCII characters, but the actual limits are smaller: <LINK_0> Perhaps this message should just spell out the requirements exactly: A letter or number, followed by letters, numbers, dashes, dots and underscores (underscores are not listed in the whitelist, but anything else is replaced by an underscore, making the underscore implicitly allowed). Maximum length is 63 characters.
KFSConstants has a constant for a single-space string if you want to use that here instead.
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Why is this change? Should not this minimally depend on if this table is transactional or not? What happens if we call it on a non-transactional table?
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
Lets keep these methods internal for now (package accessible).
nit: remove else {}, throw exception after if block.
clean up empty quotes and new line.
OK so StringBuilder(null) NPEs. Why are we calling format on something with a null tip? Why are we formatting that string as "null~5" when we know its not a valid reference name?
unnecessary parenthesis?
I'm not sure how I feel about the use of null here. If the keys can ever propagate back up to the blocks layer, this could cause issues. I would recommend giving the key a name like "distance" or something similar for consistency with the other sensors that report values.
Check error code/description
style: unnecessary blank line
Why do you use sleep ? It is highly discouraged, wait for an element instead
Check first that target is not null.
No super(); needed.
this usage does not seem very fine
Should the first parameter not be getTaskServerLogsByTag?
please throw an IllegalArgumentException if str does not contain "t" or if strSplitted.length != 2
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
I guess I am a little uncomfortable with the use of checked exceptions here. This exception goes down through the request manager and (I think) tells us whether a user is admin OR SequencerServiceRecord that is being sent through is null. Since we don't attempt to recover and exceptions get logged anyways we have really done nothing useful with this exception. Here are some other ideas... ###### Options include: - Not throwing the exceptions in the first place and just doing the logging. - Throwing _RuntimeException_ instead so you don't have to bother catching and you get the logging for free. - Attempting some sort of recovery if this exception is caught (forward to 404 / 400 page). Personally I'm all about checking the inputs in the API before they ever make it to request manager. I think they call it _sanitizing your inputs_. That way you don't even try to save if things don't look right, you can just redirect to a friendly "Nope 404 / 400" page. It's a better user experience I think.
forgive my ignorance, but how does this solve the issue? Isn't there still the org.hibernate.Query vs org.hibernate.query.Query issue in the source code?
I think this should be an await with a 5 min timeout, we don't want to leave threads stuck if the initialization takes too long.
Scm api has rules on the placement of annotations for methods
log a serious error that shutdown wasn't called, so as not to (inconsistently) cover for mistakes. ...nvm you did this... but why put the log over there...?
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
Does the output stream need to be closed?
The logging level for this is more appropriate at debug.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
On my computer 1 ms is not enough. The test fail sometime.
This should be synchronized.
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
![MINOR](<LINK_2> 'Severity: MINOR') Missing curly brace. [![rule](<LINK_1>](<LINK_0> ![MINOR](<LINK_2> 'Severity: MINOR') At most one statement is allowed per line, but 2 statements were found on this line. [![rule](<LINK_1>](<LINK_3>
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
There no whitespace around <=. Also - good to enclose blocks of that that if/else in {}.
This is obviously faster, but how do you prove the runtime performance gain outweighs the memory overhead of adding inward edges?
could we just initialize targetgroups = new HashSet<>() at the top of the file?
Check first that target is not null.
return ?
You cannot @Override this method to implement the method from the interface because after obfuscation it will get the srg name. Please consult [the mixin examples](<LINK_0> for how to deal with conflicting methods with the **same** signature/name. _EDIT: actually never mind, I just noticed that the MCP name has an uppercase "ID" while the sponge method has the Pascal-cased "Id" so it's all fine._
This can be replaced by the remove call directly: if (knownPersistenceSpaces.remove(clusterCacheIdentifier) == null)
input is not @Nullable, remove annotation or add null check.
Actually this _isn't_ @Nullable so should either remove the annotation or add a guard that returns false.
I'd have said Objects.equal(contender.getParent(), ancestor) here, to make it a proper descendant check.
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
nit: redundant
You could just leave this part off. suggestion
>byte[] [](start = 11, length = 6) DecryptResult
Sync clients cannot use withContext. You need to explicitly add a Context to the API args. Note that Context is supported only for APIs that return Response<T>.
@greenaddress  and this?
Exposing PojoProperties (an internal class) to API
AsyncSerial again?
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
This shouldn't declare throws Exception.
Would it make sense to add something this.caches.clear() to the stop ?
java LOGGER.info("Groovy console stopping...");
This is getting long, wrap wrap the arguments
This can use partitionChannelTypes
Why now is proper? If whole predicate is pushed down, then I would expect to see TupleDomain.none() here.
The constructor already does this logic. Could this just be this.metadata = metadata?
This seems to be pretty hardcoded, is there any way to make it configurable?
If you are going to do this do you need to @sychronize? If not indicate it is not threadsafe...
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
Is this really necessary? AFAIK the scope and key should never be MarshalledValues.
Why remove this? This makes is a shortcut when you check against the same instance.
They are all TimeEvent instances in current implementation so TRANSPARENT can never be returned (it should for filler 'multiple' events)
about this API... for Cedric's VM, I just had to implement something that may change some style value for specific events. I'd like to just be able to update one style value, but the returned style map is read-only and for just cause! You could add a method Map<String, Object> getSpecificEventStyle(event) that would return only the difference and this method would merge the 2 maps if not empty. This one can be final.
Please add a check on table too or write in the doc than the table parameter can't be null and be sure of that!
Minor: move init to the beginning after the constructor
Please copy args here too
Possible candidate for bind() if that method is created.
nit: This reads weirdly, since I assumed this was an enum and we were marking the CAS as successful. Given that we already branched on casResult.successful above, maybe this is clearer as false?
Code style preference ... but I'd rather stick with the explicit else. If someone was to screw up the if branch to no longer return, this would compile fine. The previous version would fail saying that there is a missing return statement.
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
this looks hacky, can we just create new operations#createTopic(Topic) method instead of creating and then updating?
logger.info("Skipping creation of topic {} on brokers, topic already exists", topic.getQualifiedName())
You can use CollectionUtils.toImmutableList
You could return empty set when user is not logged
Please change to sessionInfoMap.keySet() .stream() .filter(sessionId -> getUser(sessionId, false).getId().equals(user.getId())) .filter(sessionId -> getSessionValid(sessionId, false)) .count();
We could the variable declaration and just use return decoratorClass.getConstructor().newInstance();
Add the original ClassNotFoundException as cause.
By coincidence, I was also working on this today. What I ended up doing was replacing a lot of these exceptions with their parent, ReflectiveOperationException to remove the redundancy, and to cover the additional ones thrown by the getDeclaredConstructor().getInstance() pattern.
this should be catch (Throwable t)
this should be catch (Throwable t)
throw exception
It's possible that you should return relDataType here, if it is not null. I'd also rename the field relDataType to rowType, because it represents the schema of each row.
I missed this before, but you'll want to: - use PDataType.BINARY if the child expressions data type is fixed width, otherwise use PDataType.VARBINARY. - implement getByteSize() and getMaxLength() by having them return getExpression().getByteSize(). The PDataType.BINARY is for fixed width data, so the expression impl has to tell Phoenix what the fixed width is through those methods.
This should return the PDataType for an element of the array
Use readAsString(...) instead
Use readAsString(...) instead
Use readAsString(...) instead
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
This could simply return the enum itself couldn't it ?
Either put this in some non-setup Constants file, or just move each version into, say, BookmarkRecord  after all, the record structure is the main thing being versioned.
studentsWhoRespond -> studentsWhoResponded
unnecessary default implementation
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Why not IllegalArgumentException?
It's easiest to initiate the field directly, and I'm not sure it's needed, the primitive should be false by default
constant or lineseparator from system?
Again since the validation is done in the UI, I think you can go directly to writing the GB response
This whole block can be replaced with functional style Java, as per example given in Epdq.
This whole block can be replaced with functional style Java, as per example given in Epdq.
I think this is unnecessary => "profile =" + this.profile is sufficient.
channelId => channelName
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
Same here, add deprecation flag.
I think super implementation is correct (size == 0). Nulls are still considered part of the list, they just take no memory in internal structure.
You should see it from the side of the user, not of the implementation
you can make the same optimizations here as you did with the other ones: Meter meter = (Meter) checkCache(classSimpleName, fullMetricName).orElse(_metricRegistry.meter(fullMetricName)); and then remove the "if (meter == null)" check
This also needs to be synchronized
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Shouldn't this be transactional?
Replace these 4 lines with assert ~originalUserEntity.isCreatedOnBuddyRequest().
Replace these 4 lines with assert originalUserEntity.isCreatedOnBuddyRequest().
No need for super()
calling super not needed
Why is this constructor deprecated?
You don't need to start the execution plan for parameter validation scenarios
Please keep the line length under 120 chars (in other files too)
Below three lines are not needed. createExecutionplanRuntime will throw the exception
I think the chart viewer should be responsible for its own presentation provider. The tree viewer could ask the chart viewer for a series appearance directly, perhaps through the ITreeViewerInterface? (could be renamed ICounterChartViewer).
analysisId is already a String
You can inline this in the call below
Should be a constant.
Implementation of this and other similar methods is highly inefficient. Better to use Character.isJavaIdentifierStart.
Could you prepend ^ and append $ to pattern to achieve the same whole-string match?
same here, I think it should be Files.createTempFile
optional: this can be outside the try{} block
Please use [try-with-resources](<LINK_0> statement instead of handling this manually.
Returning the first chunk of the stream before "\A" [implementation] and returning the entire stream contents [interface] don't seem to be in sync.
use try-with-resource instead: try (Scanner scanner = new Scanner() { }
May want to add a failure message to this assertion that includes the expected value. Otherwise the failure message will just say that it was false when it was expected to be true and we'll have no idea which value it failed at.
What's the purpose of this line? I don't see any difference if the url is correct or incorrect. It just clicks on the Verify button and then continues with clicking on OK. It would be nice to preserve the verification result. For example you can return it as String result.
Is this safe? Shell to rename tag can not be focused sometimes, it's a good practice to use new DefaultShell(title) to focus shell you are working with as well as have better readable code (you know precisely what happening in you). Just a note. Did you know, that using new DefaultShell(title) wait for a new shell for 10 seconds and focus the new shell? It is almost identical to new WaitUntil(new ShelLWithTextIsAvailable(title), TimePeriod.NORMAL), almost - you dont have to write so much code and it looks better ;)
Do not throw an exception in such a method. We just want to know whether the url is valid or not.
add "this" qualifier
So we decide this class to be a leaf ByteCode Node? (Alternative would be make this returns ImmutableList.of(block, position)
Instead of now having two methods, getNodes and getContents, in regular blocks, I would pick one name. I've gotten used to getContents, but getNodes is also fine with me. So if you prefer getNodes, I would deprecate getContents for removal to not have this duplication.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
There's an extra { that got added here.
Might as well add a comma
Since a SAML Attribute map can have multiple values, the type here should be Map<String, List<Object>>.
This should not be changed, this is for backward compatibility. getInstances was added for this purpose. (maybe at the end we can remove it, but I prefer to keep if for now)
I think this should be stripe_account_id ? as per PP-4302
I think you should also have if (c == null || c.length < 7) return; or else we'll hav an NPE
unnecessary array new: {{true}, {false}} should work here
What's "c"? Can we unabbreviate it?
Please keep the getter and setter closer.
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
The ListenerList implementation already takes care of this. Remove the "contains" test.
No use checking if the list contains() before remove(), let's avoid double iterations.
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
I think that the lock should be acquired for each image disk, vdsm call might take few minutes so we will provide better user experience.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
We could omit the second Integer.
This will not work on a runtime-system
defensive copy?
Please refactor to different methods
No, RunVmCommand is executed before the VM is running, The VM's status should be down
Why not just simply "command.setVM(vm)"?
Any reason why this cant be unloaded?
Are these methods part of the upgrade?
Binary output length can also be calculated.
Hmm, is this missing the .incrementVersion() call?
I think it should be synchronized too.
As mentioned earlier, these calls might need to also regenerate the iterator. Please double-check.
can't we use optional?
Style-nit: no brackets around single-line blocks
Is it possible to retrieve that bean only once? I'm not sure how performant this operation is in Spring..
Can you throw ElasticProfileNotFoundException() if existing profile is null? the remove function below can be successfully run when null is passed to it, but the user won't know that nothing has changed.
I couldn't understand the need to get templates config and set it back again, is this required?
You should put default tenant here if it is single-tenant cluster, similar to addTable() You may extract this part into a helper method
Collections.emptyList()
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
defensive copy?
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
Is this needed?
Extra space again
No key for encryption? ;-)
Missing codes.
just return "" instead of new String()
you can inline the non null checks with assignment, e.g. this.packageName = checkNotNull(packageName)
Is this still required? Seems like we might want to prefer exploding instead suggestion this.packageName = Objects.requireNonNull(packageName, "packageName == null")
If this is intrinsic, needs to be prefixed.
Should it be logged at the error level?
Integer amount = 1 + amountOfCardsDrawnThisTurn.getOrDefault(playerId, 0); amountOfCardsDrawnThisTurn.put(playerId, amount); if (amount == 1) { // do stuff }
This class has no superclass, so I'm not sure we need to call super() here.
Do we need a new BufferManager on every snapshotApply? or could we just reset?
Need some log here
I still don't follow what this timestamp does, can you please explain it to me.
When the result of Math.pow is 15.9999999999999999, numberBuckets will become 15.
An enhanced for-loop would be cleaner than an iterator.
The sublist could use a vraible for readability and line length
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
Laurent, you could put else if here. And even: Command cmd = super.... ICommand result = null; if(getHost() instanceof.. ) { ... } else if (cmd != null) { result = new CommandProxy(cmd); } return result;
initRepository() needs to be called here too.
suggestion MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, "typeName", type.getInternalName());
@lindamartin I don't get how it works if LineCounter doesn't extend any interface (e.g. sensor)
What bugs me is that you have to worry about the file path before calling this, this shouldn't be... You should be able to just call the preload with the same File as the one in addXmlFile.
This test probably doesn't do what you think it does, because it verifies that EXT_ID matches with itself. (Same with several of the subsequent tests.)
Why do this ? You can iterate over the set just fine - no need to copy it to an arraylist
nit: unrelated in general it's better to make dedicated patches for cleanups, it's clearer when digging through the git history
Should make a differentiation of the name and id.
If this is intrinsic, needs to be prefixed.
Should throw at construction time instead.
super.init() method never throw an exception.
please use baseActivityTestRule.launchActivity() (without the "null")
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
Let's add a ctor for FeatureFlagBuilder(FeatureFlag f) and then make FeatureFlag immutable.
This should actually return something, no? :)
If the _keySize is an Integer then return that here so it doesn't get unboxed and reboxed. Use int everywhere or Integer everywhere.
instead of thowing we could return an empty list
Best to avoid logging any passwords, some end users will actually audit log files to ensure no passwords are logged.
Why is not the check of presence of certificate with given alias left for the next processing, like in case (principal instanceof NamePrincipal) == true?
This can now become package private and be annotated as @VisibleForTesting I think.
You can contract this into dialog.onOK(config -> exportConfiguration = Optional.ofNullable(config));
We can use the expected attribute of the @Test annotation to declare IllegalArgumentException to be thrown anywhere in the annotated test method like this: @Test(expected = IllegalArgumentException.class)
Perhaps use mkdirs?
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
I know it's not part of this diff, but why isn't this function static?
You shouldn't call onXXX methods while holding a lock.
terminated = true ?
You shouldn't call onXXX methods while holding a lock.
could use a better error message like "Failed checkForChrashes call" also could dump the stack with a line "e.printStackTrace();"
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
Hi @rezita, I think this should be isSHREnabled
This logic could also be moved into the Dependencies class.
it could be simpler return this == LOCAL
Can you make this if clause a block by using {...}? Supposing somebody enters a new line accidentally, then this method will end by returning false always.
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
Should be- setTitle(text.asString()) not setText.
Could rewrite this to use ifPresent.
Don't expose the whole list. Either a single getter getLocation(int), or an Iterable, or both if needed. And even when using Iterable, you also have to be careful for concurrent accesses. But in this case, elements are added to the array in loadXml(), which is called by the constructor. Which means that once this method becomes accessible (after the constructor has run), it should not be modifier afterwards. In fact, you know what would be clean? Putting the loadXml() stuff right in the constructor, and saving the fields themselves as unmodifiableList/Map's. Then you can expose an Iterable view, but don't have to worry about locking anywhere. Also, you often use List, when in fact the only operation to do is to iterate on them. If the order is not important you should use Set/HashSet (or TreeSet if you store Integers/Longs), it would be more performant.
you can use Collections.EMPTY_LIST
it's a bug, we should throw UnsupportedOperationException when a method is not implemented, please fix it
Doesn't matter much, but we should throw IndexOutOfBoundsException("index=" + index). The operation doesn't have a missing implementation - it's implemented, but there's no valid index it can be called with. Same in EmptyRowBatch.getRow()
Should this be implemented?
Should this be implemented?
we can remove the status variable by calling "return deleteEndpoint(endpointName);"
120 character limit seems to be violated.
Why we are starting and ending tenant flow in all the test cases? Shall we move the start tenant flow to @BeforeTest method and shall we end tenant flow in the tear down ?
verify(fragmentMap.containsKey(id), "fragment id not in map: %s", id);
but now you don't really need "new" - these classes are stateless, no risk of two (or more threads changing a state of a single instance, so u can definitely hold a single instance of a mapper. You should be aware to the fact that "new" is an expensive operation.
I disagree that this is the right place for it, it's hiding this logic in an unrelated place, I think this call needs to be done explicitly where the remove is called (as is the case for statistics)
types --> type
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
These shouldn't have changed.. The bicep min/max should be 5-90 ... not 0 to180. The change in behavior in setMinMax was fixed .. these changes should be reverted.
Extra space after synchronized.
what is clientConfig is anything else?
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure. #refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)
you should return the litteral enum. It would be simplier
Please add a check on table too or write in the doc than the table parameter can't be null and be sure of that!
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
what happened to handling of nullables?
Does the default case of varchar work fine for all other presto types not handled in the cases above?
Instead of defaultWriteObject, just handle it all yourself: oos.writeInt(hash); T object = this.object; byte[] buf = this.buf; if (object == null) { oos.writeInt(buf.length); oos.write(buf); } else { oos.writeInt(codec.sizeof(object)); CodedOutputStream cos = CodedOutputStream.newInstance(out); codec.encode(object, cos); cos.flush(); }
Please don't store the buffer in the object, it doubles our memory footprint.
If we can't get a model-set, will anything work? Perhaps this should throw an appropriate exception in that case.
Don't you want to test PUT and expect OK here?
Thats a bit hard to read with all of the escaping, maybe better with triple quotes or stored on disk/loaded into a JSON parser?
where is this used?
HiViATFShouldRequestForMEGAAdUnitVAST -> HiViBTFShouldRequestForMEGAAdUnitVAST IMHO :smile_cat:
I never knew you can do typeof(...) although it's a little misleading because typeof is not a function, it's an operand, adding () makes it look like it's a function. How about triple =?
![MAJOR](<LINK_0> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_1>](http://sonar-s4/coding_rules#rule_key=squid%3AS1166)
style nit: we don't use braces around single line blocks
Neat but violates coding style. Could you use the standard brace style. We use the standard android [coding style guide](<LINK_0>
Please remove isEmpty() check. Null check should be removed too, but the comparisons should be made null-proof.
Why ignore the epoch/cluster id check?
Please introduce _"delay"_ as a final field in GlobalSettings, see one row above.
we can do without remote JMX support for the embedded Jetty instance
should be called resources
should be called resources
should we do this assert on other list endpoints (I don't think I've seen it yet) also why do we expect 1 when we're not even passing a limit?
For loop?
should this count be parameterized?
Calling setProgress() with intermediate values shouldn't be necessary.
We don't align on columns.
FYI All instances of HardSoftLongScore.ofHard(1L) may be replaced by HardSoftLongScore.ONE_HARD,
Can we use the variable name "employee" in such cases? (Same for a above constraints) lamdba's don't have an explicit type written down. (It says "e", not "Employee e"), so for readability (most users start from one of these examples), let's use a full variable name. In general, in optaplanner-core only the following short var names are used: int i, Object o, Exception e.
Why do we return the parents name instead of the name we store a few lines above?
possible exception
Is this supposed to be <code>return "Bump"</code>?
Collections.singletonList
Collections#emptyList could be better.
Collections.singletonList
Please rename this layout file as well removing _new_api.
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Extraneous 'a'
Utils.validateArg(lowerBound < upperBound. . .)
let's explain this constant
filters method argument should be passed to isMessageInLogFile as an argument
Better to throw an IOException.
If logFileLocation.logFile == null, then the line above will throw NPE. In addition, no need to call logFileLocation.logFile.getParent() twice.
I think we should make this default value as -1, util we have benchmarks show 500 is in general good for most of applications.
This probably will be replaced by <LINK_0> ?
why Integer and not int ?
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
The agg function here should be adjusted to support the optional compression param like in the quantile version
can you explain why this change ?
Can we revert this constructor argument change for classes that don't implement ResultBearing?
buildStatement() could be called here, removing statementBuilder variable completely (if not, making it final could be a good idea). buildStatement() could also return a String, not StringBuilder. Same for other builders.
This should be a debug message. info is default level. info will flood the logs.
The orchestrator will pass down a connected client (i.e. it will have a layout ready) when it creates a workflow, why is this needed?
This needs a fragment tag, not a tag for logging.
Please extract Globals.prefs as a constructor argument (probably replacing PreviewPreferences) as we want to get rid of Globals as much as possible.
in case of switching, in my opinion it's better to us etry/finnally like that:  switchToIFrame(); try { waitForElementByElement(getInfoLink); //Opens new tab to Template namespace getInfoLink.click(); return new ArticlePageObject(driver); }finally { switchOutOfIFrame(); }  it's clearer in reading
Global listener catch each click. You don't need to log it.
You are logging already logged click.
@kujtimiihoxha Why not just "X-Netbout-Alias: %s" ?
@antonini Let's use Collections.addAll instead of having a loop.
this constructor can be package protected if it supposed to be used for test only
since we're going to remove the vm anyway, this can be replaced with: if (startingVms.remove(vmId) && log.isDebugEnabled()) right?
do we really need this in 'info' level? we have the log of run-vm..
Why not just simply "command.setVM(vm)"?
Can use your new method TimeHelper#parseLocalDateTime?
Since you now have ConcurrentHashMap, you could cimply do return patternDateTimeFormatterCache.computeIfAbsent(pattern, DateTimeFormat::forPattern)
While UTC is the good choice for epochs, here we should use GMT to comply with the spec. ![image](<LINK_0>
I think we should remove a pair of parens:  mSession = new Session.Builder(this, mApiKey, mSessionId).build();
I think we should add this datum to the frame and confirm that the session also successfully moves on (just to ensure the end-to-end is also still working)
Should it be possible to extend this Stats-class? If yes, this instance creation should be extracted into a method.
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
Remove entire wrapper finally block
Remove entire wrapper finally block
Let's make sure that no project uses this resolver. If there is a project using this resolver, let's throw an exception and tell the user, he can't remove the resolver because it's used.
This doesn't look like a recoverable scenario, should you be re-throwing this one? Or is there some default/fallback VipAddressResolver if the instantiation fails here?
Please check for null here using something like: java Assert.notNull(beanResolver, "beanResolver cannot be null");
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
As this operation is optional, just say it won't be supported because it's not mandatory.
Single if can be used here too
oops !=
We should just check for >= ICS instead?
I do not understand why is this template, I expect: public void put(VdcParameter param, Object value)
why is this return null??
What if type is not Class type?
Could you make this method protected? This will allow override it when needed
reset compensation?
Same here, making methods protected allows users to override them.
same issue
And this change should be reverted as well.
really minor, probably it can just return value to avoid integer boxing with Objects.hash or use Integer#hashCode.
please replase MojoExecutionException for a new generic DeploymentExecutionException
No Thread.currentThread.interrupt()?
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Do the suggested changes before getting @lejolly to review.
I think this has to go to the finally block, already after this.received = in;. Otherwise race condition.
Map<String, String>
I think the indentation is still a bit wrong here?
Try to line wrap at higher levels of the expression. e.g.  java verifyUserWarning(model, "involves:bOb", Arrays.asList(String.format(USER_WARNING_ERROR_FORMAT, "bOb", REPO)));
this method should return List<StorageFormatType>. the conversion to Integer should be done when using it.
assert name != null;
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Why is this file changing? I'm concerned that changing domain objects will have far-reaching effects. As well, there's no id that this.id can be set to in this method
brackets or nothing.
@tbarsballe has gone through and done a QA run to ensure closed writers return hasNext(): false (rather than thrown an IOException). Lets stick with that for consistency (principle of least surprise)
replace this with  @Override protected void initServices() { latoken = RestProxyFactory.createProxy(LatokenAuthenticated.class, getExchangeSpecification().getSslUri(), getClientConfig()); this.marketDataService = new LatokenMarketDataService(this, latoken); this.tradeService = new LatokenTradeService(this, latoken); this.accountService = new LatokenAccountService(this, latoken); }
why do we want to correlate cinder and managed block storage?
ooh! I ...Connector, here!
Don't qualify with HostJobStatus: return this == running || this == pending
you can fail inside of try block instead after db.execute then you do not need to have return statement inside your catch block; also you can use ExpectedException rule
Gary, I have this test like: java //INT-2399 @Test public void invalidInlineScript() { Message<?> message = new ErrorMessage(new ReplyRequiredException(new GenericMessage<String>("test"), "reply required!")); try { this.invalidInlineScript.send(message); fail("MessageHandlingException expected!"); } catch (MessageHandlingException e) { Throwable cause = e.getCause(); assertEquals(ScriptCompilationException.class, cause.getClass()); assertThat(cause.getMessage(), Matchers.containsString("No such property: ReplyRequiredException for class: script")); } }  And it works for me on both Java versions, as well as from IDE and Gradle. Also this fixes the Travis failure.
JUnit has [ExpectedException](<LINK_0> which I think works better than try catch statements. There are some examples in the Geode code base if you want some inspiration
Is it necessary to remove this setLocation on the child? I think this may cause a regression when docking directly from the palette.
I think you can write this as java tableColumnReferences.computeIfAbsent(accessControlInfo, LinkedHashMap::new).computeIfAbsent(table, HashSet::new);  This also avoids creating empty maps when one already exists.
Check everything with requireNonNull(...)
Use this(...)
requireNonNull
How about adding an UncloseableAggregatedMemoryContext that throws if someone calls close
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Rename "ann" to "rules", "rulesAnnotation" or something more descriptive.
Collections.singletonList
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Missing randomDiscard param.
Maybe card's bug: I think there should be two cycles (damage all first, then discard all -- as card's rules).
suggestion
This could be set in the constructor instead of checking this on every request.
Safer to call: getFirstHeaderOrNull("Signature") == null
wrong message
assert.NotNull ?
Please put ternary operator inside brackets.
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
Revert this line?
![MAJOR](<LINK_1> Make "applicableWithUncheckedConversion" a "static" method. [![rule](<LINK_2>](<LINK_0>
@vilchik-elena Suggested implementation to fix invalid cases such as x + 1:  Constraint numberOrBoolean = Constraint.NUMBER.or(Constraint.BOOLEAN); Constraint firstConstraint = firstOperandValue.constraint(state); Constraint secondConstraint = secondOperandValue.constraint(state); if (firstConstraint.isStricterOrEqualTo(Constraint.STRING) || secondConstraint.isStricterOrEqualTo(Constraint.STRING)) { return Constraint.STRING; } else if (firstConstraint.isStricterOrEqualTo(numberOrBoolean) && secondConstraint.isStricterOrEqualTo(numberOrBoolean)) { return Constraint.NUMBER; } return Constraint.NUMBER.or(Constraint.STRING);
![MAJOR](<LINK_1> Change this comparison to use the equals method. [![rule](<LINK_2>](<LINK_0>
1. I wonder if this class can instead be made an util / or a function. 2. Should we return an Immutable collection or a copy here? That way, external callers don't mutate the map, and this class is immune to those changes.
This also seems kinda pointless and a bit brittle. Just return resource.
How expensive do we expect calls to the ExternalResourceDrivers to be? I'm just wondering because here we retrieve the ExternalResourceInfos for every task, independent of whether they need it or not. I think I would prefer that this feature would not add additional costs for tasks which don't want to use it.
same suggestion about static comparator
And this should be able to use the static comparator to be a little less full of (((())))(
and using comparator here
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
Missing finals for all tests in this file
Is it please possible to add a reference to the upstream jira in the assert message?
super.containsKey(key.toLowerCase()) ? given ConcurrentHashMap already provides containsKey
Missing @Override annotations?
better to cast to string instead of using toString()
Not sure if vm can be null, it is already locked.
what is the new behaviour now that you don't setSucceeded to true ?
minor: move the else up on line, together with the "}"
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
The innerIterator is not thread-safe, meaning if two threads access next() in parallel, they may get junk. By synchronizing the wrapper, only one thread at a time gets through to the inner interator, other threads are blocked in the wrapper until the thread inside is done. That way, this method returns a thread-safe iterator.
I'm not quite sure what I'm reading here, but shouldn't there be a few more methods overridden here? ie nextIndex, hasPrevious, getPrevious, previousIndex
This is the only place that add entry to the pool, is it the only way to fill the pool?
do we need to ask service for current user role? cannot Principal be added as a method parameter?
You already did the binary search, you could use the returned insertion point to avoid sorting.
remove extra line
there is only one operation on this variable, please use: new ArticleContent().push(redirect, MercurySubpages.CC_REDIRECT_SOURCE_1);
can we give different name to this variable? it is meaningless
An exception without any messages or stack traces.
Might be out of scope of this PR. If it is, please feel free to ignore - but we are doing nothing on exception here. A message or stack trace?
formatting
I think this will fail if the new size is smaller than the current one. Could be checked with an assert (private methods).
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
What are your thoughts on  hdf5.Group thisGroup = groupArray[i]; thisGroup._close();  ?
No need to define "throws IllegalArgumentException" in function. It extends RuntimeException. public List<String> getAvailableSearchFields(String opac) {
Redundant assertion
You are opening a stream but closing it inside a other method. Is this a good way? Would it not be proper way to open and close a stream inside the same method?
weird indent (and some others @Overrides and throws)
1 and 21 should be static final constants from the TACmiMeasureType enum.
extract 99 and 10 as a final static member constant
Coding conventions: Let's have the @Override on its own line please
What about String commandName = null; if (forceRemove) { commandName = "GlusterVolume.removeBrickForce"; else { commandName = "GlusterVolume.removeBrickStart"; } JsonRpcRequest request = new RequestBuilder(commandName).with ?
Same for detach
Declared exception from update method can be removed as well as this try-catch block.
Utils.validateArg(lowerBound < upperBound. . .)
Are you actually using this anywhere, or are you just adding some flexibility "in case"?
public constructor in private class should be package level constructor.
Does this need to be public? It seems to me this would only be useful to call from subclasses, so it could be protected. Shouldn't we make it final in a 1st iteration or do you have use-cases that need to override it?
Isn't the coding convention like: omit "this" when it is not needed ?
Please, move this test to createTable.sql. SCRIPT TABLE TEST1 output is not too big and I don't see any reason to use custom checks for presence of substrings.
Just to check, is there anywhere else in this file where we edit the visibility of the question?
Nice way of combining tests so we don't spend (too much) more resources! Good workaround since it is a little challenging at this point in time to test this at the Javascript level (which we should actually).
I believe that many AsyncKTR's can share a single HBaseClient, so it should be 'owned' by the Kiji instead of being shut down here. Let me know if this isn't a clear explanation.
Is there already a function like this another IT? If you can find one, please use that one
why are you using old methods instead of new CTF
Does this need to be public? It seems to me this would only be useful to call from subclasses, so it could be protected. Shouldn't we make it final in a 1st iteration or do you have use-cases that need to override it?
and the array would be of size 3 if it did...suggest to use a bytebuffer
I think this method can work just like set(). You complement the intMask with ~ and then &= it.
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
The version check should come before the call to loadTemplates().
when is this used?
You are still programming in Javascript here. :-P What about replacing "" with null here and remove "" from the variable declaration?
the part where the pmwVendor fields are updated could probably be extracted in a separate method
Is a plain "else" block also needed here to at least log the cases where no PaymentWorks processing is needed?
the else is not really needed here since the code after won't be called if the if condition is true and the method returns.
blocking calls inside the SDK are not good. they can cause deadlock, perf hit, etc. We are not doing blocking calls anywhere else.
where are we doing the initialization blocking call now? If the global endpoint manager is not fully initialized with first databaseAccount fetch could this return null?
assert get account null
Consider a case where user entered a single quote ' in streamName, then the sql query can give a syntax error and the app will crash. I think it'd be better if we use ? in sql query and provide [arguments](<LINK_0>,%20java.lang.String...)) in queryRaw.
Can the constants embedded in the strings be extracted to class constants or if they are already defined in other objects be references to the existing definitions?
this whole tests needs some cleaning up before we merge it back. i'll look into it
Remove extra empty line
This got out of sync when I reverted the WFCORE-307 fix. The correct property is "jboss.as.test.disable.runtime".
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
You could also use path.endsWith("/")
use existing constant
In my opinion it is not a right place to show internal representation of subscription name. It will be better to do something like: new SubscriptionName(subscriptionName, TopicName.fromQualifiedName(topicName))
Should be "InstaPost" actually.
virtualColumns and descending go in different order elsewhere in this class
There are no backward compatibility concerns in toString(), please change the key.
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
This causes a compiler warning, please either suppress it or remove the exception throw entirely. Warnings in snippets cause noise during the build process so we can't submit patches that introduce them.
This is a bit of a nasty if-statement. Maybe add a boolean "notNull": boolean notNull = text != null || arrow != null || ...; Then just add the notNull variable to the if-statement.
This is another behavioral change that I don't want to see in an unrelated PR.
Empty line, also it could be better with more fields (use your ide toString generator).
Would be better to return "JDBC:" + dialectName.
You already log an error if JNDI lookup fails, as part of getAuditLogger() -- do we need this else statement?
You use this exact log message in the AuditLogger class, do we need a statement both places? If we do, can you make the message here (or in AuditLogger) more specific?
Any logging that is just "begin" and "end" statements should really just be trace. Apply to all subsequent uses in pr.
Perhaps create a named constant for the interval since it's in the asserts for several of the new tests
why? let's format it properly, it was ok before. annotations and method definitions on different lines
Can workspaceChatStatus be null? If it can, this should have null check.
This is redundant in Mockito 2
I see this code is same as the one in earlier test, so it can be extracted for easier read, with just return value as parameter.
use Version.v3_4
ObjectUtils.objectsEqual(a, b) may help here.
There is no use for the return value of this method. please change it to 'void'
This validation is not required. You can expect the brick name returned by glusterfs (and consequently vdsm) to be of the correct format.
Hm, I suggest to extract timer-specific code in updateController method into a separate method, for example: private void updateController() { this.controller = modelProvider.getModel(); } private void updateModelTimer() { // rest of code from original updateController method } If I read this correctly, we need to execute timer-specific code (i.e. updateModelTimer method) on each refresh rate change via GUI (i.e. setCurrentRefreshRate method).
this will crash on non UI thread. Please simply use Display.getCurrent != null.
Also, NO_CACHING isn't invalid is it? It just means... no caching?
Why not <code>return ExitStatus.COMPLETED</code>?
This line will always evaluate to false as we are comparing ExitCode with String?
I am thinking if we could make this more readable by using StringBuilder to append. Something like this:  sb.append("Processed: ").append(processedCount) .append(", Active: ").append(activeCount) ...
We could probably use getItem() method here, for consistency.
an empty catch clause is not very fancy in our code. please handle the exception if it is caught and think about side-effects this code can have.
This is acting like these requests succeeded, is that the correct thing to do?
Magic number. Please run checkstyle/pmd/findbugs and fix all violations.
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
could this be 8? the size of a char?
remove or assert ;-)
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
So how about set to 10? ;)
duplicate assert
The name is very confusing, assert equals seem to indicate it should take 2 parameter and make sure they are the same. I know you mean to assert symbols from Expression and RowExpression are the same, but you really can't tell from here. Maybe just call this assertSymbols.
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
Exception propagation. No need for subsequent return null
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Make this as a log.error statement. And needs to have space after the ","
We definitely need more details about what is invalid about the configuration (e.g. which keys are missing)?
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
Same as consumer. If parameters are null shall we throw exceptions so that deployment fails with required message?
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
I would move this to a constant so we can access it from tests as well.
Add reasonable toString() method, returning null doesn't seem as proper way.
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
Set the httpclient in pipeline instead.
Just style, but I like wrapping conditionals in () for this statement. In my view it improves readability in the ternary operator that is already somewhat tricky.
Why don't you pass the message in the annotation?
Replace with: return index >= 0 && index <= this.actions.size(); No need to return a boxed boolean
This has several formatting issues
Please add ? and % as well
unnecessary array new: {{true}, {false}} should work here
unnecessary new Object[], and there shouldn't be a space around the contents of an array initializer, e.g.  public Object[][] getLinearIndexFactoryTypes(){ return new Object[][] { {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed")}, {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed.gz")} }; }
Why the change? This does the same thing as the original code.
I believe the return value of System.getProperty("os.name") should be normalized first using:  private static String normalize(String value) { if (value == null) { return ""; } return value.toLowerCase(Locale.US).replaceAll("[^a-z0-9]+", ""); }
if you want to make this code more efficient, you can go for something like  private static final boolean IS_WINDOWS = System.getProperty("os.name").startsWith("Windows"); public static final boolean isWindows() { return IS_WINDOWS; }  That way the check happens only once at class loading and initialization time. Since we do not assume that we change the OS underneath a running JVM, it should be fine ;-)
suggestion assertEquals(1, IOExceptionOnOnlineListener.onOnlineCount);  I suggest following the existing pattern in this file and calling the assert() methods directly. Then the new import also wouldn't be needed.
Shouldn't this be using the builder pattern?
Failure message, please.
I dont think you need the RocketMQ version number in the name here.
Please use more specific JSON type names.
This is not commonly used in Druid, can the subtype registration be kept as per prior? If you want to keep names and class registration together you can use com.fasterxml.jackson.databind.jsontype.NamedType.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Please catch specific exception(InterruptedException) not generic.
Why do we need this method? Wouldn't be better to merge this one with getLatency()?
nit: same here about reversing if-else. I think PMD complains about it btw
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
nullity check here too :)
nullity check here too :)
Should this comparison be !Objects.equals(guestCpuType, value) ?
I'm more for json and something like {status: 500, message: <message>}
Was this detected by findbugs?
If the invokeMethod call fails then the implementation needs to know so that it can keep retrying the afterLRA notification.
may be try-with-resources?
You only want to use closeQuietly() on an OutputStream when an exception already occurred. Otherwise you mask exceptions that happen during a close(). Those should be treated the same as exceptions during write() calls.
Files.move(from, to, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE); I would pass both parameters for the first try.
not related to your changes, but it looks like this field is not used anymore.
This constructor was not set as public for a good reason. Better not change that visibility and use a different constructor instead.
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
Perhaps we should explicitly prevent nulls here (and for password) Misc.checkNotNull(username, "username") or whatever exact syntax it is?
HQL/JP-QL
Actually, I'd recommend initializing principals using Collections.singletonList(SimplePrincipal.newInstance(username)). The resulting list is immutable and an efficient implementation.
return HConstants.EMPTY_BYTE_ARRAY; ?
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
40?
This is wrong. We still need to use the folder name for equality checks.
This isn't a valid implementation of equals. You can have non-equal things have the same hash via a hash collision.
this is just white space changes right?
Iterate the return value, no variable needed.
rename to iu
artifactId is not enough... groupId and packaging must match too
Should there be a ITimeLineEvent interface?
I'm a bit worried about how gaps will be handled, with this implementation we have to make sure that no dummy event is added for gaps. Also no NullTimeEvent allowed. Maybe that is OK? Or better to just ignore them?
Do we have any threading concerns here?
This this. should no longer be necessary here - could you please remove it?
You should be able to remove this. here.
This is unnecessary
We should just check for >= ICS instead?
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
should the interface not the implementation suggestion public List<String> getTopics() {
new ArrayList<>(causes);
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
I don't see any change that is related to elapsed-time, why is this change needed?
Why not just simply "command.setVM(vm)"?
super.getVm() will do dao call...
result -> results
Let's convert to a RegistrationFieldType here so that anyone who uses this code can work with the nice enum instead of strings. It'll simplify the activity code.
These lines can be optimized to return fieldType != null ? fieldType : RegistrationFieldType.UNKNOWN;
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
return a copy of the data to keep DataExtension immutable.
Please check that the data buffer has at least 2 bytes to avoid a NPE.
these setters should not be public
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Missing StringUtils.isNotNullOrEmpty() check
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
Let's implement this in pre listener. Also need to implement doPreSetUserClaimValue()
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check for the presence in the list of the low-level permission like WriteProperties which are the ones actually checked by code in AbstractSession.
wouldn't it be better to return List<File> here ?
wouldn't it be better to return List<File> ?
do not expose the list directly
I think you can make the ResourceLoader a static class variable as creating an ResourceLoader can be expensive.
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
I would suggest reverting the isSytemLibrary field back
IMO we should still throw an Exception here after logging the error - failing the deployment seems OK to me, as long as the user can find out _why_ the failure occurred. (If these values aren't specified, **the function itself won't work.**)
Is this still needed after removing the download stuff?
Why fakeThread
I still feel this is hacky. I would rather have either a different endpoint for block indefinitely requests, or a flag you can set in LockRequestV2 itself.
this snippet feels like it should be a static method that you factor out and can use here and in the above method, like private static Set<LeasedLockToken> leasedTokens(Set<LockToken> tokens)
Please revert if possible
Done in: <LINK_0>
Add "this" qualifier
once again, equals/hashcode - does it make sense? please revisit in all value types you created
Is it intended to not compare the size of the stack here? (FluidStack doesn't take size into account normally for equals, though it does for hashCode)
Is this meant to compare the item stacks beyond object equality, given ItemStack does not override equals *or* hashCode
How do you know that tableName is not, itself, an SQL injection attack?
Need to use UUIDs instead, for performance. Nit: can be final.
if getSessions(Arrays.asList(sessionId)) returns empty list you'll got NoSuchElement exception here. May be we should return null in this case ?
Overdid: if null, return null :smile: From other side it can't be null. See ctor:  Assert.notNull(inputChannel, "inputChannel must not be null");
this. on method calls? I guess you have just moved those existing setter over here for better class structure. Nevertheless can we fix this. as well since we are already here in a change?
hld can't be null here
remove this line
It seems this given statement is not necessary anymore.
also this one seems unnecessary
Why only adding it to the active window and page?
missing braces
What if getStatus return ok, info or warning? You are not supposed to know that Status is null when everything went well. Perhaps, you can add "|| ...getStatus()<IStatus.ERROR
That does not seem right ;-)
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
It would be good to use constants instead of hard coded property names. Maybe you could use KFSPropertyConstants.BUILDING_NAME constant instead of "buildingName" or add new constants to CuCamsConstants.java
What volume of vendor numbers are you expecting this method to receive? For smaller volumes, the current setup here should be fine. For larger volumes, though, it may be more efficient to build a query like the following (but in OJB Criteria form instead): (VNDR_DTL_ASND_ID = VAL1 AND VNDR_HDR_GNRTD_ID IN (VAL1A, VAL1B, ...)) OR (VNDR_DTL_ASND_ID = VAL2 AND VNDR_HDR_GNRTD_ID IN (VAL2A, VAL2B, ...)) OR ....
@sbespalov : Unless you intended this for debugging purposes, I think it sounds like a reasonable suggestion.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Redundant with the e.getMessage? May be something like "Wrong class path: e.getMessage"?
Would be useful to move to SpinnakerException family for all exceptions. There's a number of places in the PR that need to change beyond this one point. Also happy to explain this (or doc if I haven't) why it's beneficial to do so.
The base class shouldn't know anything about expired tokens.
please extract as separate commit
CI build shows 90+ failing tests, and they all appear to be caused by this change. Perhaps some of the other converters are lossy as well, and some of the failures appear to be for objects which do not have hashCode and equals methods defined, so the comparison fails because we have distinct references before and after deserialization:  junit.framework.AssertionFailedError: <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> vs. <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> expected:<com.thoughtworks.acceptance.AttributeTest$Camera@50d640dd> but was:<com.thoughtworks.acceptance.AttributeTest$Camera@447bf09d>  Also one small nit, I would change the spacing to make the failure messages a bit easier to read: suggestion assertEquals(xstream.toXML(expected) + "\n vs.\n" + xstream.toXML(actual), expected, actual);
I might miss something, but assertEquals for arrays is marked as deprecated and assertArrayEquals is the recommended replacement.
We may not need this method and can use gatewayResponse.getError().map(s -> s.getMessage()) instead in CardCaptureMessageProcess
would prefer to make the conversion from exception to SerializableError symmetric in ServiceExceptionMapper and JsonExceptionMapper
This seems redundant. notifyError(ErrorResponse response) doesn't care about ErrorResponse object, it just unwraps the cause. I think existing version is better, no need to wrap/unwrap.
It would be better to move this debug message to RepositoryStreamSupport#doClose or RepositoryStreamSupport#close
Presumably you'd want to return here a read-only view of mappings.
I'd move this method to the end of the file, so that order of declaration corresponds to use as createOpenAction -> getSelectedPaths -> getRepositoryPath.
Have you looked at class HashCodeBuilder from the commons lang library (that we use)? It helps you build a hashcode, and its append() method supports null so it does not require any explicit testing. It should let you do something like (untested):  java return new HashCodeBuilder().append(uri).append(title).append(description).build();
events can't be null
permissions can't be null, otherwise the constructor would throw a NPE.
for me it's too long. Maybe Result.wrap() ?
Static import?
Maybe it's better to use LOG.debug("Failed to find subscription: {}", subscriptionId, e); to avoid unnecessary string concatenations.
Not needed, delete.
progress.split(1) ? Interestingly, the counts seem to off quite frequently. Here only 2 of 3 ticks are consumed. I wonder if that was intentional?
Is this the correct monitor to do the "worked" on? I missed this in PS1 review.
instead of e -> e there is a Functions.identity()
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
endless recursion? should it be org.apache.dubbo.common.utils.UrlUtils.parseURLs(address, defaults).stream()?
setIsBatHanging(!awake) for same reason as above
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
I do not know much about databases but whether this method is properly constructed? My Eclipse returns "This method must return a result of type boolean" and I can add return for firstRun of false.
suggestion return this.connectionPool.getNumWaiters();
Use Assert.fail instead
All the other throw new RuntimeException should be changed to Assert.fail as well
Should also be externalized
There are two 'additions' groups, this one and another before the align action. One should probably be changed. I wonder if those two TmfView common actions should be in some same group, with 'additions' group separator added after, for all the subclass actions in that group?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Can we move this isAdded() check back to the top of the function? I recall that we placed it here to prevent a crash (that we may or may not have reproduced), and I'd rather err on the side of caution.
truck is unused
check for READ_ONLY style is missing?
Ternary if?
Style: bump closing paren to next line with no indent.
Also check data type, should be BYTES. Same for other classes
Is modified always called and you do not need to to process the config in activate() at all? I didn't know this, that makes the implementation indeed easier :-)
use namespace instead of DEFAULT
why not an empty map?
I haven't looked at messages.properties, but this seems like an odd message code. (Other?)
You don't need the else clause, it is redundant, just return null
This is not correct, orderGroup and sortWeight need to be copied too, this should stay unchanged instead you update Order.copy to copy over these fields too
Logging.
one param per line and leave the first line empty
You need a CachingInputStream in order to make cache work.
s/possitive/positive/
Should these items be copy constructed opposed to rewired?
Please copy on construction for primitive arrays.
Please remove an excessive space character.
Can make this into a singleton as we have with UNSET.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
this method should be defined in Menu interface
Bad code. Remove try - catch.
Not clear why AIDL_LAYERS_PREFIX here
use an overridable getOperationTimeout() method instead
How about using snaeService.wait(500); instead and calling notify(); in the event handler?
For a lot of the uses of this method, this should be context.getServiceRegistry(true). It doesn't need to be for the getService(context) != null checks, but for the other ones if the handler is changing any state it should be 'true'.  * <strong>Note:</strong> It is very important that the {@code modify} parameter accurately reflect whether the * caller intends to make any modifications to any object reachable, directly or indirectly, from the returned * {@link ServiceRegistry}. This includes modifying any {@link ServiceController}, * {@link org.jboss.msc.service.Service}, {@link org.jboss.msc.value.Value} or any object reachable from a value. * * @param modify {@code true} if the operation may be modifying any object reachable directly or indirectly from * the returned {@link ServiceRegistry}, {@code false} otherwise
Similarly use the Java 7 template
Probably enough to have Longs.hashCode(pointer) which should be a little faster.
Instead of the Guava Objects.hashCode, use Objects.hash instead. It is available since Java 7, and reduces our dependencies to Guava (furthermore, this method is not available in Guava 21 :) ).
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
@hmcl I think issue pointed out here is the loop that we have to go through all the types for every request? . Is this only for queryparams? or are we trying to find type in other cases too? . If its query params wouldn't it be safe to assume the values could either be string or int
unnecessary boxing
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
can't this be an ObjectArgument.of?
Collections.emptyMap() would be better for performances (not actually created a new object).
can use without "== true"
could return Collections.immutableList(logEntries)
i am a little concerned about how often this is going to be invoked. It seems like a huge waste that most of the result would be thrown away.
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
suggestion throw new UnsupportedOperationException();
I don't see the point of having a cancel action in a subtab.
Why not initialize them at construction time instead of lazily on request?
How does the deadline in Context set by user? It seems to be harder to track where the deadline is coming from.
Keep the config useTimeout == true? then we know it takes precedence over config.
Why returning an unmodifiable map? The returned map is a new instance generated in this method. There should be no other reference to it except for what returned from this method. Returning a modifiable map would also save us from converting back to a modifiable map in getTaskManagerLabels and getConfigMapLabels.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Remove
do we need to return the whole stack as the result? that seems a bit much to the user. how about just the message as before and log the exception?
have the result of errorTypeLocator.lookupErrorType(retryExhaustedException) already available during initialization , to avoid doing the lookup fir every handled error.
why is this return null??
This is just delegating to getNext. Maybe we can put getNext code here, since it's the generate value logic.
Can make this into a singleton as we have with UNSET.
extra line
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
I am not 100% convinced if this would be a trace info. We probably won't need this information to debug the internal work flow, but whenever this information is needed, there should be some error (or complaint from users). So from logging perspective, it more looks like an error.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
I couldn't understand the need to get templates config and set it back again, is this required?
this section is copied in several tests, maybe it would make sense to factor it out into a helper method
Just pass null as a parameter without variable (here and below)
Asserting the actual message isn't a good idea because this could be localised or message changed which would break the test.
Not your change, but just noticed this should probably be changed to ExpressionTimeoutException instead of depending on the message.
this...
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Note File.toURL() is deprecated and known to cause issues (though I don't quite recall which ones). The recommended way to do this is through File.toURI().toURL()
if those lists are intended to be empty list (and not be modified by the client) the always return Collections.emptyList()
better cache this to avoid multiple db queries
while on it can you please rename v to vm ?
Should mark @Nullable here.
This method seems weird, especially in a context of ValidAggregate. Let's discuss it.
This should return the list of resources under it, see FileResource impl for more details
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
Is there a way to do that waiting for an event to happen instead of fixed time interval?
use finally
just inline this. ex. if configuration.getPercentage() is mutable config, make a final copy. This code is simple enough that it can be inlined, and there's no reason to require an allocation or another type to do this math.
this is dodgy with the default state backend because people may not have cleared their local span and all of a sudden the traces start having random local spans as their parent. I'd make an internal flag that's set when the state store is InheritableServerClientAndLocalSpanState. Only when that's set accept a local parent. While seems yakky, this will insure existing users against the behavior change I mentioned. It is super confusing to try and debug spans that have the wrong parent, speaking from experience!
This method is a simple converter that is only dependent on frequency and not dependent on clock offset. It should return nanos * clock.getAntiScale(), or nanos if clock is null.
I would not create anonymous class here to only add the item. It can be done with less and more "standard" code.
maybe this should no longer be named pliList
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
Is this change related to updating apache velocity?
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
That would create a warning. The only safe way to do that is casting from the caller.
From the wiki: Its fuse lasts 40 redstone ticks (4 seconds/80 game ticks) if activated by redstone or fire, or a random number between 10 to 30 game ticks (.5 to 1.5 seconds) if it's destroyed by an explosion. In other words, right here the number of ticks needs to somehow be passed down to the explosion objects (setFuseTicks). My recommendation is to add an overloaded method to explodeBlock that accepts a boolean: blownUp (name is just a suggestion). If that boolean is true, this 'random' tick count is applied, otherwise the standard is used. I would almost go as far to say that the boolean should further propagate to the explosion object that holds the fuse ticks so that magic numbers aren't all over the place.
For sanity, else throw new IllegalArgumentException("insert message"); with the proper formatting :3
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
I would change this test to ensure that the default columns are present, not in a specific position. so, something like: assertThat(cursor.getColumnIndex(COLUMN_ID), is(not(-1)))
I think you need to do separate request to the db to retrieve all cars of this person
This check is redundant; the projection in the query is just 10 lines up and there's only one column.
what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
Lol! I just realized this message has always been incorrect. If a user's rule is configured as: xml <rule name="MyRule" language="java" minimumLanguageVersion="8"> <!-- Java 8 rule! -->  We are printing something such as: > Unknown minimum Language Version 8 for Language 'java' for Rule MyRule; supported Language Versions are: java 1.3, java 1.4, java 1.5, java 1.6, java 1.7, java 1.8, java 9,   So, a user would understand, that instead of 8, they should write java 1.8 as: xml <rule name="MyRule" language="java" minimumLanguageVersion="java 1.8">  which would not be valid. We should probably just do: java language.getVersions().stream().map(LanguageVersion::getVersion).collect(Collectors.joining(", ")));  to produce: > Unknown minimum Language Version 8 for Language 'java' for Rule MyRule; supported Language Versions are: 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 9,
What is the purpose of cleanup? Clearly mention in java doc.
public
Better to extract local variable for URL to avoid noise from Sonar that we defer NPE calling the method several times.
It can be null?
names
All standalone instances of "--" should be pulled out into a constant (e.g., "NULL_DISPLAY") so that we have the flexibility to change the display value later.
Can you try swapping below two lines in DefaultBlockWorker::stop() instead of this logic?  // Stop heart-beat executors and clients. mResourceCloser.close(); // Stop the base. (closes executors.) super.stop();
It's good practice to not synchronize on 'this'. Using a private 'new Object()' as a lock is better defensive programming.
This and executor can be pushed into Distributer.
"%setup -q -n %{name}-%{version}" is the same as "%setup -q"
Reuse result of StringBuffer.append instead of using buffer local variable.
Use StringBuilder
Why is this file changing? I'm concerned that changing domain objects will have far-reaching effects. As well, there's no id that this.id can be set to in this method
This constructor seems redundant with the one above. Do we have any special need for it, aside from not having to specify survey? I'm concerned that if we update this class, we'd have to update 2 constructors instead of one. At the very least, we should make this constructor call this(label, activityType, ref, null) to avoid duplicate instantiation code.
use stripWildcard(refName)
events.isEmpty()
> flush() [](start = 4, length = 11) flush? #Closed
Add the expected events and the event in the failure message
return !sniDomains.isEmpty();
how about return unassigned.isEmpty() ?
Hmm obvious error here
Why do you we need to keep a reference to the activity here? This will leak the app. We should use mEditState array instead.
@droneboost use the activity parameter instead of calling the getActivity() method.
this is used for manual retry, so it should retry once immediatelly
No tabs please.
you don't need a try-catch here. You can simply use @Test(expected=NullPointerException.class)
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
> Use this.h.removeCallbacksAndMessages(null) instead. Done in Patch set 2
done for patch3.
Please keep this.cell near the related fields (previousFamily & cell count) below
Consider limiting the number of characters to 32, since there are no HTML entities with more characters than that and it would help to avoid false-positive matches. <LINK_0>
I think that double ternary operator here might be a bit confusing, maybe we can simply use if-else statement instead: if (progress < 70) { return "#669966"; } else if (progress < 95) { return "#FF9900"; } else { return "#FF0000"; } Also please consider extracting these colors into public static final fields, i.e. OneColorPercentColumn could use ProgressBarColumn.GREEN or similar constant.
No key for encryption? ;-)
why is it adding null?
Maybe just getActiveChannelCounter().inc()?
This line can be changed just to a return statement. It will have the same effect, but the DB call will be avoided. Similarly to UpdateVmCommand.java.
Remove this by returning null above.
Duplicate map keys (%s) are not allowed ?
Returning an empty string when an invalid position is passed could hide some bugs. What do you think about skipping this position check so an ArrayIndexOutOfBoundsException occurs if an invalid position is passed?
Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to do dimValue == null ? "" : dimValue Druid's handling of nulls and empty strings could definitely be better though.
These can throw NumberFormatException, may be better to catch and use a default (0?) value.
Why are we returning an empty array instead of just returning null?
unneeded else
Same issue here, double delete user.
merge line 76 and 77
can use Ds3DocSpecEmptyImpl here
cause -> e please
Is this for debugging?
You can write it directly notNull(subscriber).isApplicable(project); (Same with other places, with static imports)
This should return false if the method is declared with the default keyword or is static
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
json.toString().isEmpty can be very expensive. Just null check is ok
@yesamer Not sure about swallowing this exception that way: if we get here rawValue is expected to be a valid json, but if it throws exception, something bad has happened, IMO. "Given a json in String format, it try to convert it in a <code>JsonNode</code>. In case of success, i.e. the given string is a valid json"...: what would mean a "json in String format" but invalid json?
Since we are creating a fresh new index, we might as well add the "cts" field, so then later on we don't have to worry about updating the mappings via rest call.
copy.setFromOriginal(this); -- should use this here ?
defensive copy?
Same as above. I think something like  java return new ArrayList<String>(loggers.keySet());  is enough
Refactor getRoles() and getPermissionTypes() to return the array and construct the response object here since methods don't really need the root as param.
If the only parameter is the id, do you need to send it in JSON? Maybe just use an url-parameter and get it with params.getRequiredParamInt("id") so you don't have to worry about if it's not sent or if its not a number etc. Also remove the param getting out of the try-block so you don't wrap the possibly thrown ActionParamsException to a new ActionException spamming the logs.
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
spacing, code style
Thanks for refactoring the selection method! I think this makes things a lot clearer. In general the internal selection methods could be static though I don't feel strongly about this
You could extract this to a method:  .stream() ... .filter(tableSchemaMatcher(schemaNameOrNull)) .collect
synchronized can be removed.
can directly return the value.
Why this change here?
Change the second part of || to an assert (verify).
requireNonNull(arrayBlock? Or checkState?
Use more values, 4-10. See TestBigintType, TestVarcharType, TestBigintArray for ideas.
You could simply use getVdsGroup() if you extend VdsCommand
I know this is not part of your patch, but I think we should do this only if initVirtResources() had succeeded (in gluster+virt mode). So, what I suggest here is, if (getSucceeded() && vdsGroup.supportsGlusterService()) { setSucceeded(initGlusterHost()); }
I don't think a Cluster can be removed while the Host is during monitor, therefore the cluster should be not Null.
No if check needed, just always set the reference to null.
If this method is called before execute(), it will throw a NullPointerException
use Long.valueOf() instead of new Long() - always for performance reasons
40?
Please check that the data buffer has at least 2 bytes to avoid a NPE.
Can we confine this change to just the calculation of the MD5 itself?
This is another behavioral change that I don't want to see in an unrelated PR.
I would prefer to use String.valueOf(value)
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
why is this public now?
shouldn't we make this private. I mean, move AccountBuilder to this file and make this constructor private so that no one else can construct an Account instance apart from builder
seems like this could benefit from using your new flattened method (once moved elsewhere like I suggested) eg. for (plan : plans) { found = flatten(plan).findAny(p -> id.equals(p.getId())); if (found.isPresent()) {return found.get();} }
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Does this method need to be public?
Does this method need to be public?
Why do you have to check for null here?
Can be private and static.
not seeing the Locale.ENGLISH setup, also exceptions are not handled. is this intentional?
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
aren't you changing the behavior of the existing method? I feel like I'm missing something
Can just pass id and let Java autoboxing take care of it.
post-content__title
changing selector type may produce unwanted side effects in some legacy browsers (which used a lot for some enterprise web apps). So please move change from xpath to css to separate PR
please use String.format to concatenate strings
What is a public goal of this getter? I'd prefer do not expose them at all to avoid undesired mutation. I understand the point for expression comparison, but it seems for me we have to encapsulte equals logic to the Recipient class. I think it doesn't hurt to have an extra GC from the removeRecipient(String channelName, String selector). Or from other side we should check the type of MessageSelector to get access to its expressionString
May as well rename this to keep future confusion at a minimum.
Is this used anywhere?
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
should this be a constant as it is used below as well.
Recursively creating the hard links may be expensive as well. Do you know how much time it takes on average?
Same remark about the constant
This seems wrong
Shouldn't it be return !isFromWire();
how about to move line 439-441 to be before line 435 - not because of performance but to make it more clear that in this case we don't need the cluster version
so maybe I'm missing something then.. we're handling the case that the compatibility version of the cluster the VM is defined in is changed. if there is some custom compatibility version for the VM, then the cluster's compatibility version is irrelevant - the VM will always run with the custom compatibility. therefore, if the custom compatibility version is set, the method should return false. only if there is no custom compatibility version set then the VM is affected by the compatibility version of the cluster and then we should check if the new compatibility version of the cluster is different than the one the cluster that the VM resides in had before. no?
I think (or want to believe) that the .toString() is implicit when formatting, hence can be removed from here.
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
I'm not a lover of passing nulls to methods or constructors.. would another constructor without the contextId be better?
Again I would make the nestedClass final and make sure nestedClass is not null here with: this.nestedClass = PortablePreconditions.checkNotNull( "nestedClass", nestedClass );
I think it is better to throw exception
Better to use factorName.length() == 0. String comparison in Java is usually done using String.equals(String str) method to compare string content, otherwise == operator will compare object instance references.
There's no real benefit to doing this check, so you can get rid of it and just do this.comparator = comparator directly).
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
Why not throw IOException and let caller handle and log etc.
throw UncheckedIOException(e)?
That sounds right to me, although I'm not actually that clear on what this method does. What does the restore field that's being built here represent?
Where are we catching exceptions for invalid file contents and things like that? Currently it feels like they'll fail over by throwing generic exceptions that look like IO exceptions or other network traffic problems
This is an unintended grant of permissions to all users. If the owner doesn't exist, this should instead call throwIfNonAdmin
getGeometry call here is redundant, because OGCGeometry.createFromEsriGeometry(new Point(x, y), null) can't return anything other than point. Perhaps, remove it.
What's the behavior when the input is not between the min/max values?
I would static import quantileBoundsToArray.
if at all possible let's try to avoid introducing more mess:)
why do we want to correlate cinder and managed block storage?
ooh! I ...Connector, here!
socket might be null if an exception was thrown in sendToSocket catch clause.
We may also want to cancel our subscription.
there is no case in which httpClient become null, right ?
Should be a SamzaException with a message, not NPE.
requireNonNull
keep requireNonNull
Can you re-route this to the new API ? Then we avoid duplicating this code.
I would have expected a Collections.unmodifiableCollection here.
I believe re-routing this to the new API is cleaner.
These "duplicate" entries should no longer be required afaik, because @AddonDependency now adds an implicit dependency. Try it out.
I notice a bunch of tests that use camel-undertow have been switched to WAR. Are we now mandating WAR for any camel-undertow consumer usage?
@hkalina The host and port can be overridden with some properties, so this is not guaranteed to be correct always. Do <LINK_0> instead
I'm not sure I like the way it would work. You mean that before every request, I would have to call "login"? Doesn't sound very user friendly.
the ArrayList of languages to translated could be cleared.
We could throw an UnsupportedException here.
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
I think that the array access itself will perform this check for you and throw an identical exception...so I'm not sure of the purpose of performing this test here. unless, that is you will show more information in your exception method. (I'm happy either way)
I believe these 3 lines should be moved to BMT, it's his logic
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
This lookup is going to be expensive. Can we keep a second map from reviews to tasks to make it fast?
@prondzyn you can return numberth element of the collection
I would suggest putting a more sensible name for the channel name like "Review reminder", the name will show up in settings for people to toggle.
mNotificationManager can be null
as long as it's the same event id that's fine i guess, though i don't really see a problem with using just one. but i don't mind
s/Mac pool/MAC addresses pool
this should be the disk alias, the user won't understand much from the id..
Call I18N.getString(String) (there are no parameters in the resource messages).
Call getString(String).
Can be static.
Single letter parameter names make code harder to read. I would go back to something like grainDefinition.
"formats" is an ImmutableList, you don't need to synchronize on it directly to iterate. Here you probably want to make sure only one thread is modifying the time zones at a time though. I'd suggest putting the method itself synchronized instead, or using another lock at TimeGraphScale's level.
shouldnt this be a little against design of unit-test to assert one or another?
this seems to ignore the boolean removeVolumes parameter to the method
This is nice to see. We should have done this to begin with.
add this (also below)
@aunyks you should make expected a Set to begin with so you don't have to convert the return value of the describe method to an array
making it a sorted set would make results more consistent
Why an array? List<String> is just as fine
nit: rename _lookahead to _lookAheadDays
Let's keep the old code here or let's try to move this method in the IndirectClient?
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?
should we have an early exit if the trace is the same? I am asking, I don't know
openTrace() creates a new ITmfTrace object. If the trace was already open there are 2 ITmfTrace objects for the same trace. For each open trace there should be only one object of the ITmfTrace class. We will run into problems with coalescing of requests (coalescing of requests only works per trace). Also, I don't not sure what the TmfTraceManager would work properly if it has to manage 2 trace objects of the same trace.
"TmfTestTrace.A_TEST_10K" should be saved in a local TmfTestTrace variable, so it is not repeated.
we can just call repeat(" ", n)?
Why not String.format("%s -> %s", argument, result)?
Does TextUtils.join()[0] not work? [0] <LINK_0>, java.lang.Iterable)
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
Why can't you just return value here?
No need for super()
This conflicts with the commit message - either Uninitiazlied is OK, in which case the commit message should reflect it, or it isn't, in which case the check should be removed.
Sorry for missing this in the previous revision, but this method can be considerably simplified by simply querying only the active VDSs: protected boolean checkActiveVdsInStoragePool() { List<VDS> vdss = getVdsDAO().getAllForStoragePoolAndStatus(getParameters().getStoragePoolId(), VDSStatus.Up); if (vdss.isEmpty) { addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_ACTIVE_HOST_IN_STORAGE_POOL); return false; } return true; }
Please replace with getStoragePoolDAO() which exists at AuditLoggableBase.
nit: I prefer the other ordering for <= or ==, it's easier for me to read "n is greater than or equal to 0" than it is "0 is less than or equal to n".
This should use the new checkPosLength(int) method as well.
Same here, we need to have second delegate that doesn't seem to add any value.
lun disks removal can't fail actually in the execute part, as it's a simple removal from the db..but i don't mind having it for the future in case we'll add ops that might fail.
different audit message for the case only the key was updated is needed
Wrong message, you are removing vm from DB
String#split() is considered harmful. Use Guava's Splitter.on(";").omitEmptyString().trimResults() instead.
The dispose() could be called from a finally block, to ensure it is always called even if an exception occurs during the getText() (which is possible given that it may call user-specified code outside of our control).
Here, you have no excuse for not using ImmutableListMultimap, you already create a copy (with ArrayListMultimap.create(...)) and then make this copy unmodifiable. Use ImmutableListMultimap.copyOf(Multimaps.filterValues(....)).
Same as above LOG statement.
should we have srcBlockId and dstBlockId?
Not sure that the "" is the correct alternative? null?
tracef
trace
tracef
You can use the string overload when TypeCriteria is exact match.
We could also consider these 2 methods for the check:  org.apache.http.message.AbstractHttpMessage#addHeader(String,String) java.net.URLConnection#addRequestProperty(String,String)  Eventually, this constructor as well new org.apache.http.message.BasicHeader("Authorization", "Basic abc")
@m-g-sonar you can add parameters constraint as you require to have two parameters in line 66.
I think we need to specify the locale Locale.ENGLISH for SimpleDateFormat, to avoid a default system locale. Example failing to parse (simulating a German system locale): new SimpleDateFormat("dd-MMM-yyyy", Locale.GERMANY).parse("1-May-1994");
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
This implementation is certainly good enough, but I wonder if replacing it by a call to return fromParameterMap(Collections.emptyMap()) would communicate better that all parts have defaults, even if some parameters are given (next to being a bit shorter).
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists.
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
I'm not happy that this state-specific code is in generic method of the CircuitBreakerStateMachine. Maybe we can add a postTransitionHook or preTransitionHook to states which are invoked here in a generic form?
what happens when the connect() did not succeed or was not called, what kind of exception is thrown?
suggestion final List<String> lines = Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8);
equals != startsWith
dir.toPath() may throw InvalidPathException. Since it is an API method, it has to be handled and wrapped to IOException
ArrayList.remove() internally moves the positions of remaining elements and this will happen for every row in this case which could be expensive. Since parsedInputRows won't be large in general, I suggest to use an iterator on the list instead of modifying the list. java public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; }
We could keep track of the input watermark and emit the maximum at the end.
Does the code that caches the endpoint state (lines 258 through 259 above) execute in the next() case or only in the output consumer case?
this does not handle the case where actual is not null but expected is, which leads to a NPE, this case should be unit tested.
This actually isn't an optimization; Float.valueOf(float f) just calls 'new Float(f)'
This actually isn't an optimization; Double.valueOf(double d) just calls 'new Double(d)' Let's just remove this change. Since this class is deprecated, I want to minimize changes to it wherever possible.
Minor thing, I'd prefer using getSessionId() instead of accessing "restApiSessionId" field directly here, for example: String sessionId = getSessionId(); if (sessionId != null) { requestBuilder.setHeader(SESSION_ID_HEADER, sessionId); }
add non null validation
static import OBJECT, ARRAY_LINES ... ?
seems to be like this should be before the vm is unlocked in super.endVmCommand();
This should go
this is being called on a different flow now. is this intentional?
InputColumn is a raw type. References to generic type InputColumn<E> should be parameterized.
Fix the log
We need to additionally explain why the argument may be null and why it makes sense to return null in this case back as well.
Maybe we could have a method telling whether the repository is registered? In this way, the API would be much more consistent. TherepositoryFor is very strict and assumes the repository *is* registered, but there is no way to tell whether it is. So I would fill this gap instead of duplicating the API call with a very small lexical difference.
I think, it's better to transfer a method parameters and keep a name at a previous position.
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
getter
Suggestion: Make this private, since all clients of this class other than Jackson should be using getNonNullTimestampSpec(). Also, maybe rename this method to something like so that the API that's actually used has the nicer short name getTimestampSpec().
Missing final
what will happen after I will add new elements to enum?
The layout could be passed in the constructor.
git-compare-window-changed-files
nit, would 'bombarindUnits' be a more descriptive name here? Perhaps even consider inlining it to avoid the intermediate variable?
Returning the JRE units from getTemporaryAdditions is IMHO enough. This method can return an empty list. This means that a dependency resolution may e.g. prefer a bundle providing javax.xml over a a.jre.javase unit. IMHO this is okay: We don't care about EEs here, so we don't care about potentially redundant bundles either.
I wonder if callers could just avoid mutating the return value and/or copy as needed. If we can skip the defensive copy, we can have a performance improvement and simpler code in this class as a simpler getter would do.
np: s/LocalApplicationRunner/RemoteApplicationRunner
Does this need to be public? If you need in tests, could you make it package private and mark as VisibleForTesting?
Can we create StreamManager in the beginning of run() and pass it into the planner so the system admins won't be created twice?
Which method throw exception? why change assertThatCode -> assertThatThrownBy?
Please remove excessive empty line.
in this case asList(a1, a2, null) should be assigned to variable, and don't call build method
Can we inject this feature directly ?
null? why not just a () -> {} ?
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Should be "InstaPost" actually.
Lately I've been generating toString() with the "String concat (+) and super.toString() template in AndroidStudio - that way we'll get the Id field logged as well which can be pretty important for debugging
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
What is the purpose of this conditional?
Would change this to Objects.requireNotnull
Does this always run on the same thread? If not, it would appear we could lose the reference to a held wifi lock.
Shouldn't this code run even if mHasWifi is false?
Same here about the null check.
Can you make all of the accessors final?
can you make those no-arg constructor private?
Is this the intended message?
This is causing a compile error. The REMOTE_USER cannot be found.
Undertow handlers should never block. This can cause the server to hang. Instead the requests have to be queued somehow and replayed once the server finishes starting. Also I'm not really sure that a 404 is the right response if the server takes too long to start.
This should be !exchange.isResponseStarted(), the response content length does not really tell you anything, a lot of requests use chunked encoding which will not set it.
You can change the 28 case to a default case, and remove this.
Looks nice for me :)
This would probably work 90% of the time, but the value that should be tested against the current value is the response from 'asMessage(text,args).
huh this is creative, I've never thought to use an executor like this before
maybe print subId as well?
do you need to make it public?
The WFLY-1069 stuff should tie into this.
Just thinking out loud here, should we add a debug or trace log if the value was previously defined and is being replaced? Something like debugf("Value '%s' for key '%s' being replaced by value '%s'.", oldValue, key, value);.
ArrayList should be constructed with fixed capacity.
use { } around if body
Should we only validate if there is a cache hit?
Since total is used only once for int remaining = total; We can remove total and: int remaining = dst.remaining(); Then it's perfect!
Maybe you could split this assertion int two?
Are muting/unmuting video here?
are we sure & will be always appropriate here? (not ?)
You should be able to write @Test(expected = WriterException.class) and then the body of the test is just the line that causes the exception.
countDistinct
should this not be "Unsupported operation for Admin service"?
We should probably prefer setReference and setAlternate to be private (or protected if used by a child class, but I assume that is not the case right now).
Please bring the braces back.
Cosmetic: Too many empty lines all over. It makes sens to put an empty line before and after a logical block to make it stand out, but in this case, it looks like it's a bit too much. Would you mind removing these (here and in the other method)? Thanks! :)
I don't think we use final for functions in our code base
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Maybe 'cluster.hasRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
You may want to change this to checking if enum constants has content, since there can exist both enum constants and elements within a type. At least within the Java generation, I discussed it with Ryan and he determined that when both exist within the same type, the elements are actually descriptive of internal variables that are not related to code generation. Therefore, if both exist, generate an enum. Not sure if its the same for the C generated code
I don't understand why we need to perform sorting here. I expect that StudyEntryServiceImpl#getStudyEntries should return the entries sorted by entry number and in fact I see this code that's supposed to do that: // Return by ascending order of entry number. We need to perform cast first on uniquename since it's stored as string return this.getStudyEntries(studyId, null, new PageRequest(0, Integer.MAX_VALUE, new Sort(Sort.Direction.ASC, String.valueOf(TermId.ENTRY_NO.getId())))); Is it not doing that?
The empty string in the constructor is redundant.
This is a String so use final String id = THREAD_ID.get(thread) ; and then you don't need to do the cast on the next line.
This doesn't look right. Should be:  result = services.get(result.getId(), k -> this.serviceRegistry.findServiceById(id, clazz));  Also, don't forget to check the result to make sure it's has the correct type based on clazz
I thought format used "%s" and "%d"?
can we bring it to config level
Could you please change waitDurationInOpenStateMillis  to waitDuration
IMO old-style for-each loop is clearer here
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Not necessary. See quality rule : MITRE, CWE-397 - Declaration of Throws for Generic Exception
why are the throws on the next line?
Since leap-day/year-day aren't part of any actual month, you need to return the zero range
I guess if partition is empty this row throws IndexOutOfBoundsException.
Is there precedent in the library anywhere for using underscores?
If leafCount is still 1, how could it be two rack groups?
This is difficult to understand because there is no visibility of itemView. Is it _safe_ to cast it to TalkView? It's not easy to decide that based on this class. That is a smell that something is amiss - if itemView is owned by the parent class, then we shouldn't be modifying it direcrtly from a subclass.
what if something goes wrong here with SWT widget, e.g. gets disposed? It fails on exception - is this desired?
what if key is null. I don't see any tests for this. What's the reasoning for shallow copy of the map? This changes the result and possibly impacts people who assumed it would not be a shallow copy.
Maybe use this.value instead of getValue() here (and also on similar occurancaes)? Similar to AbstractSingleCatalogData.
fields of objects are typically < 10 say - iterating them is not a real problem. Also schema building is KN OWN to be a heavy thing they can be slower (where slower is not really slow) - So there are no perf savings to be had in schema generation as a rule That is not to say it should be terrible - but that when people come to us about performance its NOT in the schema gen side of things
For loop?
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
if fiddling anyway then maybe put it first given shortcut logic
I'm not convinced by all these _URN suffix. An urn is basically a string. And any IDE can tell you its type if really necessary. I'd remove them all.
1.0f -> enum
This is really really nice!
Why empty? It supports ALL streams!
make unmodifiable
There's no concatDeep, I guess..? ;-)
I think you can use By.cssSelector("#" + elementId + "." + targetClass)
Missing finals for all tests in this file
This is probably giving you a raw-type generics warning. Suggest replacing Class with Class<? extends InputKind>. This will create some ripple effects though that might be a little tricky... Since this is SDK-internal for now, I'll leave it to you whether you annotate this type fully.
This should not be changed, you should only be changing search methods
Since this block is used twice, perhaps pull it into a private method?
Seems like this should be more defensive, i.e. check for the type before casting.
I don't think it is right to return always return true for two different AuthorizationContext instances.
Why not just do this instead: return obj instanceof DueDateAmountMap && innerMap.equals(obj);
Why U don't want to consider id in equals and hashCode ?
Should this be in line with YEdit's spaces-per-tab preference?
@tfesenko Does your "1" hear assume that the line delimiter will be LF? I'll test a CRLF scenario in QA.
this again will throw internally BadLocationException on -1.
no need to break lines here?
this needs to be resolved. the plotting is important.
I wonder if we should have "ok" final state as well?
just inline this in the enum? java public enum Category { CONFIGURATION(Messages._ManagementLink_Category_CONFIGURATION()), SECURITY(Messages._ManagementLink_Category_SECURITY()); //..... private Localizable label; Category(Localizable label) { this.label = label); } public Sting getLabel() { return label.toString(); } }
Can be static
Extract result variable.
not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true? I see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?
Should be given/calculated
could this be 8? the size of a char?
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
This is confusing. We have no internal value of system_server. "No valid system_server to be checked" makes it sounds like it's a device side thing
is this check correct? mModuleStartTime != null If it's null, means TF hasn't trigger it to reboot, right?
since this Bindings needs configuration through openhab.cfg setProperlyConfigured should be called after the configuration has been read and applied properly (see method updated()
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
Why we should change behavior for the deprecated method?
The method implements synchronization via  lock API, the synchronized seems redundant.
I'd vote for java private <T> T getConfigurationValue(String fieldName, T type) { return (T) invokeGetter( ... ); } getConfigurationValue("sourceRoot", String.class);
out of curiosity: what meaningful exception could possibly be thrown here ?
inline
No necessary. + operator with a string operand (the prefix) performs auto-stringification of the other operand.
Could be bundles.values().forEach(this::registerBundle)
Should null check, anytime you encounter a boxed value you always have to null check.
messages claims that integers were expected while they where checking longs actually; some rewording would be nice
Possibly compiled away, but + 'f' ought to be more efficient in principle.
This can still return HistoryReferencesTable.
I think we should consider the case sensitivity here.
public, same for the other one
If user have used our listener in most common way (ethereum.addListener(new EthereumListenerAdapter(){})) he will get strange exception here, I guess.
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
The methods to add or remove a listener are usually thread-safe in Smack. This is not the case here.
isn't the currentRow the instance of RowBuilder which was just added?
The chance of creating a row is high, why don't we just create the builder at the beginning? if (lastResponseProcessed) { // illegal state exception ??? } RowMerger builder = new RowMerger();
> Sorry @javornikolov but I didn't understand what you would like to test. These are all the rows that exists in query 2 but not in query 1, so they all are marked as error (missing) and are chained to each one, and the first is chained to the last rows processed. > How can I help here? Sorry. I think I described it the other way around. I'm testing with following and I'm getting only 1 missing row, when 3 are missing:  !|Execute|create table TESTTBL (N int, TWON int)| !|Insert|TESTTBL| |N |TWON | |1 |2 | |2 |4 | |3 |6 | |4 |8 | |5 |10 | !|Store Query|select * from TESTTBL|q1| !|Store Query|select * from TESTTBL where n in (1, 2)|q2| !|Compare Stored Queries|q2|q1| |N |TWON?| !|Execute|drop table TESTTBL|
you should not compare two Strings with "!=" or "==", use equals methods instead or if both strings can be null use org.apache.commons.lang.StringUtils.equals
call By in the getElementText method, not here
The same observation that in the previous test case. May be is not neccesary ask here if the room is available
Sorry, I suppose I wasn't clear. I meant that using == below would mean this check for null 'eref' and returning an unexecutable command would then not be necessary and could be removed. The idea being that perhaps the superclass would be able to do something useful (for example, look for a suitable reference and try again). So, let's remove this null check and see how that works.
why call super here if the first return is call, gmfCommand will be never used. More the gmfCommand will be always null. It's not necessary to call super. Just return the unexecutable command in case of proxy or null: return request.getTargetContainer().eIsProxy()?UnexecutableCommand.INSTANCE:null should be enough.
What is about the null's here?
you don't need use replaceAll, because above you used normalizeJson
Nitpick: promote magic literals to fields, construct body field with reference to them.
Please don't return from if branch and reduce code duplication between branches
method reference here as well -> anywhere we are calling a static method can be replaced by a method reference
create a member for ClusterServiceModel
Since the VM subtab always uses this query, I would encapsulate it inside VmAffinityGroupListModel and make its constructor no-arg.
Why is this method parameterized?
I think this whole method could be replaced with Guava Iterables.size()
all these util methods should be private.
Should be "InstaPost" actually.
Looks like this toString() got generated before the tags field was added :P
Can put the closing single quote as part of the subsequent String
return listAllConsumers(props).stream().filter(consumer -> getConsumerTopics(props, consumer).contains(topic)).collect(Collectors.toList())
new ArrayList<>();
new ArrayList<>(causes);
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
this view is using the same context. what about if you use the context from itemView.getContext() instead of passing a new parameter?
It shouldn't be there. ProfileView should be shown in onActivityCreated of relevant activities in which we have to make it appear.
We should exit early if this.discardChannel is not null, no need to store this local variable in that case.
Add a new line after the @Override please :)
... and below.
Should this method be public?
This seems to be an unexpected case... in fact, an error. We should at least raise the log level to WARNING, or maybe even throw an exception.
What about extracting this complex checking logic to a method (e.g., matches(slaveId, data))?
Please use interfaces where possible.
Sometimes we call setZoomedList(null). So here your else should call the comsumer with null.
Add this qualifier: this.data
@xupyprmv are you sure that we should use anything related to ec2?
@cvrebert let's avoid composite names: call this var evts.
I would prefer ArrayList here, as it's faster, have smaller footprint and we don't need fast insertion in the middle.
Second condition is unnecessary (checked in while loop below)
linked hash set in case same classloader there multiple times?
Don't use addFileUrls, just add to your urlList
Should getDataProvider() only be called once in the method? And should itemIdentifier.equals() be used because it can't be null?
Please avoid one letter variable
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
should we return false or null?
this.
Tracking cost for getKeys() seems necessary. computeTracer.recordTime(0)?
Static import
Static import
Static import
Could you explain the contract here in a docstring? If two arrays are different lengths why are they equal if they have the same content up to the length of the smaller array?
You use underscore in numeric constant above, but not here. Let's be consistent!
use Bytes.memcmp()
Have you tried this with an existing stream with applications deployed? I wonder if we can use the explicit streams/logs/{streamName} endpoint for this.
Also wondering the case: if Bolt points invalid streamId (not matched with parentStreamId of Spout/Bolt) so could **validation** be required? (to cover this case either **fail-fast** or **warning message** due to redundant Bolt)?
Why is it public?
I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the "get" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course) ?
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
you turned around T & I here, it should be declared as:  protected <T, I extends T> @Nullable I getService(Class<T> clazz, Class<I> implementationClass)
as with the others, need to "remember" the first via, not the last.
this seems wrong. now you keep track of the last one and not the first one.
I guess this could blow up...
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Why propagate and not simply Thread.currentThread().interrupt()
Here the important inner exception gets lost, please pass e to JadbException constructor.
all these methods can be private
Here we should return Polygon or MultiPolygon or create two implementations?
Should be super( NativeTypeEnum.STRING );
Shouldn't this maybe be a threadsafe list?
what about one more test regarding the actual execution?
I don't think this makes sense, unless TestItem::invalidSql also supports HIVE dialect.
- [x] I know you're just copying what I did, but then again I was copying the tutorial, so that doesn't make it good. It seems like we could just call ElixirFileType.INSTANCE.getDefaultExtension and ElixirFileType.SCRIPT.getDefaultExtension, leading to  java public void createFileTypes(@NotNull FileTypeConsumer fileTypeConsumer) { fileTypeConsumer.consume(ElixirFileType.INSTANCE, ElixirFileType.INSTANCE.getDefaultExtension()); fileTypeConsumer.consume(ElixirFileType.SCRIPT, ElixirFileType.SCRIPT.getDefaultExtension()); }
I don't think the process deploy should fail in the case of temp file deletion fail
What if .delete() returns false? Shall we handle it somehow?
Use Logger.
duplicate regex as above, can we reuse it?
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
Please follow the style guide in CONTRIBUTING.md to add this to field access. You can turn on > save action .
Call setFocus() on the table control.
Is this not needed anymore?
The configProvider is still required, isn't it? If so, we should still have Objects.requireNonNull(...) as a NotNull check.
Can you return 'this' like the other setters?
Why not use badges = getBadges(userId); here? I think that's more clear than a call to a void method where you have to read through the whole method to understand the side effects.
This too would benefit from the (proposed) ConstraintType.EMPTY enumeration item.
I recommend using ITypeConstraint instead of TypeConstraint here. The latter is only for enumerable type constaints (I know, super misleading legacy name), and does not include TypeFilterConstraints that correspond to non-enumerable IInputKeys (such as java Class type filters or unscoped EClass type filters).
We can shorten this condition: java (StringUtils.nonEmpty(value) && constraintType == null)  FQN for StringUtils is org.kie.workbench.common.stunner.core.util.StringUtils
I'm not sure we want this to work with Type directly or instead use Class here.
I'm a bit concerned about this change in behaviour. We have two possible cases here: 1. the parent is null; I agree in this case that we could avoid copying the Set, still, the copy was preventing illegal changes on the collection once it's given to the invoker. How about returning an UnmodifiableSet instance? 2. the parent is not null: this is possible in case the ResteasyProviderFactoryImpl is created with an explicit parent and local = false. To be on the safe side, I believe we should keep on merging the two collections. Alternatively, we need to either investigate and exclude the scenario or think about a more complex optimization. WDYT?
I guess we will have to add DistributedCacheFactory.class also here..
Does it make sense here to overwrite cookies with same name (i.e. check using name if already in list and overwrite rather than allowing multiple cookies with the same name)?
I don't like this because it means we cannot have an empty String value. Could the code that sets the cookie value to "" set the max age too?
I would have expected this extractor to return the value of the found cookie (by its name).
Do we have to serialize the state in Operator? I think the caller class would be a better place to serialize it.
(Integer)? not (long) ?
throw RuntimeException?
same as for AddAddress here
Do either of these two 1. Add address.equals(InetAddress.getLocalHost()) to the check as a local inet address may still not match the two specified conditions above. 2. Create an unresolved InetSocketAddress in getRMWebAddress with canonical hostname and check for null InetAddress here
Why do you need this change? Seems you should prefer the autogenerated Shadows.shadowOf()?
I think in this class it is possible.
This block is common to all tests in this class and could be extracted to a private method, parameterizing the name of the process
This handler is not used at all, please remove it.
I think that we should send this event in task action logic Additionally used string constants should be added to task package into appropriate class
I would add more detailed information about the sample here:  if (ioSample != null) { parameters.put("Number of samples", HexUtils.prettyHexString(HexUtils.integerToHexString(1, 1))); // There is always 1 sample. parameters.put("Digital channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getDigitalMask(), 2))); parameters.put("Analog channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogMask(), 2))); for (int i = 0; i < 16; i++) { if (ioSample.hasDigitalValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " digital value", ioSample.getDigitalValue(IOLine.getDIO(i)).getName()); } for (int i = 0; i < 6; i++) { if (ioSample.hasAnalogValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " analog value", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogValue(IOLine.getDIO(i)), 2))); } } else if (rfData != null) parameters.put("RF data", HexUtils.prettyHexString(HexUtils.byteArrayToHexString(rfData)));
Shouldn't we add the Transmit options field here?
nit: space after 'if'
Are/should toCreateRequest and toUpdateRequest be chained in some way? I don't see if there's a way of changing a reference set member status here.
it looks like agents map is not modifiable at all, so what do you think about using instance of ImmutableMap instead, then you don't need to wrap keySet() with a new unmodifiableSet instance each time getAgents() is called
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
Might give this a shot, if the type parser is indeed fixed?
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
reuse method I proposed to introduce above
I think entry.getFields().stream().anyMatch(fields::contains) is slightly better performance wise (as disjoint needs to check if *all* elements of fields are not contained in entry.getFields())
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
ExecutorConfiguration(Optional.absent(), Optional.absent(), Optional.absent());
I hadn't considered before now that Briefcase uses form name a lot (directory naming, etc). That's potentially dangerous as there's no uniqueness guarantee but I suppose there isn't one for form_id across multiple servers, either. Using form name here is the consistent way to go but thought I'd mention this just in case we run into issues related to it at some point.
Would prefer to store the quark as a member of this class and keep the getThreadQuark method.
This is a String so use final String id = THREAD_ID.get(thread) ; and then you don't need to do the cast on the next line.
I prefer to use streams for such loops
Guice best practices: make this constructor visible only at package level.
Do we have to make new instance of MLRCodec every time?
Do we have to make new instance of NMFDataCodec every time?
This is the topology at the time of submission, not the latest one, which is what you want right?. The latest one can be gotten from the current physicalPlan.getTopology(), but even that one doesn't contain updates to the config (e.g. parallelism) since creation. If that's needed see UpdateTopologyMaster.
We should include the topology name in the message as well: Topology foo already exists.
nit: Could visit the graph with a visitor that gets both extra jars and resources first and pass that object to the methods below to avoid traversing the graph twice.
does it make sense to add column features to the enabled features on a table? You also add features twice, eg the hideShow from tableconfig and the hideshow from columnconfig?
Passing in a JsonNodeFactory instance might be better here, because then the JsonConverter instances and JsonDeserializer in each converter will all use the same JsonNodeFactory. As it currently stands, the JsonDeserializer has it's own instance of the JsonNodeFactory, and it's possible that they could be set up differently in the future and not caught.
This can be static
Its more efficient to ask the block directly if it is air, rather than the world.
switch statement missing default case
I'm torn on this one. I can see a temporary "FAILED" output being useful, but it's still kind of "RUNNING" since it'll get picked up again unless something breaks internally.
please add populate() call before addLinks()
It could be moved to the for loop.
You can replace the upper block by:  return identifications.stream().map(userAndCredentials ->{ ListeningUser listeningUser = userAndCredentials.getListeningUser(); UserIdentificationImpl user = listeningUser.getUser(); return new SchedulerUserInfo(user.getHostName(), user.getUsername(), user.getConnectionTime(), user.getLastSubmitTime(), user.getSubmitNumber())) }).collect(Collectors.toList());
if ... return map.get else return null
Assert.notNull()
For consistency across the project, please remove the final keyword from this local variable.
no need for the manual check (especially for the unannotated parameter).
@dalifreire making a static method is a workaround not a solution. Here you could store the stream as a field and create Channel in requests method and pass the created variable to copy and make.
nit: public abstract void
Initialize to immutable if present.
Should this throw IllegalStateException? Seems like bug case.
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
we can replace that with findAny/findFirst as we don't really need to know those vms
but there's no reason to change this method now, no?
getVm() might return null at this point
Should this include all the other fields a well?
We don't include the underscores in the field names.
Does not match conventional toString implementation.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
Should this check Collection as that is the super type for List and will capture Set, Queue, etc.
I'd like to know whether there really are cases when "-quoting doesn't work and we have to speak []-slang.
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
![MAJOR](<LINK_0> 'Severity: MAJOR') Reduce the number of returns of this method 5, down to the maximum allowed 3. [![rule](<LINK_1>](<LINK_2>
remove semicolon
can you please also add method ok(TimePeriod waitForJobs). TimePeriod.LONG may not be enough for all cases
Do you really want to just log when this happens? This exception can happen for example when the shell is not closed after pressing "Yes" button. In that case the test should fail, because it's not able to continue correctly (the shell remained open).
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Remove "()", (input) ==> input
why is this necessary?
these arrays could be static finals. That would save allocating new ones all the time.
Shall we change this to "Unable to resolve the hostname of the ....". there are few other places as well with same error message.
Hm, should we thrown it as InternalProcessingException ?
"Error while moving file from ..."
This should not use the --metadata parameter since that is used for object metadata. We should probably use a different parameter like, --datapolicy-id or something like that.
Use a guard method here
So we are limiting them to specifying a single object?
No need to have a final local var, please use an Immutable List from guava and please build it looping through the stack as it will involves less iterations than constructing a new list and slicing it.
Likewise here, make sure you include the default arg of "".
minor: rely on interface rather that full type.
Please add ? and % as well
unnecessary new Object[], and there shouldn't be a space around the contents of an array initializer, e.g.  public Object[][] getLinearIndexFactoryTypes(){ return new Object[][] { {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed")}, {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed.gz")} }; }
unnecessary array new: {{true}, {false}} should work here
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
Is there a constant you can use to replace the ".done" literal?
Have add and remove synchronized on dataSourceObservers just on the off chance an extension tries to do something on a separate thread introducing a race condition.
We probably should log and rethrow this exception, correct?
Seems like a Map<String, String>would do so we do not need to do the casting
We should probably not swallow this exception. We can log and rethrow.
We can use item.isPresent() as the argument directly.
This reads slightly better without the IS_ prefix to me.
this is not intended right?
Can we make these configurable now instead of deferring this?
I think by keying the cache by a Credentials object, that we'll end up with a cache miss on each new request, since each object will be specific to a particular request (since it has a timestamp, signature, etc.). I wonder if we should instead key it by the apiKey that is in the credentials?
This is convenient API, but I worry that this obscures the configuration properties outside of code... like if one is manually editing the config file or using the shell to set properties... the code doesn't match the literal property names people use elsewhere. I think a better implementation is to stop requiring properties to be prefixed with "general.custom" and allowing them to have any arbitrary property name in our config. Then, we just let SPI implementations do whatever they want for their property names.
you're testing for silence, but detect method returns true? shouldn't return false?
please remove TODO and printStackTrace() and use proper logging instead
Can also call ByteStreams.readFully(InputStream, byte[]).
There's a Map-specific assertion class:  assertThat(results.get(0)).containsEntry("name", "eric");
Why does this need @SuppressWarnings?
Iterable<Integer> keys = intsBetween(0, 100_000); Iterable<String> stringKeys = transform(keys, Object::toString); Iterable<String> values = limit(cycle(Arrays.asList(null, "value2", "value3", null, null, "value6", "value7")), 100_000);
Doesn't this duplicate the nonNull check?
Doesn't this duplicate the nonNull check?
Doesn't this duplicate the nonNull check?
Typo here. should be service_type
I'd inline this - MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("entity_id", entityId);
Isn't it better to sort it which fetching (in the query itself that is)
Newing it up like this will make it hard for someone to put in their own... The rest of the Nodes use a get() method to pull the value and expose a setter so that it can be overloaded, can we do that too?
when is the lock downgraded/released in this case ??
io.druid.concurrent.Execs#makeThreadFactory ?
Would be awesome to rename it to something more descriptive like isDiscussionsPresent() or similar
footer is used once, cast it directly
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
This method should return RemoteCache<K, V>.
This is convenient API, but I worry that this obscures the configuration properties outside of code... like if one is manually editing the config file or using the shell to set properties... the code doesn't match the literal property names people use elsewhere. I think a better implementation is to stop requiring properties to be prefixed with "general.custom" and allowing them to have any arbitrary property name in our config. Then, we just let SPI implementations do whatever they want for their property names.
isBlank is another one that handles nulls
Why not  java logging.setLevel(loggerName, Level.valueOf(newLevel.toUpperCase(Locale.US)));
Is this load operation necessary each time this method is called?
This is not how it should be. This should be:  if (log.isDebugEnabled()) { log.logDebug( message ); }  Do not use "if (debug)" because this is hardcoded and will never be enabled. Do not use "setLogLevel()" because you're overriding the system administrator's configuration.
Should be a constant of Run rather than RunQC
Nitpicking this change here - isn't this antipattern?
Probably it should just return false
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
You can remove these 2 lines, and use createBuilder(new CalendarSerializer())
Pls put them into a separate JSON file. Format the JSON. In order to read the JSON into string, use: java IOUtils.toString( getClass().getResourceAsStream(path), Charset.defaultCharset() );
Should use the log, maybe a warning.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
can you add blobId to the msg.
Currently yes. But it's prudent to think beyond the current use case and towards future uses. It's best to think defensively in these cases. Hence the need for the preconditions throughout.
can we remove the todo?
Ipv4 has the following code - "bootProtocol == null) ? Ipv4BootProtocol.NONE : bootProtocol;" Why didn't you adopted the same code here?
nit: since bookie is not final, there can be possibility bookie is null if these methods are not called in correct order. can we add final modifier to bookie field?
this.protocols = new ArrayList<>(new ProtocolConfig(protocol)); seems better to me
Can we point users to some kind of regex about how to specify these options, or what the valid values are? I don't entirely understand the format based on the docs and usage string here.
Can be replaced by: return script != null ? "" + new String(getHash()) + "\n" + script : "" + new String(getHash()) + "\n" + url;
please use StringFormat and %n instead of \n, so we're less platform dependent.
Is this an acceptable value for all metrics? Any way we can distinguish between a legitimate 0 value versus the case where metrics was not found?
Should make a differentiation of the name and id.
This also needs to be synchronized
can we use BeforeClass annotation?
you're still not closing the input stream anywhere
@exper0 let's use try/finally blocks for closing instances of Closeable
Kinda nitpicking here but if you have addCacheEntryListenerConfiguration then add removeCacheEntryListenerConfiguration just to be nice and symmetric...
Nitpick: space
I assumed you were going to pass entryFactory here
Shouldn't it be -1? No element in topicCounts map means this topic's count is zero, right?
No extra synchronization needed here because rowCount is already AtomicLong. Unless the intent is to not let shouldStop, rowCount, isRunning get modified concurrently since you are guarding accesses to them by doing synchronizing on "this" .
Use LOG.debug, because this data does not contain much information.
!showButtons
mb it would be better to init state of view and only then show dialog?
These APIs aren't great since the method has no effect when called after controls were constructed. We use that in other places as well but so it seems okay but it's better to either fail when this is called after control creation or dynamically update the UI.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
defensive copy?
Can't this be further improved to just Arrays.asList(values)?
Just "groupName".
I think if the view exists we'd still want it to update. Get the view not from the event but via PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().findViewReference(RepositoriesView.VIEW_ID).getView(false).
this should call getView(event).expandNodeForGroup(group); instead
refreshJob field should also be set to null on dispose.
All this code could be encapsulated in PermissionAuthoritySessionManagerListener constructor.
Try to avoid cast here
What is the purpose of this conditional?
remove public
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
Why the change to AssertionError?
Personnaly I think it's overkill for such a test class that will probably never be extended, and even in the case of an inner class, the AssertionError wouldn't be clear. But this is just a detail!
Do you get any compiler or pmd error if you remove the line that throws the exception? I get wanting to make the default constructor private, but it would be cleaner if the method were simply empty.
I think that deathdateEstimated was only added in 1.11.x, it should not be known in the context of 1.10.x compatibility.
Aren't the name and description properties already added by the super class?
What about if instead of pulling this out into a method like this we just have this method do:  DelegatingResourceDescription description = getCreatableProperties(); description.removeProperty("property")
I think in this case is best ignore sonarCloud. Not sure who's reponsible for the sonarCloud rules, but in this case I'd just ignore.
suggestion return fileSystem;
Logging.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
Since this is being created with a static method, and is thread safe, create the objectMapper in a static constructor, and make objectMapper static
why is this required to be public ?
Cache file name string
you can make it public for not to use generateArtifact(packageId, packageVersion, 0) method calls below
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
You can use CollectionUtils.toImmutableList
return workflowExecutors.getWorkflowExecutors().stream().map(executor -> converter.convert(executor)).collect(toList());
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
Is this a _good_ value for this property? Will the Api work if users don't override it? Should this value be passed as the credential?
Does that work when the test is run from the IDE? There is a test helper TestConstants#getTargetDir which gives you the target dir. If I understoof correctly these tests are also running in container, not quite sure how it would work then!?
The default toString on the List doesn't do the same thing?
return new StringBuilder().append()....toString();
return new StringBuilder().append()....toString();
Can you return creationDate.clone since Date is mutable?
Since Dates are mutable, return a copy of endDate.
Stack overflow? :)
should the Builder constructors be private as they seem to be hidden behind the of methods?
will this method ensure that etc/conf/conf.yaml is absolute ? If etc/conf/conf.yaml is provided then etc/conf/conf.yaml is returned which is not absolute
This should be thread-safe, and its not. The prior implementation was relying on class initialization to ensure thread-safe initialization of the userHome property. Since you've moved this to be an instance member of this class, you need to modify this method to use some sort of thread-safe construct here. It might just be sufficient to mark userHome volatile. java.io.File is immutable, and initializing the variable is relatively inexpensive, so doing it concurrently from multiple threads in the event that more than one thread needs the value at the same time and its not yet prepared isn't an issue.
if credentials is null should not execute mocked push
Why is stopScan() required here? The call to scanLeDevice(false) will call it.
Dianne will tell you to remove this. This is logspam.
Optional should be used in interfaces. Use null as internal value.
remove unnecessary checks
not working for null input
Shouldn't a cast to int be enough?
Shouldn't you also divide the result by 1000 to get milliseconds?
Shouldn't a cast to int be enough?
suggestion 749, // CWE-749: Exposed Dangerous Method or Function  Or maybe: CWE-676: Use of Potentially Dangerous Function ?
Should we just add the entire organization to the debug statement?
What is this for? If you want to set an icon for the Stage, please do so in the DNAInator class.
Could delegate to base class instead, super.scan(msg, originalParam);
I believe this is checking if the parameter is in a POST body and not if the body is of JSON type.
If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.
This logic is not correct since it would stop at the first '\r' in "// blah \r blah \r\n".
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
What do you think about changing the return type here to the enum ArrivalFilter? Seems like a conversion always needs to be done anyway, so we might as well do it here.
can the selection be null?
check first (select.getFirstElement() instanceof Resource)
Not that it matters so much, but the idiomatic way to "unpack" thing from Optional given a value to return in case of empty is [orElse](<LINK_0> which makes this common pattern i bit less verbose: return parent.orElse(null) But this kind of defeats the purpose of using the Optionals in the first place (to avoid having to return nulls). Otherwise +1 to merge.
inspection is the only client of this method, move the method to inspection
Do you want to ignore case hear also? You could store all the values given to the constructor in lower case and then here convert parameterString to lower case and then contains would work.
:bulb: This code should be in a try/finally for exception-safe closing of the Formatter instance.
Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)
Is there a more specific exception that can be caught?
Redundant assertion
Why is it public?
orcDataSource.getId() ? Or change "path" to "dataSource"?
please remove unsed code
Let's avoid changes in the classes not directly targeted by this pull request.
You can use StringUtils from the commons.lang3?
This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute.
This should be protected and not public. @okulikov, can you go through your changes and change the access modifiers of all modified methods to be as limited as possible?
duplicate semicolon could be removed
It looks like these two exceptions can be combined into one. I don't believe that you need to call out the specific exception since it will print the stack trace for the exception.
Would be a tad simpler to do: for (List<ITmfEvent> list : tbl.values()) { count += list.size(); }
maybe this should no longer be named pliList
Why not a for each loop?
There is no need for null checking in this case - second condition is enough
Maybe it would be better if you add enum value SourceCode.CONSTITUTIONAL_TRIBUNAL and use it in here.
public
Why leave the burden of capturing the exception to the user?
context.getEntityType().equals(EntityType.FEED.name()) should do.
Maybe we should name this variable entityReferencesDescriptions?
Can we use BinaryUtils#resolveClass instead of making this method public?
Probably we should log the exception here (debug or trace), just to help with troubleshooting
Probably we should log the exception here (debug or trace), just to help with troubleshooting
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
Actually, in most cases HeaderChannelRegistry contains TemporaryReplyChannels which aren't beans and this exception message will see often exactly for gateways with some serialization during flow, but without HeaderChannelRegistry. So, my position to change it to more generic statement: > "Failed to look up MessageChannel with name '" + name + "' in the BeanFactory" + (this.replyChannelRegistry == null ? " (and there is no HeaderChannelRegistry present)." : "."
this. on method calls? I guess you have just moved those existing setter over here for better class structure. Nevertheless can we fix this. as well since we are already here in a change?
Can we please add limit to the exception message? So it will be much easier to see the problem!
You may want to say something like "Items per page limit cannot be..."
I don't think you need this new flag. You should immediately return null from fetchNextReady() if the child has already been closed, which you can test with child.isOpen() or child.eos(). @jingjingwang do you agree?
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
testType can be null, so it would be best to invert the equals() check as so: java if ("buckets".equals(testType)) {
Why is the exception swallowed here and not thrown? If there is ANY problem creating a bucket, the exception for that problem is lost at this point.
If quality is an int, we don't need the check.
Please consider writing a class version number (e.g. 1) as part of SerDe in case this is ever stored on disk.
As above, you might as well just delete this line.
Same as above. If you don't have a valid publisher throw exception
shouldn't this be a different hook so that the optional one can return null while the active one returns a Publisher?
Fix this
if at all possible let's try to avoid introducing more mess:)
Very small suggestion: I believe this could be simplified to "String keyUseString = keyUse == null ? DEFAULT_PUBLIC_KEY_USE : keyUse.toString();"
Please use a 2-space indent and braces around the throws block.
Remove the InterruptedException from the signature.
!droplets.isEmpty()?
!sizes.isEmpty()?
Why not reuse the ObjectInserter that you already have as a field?
s/last/lastIndex/
Don't initialize to null. RevWalk revWalk = new RevWalk(repo); try { } finally { revWalk.release(); }
Use parameterized logging instead of string concatenation.
Unnecessary "else" blocks, just return
"else if" maybe?
Change log level to debug
Change log level to debug
Shouldn't errString be in the exception?
Same here, but check the max cook time instead.
keep this the same
You should return false here if value is greater than the furnace's set maximum.
Not related to this change but this should be spelled "Cancelled" to be consistent with method "isCancelled" of ProgressMonitor.
It throws an IAE when workDirTree is null. Not more, not less.
This might be paranoid, but you may want to catch UncheckedIOException as well.
element can be invalid at this point. Also you don't check what element it is. E.g. in case of batch inspection mode that was run on injected text, you'll get a file here as an element, I don't think you want to replace file with ""
You shouldn't create struct literal at this place. Because method name is getData and it's called in isAviable
As currently written, isValid() will not fully validate the data in the record, since some fields (like the base qualities, etc.) may not have been lazily initialized yet.
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
If you have a translation use that if possible.
Can you add getId() and mark id() as deprecated?
Worth including an entitlements check, because the return values could contain passwords retrieved from brooklyn.properties. For example, something like:  if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ALL_SERVER_INFO, null)) { throw WebResourceUtils.unauthorized("User '%s' is not authorized for this operation", Entitlements.getEntitlementContext().user()); }
can we create a constant datastax-java-driver?
It seems that all we should need to refresh the schema is the config name.
"cwl" should be DescriptorLanguage.CWL.getShortName()
(redundant suggestion) this "literal" (as close as we get in Java) is short enough that it _could_ fit inline in the assert, below. The motivation, here, is to bring the declaration of the value as close to its use as possible (in this case, reducing that distance to zero).
This could use Collections.singletonList
This is a bit too strong. You should perform the verification of the true and false expressions only if the type of the expression is Optional. With the current state, the following code will trigger an issue, and it has nothing to do with optional and is perfectly valid:  public Optional<String> bar(booleab b) { Object myObject = b ? null : new Object(); return Optional.empty(); }  With the following, it should work:  if (conditionalExpression.symbolType().is(OPTIONAL)) { checkNull(conditionalExpression.trueExpression()); checkNull(conditionalExpression.falseExpression()); }
I think you forgot to remove this line
Can have a isRef(Expression) and isLit(Expr)
Since you already kept the routingTable, is it still necessary to keep them as private fields?
Why are we passing null rather than handle.getCatalogName()?
Better to check NPE for these calls.
Can we add a throws declaration to an existing public API, even if it's deprecated? We just reverted a change [1] because adding throws broke backwards compatibility. [1] <LINK_0>
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
should this be altered to use the 2 parameter version?
avoid using \n, I remember windows contributors having tests failing because of such usage.
minor: can be final
Yes, or unbox a NonFatalException in the default toCompletableFuture impl. Unboxing it is perfectly ok because there is no public API that allows a call-site to construct a NonFatalException outside of a Try. Please find the suggested impl above...
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
For loop?
int[] props would make everyone including the style checker much happier
Perhaps consider a constant for "NOTIFY" as it is repeated various times.
This is a nice test. Demonstrates how simple and clean it is to create and submit a job.
Hrmm... I understand why this was changed and what the issue was (ID generation is only done on persist), but this isn't correct either -- the implication is the default state is "queued," and we're creating by default; neither of which sits well with me. At the very least, we should move this down to the try block with all the message sending.
Small style nit: We don't use braces around simple statements.
Why is this private, when addFiles does the same thing and is public?
Should we return immutable list here?
@xpdavid is this the right thing to do?
To always be safe please use context.getApplicationContext()
please use constructor inheritance for these
Please move this check into the null check bellow, since we are already checking if this.key == null.
Please keep this.cell near the related fields (previousFamily & cell count) below
these are synchronous as opposed to async
Please make the constructor private (see Invalid).
are these setters used anywhere?
final This should probably contain this.value = value at some point... and it should only do so if isListening = true.
With the AtomicReference, we could remove the synchronization and just close the previous value we get from the getAndSet(V) method.
should be able to make this private.
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
s/A submitted/The submitted/ s/task/event/ Also, is it possible to add some info here? perhaps the event's type or something like that?
Unmodifiable if possible
Although the logic is a bit different then above as we are aborting all remainder futures as soon as an interruption is detected
The constructor should be made protected so that users can easily make a wrapper for it.
The connectTimeoutMillis and readTimeoutMillis in the builder appear unused.
Nit: we prefer AssertJ for assertions.  import static com.datastax.oss.driver.Assertions.assertThat; ... assertThat(builder.tracing).isFalse()  Not a huge difference for a simple boolean, but for more complex types like collections it's way more expressive.
final
since it is static, you should use class name (LRUCache.MAX_ENTRIES) or just omit this
What is the point of having _both_ these statements?
> implementation in load balancer module and interface def in query server module Correct. > Then load the implementation in queryserver module via service loader from loadbalancer module Yup > How do make query server dependent on load balancer module when load balancer has a dependency on queryserver. Is there any plugin to load the jars from loadbalancer into queryserver target This is what ServiceLoader solves. Perhaps you do not understand how ServiceLoader works? At compile time, PQS only knows about the interface. At runtime, both the interface and the implementation are present. ServiceLoader provides the implementation of the interface (based on the runtime classpath).
I don't like the idea of doing more than necessary initialization works at the constructor level. It should be whoever uses the class' concerns. A simple setter like  public ZkBucketDataAccessor(ZkSerializer zkSerializer, BaseDataAccessor baseDataAccessor) { _zkSerializer = zkSerializer; _zkBaseDataAccessor = zkBaseDataAccessor; }
Should we provide public ZkBaseDataAccessor(String zkAddress) as well? This would be the default constructor using ZnRecordSerializer when a custom serializer is not needed.
You don't need a transaction here
I think its better to if (isCopyPerms()) { execInTX -> save quota copy perms } else { save quota } and remove the check for isCopy... in copyQuota method
don't we need compensation here in case the removal fails?
This is super silly. Never do this and read about java string pool. Just hit java string pool in google and you will see a lot of articles.
please don't rely on InternalObjectNode for the new tests. we want to move away the end users to use ObjectNode instead and these tests may get used as samples. Please either use a pojo or use ObjectNode.
Could be just package accessible, just for tests.
delete() should be executed from within the future so it doesn't through right away.
This should happen within the future
emptyCollectionWhenNull does not need to be serializable... Use thenApply instead of handle and return rather Collections.emptySet()
Why not call put in this class for atomacy?
Should only be for the provided keys?
looks like we're only updating the timer metric if it's a writeAround cache. I'm not sure if we should do that - metrics should be updated regardless since you're measuring the time it took for the "delete" operation right?
Could you add a check to filterSteps.get to make sure it doesn't return a null? Something like this: Preconditions.checkNotNull(filterSteps.get()) Our code analysis check is complaining about that
why not just selectedFiles = workingVersion.getFileMetadatas();
you need to close this directory stream
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
Add the original ClassNotFoundException as cause.
Could you please instead use Context.getClassLoader()? We try to never use Class.forName directly throughout the SciJava codebase; the thread context class loader is used in many places throughout ImageJ, but it might return null, so you need a fallback. See cd67323c13678c931cb5e1e798149c45ef5b21a9.
Can't ServiceHelper.getSelectedService be used? It has the advantage of not relying on the specific format of the url.
Would be good to put more brackets around it so it's obvious at first glance about whether the + after job is only in the else case (which I believe it is). The previous toString impl this replaces was particularly bad for finding where the : was!
toString looks wrong: will say "private-key" whether or not there is privateKeyData, and will say "public-key" if there is no publicKeyData.
Be aware that if you update version.hashCode to take build into account that now this will no longer be correct since this doesn't compare with version.equals.
really minor, probably it can just return value to avoid integer boxing with Objects.hash or use Integer#hashCode.
And this change should be reverted as well.
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
Due to consistency I would just return "skadi" here
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
suggestion return !root.getParameters().isEmpty();
Maybe this package symbol can be factorized.
Not sure if this is supposed to be a Long instead of long?
Under some conditions I'm running here into an StackOverflowError: java.lang.StackOverflowError: null at com.google.gwt.user.client.ui.TreeItem.getChildCount(TreeItem.java:371) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:538) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:528) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:310) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) ... One scenario in which I'm getting this error is when I filter for projects having the parent 'parent2' while having the following project structure: -- All Projects -- -> parent1 -> parent2 -> (project1, project2, project3)
suggestion if (structureTreeNode.getDataObject() instanceof View) {  instanceof already checks against null
Consider reverting this since it's no longer a WIP patch.
IllegalStateException
IllegalStateException
The Logger should get the ID of the current bundle, which is "o.e.ease.ui.scripts". So you are still using the wrong activator...
I don't see any problem with prohibiting x-site backup to/from a LOCAL cache, but I'm not that familiar with x-site configuration and I don't know if it's possible to do that validation.
Couldn't we use a WithinThreadExecutor here? This constructor creates a new single-threaded executor, which would mean one thread is allocated for each cluster listenre.
Please io.druid.java.util.common.ISE for IllegalStateException, which under the hood uses StringUtils.safeFormat for error message printing.
See identifiedElementQuery.getLabel()
The icon is not being set. I don't have a preference for the icon location, if you want to keep the previous location you can do so by changing the horizontal text position (to leading).
Why not IllegalArgumentException?
Same as above, why not use try with resources?
Same as above, why not use try with resources?
this should be a warning perhaps? since we ignore it anyway
String.valueOf() shouldn't be used to display integers since it doesn't consider the user's locale. Use i18n.number() instead.
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
not relevant for localization.
BTW I think only the patch to getIconFileName is needed (cf. core/src/main/resources/lib/hudson/actions.jelly).  git ls-files -z | xargs -0 grep -lZ -- \\\(conFile\\\|rl\\\)Name\\\(\\\)\ \\\?\[\!\=\]\=\ \\\?null | xargs -0 ls -l
Better revert.
unnecessary
We'd better fail here instead of silently returning null?
checkNotNull returns the object, so these lines can be rewritten in the form of: this.fetchStrategy = Preconditions.checkNotNull(fetchStrategy);
I think we should extract these checks into a separate EngineDiscoveryResultValidator class or sth. similar.
@dalifreire let's get rid once time used variable
We shouldn't ignore an invalid enum value.
I'm assuming the JVM will figure out not to make a new string here every time...
I believe the preferred method is to do one cache.get(nodeId) and then check to see if that result is null. I believe containsKey should be avoided.
space line
You could use functional style expression like: suggestion return node.orElse(null);
The code of the CompositeReconcilerStrategy constructor should be used here, and in case there's only a single reconciler strategy, it should be returned directly.
Should we abort for invalid value?
Have you verified that order is preserved?
Shouldn't you verify the mac is not null to avoid NPE? 'ImportVmFromConfigurationCommand' has this check.
No need to extract to variable
I see this is only called from ImportVmCommand I think it can be inlined (or moved to ImportVmCommand) and use getMacPool that is already defined there..
I'm not sure silent catch is good as after that url is null and it will create exceptions
What do you think about this?  java String url = API_FACTORY_BASE_URL + "workspace/" + workspaceId; if (path != null) { url += path; }
Both parts of if should look the same.
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
I think that CSSDOMSemanticElemntHelper should be an Singleton.
Can you repro this on master? If yes - definitely worth filing.
This correctly cycles back through the pager when the Back button is pressed. However, when the first position is reached, the Back button has no effect (i.e. the dialog should close when Back is pressed). To handle the final Back case, you could add an else here and say the following: else { super.onBackPressed(); }
@droneboost that wasn't what I meant. A ListView recycles views that are not visible so that it avoids creating new views as the user is scrolling up/down the list. It does the recycling through the View view parameter in the getView(int index, View view, ViewGroup args) method. If there's no view to recycle, then that parameter is null, otherwise that parameter will be non null, and you can reuse it. A typical example is as follow:  public View getView(int index, View view, ViewGroup args){ if (view == null){ view = View.inflate(...); } // else the 'view' parameter is non null, and we can reuse directly without doing an inflation. initViewItem(view, ....); return view; }  With the class field, you're overwriting the same view with the successive data, so all the entries in the listview will look identical.
you could assign this to mParent in the constructor of Builder, and then you wouldn't have you check against null?
you should check only snapshots of this specific vm
You don't have to use addCanDoActionMessage for this, since there's a ValidationResult constructor that receives a list or replacements (ellipsis so you don't really have to wrap it in a list or anything). That's the way it is used in most places
we should ignore the ACTIVE snapshot here
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
Use Objects.equals() to handle nulls concisely.
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
throws
throws
nit: throws for consistency and clarity.
Lets not catch the exception and just let the original exception propagate unto main.
use same type for instanceof and force casting
Should it really return null here?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
blank line
Cool, didn't know about DeadEvent. When you switch to slf4j, make sure to use playerholders {} instead of string concatenation and follow the [logging format guidelines](<LINK_0>
Maybe check for if name ends with ':' so we don't do a double one?
Implementation of this method looks exceedingly complex. I'm not sure how to simplify it since it is not clear to me what this method is trying to achieve.
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
Isn't this logic backwards. You want to return true if it exists so it should be Tribble.indexFile(vcf).exists() || Tribble.tabixIndexFile(vcf).exists()?
This method is useful in some cases, but I don't think that we should make this public API. Without proper lock, this method does not guarantee anything.
should be "*notconfigured-it.war" Double check the folder because not sure how this passed.
This is check in the overriden enqueue method. I think this check is extra here.
This check is extra
nit: I would reorder these methods. registerLifespanCompletionCallback -> setNoMorePagesForLifespan -> isFinishedForLifespan. (here in all other classes) setNoMorePagesForLifespan -> isFinishedForLifespan happens one after the other, so it is easier to read if they are together. And registerLifespanCompletionCallback happens before this two, and even before enqueue. So maybe it even makes sense to move registerLifespanCompletionCallback before the enqueue.
perhaps if not has permission?
The stacktrace here is pretty boring. Therefore it was left out intentionally (although due to the missing placeholder still wrong). It would have been nice though to let the user know what exactly was the value that wasn't so great: java logger.warn("Could not set new location {}, keeping old one: {}", location, e.getMessage());
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
"isSearching" should be a class level string
Should we keep a reference to the Bundle here?
Would you mind making the "tabList" string a constant symbol since it's referenced in multiple places.
I guess that if "columnToBeSortedOn" is null (sorting is turned off), we should not write to a temp file. We should write to the final file directly. So maybe let's rename the "_tempFile" variable and call it something a la "_targetFile". And initialize it according to the null check.
delete on exit?
Re-use temp file
Could use '/' and ']' to avoid the need for extra NON-NLS
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
id:name might not be enough to uniquely identify a container. I think you should also include the string representation of the parent account (i.e. parentAccount.toString()).
Please use lowercase as it refers to the argument: disposables is null.
disposables is null
disposable is null
probably best to use getIntInRange() here too to avoid negatives (I think I didn't know that the function existed when I first wrote this).
I don't know if we should set a default key. We might want to require the user to generate something unique to their service.
Write 20971520 as 20_1024_1024. Ideally, Default annotation would support this approach too, but I know we don't have that yet.
@NielsCharlier consider refactoring this to use Java 7 try-with-resources.
Perhaps try-with-resources? Needs care with the disposePassword.
this can be stored as a field; an ObjectMapper instance is threadsafe once constructed
should this have a ,  to match the rest of the pattern?
VertexInfo vs NodeTopologyEntity.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
Introduce local field for entityManager.getEventSystem()
Maybe some not-null check should be added here.
entryId is not used, please remove
u add this var here, but onlu use it inside. u can just do entries.get(entryId).setEntryIsLive(); in line 515 instead this line and instead of 515-516
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
minor: this not required anywhere.
remove this
no need for explicitly using 'this'
requireNonNullElse is better
I think you can plug in the User directly as a method argument. @MatthijsKok figured this out somewhere. Maybe we can even make it a Class field as every method in this Controller needs the User object.
This is an unintended grant of permissions to all users. If the owner doesn't exist, this should instead call throwIfNonAdmin
Might be worth having a displayName?
Make it localizable?
Nice2have: make it localizable
I think this should be stripe_account_id ? as per PP-4302
Let's change the signature to ImmutableMap as well, please.
Why do we want to return it if we have methods to manage it. It seems like encapsulation issue.
*ws* is being removed automatically at the pre-destroy step. Instead, of that, we need to try removal of workspaces with name **MIN_WORKSPACE_NAME** and **MAX_WORKSPACE_NAME** which could probably remain after the test execution in case of failure.
To figure out the workspace you should request factory by name and get workspace name from config.
What if workspace is not running at the moment? It doesn't mean that workspace is restarting at the moment, or language server will be restarted as well, do it?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
what's the intent of this change?
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
I'll check later, but should this be doesUserHaveCollectionAccess?
in what case they are not equal ?
Check that stmts is not null
cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no?
Shouldn't this be based on package name ? , getPackageName()+".depicts.contentprovider"
use log
Let's use seleniumWebDriverHelper here
It's better to rewrite the code to use SeleniumWebDriverHelper class.
It's better to rewrite the code to use SeleniumWebDriverHelper class.
Since the constructor doesn't "return" the token, we use a different naming scheme here. Here is a suggestion for this method: public void bitreserveClientWithTokenShouldSetTokenAndRestAdapter
Why uppercase _INSTANCE_? Is there a convention for this?
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
Not sure, do we really mean to pass null as the idToken to the new instance here or should we use the provided idToken parameter instead? I think that Scenario No1 fails to complete the account connection because of this.
200 -> HttpStatus.SC_OK?
Since we're tracking this event after the user taps the next button and only when the email is valid, maybe we shouldn't call it "email filled", as it may be misinterpreted as the user just filling in the email input. Does that make sense to you? To be honest, I'm not even sure why we need this event. What's the idea here?
public static? Is that keyword ordering important in this codebase?
for ease of reading can you extract refSeqWalker.getSequenceDictionary().getSequenceIndex(record.getReferenceName()) as a final variable?
This modifies the data inside record itself (vs modifying a local copy of the data). Is that what you want to do here? It seems unsafe to modify data in another object, especially as a side effect of calling isAdapter().
please, also check at least elements count
I'm wondering why do you use RtForks in MkForksTest tests. We should test MkForks instead
looks like wrong indentation, maybe you forgot to run build with qulice profile enabled?
why this was changed here and not in the master?
please use VmTemplateHandler.BlankVmTemplateId (i guess this is what you meant..)
VmTemplateParameters also contains the id, can pass that to it and drop it from this class
Throw exception instead of logging it
you should declare it as Provider<KubevirtAdditionalProperties>
This can throw NPE if CacheClosedException is thrown during initialization of clientCache
I think ideally we would also extract IngestionEndpoint from the connection string and not expose endpoint() directly
suggestion this.licenseKey = licenseKey;
It breaks binary compatibility. Usage example: <LINK_0>
do we also want to check cleanup of key B 3 if it were in the map?
not all exception means not_found from findKey, please print out the exception as well. Also, we should use error here.
Can this call Client.getMetadata rather than require a separate method to retrieve MetadataState?
null is not handled in the callers
Style-nit: no brackets around single-line blocks
Consider using ServiceUtils.getService here as well
Use readAsString(...) instead
Use readAsString(...) instead
Use readAsString(...) instead
You'd still want to tear it down. How about using a straight-forward if-else ?
Suggestion: You can set OK by default
This is a duplication of lines 823-833, we can extract it to a method and prevent this dup.
if else would be better.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
I'd go for: return ImmutableList.of("node", "show", "-l", nodeName, "--format", "json")
Is this needed?
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
I believe this is the cause of your failures as you are setting up a Java17 project which will be called TestSetup17project or something like that.
log()
Are you setting these anywhere?
shouldnt the delegate be closed or at least flushed?
Isn't there a different way to get "android.owncloud.com" instead of using a hardcoded string?
extract to metod?
suggestion /* package */ Intent buildIntentForUri(Uri uri) {
won't there be an NPE if upServer is null?
Error message should have zoneId. I think this goes for every message that prints a cluster...
Should'nt the getter name be getClusteId if the field name is clusterId?
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
Shouldn't this be a field so we don't have to create one each time
While we're renaming, might as well remove that extra _.
We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it.
getId() != notificationId, notificationId = ATOMIC_INTEGER.get() Always be careful not to change behavior.
Core.ID
return !metacard.getTags().isEmpty();
This won't do anything since metacard is a mock.
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
@ge0ffrey This is not factorial, this is base ^ base
final for all vars that do not change
I've got a fix in a PR that [removes the watchManager](<LINK_0>, so let's just make sure that doesn't get squashed by this :)
This code block is repeated over and over (lookup, register and log...) maybe make it a static method in Disposer?
Same here:  for (String localPath : pathIterator) {
Also you missed similar fix in the lockInterruptibly() and tryLock()
space before catch
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
@jackyq2015 best to wrap things like this with URL encode as a best practice.
synchronized?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
you should account form previous page too
Add a message to checkState so that it's easier to debug if we ever hit it.
Debugging? Remove.
Rename to "finishRefAndObjSections" or something since it may be closing the index block section or index.
Define a final static int BILLION = 1000*1000*1000; and say 2*BILLION so we don't have to count zeroes. Ever used the old Turkish Lira, counting the zeroes to figure out whether it was a million or ten million? 1000000 vs 10000000. Btw, zeroes or zeros?
semantic units should be separated by empty lines.
dont think a setter type function should return the "this"
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
Needs to be in finally - we might get interrupted.
Can't we instead of that peculiar disable/enableClose return here a wrapper with the empty close() impl and invoke delegate.close() in that releaseConnection() above? Something similar we have in the Spring Kafka: <LINK_0>
You could set connectionFactory to default, and then create the connection in the return statement.
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
What if type is not Class type?
in case you are removing the SafeHtmlUtils.htmlEscape(renderedText); you do not need to override the render() method. Please use only: super(new EmptyValueRenderer<String>());
value ! = null can be removed as StringUtils.hasText(value) does the non null check as well.
simplify this to  return getVarArgIndex() > -1;
May be just pass ValueNull.INSTANCE? Why sending these strings over the wire?
Shouldn't this API call be guarded by a check for Android version M?
This is a very costly operation finding the event size every time, can't we do any other optimizations
Should this maybe log an error or warning that the event date time was in an invalid format? And we're ok with defaulting to today?
This should probably include the function name in the error message. Also, should the error be logged as well as the message?
Could you please replace event.getTarget with a variable to make it clearer
Another access change API violation, same a little below. If not needed then lets not change it here :-)
**When using DelayedActionTriggeredEvents it's not enough to just filter by component. You need to set and check an ID for the event.**
You can use StringUtils from the commons.lang3?
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
I would prefer return type(type.getDefaultState()) instead, to be less repetitive.
please change this to getById
are you sure you want to include an external call in the transaction? I'm against it
it's not ideal to throw any exception in the failure handling part
Please add at least of project in order to check that the result is empty because it return an empty list
I would do a static import of ComponentTesting to improve readability
1. Not sure if its ok to error on failure to get engine time stamp. 2. Failure to touch base with engine might essentially mean that the subsequent commands also fail and there's no use of asking for user intervention or things of that nature and somehow attempting to proceed with normal flow of snapshot creation. 3. Given 1 and 2 I still feel handling the failure manually in code is better atleast in order to close any other previous window(ex: snapshot create window) Let me know what you opine
No tests to cover this method! :open_mouth:
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
ACE is a subclass of SecurityException
Is this the most typical case? I would have thought most chunks aren't null and such I'd suggest flipping the if/else block.
What do you think about simplifying this method to: java while (true) { final SoftReference<Chunk> chunkRef = chunksCache.pollLast(); if (chunkRef == null) { return new Chunk(defaultChunkSize); } final Chunk chunk = chunkRef.get(); if (chunk != null) { chunk.cursor = 0; chunk.startIndex = 0; chunk.chunkSize = chunk.keys.length; return chunk; } }
Google's Java style requires methods to be lower-camel-case. e.g. convertChunkSourcesToModules() This looks like Python code to me. :)
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Did you take a look at HibernateDiagnosisDAO? The service layer will delegate to the data access layer which fetches directly filtered data from the database instead of fetch it all and then filter in the application memory.
In the DAO we don't throw APIExceptions and its subclasses in general, so you can remove this
Do you mean s.length() > len?
maybe test first char for empty letter as well to reuse s if possible?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
> 0
can make this method private.
I think that the log messages related to extensions cannot be part of "pluginNotStarted"
what is this supposed to do?
getDefaultTracker is called every time an event is reported. It is worth thinking about setting up the default tracker in a manner that doesn't require you to set the user id every time getDefaultTracker is called. Like if you setup that part of the tracker every time a new user logs in, you don't need to do it every time you call getDefaultTracker. That said, it might be a more complex implementation that isn't worth the effort. I'll leave it to you to decide.
is it worth doing a call to LogUtil.i() here?
I still think you should throw an exception if name is null
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
I think we should also check for empty or whitespace only strings.
@marchof I'm wondering why in case of invalid command exit code is still zero?  $ java -jar jacococli.jar test $ echo $? 0
Why this change?
Why this change?
Should throw at construction time instead.
NIT: Seems like a funky way of appending the strings to each other. Isn't this what you're effectively doing...  java StringBuilder transformedName = new StringBuilder(); if (this.archiveId != null) { transformedName.append("[" + this.archiveId + "]"); } transformedName.append(TestNameTransformer.getTransformedName(testName));  Seems a little easier to read to me, but obviously subjective (hence NIT).
The exception also needs to be modified a bit.
This cannot work.
"Modifier 'private' is redundant for enum constructors"
return symbol != null ? symbol.qualifiedName() : "";
Not related to this fix, but can't we get rid of this extra InitializingBean operation and just getSSLContext() directly in the ctor ?
Should be optional => <code>@ChechForNull</code> and convert empty strings
Please copy args here too
Try using StringUtils.isTruthy(this.path)? <LINK_0>
Style-nit: We always wrap statements in curly braces.
You might want to put the double-check-locking mechanism into a private getter of myAddrs to consolidate the logic in these 2 getters.
SCAN_MBUS_CHANNELS
Have you considered to give this function its own interface? E.g. java @FunctionalInterface public interface DelayFunction { @Nullable Duration calculateDelay(@Nullable Object result, @Nullable Throwable exception); }
Suspicious null here. Instead of getType(null), why not just Type.STRING?
this can be static (most likely will need to be)
I'd really like to wrap this in Collections.unmodifiableMap.
Once you move to using the metrics prefix, you'll need to modify this. Plus you should use a regex for matching: <metrics prefix> + MetricsAware.KEY_REGEX + <metrics name>
Can use Objects.equals here
What happens if the user is "brooklyn"? Is it sensible behaviour? Can/should we add an else block with an assertion for that?
Do the RootLayer, RootLayerStyle and Styles also need to be updated?
just need log.warn("msg {}", ex.getLocalizedMessage(),ex);
try to use LOG.warn("Unable to access property: {} {}", NhincConstants.KEEP_ALIVE_PROP, ex.getLocalizedMessage(),ex);
Please use LOG.warn("Unable to access property: {}", NhincConstants.KEEP_ALIVE_PROP, ex.getLocalizedMessage) to reduce stack trace
Why are we removing the call to hsync()? hflush() doesn't guarantee that data has been written to stable storage.
We may need to put this behind the flag, especially if we want to back-port it to older GCS connector versions. We can enable it by default in master branch though.
I guess this method should be removed entirely here and below. (It was one time and it flush process to server log twice). As an option it can be optional using some system (maven) property for debugging purpose.
Exception again
please add the method signatures as well
Instead of reading into a String, can't we just pass a FileReader into Gson? Then we could also throw the FileNotFoundException back to the caller so they could handle figuring out if they had the wrong path or no read access or whatever.
instead, can you put this.previousStop = (previousStop == null) ? "" : previousStop; in the constructor of LexicographicTopNMetricSpec and here , replace line#191 by this.previousStop = super.getPreviousStop() ?
This was returning a "domain" Stop before, I cant see that the StopAdapter comes into play here. Or, did I miss something? It seems like there is a lot of types in play for just stop on this API, but if the "domain" stop is retuned then we need to make an API type for the old dev-1.x Stop, too. I can discuss this @abyrd and possible the community - maybe it is better to clean it up.
lets remove sdkfields from here
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
@vilchik-elena Why not using com.google.common.base.Joiner? e.g. return "\"" + Joiner.on("\", \"").join(duplicatedParameters) + "\"";
This can be dangerous because if someone supplies microsecond resolution it will be 0 ms, thus will trigger an exception. You should rather use getDuration().
Why does this need to be static?
You can just return the StringUtils.equals() result directly; making it a ternary of "? true : false" is redundant.
Here you should also use the assert, since the else branch also only throws an IAE.
use as loopvar?
I know you just re-factored this code into another method, but I am asking myself why the getItem() method is called on the itemRegistry vs itemUIregistry in case of the basicui.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Please keep this.cell near the related fields (previousFamily & cell count) below
remove tabs
It's the fPartListener/2 that is null. I don't think the site and page can be null at this point.
could probably inline, won't be null
Perhaps we could look into making the deserializer more flexible with respect to encoding issues (just like it can be configured to accept unescaped tabs)? I have not checked if it is possible though.
No biggie, but for Java 8 this could be: java final Path file = dest.toPath().resolve(fname); writer = Files.newBufferedWriter(file, UTF_8);
why sampling logger? do we expect a lot of openFile?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
nit: you can do mLGNames = Sets.newHashSet();
Wouldn't it be a serious bug if m_activeSegment != null && m_segments.isEmpty()?
Add the original ClassNotFoundException as cause.
Class<?>
Let's make sure error messages are consistent.
The constraint here should be on the consumer key, since on the old job the TARGET_TYPE is a consumer, and TARGET_ID the consumer uuid.
The original job does not seem to extend UniqueByEntityJob, or implement the isSchedulable/scheduleJob methods, so there is no need for constraints on this job.
typo: starttup -> startup
can you pull this from a static string?
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
return Platform.getOS().equals(Platform.WS_WIN32)
I see that similar methods in this class use IllegalStateException, shouldn't we do the same here?
Can return PlatformType.platformTypeNames(platforms); instead of doing the same lookup twice
It seems this variable is not used, can it be deleted?
remove public
should be typed
why change the readability status here?
Minor: please move private utility methods to bottom.
It would be useful to know if i file was not deleted for any reason. Maybe add an Logcat error.
This method publicly exposes a field that is otherwise lock-guarded. Would be good to avoid that, or at least not in the production scope. You can do the following: - pass this directly to the constructor of SortMergeSubpartitionReader - reduce visibility to package-private and annotate it as @VisibleForTesting.
Should you attempt Path.toFile() here?
Don't we need to do the caching here?
Let's only use DsfDebugOptions... as mentioned above
Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.
Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
Shouldn't we add the Transmit options field here?
Log in logger, not just print in console.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
I'd rather pass down the auth information to the QueryLifecycle. There's no harm in checking it twice, if it's good enough for Santa Claus then it's good enough for us. Checking it twice should also allow us to get rid of the no-auth path in QueryLifecycle, which would be good. Perhaps a good place to stuff the auth token is the PlannerContext.
Same as with the imperative template: Shouldn't we just deprecate these methods and introduce Flux<SearchHit<T>> search( )?
extract method
extract method
This should not call log.error(t). It should return ExceptionUtil.getStrackTrace(t);
I think it should be return executeCommand.execute(action, resultCallback); else you lose the "good" DispatchRequest in the process.
return undoCommand.undo(action, result, callback);
This is a place where we could recognize specific commands and transform file:///projects uri's.
do we want to keep this non-null if there is an issue with dispose? Basically, should we set it to null in finally or here?
Is it for sure targetName will contain @. I mean in case of serverName null, and when targetName is not under server control entirely.
If ClientCnxn.clientConfig is final then you can replace this by clientConfig.isSaslClientEnabled()
Remove this if statement and let the code below handle the null case. It will nicely print out the existing repository names in case of nullOrEmpty.
The .toString() can be left to the logger for performance.
> APIEvent(final String eventName) { [](start = 4, length = 34) nit: new line please. #Closed
I think the return type should be IborFutureTemplate as AbsoluteIborFutureTemplate is package-private.
Call new SeasonalityDefinition(a, b) as it will avoid an object creation.
Is there precedent in the library anywhere for using underscores?
Use FileUtils.mkdirs
You could change line 188 to final boolean[] success = {false};, success set on line 194 with success[0] = true; and return success[0];. This pattern is often used in similar situations. It leads to an allocation, but if the MOE is smart enough, it could optimize it out. And if not - flush is a slow operation anyway, so it doesn't matter that much.
suggestion Map out) {
+ desc
This description should mention TC and SC, I guess.
real and bigint still applies for qdigest right?
you import ByteBuffer, no need to use the full package path
You may speed up the hashing by having a ByteBuffer cache created at class level. You may create a 64bit long buffer and set the ordering once. Then, you can clear the buffer before putting a value in it then flip before invoking hashByteBuffer. In the other hand I can see the functions hashLong and hashInt in LongHashFunction. Maybe it worth to update the HashFunction interface so you can call these directly. I am not sure which options is the best or which one performs better.
What exception? To somebody reading the new version, this is confusing, this method doesn't throw any.
Collections.unmodifableList()?
missed formatter
No need to convert the List again to an ArrayList, Arrays.asList will be enough here.
It looks like this makes it case insensitive if it's otherwise an exact match, but case sensitive if matching a subtype, which is really an odd thing to do.
After checking how MimeBodyPart is implemented, it might make sense to tweak this to:  java return String.format("%s; charset=%s", mimeType, MimeUtility.quote(charset, HeaderTokenizer.MIME));
Implement this
please just define on the next row.
missing: a test for an empty ("") description and a null description.
should be static - please fix when you rebase
It's hard to see why one would care about having a stored value that's not current, and indeed it seems that this method is only used in ImmutableComputableGraph::statusToString, which is never used.
I think it is better to set the return value at the topmost level i.e. in executeQueryCommand() So I would suggest to remove this method, and rename executeCommand() to fetchAdvancedDetails(). And the code in executeQueryCommand() can look like: @Override protected void executeQueryCommand() { String volumeName = getParameters().getVolumeName(); if (StringUtils.isNotEmpty(volumeName)) { getQueryReturnValue().setReturnValue(fetchAdvancedDetails(volumeName)); } else { getQueryReturnValue().setReturnValue(getServiceInfo()); } } This also means that the methods getServiceInfo() and fetchAdvancedDetails() will return GlusterVolumeAdvancedDetails.
this "return;" statement is of no use.
Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?
Why is this method static? Only singleton access methods like getInstance() should be static.
sb.append(item).append('\n');
That statement should work, there's no need to modify the source here. If something is wrong maybe it's the file encoding during the git clone or other editor that changed the encoding. On my clone :  $ file src/test/java/org/mockitousage/matchers/MatchersTest.java src/test/java/org/mockitousage/matchers/MatchersTest.java: UTF-8 Unicode c program text
Empty catch again? :) AssertJ or suppress will work better for us I think.
@lukasz-szewc This line must be removed cause this was not tested in the original test case. For the same reason the call with '2' must be delayed by 20ms.
Looks like its only usage is in the CommandBus.Builder, so let's hide it from the public API.
should this only initialize the testMessageBus instance if it's null? (could be synchronized at method-level or in a synchronized block)
I think this method can be final with addition of extra "hook" (overridable) method to register handlers: public final void setEventBus(EventBus eventBus) { this.eventBus = eventBus; if (eventBus != null) { registerHandlers(); } else { unregisterHandlers(); } } /** * Override this method to register custom event handlers as necessary. */ protected void registerHandlers() { // No-op, override as necessary }
Same here: should be Branding, not ProductBranding
Why change the name the property? Accident due to mass refactor/rename with IDE?
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
This method might be the one in public.
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
Tiny style thing, can we put brackets round boolean expressions like this e.g. boolean valid = (files != null);
You can make this file File
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
Not sure this is right unless it's only supposed to work on *nix.
use an overridable getOperationTimeout() method instead
How about using snaeService.wait(500); instead and calling notify(); in the event handler?
For a lot of the uses of this method, this should be context.getServiceRegistry(true). It doesn't need to be for the getService(context) != null checks, but for the other ones if the handler is changing any state it should be 'true'.  * <strong>Note:</strong> It is very important that the {@code modify} parameter accurately reflect whether the * caller intends to make any modifications to any object reachable, directly or indirectly, from the returned * {@link ServiceRegistry}. This includes modifying any {@link ServiceController}, * {@link org.jboss.msc.service.Service}, {@link org.jboss.msc.value.Value} or any object reachable from a value. * * @param modify {@code true} if the operation may be modifying any object reachable directly or indirectly from * the returned {@link ServiceRegistry}, {@code false} otherwise
can jsonAsString ever be null, seems like you create a PhoenixJson object you it will always have be from a string
This line should be removed to ensure clientAuthenticationMethod is ClientAuthenticationMethod.NONE
Maybe have an overload that doesn't require this since it isn't used.
Is this really correct? ASCII characters would include all 128 defined ASCII characters, but the actual limits are smaller: <LINK_0> Perhaps this message should just spell out the requirements exactly: A letter or number, followed by letters, numbers, dashes, dots and underscores (underscores are not listed in the whitelist, but anything else is replaced by an underscore, making the underscore implicitly allowed). Maximum length is 63 characters.
no way username is null?
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
If any of the parts are null we'll end up with different strings for id nothing missing -> name/tag/instance/taskhost if tag is null for whatever reason now string is name/instance/taskhost.
requireNonNull(finalTaskInfos, "finalTaskInfos is null");
What does this have to do with Redis?
getClients(this, null, null)
Not exactly. findmeans that the initialization should happen before.
While getClients should have no initialization.
Seems redundant to have both static factories and public constructors in the public API. Especially when there's multiple overloads such as in some of the other processors. Can we choose one and expose only it?
shouldn't that be return retriesOnFailure.decrementAndGet() >= 0;? It returns the updated value, so retriesOnFailure = 1 would lead to no retries
Retry.NO_RETRY is already public, this getter is not necessary.
return columns.stream() .map(HiveColumnHandle::getName) .collect(Collectors.joining(","));
static import toList
suggestion .map(colMet -> newColumnMeta(colMet.getCaption(), true))
don't need to throw exceptions - just return null.
get rid of "..." not enterprisy!
still think that we should log when there is a not found mapping
I'm not sure it should be public from start. I have a rule to make public as less methods as I can. When you declare some method as public you must not remove/rename/change arguments of this method. So better to declare it less visibility unless you are sure it should be public
i think ovf can be null (looking at previous code)
You can put the text that's apart of the first append statement into the constructor of the StringBuilder.
Since you now have ConcurrentHashMap, you could cimply do return patternDateTimeFormatterCache.computeIfAbsent(pattern, DateTimeFormat::forPattern)
While UTC is the good choice for epochs, here we should use GMT to comply with the spec. ![image](<LINK_0>
Shall we extract a TeammatesDateTimeFormatter using DateTimeFormatter.withLocale(Locale.US) for use?
An IllegalArgumentException refers to a wrong parameter. I think an UnsupportedOperationException is a better choice here.
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
this noopSubscription seems used in many places, create a single one and reuse?
UnknownHostException not necessary here
new QueryResult<>() is redundant here
There are 3 studies. Can we change this to results.size() == 3?
This does not reflect the tryLock(long time, TimeUnit unit) contract. We may obtain the local lock but should wait for the result from DB exactly during the desired time. Or even better for the time which is left after the local tryLock. Can transaction timeout help us here ?
move check back as first in the method to not change behaviour if null is passed as unit but we are in the EventLoop thread.
Improper way to handle interruptions. They need to be propagated up by re-interrupting the current thread
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
remote this
The difference between this and offer0 is the assert and m_closed check only. May be it is OK if the m_closed check is done twice and we have just this offer and no offer0.
exception does not need to be caught.
exception doesn't need to be caught.
what is the intent behind having the store id in StoreToolsMetrics? Looks like most pass in dummy values
Is addToResponseBody() being used from within any other method? Like why have this method at all? Alternatively, why do this single check within write() when you do other checks within addToResponseBody()?
This must be supported.
Use the bulk put method of memory segment "put(ByteBuffer)"
One concern that I have is whether this method is only used for the determining the next billing period start date. I want to make sure it does not inadvertently affect offer parts of the application.
Also check [this](<LINK_0>, you should deep copy instead of clone in setters
Why you are using diffrent methods here? 1 . new Date(onsetDate.getTime()) 2. (Date) endDate.clone() Better to keep the consistency among the code, and provide your feedback why did you select that among others.
this view is using the same context. what about if you use the context from itemView.getContext() instead of passing a new parameter?
Redundant casting.
Remove this if it's not needed.
Nit-pick: like in HostNetworkInterfaceBondedListViewItem.java, the typecast could be inlined here.
use const LOG
you have already got listView as parameter, so no need to call "getListView()"
you could just do setConfirmWindow(null); like above method
I seem to recall this is not safe. Don't you need to use an iterator to modify the collection while iterating through it?
add a null check for getConfirmWindow()
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
@rui-castro can we inline this variable?
tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().
Style-nit: no brackets around single-line blocks
What's the point of this return?
No need for public setter as it's set in the constructor.
Seems like this condition is "No table manager found"? Should this log be on a null check for tableManager.getTable?
also same lookup pattern as described before
To avoid confusion, I think it would be good to used fully qualified names for all raw proto types while using short names for gcj models (or vice versa)
Remove extra empty line
In separate line ?
This should be package private. So, remove the public modifier.
What if we don't want to set it? How does the UI know that this has happened?
Not sure that it's good. If path is not setup - this.dir will be still null - and we just pushing NullPointerException one level down.
Does this method need to be public?
Check isDebugEnabled()?
What is the purpose of this error()? Why simple debug() is not enough? and at least whitespace after "client" word.
This (the whole method) could keep the same indentation char.
@lorobode Can you update these setters to use builder pattern and return LinkedContact object.
Should we check if the connectionId actually belongs to this <host, port> pair? There could be possibly error cases that connections to <host1, port1> are checked into <host2, port2>.
return queryId
Can we take the code that is in ensureCredential today and pull it into the constructor now? It's the only place we call it now and it will simplify things.
This is the same as the code sample above in 44 - 52.
To follow the conventions of Spring Security, please change to "webClient cannot be null".
We should log this properly too, I think. Errors in this class don't always bubble up where they can be inspected easily.
This is the one place we should crash and burn.
Should it really return null here?
if mockTime was incremented by exactly the time required to trigger the operation timed out error, why would we need a loop?
can you make "9" a constant as we use it most places
shouldn't this be "ServerErrorCode.Blob_Expired"
Shouldn't this be log.trace?
io.druid.java.util.common.concurrent.Execs#makeThreadFactory(java.lang.String)
Could this common logic be shared between in HttpEmitterModule and ParametrizedUriEmitterModule?
@Nullable but actually, why allow null here?
If we should never get here, maybe throw: throw new IllegalStateException() or some such.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
Please use [ExpectedException](<LINK_0> You can look at the [phone-number tests](<LINK_1> for an example of how it's used
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
It know it's part of the original code but it's better to clean it up. Remove these two lines, just let the Exception be thrown, it'll give clearer test error messages if there's a failure.
is there a reason to clone the whole VDS object? how about adding a method getVdsStatus to VdsManager that would simply return the status of #cachedVds ?
I see what you meant but that's a very confusing name since the collection holds VdsmVms
how about reportsOnExistingVmsInDb?
You can use ExpressionUtils.methodName(mit) for that.
Remove final modifier.
We could reduce the cognitive complexity by 1 using:  public static boolean isInvocationOnVariable(MethodInvocationTree mit, @Nullable Symbol variable, boolean defaultReturn) { ExpressionTree methodSelect = mit.methodSelect(); if (variable != null && methodSelect.is(Tree.Kind.MEMBER_SELECT)) { return extractIdentifierSymbol(((MemberSelectExpressionTree) methodSelect).expression()) .map(variable::equals) .orElse(defaultReturn); } return defaultReturn; }  or  public static boolean isInvocationOnVariable(MethodInvocationTree mit, @Nullable Symbol variable, boolean defaultReturn) { ExpressionTree methodSelect = mit.methodSelect(); if (variable == null || !methodSelect.is(Tree.Kind.MEMBER_SELECT)) { return defaultReturn; } return extractIdentifierSymbol(((MemberSelectExpressionTree) methodSelect).expression()) .map(variable::equals) .orElse(defaultReturn); }
Shouldn't the super.onXX() be the last call?
Shouldn't the super.onXX() be the last call?
Shouldn't the super.onXX() be the last call?
It always convert rows to BinaryRowData for comparing. Could we additionally compare the RowData directly when checkClass is true?
suggestion @Override public GridCursor<Row> find(Row lower, Row upper, BPlusTree.TreeRowClosure<Row, Row> filterC) { assert filterC == null; return find(lower, upper);
Perhaps it doesn't mean that rows are really identical to each other, but only that they have the same place in sorting order or I'm missing something? If this method will be used wider someday this may lead to usage of old values with NUMERIC, VARCHAR_IGNORECASE, TIMESTAMP WITH TIME ZONE, or may be some other data type that has distinct values with compareTo( ) == 0.
should we have Objects.requireNonNull in these?
Always enclose if (and other conditional) bodies in curly braces.
Seeing that the 'Edit Button' patch is already in master, I'd suggest rebasing this patch on top of master to avoid any possible merge conflicts.
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
"formats" is an ImmutableList, you don't need to synchronize on it directly to iterate. Here you probably want to make sure only one thread is modifying the time zones at a time though. I'd suggest putting the method itself synchronized instead, or using another lock at TimeGraphScale's level.
see above wrt logging
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
If we move the logic to the builder factories, this would not be needed.
Nitpick: windowId > Stateless.WindowId
Can you use try-with-resources for these to ensure they're closed even if an exception is thrown.
I think this should be after oos.writeObject(o);, in case there is buffered data. In any case, before obtaining the byte[] result.
looks like duplicate code, can it be refactored so it's not in multiple places?
better: return !inputSchemas.isEmpty() && inputSchemas.values().stream().noneMatch(Objects::isNull);
in input schema -> in the input schema
This function no longer needs to be protected. It should be private.
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
Shouldn't this be wrapped in a try... finally block?
This seems rather incongruent to me - should we define a dedicated filter for managing request-lifecycle MDC keys?
again, this cannot be, there cannot be unconditional chaining... the nego should be able to stop the chaining, please see current implementation of nego.
I don't think we want to automatically announce support for spoiler messages. The XEP is pretty clear that if a spoiler message is received the content must only be displayed upon user's request. But this can not, or only with to much effort, be guranteed on the library level. I think we should remove the automatic announcement of spoiler messages and instead provide a method the user explicitly has to invoke in order to announce support for spoiler messages. As beneficial result, the whole automatic manager initialization boilerplate code can go away
I think ServiceDiscoveryManager should be a field of this class.
I *think* that adding the disco feature is unnecessary in this place, as the ServiceDiscoveryManager already should announce that by itself.
@Happy-Neko Let's call this from, [avoid compound names](<LINK_0>
Ping.
@olenagerasimova it's not correct usage of Hamcrest-matchers, it may cause inconsistent state of matcher. You can check correct value to describe in describeMismatchSafely argument.
why cloneContextAndDetachFromParent()? that means that under the tasks tab the child commands won't appear under the create snapshot for vm.
Try to call getTaskIdList()
I assume we should have the same behavior as ExportVmCommand. Do we still need this?
replace with: Mono.when()
Scheduling a message isn't part of the scenario. Do that as part of your // Arrange.
What about sending a non-session message to a session entity?
So before this change, it would make sense to return the reference to the stopped service, since it wasn't part of the API that we supported re-initializing the ErraiService. But if we are going to allow that, maybe we should be checking isInitialized() here, instead of just service != null?
Injection constructors should be package private. Remove the public modifier.
There should be a null check here if it doesn't accept null values
catch throwable in activate method
Do we need two debug logs here?
this should probably fail on receiving interrupt
Should this be put in the try block so that the exceptions it throws are wrapped?
Same as getLatestSequenceNumber - save the current position and restore after
This call has the side-effect of actually changing the position of the pointer in the stream which may be unexpected by callers. You should save the current position, get the latest sequence number, and then restore the current position after.
Could remove the else
The student can be an unregistered student so googleId can be null or empty.
we should use student.getName() instead of AdamUpdated
throw NoSuchEntryException to keep it consistent with asyncReadLastEntry.
activator is never null
Some of the unsupported methods do throw newUnsupportedMethod(); while others do throw new CacheException("This context is immutable");. Maybe we could make them identical.
A ternary statement is fine here.
Why this change?
I imagine that -if- the state change is redundant it will remain in the intermediate pipeline list but won't generate a task and the variable task will contain null, generating a NPE. However, rather than checking if task is null, how about we subscribe to the FBM -only- if a task is generated? Also, I now realize that a state change in the intermediate list could be redundant one moment, needed another and back to redundant as the user changes settings. In particular, if a needed state change is made redundant, there is no functionality to unsubscribe from the FBM until the state becomes needed again. I think it's ok to leave the task in memory Finally, how about StateChange.value becomes "protected" so that you can write: fboId = frameBuffersManager.getFBO(value).fboId; That been said, I really wish we didn't go through an AbstractStateChange so that we could write: fboId = frameBuffersManager.getFBO(fboName).fboId;
add null information
suggestion if (unit.getId() == null) { unit.setId(UUID.randomUUID()); } units.put(unit.getId(), unit);
static import DataSize.Unit
what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
Debug has to be detected first otherwise we'll always take the INFO branch.
This is a change of behavior. Some tests might not require all nodes to be up and trying to enforce that here seems like a stricter check. The earlier check createKVS can succeed if we have quorum too. We can perhaps have a classRule in the test classes to disableAutoCompaction if thats the first thing to do? Does this nodetool command require the node to be up first?
this code snippet is the same in all of these tests. Have you thought about just making a new CassandraContainers rule which wraps the Containers rule and just contains a CassandraKeyValueServiceImpl?
inline raw() ?
Is this if needed since there is no else for it?
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
Same concurrency concerns as stated above.
Provider.class is very general, could end up returning providers of other types. Simplest solution (if we want to pull in injectors registered by other sources) is to track Injector.class - or we could create our own interface that extends Provider<Injector> that other people could use.
Please add { } even if its a single line statement.
suggestion var service = getCandidateServicesToMatch(serviceId)
style nit: no braces around single line
Shouldn't we also add field. getSchema() to the fullName? Because some users have custom schema's that element+qualifier combinations that overlap with the dc-schema (e.g. atmire.date.issued).
we can just call repeat(" ", n)?
i'm not sure i would put possibly deleted. i would suggest leaving that part off, or, since we can determine that, figure it out and then put it if applicable.
The attribute type needs to be exact here. suggestion public <T> AttributeRenderer<? super T> getAttributeRenderer(Class<T> attributeType) {
Same here: return Utils.copyAttribute.....
Please add ? and % as well
unnecessary array new: {{true}, {false}} should work here
Do these strings all need to include the escaped newline? Everything seemed to work ok for me if I replaced all occurrences of \\n with a simple \n? On a related note, would that change make the matrixAsString.replaceAll("\\\\n", "\n") lines removable too?
Maybe IOException since it's supported here?
Throwing SQLFeatureNotSupportedException may cause JDBC applications to not work. It would be better to print out a warning message.
How about this one? I think there'd be a standard error code for this.
This should be written this way. We also have to keep the code readable.
It would be good to change this to private
See if you can change things like this to just return "Invalid response";
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
WRT to the changed logging, shouldn't this method return a success indication (boolean), so the caller could at least log one error message that the server is not running / listen?
Nit: Objects.requireNonNull will ensure we never accidentally cause NPEs to be thrown.
these setters should not be public
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
why synchronized?
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This should really not be public.
I think I prefer "Invalid key" as exception message
Could you use one check of CoreUtil.isNullOrEmpty() here?
Does this action exist in material_select? It should, but need to make sure.
Please consider to evaluate 'typedItemList.indexOf(item)' only once.
@Happy-Neko Same here, let's use IndexOutOfBoundsException with custom message.
Great tests. I'd suggest using nio (Files.copy and Paths), rather than bringing in the dependency in the org.codehaus.plexus util, that is available now, but is not listed explicitly in the project dependencies. For simple things like these it's almost always better to use standard java library stuff in tests.
Are you sure that was not used in a "normal" use case?
this is just a setter, why we need to update it?
I prefer to leave this as package-private to avoid a synthetic accessor.
this.clientTags = Collections.unmodifiableSet(requireNonNull(clientTags, "tags is null"));
likewise: can make package-private to avoid a synthetic accessor
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
Where did 31 come from? Why not use *=?
this needs to be wrapped in an if (timestamp != null) check
you should do the ImmutableList.copyOf() at the constructor, and here just return the list directly. This will ensure that the constrcutor's caller cannot modify the list stored in this class.
Seems like we could use the check here too?
I think we should also check for empty or whitespace only strings.
Nullness of this is already tested in computeHashCode().
Instances can be null or empty in case of no instances in ready. Null check and empty check is required here right ?
else is redundant here
missing a final
This is the checkout for one smart alarm perday, so shall it be DUPLICATE_DAYS?
That's a lot of nested ifs, can we simplify?
Don't need to start at zero every time, keep a static var holding the last returned value. A from-scratch search will need to be done every launch which avoids any issues with uninstalled mods.
brackets or nothing.
using a check with next = null might not be good enough. What happens if null is used as lower bound? I would like to avoid this leading to endless lopps
Well it would be the more correct thing to do if we didn't know how the viewer was implemented, but in practice both method implementations are identical in TableViewer and they return the same control.
This method overrides StandardGDBDebuggerPage.dispose(). Why don't you just use super.dispose() in it and dispose only of the widgets and classes added to GDBServerDebuggerPage?
Should workbenchLabelProvider.dispose be called as well when non-null?
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
Unnecessary SKVI<K,V> parameterization?
This should go before this.starts.next() as if this.starts.next() is empty, it will throw FastNoSuchElementException and the previous iterator would not have been closed.
We should use other method, this ends up creating an AccessControlScannerThread unnecessarily.
Could you include the invocation-future toString in the exception message?
throw new IllegalStateException("Current thread " + Thread.currentThread().getName() + " is different from the operator thread " + operatorThread.getName());
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
Since v is not used/needed, could use thenRun here like .thenRun(() -> cd
In principle I like aspects of this PR but we cant accept it as it as is because its using a the ForkJoinPool without the ability for some one to specify another ExecutorService. When ever code uses Threading then the ability to control the underlying ExecutorService is super important. Managing threadlocals and security managers and so on can be important some some people (it very much is at Atlassian where I work) and hence you need a way to inject your own ExecutorService into the mix. For example notice how graphql.execution.ExecutorServiceExecutionStrategy takes an executor service say. This is done for that reason. Make this code require an ExecutorService, default it to ForkJoinPool.defaultPool() and have the static methods also take an ExecutorService.
i think, passed collections cannot be null. Can we put a null check?
You could have returned the result of addAll to make the returned value a bit more meaningful. This (historic) boolean API is a bit weird though.
This will fail if toolingIds is null. It is not necessary to wrap the argument into an ImmutableSet here, feel free to remove, and also apply this to the setFields, filterByIds methods.
No need to log here.
no need for logging here
can we optimize this part? Now we deserialize key for every call.
I would prefer  return this.archiveId == null ? TestNameTransformer.getTransformedName(getFullName()) : TestNameTransformer.getTransformedName(getFullName()) + "[" + this.archiveId + "]";  or an equivalent. We should not be allocating a StringBuilder for the verbatim case
This should be a PrestoException(NOT_SUPPORTED) error, since the operation the user requested is not supported. HIVE_METASTORE_ERROR is used when there is a (normally transient) metastore error.
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Is it possible to throw a more specific exception?
[optional] Directly return the result in both cases and eliminate the 'token' variable?
can you pull this from a static string?
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
please extract as constant
You change some methods signatures/arguments into _*NameCount*_ but these methods still containing _Segments_ wording
Did we want to have this normalize the path also by returning the normalized version from Path?
It seems like we would be better off making this actually return the path instead of a String. It's different than the old API, but I'm not sure I see the use of getting a string back.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
This is breaking the pre 2.9 tests. We could just check that the string matches up to the \n.
Why do we need this change?
Uneeded spaces
return fp;
we can assert a bit more, check if ids of endpoints are the same
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
There should be an assertion I believe ;) assertTrue(conflicting.contains(...)); And probably alos useful to check that model.di and model.notation are not in conflicting state in the git repo?
possible exception
Do you hate static imports? :)
{ }
I think I mentioned that: there should be a new test regarding validation of this attribute in ElasticsearchSchemaAttributeValidationIT. Unless I missed it, there isn't any?
Mistyped config path, should be Properties.Fire.BlueFire.RangeFactor
requireNonNull
Same thing as above, let's split out a config for this.
Now the commit action is not enabled when I select a non-project resource. The method getRepositories does only work for projects.
can be !isDisabled()
Do you forgot to compare items and label?
So all HashFunctionPartitioners are equal to each other? What about the 3 different variables? Also the hashCode is broken as that uses 2 of the fields :(
once again, equals/hashcode - does it make sense? please revisit in all value types you created
Index could return a List<Question> instead of List<Long>, right? The less logic we have on the controller, better
artifactId is not enough... groupId and packaging must match too
Can Java 8-ify this method and replace the body with a streams/map/collect one-liner: return names.stream().map(name -> new ColumnId(tableId, name)).collect(Collectors.toList());
Don't block the merge on this, but these three System.out should probably be handled via logging
use Files.delete(keystorefile.toPath()) that will give you proper error
log error
If you would like to do lazy initialization for the singleton, then you will need to be careful about concurrent calls to getInstance. This class doesn't need lazy initialization, so you could just initialize directly when declaring the static variable. Then, you won't have to worry about concurrent calls.
Are you sure this synchronization is right? If "factory" is a new String object for every call, then it won't never block
I would say use a flag  @garrettjonesgoogle thoughts?
We always use brackets, even if the if only has one statement. Same goes for the else clause below.
Since the label text is static, you can set it in confirmChangePopup.ui instead. ("text": "Rebinding instead of "text": "Title")
don't you want to make something like this ? saveButton.addClickHandler (new ClickHandler() { @onClick(...) { onSave(); } }); or i cant see why not like this
This class is still beta--I would be OK just making this method non-static and using the registry
This is standard procedure in our existing registries. :+1:
Alternatively: Qualified.class::isInstance
Instead of changing the method that is getting called, the missing one in search query can be added here and it seems the updateDomain method in managementserviceimpl is not in use. It can be removed
Please use Collections.singletonList()
why use such a complicated dialog, why not use the code used in the wizard when creating a new view model?
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
Can use validatePrimaryLanguage here and below.
If we write "language", the switch-case no longer passes.
Can you handle parse error here?
Not sure we need this method. Couldn't we just roll this into the setPollIntervalMinutes?
nit: I think it'd be better to call this enableInterval
Why not public access?
What about "fail[]".length() instead of 5?
Optional should be used in interfaces. Use null as internal value.
Still why do you need to make separate subscription for each separate RemoteServiceInstance and keep separate future map for each service instance. Single future map and subscription would be totally enough for the whole system.
rm public
I just thought about it, but GET /domainMappins can be potentially an expensive computation as it iterates on the all content of RecipientRewrite tables to find domain mappings. Maybe we should allow to get domain mappings for a single domain. Something like:  GET /domainMappings/fromdomain.com ["domainalias1.com", "domainalias2.org"]  Wouldn't you mind adding it?
Find / replace mistake
- Can we inject the EventHubWrapperFactory into the EventHubSystemProducer, EventHubSystemConsumer and EventHubSystemAdmin instead of class-loading them via config? It'd be much cleaner with types that way. Use-cases at LinkedIn that require tunneling can inject their tunnel-aware versions of the EventHubClientWrapper.
How does the subscriber know the producer doesn't emit if we never request it too?
Changes this to: return newKeyExpression( colKeyExpr.getDatum(), colKeyExpr.getPosition(), // This will cause the IN expression to be removed from the where clause and // processing to continue for subsequent row key columns Collections.<Expression>singletonList(node), // I actually don't think this is used anymore, so I'll remove after I pull your change in. // Instead, the above extract node list is used where this was before. But this is now // an equality check instead of a filter between the min and max in the list list. true, ranges, node.getChildren().get(0)); 0
I'd say this should be loaded when new instance of this class is being initialized otherwise there is a chance that multiple loads will be performed in multi threaded environment - e.g. when several kie servers connects at pretty much same time.
!keys.isEmpty()?
Should not it be [less than 20](<LINK_0> ?
just to repeat the question I had in the test code, what happens if you set badgeCount to 0?
This represents a poor API. If you are not going to provide a working implementation for all versions, the newInstance method should be marked @Nullable and you should actually return null. This way callers explicitly have to write:  java if (mHighlighter != null) { mHighlighter.highlight(...) }  An alternative strategy is to add an isSupported method that NullHighlighter (prefer NoopHighlighter as well since null has no semantic context here) implements and returns false, then throws on all other methods, forcing callers to write:  java if (mHighlighter.isSupported()) { mHighlighter.highlight(...); }  The reason for being explicit is so that readers of the highlighting code can see plainly that it might not be supported and that would explain why it's not working for them on a naive/quick read of the source code. Forcing folks to dig all the way down into the implementation to see that possibility is frustrating.
key.setDataId(event.getId()); -> key.setDataId(event.getDataId()); This issue was the culprit for failing on itest profile. I am going to test the cluster profile to check if everything is green also.
Variable name choice is confusing because it shadows the field key
metric?
Maybe make it protected instead?
Why is it done lazily? Seems we'll need it in any case?
@marko-bekhta I just noticed this change. What does it have to do with this patch?
Above three lines are duplicated.
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
for readability I'd suggest creating a small private method which maybe takes a date divides by 1000 and casts, looks a ugly over and over.
Once we start using placeholders, the getString() API can actually support it via additional parameters; it's pretty cool. suggestion String dialogContent = getString(R.string.confirm_deletion_message, " \"" + listName + "\");
please also add the GUID which is important.
break the line
It would be nice if we didn't return mutable copy of metadata here
what does passing a null type in mean?
Can this call Client.getMetadata rather than require a separate method to retrieve MetadataState?
Use InetAddress.getByAddress(byte[]) instead? byte[] addressBytes = { 0xff & hostAddress, (0xff & (hostAddress >> 8)), ... }; try { inetAddress = InetAddress.getByAddress(addressBytes); } catch(UnknownHostException e) { return null; }
I don't think this check is relevant
Do either of these two 1. Add address.equals(InetAddress.getLocalHost()) to the check as a local inet address may still not match the two specified conditions above. 2. Create an unresolved InetSocketAddress in getRMWebAddress with canonical hostname and check for null InetAddress here
i think it's slightly better to add one more argument in AzkabanFlow constructor called type, and let builder handle the default parameter passing.
Enforce immutable and non-nullable lists. If this is a read-only object, not something users will build and send to ARM in a request, then avoid having nullable collections (the typical tags field of an object is a counter-example as we need to send it as null, so we enforce immutability but not its presence): java new AutoValue_Metric(data == null ? ImmutableList.of() : ImmutableList.copyOf(data), id, name, type, unit);  Apply this pattern to all lists in the new model classes.
we never use NULL, it is a bad practice in general.
We should probably log something if there's no provider. This might save someone some debugging time
if you create replacement here, and there's no new test in following patches, make this method private as it seems, that this is not use from outside of this class.
This check can be removed if we rely on a bug-free DS implementation. Correct?
The same as with previous - make it final, don't check for null (reduce amount of lines)
I don't like the idea of doing more than necessary initialization works at the constructor level. It should be whoever uses the class' concerns. A simple setter like  public ZkBucketDataAccessor(ZkSerializer zkSerializer, BaseDataAccessor baseDataAccessor) { _zkSerializer = zkSerializer; _zkBaseDataAccessor = zkBaseDataAccessor; }
IllegalStateException floated from HttpRoutingDataReader should also be caught.
nit: remove else {}, throw exception after if block.
StringPool.EMPTY instead
I don't think it's a good idea to make a special case for this. We can POST the options in the body for all changes requests
Consider to do this only once in the onInit(). Even if it is void method call, it is still a CPU tick on every single incoming message.
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
This is the one place we should crash and burn.
change to charge_created_successfully
Should we close the activity if an error occurs retrieving notes, and the current note is null?
You are using Toaster everywhere in this class except for this message. For the sake of consistency, use the same class here as well.
I'm not sure why you remove hidden cards here.
Rather use an EnumSet here, with addAll()
I guess we're not consistent across the codebase on whether method annotations should be on the same line as the method signature or on their own line(s). Let's pick one or the other and stick to it on at least a per-class basis, though.
make function synchronized. Res: done with syncronized block
Does this need to be a singleton?
Make use of the [lazy holder pattern](<LINK_0> to prevent the conditional at each call.
Strange parentheses here ( selected), maybe this was a cast before?
embedcode2 - please name it according to the purpose of usage
Once we move to a simple, declarative boolean passing model, we won't need this line.
Please don't use System.out in production code ;)
Instead of calling those 2 setters, you could try invoking validatePage which should take care of fixing button enablement.
M-m-m. What made you to do these changes? Thanks
Recommend adding a link in the report to the LBA Wiki that explains what this error is and how to fix it. Maybe a link to general information about Validate Requirement Changes so that we could add other things as needed. An this would just be one of them.
Typo: hel
These constant names may be confusing since they are only being used in event notification validation to size the items for the database and have no meaning for the rest of the Concur processing (request extract, collector, sae) validation messages.
Please put entry.getKey() in a local variable.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This test would be useless if the map had been initialized in the class.
Better to add the exception as the second argument
same thing here.. how connection would be null?
this line is repeated in the else statement, so can be moved to above the if
As we have ALL, I think you can just add only ALL here.
or just java public static Object[] data() { return TestPlatform.values(); }
this.
![MAJOR](<LINK_1> 'Severity: MAJOR') Call "tagName.isPresent()" before accessing the value. [![rule](<LINK_2>](<LINK_0>
Why do we have different checks in these two tag methods ?
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
This isn't needed (you can store null, and who cares if we save/restore a device and later replace it in #onApiChange?)
generally we like to keep the super as the first call on methods unless there's a need to switch
"isSearching" should be a class level string
please fix the whitespace. You just need to return the options here.
Please initialize this with setMaxInflightRpcs(BIGTABLE_MAX_INFLIGHT_RPCS_PER_CHANNEL_DEFAULT * BIGTABLE_DATA_CHANNEL_COUNT_DEFAULT)
This should definitely be a different PR.
We might use a NavigableSet instead if a TreeSet is used, I assume.
Sometimes I also try to protect internal collections, but normally it only complicates things later. Can we return it as-is?
Can this return a List<JsonPatchOperation> instead?
This inevitably is linear. What about key-ing tasks contexts by their ID (maybe as a separate structure in this class)? Or persisting returned value in UpdateSystemMemory?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
If taskStatus is not null, should you try to fill in what you can of a TaskStatusPlus from it, instead of returning null, to maintain behavior similar to previous in the case that taskMaster.getTaskRunner().isPresent() evaluates to false?
Could this be a static field?
Replace by Objects.requireNotNull()
Shouldn't be similar occurrences of checkWhiteList replaced by checkConfiguration?
just use a raw string here no need for String.format
BufferUtils.byteToInt?
Is this class thread safe? I don't see any guards being considered if multiple threads access these methods?
we don't need to check other == null here, the next condition check covers it.
suggestion return Objects.equals(address, other.toString());
suggestion return Objects.equals(messageId, other.toString());
KernelMemoryAnalysisModule
If this module doesn't belong to the active trace of this view, it will never be consumed.
hmmok, might as well do it right, I'll push another version in a few
consider merging both lines
Should one of the following happen in case contentType passed is null? - throw an exception, or - set this.contentType = null
Why allow a nullable input here? Users wanting a null content type can just call the String variant, no?
Will * <LINK_0> * <LINK_1> work as well?
You can create a constant to include the "http://" string and named as **HTTP_SCHEME** for instance.
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
I hate 'this'.
We probably want to make events() returns List<EventType> as setEvents()
This does not guarantee that the list is mutable, which is required by addEvent(). There's an inconsistency because setZoomedEventList() is not overridden. Although, I'm leaning towards doing no check at all in this class...
It looks like this makes it case insensitive if it's otherwise an exact match, but case sensitive if matching a subtype, which is really an odd thing to do.
return Boolean.TRUE.equals(bypassIfSameMimeType)
forName(mimeType) can throw MimeTypeException ; i think an NPE would occur in that case
IMO should be reverted; see discussion below.
hard coded paths doesn't looks good at all
This shouldn't be hardcoded
This can be simplified to return this.cmd.hasOption(optionName));
This should be replaced with a guard method.
Should make a differentiation of the name and id.
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
just curious, why getRootCause(exception.getCause()) instead of getRootCause(exception)?
check for cause != null
suggestion throw new UnsupportedOperationException();
unlockAllReturnHandler should be used.
This won't invoke the additional interceptors, is that okay?
why not use super? like: return String.format("%s, volumeId=%s", super.toString(), diskImage.getId())
please use vmDisksSource here as well
please use getVmtGuid
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
why not call the new method with null as third parameter?
reportservice
This will silently ignore the exception. Should be throw Throwables.propagate(e);.
-set and why do you not add the id ? Currently this message is not that helpful if you want to debug the issue as the id is silently swallowed. Or is the id part already contained in the MissingRecordException ?
can e be final?
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Why do we need double logging here? One when logException is called and later in 101-102.
"Initial connection"?
it appears that this change can be reverted.
I think keyStore and keyStorePassword should be used here for replication ClusterA -> ClusterB (or both sides can use both keystore and truststore if mutual authentication is enabled)
static import SECONDS
Why final at variable level?
better to have fail(); in the onSuccess()?
better to have fail(); in the onSuccess()?
better to have fail(); in the onSuccess()?
This assertion is probably not buying us anything
Redundant assertion
Redundant assertion
final Set<Type> majorTypes = EnumSet.noneOf(Type.class);
That would require a resize of the underlying map, as the default load factor is 0.75... Let's just use new HashSet<Type>( getAssignment().getImportTypes() ) followed by just the .add( enumType ).
Better to not use a list here: Queue<Type> next = new ArrayDeque<Type>();
You can make use of early returns here to reduce nesting, e.g. java if (userInfo.isAdmin) { return; } if (!userInfo.isInstructor) { throw new UnauthorizedAccessException(...); } // everything else
Should this be getNonNullRequestParamValue?
The null check can be omitted as it is checked inside verifyAccessible
Is it really filter name?
I know this default is here for backwards-compatibility but I'm not sure about the value. If I create a factory - "OffsetDateTimeFactory" - I wouldn't want that to be the logicalType name. In other words, what do you think about the default implementation being: default String getTypeName() { throw new UnsupportedOperationException(); }  This way it is required by any new LogicalTypeFactory to implement it?
If you have a translation use that if possible.
Cache this value.
Why absent?
Use the caching util as I mentioned before.
This should return T.
it is possible that getItemAtPosition returns null -> sure NPE here
It should be get from enumerations array size once types shift to enumeration.
Should this throw IllegalStateException? Seems like bug case.
Use LOG.debug, because this data does not contain much information.
Now when distinctValuesCount.isPresent() && !nullsCount.isPresent() we return absent NDV, while previously we returned NDV with a an error. Maybe it is better to return the something with error than nothing.
Missing super() call?
Inverse order.
Now we only support copying one object? Why?
You should be able to delete the try-catch here.
Could alternatively use Objects.requireNonNull(locator, "null statement locator")
The volatile modifier on the underlying boolean returned by isValid() should result in a safe double-checked locking impl, no?
I don't think we need to observe on any particular thread
Revert this and keep explicit
No assertions?
You're not checking the mediatype here. At this point, do we just have to assume that jax-rs has called the above method and is giving us something sensible?
How about using GSON.toJson(o, new OutputStreamWriter(entityStream))? We should also make sure to flush the writer before leaving?
Not sure if I'm a fan of using this exception, as it looks like it forces the use of another exception mapper. Have you tried doing just a WebApplicationException with the Response.noContent().build()?
remote this
Isn't the isSessionExists condition enough?
if getSessions(Arrays.asList(sessionId)) returns empty list you'll got NoSuchElement exception here. May be we should return null in this case ?
Why is this change needed? if so should the deprecated method not call this one.
Why allocate a new array? You already have created the array; why not just set the array element ?
Should make a differentiation of the name and id.
bad hashcode.
Done in: <LINK_0>
should remain int too
The return type should be IEclipsePreferences so as not to expose an internal implementation in a public API. Curiously, I don't get a warning here, only in EMFCompareRCPPlugin. Don't know why, but must be changed anyway.
UNKNOWN is basically a stub for anything. For example, during test, we write a file using some fake key provider, and set it to unknown. As long as the reader uses the same key provider, it is able to read the file without making the fake provider an actual provider in the proto
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
ewwww, abusing try/catch for this is really unideal... We have a Pattern for Numerics you know?
Why do we need this fail statement?
There seems to be different order than it should be. Please check it with old message.
I don't think replacing the bus and dispatcher proxies is a good idea. There could be references to the old proxies that are held by other classes. Like this proxy, you will probably want to reset these bus/dispatcher proxies and close the same instances again.
I suspect that this is going to cause a performance hit, because this is in the hot path and the init() method in ProxyConnection introduces and additional dereference and method invocation. I initially did it like this, but eventually introduced it as an additional stack parameter to the constructor to reduce the overhead.
mind the code style
Use java.util.Objects.equals().
I do not like amount of UnsupportedOperationException , if we do not know what to do in such methods ..... is it better to put that to class implementations ?
This should be both .class and .this, because this should allow us to get all debugger events dispatched jobs or only for the current dispatched.
This method doesn't clone the extra components nor the formatting
Another access change API violation, same a little below. If not needed then lets not change it here :-)
Could you please replace event.getTarget with a variable to make it clearer
equals!
Missing finals for all tests in this file
please replace with if else construct
This log will be shown pretty often..
Let's remove this? overcomplicates the code
java .subscribe(new Action1<ResultType> { });
why have extra lists on heap?
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
I feel like we're overthinking the setter. If the user is purposely setting the value to 0, I think you should just let them do it. This code makes this API less readable and introduces complication since the 0 mutation should be reflected in the UI as well. you should just let my old code die, lol.
we never use NULL, it is a bad practice in general.
Whats the meaning of catching an exception just to rethrow it under a different class?
If you make the EMPTY_EXPIRES, you could use it here.
How is this expression different from "this"?
needed?
I have found a bug in this latest patch. The line 107 should be modified so it considers the RefRight.ALL value is "refs/*" but a RefControl instance to "refs/*" would have its refName member value equals to "refs/". So, the correct code to 107th line would be: if (!RefRight.ALL.substring(0, RefRight.ALL.length() - 1).equals(getRefName()) && getProjectControl().isOwner())
Throw an unsupported operation exception here.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
new ArrayList<>(causes);
Generics on the right side are redundant since Java7
We don't need another ImmutableList.copyOf. You are doing this when parsing.
You don't need this line because of green 31.
Could probably replace these hasSize+contains calls with containsExactly, but nbd, this is what the existing code had.
This should use the new fixture function createBucketRequest() instead of reconstructing the Ds3 model
what's the difference between line 165 and line 173 test cases ?
Maybe consider moving this if statement where you call the method instead of inside it
should probably be getParameters().isUseCinderCommandCallback() && <remove stateless snapshot or create stateless snapshot>
fail() if no exception?
Please move to a separate "Polishing" PR.
Please add curly brackets for the for-loop.
Add the expected events and the event in the failure message
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
throw -> failure or exception?
Maybe IOException since it's supported here?
extract as constant?
why not just getResourceManagerRoot().toPath();
Would it be possible to change these two to constants as well?
Maybe make this "Initializing monitor for..." to distinguish between the init() and configure() method below.
You should see it from the side of the user, not of the implementation
synchronize
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
java "MetadataImpl{name='" + name + "'}";  would be simpler
Change string to "EmailAddress{" + value + "}"?
can we use BeforeClass annotation?
DateTime.now() is preferred over new DateTime()
I have seen pcapNg files with a different extension. They don't work because the code expects pcap magic number...
Run formatter
We have a new U.nonNull() method.
Code conventions: we don't use curly brackets around single line blocks
Probably we should log the exception here (debug or trace), just to help with troubleshooting
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
Please extract the variable for the class name.
Could there be value in adding a warning statement if we detect current being 1000ms less than last? That could indicate a clock drift, which might be worth logging (although we wouldn't want to spam it(.
token.sum() can be replaced with getToken()
Could the instance var metricValues be dispensed with and the following done instead? java @Override protected void prepareMetrics() { long now = System.currentTimeMillis(); if ((lastUpdate + minimumRefreshDelay) < now) { recordValues(updateFromZookeeper()); lastUpdate = now; } }
These two assertions should probably be their own tests, testNullPath and testNullPathWithRoot respectively.
why not just getResourceManagerRoot().toPath();
I'd add a guard to prevent surprises if (db.isBare()) { return null; }
This might cause null pointer. Consider using Objects.requireNonNull wrapper.
Why do you need to add this check here, but not this one ? if (!"".equals(adapter.getSearchQuery())) { showSearchBanner(); }
Interesting. Not an error ofc but calling notifyDataSetChanged() is something the Adapter itself is usually in better position to perform rather than the adapter's user. Any particular reason not to do the call inside setPeopleList() for example?
Would you also add an IS_NULL filter here?
should the SortExpressionExtractor be renamed as well?
It's sad we had multiple params per line before. Let's fix it by having one param per line.
Hi @diegolovison , I think the message here should be not stopped but: Pattern.compile(".*\\[org\\.jboss\\.as\\].*started \\(with errors\\) in.*"); (at least this is how it was before Gustavo's changes) Would be great if you will fix that too. Then I will rebase the PR as I am facing this issue too.
Why is this needed?
Please group mr, ms, and mrs together
This is a breaking change, since it no longer invokes the filters in reverse order. So please revert this.
better do the close in a finally block.
- Are you sure this is enough? Containers, which are started by scheduler, are not part of the cluster. Therefore they are not stopped. If I recall correctly, the scheduler gets killed by destroy(), but schedulers remain running - CLUSTER is annotated by @ClassRule, therefore stop() will be call through MesosCluster.after()
Why exception is logged and thrown? Any reason?
Locking the configuration shouldn't be necessary. FileBasedConfig extends from Config, and Config is thread-safe via atomic references. So you just need to determine if either file needs to be refreshed, and if so, run its load() method again to pull it in from disk.
Should we check for systemConfig.isOutdated() as well?
This should return a builder with the current options set.
This method should be static and need not pass this as an argument to the constructor.
1. How can users combine JAVA-2205 and JAVA-2201, e.g. by using the programmatic API _and_ loading from a different classpath resource name? Is the idea to use new DefaultProgrammaticConfigBuilder(Supplier<Config>, String)? 2. Why not follow similar patterns in the code base and call this interface DriverConfigLoaderBuilder (or maybe ProgrammaticDriverConfigLoaderBuilder)? Similarly, shouldn't this method be called just builder()?
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
commit is not used.
Put a new line in after every \n to make this readable. Or alternatively put the blueprint in a file in src/test/resources/path/to/file.yaml and load it with new ResourceUtils(this).getResourceAsString("classpath://path/to/file.yaml").
These should be inline - not required for testing
quasiIdColumns and infoTypeNames  should be inlined
[minor] This public can be removed.
catch IOException and rethrow to avoid wrapping an IOException with an IOException
"Error while moving file from ..."
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
nit: space between if and (
nit: space between if and (
nit: space between if and (
dimFilter is non-null, so could be simplified unless you want to stick to "as IntelliJ generated" form.
"" to remove the last ternary
"set up" as a verb is two words, so should really this should be setUpFilters
add "this" qualifier
Would it be better if use StringUtils.defaultString() on the string methods?
After rebasing with the TmfTimestampFormat patch, you could replace "-9" by ITmfTimestamp.NANOSECOND_SCALE
Is this necessary? If I remove the update line everything seems still to work.
pls substitute these three lines with setInternalState( this, "jvm", jvm );
Not sure you need the catch here? Since it's a test probably better to throw it?
It should probably return ISegmentStoreProvider
externalize
rename to callgraph...
Should return ReadOnlyArray.
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
I think we should also check for empty or whitespace only strings.
please change this to simply return Objects.hash(...) to keep the boilerplate/LOC down
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
Where did 31 come from? Why not use *=?
Shouldn't a cast to int be enough?
Shouldn't a cast to int be enough?
Shouldn't a cast to int be enough?
Not your change - we should actually set this to the saved stdOut - ideally saved around L85 (now L97) System.out
Run-on sentence; does not explain WHY user should use other api. Preferred: "This method is deprecated and may be removed at any time. Please use ..."
What do you think about moving the url strings into constants?
Please use MiddlewareRequestException and add the message in mw_messages_es.properties
suggestion if (bundle) {
wouldn't it be better to return List<File> ?
suggestion return Framework.getService(FileManager.class).isUnicityEnabled();
can be !isDisabled()
We usually want the config default specified in properties file, there is no need to provide a default in java code.
we shouldn't need the ?test param any more
Missing final
@marcaurele I think this needs to be changed back to Long, or else the method cannot be found as it is called with type Long.
This should invoke the other constructor so that taskData can be marked as final.
I'm wondering if we cannot avoid this cast. Maybe we can extract a private method buildFromInternalTask that takes org.activiti.engine.task.Task internalTask, Task.TaskStatus status as parameters and returns TaskImpl instead of Task. This would avoid casting here and on fromWithCandidates. What do you think?
can be refactored into commcare task
remove mRoles
It looks like we can rely on event.value to give us the user name, so perhaps isAvailableUsername isn't necessary?
As we discussed on the call, I think it'd be a good improvement to have this logic by itself in a helper method.  private void trackMagicLinkSignupIfNecessary() { if (AppPrefs.getShouldTrackMagicLinkSignup()) { AccountModel account = mAccountStore.getAccount(); if (!TextUtils.isEmpty(account.getUserName()) && !TextUtils.isEmpty(account.getEmail())) { mLoginAnalyticsListener.trackCreatedAccount(account.getUserName(), account.getEmail()); mLoginAnalyticsListener.trackSignupMagicLinkSucceeded(); AppPrefs.removeShouldTrackMagicLinkSignup(); } } }
This does eventually emit the CompositeException. Is this consciously wanting to handle each error individually instead of only via the composite?
Please add a space after (Class<E>).
I would suggest reference.getEReferenceType() here, for pedantic correctness.
suggestion + "'><label id='labelId' someattribute property-binding='[[foo]]' "
I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?
instanceof is null check itself.
Better to throw an IOException.
can it return null?
If logFileLocation.logFile == null, then the line above will throw NPE. In addition, no need to call logFileLocation.logFile.getParent() twice.
check it like this - disk,getDiskStorageType() == DiskStorageType.IMAGE
Please consider to extract to a different method (like isInternalManagedDisk)
/s/Disk/DiskImage
You can replace the screen position click with TestUtils.toggleNavigationDrawer().
this "closeSoftKeyboard()" is not doing anything, because you are using the wrong import. you are using android.support.test.espresso.action.ViewActions.closeSoftKeyboard, which is a ViewAction, so it has to be done in a perform. if you just state it outside, you create a new ViewAction object and not doing anything with it. the correct one for this would be: android.support.test.espresso.Espresso.closeSoftKeyboard, which is a standalone action like "pressBack()". so either: import static android.support.test.espresso.action.ViewActions.closeSoftKeyboard; ... .perform(replaceText(validName), closeSoftKeyboard()); or: import static android.support.test.espresso.Espresso.closeSoftKeyboard; ... closeSoftKeyboard();
please use the static imported method (allOf) as in the onView above.
new ArrayList<>(causes);
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Throw an unsupported operation exception here.
TrackType parameter not needed.
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
To make this final?
throw UncheckedIOException(e)?
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
please create a more specific exception that extends this one.
please make sure you are rebased. this method was renamed on Feb 11.
i think something is wrong here, when host moves to up this command is called, status shouldnt be non operational, also the reason, so this always returns true?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
So, this method now looks a bit odd: it invokes just obtainConnection() independently of this.isSingleUse(). I can guess that synchronized(this) makes sense in case of !this.isSingleUse(), but how about to move the synchronized(this) to concreate implementation of AbstractClientConnectionFactory#obtainConnection() ? From other side it looks like we should use ReadWriteLock around theConnection. Let me know your opinion and I'll push polishing
++ is not thread-safe, so connectionCounter would need to be changed to an AtomicInteger.
Changeing default later will be considered breaking. Can it be enabled by default
Don't you mean lessThan(second.getLowerBound())?
Have you checked that the test fails if the this assertion fails?
In case of duplicates, you may be publishing more metrics?
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
IseException is a REST exception. We should throw something like a ConfigurationException here instead.
Please add a space after (Class<E>).
these 3 methods are public do you really need them?
Will this ever be used outside of jolt? If not change it from public.
never null
How about passing an already positioned and limited input stream? (doing inputStream.seek(readStart); and ByteStreams#limit outside)? If you do that then most likely you won't even need this class.
We can write this code as, java ClassLoader classLoader = ServerConfigurationTest.class.getClassLoader(); return classLoader.getResourceAsStream(path);  IMO this would be more readable
this constructor feels wrong now... I think it should be a Module and a Definition and then the constructor calls getCombinedGrammar.
Explain.
To generate parsers only kast.k is needed. Why are you including ALL the builtins?
return authentication.getUser(username);
This class has no fields so its methods should be static.
merge line 76 and 77
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
I think you mean (d<=0)
Upstream is already thread-safe, so this isn't needed.
If the ping cannot be sent, would it maybe mean the connection is already closed? Would we also want users to submit bug reports whenever this happens? I suspect we may want to no-op if the ping cannot be sent.
I would log warn here and not rethrow unchecked exception, especially since closed will never be executed (could be wrapped in finally block).
It does not seem to matter what the disconnect message is, or does it? We probably do not need to assert a specific message.
We can use bit-operators here to test for the bits in the permission bitmask :) Executable is 0b001 = 1 Writable is 0b010 = 2 Readable is 0b100 = 4 So we can replace this with: java return permission & 4;
why not just if(200 <= responseCode && responseCode < 300) ?
// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off
reduce to debug
can not -> cannot
Use PercentType instead of DecimalType and you do not need to divide by 100.
Also add: - plugin_type - this will be needed if we have more than one driver installed, and if we ever attempt to do automatic host install
seems as unneeded cast
This isn't doing anything special (such as transform) before calling forEach, so write it as a normal for-each loop
This must be implemented.
We definitely need to refresh the ListInfo here. This action mutates the list.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
setReadTimeout and setConnecTimeout accept values in milliseconds, you're putting seconds there as I can see. :)
like line 63 but this is setFeature, so should be removed?
This log does not tell what subscription it refers to. What's more I think we should log it for all subscriptions, whether http/2 or http/1.1 client is selected.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
You can also use IO.close(bb) as IO.close will not throw any exception.
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
You can change the 28 case to a default case, and remove this.
Gson doesn't run on these versions so I don't see any reason to include them.
Unsigned types are not used in the current implementation. So, you can omit them.
You can make the return type here more specific so that you don't to cast to SchedulerTask elsewhere
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Actually the underlying objectExpr could have free variables.
Apply try catch to this line only
is try catch block necessary here?
initializeYoutubePlayer method call OnError makes a loop if device is unable to initialized the youtube player each time. We should show error message to the user after 2-3 times of retry.
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...)
Non-standard equals?
Why is this if needed?
The second condition should be clusterId <= MAX_CLUSTER_ID
return queryId
Question: What would the returned URL look like for a local JAR? Could you give some examples here?
Here this can be package-private and not public. Also we should annotate it as @VisibleForTesting.
@bxf12315 can you check the expected String here instead of just notnull?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
Should use the log, maybe a warning.
Hm, you got java doc on the next method, but not here?
This can simply return NON_APPLICATION and isApplicationType() can be removed. The methods will always return false.
isSensitiveAction() and isSensitiveResource() will always return false, so the calls can be dropped.
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
Don't you need a super.setUp() call here?
please use baseActivityTestRule.launchActivity() (without the "null")
super.init() method never throw an exception.
Why do you include the size of the binding set as part of the hash code?
I would recommend an else if here to avoid comparing against a string unnecessarily.
seems like synchonized is not needed here, given increment/decrement already protect
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
This probably doesn't need to be wrapped any more. Also, when it's unwrapped the nls suppression can be inlined?
This should be ISE. Also, it would be better to check the exception message as well. Please refer to AppenderatorDriverFailTest as an example.
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
It is the same in this line, leave a blanck space before "+"
More user-friendly to say "', only Switch, Number, Dimmer, Rollershutter and String items are allowed - please check your *.items configuration"
Because of the changes to supported item types, this throw message should probably be updated to something like "Items of type {} are not supported."
Restore to original. Also apply to the other similar throws.
maybe getReturningItems, the clause suffix is not really informative.
The magic constant 2 is a smell here, can what's happening here be clarified a bit?
ditto, s/i/identifier/
This is unsafe, since attributeType is protected and can be set to null, but the contract is to return supplier only on non null values. This must be rewritten to check for the null value first.
You could break each of these sections into their own predicates to increase readability.
should we use an equals here?
Do we really want to sleep for 1 sec? Also, with a constant sleep time it is possible that one thread gets starved of locks, if other threads keep jumping in. Might be worth sleeping for a random amount of time, say between 50 and 300 ms. Also, you're not converting time to ns here.
add prefix to "About to invoke" message too
Don't need to return the Arguments.
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
This method should return RemoteCache<K, V>.
Missing types
Instead of making this string concatenation every time, do it once in the constructor and cache it to the field.
Here we should return Polygon or MultiPolygon or create two implementations?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
script services must cope with nullable values. layoutExists is not nullable thus please keep the null check additonaly before the layoutExists check.
It's really not clear if this is the source or the target.
toString() should be used only when you need to "print" the reference (like in a log message). Otherwise, if some other code may be resolving the string reference later then you should use a proper reference serializer.
Perhaps you can remove the temporary variable entirely and use map to make this method a one-liner?
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
change
change
please create a more specific exception that extends this one.
So that is getting a thread that is local so as to get the classloader?
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
We have thread executors. It is important it must use these. Also this solution uses up a thread permanently which goes agaisnt some of the thread modelling. Look maybe to use schedule thread executor
looks like we're only updating the timer metric if it's a writeAround cache. I'm not sure if we should do that - metrics should be updated regardless since you're measuring the time it took for the "delete" operation right?
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
this method deserves a description
No need for super()
calling super not needed
This line is duplicated.
nit, Collections.EMPTY_MAP?
nit: this is a slightly nasty way around the line length issue.
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
isSecure() return true if "coaps is used and false if "coap" is used. The naming is not so good with the OSCORE addition (so maybe we need to rename it but later.) So in this case isOSCORE should not impact isSecure()
final
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
We can get rid of the above variable
What is the reason for appending 1 to the variable name?
Was this implemented like so in the emrapi module?
Is it just my tired eyes or is this backwards?
please make sure you are rebased. this method was renamed on Feb 11.
@kishorekasi Generally wondering if this will increase the latency of the operation since we are not failing and retrying connection?
Please use -'getExistingNicsBusinessEntityMap()' instead of directly- 'existingNicsBusinessEntityMap'.
private ActionReturnValue attachToClusters(List<NetworkCluster> networkAttachments) { networkAttachments.forEach(networkCluster -> networkCluster.setNetworkId(getNetwork().getId())); return runInternalAction(ActionType.ManageNetworkClusters, new ManageNetworkClustersParameters(networkAttachments), getContext().clone().withoutLock()); }
Although the HostSetupNetworks will ignore it. Isn't it better not adding it to 'attachmentsToSync' at all in case 'attachmentToSync.isQosOverridden()'. Not that important, giving +2...
This commit appears to duplicate changes from the #430. Is this intentional? Which branch do these changes belong on? They should only be on one or the other. Please amend one of the branches to fix this.
There must be a reason why we are hiding translation spinner here (in fact, there is a separate method for updating actionbar spinner).
We didn't use the custom action bar before. No need to use it now.
you should add isAfterOrEqual and so on
you removed stats.waitUntilBuilt(). Why?
Some brackets might make this a bit easier to read?
Given the other changes, I wonder if the handler is needed at all or whether just need a way to disable it. If keeping it, I wonder if onReceived(Map<String, Object>) and onProcess(Map<String, Object>), and then all _received_timestamp and highWatermark logic could move into the handler.
we should not modify the original properties. I would just return properties; here
shall we use mapToSortedString like in other tests? it probably would make tests a bit more readable.
This is always non-null. load() throws an AggregateNotFoundException when an aggregate can't be found.
Why can't we use aggregate type to note this?
This blocks multiple invocations from the same unit of work, but will not prevent different UoW to trigger the creation of a snapshot....
This will delete all queries in the application.
It's not good idea. Group 'Registered users' contain over 40k users which will be retrieved from DB. You could better write a hql query to retrieve a limited list of users from given group.
Possible race condition.
And get in the end to check that there is nothing in the collection on the matter.
I think here must be store.get(file1) to be sure that the replace hasn't affected the collection.
I see it's just a copy/paste of similar code above, but note that you can do just file.refresh() instead.
Just use Collections.addAll(...) ?
do we need to unvoid..?
imho it should just be write(...)....
suggestion
suggestion
grammar nit: 1, not one, and no :
Can be private, I think
Do we need this?
// nitpick-mode-on Can you change this.ctx to ctx? // nitpick-mode-off
This method is a good idea! I know I'm nitpicking, but may I suggest to skip the contains() call and just do a get() and if null, then return defaultValue? This will skip at least one MultiMap call.
this method is useless. Can you send a patch to remove it so all the code that needs uuid will simply use UUID class?
Oh my, identifiers in strings! This is a maintenance nightmare!
throws IOException can be removed
closer.register(executor::shutdown);
Shouldn't we change memory reservation here?
Use Widgets.isAccessible(shell)
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
Should be !socket.isValid()
Wrap up in a SamzaException or add separate catch blocks for general exceptions and SamzaExceptions if you'd like them to be treated differently
Nevermind, I see it is the Future.get() that throws the InterruptedException.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Instead of allowing null for additionalClasses, I think it would be better to use an empty collection, and mark the parameter NonNull (or use ParametersAreNonnullByDefault). I suppose we need com.google.code.findbugs:jsr305 on the classpath (scope: provided).
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
synchronized (disposableResourceProviders) { disposableResourceProviders.add(provider); }  ?
You could add a check(String sqlQuery, java.util.List<Row> expectedResult) to FileSystemITCaseBase.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
use createTempFile
You can write this in a more compact form by reusing the return value of StringBuffer methods, e.g.,  String string = new StringBuffer() .append(method).append("\n") .append(endpoint).append("\n") ... .build()  And actually this is equivalent to just using + for concatenation.
toString() formatting.
IDE propose me to replace it with String, like java return "host " + host + "\n" + "HostName " + host + "\nIdentityFile " + SSH_BASE_CONFIG_PATH + getValidNameForSecret(host) + "/" + SSH_PRIVATE_KEY + "\n";  WDYT?
This empty is unnecessary, I believe :)
Isn't it also important that adType was async and method was top?
What do you think of testing this ad type in another slot for example MIC or new BLB?
What is the reason for appending 1 to the variable name?
use final
Spuild we ise IDType here instead?
why have you delete metricName (metric id) from hashCode ?
permissions can't be null, otherwise the constructor would throw a NPE.
should hashCode really depend either on taskName, or description, or hashCode?
Suggestion: maybe call these encrypt64CharacterKey and encrypt32CharacterKey or something instead of encrypt and oldEncrypt; the latter doesn't provide a lot of insight into the difference, and will just need to get renamed again if/when we change the algorithm again.
![Oh Hell No!](<LINK_0>
suggestion if (eventData !=null) {
final missing. Same for the other ones.
"Initial connection"?
Subclasses are also doing this. The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.
Actually _all_ components have a distributable flag, so you shouldn't filter on analyzers here.
I think you still need to check if the tree has been disposed?
Shouldn't there be also a check that old name does not exist anymore?
I would suggest create method for computing that selector and instead of replacing strings we can use string concatenation like: String.format("div.autocomplete div[title=\"%s\"]", toolName); Or we can use that inline here.
1. please change one letter: "Verifyimg" to "Verifying" 2. do you need screenshot here?
this method should return ArticlePageObject object
decrease to TRACE level
this.m_
The generic type information is lost at runtime and the XML only declared TemplateRegistry, I am not sure if this is always correct
Looks like it should be s/location/expiryQueueSize/
is it better to use name instead of null?
How about putting a name for the thread? It may help in the future if we need to debug.
Any particular reason that you published an EventStatus instead of publishing an EventOutput directly? Remember that pumpEvent exists.
Are we using dots or dashes? Either way, we should make sure that this is consistent.
You may want to make the default smaller - like 0.01.
Best to avoid logging any passwords, some end users will actually audit log files to ensure no passwords are logged.
Can we declare global final variable for "JKS" and refer in code?
We can use try-with-resources now. I know this is only a refactoring but we can take this opportunity to clean up code
Check for equality of error code
Check for equality of error code
Check for equality of error code
we should not declare to throw generic Exception
This should call all  java return all(params, (RequestOptions) null);
Should we maybe wrap other throwables in a RuntimeException here? Or throw a new RuntimeException? Seems inadvisable to just ignore an error. Someone who's already using this might see an AggregateException with no causes.
Again, use IOUtils.
You can do this with IOUtils.write(), too.
ALL_CAPS is for class-level psf Strings. These should either be moved to class level or just passed directly to createTempFile without making a one-time use string variable.
Optional
Return if the list contains
It would be good to make it configurable whether or not the email gets masked. It's not a must for now but I'm willing to bet that someone will create an issue for it in the future.
Not sure if there is any chance that a trigger has no context or context=null. In that case, this will throw a NPE. wdyt?
Where here is just disabling and in the ifs above and below is hiding? Not saying something is wrong, just interested.
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
nicer to have a method IncrementableEntryVersion.incrementVersion()::IncrementableEntryVersion to take care of this. Would drop the not-so-nice instanceof.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
Please check if this method really should be public in a private static final class. The parent method is protected.
Have you intentionally omitted index check?
These 3 methods should be private, or if useful outside of this controller, they should be in a utilities class
Do we need the toString() here?
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
As setInstalledLineNumber, this should also set RESET_INSTALLED_LOCATION
I think the "if" is the wrong way around here. Or more precisely, we must always do the super.decrementInstallCount() The way to test if super.decrementInstallCount() is working as expected is: 1) insert breakpoint, observe it is a blue dot, no check mark 2) start debug session, the breakpoint should change to a check mark 3) Stop debug session and breakpoint should become a dot again.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I'm not sure how I feel about the use of null here. If the keys can ever propagate back up to the blocks layer, this could cause issues. I would recommend giving the key a name like "distance" or something similar for consistency with the other sensors that report values.
This is probably not correct. It needs to be a good approximation to make A\* working fast and correct. If it is too small A\* will be too slow, if it is bigger then a single value in real world then route results can be incorrect.
The problem is that we do not handle negative integers in getDist yet: val / INT_DIST_FACTOR and I prefer having this check as early as possible. See also #1544
Aren't just 3 asterisk enough? :-)
I don't think you need this new String
The link member should be removed and this line may be replaced with:  java return this.baseStyleGuideLink + this.name;
Should we sort the fields (an other validation targets)? The reason is that you might have two assertion failure and being deterministic might help. (as we might not need to be deterministic in compiled output order)
Let's reduce cyclomatic complexity by inverting the condition and returning the ignoredFields immediately, and then de-indent the for loop.
Actually the underlying objectExpr could have free variables.
If possible, generally please make all values final. It is one of the main rules to achieve functional programs.
(minor) I would test the positive condition isEmpty() and swap the cases. It is less information for the human brain to process and ! can be overseen
Can we compute this lazily only once hashCode is called, then cache it in an instance field?
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
Better to create a new set, rather than update the super set. The super set might (and should, I think) be immutable.
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
What about hashcode and equals, should they need to be regenerated with the new boolean
this can be simplified by using Objects.hashCode(commandId)
use Objects.hash()
lowercase for package names.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
Remove throws Exception
nit: Unsupported
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
This should have just package visibility (for now it's just for HostProcess to use).
nit: Unsupported
As we are not exposing the original Scan directly, why to create a new Scan again here? No need
This should have just package visibility (for now it's just for HostProcess to use).
Avoid the scannerLock object and synchronize on KieRepositoryScannerImpl.this. I believe this will make also clearer that you're sync'ing on the same lock of the scanNow() method.
if test is in same package, then visibility can be default
child
defensive copy?
null? why not just a () -> {} ?
The local var is useless, you can remove it.
Seems doing all these potentially long-running operations as synchronized leaves a good chance for deadlock. Not sure how waitUntilAllOperationsAreDone ever completes if it's not empty, since you wouldn't be able to call operationComplete(), no?
I don't think this PR addresses the problem. There's an extra lock here but the lock was already acquired on line 168 and the lock is reentrant so I don't think this does anything. As best I can tell the problem is the call stack that can happen here (all while holding that lock): RetryHandler#performRetryIfStale BulkMutation.Batch#setRetryComplete RpcThrottler#onRetryCompletion At this point outstandingRetries.remove(id) is called, which will cause a ConcurrentModificationException on the next iteration on this line. If that's all true, then we should make a local copy of oustandingRetries.values() (because it's backed by the map: <LINK_0> and iterate over that.
Sorry but I did not find where we call the close method?
+ desc
real and bigint still applies for qdigest right?
"robot explain --input <file> --axiom <axiom> --output <output>"  Default reasoner should is ELK (returned by CommandLineHelper.getReasonerFactory(...)) so the user wouldn't need to specify that. Maybe make a note in the docs? And if you link to the reason docs, they can see all available reasoners.
Is this a reason to have separate if statement instead of while (!shutdown)?
Why this debug log is removed? Not sure, if it's there for any security issues.
I would be inclined to add another catch block here for Exception or even possibly Throwable. If a RuntimeException is thrown for example, the SessionAliveChecker thread will die silently.
It's not public, it can be changed. We need to have it backward compatible for one minor version. If this is to be released as 3.9.4-c1, MC 3.9.x and MC 3.10.x needs to be able to work with this. You can add extra fields which we will use in an upcoming MC 3.10.x release. Removing the field needs to be delayed until HZ 3.11 where we can adjust the codebase to not expect the field.
A simple "for" loop would be better here. We've been made aware that lambdas have a bad impact on metaspace and that can add up if we use them everywhere. I don't like to have to avoid them, but since it's easy here...
To be on the safe side, I think we should add a type check here, as we don't want one stat to prevent all others from being sent in case of a casting error.
java String desanitizedCourseName1 = SanitizationHelper.desanitizeIfHtmlSanitized(obj1.course.getName()); String desanitizedCourseName2 = SanitizationHelper.desanitizeIfHtmlSanitized(obj2.course.getName()); return desanitizedCourseName1.compareTo(desanitizedCourseName2);
By right, soft deletion should not result in InvalidParametersException
This should either be on the same line as the if condition, or it should be inside brackets. Or you can change it to the opposite condition, and move all the logic inside it instead.
Reading an Config object and then writing it again should not alter the XML. This code will do that. This is better: if (subSingleCount == null) { subSingleCount = inheritedConfig.getSubSingleCount(); } But there's a ConfigUtils.method to do that for you. Don't do defaulting in the inherit() method, do it in locally in the build methods (so it doesn't change the global fields of a config class.
Is it an exceptional case for ConfigLoaderFactory to not be present here?
It looks like this will already get logged as part of createConfig. Do we need both?
If you are going to do this do you need to @sychronize? If not indicate it is not threadsafe...
this
This would be safer if rewrite it in the following style: java return getMetadata() == null ? null : getMetadata().getName();
consider renaming this to detectLanguageBatchWithResponse to be consistent
"0"?
"0"?
it doesn't work for multi reference + complete tests please.
Inverse order.
Now we only support copying one object? Why?
Unneeded parenthesis. You probably can one-line this method anyway :)
Preferably have one call the other?
Why not just use a regex?
change to IAdaptable
The super() returns "" on null. Why should we differ?
we don't need the enabled variable nay more. We can directly return the parsed boolean value.
now that we have some permissions in common in ImportVmCommand and ImportVmFromExternalProviderCommand, we should probably move the code that currently exists in ImportVmCommandBase#getPermissionCheckSubjects to ImportVmCommand and have the permission check on the destination cluster only in ImportVmCommandBase as it is common to all import commands, what do you think?
would you mind inverting the condition to simplify it and skip the negation ? if (isImageProvided()) { ... } else { ... }
make permissionList private variable, permissionList should be created only once
won't this throw a runtime exception if the other object isn't a Page?
pls use Objects.equals for comparison
It is not, this change should be reverted.
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
This is similar to Compressor
take a look at how the output schema is generated from the inputSchema, <LINK_0>, if it is not in the mapping list, it is identity, if it is, it gets mapped to some other value.
You can set the label test in the ui binder file for both versionLabel and userNameLabel now.
String.valueOf() shouldn't be used to display integers since it doesn't consider the user's locale. Use i18n.number() instead.
These values should be set in the FXML
Can't we do this once at the start, since we always enable(true)?
The config should not be explicitly saved (it already is when ZAP shuts down).
on each user modification your method will be called and gather+process all the text inside the editor.. Try your modification with huge file.
I think the granularity should be 1 seconds instead of 5 seconds here.
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
I don't think we should do this. Perhaps as a fallback if getCanonicalName is empty? It's a change of format so it's a breaking change. Or perhaps we could adapt the test? I haven't looked in details yet so thinking out loud.
Ternary if?
There should be some kind of a warning if the cost function, provided as a hint, is rejected because of an invalid type and the default implementation is used.
Should we put the check here too?
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
1MB tips this into the scale tests. If this is the size needed to validate perf then make this test a subclass of S3AScaleTestBase and place in org.apache.hadoop.fs.s3a.scale
assertThat( Strings.isEmpty( " " ) ).isTrue(); ?
Reverse (expected first)
Please don't do cleanups in the same commit as bugfixes/features/improvements
can you make those no-arg constructor private?
I don't think copy is required here. Even if we did this for immutability, we'll have to do this again in getter methods which we are currently not doing. So, just copying here isn't useful.
in general, I'd be consistent about when you're using "final" or not. This applies to all other areas of your code.
Since listener execution order isn't guaranteed, do we want to validate this this way or just .contains() each of the values?
Why do you need a TypeReference? Why does retriableHttpGet need to be generic? It's a private method, used once, and its logic and logging makes it specific to fetching tasks.
Slight concern here is that we'll be notifying these observers before we actually persist the state to the database (which will happen on completion of the persistence method/transaction) so there is still a chance this will sent notifications but the database won't reflect those changes. Also since calling all the observers seems to be in the current thread it will delay the database update by however long each of those observers takes to do their work. Do you think it would be better to fire an asynchronous event instead?
this does seem to cover some people who might have a legit reason. but some do "gc/runFinalization/gc".
Returning Run here seems a bit cheeky for this method as API.
This check is out of order. You would have to do the get before the delete.
generate hashcode again, it doesnt account for caseSensitive.
Does the operand really can be null?
What about items and label?
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
Why changing the method to be static?
s/n/name/ n is always an index
~~The tests are not covering the bug that you fixed. I can change back this line and your tests still pass successfully~~ nvm, i realised my mistake.
Kan bare skrive: return ZonedDateTime.now().isAfter(header.getExpectedResponseDateTime());
This will be a breaking change for developers not using the Identity library and using this class directly from the core for their custom credentials.
I think we have to make as BlockingQueue and use its poll(timeout) to block the testing thread for the message from the async internals. There is no guarantee that all tests are going to be direct and sync. WDYT?
It seems to me you would still be able to implement this method. You are just going to have 'eventType' as the first element in the partition list.
To save duplicated logic, this method should call the maximal overload.
Can you revert this and pass the configuration to the construction of FolderMonitor instead.
Can we return a copy here?
When we create the index view, there is a slightly more hydrated version of ui configuration that gets sent. We would probably want a new pojo that mimics that. It includes things like shell commands/etc from different ares of singularity configuration
int[] props would make everyone including the style checker much happier
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
This method sums over the second and third dimension.
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
should mutateRpcTimeoutMs be an int or a long?
In this impl, JobCoordinator is responsible for the life cycle of containerController. If we add awaitStart(0 inside JC, then there is no reason why StreamProcessor needs to know about containerController anymore. Can we make this cleaner?
Why do we return the parents name instead of the name we store a few lines above?
possible exception
Is this supposed to be <code>return "Bump"</code>?
suggestion Objects.equals(value, other.value);
Objects.equals
Objects.equals
Please change this to  java return new ArrayList<>(failures);
you can do something like CategoryField.class:: isInstance
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
@exper0 full path HmRsHeader.VALUES_STR
@mavrk I think you mixed tabs and whitespaces in the description.setConcept(this) line. in OpenMRS we use tabs. Please remove your whitespaces.
/** * Gson objects are very heavy. The app should ideally be using just one instance of it instead of creating new instances everywhere. * @return returns a singleton Gson instance */ @Provides @Singleton public Gson provideGson() { return GsonUtil.getDefaultGson(); }  It would be handy if we could not create Gsons here though I don't know how this class is instantiated by room
Use org.ovirt.engine.core.compat.StringHelper.isNullOrEmpty(String)
not needed
I would suggest making this method synchronized
there should be a break after this line. we don't want to fetch everything, just one element is enough
this.stashedStarts.isEmpty()
The ListenerList implementation already takes care of this. Remove the "contains" test.
No use checking if the list contains() before remove(), let's avoid double iterations.
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
A good opportunity to not hardcode the port here, but rather use findFreePort()
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter.
negative logic
negative logic
Is it needed here? Doesn't line 764 do it?
I think this is cleaner  public long size() { return writeOutBytes; }
This is way harder. We need more than just the change. The user's notification filters might include "reviewer:foo" and thus require the approvals. So you'll need to loop through all of the filters, compile them, and get their own NeededData values and union that with your own need for the change here.
Is there a serde test for this?
Delegating to type would be better here, and would work when this Binary is used for Decimal.
We also need to override that in NestedUDTMapper and EnumMapper (using an enum as partition key, though unlikely, is possible).
We should consider extracting the functionality of the stringValueOf(...) to some helper/utility class, as we may use the same functionality elsewhere? :cake:
A method starting with "set" that has more than one parameter does not define a property, so should just be ignored rather than thrown an exception.
We need to have a backup plan here if type isn't a TypeVariable.
Do you think we really need to add the method name? The error marker will be raised right at the concerned method, so I don't think that's necessary. I'd just say "No implementation can be generated for this method. Found no method nor implicit conversion for...".
Same here - you need to close the stream
It's better to restore settings back. java prev = erlangSettings.SPACE_AROUND_ARROW; try { erlangSettings.SPACE_AROUND_ARROW = true; doTest(); } finally { erlangSettings.SPACE_AROUND_ARROW = prev; }
"discovery.zen.minimum_master_nodes" should be defined in a constant because it's used 3 times in this class.
close does an implicit flush
Why not throw IOException and let caller handle and log etc.
Can you reduce the nesting depth here?
Should you check if there are some files you should still delete, in case this error happens?
throw exception
Throwable suppresses Errors like OutOfMemory exception. These errors are supposed to be fatal in Java. I would rather handle Exceptions only (FindBugs does not like it IIRC) or propagate Errors
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
These shouldn't have changed.. The bicep min/max should be 5-90 ... not 0 to180. The change in behavior in setMinMax was fixed .. these changes should be reverted.
Please add the permission needed => "Requires 'Administer' permission on the specified project"
note when rebasing that i added the following here to handle missing data:  if (data.numHetsInSegment(segmentIndex) == 0) { return Double.NaN; }
It seems that the only advantage of breaking apart the AlleleFractionState is that we can avoid the issue of shallow copies referring to the same AlleleFractionState.MinorFractions list when making proposal states?
This method is only used in test code?
Should be outside the if
The combination of succedded and force is not clear to me, let's discuss this; I believe this API should change.
And then else if this
Operation operation = snapshotTable(snapshotName, tableName); if (operation.isDone()) { return; }
why?
Here the SnapshotStatus contains parentpath as well, the path will be the one wrt the actual namespace not with respect to mount table. You need to replace the parentpath with path corresponding to the mount entry. if mount entry is : /mnt -> /dir in ns0, then if you trigger call on ns0 the path would be something like /dir/sub.. that you need to change to /mnt/sub.. In case of InvokeConcurrent you would be able to get Src and Dst from the ret and maybe something like this may work -  response = ret.values().iterator().next(); String src = ret.keySet().iterator().next().getSrc(); String dst = ret.keySet().iterator().next().getDest(); for (SnapshotStatus s : response) { String mountPath = new String(s.getParentFullPath()).replaceFirst(dst, src); s.setParentFullPath(mountPath.getBytes()); }  For the invokeSequential one you won't be having the detail on which location did the call got success, For that you have to get it returned back from RouterRpcClient#L858, I guess to get the location returned you would require a new InvokeSequential method which returns the location as well, may be can refactor and reuse this one... This problem would be there I think in getSnapshottableDirListing() as well. If you want, you can put a TODO and handle the location stuff in a separate follow up jira for both API's.
make sure all the if/else if cases in encode() are covered, e.g. '\t' is missing.
How about a test for an override in a nested class?
Can you remove the System.out.? They are unecessary
Minor: you can decrease the visibility modifier for some methods here and change some methods to be static.
If from can't be null don't declare it @Nullable.
Use braces for all if statements. Alternatively you can use one-liners, but braces are typically preferred.
why?
Would not use the work "type" here
should we also require non-null deserializers?
You want g.add(null, checkBox) and put the display name onto the CheckBox widget. This way it shows [x] Foo instead of Foo [x] and users get a bigger click target (the label text) to mash with the mouse.
Would it be better to create a function to just mark all the cards and use that in testMarkAll, testDeleteAll and testUnmarkAll?
I remember some discussion for coming up with this logic of selecting cards randomly. Have you decided to remove that?
It is confusing to have unrelated asserts in one test method, please split those into separate tests.
@fanifieiev the same above.
@Iprogrammerr Please use IsEquals from hamcrest in these two assertions
Why not check isEmpty()?
Why not check result.isEmpty?
Can you use isEmpty()?
should this be named getRelativeDestinationFolder then? But the way it's used in ImportHandler.java is not relative so it looks like it's the field that needs to be renamed.
This could be replaced by Folder::new.
externalize
@pefernan here the message should be: logger.warn("Unable to parse value of " + KieServerConstants.KIE_SERVER_MODE + " = " + modeParam + "; supported values are 'DEVELOPMENT' or 'PRODUCTION'. Falling back to 'DEVELOPMENT' mode.");
Same here, the code doesn't count with the case when config map is used for other things than Kie server state.
Regular?
This method can be private.
nit: you can merge both lines above as checkNotNull will return the given argument
I think you should use writeShort instead of writing two bytes separately.
Mock this also.
MessageQueue.RegisterBankAccount_EventMessage
can you break up the long line?
same here (using getNode)
In every other test, you name variables ast, ast2, etc. and you put them in order of variable names. This is the only one that breaks that pattern. Can we make the layout here similar?
This doesn't seem like a very detailed test unless we have one that is more complex than this. Can we have a test with more then 1 AST to show we stick with only the first one even if there is more.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
This was already a problem with this in the old code, but the parameter name strings and values are mismatched here.
assert name != null;
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Expose Map if you can
What's the point of adding a copy here?
Curious: why need to track closed in DriverSplitRunnerFactory?
I'm pretty sure that the setting of this local variable must happen within the synchronized block, and maybe at the old location the set was happening (not sure about the state machine), otherwise, you may observe an old stale value. Also, I'd merge this change into the commit that creates these classes.
Could be renamed.
The last assert is different from the first 2
please test other types as well..
I guess null check is also will be nice to see here. Like java assertNotEquals(a, null); b.setDefinition(null); assertNotEquals(a, b); assertNotEquals(b, a);
<LINK_0> Let me know if you have any issues managing or adding items to the project
Can't we return the size in the case of MapCacheStoreAdapter?
nit: one param per line; keep the first line empty
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
nit, Collections.EMPTY_MAP?
usually data objects never return null where collections is met
Coding best practices: Interface i = new Implementation();
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
no need to specify type on RHS
You can define private static final int DEFAULT_WORKER_COUNT = 4..
Be more specific with your error message
Maybe try to run something bigger here, that has more stages and tasks
@fchauveau there is no null handling of source, is this intended ?
Run formatter
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
Is there a reason you chose _system_name environment variable instead of the os.name system property as described in the [Java properties](<LINK_0> tutorial?
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
There should be different ways to compare the type, based on the given type expression: 1. Check for equality with the fully qualified type name (including the namespace information) 2. If no namespace is provided in the given expression, check for equality with the type's display name 3. Check for equality with the fully qualified XML element names (including the namespace information)
I believe it would be more understandable to do the following:  // Throws a GitLabApiException if format is invalid format = checkFormat(format); Form formData = new GitLabApiForm().withParam("sha", sha); Response response = getWithAccepts(Response.Status.OK, formData.asMap(), MediaType.MEDIA_TYPE_WILDCARD, "projects", projectId, "repository", "archive", ".", format);
Change back to urlEncode(filePath) after fix to AbstractApi.urlEncode(String s)
Yes, this would be a good idea.
Override
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Better: '|'
Should this try to create a URI with the old logic when it's null for retro compatibility ?
It's wasteful to be calling getRequest() in these methods. Consider taking in the original Request and storing it in a field alongside the mutable result of newBuilder()
revert this unrelated formatting change
This is effectively your synchronization barrier? After fetch(...) returns, you are guaranteed that the value will be populated in the cache, assuming the writer is utilizing the same cache. Am I understanding this correctly?
Putting fetch inside get() might not be good. If this api blocks writer, writer can starve because fetch can really take a long time due to hole fills. If this api doesn't block writer, then the NoRollBackException issue will still occur quite often as this reader may override the writer's value with no undo record.
Its more consistent to release the resources on close()
Here one could advertise the existing Hints.GEOMETRY_CLIP, so that the StreamingRenderer instantiates the clipping collection only when needed.
Seems like we need a new method FetchHints.validateHasEdgeFetchHints(Direction, Label...)
See above about checking the labels
Help me understand why lazySet is safe to use here. It seems we want to have visibility of this value when we next read, but my understanding of lazySet is that it does not guarantee that.
I don't think we can use lazySet here. Take a look at this definition: <LINK_0> > The semantics are that the write is guaranteed not to be re-ordered with any previous write, but may be reordered with subsequent operations (or equivalently, might not be visible to other threads) until some other volatile write or synchronizing action occurs).
Make sure you have a mutable details field here.
socket might be null if an exception was thrown in sendToSocket catch clause.
Why that new close() can't do this for us, too?
> Use this.removeCallbacksAndMessages(null) instead. Done in Patch set 2
new HashMap<>() will do
better to return an Empty Map, otherwise callers would need to check
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
s/Kills/Kill
+ desc
l10n
This injects mutable internal state. A copy is needed.
no need for the manual check (especially for the unannotated parameter).
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
id is not creatable
We need to also support platform 2.1.*
What do you use refRep for?
Does TYPICAL_LOG_MESSAGE need to be a local variable? You can hard-code /typicalLogMessage.json here if only used once.
Suppress the non-localised string warning here. //$NON-NLS-1$
Let's not delete the file? As of now, the .jtl results file isn't deleted either
Should be a space after ,.
I don't know what to do about it right now, but I would be a lot more comfortable if the Model lifetime was connected to the PsiElement lifetime. In my ideal world, the models are just a veneer over the PSI. That's not to say it's the _right_ way to do it -- just a gut feeling. I worry that local caches in the model can become out of date as the PSI changes (the user types, and/or refactoring). Maybe my concern is unwarranted. Do your concerns match mine?
I'd prefer to use the instance variables directly get as an indicator it is modifying something within the class. getLibraries() and getTargets() really mean to return a frozen collection. Sorry legacy issue again.
What if the key is negative?
suggestion ReentrantLock getLock() {
why this.writeLock().unlock() is not enough?
Assuming the change to ConcurrentHashMap.  JSONObject json = new JSONObject(mVars); return json.length() > 0 ? json.toString() : null;  There is also a race condition issue this fixes (we have not noticed yet). After passing the == 0 check, the map can still be emptied before we copy it. So then we would return an empty String instead of a null String.
I think you should add proper custom error message in this case.
extra line
Can make this into a singleton as we have with UNSET.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
What if fileName doesn't have any .?
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
remove the explicit initialization?
Use Scanner instead so that large files are not loaded into memory at once: CSVParser csvFileParser = CSVParser.parse(new File("filePath"), csvFileFormat); for (CSVRecord csvRecord : csvFileParser) { ... // qualify the csvRecord; output qualified row to new file and flush as needed. }
Can you explain this?
Can you replace the above 2 lines with for (Token token : tokenStream.getTokens()) { please?
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Is it possible to throw a more specific exception?
Use logging instead of this.
This should be done generically in BaseSingleFragmentActivity I guess, instead of needing to have the Fragments query the Activity's launching Intent extras. This would make the Fragments much more modular, as can be seen here.
@chaviw you can skip the check for null. If fragment is null then the instanceof check will also fail.
This should be at least a constant, and more probably an instance variable.
i'm not sure this should be exposed to the poor user
suggestion return Collections.unmodifiableMap(tags == null ? new HashMap<>() : tags)
Per our conversation, please check for the exact type.
Include the value or its type in the message?
I think JPA requires this to return a Long
Remove unnecessary this
1. This change is not related to AndroidX porting. So, it shouldn't have been here. 2. What if the view is null?
I think we won't need the second commit if we use [SHOW_IMPLICIT](<LINK_0> instead of SHOW_FORCED. Using this flag the soft keyboard auto-hides in case of activity change.
what if provider == null?
I think the older version checked empty string and this change removes that check on the username?
Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase(). I suggest creating a new tearDown() method for performing the rollback.
It's not wrong, but it would be very nice if you could use the logger messages embedded in the _Log_ interface? So here you would have:  log.redisStopping();  Which allows the internationalization team to translate it or redefine the logging level.
Does the sleep need to be 10 seconds? Is it because that's how often the ThreadDeathWatcher does its check?
should assertOpenBlock(); here, and have a test that fails without it
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
HashUtil.combineHashCodes
Revert this. referenceExpression is non-null AFAICS
return only if the provider is an AnalysisModule?
rename smth like getOrCreate?
instanceof check is enough, no need for null checks in this case
So there's a bit of a elegant hack to doing this: You can redirect to do the same as the original method, and then override this injection method in VillagerEntityMixin to do all this logic that otherwise you'd be doing. I do this with WorldMixin_Tracker and ServerWorldMixin_Tracker to do extra logic only on server worlds for injections that are in the subclass.
formatting
Why is this not just list.addAll, or better yet just pass them to the ctor?
I suggest adding getDiskDAO(), the same way you have getSnapshotsDAO()
It will be better to just add if the id is different than 'oldDisk'
If you're changing visibility here, I'd go all the way and make this private
This should also be synchronized
I'm wondering if we should take care of concurrent modification for this list. We should, maybe?
This is the same as downloadBatchMap.containsKey(completedDownloadBatch.downloadBatchId())
Should this be similar to other parts of the API where if connection == null get call get Connection and if not we use the instance?
Hmmm... This pretty tightly couples SQL string with the prepared statement in terms of parameters. I'd go with approach that schema creates the statement with given parameters (aggregateIdentifier, and sequenceNumber in this case). What do you think?
log.info or log.error?
Work is generic, so add <?> at least
Maybe wrap in an immutable map.
style: unnecessary blank line
not related to this PR but wondering if returning null or an Optional.empty() in case of corrupted data shouldn't be better.
You could static import getMimeDecoder to match the other file
you can use [Encoder.encodeToString()](<LINK_0> function
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
I believe the Sanitizer call is not needed here.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
The this. in getters are unnecessary too.
Should make a differentiation of the name and id.
Maybe we want to keep something similar to what id was before
This does not cause performance issues? <LINK_0>
Why this? In that case the generated bitmap will not have the alpha channel and we are going to sacrifice the transparency.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
This method should be private in visibility.
why not just repo?
Looks good, but it will work only once. If I run it twice, the second execution will fail, because a repository with this name (test-repo) already exists. There are two options: 1) generate a unique name on every test run, using RandomStringUtils, for example, 2) delete the repository after test execution in finally block. I would recommend to use both options.
To be safe, should check gerritTrigger.getJob() != null first.
@GaneshSPatil with this check, in cases where multiple ConfigRepo plugins are used none of the repos will be parsed if a single plugin is missing. Guess this was not intended.
pls use formatter
So this allows an env prop to enable a feature (in spite of whatever is found in the meta-inf files) but it does not allow for disabling a feature. Is this asymmetry intended? I find it quite confusing. I'd imagine it would be less confusing if env props (if present) would act as an override for both true and false values.
We prefer the default specified in the properties file.
nit: just a personal preference, but getting one less internal reference to a public function all makes the code usage check easier, like features.get(feature).
I think it's odd to use Optional with collections since you can return an empty collection instead of an empty Optional.
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
I'd suggest logging the exception here, might be useful for debugging. Probably include a message indicating the consequences (the punch table may not be updated until the first user transaction).
suggestion bannedColumns.add(COL_ID_ACTIONS);
why is it adding null?
Could change the return type on method to Collection
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Can make this into a singleton as we have with UNSET.
Shouldn't you pass something like the size of the list? checkQueue assumes you are going to add 1 item. I mean something like checkQueue(tasks.size())
neither of these need to be a concurrent data structure. if you just make them a regular list like a linkedlist, the variable will be local, not subject to comodification.
s.name().equals(state) would be better
Ran into a spark bug a few days ago where a shutdown hook firing during a "clean" shutdown causes problems. This method actually needs synchronized or else a shutdown hook fired from a SIGTERM won't wait for runCallbacks() to finish
This also needs to be synchronized
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
Could the attribute be null here?
reminder to change this to ConcurrentHashMap.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
Also, since RxJava is used here otherwise.. this code should follow RxJava patterns. Basically, instead of this codeblock, use something like  java metrics.filter(m -> publish.isPublished(m.getMetricId())).map(pendingMetrics:add)  Or make it even prettier with some more reactive handling.
Does it make sense to separate this out into two cases? 1) Argument metric is null -> throw IllegalArgumentException 2) getMetricFromName(metric.getName()) == null
could metric == null?
Now that looking for this method, let's change the log messages a bit Let's have instead these two log messages logger.info("Skipping file: {} ", source); <- remains unchanged logger.info("Not skipping file: {} ", source); <- just before the return false and let's drop the first looking into file...
throw new RuntimeException(ex); so that we will just wrap the original exception and it's message and stacktrace is visible.
Could use the Apache CommonsIO FilenameUtils.separatorsToSystem(String path) to be safe & cut down on verbosity. Also, that same utility has a lot of other useful methods that we could be leveraging throughout: A few: normalize(String filename) //normalize unneeded relative paths to simplify the path. ex: a/b/../b becomes a/b getExtension(String filename) //gets the extension wildcardMatch(String filename, String wildcardMatcher) //allows you to compare extensions or file names easily via wildcard
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
I think it should return Array here.
I think it should return Array here.
The implementation of this method will never return a null element. I think the annotation is an overweight of the method. IMHO it is better to update java doc to said the method returns not null value instead of adding a runtime check on every method call.
The rule added event must be fire after adding the rule into ruleengine
Shouldn't this mean new rules get the lowest position (highest priority)?
It would be better to also check that the function is unary.
I think it's better to replace this(type, data, new ArrayList<ColumnDef.TYPE>().
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
This kind of verbage is full of some dangerous assumptions about the nature of the language involved. If we were in a right-to-left language this would be really confusing to put together. Two options that might help: 1) Use the localization keys to do the construction, IE: Localization.get("cancelling.title", new String[] {titleText}) where cancelling.title=Cancelling: ${0} or something similar. Alternatively, you could only use the message view for the cancel message (although I'd put the "..." in the message itself for the same reason)
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
Will * <LINK_0> * <LINK_1> work as well?
Please add a space after (Class<E>).
please return String.class here
Please extract the variable for the class name.
I would suggest exposing the max length from the validator and using it here so we ensure they do not vary independently
You can use && instead of nested if
why can the operation name simply cange here? (see the setter). In addition I think a simple direct string might be the option easier to read?
extra space.
Would you mind improving this test to use executeFile() instead of executeString()?
I fail to see the difference to the previous test. Is there any?
singular
Should'nt the getter name be getClusteId if the field name is clusterId?
return queryId
IIRC the previous contract was to return an empty list and not null?, see method above
It seems like == would be sufficient and faster than .equals() here since we'd be testing identity of the component rather than equality?
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
Throw an unsupported operation exception here.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
new ArrayList<>(causes);
this field name is confusing since the parameter passed to the constructor is a File but this is a PackFileName, maybe better packFileName
You are using checksum checking to return a more accurate return value but not to improve performance. I hoped we are (also?) improving performance. What you are doing here is adding a check which only gets executed when super.isModified() has returned false. In the majority of the calls to this function the packfile will be unchanged, isModified will return false and we are adding a performance penality to this dominating use case. I hoped that we use the checksum check to improve the situation of false positives returned by isModified: the situation where isModified() returns true where it should return false. We saw that isModified() returns too often true because of the racy git situation. All the metadata tell the file is unchanged but if the lastReadTime and lastModificationTime are too close we do return true to force a reread of the content. And instead of that re-read and re-parse of all content I hoped we can just read the checksum to find out: "The packfile is indeed unchanged because the checksum is still the same. No need to read all content." I suggest to do something like: boolean modified = super.isModified(packFile); if (!modified) { return modified; } // super.isModified() return true. Check the checksum first before // really returning that the file is modified if (checksum != MISSING_CHECKSUM && getModificationReason().lastModifiedChanged && checksum.equals(readChecksum(packFile))) { return false; } return modified;
(optional) likewise
There is no need to call super explicitly. Same applies to other constructors.
@victornoel I'd keep IOException here
Is this going to be shown to the user? In that case, you may want to say 'Error in filter'.
recipeFileContentProvider param is missing in java doc. DevfileRecipeFormatException is not desribed in @throws section
There's a factory method FileContentProvider.cached() that's maybe slightly more readable
What a reason to have a public class without any public methods, with one package private method? Consider making class package private or method public.
How about make "filter" to a constant(KEY_FILTER) in NotificationListFragment, since it's an argument key and many place need to use it. typo it may cause bug in other place.
These Overrides are generally on separate lines (I don't think our styles are set up correctly but check the rest of this file)
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
This test checks topic creation. Why do you call replyTopicStubs?
Duplicates in createTopicStubs
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
Consider using == maybe?
do we need traceId to identify the object? i think the previous implementation was fine
@pynicolas Can't we just compare hash codes instead?
Maybe we should also deny requests while recovering after a shutdown
Shouldn't you be able to replace this with:  java return requestContext.getWebRequest()  If it's unset then there's a bug somewhere.
Please copy args here too
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
Using "/" directly is not portable. Java has a system method to get the directory/path separator character.
extract as constant?
Could this and the above constructor be changed to use the below contructor? e.g.:  public Region(){ this(null, 1, Integer.MAX_VALUE); }
I'd say "block end cannot be before block start"
+/- 1 confusion: suggestion this.startDistance = start;  that was the last one.
When you extend the abstract class that you use here, you shouldn't need to override these methods. Is there some special reason for doing that? I worry that any new method addition will be forgotten here and would rather that we just used the abstract class'es methods.
should not be this private?
They are still non-modifiered?
Did you take a look at this? <LINK_0>
Did you take a look at this? <LINK_0>
Did you take a look at this? <LINK_0>
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Maybe  message.toLowerCase(Locale.ENGLISH) .contains(Const.ACTION_RESULT_FAILURE.toLowerCase(Locale.ENGLISH))) {  instead:)?
missing @since 4.5 for new API method
This class should be immutable anyway so why not wrap the collection in the constructor once rather than every time it is returned to caller?
Could change the return type on method to Collection
@dmzaytsev let's extract this into a private final String variable.
@ekondrashev Too much indentation for lines 61-64, move them back four spaces.
@d-molotchko use String.format instead of '+'
Calling setProgress() with intermediate values shouldn't be necessary.
localize.
Please make it final.
You can make this method private
Wait, this is worse than the previous version. What happened to the assertEquals()?
the order of arguments in assert*() is counter-intuitive... it's (expected, actual). Technically the 'result' variables should always be second.
shouldn't the test throw the exception, it will be marked as a failure too, with complete stack?
Shouldn't receive a RuntimeException anymore?
what is the reason of this change ? I think you should revert to "this" instead of null
Add a constant for this
why not use the MessageLevel type?
I believe the security manager will be null in plain java also, therefore the system exit one will not be added. What I've seen (in slf4j) is a check for android by getting system property: java.vendor.url turning that into lowercase and checking whether it contains android...
why we need to check if peerLeaderReplicasByPartition contains partitionName? I feel it's unnecessary.
suggest changing to INFO level
Do you know in which case, it may throw exception?
return (id == null ? 0 : id.hashCode());
What about hashcode and equals, should they need to be regenerated with the new boolean
Feels like this could be less complicated. How about return ((getLabel() == null) ? 0 : getLabel().hashCode()); figuring that Favorites without labels are all equal and where they do have labels String's hashCode() implementation is just fine as-is?
Can we create a variant of getValue(Class<T> type, String key, T defaultValue) that will handle the NoSuchElementException instead of having to handle the exception in all the getXXX methods?
As previously discussed this is not thread safe. We cannot use Map.computeIfAbsent() or Map.putIfAbsent() introduced in JDK8 so I propose to add ConcurrentMap<K, C> concurrentMap field and corresponding param to the constructor. It would be illegal to provide both suppliers. The get() method could have two branches. One for regular map:  if (map.get(key) == null) { V newValue = supplier.get(key); if (newValue != null) map.put(key, newValue); }  And second branch for ConcurrentMap - the same as the current version but using putIfAbsent() instead of put(). Of course, we would have to modify SetMultimap and ListMultimap.
Why not just create the array yourself and use arrayCopy ? Way more efficient
please also add the GUID which is important.
Recommend to use ToStringBuilder
Recommend to use ToStringBuilder
What is the purpose of cleanup? Clearly mention in java doc.
Integer.parseInt
removeRoleCreateForLoggedInUser should be 'removeRoleCreatedForLoggedInUser' ?
Detail: I would rename this method to "attemptToChooseTableFromPrioritisedList" to make this sort of bug a little clearer.
method reference
Could use constant in this message
See also DefaultDockerClientConfig::dockerConfigPath field
As an aside, shouldn't this if clause have an else? I'd also add some logging, just like in updateConfig. Could help us see it wait to get this lock. Again, both are not related to this issue, I know.
Minor: have you considered introducing a simple copy method or perhaps implementing Cloneable? (But of course, the above code is a thing of beauty.)
What is the purpose of catching this exception. If this thread is interrupted it sounds more like an IllegalState somehow?
why public?
Should we add logging to indicate this condition?
The first three should be required.
I don't know if we should set a default key. We might want to require the user to generate something unique to their service.
probably best to use getIntInRange() here too to avoid negatives (I think I didn't know that the function existed when I first wrote this).
Instead of obtaining the Authentication, please use the SecurityContext so that the original SecurityContext is used (this ensures that if a custom SecurityContext was established it is used later on as well)
I believe this method should be private. If a user wishes to override this behavior they can supply a custom successHandler. Similar for onAuthenticationFailure.
Error message should indicate "Seventeen-argement init()" instead of "Fourteen-argument init()".
Missing types
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
It seems this variable is not used, can it be deleted?
Why are you creating an instance of the class to perform the conversion? Why not just use a static method. This seems like it's creating an unnecessary object.
Why degrading to raw type here?
The calculation and assignment for averageTemperature was calculated just before this line, is it getting calculated somewhere else now?
Cannot we simply use equals twice instead of relying on reflectionEquals? ;) Or if underlying Table does not have proper equals implemented it there instead of hacking it here?
Instead of reference equality, we should change the implementation to use the query field in equals and hashCode computations.
should atleast check o being non-null and instanceof IdentityExtractionFn .
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
why this change?
This mapping is not sufficient, since Appium server uses more levels, for example warn and error
Update the toString to include ledgerIdAssigned?
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
please fix it here as well (though generally speaking mentioning method name in log is redundant since log4j prints it anyway, but that is not relevant to your change)
MyTable does not support nested-projection-supported
Still this can be a static message as all messages are defined in the beginning of this file
Flip this check and throw
Lets not catch the exception and just let the original exception propagate unto main.
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Cosmetic: Could you please following the project's coding convention:  return "PUT".equalsIgnoreCase(request.getMethod()) && request.getContentType()!=null && request.getContentType().contains(MediaType.APPLICATION_JSON_VALUE) && request.getRequestURI().contains("/-/user/org.couchdb.user:");
Looks like this will incorrectly log the requestExpiryTimeout for control actions. Can you update the log to use the expiry timeout computed from the previous line?
please move calculateScope(ast) inside expression to speedup a little bit performance, scope calculation is not always required.
Why do we ignore annotations under ANNOTATION_DEF?
When is it not identifier? And does this cover things like new OuterClass.InnerClass() or new package.Class().
Should we break the for-loop early if the condition is not met?
eventProcrssor.close throws any exception? It just set a boolean value.
What happens when delta < 0
Is there a more specific exception that can be caught?
assertThat is fluent so you can chain assertions here, line by line
Redundant assertion
I prefer "Error while waiting for the task to be started.", the exception should inform if it's a timeout, etc.
This exception is not ignored, so can you fix the variable name?
you could use Exceptions.expectExecutionException();
Does not compile, but not really important.
Should maybe other countries be added here?
The this is surprising here, I'd remove it.
I am concerned that this changes the behavior of the future returned from createNewListener where a callback could see a null value. Instead, how about we create a constant CancellationException and then setException(constant)? Would that give us the same benefit?
return onCancelled()?
I think what the old code was trying to do was ensure this future gets removed from the list after a refresh if it was canceled. I think this might achieve the same result in a clearer way: boolean result = super.cancel(mayInterruptIfRunning); if (result) { refreshListeners.remove(this); } return result; In particular, if it was successfully canceled, then the set(null) call within afterRefresh is a no-op.
Why public?
Let's avoid raw types, please.
any reason for explicitly invoking super.toMap() ?
if the stdouts are irrelevant let's remove them
Bad variable name! Variable names should be clear enough. Rename it.
Please use append() call to append strings to a StringBuilder instead of resorting to concatenation, because that kind of defeats the purpose of using a StringBuilder
By composition, do we need this?
If an exception is expected, should we fail if the exception is not thrown?
expected
If it is a mock user, better to call it "mockUser" or so so that there is no assumptions it is something real
is it necessary to run the indexer to test simple cors header in the response?
use {apiToken} <LINK_1>
maybe ensure that this falls later than endTime, to not query the same interval multiple times? i.e. case where fLastQuery + fResolution <= endTime
I'd recommend using parentheses with elvis notations: fTime1Bound = (fEndTime != SWT.DEFAULT ? fEndTime : fBeginTime); so that we don't read the code as fTime1Bound = fEndtime But here you're actually assigning fEndtime, so maybe it's not that bad. Up to you.
lowestTimeAxisOffset is used above. Looks like a bug in findbugs.
Any reason to use an unmodifiable list as the list is already a newly created one?
should this use Objects.equals JIC null safety is required?
getActiveChannelCounter().dec()?
avoid using \n, I remember windows contributors having tests failing because of such usage.
This formatting looks off
Since I already have implemented allOf in CfUtils, it had better to use it:  return allOf(futures).thenApply(x -> futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()));
any special characters to block in webhook name?
you should probably check Item.Configure here
You may want to assign labels to this node; it's marked to only run jobs that are exclusively tied to itself or a label.
could be made static
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
what is wrong with this implementation is that it will fail only once, on the first class. and in order to catch the next one you should run JUnit again. Instead, would be much better to do:  java MatcherAssert.assertThat( Iterables.filter( classpath.allTypes(), new Predicate<Class<?>>() { // filter it out if it's one of the types we want to exclude } ), Matchers.everyItem( new CustomMatcher<Class<?>>("annotated type") { // .. } ) );
Error message should indicate "Seventeen-argement init()" instead of "Fourteen-argument init()".
Is javax.ws.rs.core.MediaType.APPLICATION_JSON available to use here?
There no whitespace around <=. Also - good to enclose blocks of that that if/else in {}.
Why does getData() not make a copy of the array but this method does?
Maybe have a of overload for StringType that takes a list and move the validation there? Seems to me that the StringType should be responsible for knowing valid parameters, not DataTypes.
!block.isIn(BlockTags.LOGS)
nit: maybe call them flattenDictionaryBlock and flattenRunLengthEncodedBlock?
arg checks?
Why Integer is excluded? LongOrNarrower should contain all integers, should it?
Tiny style thing, can we put brackets round boolean expressions like this e.g. boolean valid = (files != null);
This method might be the one in public.
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Get rid of this object ID stuff and define it here: <LINK_0>
It might be cleaner to accept a RefUpdate object here, instead of 3 parameters? Looks like all of the callers of this form are getting the values from a RefUpdate.
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
Actually the underlying objectExpr could have free variables.
should return the variables referenced in the right hand side of the effect declaration, e.g. the start of the path in each Effect in the effectSet.
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
This is a breaking change.
Can you add .protocols() explicitly here. There's a getProtocols() method in BaseSslContextFactory. Should probably be TLSv1.2. I think maybe a cleaner solution is to subclass that class and create a ClientSslContextFactory that holds this logic. You can initialize it in the constructor of this class and just call this method in the init block.
Should be optional => <code>@ChechForNull</code> and convert empty strings
Why not pass the paymentAccount and avoid the extra lookup and null check in paymentAccountManager.removePaymentAccount?
This is functionally identical, but in the new code, in the string ID case, we'll query the DB for an account, and then only use the string ID (which we already have). Is it worth adding a hasId() to AccountId and optimizing on the case where we only need the string ID?
assert get account null
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
I don't think you want to call the super implementation, as you are handling capability registration conditionally.
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
labelX should be x + ...
I am sorry, I induced you in error. Because this font was created from a font descriptor that was created from an original font without any modification, createFont() returns the original font, which happens to be the system font. So you are disposing the system font and the result is not pretty... :(
can you set this to warning level instead of error (Timber.w) - just trying to avoid too much non-fatal stuff in the error logs
nit: this is Optional.ofNullable(metricName.safeTags().get(ADMN.TAG_CURRENT_SUSPECTED_LEADER)).filter(x -> x.equals(String.valueOf(currentLeader)).isPresent(); though I'll leave this as personal preference
I don't think consumer can be null since you already guard against that prior to calling getConsumerMetricValue(). The suppliers/lambdas are bound to the consumer param.
or just "!tMetric.getTags().keySet().contains(unwantedTagName);"
This is standard procedure in our existing registries. :+1:
return an Optional<Integer> instead, then you can probably also get rid of JMXServer#getInstance
instead of calling an extra method for just one if statement (seems a little overkill), why don't you do one if statement to determine the validation status Status status = condition ? passed : failed and then one more line for setting the status if it needs to be set => 3 lines of code
Can call the method directly, instead of using reflection. return FieldValidator.getPopulatedEmptyStringErrorMessage(...);
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
I think the annotations should be on separate lines
you added synchronized to the method here, wanted?
If there is nothing to draw, what about just skipping the drawing and return 0?
init the string builder here with stime as arg
Use isZKLogAvailable() instead
use waitResponse()
Please extra this check in its own test method.
I get changing all the UNSAVED_ID constants to primitive, but why change getters to Long object when the field is still a primitive? It just necessitates a lot of boxing/unboxing
return queryId
Should'nt the getter name be getClusteId if the field name is clusterId?
Where does the 5 come from? I feel like we should just throw an exception here.
I am a bit confused that this check will be called on almost every line of code.
reuse getAcceptableTokens()
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
nit: jut call super.setForceCloseTimeoutMillis(...) this will also ensure we do the correct thing if we ever change the super method content and will allow to make forceCloseTimeMillis private
check positive?
This is redundant.
!droplets.isEmpty()?
Remove redundant assertions.
I'm not sure we need this. II would prefer to let the logic of collecting exceptions hidden in the visitor. Why not directly handling this case in the MethodInvocationVisitor then? You can perfectly give the symbol of the current methodTree as parameter of the MethodInvocationVisitor constructor, so you don't lose the info from where you are calling. At the end of the visit, you could then simply add thrown exception from the default super constructor, if super has not been called and it's really a constructor.
this won't work. in the immense majority of cases, the declaration of the parent method won't be in the same file, and so you won't have access to the modifier.
I would probably have a dedicated isConstructorWithNoParam method and have only one call to .add
this method can be static
Given these are distinct, it would more sense so return a Set instead of a List.
Can we inject this feature directly ?
Please use a [StringBuilder](<LINK_0> instead.
Use the new ClientLogger.logAndThrow API whenever you throw an exception.
As this is a private method, that you only invoke in your public method generateHmacSha256(), there is no need to catch exceptions here. Just handle it in the public method and use a throws declaration for the private method. That way you will also prevent unnecessary wrapping of exceptions.
here too, or just log the error
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
Should use the log, maybe a warning.
Are you sure that String.format is one of the effective ways to concatenate three strings together?
Please consider to add a log here (maybe warning) someting like : "connection " + connectionId + " has been removed from DB, no hosts were disconnected" Could be worth some scrubbing time
I think it should be here {0}
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
@gkatzioura can you please run benchmarks and compare latency and throughput of AtomicRateLimiter before and after your changes with various contention parameters?
I couldn't understand the need to get templates config and set it back again, is this required?
Pass the FeedbackQuestionAttributes inside the UI template class and use.  feedbackQuestion.getQuestionDetails().getQuestionSpecificEditFormHtml(qnNumber);  > ---- Polymorphism :D
In general, we want to do single responsibility design. So every module, class, and API (like this one) is only responsible for 1 thing. This makes the code clean, compact, and easy to understand. By having checkGroupBalance() fire within this method that seemingly only calculates a string given its name, this almost feels like a side effect and violates single responsibility design. I feel like we should fire this in the onAfterTextChanged() block for each of the EditTexts. It will lead to redundant calls, but this operation is cheap and code readability is more important.
Using the ternary operator here will result in nicer code: return phoneNumber != null ? PHONE_UTIL.format(phoneNumber, PhoneNumberFormat.E164) : null
are these setters used anywhere?
Please make the constructor private (see Invalid).
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
Make constants
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
Debug code, should be remove it.
Use StringBuilder instead. Also, you can use ToStringHelper in guava.
toString() formatting.
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
The problem should be somewhere else :-)
Can you add a hasUnfinishedInput method like the in the RowNumber commit? I think it made the code easier to read?
wouldn't it be enough that one of these is null?
What's the point of adding a copy here?
cant see tests for this
Why a TreeMap?
This line will always evaluate to false as we are comparing ExitCode with String?
probably want to have assertNotNull for taskExecution and jobExecution.
Is null the right thing to do here as the default or should we do something like throw new UnsuportedOperationException()?
I think 15, 11, and 4542278 should be named constants.
you removed stats.waitUntilBuilt(). Why?
Please use atomics instead:  java private static final AtomicReference<Schedulers> INSTANCE = new AtomicReference<Schedulers>(); private static Schedulers getInstance() { for (;;) { Schedulers current = INSTANCE.get(); if (current != null) { return current; } current = new Schedulers(); if (INSTANCE.compareAndSet(null, current)) { return current; } else { current.shutdown(); } } }
it'd be more robust to explicitly build the cache key, rather than embedding the toString of a List.
Could you put the CACHE_TYPE_ID first?
Couple points here: 1. This ByteBuffer needs to be larger to accommodate filterBytes. 2. Typically we put 0xff after a string like boundBytes in the cache key to delimit it from other parts of the key
run -> status
Is there a reason why this method throws InterruptedException?
The throws looks like overhead here.
Use Guava Streams.stream(myStream) instead of StreamSupport.stream(myStream.spliterator(), false)
Use Java 8 String.join instead of a third party library
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
Mike spotted you're changing the formatting of private keys from "Utils.HEX.encode(getPrivKey().toByteArray())" to "getPrivKey().toString(16)". What's the reason? On StackExchange I read .toString(16) is stripping leading zeros. I'd personally prefer to at least keep bytes intact.
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
Should it really return null here?
A couple of things to try: 1. Add some debug logging to tell you what the actual size of the element is here (i.e. just its offsetHeight/offsetWidth). The most common cause of this sort of behavior is elements trying to compute their size when they are either not visible or not attached to the DOM. 2. In cases where you need to wait for the browser to finish a layout pass before picking up layout properties, the idiomatic thing to do is to use Scheduler.get().scheduleDeferred(), which schedules work to happen on the next event loop (something like a timer at 0ms).
initializeYoutubePlayer needs to refactor to initializeYoutubePlayerFragment youTubePlayerFragment should be attached with the container once on onActivityCreated and remove from the container on container destroy e.g onDestroyView.
These three if conditions can be merged into 1 if condition.
Instead of converting the Path to a String, we should just return the Path object and have the callers use that instead. That way no one should have to deal with file separators and can use existing Path methods.
lowercase for package names.
Minor: simpler to use cloudDataNode.
Is not safer to use Locale.US instead of ENGLISH ?
Yes, makes sense, will update the patch.
This should be done on the client side.
There is indeed a behavioral change, the previous code was trying to lookup the files using the resource loader even if the string representation had no scheme, this one does not. The following change fixes the specific build failure. suggestion return uri.getScheme() == null || "file".equalsIgnoreCase(uri.getScheme());  I've verified this change makes for a successful build (with all extensions included, -Prelease):  [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 06:12 min (Wall Clock) [INFO] Finished at: 2020-05-06T15:36:28+02:00 [INFO] ------------------------------------------------------------------------
if only passing the message of the exception, please log the stacktrace here.
is getServerKey() invoked for every request? Is it possible to pre-compute the value and cache the URI? I think new URI uses toString and string parsing underneath which is CPU intensive.
Spring Security builders are not typically additive - instead they replace. This allows Spring Security to gracefully backoff when an application wants to manually configure a value. What that means here is that if the application has configured any algorithms, then the auto-fetch doesn't get run.
The Stream API is a bit too slow and hard on the garbage collector to be used in Spring Security - will you please change this to a for loop?
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
We have thread executors. It is important it must use these. Also this solution uses up a thread permanently which goes agaisnt some of the thread modelling. Look maybe to use schedule thread executor
throw new IllegalStateException("Current thread " + Thread.currentThread().getName() + " is different from the operator thread " + operatorThread.getName());
Could you include the invocation-future toString in the exception message?
If you have the guard above, you don't need this.
Simplify it as " if (m_isLeader || isForLeader)"?
May be you can check if there are any txncommit interests registered also here. Then we don't need to schedule the task unnecessarily, if DR is not enabled.
ms <= 0? Thread.sleep(0) may or may not be a scheduling yield. Its undefined in the platform docs.
should this be in a finally block to release in the case where an exception occurs?
should use Thread.currentThread().interrupt() when catching InterruptedException without rethrowing it (see item 69, p275-276 in Effective Java second edition.
Return from method Details at object that you found , and in place check for not null
Since we are changing this line, please make it private. We shouldn't have any public methods in check except for overrides and setters unless for some very weird reason/hack.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
[Checkstyle] INFO: '200' is a magic number.
Great test, use withHeader and Basic authorisation header in this stub, just like in Stash test
Use assertJ please
I know this is a bit strange but here I will not really change this. Historically this was used to know if we should use unsecured(coap) endpoint or secured(coaps) endpoint. So maybe the right name is "isCoaps" ? But anyway I read the code again and maybe this does not make so much sense now, so it would be more wise to not touch it for now.
I'm not going to block on this one as it sounds like you have talked about it with the team. My personal pref would be to detect the configuration as much as possible, currently, you need two properties, orgUrl and token, in those cases we could assume SSWS Similar with the private key, we could assume if orgUrl, privateKey, and scopes are set we could assume PrivateKey. This could also be done as a future optimization (and would be backward compatible)
May as well reduce the visibility of the method if it's only exposed for testing.
Can be replaced with streams java List<CharSequence> titles = titleList.stream() .filter(titleProp -> fieldApprover.approve(titleProp.getDataInfo())) .map(StructuredProperty::getValue) .collect(Collectors.toList());
I think streams can fit in here better java return source.stream() .filter(x -> fieldApprover.approve(x.getDataInfo())) .map(StructuredProperty::getValue) .collect(Collectors.toList());
Object returned by this method is not used e.g. method can return void
You could use the list collector directly.
ontology.listClasses().toList() always returns a list of size 0
Please change this to  java return new ArrayList<>(failures);
Possible candidate for bind() if that method is created.
Although bound() may be the "better-named" method to call here, it involves two operations (a set and a get). Since this method does not actually read/use the return value of bound(), maybe setContext() is still a better choice (more efficient anyway) ? If the return value of bound() was assigned to a local variable and compared to invocation.getInvocationContext() (to confirm the context was bound as expected to the ThreadLocal) it might be a different scenario. Maybe an additional method with a similar naming convention:  public static void bind(ActionContext actionContext) { ActionContext.setContext(actionContext); }  could be a compromise (named to indicate an attempt to bind, which does not provide a return value to confirm it was actually bound as expected) ?
Could this be protected as well?
Ah, interesting...delete would fail if a key with KEYPAIR_NAME did not exist?
Can't import be used here?
Should it really return null here?
This part of the patch should be in the VCS-specific commit.
quasiIdColumns and infoTypeNames  should be inlined
Related to field instantiation, test parentId = UNDEFINED_PARENT_ID
info might be too noisy. Let's make this debug.
Instead of new MakeBucketArgs().builder(), this should look like MakeBucketArgs.builder()
Might be better to call deleteBucketNotification here
can this return emptyMap? and just be another clause of the if below?
Should we have the monitor test here as well?
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
Please update the exception message to say KieModule too?
You need to get rid of the forward slashes here too
why 4?
ExecutorConfiguration(Optional.absent(), Optional.absent(), Optional.absent());
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
java docs please
Why should the caller have to provide the RestResponseChannel here? Given the RestRequest you would (or should) know what the RestResponseChannel is, wouldn't you? Why put the burden on the caller and allow for mistakes to be made?
when do you use error Vs trace Vs debug?
why do we need to close the connection here?
nit: String.format may allow this read better ? (opinion)
Add another assert for the case when the cache version is provided but the VEP version is not.
We should have a global Utility function (static method - e.g., of Settings.java class) to get the full path, given a project name. I see the same code at 4/5 places in the code. Search for "rootDir + F" and you'll find the references.
Since the event is really a resource rather than a model, it would make sense to me for this to return the event resource instead. You can get back to the model in other places if needed by calling .getModel() on the resource.
Is the deployProcess() method doing something? if not we should start getting rid of dead code.
This may chain to the next (more complete) constructor instead.
We can be more explicit. There are only two protocols so we can compare with XML. We are comparing enums so we can use equals here.
hostOs is to make sure that the host was active before?
since this happens before canDoAction, getVdsGroup() can be null
Why is this removed?
we need to reset this property in a @Before block
The editor can't be null
Do you care that this doesn't account for: <LINK_0> Is "Other Info" included in the docs?
The types could be removed.
This sounds suspiciously wrong.
Annotations on different line
I don't know which pr will contain the final setting for this, but the 2 FAILED statuses should be here also. cc @hreeve-cloudera
Hm, my understanding has been that the base implementation should look like: Java if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); }
Well, what happen then if user still use the deprecated method? we need to be backward compatible, right?
This should use the new checkPosLength(int) method as well.
It would be nice if the default value of a "1000" was in a constant, and maybe you want to set the default to zero in case you pass "false" as an argument for the detectColumnTypes property.
other methods like this put name first, then id. switch for consistency
this is confusing, it is called router but actually it is routerUrl.
@dmzaytsev let's inline this
nodeID could be null
What about data type here?
Another way to get the field node, a more readable one, is casting the parent node to KeyValueNode and ask for the key, like this:  KeyValueNode parent = (KeyValueNode) node.getParent(); Node field = parent.getKey();
Maybe we can improve the message further by checking if null == operation and show a different message in case it is. Something generic (like Unable to complete operation on "event-type-name" + reason. What do you think?
This toString() is used when printing the query plan. We probably don't want to include the partition values.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
BoundingBoxUtil checks to see if box is null, and if it is it just uses "pos". So you don't need the null check, and can replace this with  java public AxisAlignedBB getRenderBoundingBox() { return BoundingBoxUtil.makeFrom(getPos(), box); }  and it won't ever throw an NPE.
return ?
Pretty sure this is a Nonnull field. Just make it a Chest or Empty.
you can do return (!StringExtensions.IsNullOrBlank(brokerVersion) && AuthenticationConstants.Broker.BROKER_PROTOCOL_VERSION.equalsIgnoreCase(brokerVersion)); #Closed
Should log a warning here
Does Java have ? operator?
Can't this be further improved to just Arrays.asList(values)?
Maybe constant will be suitable there?
Maybe remove the package name as it is already in the import statements.
You should use a consistent method naming paradigm within your class. I think this is the only setter that says "set" on the start. Either have all of them say set, or none of them. This might also be a good opportunity to change "rya prefix" to "rya instance name" since the prefix is Accumulo specific.
size > 0 not enforced anywhere
nit: combine with assignment this.strategy = requireNonNull(strategy, "strategy is null");
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
IseException is a REST exception. We should throw something like a ConfigurationException here instead.
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Are we sure newValue is always non null?
Why not in combination with above do this: setValue(value, false);
I'd remove the empty lines before and after this one.
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
All of these createTable and deleteTable methods should throw UnsupportedOperation permanently; table creation/deletion is outside the scope of async-kiji.
Please get the current descriptor here. Once you have that, we need to create an array of modifications that need to occur. Those modifications need to be sent in a single RPC. There's a method in AbstractBigtableAdmin:  protected void modifyColumn(TableName tableName, String columnName, String modificationType, Modification... modifications)  Please use this method with an array of modifications. That will send a single RPC.
missing onDestroy suggestion @Override protected void onDestroy() { super.onDestroy(); mMapView.dispose(); }
Can this be null?
Can you clarify why this is necessary? Also, the rest of the Activity uses getFragmentManager() but this is using getSupportFragmentManager(). Any specific reason?
Nit: Have you considered using a ternary here? Avoiding intermediate variables is often a good thing.
nit, would 'bombarindUnits' be a more descriptive name here? Perhaps even consider inlining it to avoid the intermediate variable?
nit, deeply nested functional chain. Consider decomposing this a bit with helper methods. EG:  return battleState.getUnits(EnumSet.of(side)).stream() .anyMatch(unitIsActive(BattleState.side.OFFENSE));  I believe you can also get rid of the intermediate variable as well and just return the result directly as well.
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
directly return "" is better
Don't we need to do something slightly opposite? Check for data instance of List and always call onMessageBatch() since it is there on the MessageListener anyway.
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
I'd prefer overriding of setEntity() method to listening for events in this case.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
Could be inlined here by using test()
Can you please compare something else than integers (String will be ok)? Silly code change in assert method can break its logic but pass this test because both index and value are 2 :)
Not sure if it tests "immediately", this test passes without changes in this PR. Maybe you can avoid going to another thread and awaitTerminalEvent()?
reset compensation?
Probably better to name the option "o", to be consistent with other offline commands. For example, that is what [CreateTableCommand](<LINK_0> uses in 2.X
return setExecution ...
Better, but use logger.logAndThrow(new ...)
BASIC scheme is virtually non-existent in the wild, better use NTLM by default, wdyt?
You should have the ex as an inner throwable to that illegal argument exception, so consumers can understand why that parse failed.
config.intervalFunction isn't used anymore in RetryImpl. If set only IntervalFunction, I think code should be like following java config.intervalBiFunction = Optional.ofNullable(intervalBiFunction) .orElse(IntervalBiFunction.ofIntervalFunction(intervalFunction));
Don't repeat this code, make it call the new constructor passing null as an argument for clientInitService.
Same for other places suggestion _tableConfig = tableConfig;
You've added a bunch of methods in between the two overloaded versions of initializeAppResources. Please move the initializeAppResources definitions next to each other, it will make the code easier to read.
i'd like to talk about different strategies for putting this in the app
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
remove OnWiki
No assertion in this test
casting looks baaaad
Let's file a follow up issue to replace rpcService.getExecutor with a proper ioExecutor.
Please use assertThat instead of assertEquals
It is pretty weird that we throw the RestHandlerException here (along with a CompletionException with no CompletableFuture in sight); it has seemingly little to do with the REST layer. I'd suggest to change the JarRunHandler to explicitly handle exceptions thrown by applicationRunner.run by changing the thenApply into a handle.
Don't make this public, instead. use. TableDefinition.id().
If you add setHasSubtypes(true) then different types of wires won't stack
You could probably use the same URL as in getResultById here.
@marchof I'd prefer to name local variable invisibleAnnotations or even better runtimeInvisibleAnnotations instead of just list
this is rather arbitrary... why the limit? we are always going to be able to get up to the basenode given that the childNode is guaranteed to be a descendant
Instead of duplicating the logic here I would prefer to encapsulate it in the respective filters, i.e. * KotlinGeneratedFilter.isKotlinClass(IFilterContext cts) and * KotlinDefaultArgumentsFilter.isDefaultArgumentMethod(String name)
protected static ConfigurablePageObject getPageObject(Jenkins jenkins) { return jenkins.getVersion().isOlderThan(new VersionNumber("2")) ? new JenkinsConfig(jenkins) : new GlobalToolConfig(jenkins); } ConfigurablePageObject configPage = getPageObject(jenkins); boolean onConfigPage = jenkins.getCurrentUrl().equals(configPage.getConfigUrl());
You should do return true at the end of the method.
install button was not visible\* :dancer:
You can use StringUtils#defaultIfEmpty instead of the ternary expression.
The parent location of the ZONE should be the REGION instead of the provider?
I know there was a discussion around this... but.... return String.format( "Path to theme %1$s, User portal css: %2$s, Web admin css: %3$s", getPath(), getUserPortalStyleSheetName(), getWebadminStyleSheetName() ); Much more readable!
suggestion this.clazz = Objects.requireNonNull(clazz);
This changes the iterator, it should be specified in the jdoc. Also. this needs testing, like what is the state of the iterator after running this.
Setting variables to their default value on construction is a no-op semantically but still mean instructions executed which causes the construction of the object to take longer.
If the reader is reused, open will be called again but this reader will never read unless you reset the "read finished". I think this applies also to the other reader.
Do we have a use case for passing in multiple PathGenerator instances? Won't this logic simply take the storagePath from the last PathGenerator it iterates over? If we don't need multiple PathGenerator instances, we should simplify down to just one and pass that in, I think.
I am not sure that toPortableString() is preferred here to just toString(). IPath.toString() makes only separator '/' for all platforms and it is what we need. Docs say that if toPortableString() is used it has to be matched with fromPortableString() when converting back to Path. toPortableString() doubles all ':' after the one that belongs to the device part (for Windows). For example "c:\one\two:x" will be transformed into "c://one/two::x". If segments have no ':' symbols, then there is no difference from toString(). However if a segment has ':' symbol, fromPortableString() is necessary to restore the original path, even for Linux.
This log message is not always correct. What about missing toClass class?
Why do we need to do this sorting? We already have a mechanism to handle types that aren't yet defined. If what you need is that types are completely defined before starting to process services, then you can call the "fixUndefinedTypeUsages" method before starting to analyze the services. Note also that sorting types by their inheritance relationship doesn't guarantee that they will be completely defined. For example, Vm and Disk don't have an inheritance relatinship, so if Vm is processed before Disk and Vm references Disk, then there would be an undefined type when processing Vm.
Just remove the try/catch. An exception will fail the test.
if (variableSet == null) {
This will update every 4 ticks even when no items are passing! We don't want that. Just set tick to 4 in passesFilter and do tick-- only when tick > 0, do the redstone signal emit changes when tick gets to 0.
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
assertNull
assertNull
if a transaction is started in all the calls to syncDbRecords(), it makes sense to move the transaction to the method itself (and if its unneeded avoid creating the transaction), that way the callers doesn't have to repeat and remember to use it instead of adding it to each call.
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Should be jsonOne. This is assuming that the numeral part of the variable name is the expected number of fields in the serialized version. If that's not the case, then can you elaborate on the naming convention?
Can you please use the static import for these in all of the classes? It's convention to use static import for Junit methods because it reduces the verbosity and its more clear. <LINK_0>
Why do we have to reset it here? Is it because the standard, GZIP compression is not supported? How hard is it to simply support it?
mFormatType is not a member variable btw
storageType can be initialized inside the if command since it is only used for storage type V2
uncessary call to super. No need to visit further.
are there unary operators which don't write? e.g. -?
I am really doubting about this call to super: What about something like :  return new Foo() { //some stuff closing };  The new ClassTree will be checked twice, once with the override of visitNewClass (via the call to super) and once with the checkUsageOfCloseable of the expression of the return statement.
Just "Kafka".
Would be better to return "JDBC:" + dialectName.
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
i don't think redeclaring the type on the right side is needed.
Just "map".
This should be addLinks(map(...))
may be we should assert on get() > 0
Overdid - setUp("redis")
In the original bitrate_bps is a pointer. I don't know how it should be handled here (since it is currently not used)
There is only one Object.class, so it is clear when == is uesd
You should use the annotations field here too, not the wrapped reference.
suggestion private <A extends Annotation> Optional<A> getAnnotation(Class<A> annotationClass) {  Avoids the "suspicious call" warning on annotations.get.
Nice, included the row.
what if input.length is a multiple of 256? wont this add an extra 256 bytes?
Why not use java.util.Arrays.hashCode(char[])?
i would use a LinkedList here instead. i can't find anything saying ArrayLists sort faster and then you do not need to specify an initial size.
Perhaps this would be more readable with the last two cases switched
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
I think "$exists operator requires operand to be either true or false" a better error message.
I will be nice to have more meaningful error message. E.g. "Text condition must not be empty string." or smth else which explain the problem with comparing actual text and the empty string.
If we revert the operands in the condition, we can remove not null check: return SearchObjects.VDC_USER_OBJ_NAME.equals(getSearchObjectStr()) && origText.contains("vm");
we could use reduce instead of fold, like:  java return Stream.rangeClosed(1, n) .map(BigInteger::valueOf) .reduce(BigInteger::multiply);
Style-nit: This method can be static.
nit: should be && rather than &?
code format
suggestion if (eventData !=null) {
Integer.toString?
We can add a checkNotNull here.
Could we just check if its an instanceof?
Are we guaranteed to try the next shardStrategy next time? We could test it: something like: when(sweepNextBatch(any()).thenFail().thenReturn() followed by verifying that the arguments to both sweepNextBatch() calls are the same.
Why does this need to be made public?
passing null here was a lousy hack to avoid double logging of the warning (as it was in the constructor). I'd take this chance to initialize the analysisCache right upon definition and skip this logic in the getter altogether.
I don't think this is possible, if the cache is not defined it will be created with the default configuration.
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Use filePath.startsWith('/') instead of filePath.charAt(0) == '/'.
this error is confusing if you didn't set the property at all maybe?
If you just retain the below line, the API contract for createInstance can be regular:  UserDTO user = userEntity == null ? null : UserDTO.createInstance(userEntity);
You use actingUser as a parameter, while the other subclasses of BuddyMessageDTO use UserDTO.createInstanceIfNotNull(messageEntity.getUser()). Could you please make these uniform? (See BuddyConnectRequestMessageDTO.createInstance, BuddyConnectResponseMessageDTO.createInstance, BuddyDisconnectMessageDTO.createInstance.) If the user is deleted, does actingUser not become null? The message factory may construct these messages (by an inbox request) after the related user has been deleted.
The above orElseThrow already guarantees that toUser is not null
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
please fix it here as well (though generally speaking mentioning method name in log is redundant since log4j prints it anyway, but that is not relevant to your change)
size could be set to 2.
Semicolon is not needed here
Please, use spaces before and after +.
ps command does not recognize j a x flags on aix and solaris
API breakage errors. You should declare another method and mark for deprecation this one.
I would suggest calling the new getGDBCommandLineArray and making a string out of it. That will make things more future-proof. Something like: String cmdArray[] = getGDBCommandArray(); StringBuffer gdbCommandLine = new StringBuffer(); for (String cmd : cmdArray) { gdbCommandLine.append(cmd).append(' '); } return gdbCommandLine.deleteCharAt(gdbCommandLine.length()-1).toString();
No, not for addCommand. The caller runs this if push cert is enabled, but the client didn't send a push cert.
I feel the isNotEmpty() check is not needed here. The for loop will take care of this case.
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
Maybe some not-null check should be added here.
Maybe add assertFalse(realm.isFrozen());
Actually this is largely unnecessary for RecyclerView adapters since it has lifecycle callbacks for when it is attached/detached. The reason this (ugly) code is part of RealmBaseAdapter is because standard ListView adapters do not have these callbacks so we are forced to use weak change listeners. Also the change listeners on our collections actually have better granularity currently. I would remove this code completely and just use realmResults.addChangeListener(listener) instead.
you're already closing it in the tearDown
'coordinate' is a single word. Also calling toString from a constructor could lead to unexpected information being displayed, because the object might be partially constructed at that point. It would be preferable to show the negative coordinate instead.
The logic of this method should return true if any part of the range is covered by any part of the Block's revision range. Currently it only returns true if the entire range is covered by the Block's range
this should not close all blocks, only the one that was implicitly created by assertOpenBlock()
This is one of the reasons I didn't create a PR yet; not sure what the answer is yet but was going to explore it (possibly using ApplicationContextInitializer and creating ContainerMetadata earlier). Earlier (current master) we had a static method being called to publish the container started event from a context (static so SingleNodeApplication could also call it), but that definitely needs to change. We need a bean, with a managed lifecycle.
this is always true because you've set it to null in the line above. What was this intended to do / check for?
Wouldn't it be better to get backend's current context, store it in a "previousContext" variable, and do a backend.resetContext(previousContext) in the finally clause.
The generated body needs to be verified too
Can you explain the idea behind storing transformation here and not anywhere else (at the very beginning of repaint())? Is it worth to keep this information and to compare it within getDoubleBufferGraphics() rather using the up-to-date viewportModel Transformation. is it because of a non-atomar opration betwenn getImage() and getDoubleBufferGraphics() calls?
what happens if one passes SHA1 here?
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
Would you please co-locate this method with int executeUpdate?
Could the be inlined?
IntelliJ IDEA tolds me to remove this unnecessary boxing.
getters are doing this check so it looks odd to have it at both places if it's immutable it should be Collection.emptyList()
Shouldn't options be Immutable?
I think we can just call clear() on mItemsSelected, and by doing so we can also make it final.
don't we need to check for the actionbar being null?
I'm sorry if I missed this earlier but the null check of feedAdapter in the int overload of this method suggests a similar null check is necessary here. Also consider checking the return value of getItemPosition() in case it's not present in the adapter
Please use builder.xxx(...) instead of new ....
public final
optional: Ref ref?
Since this is not an exposed interface it is OK to change the signature. But, I'm curious to know that any other project or users depending on the revision number.
[2019-10-01T07:16:01.665Z] /home/catroid/jenkins_slave/workspace/Catroid_PR-3353/catroid/src/main/java/org/catrobat/catroid/ProjectManager.java:98: error: cannot find symbol [2019-10-01T07:16:01.665Z] return INSTANCE; [2019-10-01T07:16:01.665Z] ^ [2019-10-01T07:16:01.665Z] symbol: variable INSTANCE [2019-10-01T07:16:01.665Z] location: class ProjectManager
Please change to "instance"
Can't we assign value to localChannelId at the constructor directly?
please remove brackets
Shall just assert db != null.
doc
Do you think this method could be cleaned up a bit? The check for RANGE header is done here as well as in buildByteRange(). I think it would be more appropriate if the check for the RANGE header is done only here and buildByteRange() is only called if that passes.
why is this useful?
Work is generic, so add <?> at least
This could be considered a strange implementation of MVP; as your P is calling V.init(..) which then calls V.setup() which then calls the P to call the V to setup some UI elements. Why not have P call perform the complete setup rather than have the V call the P to call the V to complete setup? Or did I miss something?
we might want to only enable when we can get a viewer from the page. Right now this enables for the plugin search, even though getting the viewer from the plugin search ends up with no viewer due to a bug I described above about getting the getViewer() method. This is not a real concern if we move to a whitelist.
Change to commit();
isn't this condition always true?
For ignored exceptions I prefer the variable name ignore (so we know it is by design).
return a boolean esp. given the semantics of the update operation if there is an existing node of the same name that is not the provided node instance
On the previous code there was a check for null on n. Why don't we need it anymore?
this is no longer thread safe - as the node may have been removed. an update to a removed node should fail. (return false)
Doesn't Datanucleus advise against using id in hash?
And this change should be reverted as well.
also host/port instead of socket address
Why not just simply "command.setVM(vm)"?
1. you can share some code with mockGraphicsDevice 2. in terms of ordering, i'd seperate between entities preperations and mocks- makes reading it easier.
minor: This can be private method
Nit: VirtualConsole. prefix is unnecessary (here and elsewhere)
This doesn't check the length of the array of for the presence of the null element at the end. How do you prevent ArrayIndexOutOfBounds or NullPointer?
shouldn't we check for if (_closed) before we check for if(_next)?.
\+ unset MDC?
I think the test might be more robust if the bounds were read before indexing the trace explicitly.
Collection.equals() just compares their contents, they don't even need to be of the exact same type. You could compare the "actual" with a Collections.singleton(trace2) here.
same question
The conditional thing seems wrong. This should probably be just enabled(index !=null && index != Index.NON);
maybe we should give a more suitable message here since IndexOutOfBoundsException simply indicates that the index is out of range. So this message gives no extra information.
putIfAbsent or use synchronized block
What if dataGeneratorListMap.get(topic) returns null? (It could be null because of unsubscribing)
Add this qualifier: this.data
Those two should be equals (and even ==) rather than going through FQN
minor : no need for the else with the returns...
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
Why need to catch to simply rethrow?
This should not call log.error(t). It should return ExceptionUtil.getStrackTrace(t);
The start method repeats this code, wouldn't it be possible to call the log method from within the start method? (Like log("SCRUMBLEDORE LOGGING FILE");) <organisation
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
wait.. couldn't this be much easier by just making a request?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Extra ", "
Change to "Choose artifact types to exclude"
why not use chain calls here? .append(...).append(...).append(...)
The method actually determines if the given processorNode is a duplicate of any of the existing nodes. The action we take on duplicate is stopping the processors. Can you please update the doc?
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
shouldn't it interceptSrc and remainingPath follow same pattern to intercept as they both split from src path only? Whats the issue if I use same interceptSource method? Do we have some concerns? Could you explain me if I miss something here?
Should be given/calculated
could this be 8? the size of a char?
We can remove the fontSize/fontName and call the new methods instead (e.g. getFontSize(FontUtils.FontType.general)).
Please include an error message here. (Probably a "WTF?!" message if it should never happen.)
>0
Can use unmodifiableCollection()
we used to [call](<LINK_0> validationService.isProjectNameValid(...) Has the validation of project names changed?
please externalize this message
This should probably include the function name in the error message. Also, should the error be logged as well as the message?
This method is bad! It should mark the thread as interrupted again, before propagating the exception (but not this pull request's fault). We also have a RuntimeInterruptedException that Peter added: creating one of those will automatically set the the current thread as interrupted.
Why propagate and not simply Thread.currentThread().interrupt()
:astonished:
same opinion here :) (though break logic here seems correct)
This should be impossible now, no? e.g. 5 rules, all match, 5/5 == 1.0. I appreciate the gate, but I'm worried it may be masking potential insidious bugs. A score of >1 should be an error yeah?
Wouldn't it be saver to check for a clock frequency of 1GHz (comparison of long values) instead of checking the scale to 1.0 (comparison of double values)?
this method should be changed to private
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
revert this string
[JENKINS-40808](<LINK_0>
Would you mind improving this test to use executeFile() instead of executeString()?
This does not work like you think. setFireInfo sets the fire info for all forestry hives because all forestry hives have the same block instance. You have to implement the methodsgetFlammability, getFireSpreadSpeed and isFlammable in the class of the hive block.
Do we need to pass in the block anymore?
This calculation is not accurate, pos is a random position that can be anywhere in 4 different chunks, so there is no way to know the true origin chunk pos here. I think it would be better to leave chunkPos null in this case and make it and the getter @Nullable. In 1.13 we can remove this old constructor.
can't you use constants.empty() here as well?
Is that intentional to remove check for dhg.getDomainName() is null. We would have null string appended to dhost name.
Maybe more informative like so:  "Unable to get build host, skipping " + BUILD_HOST + " value..."  ?
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
The return type should be IEclipsePreferences so as not to expose an internal implementation in a public API. Curiously, I don't get a warning here, only in EMFCompareRCPPlugin. Don't know why, but must be changed anyway.
Just asking, should we put it in the map too?
synchronized block is not needed
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
even though it's not technically needed, I think it helps readability to add parentheses in cases like these: boolean startTimer = (getNbPendingBackgroundRequests() == 0);
Did you run your test? Does it work with Github account? I don't think it does, since you're creating one gist and deleting another one.
This assertion may fail if there is more than one public key on the repo you are testing on. I don't think that's a safe assumption. Better to use Matchers.hasItem() here I think.
what this line is for?
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Exception should be logged.
I don't think we want to propagate the exception in this thread. We just want to return the throwable. It wasn't this thread that had the error.
Can throw exception when created with no args constructor
You could make this protected if you want.
I don't see why you introduced mutability here? Local variables would have worked just as well. If you really want that, please at least make the setters package-private.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
why exit here ?
Please check also left content, in order to be sure that left model has not been modified.Please verify all other tests that present the same problem.
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
For Right to Left test, you also need to test left models (those who have been modified).Please verify all other tests that present the same problem.
Isn't there some standard way to dump a stack trace?
second or last? Do we even have guarantees GETPROP has only two children? This AST is atrocious :)
These two lines can be return values.getOrDefault( v, n );
:bomb: this is not a solution. hashCode() can be equal for two different objects. Do it using the four fields.
Log the conflicting classes found for easier tracking.
Please use braces
beginBlock should close the paragraph that was created in assertOpenBlock(), if there is one currently open. Note that it should not close *all* paragraph blocks, only the one that was implicitly created.
why not apply attributes in all cases?
turn this for loop into a function?
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
Sure thing. Though I still think there is an interesting case to be made for a "heavy-handed" view even in this case... my intuition is that it's odd that the view output's root and all strings originate in the middle of a SQL query. It smells like action-at-a-distance between layers. Oh well, a debate for another time if anyone is interested.
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
What do you think about public contains(T item) calls a private boolean contains(ListDataProvider<T> dataProvider, T item) instead of creating the dataProvider itself? This could increase the performance especially if you call containsinside a loop like in addItems, addItemsAfter or addItemsBefore.
You should call a setter here and let fXYDataProvider be private. And null-check the trace to avoid a null warning
Is there a reason not to import java.util.UUID? e.g a conflict with a similarly named class?
How about removing the whole cluster deleteRecursively("/CLUSTER_NAME")?
Will this bring lots of printout? Is this for debugging purpose?
This is the only place that add entry to the pool, is it the only way to fill the pool?
s/B/b/
Comparing with #2845 RSS feed will be with project name but not build status. This is not enough. We need to see project name (for rss with multiple projects, what #2845 broke), build name and build status like it was before.
Should we do an Assert.assertTrue on the return value of verify()?
Can you share why we need to unsubscribe all here?
The path contains"/" symbol. Would that be OK?
add "this" qualifier
Add this qualifier: this.logicalDevices
Is new allowed always. I think by default all commands are allowed. If so then we can remove it.
Can be simplified to AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());
return Status.BACKUP_FINISHED.equals(status) || Status.RESTORE_FINISHED.equals(status);
Update this method to also return true if status is HALF_OPEN?
Again, processible gets renamed to runnable, process to run, yet doProcess remains as it is. I think that's an easily avoidable inconsistency.
should we automatically call close() here to release everything? otherwise we'll need to require developers to explicitly call close() themselves on either the CTR or CTS
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
Throw an unsupported operation exception here.
we should return immutable list. You only expect caller to do read operations, right? #Closed
new ArrayList<>(causes);
Collections.emptyList()
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
defensive copy?
omit: Initialing...
should be info, not debug
FileNotFoundException is a subclass of IOException
the return type should be M
shouldn't takeWhile take care of this already?
should rather be  Java Objects.requireNonNull(throwableSupplier, "throwableSupplier is null");
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
This should probably be stack not block.
This won't make subclasses' updatePhysics cancelable. To do that, you have to create another empty method, call it at the end of updatePhysics, and make subclasses override that method instead of overriding updatePhysics.
SyncNetworkParametersBuilder contains those logic in labelAdded() & labelChanged() perhaps it could be reused ?
I'd suggest to merge Lior's patch which was mentioned in the previous in-chain patch to reduce the changes to this patch. OR Just rebase on top of his patch which clears this soon-to-be-removed code.
what guarantees getParameters().getNetworkId()) represents a real network ?
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
does not need to be public in non-public class
Seriously dude, don't reformat code for no reason.
Take the limit (50) as a parameter, this will be useful for later
It seems like passing the event id to the super class constructor and also making it a field might be a little confusing. Personally, I prefer the approach used in DataSourceAddedEvent where the id of the object is obtained in getNewValue via long id = (Long) super.getNewValue() and the "extra" field is not required. Thoughts?
As we know exactly how many events before the snapshot is written and how many after (all that left), I'd simply split into 3 operations (or 1, if we don't write the snapshot, or 2 if that's an edge case) and write events in bulk - to improve the performance. E.g. java if(!eventsBeforeSnapshot.isEmpty()) { write(eventsBeforeShapshot); } if(snapshot.isPresent()) { writeSnapshot(...); if(!eventsAfterSnapshot.isEmpty()) { write(eventsAfterSnapshot); } }  Together with that I'd remove this suspicious eventCount referency-bouncing there and back. It's a typical source of programming mistakes.
These two lines probably can be combined into one.
return tags;
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
I'd rename this variable to memberValue.
This should be stored in a field.
you can just return from inside these cases and avoid the local var / null initializer problem.
Maybe it would be better to move it to localization
We ususally don't put the logic in the entity class. Will be confusing that this setter has side effects: addAttribute("blah").setNillable(true).setLabelAttribute(true)
TEXT datatype would be more appropriate.
you could be more specific and check instance of Function0 maybe?
This almost looks like code I wrote!
this should go in .canExecute(ITmfTrace trace)
Check if credential and registryUrl are null before creating the Deserializer.
Please keep this.cell near the related fields (previousFamily & cell count) below
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Use Objects.equals() to handle nulls concisely.
Is there a reason why the equals method is not fully implemented? It's returning false for separate object instances that contain the same description and value, but it should return true. Your IDE should be able to generate it for you.
since this is the vdsbroker, you should be able to use java.util.Objects.equals()
while I think it makes sense to check this if we are calling it E from, E to, wouldn't the constructor be a better place to enforce this? In the 2D query patch, Genevieve suggested not enforcing it in the constructor and using min/max instead.
... this subset here may be empty, which will throw an exception. And it does actually. I tried the full branch on a kernel memory view with trace "bug446190". So either we allow empty sets, which would require min() and max() to be @Nullable, or if the subset is empty, we return a singleton empty condition. What do you think?
Are these cases all needed? Or what all of this just copied from categories?
Please remove this invocation. Right now, the test would pass even without your ExtensionBeanDeployer modification. If you remove the invocation, the test would fail without the modification. Otherwise looks good now.
I think getReceiver().getClass() should be enough. And we could consider type.toString() instead of type.getJavaClass()?
A more clear approach is to return an initialized reference and set it to a final field, i.e.:  this.annotatedMethods = wrapAnnotatedMethods(delegate.getMethods());  Also the sets should be immutable.
add this (also below)
You're supposed to call super.toContainer() to retain the necessary information such as the data version of this manipulator.
this
Why not use name as the key in CACHED_ENCRYPTION_KEYS?
suggestion return format("metadata[%s]", key);
Joiner.on(",").join(getAttributeKeySchema(keys, schema).getColumnNames())
A regular integer will do fine. The connection handler is single threaded.
do we need to unvoid..?
imho it should just be write(...)....
Order of expected and actual values is wrong.
I'd prefer the use of unicode escapes here instead of the actual characters
There should be an equality test for identical requests with different dependency levels
Could throw IllegalArgumentException instead.
Just curious, why does this class use logging but StaticAbstractConfiguration is being changed to System.err?
style nit: missing braces
use ShellIsAvailable
can you please also add method ok(TimePeriod waitForJobs). TimePeriod.LONG may not be enough for all cases
use ShellIsAvailable
I'm thinking the constructor should be public as well so that applications can use it in their own authentication providers.
I see no reason for the setters to be public.
looks like this could be ClientReliableTopicConfig (similar to the way done below for FlakeIdGeneratorConfig)
Should we return an explicit IStatus.ERROR instead? * It would avoid potential NPEs on the client side. * It would make it clear that this method should not have been called on an ResourceStrategy which explicity says it does not handle this method.
Possible ClassCastException, since there is no check that the loaded resource is a view.
why not call the new method with null as third parameter?
remove
Please keep this.cell near the related fields (previousFamily & cell count) below
the default should be made a constant somewhere instead of being defined in multiple places
maybe we need something more generic to handle forwarding of events?
Why propagate and not simply Thread.currentThread().interrupt()
Can we log chargeId/ChargeEventId ?
and doing the instanceof check here instead (trace instanceof TmfExperiment)?
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
Extract if conditions into named structures (variables or functions), like isThread, ... ? (Especially the last one is difficult to comprehend)
is this key unique enough if there are multiple fields with the same type, either in the same class or in class parents?
public isn't needed
Better use Class#isAssignableFrom(Class) which is like instanceof
float?
It is a little weird to have a side-effect like this. I wonder if you just do the validation during build time and throw an exception then...
Needs to be in a finally block. Otherwise any error will put us into noop mode forever.
!getCustomTopicNames().isEmpty()
Can we name this something other than it? Even i would be better to me than it.
This could just return a List, Collection or even just Iterable. We shouldn't return a concrete type like this.
no static
Why not return "!this.id2descriptors.removeAll(id).isEmpty();" like in LegacyPropertyContributorRegistry.java?
Ah no, I didn't think. It's of course possible because we're removing the same instance and equals therefore works...
Need to pass xmlEnvironment as second argument to XmlStringBuilder.
Just to be sure that there are no NPEs, consider switching getNamespace() and NAMESPACE
Could simply be xml.append(payloadElements).
Down below we throw BadRequestException. Here we throw IllegalArgumentException. Let's be consistent.
@bhhari - nanAllowed && Double.isNaN(value) filter is redundant; NaN has been checked already - ditto testFloat
avoid using this.
TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - started)?
How about using proper bitmasking to make the usage of the two last timestamp bytes more obvious?
Just to confirm, you know if TIME_MULTIPLIER is 2, not only will this speed up time by 2 (like you would expect), but also jump 44ish years into the future, since System.currentTimeMillis is posix time. I'm not sure if this actually matters or not for the way we're using this.
should the interface not the implementation suggestion public List<String> getTopics() {
It might borderline overkill, but I'm considering if we could avoid the copy here with logic like the following:  if (!groupSubscription.isEmpty()) return groupSubscription; else return subscription;  Basically relying on the the group subscription being a superset of the local subscription when it is defined.
redundant method("POST")
@ivandalbosco is it possible to refactor these 6 lines?
make it final. You don't want classes extending it to override this, as it's driving the analysis.
In addition to methods, we could also cover functions and anonymous functions. That's what we do for [JavaScript](<LINK_0>
flatMap that stuff
this does not handle the empty 'lists', it will throw an exception
Better to not use a list here: Queue<Type> next = new ArrayDeque<Type>();
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE);
suggestion EMPTY_VALUE);
should it be an error condition or log something if both the invoice number and the customer payment number are both blank?
This method is used in places other than interstitials. Let's remove this log. Callers already log something.
I know this name was chosen to match the DiscoveryClient, but I find it a little unfortunate. There is such a thing as the instance ID, which is a GUID like the application ID. This property is really the instance index, as it is named in the VCAP application properties.
Should add a method calculateSettlementDate on ResolvedCdsIndex that takes the valuation date and reference data. Like calculateSettlementDateFromValuation on ResolvedCapitalIndexedBond.
No full stop at end of error message
Stack overflow? :)
return dto
I like that this exists. Consider, though, that the endpoint is in XML, and it's used programmatically - probably the client will parse it to get individual fields - maybe it's better to show an error message in the same kind of format? Also maybe it's not the best to show external users our internal messages - how about logging the error message in our logs, and saying something like "Unexpected error occurred, email us if this persists"?
List<BankDto> bankModelList = isBank ? bankService.findBankList(null, null) : bankService.findUmpBankList(null, null)
I believe you should move this to inside the executor below. First, it will help deal with concurrency. Second, and more important, it will allow to fetch the latest model when the time expires, instead of being stuck using a potentially old model whenever the timer expires, since we use the model available at the creation of the timer, not at each run of it. Note that the old code used to "re-fetch" the model inside updateLoads(), so each time it was called.
Same here, making methods protected allows users to override them.
The exception in this line isn't being used. Use it or lose it i guess haha
You can push this directly to the frame so you don't have to pop it manually.
Make this a method already..... skip the casting....
Multiline this annotation, it's too long now.
This needs to be run-aware
Also keep the stacktrace in the log
This error message does not make sense. How about "Bugzilla issues do not support the IssueStatus CREATED".
for this and above we should be using the convertView to recycle the view, if it is null we inflate, if not we assume it is of the correct view type.
:bug: I think you meant new OrganizationFolderEmptyView(this), which getPrimaryView should be made to use.
I don't like this side-effect. Can you do it in a static method rather than ctor?
why is this noncompliant?
Is this a sufficient check that it's not a boolean? notBoolean and notChar are less meaningful than the other sanity checks (notDigit etc). Just thinking how much such sanity checks add.
I would use a less "negative" name, e.g. "eclipse.show.wrapByDefaultPreference".
For me it looks very strange that for initialising collections we use two different approaches within 5-line method :) (Guava and java.util.Collections) I would prefer to have homogenous approach (at least within the same method) doesn't really matter which one.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
While getClients should have no initialization.
This is not thread-safe, right? Someone can increment the _pendingCount after this block and have you tryExecuteLoop() again.
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Use same order as the field declarations.
Well, not necessarily on your own, but if us two don't understand why this works like it does, it means that this part of code needs fixing and probably git blame is your friend on the quest to reach the author :D
Use fileContent.trim().length() == 0
missing braces
This converter does not have any effect
Not sure if it matter much, but the 'better' way of getting an empty list is: return Collections.emptyList(); In this case however we need to specify the type: return Collections.<CertificateInfo>emptyList(); As the compiler cannot infer the proper return type.
To avoid code duplication, I'd suggest to follow pattern from the "getHostListByStatus" method: SearchParameters params = ... Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? params : params.withoutRefresh(), aQuery); Alternative solution (not sure if better, as it needs more code): private <T extends VdcQueryParametersBase> T setupParams(T params, boolean doRefresh) { return doRefresh ? params : params.withoutRefresh(); } // inside getDataCenterList method Frontend.getInstance().runQuery(VdcQueryType.Search, setupParams(new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), doRefresh), aQuery);
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
please use @Inject for getting the StoragePoolDao..
Why not call vds.getStoragePoolId()? Isn't that good enough?
This is a public API, so let's not change it here. If you need a ConfigEntry with synonyms for the test, create a static method in ConfigTest that will make it. That will keep the change confined to the test code.
Remove?
We use tab for indentation(with size of 4 blank spaces), can you configure your editor for that?
Would it make sense to add this method to ResourceManager interface ?
From <LINK_0> > Note that this implementation is not synchronized. Multiple threads should not access a PriorityQueue instance concurrently if any of the threads modifies the queue. Instead, use the thread-safe PriorityBlockingQueue class.
Is this going to be correct if there is a loop added in the transaction as well? I'm suspecting Direction.OUTGOING is the graphdb semantics which should include loops.
This looks overly complicated. Maybe  Set<String> set = new HashSet<>(); map.values().forEach((s) -> set.addAll(s)); return set;
This is standard procedure in our existing registries. :+1:
Use method reference
We usually want the config default specified in properties file, there is no need to provide a default in java code.
This should default to true to preserve the previous behaviour.
This should call config.useKafkaTimestamp()
s/executed/execute/g or maybe even simplify this to "An exception was thrown by a Executor"
Why even rethrow? It is not clear from either JIRA or the PR who was catching the IOException to begin with and where it was swallowed, but anyway I see no reason to rethrow this. Just delete and remove the throws clause.
nit: add e as a debugging parameter
Discovered in another PR we've been doing this backwards - it needs to be assertNotNull(msg, value) to work correctly.
Why do we return the parents name instead of the name we store a few lines above?
possible exception
I think you can avoid the ternary statement here by checking if (this.world == null) instead, and returning this.world.get() at the end.
If you use them as absolute height bounds - rename these methods to match. When I proposed these names I had in mind using them as actual defaults (I thoiught it's obvious).
This check seems excessive. It's caught by the else.
This variable is useless. Please just use return in your if/  branches.
null =
constant
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
Should fail gracefully (e.g. log error and return an empty string?).
Not covered.
the workspaceitem needs to be deleted
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
Why Exception instead of Throwable like we did for before()?
minor, is it method scope for Visible For Testing? If not please change it to private.
Unnecessary (and incompatible); revert.
Typically we use Map on the left hand side rather than HashMap
does it need to consider Windows?
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
You could also use path.endsWith("/")
Maybe "dequeue" is not the best choice of method name here. It suggests something about queues, but the actions taken use a repository, so I would think "load" or "find" would better describe what happens.
Missing an argument
No need for such harsh line wrapping, the style guide states it is up to 150 characters.
Do you know anything about the expense of these methods? Will these cause RPCs to namenode?
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
You could also use path.endsWith("/")
should rather be named currentContextClassloader
I believe this is breaking backward compatibility as it will register itself with different name then it was persisted before this change so I think we should make it via additional cunstructor so we won't break existing sessions
Can created URL class loaders be cached, it should not be necessary to create a new class loader each time loadDependencies() is called.
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
better to cast to string instead of using toString()
better to cast to string instead of using toString() .
This should have a static logger method with a code
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
Should we provide a variant that returns Optional?
please replace this line with: return StringUtils.defaultString(result); or the two lines with: return StringUtils.defaultString(getMessageOrNull(logType));
Symmetry (throw)?
you can use Collections.emptyMap() instead of creating new empty one yourself
Put in on the same line:  HiveType hiveType = hiveColumnHandle == null ? null : hiveColumnHandle.getHiveType(); return Optional.of(new RichColumnDescriptor(columnIO.getColumnDescriptor(), columnIO.getType().asPrimitiveType(), hiveType));
I don't think we use final for functions in our code base
Looks like a DriverException is being hidden behing a NullPointerException.
lets include e.getMessage() to be consistent with other plugins.
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
for a similar reason as the predictor, we should error if the input schema is null
i'm surprised this passes checkstyle
subject.getUserName()?
Do we use this outside the constructor?
This needs to return compressedMessage.clone(). We clone it so that code that calls getCompressedMessage() can't mutate the message text (as arrays are inherently mutable), and all of the Message classes should be immutable.
Is this the intended message?
Racy. Maybe just chuck a synchronized on.
How are splits handled? this should take split start and end into account?
How would you feel about having a DataSegmentInputSplit as per <LINK_0> ? Alternatively we could have a "HadoopDataSegment" which has a hadoopy loadSpec which is only a URI parsable by hadoop (in addition to the other things a DataSegment usually has. That could allow the peon/overlord to setup stuff correctly for hadoop. We have the data to get all the splits done completely, it is just a matter of ensuring the data gets propagated to Hadoop correctly.
those don't need to be public.
return if already destroyed
The parameter is not used for this method so can be removed
correct the type. it's not service
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
@xpdavid is this the right thing to do?
please replase MojoExecutionException for a new generic DeploymentExecutionException
The path can be moved to constants since it is used in FeatureInstaller.java
Cache file name string
Missing @Override
These will all break if A or B is null. Recommend using the autogenerated intellij equals + hashcode unless you have a good reason not to
If you find your analysis panel starts going a bit loopy (IIRC you said it does), you might want to check your hashCode implementations - you should try to use result = ~~result type construct.. I can dig out the original email if you like?
Not enough to test that ToString returns a non null value, we should check the actual value as well. We need similar test for testSmsMessage_EmptyBuilder() testGetBuilder() and testGetBuilder()_EmptyMessage()
Suppose that AcknowledgeBuilder is less code than Acknowledge.AcknowledgeBuilder.
I would create simple test that uses 1 or 2 bytes to make it more expressive
Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.
you don't need a try-catch here. You can simply use @Test(expected=NullPointerException.class)
Please add a cast to Object[] here.
I think this log message makes more sense in the ctor than here. Since users are immutable you'd want this logged once when a malformed user is created, not every time you access its key.
Why not use name as the key in CACHED_ENCRYPTION_KEYS?
This shouldn't be made optional, and if there are usages that are implemented wrongly (that come under this PR) they should be fixed as well.
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
I don't think this check is relevant
Isn't this a bit dangerous? If we're in a network without dns "Unknown" will be all over the place?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
Since we're returning a new set anyway, why do we care whether it's immutable?
This should be done with field declaration example:  java private Set<String> users = new HashSet<>()
This is a breaking change.
Our standard convention is to prefix with this for instance members - return this.context
Minor: move init to the beginning after the constructor
I think we should separate concerns more clearly here: - FormValidation ensures that the value in fields make sense and if not display a meaningful error message. - DatadogClient checks connectivity to the provided endpoint for example this function should only check that the string looks like a valid url, not that the url is a datadog one, nor that it is reachable.
any special characters to block in webhook name?
you should probably check Item.Configure here
ArrayList should be constructed with fixed capacity.
Add a empty line before this.
does this need to be calculated on the fly each time or can we save the iterable?
final?
Could we log it?
Need to use UUIDs instead, for performance. Nit: can be final.
nit: Only plan parameter is used. I don't think you need to check anything but plan with the requireNonNull.
ImmutableMap.copyOf()
Wow, that's pretty useless until you squash this commit with "Implement CostCalculators"
would this work? (also removing the import) suggestion .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice);
This needs some polishing to avoid > 2015-05-07 11:20:11,855 WARN SimpleAsyncTaskExecutor-1 [org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer] - <Consumer raised exception, processing can restart if the connection factory supports it> > java.lang.IllegalArgumentException: Connection must not be null
java.lang only required here
can be inlined into a single return line
why null?
no need to check for testName != null. I think it can't be null and if it is, the getTestResources(testName) will throw a NPE when accessing the map.
you need call addColorSettingsListener on the new instance.
String.valueOf()?
String.valueOf()?
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
scheduleTimes --> scheduleTime
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
That's not very clear: if doResolve does return null, it most likely means that the CodeMining doesn't require resolution, so isResolved should be true. The implementation seems erroneous here. This may be caused by resolveFuture == null which can mean 2 different things: either the future wasn't requested yet, or the future was requested and null was returned (ie no resolution required). I believe you need some more details or another state variable in the class to distinguish both cases.
How do we deal with readonly ledger handle?
Non-standard equals?
Why U don't want to consider id in equals and hashCode ?
Same as for the hashCode - what if the element is null...
Seems the output name cache should be reset here, not below.
Becarefull with those assert. They will not fail if jvm is not launched with specific argument (-ea). You may use a Preconditions.checkState() instead.
![MAJOR](<LINK_0> 'Severity: MAJOR') Change this condition so that it does not always evaluate to "true" [![rule](<LINK_1>](<LINK_2>
I believe that this is the same as Objects.hash(readName, pairStatus);
Would it make sense to rewrite equals to avoid #toString since this is a rather expensive equality check. That would allow for a more efficient #hashCode, too
Yeah this should be return set.get();
Should be "!= 0" instead of "> 0"
checkState(mPut != null) ?
nit: you can do mLGNames = Sets.newHashSet();
please update - should we keep this or format to remove ====
We should log this error by using our Log.e method.
shouldn't we create Note object first and then new NoteInfo(note)? otherwise it would be missing name and config
We do not unpack it for all the inequality operators. Because of that i assume that the assumption is that the higher bits are always zero (or the same). Therefore i don't think the downcast to byte is needed here.
nit: I see the point here to use a delegation call to xxHash64. But given it's a simple function, maybe just inline it as return XxHash64.hash(value). Thoughts? @haozhun
What's the behavior when the input is not between the min/max values?
You may use org.bonitasoft.studio.model.process.builders.ConnectorBuilder. You can then write a one-liner for your test: assertTrue(onFinishFilter.select(viewer, null, aConnector().onEvent(ConnectorEvent.ON_FINISH.name()).build()));
You should call this right before the line you expect to throw the exception, and have no code after that line.
It seems strange to test for null in this test, since it is testing the happy path. Can you create a FilterStub?
why not an empty map?
Since a SAML Attribute map can have multiple values, the type here should be Map<String, List<Object>>.
throw throw method should be named as "createUnsupportedOperationException"
Argument name
Argument name
I'm guessing you don't want the name to be null either. Should it be specified or is it assumed obvious?
Redundant casting.
this view is using the same context. what about if you use the context from itemView.getContext() instead of passing a new parameter?
This textView can be named accountText
Collectors.toList()?
can / should this be Optional<Class<E>>?
Method reference for success here, e.g. map(Validation::success) I tried this and did not need the types.  return isSuccess() ? f.f(success()).map(Validation::success) : List.list(Validation.fail(e.left().value()));
I have some concerns about this. 1. Wouldn't this make crashlytics run in debug mode as well? The old Crashlytics didn't "ignore" things in debug, but we definitely don't want them reported. That was why it was in the if...else in LoggerStarter. 2. The reason for crash logging to be initialized in LoggerStarter is b/c if the content provider is accessed through a Context which is not ours (like if we export our data), then our Application does not get launched so crashes would not get reported to us. LoggerStarter is initialized in the content provider, which circumvents this limitation. 3. Does this create a Twitter singleton that we keep around for the lifetime of our app? If so, that seems like a waste of memory since we only use it for the login stuff and even then only for vendors who actually use twitter.
See also DefaultDockerClientConfig::dockerConfigPath field
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
What is the reasoning for this logic? Specifically the desiredID < 5.
see above wrt logging
I'd prefer we not import the icu.util.Timezone and make java.util.TimeZone the default in this file as it's returning this thing. The icu.util.Timezone is an internal impl detail. Alternatively replace all uses of TimeZone with the new icu version throughout the system (if we really want to replace it). Mixing the two seems bad
Please check the result here and break if false , since all values are with AND , there is no point to continue if we got false
I still don't get this method, what is the disk isn't plugged to any VM at the moment? what if we have more then 1 vm that the disk is plugged to and they are DOWN? it won't be executed.. don't we need to sync between the qcow header and the metadata then? it's not clear
if we have one vm which is down, why do we need to perform it?
Should use the log, maybe a warning.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
here too, or just log the error
Possible ClassCastException, since there is no check that the loaded resource is a view.
why not call the new method with null as third parameter?
reportservice
This was renamed to PARTITIONED
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
This should no longer be needed. Rewindable split source must be selected based on the REWINDABLE_GROUPED_SCHEDULING passed from the engine.
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
wondering how thoroughly we've tested this; does the 0.9 producer do anything smarter when given a non-existent topic? Or are we really stuck guessing at timeouts?
You should output the session id in the message to aid debugging. Also, I would use this form log.error("An error occurred while removing session", e);
unnecessary change
why a static method here ? for constancy I would make it not static.
RelationalSymbolicValue.class::cast ?
Why not: java if (val instanceof Double && Math.abs((Double) val) <= 1.0e-131) { return ZERO; } return val;
yeah
in some cases lhs/rhs could be null, pls do the null checks appropriately
Maybe use the getStorageId method here?
why using equals for VolumeFormat and '==' for DiskStorageType ?
There needs to be another log message after the image has been fetched confirming that it was fetched and cached. If I saw only the message above in a log, it would look like an error to me because it's "Trying..." but never succeeds? Or you could just move the log message to after the image fetch and change the message to be in the past tense. e.g. ""Image %s not found in the image cache. Image was fetch from the provider and cached in jclouds." Also, should this be a debug statement? It's not exactly unexpected behaviour. I'm not sure. I could go either way.
Why this change?
put each argument in separate line
It's easier to read if expected values are provided.
Is this supposed to be <code>return "Bump"</code>?
use keyword "this" in these methods before member names.
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
Consider the CollectionUtils.isEmpty(this.applicationDefinitions) instead
@xpdavid is this the right thing to do?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
mfsu instead of mfe?
this usage does not seem very fine
protected constructor was added with purpose not as a mistake.
Change the commit title to say "Fix potential overflow in Bing tile functions". Also, for better readability, add parenthesis around (long) tileCount.
Should this throw IllegalStateException? Seems like bug case.
you removed stats.waitUntilBuilt(). Why?
Why is this throwing Exception? Should usually not throw anything.
The default implementation of close() is to wait forever. What's the reasoning for using Duration.ZERO here?
Should this be shutdownNow as any pending reactivate commands should be terminated?
test will success in old versions
why is this surrounded with parenthesis ?
Use isZKLogAvailable() instead
I don't think we need this assumeTrue. Docker API has had build params since 1.18 <LINK_0>
nit: typo in expexted
Maybe try using message.status() instead? I'm running docker 1.7.1 and that's where it was for me.
As noted above, just put the init code in init() unless there is a reason not to.
Consider instantiating the InitialContext only once, for example in the PostConstruct.
super.init() method never throw an exception.
missing check that vm exists.. (getVm() != null)
using command line user can provide a wrong id (say, by mistake), so its better to check for getVdsGroup() == null here as well
Do you mind to write it to utilize the ValidationResult API?
Should the shadow not store this value and the one above in variables and provide setters for them, rather than just always returning false? The same goes for all values actually... Would be better to provide setters for them.
other single line methods don't have new lines, no reason to start doing that now :)
Can be done in 1 line.
I don't see anyone calling this explicitly. Should the removal of Paths.build(Paths.CONTAINERS, id) happen as the ephemeral node removal?
will it actually trigger the watchers if you set the same value as it had before?
What if this path actually exists on the user's workstation?
So what's buggy about the CopyOnWriteArraySet?
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
may be only rule name here would be more clear ? i.e. \w+ only? possibly case insensitive too.
Isn't this superflous? Why not let Files.createDirectory directlry throw the excption?
Any reason not to do the split and trim at the same time, which would avoid the extra var? i.e.: params.getString(PARAM_IDS).split(",").trim()
We need the inode information as well to build the folder object, no?
you could be more specific and check instance of Function0 maybe?
Assert that verification.bank_account.href matches bankAccount.href
isn't this the same as if I would have imported the method from Either? @danieldietrich, what's the take on that, is this meant as a shortcut for only importing the API?
Unnecessary parentheses (and an extra line break).
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
Can you put here "storagePoolId" instead of "spUUID".
don't you need to increment the index to avoid infinite looping? how do you avoid having seriesName, and seriesName(0)?
Note this will eagerly materialize the parameter Instant.now().atZone(UTC).format(TIMESTAMP_FORMAT) even suffix is presented. I don't think it's a major performance issue since suffix will only be presented in two places. @haozhun any thoughts how should we handle this?
Use UserCoreConstants.DOMAIN_SEPARATOR
You added this to the ctor's signature, but forgot to save it in a data member.
It seems cleaner to me to just store the string here and keep this a simple-stupid POJO, and have the optional "logic" where it's used.
can be replaced with: return dbImage.getId().equals(vdsmImage.getId()) ? VolType.LEAF == vdsmImage.getVolType() : true; But it is not a must, just a matter of style.
spacing here looks off
use as loopvar?
We shouldn't have this case here. The old code was just plain wrong to be using a StringType for the password. Leave the original else block when that first get returns false.
rename this to hostSpecification and then you can use host as the foreach var.
rename to hostCandidate
I know this was just copied from the original endpoint but bundle can be null here (although very unlikely)
Format
We should not force all of the refreshes
I think we should keep this synchronized.
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
Same here, would be better to leave it on the previous line
I think there's a method in Runnables that returns a do nothing runnable
Have you intentionally omitted index check?
I would suggest to just check the endianess and then decode via the array directly to reduce GC
Add a private final stripeMask field that is initialized to stripes - 1. This will eliminate an arithmetic operation from this hot path.
Okay, but already done implicit.
shouldn't it logged not printed?
Why not eagerly create the cache here?
missing curly brackets.
Should make a differentiation of the name and id.
Minor suggestion/subjective: could get rid of the nesting here using something like: java if (displayName != null) { return displayName; } if (name == null) { return fileName; } if (version == null) { return name; } return name + ":" + version;
Remember to call  configureConsumer(answer);  also as that is needed, see other components.
You need also to do configureConsumer(consumer)
You meant a consumer here I guess?
toList() should return only JSON object. I understand that getObject(i) can return CBL Array() or CBL Dictionary() ?
This should use LinkedHashSet, which would reduce the LOC since the !contains() check can be avoided.
pipeline this
I think you mean (d<=0)
I think you will find that there are 1000000L nanoseconds in a millisecond and not 1000L as you suspect
I think the granularity should be 1 seconds instead of 5 seconds here.
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
Lately I've been generating toString() with the "String concat (+) and super.toString() template in AndroidStudio - that way we'll get the Id field logged as well which can be pretty important for debugging
Looks like this toString() got generated before the tags field was added :P
Again, don't clone a new event. In the new code change, the "else" will only be executed in very very small time windows. You have proved that when the sender is shutdown, the eventProcessor will be kept. So enqueue will not go to the "else". We will never worry about the tmpDroppedEvents become too big.
Constantes? Suggestion: EVENT_ID ou AN_EVENT_ID
Mappers can be stored in static final variables instead of rebuilding these each time.
lambda
I think it would be more useful to return the SWTBotShell of the dialog that is opened by this method.
sliders
The number should be canonicalized before retrieving the contact, using Utils.canonicalizeNumber(number, username)
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
return id list
I am not seeing this assigned anywhere. Is this needed?
How about using forEach here too?
This has a ranking of 30 in the plugin.xml, we should use the same in our tests.
Shouldn't we avoid to have U+0000 or any other chars not valid for table name in the name? I think we should update TestHelper.getRandomString(int) to exclude U+0000 at least.
Since this is recoverable, can it just be info?
Doesn't look like you need a contains check here, "mike".split("\\.") ==> [mike]
Might consider using a [SimpleConfig](<LINK_0> here. Won't make a huge difference with the class as-is, but will make it easier to make changes in the future if we ever want to expand on the configurability of this predicate.
Typo. And I think we mainly use the arg name in this situation, i.e. checkNotNull(mbean, "mbean")?
Default to off until config is back
Static import
Static import
Static import
Is synchronized needed here? workflowDefinitions is already a synchronizedMap.
workflow.getEntryPath() here, tool.getEntryPath() up there seems simpler.
code style
This no longer needs to be public, that was only for MergeOp.
Can you return 'this' like the other setters?
The configProvider is still required, isn't it? If so, we should still have Objects.requireNonNull(...) as a NotNull check.
to remove, just use new ArrayList<>() in the constructor, two lines below
addAll
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
new Double is redundant here
not public
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
I know this is pre-existing, but getQuery has a bunch of other usages that refers to the query text. I would rename one or the other.
HQL/JP-QL
What does connector mean in this context? It's unclear.
inline permissions and then remove redundant this
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
How about Collections.emptySet() ?
use same type for instanceof and force casting
![MINOR](<LINK_1> Make "getKeySize" a "static" method. [![rule](<LINK_2>](<LINK_0>
Please use SecurityUtils.getMessageDigest
We should add a log message to indicate that we're going to block while waiting for a service to be available.
coding style:  try { ... } catch (ClassNotFoundException e) { // Don't mind... Attempt next class loader |
typo: "is has"
Collections.singletonList
Collections.singletonList
return Arrays.asList(....)
Again, this is too much specific logic that this component does not need to know about. It should only depend on Prefs.showEditMenuOptionIndicator().
This is too much specific logic that is spilling over into a very general function. The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does.
feedDisplay is a strange name. I had to look at the xml file to find out what it actually is. How do you feel about feedDisplayContainer? I know it was like that before and the guidelines we have come up with say that it is not necessary. How do you feel about this? Should we update the guidelines?
We probably need something based on version rather than on whether the default token cache is being used. If we want to test versions of ADAL that do not contain common cache... for example.
Mann knnte das auch ohne "username" machen:  java if(...) return authentication.getName(); return "...";
Instead of obtaining the Authentication, please use the SecurityContext so that the original SecurityContext is used (this ensures that if a custom SecurityContext was established it is used later on as well)
same here. we don't need to set explicitly for blob not found cases.
shouldn't this be "ServerErrorCode.Blob_Expired"
it seems the Exception is unnecessary, we can remove it.
I think we can revert this change already since AnonymousQueue is now Base64 by default.
Seems like this should be more defensive, i.e. check for the type before casting.
We may want to use [BlockingQueue.drainTo](<LINK_0> in this call
Why is the call to trim() necessary? If it's necessary, I would move it to the client.
May I suggest a pre-check for getParameterCount() == paramTypes.length in order to avoid possible allocations coming from getParameterTypes()?
why not simply new Mirror().on(obj).invoke(method).withArgs(args)?
This change may cause the lock not to be released in some cases. With this change, in case of a failure VdsManager is responsible for releasing the lock. The VdsManager releases the lock only in case it catches an immediate exception. In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked.
as is in 718
That's going to weird in a log, especially if the user suppresses stack traces. If you're going to change it, this would be better:  java super("Exception during pool initialization: " + t.getMessage(), t);
Is it a good idea to give access to the view directly to the page? Wouldn't it be better to have an inner class for the sheet page to access the contents?
rename to className
do we need any content in this constructor at all?
will this remain package private once we have the next PR as well? Or will it be a private one?
would be nice to save index.getColumn(column) so we don't have to do the lookup twice if it's non-null.
I guess the condition can now be unified like so: if (present && getColumnIndex(column) == -1) We could also improve readability a bit here, up to your consideration: boolean columnAttached = getColumnIndex(column) != -1; if (!columnAttached && present) { ... } else if (columnAttached && !present) { ... } Also, please verify this patch in WebAdmin "Events" main tab, clicking on "Basic" vs. "Advanced" radio buttons (columns should not jump but retain their logical position).
in case closing one grouper throws ex, we would still want to close the remaining ?
Don't know if FixedChannelPool#close is idempotent or not, but it would be better if we could make closed an AtomicBoolean and call super.close() only if it wasn't called before, via closed.compareAndSet(false, true)?
Build failed: Need to throw IOException or catch it  public void close(){ try { if (input != null) input.close() } catch (IOException e) { // ignored } }
Mid return may worsen readability
This is the same as downloadBatchMap.containsKey(completedDownloadBatch.downloadBatchId())
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
What we are waiting here on?
But we have already clicked the button in the command before, haven't it?
Are we really need to wait 2 seconds if we are waiting on web element anyway later?
remove this method. you dont reuse the variables anyway.
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
Hm, this differs from my suggested implementation a little bit (<LINK_0> forEach: "Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception." So, your one stopped if a job's run method throws a runtime excpetion (silently). This could be hard to detect. Mine logs a warning, and continue with the next job. Do you want to use lambdas and stream whenever possible or why have modified it this way?
qry -> query
Store magic number in private static final?
qry -> query
Do update all the places where you can now just use typicalBundle, instead of getting it again.
Why is this line needed here but not in all the other tests touched in this PR?
Why not use the verifyUnaccessibleForStudentsOfOtherCourses in the parent class?
Is it okay to remove this?
casting looks baaaad
remove OnWiki
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
ImmutableMap.copyOf()
Maybe the simpler:  return Objects.hash(podSpec, podMeta);  or maybe not, because that involves an instantiation of an array under the hood. On the other hand, it leaves less room for error. :smile:
Where did 31 come from? Why not use *=?
Alternatively you can do: Arrays.hashCode(new Object[]{command, spec});
I think we should return a dto here and do the marshalling of the response in the IL as we do with other responses.
![MAJOR](<LINK_0> Remove the unused method parameter(s) "request". [![rule](<LINK_1>](<LINK_2>
Setting the clock configuration is not about replacing keys.
Is it really necessary to set prototype scope for EVERY Provider ? I do believe it can kill some logic if some bean of Provider.class should have singleton scope (in custom code for example).
why are we doing a bean lookup here?
IMO the logic that is now in the configure method of the properties class should just be here instead.
Does this cope with the case "The previous session ended in a crash. In other words, one session can only have 1 crash at most." in the project definition? Should we also check if there have been unhandled errors?
Create an io.realm.internal.objectserver.SessionManager and move sessions there? I am quite uncomfortable to expose removeSession() to public.
Maybe pull creation of this exception in a method so it is not duplicated here and in assertOpen
I think it is confusing to put this above instead of in doCreateProject (right before the RPC call). If there ends up being another way to trigger the create (via keyboard...), it will be missed, or have to be duplicated.
I am having a hard time understanding the reason for this change?
There is no need to create an odd variable
Again, perhaps I don't understand the Java API, but IIUC client.flush(...) is explicitly telling ES to flush all memory associated with an index to storage, and that ES tries to do this automatically. If we have to do this, then commit() is definitely the place to do it. But is it really required? Do we want to force a flush to get the durability of the write to disk?
Should use the log, maybe a warning.
Shouldn't we propogate this exception?
This is another one that might cause problems. @lbergelson you've done a lot of refactoring to pull interval/region-like methods out into a single class; do you see changing Interval.equals() to not accept subclasses?
This code is correct, but it could be implemented in a more succinct manner that is a bit easier to read: public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrManagedConnectionFactory ) return this == other; return false; }
suggestion return Objects.equals(address, other.toString());
Could we call and return the argument(GraphQLArgument.Builder builder) overload that's defined below?
This method has an external annotation now.
nit: check if this is empty, and if it is pass null? Otherwise you can't add an initializer on the copied instance. (I'm looking at the constructor and trying to figure out what the opposite assignment is!)
Should remove, and use similar functionality in CoreAuthenticationTestUtils
can we pick one over the other especially if it's just test convenience?
This shouldn't depend on the concrete type
Looks simple enough. Are we OK with exposing those objects though? One could iterate and modify the readers individually. Just making sure...
Since I'm suggesting creating the Response with the input stream this could simple return it now
@fabriciofx Here also, we could return the body() of our decorated object directly
nit: I would extract webDriverContainer.getContainerInfo().getMounts() variable :)
I _assume_ that the Testcontainers project will be permitted to freely use the enterprise edition for local builds and CI testing of this module?
Possibly the better option (not requiring waitForSQSContainerToStart) would be to use different waiting strategy (reference: <LINK_1> java .withExposedPorts(80) .waitingFor(Wait.forHttp("/"));  withe the port exposed by sqs and end the endpoint pointing to the queue we're interested in (<LINK_0>
You should create a ServerSocket on 0.0.0.0 to attempt to bind the port, rather than attempting to connect to it. There are a lot of reasons the connection to the port could fail, and it could even block for a bit trying to connect which would cause this function to hang. Additionally, there's no real guarantee in singularity that the app will bind to 127.0.0.1, it could just bind to the main IP of the host and you'd miss it, so binding 0.0.0.0 would ensure it's not listening to the port on any address.
Let's add a message here: "Checking if port XXXX is in use...".
Current code doesn't detect port 8080 is used by my local EAP. The only way it works for me is if it's implemented as  java try (Socket socket = new Socket("localhost", port)){ return true; } catch (IOException e) { return false; }
log should say store is not initialized.
Are you sure you don't need to wait for the start completion of any of the services? Looks like this service is just a meta service that starts other services.
Addressed.
nit: We have this logic in a couple other places. Maybe sufficient cause to turn it into a method?
Can it be null?
Nit: should this be declared final?
Hello~ The classes in jars in extensions directory are loaded by URLClassloader, but the KafkaProducer here use the appClassLoader to load classes in org.apache.kafka.common.config.ConfigDef parseType() and this lead to org.apache.kafka.common.config.ConfigException. That is the problem I got. I found some code in KafkaIndexTask, in method newConsumer() such as:  ClassLoader currCtxCl = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(getClass().getClassLoader()); // ignore some code ... }finally { Thread.currentThread().setContextClassLoader(currCtxCl); }  This can solve the my problem. May I ask have you encounter this problem?
The producer is create using try-with-resource clause thus, the producer should be flushed on the implicit close() anyway? Thus, I don't think explicit flushing would help?
I understand, that it's not in this task, but can you please rename method before from getKafkaProperties to getKafkaConsumerProperties?
Wouldn't it be better to rename mPostsList to something like mQueuedPostsList now that this PR makes a clearer distinction between something being currently uploaded as opposed to something being in a _queue_ to upload?
This can be simplified to return (postToCancel != null && mUploadStore.isRegisteredPostModel(postToCancel));
Maybe we should rename org.wordpress.android.ui.stats.models.PostModel to StatsPostModel to avoid confusion?
@Nullable public
diagramEditor = null; --> to avoid potential memory leak
I think injectionTarget.getClass() does not make sense here. It will be better to simply pass the IT instance. And the same probably applies to extension. Also I think it would be better to log both the original and the new value for all ProcessX events, e.g. something like: ProcessInjectionTarget.setInjectionTarget() called by {0}: {1} replaced by {2}. What do you think?
It would be nice if the default value of a "1000" was in a constant, and maybe you want to set the default to zero in case you pass "false" as an argument for the detectColumnTypes property.
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
-1 just noticed now: forgot about skipExec here. This must also be handled, otherwise it will be ignored now.
Changes this to: return newKeyExpression( colKeyExpr.getDatum(), colKeyExpr.getPosition(), // This will cause the IN expression to be removed from the where clause and // processing to continue for subsequent row key columns Collections.<Expression>singletonList(node), // I actually don't think this is used anymore, so I'll remove after I pull your change in. // Instead, the above extract node list is used where this was before. But this is now // an equality check instead of a filter between the min and max in the list list. true, ranges, node.getChildren().get(0)); 0
defensive copy?
This value can also be parsed from the mzML:  <scanList count="1"> <cvParam cvRef="MS" accession="MS:1000795" name="no combination" value=""/> <scan> <cvParam cvRef="MS" accession="MS:1000016" name="scan start time" value="0.0028779136" unitCvRef="UO" unitAccession="UO:0000031" unitName="minute"/> <cvParam cvRef="MS" accession="MS:1000512" name="filter string" value="FTMS + p ESI Full ms [118.00-1750.00]"/> <cvParam cvRef="MS" accession="MS:1000616" name="preset scan configuration" value="1"/> <cvParam cvRef="MS" accession="MS:1000927" name="ion injection time" value="50.000000745058" unitCvRef="UO" unitAccession="UO:0000028" unitName="millisecond"/> <scanWindowList count="1"> <scanWindow> <cvParam cvRef="MS" accession="MS:1000501" name="scan window lower limit" value="118.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/> <cvParam cvRef="MS" accession="MS:1000500" name="scan window upper limit" value="1750.0" unitCvRef="MS" unitAccession="MS:1000040" unitName="m/z"/> </scanWindow> </scanWindowList> </scan> </scanList>  Check the "scan window lower limit" and "scan window upper limit" accession. If the value is not present in the file, return the value of getMzRange()
i remember that month number should be 11
Shouldn't this be Calendar.getInstance() instead ? That way it's truly a no-op.
this is 12/21, not 11/21, a minor issue, but better to change it
add "this" qualifier
How about a few simple tests for this method?
Is this a textual description or should this be an enum?
This may not be thread safe if only one sender is instantiated. We probably only want one sender or at least only one httpclient.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
throw UncheckedIOException(e)?
It may be worth expanding this to include say: + "who also have 'Push' rights on " + GitRepositoryManager.REF_CONFIG
Is this change related to supporting commit validation by plugins?
The rest of this method used the ctl.getRefName() inline where it needs it. I proposed to remove this variable and use ctl.getRefName() to match the style in the rest of this method.
how can a clusterName be null?
Is this really correct? ASCII characters would include all 128 defined ASCII characters, but the actual limits are smaller: <LINK_0> Perhaps this message should just spell out the requirements exactly: A letter or number, followed by letters, numbers, dashes, dots and underscores (underscores are not listed in the whitelist, but anything else is replaced by an underscore, making the underscore implicitly allowed). Maximum length is 63 characters.
Hi @tmiyargi @fl4via and/or @stuartwdouglas will have a final say on this one. I'm just a lurker in this project. Having said that, I think the backward compatiblity of this shouldn't play a role here, because this bug fix is about fixing a wrong value that was being retuned, before this change.
enclose if and else within { } even if it's a single line
final URI uri
Minor - we can do fb: and fbkey: as static final strings instead of hard-coding them here?
new Boolean avoid the constant pool -- putting unnecessary pressure on the garbage collector. Please use Boolean.valueOf instead.
Yes, that's what I was thinking: HMV could be set at any time, including between cap-fetch and selector-creation. By the way, it looks like StringDimensionIndexer's handling of hasMultipleValues is not thread-safe (it's updated by the indexing thread and read by querying threads without locking). It'd be good to fix that too.
Could you add more information about this log: logging.info(String.format("Sitting capabilities for current browser - %s", getCurrentWebDriver().toString()));
Wouldn't it make sense to call setImage here? Or do we have different semantics in that method and this one?
What's driving the change to increase visibility here? These are intended to be used only by subclasses.
Follow the same order of argument definition. Always add requireNonNull unless we are sure it is not needed (@Inject) or the value can be null (usually annotate by @Nullable).
I'd rather toLowerCase() is applied after substring(), not before.
Why do we force the code to 4 digits? And btw what will happen if a new reason code is added with 5 digits? In that case, it could be a good idea to put the format in a static variable near the enum.
You could remove the braces around the first check.
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
shouldn't this have a more specific type?
This is not necessary.
final is useless here. Also, consider this.  java try { callback.onSuccess(sessionStore.read(AuthEndpoints.NAME).getAccessToken()); } catch (Exception e) { callback.onFailure(e); }
Why not pass the paymentAccount and avoid the extra lookup and null check in paymentAccountManager.removePaymentAccount?
Is this how it's supposed to be used? Secret Store's tokens are not OAuth Tokens.
Same here, return ImmutableSet.of(this.modelResultStream, this.rootResultStream);
Actually the underlying objectExpr could have free variables.
What's the reason to remove the isBootstrap flag? I thought that we need that to avoid repeatedly pulling on the coordinatorStream?
should this be wrapped in a try-catch, so that we can do ServiceStateLogic.setExpectedState(this, Lifecycle.ON_FIRE);? For example, see DynamicClusterImpl.stop() and AbstractApplication.stop().
As noted above, just put the init code in init() unless there is a reason not to.
This reads as if TenantIndex initializes the BoundedContext.
Can be made package local
Only one return statement
make it a static method?
You could add a package-info.java file to the package
Maybe more informative like so:  "Unable to get build host, skipping " + BUILD_HOST + " value..."  ?
DnsResolver was written as a utility class with only static methods. This PR changes an implementation detail of this class so there's no need to make it possible to instantiate DnsResolver directly. Also, I'm concerned about making such breaking changes to public methods. The PR can be greatly simplified if the static change were to be reverted.
assertFalse(...);
assertFalse(...);
assertFalse(...);
toString() output probably should not be dependent on the timestamp preference settings
Newline at the beginning of the string? For readability?
Better: '|'
Btw, this is why I suggested you just create a specialized Executor, so you don't need to do this manually everywhere.
I'd rather pass down the auth information to the QueryLifecycle. There's no harm in checking it twice, if it's good enough for Santa Claus then it's good enough for us. Checking it twice should also allow us to get rid of the no-auth path in QueryLifecycle, which would be good. Perhaps a good place to stuff the auth token is the PlannerContext.
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
"data" is already a plural noun.
This should also use JobParametersNames.
assertTrue(annotationMetadataMongo.isDefault());
I don't see where we handle HibernernateException.
suggestion if (session.isHost() && session.getRemoteUsers().isEmpty())  you have to check if we are the host, otherwise the client disconnects on a canceled outgoing negotiation
The session can be removed between the two calls to sessionRef.get(). Session session = sessionRef != null ? sessionRef.get() : null; if(session == null)
Any reason for using toString instead of getId these two lines? I prefer getId as it's more explicit.
@essobedo once used variable can be inline
if you think Lists should be made unmodifiable for private functions, this should be converted for consistency.
As a nit, should have a null guard here.
final
should not error if docker doesn't exist?
space line
The second condition should be clusterId <= MAX_CLUSTER_ID
return queryId
Possible NPE, miInfo.getFile() is not guaranteed in current implementation to return anything in particular, so may return null or empty string.
I don't really see a need for constructing a File object with the path to an URL here, just split it yourself
{ }
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
I'd also set a flag internally on this listener. Then, if in future some code called listenToCache() with an already-triggered listener, you could just return immediately.
Would change the function name to AllTeamsHaveAPlayer()
I think Guava has MapSplitter for this purpose.
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
This uses the platforms default charset, I think we should probably use the more explicit getBytes("UTF-8").
Why propagate and not simply Thread.currentThread().interrupt()
Can we log chargeId/ChargeEventId ?
Doesn't need to throw IOException
This won't make subclasses' updatePhysics cancelable. To do that, you have to create another empty method, call it at the end of updatePhysics, and make subclasses override that method instead of overriding updatePhysics.
It seems like passing the event id to the super class constructor and also making it a field might be a little confusing. Personally, I prefer the approach used in DataSourceAddedEvent where the id of the object is obtained in getNewValue via long id = (Long) super.getNewValue() and the "extra" field is not required. Thoughts?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Although AsyncClient is deprecated retrieving event loop has some additional checks. Could you please check AsyncClient.findEventLoop?
Still this can be a static message as all messages are defined in the beginning of this file
Update the docs above to reflect the exception.
All of the above getters/setters should be removed. Only the editorState getter/setter should be exposed and any other class that wants to modify the state should go through editor state getter/setter
nit: use parameterized logging (and for the subsequent log statements).
For future PRs, we use /* package */ to designate package protected methods.
In addition to methods, we could also cover functions and anonymous functions. That's what we do for [JavaScript](<LINK_0>
uncessary call to super. No need to visit further.
@ivandalbosco IMHO it's better to move the call to isPrivate into isException
Why does it need any change?
magic number?
For consistency, we always include curly braces for loops or if-else statements, even if only followed by one line.
Maybe worth removing the call to Objects.equals() here too, as both child and parent can not be null.
will this be called after removeView() for example? It seems like you'll end up adding the same view to mDisappearingFragmentChildren. Perhaps this is the only place it needs to be added?
nit: you can merge the above two lines
![MAJOR](<LINK_0> 'Severity: MAJOR') Make this anonymous inner class a lambda [![rule](<LINK_1>](<LINK_2>
looks like the exception is tested, but the delete itself is not...
1. Change Exception to exact exception you get 2. throw the exception after log or don't catch it here
please validate ledger id
move this to the end of class
Shouldn't result be returned immediately after the completeExceptionally call, just as with the mergeSegment(int) function?
ohh.. actually we should default to 443 if https!
Shall we move character '|' to a constant?
we miss a validation for the port value if it was provided by getParameters().getAgent().getOptionsMap().get(PORT)
Formatting (extra {})
So does this mean that pumpkins are easily duplicated?
s/spongeImpl/impl
remove this.
is it worth enforcing this locally? We might allow more colors in future.
How about applying this method inside convertColor to avoid duplication and to make sure the same input sanitation is applied? Looks like in all cases color.trim() is desired before calling convertColor anyway.
(nit) suggestion .computeIfAbsent(partitionId, k -> new PartitionUpsertMetadataManager(_tableName, k, _serverMetrics));
suggestion Objects.requireNonNull(partitionId, "'partitionId' cannot be null.");
Can simplify this to: return partitionIds.stream().collect(Collectors.toMap(Function.identity(), partitionId -> new CloudReplica(partitionId, currentNode)));
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
This should not be changed, you should only be changing search methods
Might be able to get away with protected
typo: perfrom -> perform
IllegalStateException
@garg-anuj Yeah doing that only.
Please make "global_timeout_config" a constant.
@TShapinsky DroneEventsType is an enum, so you can use event == DroneEventsType.STATE instead of using the equals() method.
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
Remove braces
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
Let's remove protected so it's package-private instead.
getAccountRequestCount.addAndGet(1)
Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?
This is functionally identical, but in the new code, in the string ID case, we'll query the DB for an account, and then only use the string ID (which we already have). Is it worth adding a hasId() to AccountId and optimizing on the case where we only need the string ID?
The message is misleading. It will crash the process. But actually that's fine, it should, if such a severe issue is detected.
Duplicate code, obtaining the Stage could use a method.
Now that you're at it...
please use a capital 'U' in 'Touse' to make it more readable :)
Probably need this?  binder.bind( new TypeLiteral<SeekableStreamIndexTaskClientFactory<KinesisIndexTaskClient>>() { } ).to(KinesisIndexTaskClientFactory.class).in(LazySingleton.class);  Please fix KafkaIndexTaskModule properly too.
This should probably throw if the value is null.
This method causes several build warning.
This will throw redundancy warnings in IntelliJ
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
It is possible for this to return null if no matching Activity is found, e.g. if one has no browsers install or no browsers set as default (not sure if this will happen). In such case we should do a null check and return null. Also can you put a space after ,? Thanks!
Thoughts on resolveInfo.isEmpty() instead of resolveInfo.size() == 0? isEmpty feels a bit more expressive of the intent.
Please fix as following code.  java PackageManager pm = context.getPackageManager(); List<ApplicationInfo> packages = pm.getInstalledApplications(0);  And please tell me what getInstalledApplications(0) means(flag)?
@antonini please name it user
@antonini please name it user, and initialize it with Opt.Empty
seems as nested if can be omitted and replace with a simple && condition with the first one
The writes in this method should be done under a lock, right? But I'm not sure that all execution paths do acquire this lock. Should we add synchronized (buffers) or checkState(Thread.holdsLock)?
It shouldn't be there. ProfileView should be shown in onActivityCreated of relevant activities in which we have to make it appear.
you could assign this to mParent in the constructor of Builder, and then you wouldn't have you check against null?
I'd use << 3 to match MemoryAddressHash
if rowsize is always positive the check for -1 is not necessary
maxSize being an int, that Math.min is quite unnecessary. But you do need to make sure it did not overflow, so I'd say Math.max(0, maxSize);
Let's have constructors one near another
Factorize userManager into a local variable.
You don't want to freeLock() before that operation? Maybe you should also change status of template at DB to lock? Global transaction?
We should throw an exception here too, saying the cluster is invalid.
This first null check is not necessary, as String.equalsIgnoreCase() checks for null and returns false if it is false.
Error message should have zoneId. I think this goes for every message that prints a cluster...
wrap with Collections.unmodifiableMap() ?
nit, Collections.EMPTY_MAP?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
The space here is also inconsistent with the rest of EssX.
suggestion private void addMismatchReasonInternal(String reason) {
I've had second thoughts about including this method. I think it might be confusing. What if the user includes named placeholders in the message? Will they expect the attribute values to be substituted? Also, for symmetry you might expect the attribute map to be added to other factory methods. Better to keep things simple and get rid of it seeing as we said we didn't have a use case for it now. We can always add it later if we need to. P.S. Sorry for changing my mind.
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Would rather be Qubole Spark 2.2 ?
Collections.emptyMap()?
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
This check for reservedProperty will be taken care of in the call to getProperties(name) below.
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
why not put this all in one if condition? if (input instanceof EditPart && ((EditPart) input).getModel() instanceof ConfigurableObject)
It is not a good practice to leave the brackets even if there is only one line you should always have them. If someone else comes and adds another line it may produce a bug.
is there a version with more parameter than 3? If not i would use == 3 rather than >=.
There is also an assertEquals(float expected, float actual, float delta) method which only used float and has a delta. It won't be caught by this.
Could you replace both lines in favor of BooleanUtils.toBooleanObject(String) with throwing error when null returned. I guess it would be safer.
result can never be null, we don't need this != null here
result can never be null, we don't need this != null here
We should consider extracting the functionality of the stringValueOf(...) to some helper/utility class, as we may use the same functionality elsewhere? :cake:
In tests we can just declare that these methods and the test methods "throw IOException" rather than catching and wrapping them, and just get rid of the catch clause.
use try-with-resources to ensure this is closed so the Inflater can be released.
Test with no assertions whatsoever?
Consider an overflow check here. @Nashatyrev proposed a good and simple solution for such cases <LINK_0>
Maybe return -1 directly. Had a "wait what?" moment here because looking at return numDocs isolated I didn't get why it's okay to return that as averageSizePerRowInBytes value.
Is it safe to set limit for buffer here? I'm not sure. Suggest to get a read-only buffer.
Please use PathUtils.validatePath to make sure that the path is valid before accepting it.
Could you mark the constructors @Deprecated instead of deleting them / reducing visibility? It makes it easier to transition between versions if we deprecate first, then delete later.
I think baseUri.toAsciiString() always has a trailing / in our usage so with the current build() method I think you will end up with (for example): http://some.example:80//path/path/path?query=true changing to this.path += encodePath(path) + "/"; will result in: http://some.example:80/path/path/path/?query=true I think both of these are valid URLs, but I think we need to be sure there are no server side issues if we use either // or /?. @tomblench any thoughts on this?
Not atomic. Two threads can reach line 100.
Not thread-safe, despite use of a wrapped ConcurrentHashMap. registered.contains() and registered.add() are not collectively atomic.
Wouldn't that happen when someone projects on an empty list of projections? Which, granted, doesn't seem very useful, but could nevertheless happen, especially when someone is only after the number of results. Maybe a safer approach would be to use a TotalHitCountCollector by default.
do not expose the list directly
SimpleDateFormat is not thread safe, so you can't share it across threads. The static instance _can_ be used across threads since this method is static, so it's not safe to make this change.
maybe add a saveguard for extremely broad ranges?
IMHO we should remove the empty line in front of a closing bracket.
This possibly overwrites state of processed item.
This possibly overwrites state of processed item.
static import QUERY_THEN_FETCH
Double assignment to scroll is bad style, and the toString is implicit when concatenating to a String. Just use: IDontKnowTheType requestScroll = request.scroll(); String scroll = requestScroll == null ? null : "&scroll=" + requestScroll;
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
probably this is an exceptional situation
you can't get here with vm == null, so it should be removed from here.
why not to compare with the standard java way for enum comparison (== VMStatus.Suspended) ? and don't you need to check whether it is different than Suspended?
In this case that you read all files into memory, there is no difference between using this and using File.listFiles()... Just saying... Something like the following? :) for ( File file : new TreeSet( Arrays.asList( dir.listFiles( new FileFilter() { public boolean accept(File pathname) { return pathname.getName().endsWith('.properties'); } } ) ) ) ) { loadFile(file); }
Files.mismatch should do the job <LINK_0>,java.nio.file.Path)
For better readability, extract to a private method so that we can have a method reference in forEach
You can replace by: this((GraphicalEditPart) editPartBot.part());
This can be ImmutableSet.
Why TextEdit?
Surely this should be wrapped in a Callable so that it runs on the slave rather than on master? (It seems to produce 0.0.0.0 when I try it on my Linux machine, but if that is guaranteed then we should just hardcode that string to begin with.)
Should we check if address is empty before return? Or compute address like before when address is empty?
style
assertThat(c.getParentCount()).is(2);
Remove these lines, you don't ned them. There is submit() method that does this standard thing.
this only asserts that this commit has this commit message but not that its tree is empty. Either check the commit tree to verify it is empty of change the method name to something like: assertCommitMessage
I'm not sure about coding OS-specific-ness. Is this the sufficient condition for all OS? 1. Does SWTBot has any users on SunOS/Solaris? Will the statemask be correct if someone uses GTK on Solaris ? It will be risky unless we test it. 2. See Util.isLinux() implementation in org.eclipse.jface.util package. It considers 'motif' also as Linux, along with 'gtk'. It seems SWT supports motif. It may be out-dated. Do we need to consider motif? Since 2-3 years we have been discovering some differences in SWT behaviors on win, linux, mac during our SWTBot reviews. There will be limitations to support each such difference. But then there will be inconsistency if we support such difference at some places. What is the best approach for swtbot?
remove public
If it doesn't have the right coordinates it's probably not useful ;)
You should have moved it here.
This should be a composite error with the original error followed by the handler crash. Example: <LINK_0>
This does eventually emit the CompositeException. Is this consciously wanting to handle each error individually instead of only via the composite?
Should this be onReplicationPutRecord?
Useless white space here.
why change this?
Same thing than for the agent: no default value.
Please keep this.cell near the related fields (previousFamily & cell count) below
have a default constructor with reasonable default values
Need to use UUIDs instead, for performance. Nit: can be final.
why are we changing the visibility of these methods?
Isn't the isSessionExists condition enough?
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
You can use the EntityTypeRegistryModule instead here.
doesn't look like this variable is being used. Suggest removing if this is the case.
Replace 'commit' with 'committed'
Replace 'commit' with 'committed'
Same as above, I think this should something like that:  catch (Throwable t1) { try { if ( transaction.isActive() ) { transaction.rollback(); } } catch(Throwable t2) { someLogger.warn("Error while automatically rolling back a transaction", e); // Maybe we could remove that t1.addSuppressed(t2); } throw t1; }
negative logic
negative logic
Is it needed here? Doesn't line 764 do it?
does this need mUseReservedSpace? Also affects equals() and toString().
Should this have output partition too?
I really never understood why these aren't Math.min'd
Throw an unsupported operation exception here.
new ArrayList<>(causes);
we should return immutable list. You only expect caller to do read operations, right? #Closed
assertThat(map).doesNotContainKey(new Object());
do we also want to check cleanup of key B 3 if it were in the map?
Ok so it looks like in COUNTRY_TO_REGION_CODES we have: java map.put(800, singletonList("001")); map.put(808, singletonList("001")); // ... map.put(870, singletonList("001")); map.put(878, singletonList("001")); // ... map.put(881, singletonList("001")); map.put(882, singletonList("001")); map.put(883, singletonList("001")); // ... map.put(888, singletonList("001")); // ... map.put(979, singletonList("001"));  So when we're looping through that map we would overwrite the 001 key with, 800 then 808 then 870 etc. So while the end result is OK because we do map.remove("001") I am now worried about our map inversion technique. Are there any other codes that appear multiple times that we would be overwriting? If so isn't that almost definitely a problem?
According to my own tests, using values-night allows you to omit this (in multiple places)
when autoconfiguration fail, the app should not continue with demo user, you must do nothing, you will be in no-login mode
Shouldn't we instead go to the TabLayout activity here iff we have a selected instance (i.e. you didn't get here from the InstanceSwitcherActivity)?
HttpServletResponse.SC_NOT_FOUND
Please make sure the word class is not added to the message before the class name.
Calendar instead of Calender?
Same here about being consistent with the underscore.
Please change error message to "The session has expired" Is there a way to add a timeout, because for now, this error message is only briefly showed and if user is not paying attention, he might miss what happened.
I don't think the casts to short do anything useful here.
I think you can make the ResourceLoader a static class variable as creating an ResourceLoader can be expensive.
Map
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
No biggie, but for Java 8 this could be: java final Path file = dest.toPath().resolve(fname); writer = Files.newBufferedWriter(file, UTF_8);
How about using GSON.toJson(o, new OutputStreamWriter(entityStream))? We should also make sure to flush the writer before leaving?
This is broken again. Since a new OutputStreamSelector is created for each Content, when this method is called OutputStreamSelector#getUnderlyingStream returns null because it has not seen any bytes. We'd want to force the text stream in this case, but I'm not sure what the cleanest approach would be.
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
I'm afraid there is a code logic problem here. If you call setReadTimeout then setConnectTimeout the read timeout is going to be override because a new client is built with only the connect timeout set.
Use ConfigUtils:isBetaFlavour
How about making these constants as static variables?
(nitpic) 0.0f is float, you mean 0.0 (double)
This change actually generates worse and larger bytecode than it was before.
It's probably better to extract a constant for "object".
why not just return new ObjectMapper().writeValueAsString(arguments)?
HashMap is enough, here.
Do we need this?
can this be cached? I hope TMF doesn't migrate, but I think this is a fix that will slow down Linux.
no need for logging here
final?
It is save to return false? Should we rather throw an IllegalStateException ?
The original version is more precise?
Fix method name with prefix..
ArboricultureBlocks.SAPLING_GE.blockEqual(blockState)
Formatting (extra {})
Adaptive banner code is removed, so I think if publisher requests a banner ad with custom size, adapter doesn't map it to AdMob supported AdSize. I think adapter should have Adaptive banner implementation.
Why do you need to add this check here, but not this one ? if (!"".equals(adapter.getSearchQuery())) { showSearchBanner(); }
FIXME: Don't cast getActivity(), use an interface.
Just return data.
I think this should be formatted consistently with the methods below it.
new Double is redundant here
please, talk with Matthew. I think we trying to use Objects.requireNotNull() instead of NonNulUtils.checkNotNUll()
almost forgot... i have warnings here. Do you have them? could them be fixed?
should this be return?
The incore merger works in memory without a working tree. Does he need attribute handling?
This isn't necessary. When you need the inserter call getObjectInserter(). Your super class manages allocation and release for you.
This no longer needs to be public, that was only for MergeOp.
Duplicate getAbsoluteFile()
Does this work in all cases? Note: There can be folders in folders in folder etc.. I think there might be an easier way.
is this 10000000000l or 100000000001? Use upper case 'L' a lower case 'L' should not be used for Longs or variable names.
You'd probably dispose your stuff, and call super.dispose() at the end.
we should probably call EcoreHelper.unregisterEcore on dispose, shouldn't we?
The controls will get disposed by the platform. You only need to call super.dispose() because the viewer is a TmfComponent.
Doesn't this duplicate the nonNull check?
Doesn't this duplicate the nonNull check?
Is the type of the left-hand side important? Can you add another method that does Object check2(Data p) { return p; } which I guess should also give a unique.leaked error.
Can be simplified to java return itemMaterial == null ? 0 : itemMaterial.getMaxDamage();
Do not need to implement these methods?
Why Long instead of long?
There is a lot going on this one line.
Hrmm, should this be needed? I wonder if this is a sign of something else being wrong.
if ... return map.get else return null
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Should use ToStringBuilder.
Extra ", "
While interesting, this is not a standard toString() impl in the Che codebase. We generally do not use multi-line string representation nor do we use "class" prefix. We generally do however enclose string fields in single quotes and use simple string concatenation to build the string. Please look around in the sibling classes for guidance.
should this count be parameterized?
Coding best practices: Interface i = new Implementation();
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
new HashMap(delegates) - don't keep a reference to the caller's map - he might change it.
Do we have to make new instance of MLRCodec every time?
Do we have to make new instance of NMFDataCodec every time?
This shouldn't declare throws Exception.
Need to implement
![MAJOR](<LINK_0> 'Severity: MAJOR') Update this method so that its implementation is not identical to "getSecurityProfile" on line 386. [![rule](<LINK_1>](<LINK_2>
Use logger?
here too, or just log the error
Should use the log, maybe a warning.
Our code needs to be compatible with Java 8. List.of() was brought in Java 9. Can you please refactor the code to be Java 8 compatible?
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
I suppose that there should be "assertTrue" here.
This is a bit of an odd definition: Technically: "hello world" is a proper regex. You probably want on top of this to test, Pattern.compile(optionValue) to ensure the regex is properly formed
DEFAULT is null while the constructor in its initializer expression is running.
What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.
suggestion return Objects.equals(this.getName(), actionParameter.getName());  The reason for this suggestion in general is that it handles nulls properly, e.g. if this.getName() returns null the previous implementation would crash
If a branch gets deleted can newObjectId be null so that in this case ObjectId.zeroId() should be used as new objectId?
Error message should indicate "Seventeen-argement init()" instead of "Fourteen-argument init()".
Why not use the type safe InvalidMdbFinalClass.class.getName() rather than a hard coded string?
coding style:  try { ... } catch (ClassNotFoundException e) { // Don't mind... Attempt next class loader |
Will this ever be used outside of jolt? If not change it from public.
This should be 3.6, even if the "quota mode" concept was available sinnce 3.2.
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
Please, change this statement to the early return form. That's the standard we use throughout the code. That's the only objection I have currently. If you fix it now, I'll be able to merge the code before branching 4.3.
Make these Locatable.
if it is not constant, please convert to lower case?
Call getStart() and getEnd() in this test as well
Why do you need caching of the originating _serviceLoader_ ?
Are we sure that is OSGi is not in the classpath we don't get a NoClassDefFoundError? Do we have a test for that? Why aren't we using the default class loader from ClassLoading instead of the class loader from ClassLoading?
Can this happen ?
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
is this class going to be created by the user?
remove? this looks left over from manual testing.
It seems wrong to me that we invert what was set and then let the action set it back. :P How about we just take the option as is and then do compareModeAction.setChecked(compareMode)?
minor: I personally think that 'this' is redundant here.
This should be synchronized.
this can be condensed to  if (!chkAuthorization(...)) { return false; } ... return true  and get rid of haveAccess
Let's implement this in pre listener. Also need to implement doPreSetUserClaimValue()
Don't construct a list return either Collections.emptyList() or ImmutableList.of();
No need for super()
calling super not needed
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
Are we not closing file handles now? :)
static?
this removes the entire failure path of the test: The assertion that appending to a nonexistent file raises an error. Why did you make this change?
a workspaceitem should be returned
Consider creating the Exception on the dumpapp thread and just sneakyThrowing it here. Then any strange errors are visible to the command. Also, then the state of the class can just be the Exception and you can be more explicit about the parameterless getDeclaredConstructor() being a fallback that intentionally leaks NoSuchMethodException.
The duck and throwsUnchecked methods need to be moved from this interface (where they are public methods) to some class in this package where they can be package private. Then the code above can use this duck method.
Same here? It is always number or null?
We have a removeConfiguration so let's not allow null value here?
space
Use InvalidArgumentException instead
Why not reuse existing? public static Type valueOfIgnoreCase(String name) { if (name != null) { return valueOf(name.toUpperCase()); } throw new IllegalArgumentException("Invalid value null"); }
I think we need something similar to ReusableParameterizedMessage.reserved for this to work, otherwise we will clobber threadlocal state with something like this: java private void func() { log.atInfo().withMessage("Value {}").withParameters(getValue()).log(); } private Object getValue() { log.atInfo().withMessage("Getting Value").log(); return value; }
I don't think we need the Integer.valueOf() boxing since startId is an int.
Minor nit: can we change these to use "reader job service" to differentiate them from the existing logging in ReaderUpdateService?
also, DbFacade.getInstance().getVdsGroupDao().get(params.getVdsGroupId()) can return null
Should make a differentiation of the name and id.
Is this supposed to be <code>return "Bump"</code>?
Why do we return the parents name instead of the name we store a few lines above?
Shouldn't this be public? Also, if we need the getter methods (and I don't think we do) could we put them right after the setter methods?
should this be named getRelativeDestinationFolder then? But the way it's used in ImportHandler.java is not relative so it looks like it's the field that needs to be renamed.
Check first that target is not null.
can't the response be null? if null as return value is legit for non existing snapshot, move the initialize of the VM into the condition.
seems like synchonized is not needed here, given increment/decrement already protect
Why do you include the size of the binding set as part of the hash code?
why not use File#getName() for the name?
There is no need to hide methods in tests, it just makes reusing code more difficult when using discovery features in IDEs like CTRL-space for method names.
I missed this the previous turn, I think; when filemode is false both changes from regular to executable and vice verse should be ignored.
It would be great to cover the util method with tests.
str == null cannot be true here as this was already checked upfront by <LINK_0> (it also correctly results in null there). We could also move this empty string or 0 length up under that check as it would be same for both functions.
nit: style wants newline
Should use a constant instead of a raw String
Use Set or SortedSet as variable type.
The sublist could use a vraible for readability and line length
Should be "InstaPost" actually.
Looks like this toString() got generated before the tags field was added :P
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
events.isEmpty()
Maybe good to add a limit to the total number of events that can be queued (suppose the send takes a while because of network issues and lots of events queue up in the meantime, leading to high memory usage)
@erdemedeiros let's remove all the system outs
I would prefer to use full words. For example directoryAllow.
I am thinking if not better to get init parameter of form: schemes.* instead of split... do getInitParameters() and enumerate extract what is prefix schemes.x sorted. not critical, but will allow comma within name...
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
[minor] IllegalArgException?
This kind of beats the purpose of having the "copyToDSpaceObject" method. This code will force hibernate to execute two DB statements: an insert and an update. I think you should move the copyToDSpaceObject to the ResourcePolicyService: * Create a new empty resource policy * Copy over the values * Then pass that filled in resource policy to resourcePolicyDAO.create(). You can enable Hibernate DEBUG logging in hibernate.cfg.xml to see the SQL statements it executes.
Do you need any null checks here?
I think can just use the @FindBy defined at the top instead of findElement() againt
maybe use single quotes to avoid having to escape the enclosed double quotes (applies to the rest too)
Is there a reason for not using the MoreObjects.ToStringHelper instead?
This should probably throw if the value is null.
:warning: Left over test log
I this refactoring, very nice. Could make this method protected.
Does this work return new String(content, charset.name())?
You probably don't need a second byte-like stream. Just do return BytesReference.toBytes(out.bytes()) or something like that.
why charset == null? if charset is not available it should use default charset.
COuld we reuse <LINK_0> ?
I think that symbol might be null here.
Minor detail but you can check type and then assign a TypeSymbol variable.
why is it adding null?
@vmaletta add final
add final
why do you call this? It will be called anyway by default.
check for READ_ONLY style is missing?
should be synchronized
I think this one could be private
Maybe it would be good to be consistent with MigrationResource and return the deleted entity in a response here as well.
same here, should be thrown from within the service in my opinion
This seems unnecessary, if you going to return the same thing at the end of the method anyway.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Why not write: "return returnString" ?
If Java doesn't have built-in libraries for this, may be use an external library such as jodatime or natty?
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
The action for these terminal cases is now the same as for TASK_RUNNING; so we might as well combine those cases. i.e., Line 97 above is the same as line 104, and there is no longer this special taskTerminated method being invoked for the terminal cases.
Should include other properties to break ties here
Is the reversed order on calendarName intentional, or should the comparison be made the other way around?
Is the reversed comparison intentional?
Actually the underlying objectExpr could have free variables.
nit: let's avoid return null even it's unused. Instead we can return Collections.emptyMap()
Can we have this return Set :)
here we need to go through Optional.ofNullable(Plaform.getProduct())
I think the chart viewer should be responsible for its own presentation provider. The tree viewer could ask the chart viewer for a series appearance directly, perhaps through the ITreeViewerInterface? (could be renamed ICounterChartViewer).
You should probably call super.dispose() here too
suggestName?
Revert back to sessionFactory.getCurrentSession()
ControllerLogger.ROOT_LOGGER.invalidParameterName should return IllegalArgumentException so you can just throw what it returns without wrapping.
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
It'd be informative to mention how long we will wait in the log message.
Should this method be public?
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
I think the CosemDateTimeDto is immutable, and as such there is no need to create a new one to protect the field in this class from changes from outside.
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Use the enum for valid values.
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
missing braces, more below
This would add IGNORE_RETURN_VALUES to the provided explicitFlags set if it was not empty, which we can't do. Maybe instead we just create an EnumSet that starts with IGNORE_RETURN_VALUES and add explicitFlags to it and use the resulting EnumSet.
Should the clear also remove the old error messages?
This needs to be changed to support locked stream syntax now.
this for is exactly the same in all the array tests, let's move it to a private method
Can revisionInfo can be reused here too?
See below (return copy)
break the line
Is it required for the upgrade?
This variable is never used.
final List<T> sorted = ...
You can replace the for loop here with values.forEach(result::add);.
I think if the label applies to the complete project, the branch list should either be empty or it should contain 'refs/*' as the only entry.
Should be final.
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
Where does the 5 come from? I feel like we should just throw an exception here.
I think there is some findbugs issue with not using {} not sure.
1. what if value is not bool? exception? you should be able to recover from it nicely 2. you doing unneeded boxing, by returning class where primitive expected, use Boolean.parseBoolean() instead 3. please cache the value of the header, there might be few queries during the hit calling isFiltered(), - you don't need to preform header retrieval and casting every time.
requireNonNull?
why the newArrayList? Iterables.filter already returns an iterable.
Iterables.filter(Iterables.concat(bob), isAssignabe)). use iterables methods on iterables?
ImmutableSet.copyOf(Iterables.filter(...)) ?
It would be ideal to clear and repopulate the LibraryType table in the V9000 test data migration. Then it's easier to test against an exact controlled number of LibraryTypes, rather than making the tests more lenient. Same with LibrarySelectionType below
missed one
Could we please use non empty expectedDataTypes? Test in the current form will pass even if we change this line to when(dataTypeUtils.defaultDataTypes()).thenReturn(new ArrayList<>());
Getting all of the parent valuemaps and merging them all just to get a single property feels a bit heavy. Within the loop couldn't we simply call resource.getValueMap().get(propertyName, declaredType) and then break; if a non-null value is found? That way we dont even look at higher resources in the tree than necessary when the property is at the lower levels, and we dont have to bother merging a bunch of maps. Thoughts?
Better check if fileResource instanceof JavaResource instead
I prefer stream+collect rather than foreach and adding element to an external list eg (please note I'm using default naming generated by idea here):  List<CloudResourceStatus> collect = findResources(resources, List.of(AZURE_DATABASE)) .stream() .map(r -> getCloudResourceStatus(cloudContext, force, client, persistenceNotifier, r)) .collect(Collectors.toList()); return collect; } private CloudResourceStatus getCloudResourceStatus(CloudContext cloudContext, boolean force, AzureClient client, PersistenceNotifier persistenceNotifier, CloudResource r) { LOGGER.debug("Deleting postgres server {}", r.getReference()); azureUtils.deleteDatabaseServer(client, r.getReference(), force); persistenceNotifier.notifyDeletion(r, cloudContext); return new CloudResourceStatus(CloudResource.builder() .type(AZURE_DATABASE) .name(r.getReference()) .build(), ResourceStatus.DELETED); }
why not  why not  this(snp, getHaplotype(), likelihoods[0], likelihoods[1], likelihoods[2]);
I would use covariant return types here so you can write suggestion public HaplotypeProbabilitiesFromContaminatorSequence deepCopy() {
Please change the line 38 to also use EnumMap<> for consistency.
Why didn't you cache the value?
IMHO, for things like variable naming, local consistency is arguably more important than global consistency, so naming this e is best. If we make a global change, I would prefer to rename variables of type Throwable to e
it would be nice to catch runtime and rethrow them as is instead wrapping in them in another runtime.
(ListView)  can be removed
Can you please also refactor file with name layout_list_item_with_menu.
Nice, I wasn't sure that method returned pixels, but it does!
Typo <naming
Use the activePlayer object instead of retrieving it again
Missing randomDiscard param.
Why do the containsKey check? If its not in the map, then get() will return null.
This is not necessary to instance validation util. Because this management API is used for check real data resource. Our split could even better to filter out the TASK current state.
Do you think it would be useful to log (warn) if this evaluates to false?
You have insertAfter(..) and insertBefore(..) on DataTypeList and its View however use insert(Field)Above(..) and insert(Field)Below(..) here.. would a consistent term be better?
This makes this nullable. If you think this will never return null, then you may want to throw an exception NullPointerException. But if it can be null (like the trace is not set yet or something?) Then make this method @Nullable and do a null-check when you call it.
We should add NPE guard: java findItem(existing).ifPresent(item -> { for (final DataObjectProperty property : dataObject.getProperties()) { final DataType newDataType = createNewDataType(property); item.insertNestedField(newDataType); } });
@garydgregory Please use Args.notNull for consistency with the rest of the code base.
could store this in a field to avoid recomputing the same thing every time we call this method?
nit: you can merge both lines above as checkNotNull will return the given argument
can we remove: declare-response, useless-assign and just return the object from the method-call?
Right here (and in the equivalent 3.0 class) is the only place you're using "this" where a field isn't shadowed, is this intentional?
Optional: no need to throws Exception since you already catch the runtime Exception here
Minor readability suggestion suggestion model.addPropertyChangeListener("scriptStatus", ignored->{
why does this need to be synchronized?
Similarly here: suggestion OnmsAcknowledgment ack = new OnmsAcknowledgment(alarmInTrans, DEFAULT_USER, now);
You should sort this Set by name asc and length desc. So we always generate methods with greater args count, for overloaded methods.
rename to type
Wouldn't be more reasonable to use entry.getValue() here, too
Do not make input file names cryptic. Please rename the file to clearly state its purpose.
I think there should be one violation.
Why we declare full path when you created the method getResourcePath to make this simple? Lets change this to use the new method.
should do some validation too. For example, if the input schema is non-null, make sure the fieldToClassify exists and is of type String, and the predictionField exists and is of type double
-1 this will cause ArithmeticException's <LINK_0>
seems like this should be config.maxSplitSize
I know that tag is marked as NonNull, but since this is part of the public API, we should make sure to not accidentally introduce a possible NPE here. So what about using return tags.stream().anyMatch(t -> t.equalsIgnoreCase(tag));?
@dalifreire why we can't use Locale.ENGLISH right here?
this creates an extra AsciiString object.
constant?
Use the constant MINIMIZED_URL_KEYWORD
Are we comparing InputEdge vs SourceInputConfig here?
wha would it take to implement this for JPA? bit uncomfortable to have new methods only for particular type ...
throw throw method should be named as "createUnsupportedOperationException"
Does it makes sense to return a boolean here(indicating it the application had shutdown within the timeout). Returning void on a timeout doesn't convey if the application had shutdown within the timeout or not.
better to remove if if statement, just set the value, the user of the entity can than use the getUseFreemarkerTemplate function to choose to use the template of not.
and here as well.
I would prefer to have stored-procedure that does it, it would be much shorter and easier. In one update query you can poll the 'oldest sub-version' and update all the templates that the about-to-be-deleted template is their base template to be sub-versions of poll result
Let's use new CacheConfiguration<> to remove compiler warning
Put "cache-" + getName() in a local variable to avoid repetition.
the build() call is not necessary here
Should this be onReplicationPutRecord?
We don't need to use System.out.println() here. These two lines should be assertTrue("Expecting: " + expected + ", got: " + e, e.getMessage().contains(expected));.
assertNotNull() and assertEquals() in the following lines instead of assert?
I wouldn't change the default.
Inconsistent Upper and Lower case in description
You can change the 28 case to a default case, and remove this.
I know this is not from you, but can you change to use arrayList, there is no good usage of linked list.
why do we want to skip a record where all values are null? These are still valid records.
In redmine 2630.
withMillisOfSecond(0) is not necessary here if it is used above.
After discussing with @ChrisGreenaway, this condition should be inverted to use the other Lease type in the check.
would synchronized(ClientLeaseGranter.this) work instead of making a lock object?
This might as well become if (enable) since the for loop will end gracefully whether it's > 0 or not.
Use a singleton immutable empty list?
You should use notification.isTouch() instead of comparing the new/old values yourself.
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Never use FileLocation.UNKNOWN if you can help it. Here you should use location
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
Not needed.
Why aren't we passing in the fatalErrorHandler or Dispatcher::onFatalError?
I don't think we need to make it so complicated. We will not do any recovering here, so we can simply:  Log(...); // The ReleaseResourcesExplicitlyIfNeeded() can be a bit tricky. // If you want to release resources explicitly, make sure set a timeout to void unexpected hanging // Also, it is possible that it can have other unexpected behaviors // If all resources can eventually be released by the death of a process, // we are ok not to clean it explicitly ReleaseResourcesExplicitlyIfNeeded(); Runtime.getRuntime().halt(1);
Minor nit: can we change these to use "reader job service" to differentiate them from the existing logging in ReaderUpdateService?
this will not work in dev mode, should be config.setSecure(environment.acceptsProfiles(Initializer.PROFILE_LIVE ))
Can you override the Command#close() and close this client there?
We should not get into firewallType being null, it should always be set for cluster add/update. If it's null, then proper error should be raised
pls use ReplacementUtils.createSetVariableString, i.e.: ReplacementUtils.createSetVariableString(clusterVersion, cluster.getCompatibilityVersion())
if you use de-morgan on the second half of the predicate you get: iscompat() && getNetwork() != null && !isAttachedtoExternal() but isAttachedToExternal() checks for null network so you can abbreviate to: iscompat() && !isAttachedtoExternal() :)
Formatting is a bit odd in this
why do we want to skip a record where all values are null? These are still valid records.
There is private method "setUpGroup()" which create group in Vo if "vo" already exists there. Use it instead of this.
I think this can be static
return createNullBlock(outputType, positionCount);
compactValues logic appears to be missing
Throws AIOOB exception when called with index = line count.
index < arguments.size() ?
can be inlined into a single return line
Was this detected by findbugs?
please throw UnsupportedOperationException isntead
please implement asLong() method instead of Long.valueOf(id), see asGuid(id) for details.
Should these have some kind of validation, e.g., non-negative, from less than to?
Doesn't look like conditions are same.
Let's use Tuple.of()
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
What do you think about changing the return type here to the enum ArrivalFilter? Seems like a conversion always needs to be done anyway, so we might as well do it here.
This logic is not correct since it would stop at the first '\r' in "// blah \r blah \r\n".
Could the method getBlockBlobClient(String containerName, String blobName, boolean autoCreateContainer) be used here?
By default, do we expose an HTTP port that allows for any client to shut down a process? What exactly does this do? System.exit? Do we anticipate (at a minimum) requiring some sort of authentication in the future?
not needed, can't happen (don't trust your IDE on this one ;))
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
If this is not used you might want to throw an UnsupportedOperationException
This is a super nitpick but since you changed the name of this method to getProviderUrl you might as well change all the redirectUrl variables to providerUrl
So you removed final, but keep it immutable * Returns an empty list (immutable). This list is serializable.
While getClients should have no initialization.
DRY use <code>this(parameterDefinitions != null ? Arrays.asList(parameterDefinitions) : null)</code>
racey single check
I think you need to add a null check; code in SourceFile assumes content can be null
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
Sorry it seems I was wrong. It seems that indeed your previous attempt was correct. java if (t == null) { throw throwable; }
is this actually what we want? it means we will lose stacktrace information for the suppressed exception, right?
List<Throwable> list = new ArrayList<>();
getNonEntityNonCollectionRegions creates a copy of all the collections, let's lookup the other maps...
if we consistently set this.context = application.getApplicationContext() in all constructors (which this appears to do), then all other places where we call this.context.getApplicationContext() can be changed to just this.context
Changing the region should also invalidate the client like above.
Aren't there any test methods that require compatibility?
Why not java static Builder builder() {  ?
If this is always a single returned value, we should use the Single<Configuration> instead of Observable. This was introduced in some RxJava post-1.0 release. <LINK_0>
add non null validation
url should just point to regular detailed sample url (/rest/tree/sample/{id})
Not sure that this constant should be used
Is shutdownNow more appropriate (which would interrupt running tasks)?
see in Volt how to properly shutdown an executor service
I think you should dispose the ShapeRenderer here.
I'm a little bit concerned about having this legacy code here. In theory, someone could make a component called None and it would not be selectable since this would just reset it.
@jomarko Are you sure about removing that line? I remember times ago I put it there for some reason, not sure if it is still needed; anyway, the point at that time was that if ScenarioGridCell.editingMode is "true", the editing does not start. When you press "enter" or anyway end editing, the "flush" method gets invoked, and after that the cell must be editable again.
Calling copy() method here has no any effect.
None of these error cases need to post events
Same goes for this one :)
You don't need to add this exception to the signature as it is an [unchecked exception](<LINK_0> :)
Why protected ? From other side can't we declare admin in the AbstractSubscribableAmqpChannel's constructor alongside with container
if you endup locking the whole method, there's no reason to use a block, you can use synchronized on the method. Applies here and any similar method.
minor: this not required anywhere.
Redundant brackets suggestion return tryActivateAndGet(e, stack.getItem()) != null;
a workspaceitem should be returned
Well, @jglick-style violates the recommended code style
I'd probably format this to have a : before the actual digest value, just to delineate between the hash type & the value.
should version be set to latest if empty?
I would prefer to have stored-procedure that does it, it would be much shorter and easier. In one update query you can poll the 'oldest sub-version' and update all the templates that the about-to-be-deleted template is their base template to be sub-versions of poll result
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
Let's have this after the Stormpath status code in the string message (rather than separate the http status from the Stormpath status)
do you need to add CRC here?
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
not needed
Please remove the public modifier
lowercase for package names.
replce com/puppycrawl... with getPackageLocation().
Remove throws Exception
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
shouldn't it interceptSrc and remainingPath follow same pattern to intercept as they both split from src path only? Whats the issue if I use same interceptSource method? Do we have some concerns? Could you explain me if I miss something here?
valueOf -> parseInt
java authCardDetails.getAddress() .flatMap(northAmericanRegionMapper::getNorthAmericanRegionForCountry) .map(NorthAmericaRegion::getAbbreviation) .ifPresent(smartpayTemplateData::setStateOrProvince);
Minor, but could you make the height and width different? It provides a little bit of protection against the values being accidentally transposed.
If you assign this to MockHttpServletRequestBuilder we don't need to do the instanceof or casting to ConfigurableSmartRequestBuilder or Mergeable
Looks like getCMPath never throw IOException or MetaException. Shall check and remove it.
Silly nit: space around expression.
why did you remove this ?
logger says "Unsubscribing"
You can just do checkArgument(!Iterables.isEmpty(futures), ...) at the top
The orchestrator will pass down a connected client (i.e. it will have a layout ready) when it creates a workflow, why is this needed?
The position parameter is in NatTable coordinates and could be out of range in the scrollableLayer. Ideally the scrollableColumn should be underlying scrollable layer column that is already found at the specified NatTable position, so that it does change after scrolling. I think you can get it like this: Position viewportPosition = new Position(position); ViewportLayer viewportLayer = getViewportLayer(viewportPosition); if (viewportLayer == null) { throw new IllegalArgumentException("No viewport layer found at position " + position); } int scrollableColumn = viewportLayer.localToUnderlyingColumnPosition(viewportPosition.column);
should we use "this" on line to make more evident what we are doing
Should we check that the value is either positive or equal to UNKNOWN?
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
I'm a little concern about this. wouldn't be better to cache the string too?
I think it still should be the feature name here (possibly surrounded by "") for the sake of consistency, we have tried to standardise on the feature name as the "classname" see #1167.
This should be private unless there are plans to use it outside the class.
Why is the copy here necessary?
What do you think: java if (!context.getDestinationType().isInterface()) return context.getMappingEngine().createDestination(context); if (SortedMap.class.isAssignableFrom(context.getDestinationType())) return new TreeMap<Object, Object>(); return new HashMap<Object, Object>();  to reduce the deeply nested if statement. And we prefer no curly braces if there is only one statement in the if/else as our coding stye.
Make the fileInfo map immutable.
Immutable fileinfo
Added code to print an error message and exit.
Looks like the client and the member proxy implementations diverge if the maxIdleUnit is null. Client interprets maxIdle as milliseconds in this case, while MapProxySupport throws NPE. Same with ttlUnit btw. This needs null timeUnits to be passed on the interface methods though. Is this expected?
We should handle maxIdle as well
the statistics check should be out the lambda (if you want them here rather than in operations), as this is creating another CF.
nitpick ... this should be renamed to simply gammaId, it's not necessarily new.
Constants? Already used and provided by Maven API? E.g. org.apache.maven.archetype.common.Constants
return queryId
this is asking for a helper function somewhere that turns mime type in to a MediaType. Could probably even go in the MediaType enum.
Please fix the typo and add the exception as the last parameter.
We want to make sure that every request is made to the right endpoint. In this case, just add here a common assertion to verify all requests are done to "/"?
assertFalse(...);
assertFalse(...);
assertFalse(...);
It feels like there's a lot of context and state that's being managed here that would be much cleaner to delegate to a composed cacheState object (which would also make it easier to change this later more safely without requiring safely updating 5-6 implementaitons
This is already read above?
This shouldn't be nullable, should it? (not actually sure...)
unnecessary array new: {{true}, {false}} should work here
Please add ? and % as well
unnecessary new Object[], and there shouldn't be a space around the contents of an array initializer, e.g.  public Object[][] getLinearIndexFactoryTypes(){ return new Object[][] { {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed")}, {new File(TestUtils.DATA_DIR, "bed/Unigene.sample.bed.gz")} }; }
Is it really needed to create a new instance of WikiSite or couldn't you just use the one passed to this method?
This kind of breaks the really clean streak of "new Client()" calls with no arguments. Could we make it adhere to this pattern?
Totally optional: we could tighten up the code a bit by getting the boolean value for !DeviceUtil.isOnline() and then passing it in as a new param to conditionallyAddPendingClient: void conditionallyAddPendingClient(FeedClient c, boolean cond) { if (cond) pendingClients.add(c); }
There should be different ways to compare the type, based on the given type expression: 1. Check for equality with the fully qualified type name (including the namespace information) 2. If no namespace is provided in the given expression, check for equality with the type's display name 3. Check for equality with the fully qualified XML element names (including the namespace information)
Wouldn't it be better to do this in the constructor and have a final variable with it?
I don't think we use final for functions in our code base
personRepository.count()
Why singular?
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
The pattern we're using in StreamDescriptors is to have the extending classes also override the toConfig method from the base class and call super.toConfig as the first step. Might be a simpler interface for extending classes since there is one less config related interface method. If we do that, you might also not need to call addTableConfig to mutate the passed in tableConfig map in generateConfig.
Zookeeper connect is not required by new kafka AdminClient, we can remove it.
Unused?
Call the function with a single Type as input instead.
not needed; same for other readers
Seems we can just have this invoke the new maxBatchSize method and remove the BATCH_SIZE attribute. This isn't exposed afaik.
Should be "InstaPost" actually.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
If you have commons-lang3 in your classpath, you can use ToStringBuilder
better do the close in a finally block.
same question here: shouldn't labelsWidget.cleanup() be included in the generated driver.cleanup()?
move this line before above line, After super.cleanup method couldn't do any of the server requests.
Here it's OK: it really may returns an instance of anonimus implementation of ARPMH
Could you change your code so that super.getHandler() is called only once?
endHandler must be read in the synchronized block
I know we tend to always do remove/install in our code, but this is actually not needed: org.eclipse.gef.editparts.AbstractEditPart.installEditPolicy(Object, EditPolicy) will remove (and deactivate) any pre-existing policy in the role we want to install the new one.
Modifying generated code is risky. We should extend the EditParts (with a CustomDurationConstraintLinkEditPart), and instantiate these custom parts in org.eclipse.papyrus.uml.diagram.sequence.providers.CustomEditPartProvider Also, DurationObservationLinkEditPart should be modified in the same way
shouldn't you return a TypedSubAppNetowrkEditPart here?
this could easily be done when creating the repository as well.
Add If task repositories then version = "" and currentRepository =null
strings != null && strings[0] != null && qName.equals(nodeName) this check is duplicated (see previous method)
Can you move the System.getProperty calls to methods on RoboSettings? We're trying to make that a central place to hold all system properties.
It doesn't get custom strategy because of a typo. Please change fhit -> fhir.
I'm kinda ok with 1. although fully share your dislike it introducing APIs About 2. I guess I get where it's heading, but not fully understand it yet, so cannot be sure
I'm good to toggle to production!
Using the ternary operator here will result in nicer code: return phoneNumber != null ? PHONE_UTIL.format(phoneNumber, PhoneNumberFormat.E164) : null
You don't need to make a variable here since you're not using it again. You could just do <code>new PhoneNumber("21234567890").getNumber()</code> :)
nit name is null or empty
Import?
combine with assignment this.outputType = requireNonNull(type, "type is required");
You can condense this to DISPLAY.asyncExec(() -> progressBar.setVisible(visible));
One minor suggestion. Make this a private final variable, and create the runnable once. Then return the variable instead. The outcome is the same, with the advantage of not creating an object every tick.
I'd increment a counter and assert its 1.
No, no. Remove this logic (that checks whether the provider exists).
Lists.newArrayList(entity.operatorIDs))  What does operatorIDs represents?
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
> HTTP_API_VERSION [](start = 51, length = 16) also what does the http_api_version mean? :) #Pending
> APIEvent(final String eventName) { [](start = 4, length = 34) nit: new line please. #Closed
Does this also require a null check similar to setcontentType() ?
why is this not private?
Do we need any printStackTrace() here?
update metrics as before.
Should we include the label too?
Another thing I was thinking in this context is that if have pairs of state changes such as DisableDepthWriting and EnableDepthWriting we would no longer need to use getStatus at all in this line, as the class name would be enough.
Hmmmm. I just noticed this change and it isn't good: from a human perspective having the fbo id alone in the logger output is of limited use. Having the name printed out is quite important. I can imagine a couple of solution: 1. we pass the fbo's URN on construction, solely for the purpose of printing it out in the log alongside the fboId 2. we store the URN in the FBO, but I'm not sure if this is going to come and bite us in the future.
In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.
defensive copy?
wouldn't it be better to return List<File> here ?
Please check if this method really should be public in a private static final class. The parent method is protected.
I would suggest You to use Logy.d here instead, as we did it [here](<LINK_0>
I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it. I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.
Expected value should be first.
why is this true, shouldn't it be false since neither of the attributes have a kind?
The pattern we've adopted is to use ImmutableList.of. In this case you can use ImmutableSet of and then you don't need to create a LinkedHashSet.
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
Probably would be better to check on RuntimeException not on OException.
Should rename this to indicate that this is an order in this trader's position. Just makes it easier to understand at a quick glance.
can use Ds3DocSpecEmptyImpl here
There should be more assertions in these tests. We should check that the handler is attaching the file and that it is setting the correct HTTP headers and status codes.
Wouldn't SC_FORBIDDEN be more appropriate?
Should return an ImmutableSet, right?
Is this first line needed?
nit: I think you can just declare Set<LockRequest> here
As Kai already stated the mime type should not be optional.
you're testing for silence, but detect method returns true? shouldn't return false?
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
We should also be using the DEFAULT_BROWSER_ACCEPT_HEADER if we the submitted one is the empty string.
Could this potentially be shortened? return acceptHeader.length() > BROWSER_ACCEPT_MAX_LENGTH ? DEFAULT_BROWSER_ACCEPT_HEADER : acceptHeader;
Could avoid this local variable if you store fHeight inside the if clause, if you feel like it (also, this. unnecessary).
- this.ephemeralCount = new HashMap<>();
What is this method needed for? You want to create a fluent API?
Same here: should be Branding, not ProductBranding
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
We can write this code as, java ClassLoader classLoader = ServerConfigurationTest.class.getClassLoader(); return classLoader.getResourceAsStream(path);  IMO this would be more readable
please change to a class-level psf String.
use correct variable name
Think you do not need Integer here, just write <>
I advise inflating the ExpandableListView from a layout so you can apply the styling there, instead of hard-coding style values into the setListAppearance method. Then, you could get rid of the Utils.getPixelFromDips() function too.
wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?
You should use toLowerCase(Locale.ROOT) as using using "toLowerCase" by itself will use the default locale (which may lowercase incorrectly depending on the language)
Maybe specify the names in the constructor (SKIP("skip")) so that someone modifying toString() by accident won't break the parsing.
throw new IllegalArgumentException("Unknown type " + value);
Same here, you cannot create a RawType of the given data, why is this accepted without throwing an exception? Need to check other types. Is this our common handling to ignore a correct "deserialization"?
I don't think we use final for functions in our code base
I know I did not mention it in the initial review but TransactionImple.getTransaction() can do a lot of work so I think you need to cache the result in a local variable in order to avoid the second call to getTransaction.
Is it supported to resume transaction in another thread? If so, what will happen with the ThreadLocal in the TransactionImpl?
Development fragment?
I don't like how this method has to use the duplicated string. I'm not sure the check is needed but at a minimum it should probably use the isPasswordHashed() method.
This should be implemented as return createUser(email, password, null);
@wisogetnid why are you removing this block?
code format
This should stay final
given that specificity of this SV is exception type I would add the exceptionType in this.
I would add: setAlertType(AlertType.INFO); So you have a default of INFO for messages that don't specify.
should this not be a constant or something?
I don't think we want to clear out the existing styles. What if someone has defined some style classes in the ui binder file that uses this widget, this will wipe out those values.
+ NUM_HEADERS + NUM_FOOTERS;
Seriously dude, don't reformat code for no reason.
IMO it should be synchronized as well
You forgot to add the address to the toString() as you did in the patch on the master branch
@override and function declaration must be at same line.
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Can make this into a singleton as we have with UNSET.
It seems safer to synchronize this method! And all other methods return a List<...>.
For non-public methods checkWidget() is not required.
Add a null check, if it is null add a menu item or invalidate the menu. Find some way of adding the menu item back in the view
Formatting
I think lowercase l should also be considered
I would recommend an else if here to avoid comparing against a string unnecessarily.
you can simplify this with String.join(",", getSortedList())
context.getClassLoader() can return null
Suppose makes sense to convert value to lower case before comparing.
why do the values "true", "yes" and "1" equal true?
I think the attribute "create=true" should not be put in the test case, it is used the very first time to create the database.
use LOG. If you are trying to display error in the console use stderr.
It would be better to fix the indentation issues, can see in couple of places.
Let's remove that TODO: we'll get to renaming things anyway.
We discussed this already, but please remind me: update() is executed, for example, when the user resize the window. Why not to avoid any form of memory allocation in those circumstances, even if it's admittedly small in this case?
Do we need this line here? readOnlyGBufferFbo seems to be used only in update(), where it is refetched.
I don't think that is necessary.
fParent was protected. Should the getter be protected too then?
Is this related, or should this done in a separate commit?
final?
If the partition being replicated is sealed, should we reflect that here? (Not sure if we have that info available.)
Why is this not singleton?
I'll let @bstansberry review your changes as he already reviewed your PR However could you please rename this variable? WildFly code convention do not use _ to prefix variables? thanks
One thing to note here is that since shutdownProducer() requires obtaining the lock, this operation can get stuck waiting on this lock. Operations such as flush can take a while (up to 15 minutes for BMM with the current flush timeout). Once concern might be that unassignTask() is called from the onAssignmentChange() threads, right? And have a limited time of 30-60 seconds within which it needs to complete?
I'd recommend to add process id to the name as well as there might be tasks with same name in different processes but still in the same kjar
This may chain to the next (more complete) constructor instead.
Unless I'm missing something, this assignment never has any effect, because it's immediately overwritten inside the buildTree() call, so we can just remove it. Pushing this even farther: it's not at all clear to me that we even want a currentPoint instance field. Seems like it would be better to make the following changes: (1) change the buildTree overload with three arguments so that the last argument is the current point (not just its X coordinate) (2) add a P argument to setCurrentPositionFor() and pass the current point to it That way we don't need this piece of class-level state at all, which seems like a better/more robust design.
Since the event is really a resource rather than a model, it would make sense to me for this to return the event resource instead. You can get back to the model in other places if needed by calling .getModel() on the resource.
Please no System.out.* calls. Thank you!
if (realm != null) maybe - just to be safe.
Since these are run as tasks, do we also want to add the check to confirm the context is still active?
t should be e
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
couldn't / shouldn't getTenantAsString return the uniqueName instead? As we use it everywhere in the TenantUserManager
We can populate this in TenantManager level?
I just sync'ed up with @pierre and this is is fine -- seems like this is already the model we have in place for other resources.
use parquet.Ints.checkedCast or you could get a negative value out of this cast. <LINK_0>
here too can drop the this for parquetWriteProtoCol and configuration.
Minor: unnecessary log?
Unnecessary (and incompatible); revert.
wold prefer a startsWith("+$") here because otherwise its far too unspecific. (Think about values which can validly contain + characters) Even better, use a regexp ^\+\$\{.*\}$. This would really only match our use case.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
throw UncheckedIOException(e)?
Add message to new RuntimeException
M-m-m. Can't we simplify the life for Jackson and for client afterward and return null here if properties is empty? I'm sure that we will add eventually more and more here, but there may be some cases when it is still empty.
Is this really needed? I mean I believe the idea here was that getProperties returns an unmodifiable map, while getMutableProperies returns the actual mutable map. Is there a problem with this?
usually data objects never return null where collections is met
I guess the connectionInterface cannot be null, so we should throw a NullPointerException if this occurs.
Just a cosmetic thing here. I think its great to have encapsulated methods (removeContentOverride, setContentOverrides, addContentOverride). Having those methods I would use unmodifiable collection when returning getContentOverrides so that clients cannot accidently modify the contentOverrides collection directly:  public Collection<AKContentOverride> getContentOverrides() { return Collections.unmodifiableCollection(this.contentOverrides); }  The same goes for the values() sets that are being returned for fields: pools, products
Why not use null instead of ""?
It's better to log a message no matter compression is enabled or not, it's always easier to search the existence for a message than to find what's missing from thousands of lines.
I don't know that we need 2 generation id fields; I'm concerned that by reading the createdGenerationId field from the PBD we might make the wrong decisions about it. IMO the authority for the 'created' generation id should be a) the current catalog version when creating a new EDS b) the value from the snapshot (that value should be communicated via the truncate call)
You can do this::deleteOldSegments for the callable. It is more efficient lambda form
BlockPos.ORIGIN
this is a confusing method. why do we are about the last position ? what does that mean? Seems like you would only ever care about is the current position (as provided by the encoder)
please fix the string formatting here. this is wrong.
This should go before this.starts.next() as if this.starts.next() is empty, it will throw FastNoSuchElementException and the previous iterator would not have been closed.
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Don't use variable names that are abbreviations or misspellings... optimize for readability rather than writability
nit: since bookie is not final, there can be possibility bookie is null if these methods are not called in correct order. can we add final modifier to bookie field?
We can do disruptor().setDefaultHandler().handleExceptionsWith(), so, maybe, not "mixing", but something like "callToDefaultExceptionHandler is not supported and useless after exceptionHandler has overridden by EventHandler specific ExceptionHandler using handleExceptionWith()"
s/install/enable/ (since there is an install command)
remote plugin administration
Rename to getCommitMessage
This appears in RawByteBitwiseOperationsCheck.isSecuringByte method, could you move both to a common method in LiteralUtils?
You should call super.visitReturnStatement(returnStatement) before leaving the method, or you won't catch cases such as :  Optional<String> s = getValue(); return (s != null) ? optional.isEmpty() : s; // Noncompliant, the null check on s is wrong!
you can most probably avoid collecting (and thus flatmapping) by relying on Stream.concat and Stream.empty and then collect on the resulting call.
What about data type here?
You could use functional style expression like: suggestion return node.orElse(null);
checking for nullable parent was added specially, cause going into project node simply has no meaning
exiting, so STDERR
exiting, so STDERR
The conversion to OsmosisRuntimeExceptions should happen in the task itself, not in the helper class (as someone might use that helper class in an unrelated context).
... yes it does ...
Isn't nextInt(0, n) the same as nextInt(n)?
drop the + 1 here, and use < instead of <= ?
Lowering should be set to true here, so that the elevator isn't holding up unnecessary weight
You should use .test().assertResult(1); instead of just subscribing blindly.
You should use .test().assertResult(1); instead.
I think I prefer "Invalid key" as exception message
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
What does it mean here to decorate it with Nullable while null is actually not allowed in the following line?
Why don't we retrieve the same label provider as for the image? Here we use the constant whereas for the image we use the object, I don't get it. Also, I need a null check would be useful.
This makes it possible for cacheManager to be null. References to cacheManager presume non-nullness.
hmm, do you test the rest service for update? What about if you try to update a given provider (without to change the name)?
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
Is it really good to create and destroy server and client for each test-method?
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
What would you opinion be as to introducing a snowflake ID as opposed to random? <LINK_0>
I'd be tempted to make this class level. In addition, do we need apply <LINK_0> or recommend users do?
Check if inputStream is null.
Please revert this formatting changes
It would also be useful to have the column separator character inside a column text and check that it also gets escaped.
NetworkStackClient alreay dump ConnectivityModuleConnector. Do we really need to dump it again? <LINK_0>"ConnectivityModuleConnector.getInstance().dump"&sq=package:aosp-master&g=0&l=331
Same here and above.
Same here and above.
Same here and above.
this function can be private
minor typo: SEPARATOR
this function can be private
use Long.valueOf() instead of new Long() - always for performance reasons
use Long.valueOf() instead of new Long() - always for performance reasons
use 'L'
Is blocking, should be on a AsyncTask
projectListFragment is always set, no null check needed Please remove log output
I would probably drop the calculation, at least the Math.ceil() call.
Honestly I cannot remember the exact reason why I make this so permissive but I know he has something to do with the GeoServer integration: <LINK_0>
I know @davidjgonzalez suggested to change this from debug to info, but I'm questioning that suggestion :) Doesn't the auth checker servlet get called on every request to dispatcher? If so, this will be quite noisy.
Shall we define a log object for this.
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
right. However would that be an internal name? Maybe not, and this should be done before calling this method, so that it receives a valid internal name
not even e.getMessage() ?
This should be handled by the nodeDelete return value, so we don't need this catch.
I would rather have another internal method that does what's in lines 398 to 400 and back in 406 to 407 but indeed takes the ClientState instead of looking it up - and being racy indeed.
static
- this should delegate to call two functions above. - also, here name would be a bit confusing from displayName. Maybe @rongrong could provide suggestion.
"not" function is already available in StandardFunctionResolution. But I don't mind having it here given it's a test.
StringPool.EMPTY instead
search for references to FilteredTree.initialText then you'll see that some inner classes of FilteredTree have special treatment for the case that the filter field contains the initialText changing this to if (!filterText.getText().equals(initialText) && filterString.indexOf("*") != 0 //$NON-NLS-1$ && filterString.indexOf("?") != 0 //$NON-NLS-1$ && filterString.indexOf(".") != 0) {//$NON-NLS-1$ fixes the problem that while initialText is displayed no result list is shown.
Again, SlingFilterScope enum.
probably this is an exceptional situation
Can you explain why protected field access are expose via public methods ? Do not change access modifiers without understanding its purpose.
Does this also require a null check similar to setcontentType() ?
why public? Are we planning to use it outside of this class?
this method checks among other checks if domain is active, which is not exactly an image validation. Please consider renaming the method.
If you have a parameter, caching the validator doesn't make sense - the API seems as though you can pass a DiskImage and get a validator for it, when in practice you'll get the same validator regardless of the param.
and here ;) string concatenation would we preferable.
Sorry if I'm being picky, but you can just call getClass() (without 'this.')
This implementation does not seem useful, as there may be dozens of those. I would print the number of events and that's it.
Why empty? It supports ALL streams!
Why new message stream instead of returning 'this'?
Are these < 120 chars? Prefer older formatting (i.e. opId get call on its own line) for consistency.
throws
throws
throws
It could be - can you create a short script to show the issue and open an issue against the repo that contains it?
This should be in a separate cleanup function with the After tag, so it still runs of the test fails.
Great - should this be deleted at some point as these tests run many times / day?
NAME -> HIGHLIGHT_CTX_DATA
To better simulate a failure with incomplete content I would rather do jg.writeFieldName("justfieldname"); jg.flush() so that we're sure the result is invalid.
Not sure, but maybe it can be injected instead of being looked up? (Same for other services in this class.)
this constructor can be package protected if it supposed to be used for test only
here, extent must be an integer.
here, extent must be an integer.
There are enough mock objects in here that it's worth using @Mock annotations instead.
Remove the this.
asRuntime(getRuntime()) doesn't seem very clear to me. Maybe asRuntime(getInternalRuntime())?
return flagdown; ?
simplify this
Getter please? If not needed externally, at least make a private one.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
s.a.
return tags;
Just an FYI, we have a fairly robust date parser included in EndpointUtil because of variability we've encountered in the past <LINK_0>
Just an observation... might it be more cool to return Collections.emptySet()?... if we have the option to reduce null usage we should do so... imho helps in the long run... but - I may be wrong...
This seems like way too generic of a place to put this validation. What use case are you trying to catch with this.
Should we have a constant for this?
We prefer the default specified in the properties file.
Boolean.parseBoolen(), twice
This makes the countQuery required and will break exiting users. Why is it required? You don't check for notNull, but than pass it on to sanitize, which doesn't do a null check.
static import ?
please be aware that we never used those before, so it can be high chance that those does not work as expected
you're testing for silence, but detect method returns true? shouldn't return false?
this variable name is misleading, it contains not only the commandData but also Ne field (see also other ApduTest classes)
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
This call will lead to an NPE if no thing type is found for the thing.
Hm, my understanding has been that the base implementation should look like: Java if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); }
Doing the refactoring of the OH2 bindings, this default implementation does not appear to be helpful. In most cases, the Thing is simply expected to go ONLINE once the bridge is ONLINE. This means that this method needs to be overwritten, so the question arises if super. bridgeStatusChanged() should be called at all or if the logic isn't reimplemented. Both variants are not really nice. I think we should change this line to ThingStatus.ONLINE as this will be the expected behavior in most cases. Whoever needs something else, should override the default impl. @sbussweiler WDYT?
Revert this line?
change to interface List
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
Package private should always be enough for testing. Use the same package for tests.
Why : is in brackets? Why you only check capitals, you sure drive letter cannot be lowercase? I think windows case insensitive so it could be if user typed lowercase.
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
I don't think we use final for functions in our code base
Isn't this the part for which we added a breaking changes entry in master?
remove
DRY: would use this(username, password, null) instead
Minor: Ideally we should avoid doing work in the constructor. Pas apiRooUrl and Client to the constructor, and provide a factory method receiving apiRootUrl, username and password and creating the constructor dependencies.
Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true?
This seems a bit profligate... and the stream construction around a spliterator seems a bit unusual.
I would not do that change. Leave terracotta there.
Let's move this ternary inside PlatformLruCache as it's an implementation detail of that type.
why are we casting to "int" ? it the value is a "long" we must return a "long" or we have to handle the overflow some way
nit: you don't need to specify this. There is no other variable declared in this scope with the same name.
If this condition is considered as an error, shouldn't the execution be terminated after printing the error?
Maybe wrap it with unmodifiable container?
Do we want this in master?
new String() is redundant.
this should probably fail on receiving interrupt
"expection" -> "exception"
can be !isDisabled()
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
since this happens before canDoAction, getVdsGroup() can be null
why did this one change?
as an optimization; There are two public methods in the parent class (fromJsonString and toJsonString). as fromJsonString is the only to instantiate, you could cache the json value and return the same in the toJsonString
i would _really_ prefer a single return path. I find multiple return paths inside nests quite confusing. Unless the alternate (single return path) is really complicated, would prefer that.
Why is this the case?
would it be better to throw an UnsupportedOperationException rather than return something that won't work?
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
Collections.emptyList.
This should invoke the other constructor so that taskData can be marked as final.
We probably should be defensive here and confirm that there is a TaskConfigurer that exists in the first place given BeanFactory#getBean throws an exception if it isn't there...
It is still public. Why?
What if the specified custom bond mode has more than one digit? You should read the whole number till the next space after the "mode=".
This should be synchronized.
Maybe just return map.computeIfAbsent(x->create())?
getQualifiedName() ?
I'd return suggestedId for the time being, but if you have reasons to keep it this way for the time being I'd be ok with it.
no need for concurrent
nit, Collections.EMPTY_MAP?
again I think you can use the diamond operator
Not necessary
Not necessary.
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
Shouldn't we switch on the id of the ListView, rather than checking whether or not the list exists?
you have already got listView as parameter, so no need to call "getListView()"
Maybe it would be better to set the ComingSoonFragment as default case. So that we only switch to the shipping fragments :)
It seems this variable is not used, can it be deleted?
@darfink shouldn't this line be GerritEventType.WIP_STATE_CHANGED?
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
Can you use EntityType.getEnum inside this method? This method will be pretty much similar to AbstractSchedulableEntityManager.checkSchedulableEntity, except, the exception may be different.
findFirst(".event .btn-see-event-info")
Don't use stream apis please
Something wrong is here: ![wrong_object_to_remove](<LINK_0> this.inUseConsumerChannels.remove(consumer.getChannel()); ?
Again, being pedantic, but if we're checking, it might as well be consumer < 0 || consumer >= numProducers)
We'll need the second usage of consumer.getId() replaced with consumer.getUuid() as well.
All of these early returns you do like this need to be switched to if (!=null)'s 1) it's cleaner and 2) it makes code easier to understand and 3) it makes future expansion easier without need to refactor these two lines. Not to mention all you single line ifs need to be converted into two lined one minus the braces.
Shouldn't this be  canHarvestBlock(player, state):  ?
I'd argue we should change it to use the two contains checks on the tags that vanilla always did, and move remove the check from the original method, so you can override this to false even if it is in the fences or wall tags. Just to give it even more flexibility...
You'll want to use .setText("and 1 damage to each creature that player controls") here.
These effects need their text changed as well
You should use .setText("and gains trample until end of turn"), otherwise the text is gonna be all wrong
add requireNonNull for parameters.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
I don't think we use final for functions in our code base
Is this stray? Or do you actually set it to test?
is there a reason why this method isn't implemented?
Does this really work? That validate method i think expects non hashed passwords, probably you shouldn't validate this, the ticket says changePassword methods. I also think these should delegate to the changePassword method that validates the password to centralize the code
Should be added the Override annotation.
super.init() method never throw an exception.
Overdid - setUp("redis")
why do we need this new method?
That is incorrect, in case the logger and eventAdmin is null we get a NPE
Move return true; out of if/else block to make it clearer that it isn't a typo to return true in either case (if it's not a typo).
@yesamer Please use the *showCheck* method - otherwise we have two paths for the same behavior
this will crash on non UI thread. Please simply use Display.getCurrent != null.
You can use Display.DEFAULT_DISPLAY directly (and remove getDefaultDisplayId)
Same code as in the method above, factor it out?
Throw it; we want to fail fast rather than wait for auth failures talking to the far end.
The scmConfigurations list can be null. Is not handled. Any reason? It was handled earlier, in places (for instance, here [metadata == null](<LINK_0>
looks like the variable name also needs an update in some of these methods
Core.ID
The name of the MetacardType could also be null in this case.
add brackets around if the clause or move on to same line.
Why public? I don't see any external calls in this PR.
and add should return a new BlockLocator
The image attribute is not supposed to be the text of the node. I'd rather keep it separate (the previous @Text attribute was fine). A practical reason for that is in the future, other languages may have a way to get the text of their node, in which case that wouldn't be fetched with getImage, for compatibility, but probably with a getText method, or getSourceCode like in #1728. Also we *may* deprecate or otherwise put getImage out of use as soon as 7.0, given its contract is super loose.
I think it's better to do the escaping at the point where the message is going to be converted to HTML. If not maybe rename this message to getTextAsHtml.
autotranslate?
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
Let's not include the %n  header here.
If this is intrinsic, needs to be prefixed.
FIXME: Don't cast getActivity(), use an interface.
You don't need the variable here. You could directly return inflater.inflate(fragmentResource, container, false)
(ListView)  can be removed
Explicit type argument can be replaced with <>.
CopyOnWriteArrayList would be a better alternative as it provides optimized functionality for thread-safety and good for maintaining list of listeners that will be updated occasionally
Well, "user.dir" is not set on all platforms. Better to use null, as used in ProcessBuilder.
@Override
This should also flag whether the binary is reused.
Let's please avoid code duplication:  public String toString(boolean shortenTypes) { String type = getType(); if (shortenTypes) { type = shorten(type); } return getName() + ": " + type + " = " + getValue(); } @Override public String toString() { return toString(false); }
maybe just call this.addUpdateTask(operation, key, "") and remove the overload in BoxMetadataUpdateTask
initRepository() needs to be called here too.
Should we return here?
The ParameterService has a version of the getParameterValueAsBoolean() method that accepts a default Boolean value as input, which will be returned if the parameter value could not be found. If you can modify this code to use that particular method, then you don't need the manual null-value checks below.
Another area where Boolean unboxing may not be needed.
just need log.warn("msg {}", ex.getLocalizedMessage(),ex);
Why do we need the scheduler address? It should come from the Hadoop configuration.
Not completely sure, but I think the earlier call to super.getOptions(); may already add a profile option.
Probably better to name the option "o", to be consistent with other offline commands. For example, that is what [CreateTableCommand](<LINK_0> uses in 2.X
Could you please make this an extra bit more specific like -SNAPSHOT? Thanks! :)
It is not enough to judge empty. You should also judge the value > 2.7.0
Can't you use just address.getPort()?
this (also below)
Why can't this take the display from the instantiating class, the CPD? You can't use Display.getDefault() in the workbench, it doesn't always return the correct value.
Both addFilterBefore() and addFilterAfter() call the addFilter() method to add the filter which also does a pre-check before adding. However, the new addFilterAt() method directly puts the filter in the filters member variable avoiding the extra check in addFilter(). Although the first call to comparitor.registerAt() (if it succeeds) would ensure that the addFilter check will succeed too. So the current implementation would work the same way. But it's not consistent with the other 2 methods of adding. Is there a reasoning behind this that I'm not seeing?
validation? channel count must be > 0.
The this. is not needed now I guess :wink:
Again, you can get rid of the this. here I guess.
![CRITICAL](<LINK_1> Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
Should be immutable by making a copy.
Yes, we rely on the I18nProviderImpl to be present and running. Not nice, I agree.
We can get rid of the above variable
What happens, if the onsetDate is null?
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Should use the log, maybe a warning.
I used to do this a lot, but now i don't think it is right to unwrap. <LINK_0>
This is using the regular Java reflection API, you need to use the [Libgdx reflection API](<LINK_1>, otherwise you will break the GWT backend. I already did [this](<LINK_0> in the serialization branch, you can just copy it.
This could be refactored into a single return statement easily.
Formatting looks odd...
I'd add an isLocal() method to the StorageType enum and have this return getStorageType.isLocal()
![INFO](<LINK_1> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_2>](<LINK_0>
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
This should return the PDataType for an element of the array
I think it is not guaranteed that changes to slot are visible within the bulkChecker which uses the mainThreadExecutor to run since the used Set implementation is not thread safe.
Try String.format() function, it's cleaner than concatenation
Missing opening "(" before getDescription().
this is not good, you've removed the information from the nested exception! :)
change
Hrmm... I understand why this was changed and what the issue was (ID generation is only done on persist), but this isn't correct either -- the implication is the default state is "queued," and we're creating by default; neither of which sits well with me. At the very least, we should move this down to the try block with all the message sending.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
You can create a constant to include the "http://" string and named as **HTTP_SCHEME** for instance.
Consider capturing DAO layer exceptions and creating the corresponding service layer exceptions, to abstract away the persistence layer from servlets.
Is it always a child project? In the commit message you talk about sub-projects, so the terminology might be a bit confusing, and it does not specify that the new project will become child projects (i.e. do they inherit from the existing project?)
Variable api is unused.
Pull this into a static final variable
should this count be parameterized?
nit: add a new line before and after the constructor
This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be "<LINK_0>" while Keycloak is listening on "<LINK_1>".
suggestion @VisibleForTesting static URI createAnnouncementLocation(URI baseUri, String nodeId)
There's no point to else here...
The warning message and the other one is very detailed and more related to transmission of activities. I do not know if it is helpful to mention a sender in the message as these are utility methods. Furthermore even if you see the message in the log file it is not very helpful at all as it does not include the path and you also do not know in what context it did happen (I guess it is the XStream Marshaller when converting activities)
Did we want to have this normalize the path also by returning the normalized version from Path?
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
In my opinion, all properties on VoiceStepOtion class should be set with test values. In the unit tests, all of them should be checked with the assertion.
That's a change of semantics, it doesn't ignore the case anymore.
Please reformat whole methidusing project formatter
this should be in the doPopulate() not in deprecatedPopulate()
You don't want to freeLock() before that operation? Maybe you should also change status of template at DB to lock? Global transaction?
you should be addressing here a isFiltered() flow (as being done in the vm.update())
But we have already clicked the button in the command before, haven't it?
It's hard to understand test scenario here. Please, divide separate steps by empty rows.
this method could by replaced by the command: javascript private static final Map<String, Boolean> EXPECTED_INSTALLERS = ImmutableMap.<String, Boolean>builder() .put("C# language server", false) .put("Exec", false) .put("File sync", false) .put("Git credentials", false) .put("JSON language server", false) .put("PHP language server", false) .put("Python language server", false) .put("Simple Test language server", false) .put("SSH", false) .put("Terminal", true) .put("TypeScript language server", false) .put("Yaml language server", false) .build();
Use one pattern consistently: Either model all sync calls as asyncCall.get() or Model all aysnc-calls as sync call + CompletableFuture.completedFuture(null) I'd prefer making async the more general API and expressing the sync-variant in terms of the async one
!keys.isEmpty()?
While you are here, fix this line to do something sensible:  JsonObject e = new JsonObject(); e.add("keys", getKeyAsJsonElement(keys)); this.allDocsKeys = gson.toJson(e);
Use type ChargeDTO in return responseEntity instead of ?
not sure why this has been added?
Error message can be inserted with translations:  Helper.setErrorMessage(ERROR_LOADING_ONE, new Object[] {ObjectType.PROCESS.getTranslationSingular(), id }, logger, e);
This should be only created by the Guice injector. Make the constructor protected.
This method is a good idea! I know I'm nitpicking, but may I suggest to skip the contains() call and just do a get() and if null, then return defaultValue? This will skip at least one MultiMap call.
Why not public access?
delegate=true style would be just fine.
It's common to throw AssertionError() for these cases, since they should legitimately be impossible.
Change where you have: " forced=" + forced to be (forced ? " forced" : "")
use a dedicated method hasParameter(tree)
You can probably stop at METHOD level as well. If you reach a CLASS or a METHOD, before an ASSIGNMENT or a VARIABLE, it can not be stored in a static final field. Now, you may also want to group the KINDs you target by category for consistency (CLASS and METHOD are failing stop conditions, ASSIGNMENT and VARIABLE allows you to investigate further)
I would make explicit tests for every kind (or switch) and have overloaded method for those. That will make classCast less likely to happen. Here there is a lot of implicit going on. Let's make thing explicit. checkIfUnknown(MethodInvocationTree ) checkIfUnknown(NewClasstree )
always linked hash map please
no need for concurrent
Should this variable name be updated as well?
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
I'm not sure we can consider angle-bracketed alleles to be INDELs any more. For instance, in the RS release VCF report we are going to write <156_DEL_BP> and consider that a SEQUENCE_ALTERATION.
I would suggest to change for  filters.add(new VariantRepositoryTypeFilter(Collections.singletonList(variantType)));  If you do that you will need to include the import java.util.Collections; The same applies for withAlternates and withReferenceBases
Log as _error_ or _warn_?
Is this a reason to have separate if statement instead of while (!shutdown)?
get body and check if has class "mainpage"
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Again, use IOUtils.
shouldnt this be cachedMessageProducer ?
Is there a reason to have this setter instead of using a randomly assigned uuid and having the RollingOperation constructor check not null on it? We use this in some tests, but I don't see us testing the Id itself (and we shouldn't, I think).
Missing StringUtils.isNotNullOrEmpty() check
these setters should not be public
Please extract this string
I'm not sure info is the correct log level. Is this something we ever expect to happen? If not, let's use warning level, otherwise let's use debug level.
nice catch, I just recently wondered about our handling of singleTop
Returning isAuthRequired by default sounds gold to me.
What is purpose of this method?
This should return false if the method is declared with the default keyword or is static
You may use here listContainers(KieContainerResourceFilter containerFilter) to retrieve just containers with specific release id.
This is nice to see. We should have done this to begin with.
should we put this block behind the AM-HA config?
For loop?
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
For each?
Please use Singleton annotation and remove this explicit binding. We plan to remove existing such usage pattern.
List<Blob> blobs = Collections.singletonList(new AsyncBlob(key))
Hmm...will this allow all the files to render correctly? Don't we need to preserve content types?
You should change the error message here to be about AWS rather than GCR.
This variable be called refreshTokenID?
Even if it wasn't in this commti I think e should be consistent regarding the logging.
should move this to a finally block I think
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
i really do not like that getConsoleText() may throw WaitTimeoutExpiredException. I would expect that it will return text or null if there is none. WDYT ?
WTF is lala
On rebase, please wrap the 'return' statement with curly braces and format the lines (i.e. a white-space is missing after the 'if').
You should probably test with both pessimistic and optimistic transactions, and pessimistic with both RC and RR isolation levels. Also multi-node tests can reveal more issues than single-node ones, I think (testing both owner and non-owner variant).
Think this was supposed to be storage.
And these constructors are disappearing in 6.0...
I think it would be suitable if some kind of padding is applied between messages, such as a newline
suggestion getPlayer().spigot().sendMessage(ComponentSerializer.parse(message));
Missing some check not nulls.
@v-stepanov isn't it changing the behavior? Before this change we used to log 102 but now it's not clear if the status in the response is going to be 102. I think this is a special log for calls to consumption API where we only know the real response status code afterwards.
if rolesAllowed is null, doesn't that make denyAll effectively true?
I'm not understanding the logic here. If isHTTPSForwardedProtoResolver returns true, why would we want SecureForwardedProtoAwareResolver to return false?
Can be inlined in the assertThat statement below.
Sorry, being picky: return StringUtils.isNotBlank(version) && version.contains("SNAPSHOT");
I made this change because the GlobalStorageStatus.getServerVersion() method is annotated with @CheckForNull and I got an issue, that's why I added the check. So we can just ignore the issue ?
Why this change?
put each argument in separate line
this method seems to have some duplicate tests; to make it easier to read, consider creating a map between a pair of WKT shapes and a boolean indicating whether shape 1 contains shape 2, then loop over the map to test whether ST_Contains returns expected results; this way it will be easier to see which portion of the test matrix is covered and which is not and whether there are any duplicate tests.
Should use the log, maybe a warning.
Hm, you got java doc on the next method, but not here?
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
This can be refactored to m_isTable = "true".equalsIgnoreCase(table)
This whole method could be replaced with return !Boolean.parseBoolean(env.get("TWILIO_DISABLE_DB_SSL"));
minor: this not required anywhere.
please add specific error message for nic plug actions which specifies the valid statues for this action.
StringUtils.isEmpty ?
why super.canDoAction() is called if the parent command is always restart and this canDoAction already run for it?
Why not make al these Calculate classes private to the method? Creating new ones everytime is a bit useless
Why only return count for m_wrapper? Don't you need add the count for all the wrap in m_bundles? This also works for class-based importers, (i.e. socket importer), right?
no need to check for null because it uses ignite.getOrCreateCache(cacheName); Is there ignite.getCache(cacheName); that won't create if there is no need ?
Can this be null?
Why do we register onDestroy?
Can you have an @After method that unbinds this connection. This is more reliable.
check notNull?
You added this to the ctor's signature, but forgot to save it in a data member.
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
I believe this can be package protected. If so, please make it package protected.
Any reason to not make this return Path? It's new API.
I think it would be better to have a private static class instead.
Please avoid the use of too complex locators. Please use constants.
Suggest to consider replacing **WaitUtils.sleepQuietly** on **TestWebElementRenderChecker.waitElementIsRendered**.
Could you add more information about this log: logging.info(String.format("Sitting capabilities for current browser - %s", getCurrentWebDriver().toString()));
I think you need to call setSize instead, which does things like updating the bounding box.
So... is this right? When vanish is false, the entity in question should unquestionably be collidable. I'm a little worried that we're getting into a spiderweb here where we have a bridge method named one thing and the key named the other. One school of thought is setting VANISH_IGNORES_COLLISION and VANISH_PREVENTS_TARGETING to true should not be cleared by setting VANISH to false. That feels largely expected and I err on the side of agreeing with that. I'm thus not against this change myself, but we need to make other changes to insulate ourselves against other issues. However, I know this is in impl, but bridge$setUncollideable and bridge$setUntargetable should really be named better to indicate that they are on vanish only. Their representive is methods should then be renamed similarly AND include a vanish check within their bodies. I'd rather check one method for collisions, rather than tacking on a vanish check everywhere too because it's not obvious that's what needs to happen. If we want/need separate non-vanish uncollidable/targetting states then we need to think about that more, because we now need to think about how this will work with the vanish based states.
Extract the string to NbtDataUtil please.
Unsure this addition is useful.
:+1: I prefer just using this form over the other string().toString(). Do you plan to do that with the other Domain classes as well?
Can we just call getClass(), so when this gets invariably copied later, that it will do the right thing? Here and the others also.
We'd better fail here instead of silently returning null?
One more thing, if we consider the part between the [] to be the event name (that an eventual UST-JUL-TC parser could eventually even interpret as the event name (and same thing with fields, everything separated by '=' could be assigned to a fieldname+value)) then we should use a consistent naming pattern. UST events usually use names_with_underscores, but that's very C-ish. Since we're in Java, should we use CapitalziedCamelCase for event names?
not a field
Isn't this equivalent to the below? java final GridColumn<?> uiColumn = newRuleNameColumn(makeHeaderMetaData(column), Math.max(column.getWidth(), 150), true, true, access, gridWidget); uiColumn.setMovable(false); uiColumn.setFloatable(true); uiColumn.setVisible(!column.isHideColumn()); uiColumn.setMinimumWidth(150.0); return uiColumn;  We could declare 150 as class constant if answer is yes.
rename to column
Why not simply "100px" as String? (100 is a constant here.) This <number> + <unitType> concatenation is unnecessarily complex, I think. This applies to other such occurences as well.
Change to: include = true; (@jessehatfield, @meiercaleb) Or should we have a config option for each restriction? (i.e. conf.isInferHasSelf()) It appears that some visitors do have a unique config option while some don't.
nit: Could be this.conf = requireNonNull(conf);
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
We should give a better clue here what they did wrong, but I don't have the verbiage off the top of my head. README will need updating too.
This and the above method basically do the same just for different types. Could be extracted.
tracef?
Note you can put these on one line: this.httpRequest = checkNotNull(httpRequest); This can improve readability when there are several arguments (and helps you spot unchecked arguments).
Let's do just one more tweak here. I understand that you need this check in order for anyMatcher to work correctly, however the current solution will break this scenario: java .anyMatcher() .requestMatchers(AnyRequestMatcher.INSTANCE)  While it would be odd for a user to do this, we want to be consistent in our behavior. Since java .anyMatcher() .anyMatcher()  is disallowed, so should the earlier one also be disallowed. It would also break here: java .anyMatcher() .requestMatchers(AnyRequestMatcher.INSTANCE, new UrlPathRequestMatcher("/path"))  I believe the answer lies in adjusting the anyRequest method implementation. If we don't set anyRequestConfigured until it is actually configured, then I believe the extra if check here is unnecessary: java public C anyRequest() { Assert.state(!this.anyRequestConfigured, "Can't configure anyRequest after itself"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; }
wrong casting
Use Uri.Builder
Flo will probably tell you to remove this extra line :D
StringBuilder, or Joiner.on(" ")... something
can we please use {} for this if condition ?
Why caps EXPECTED and ACTUAL here?
You could use IsIterableContainingInAnyOrder.containsInAnyOrder instead.
This needs to choose the target when the ability triggers, not when it resolves. I'd use adjustTargets to do this.
Must be ANY, not YOU (At the beginning of each end step)
this doesn't need to have the ability and effect both be optional, just the ability is fine.
hell no
should rather be named currentContextClassloader
I would prefer do not fallback to the getClass().getClassLoader(). The Assert.state() in this method should be great compromise.
Can you mark this @Nullable please?
Why not using "getNewMacPoolId()" in getPermissionCheckSubjects as well (please notice there is also a null check- 'getParameters().getStoragePool() == null', please add it here as well).
Same here not thread safe, use read write locks
shouldn't you convert the logType.getDuplicateEventsIntervalV value to millis?
can you please also change logType.getDuplicateEventsIntervalValue() to duplicateEventsIntrvalValue
not related.
This should check the environment variable before returning true.
Check env variable before returning true.
Check the env variable before returning true.
Why? This was here for a reason etc.
For ignored exceptions I prefer the variable name ignore (so we know it is by design).
I think there is a good chance there is an existing bug here. I think it is wrong to try to get an ArjunaCore TransactionImple here, it should be a JTS one and could be a copy/paste error here: <LINK_0> what do you think @mmusgrov
Do you have a test that peeks the next sequence number?
Instead of asserting the number of events, I would try to assert that the messages I expect came back. (ie. message 1 and message 2)
Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.
not List<T>? :-)
List#sort usage.
Unmodifiable if possible
This method can give an incorrect result if the last buffer is moved from the inner queue (which is then empty) to the output buffer (which was previously empty) in between those two calls.
Same here, add deprecation flag.
I think super implementation is correct (size == 0). Nulls are still considered part of the list, they just take no memory in internal structure.
the name of this method is not clear (pun not intended...) because the word 'clear' is usually used when some collection is being emptied. actually looking at the code in the clearAttachments, you are computing the attachments to remove. this makes sense, and is also consistent with the row above 'bondsToRemove.add' but is obscured by the name of clearAttachments. secondly, the last line in the clearAttachments() method is not dependent on the id that is being passed to it. so this line should not be there. it should be here below line 60. then you can rename clearAttachments to calcDestAttachmentsToRemove. this would make the flow symetric, consistent, readable.
(not only) my opinion, (but) feel free to ignore. Assertions does not work at runtime. After optimizing, you will endup with some NPE without any explanation. It's better to throw exception using for example: java.util.Objects#requireNonNull(T, java.lang.String) This construct overpower assertions in every way. Assertions only benefit is cool looking keyword.
you can use attachmentIds.stream().map()....collect(Guavate.toImmutableList()) to produce an immutable list. Without using the builder.
Unchecked cast in the old code?
I am just wondering: what happens if this sql command does not complete and throws an exception? The system will be in an inconsistent state of having submitted the flow, but not having it registered in the DB (and not be in the RunningFlows map, etc). Should we handle this scenario?
May be its safer to assert that it exists before and then assert that is doesn't after delete.
is it necessary to encode duration iso standard?
Move the jsonGenerator.startObject() method call here, so the subclasses aren't responsible for creating this. It is confusing this way.
ZoneOffset.UTC or similar cannot be used, in order to make it more readable?
let's update all the includeTextDetails references to includeTextContent
validateBlankPdfResultData() is this method is only specific to Receipt result lets update it to validateBlankReceiptResult() ?
if recognize from url, shouldn't content-type be application/json?
This is not required. Instead of generating content uri here, simply pass it to UploadItem from UploadableFile.
Tighten it up, delete line breaks.
do we really want such value here?
The pattern is to have the init before the try: AdminClient client = AdminClient.create(getDefaultAdminProperties()); try { ... } finally { client.close(); // no need to check for null if the factory never returns null } But if AdminClient is AutoCloseable you can just use try-with-resources.
the client could be null
isDebugEnabled
lambda
I don't think you need this condition. TranslatorUtils.toDBObjectList will return an emptylist if the key isn't set, which should then be fine.
Need to ensure ordering, per our conversation re. hashcodes :)
Could you replace the magic number 128 by a constant?
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
![MINOR](<LINK_1> Make "getKeySize" a "static" method. [![rule](<LINK_2>](<LINK_0>
What I'm missing here is the check if the element is null. I know that the probability is very low, but still...
I think we should use HashUtil.combineHashCodes(definition.hashCode()), WDYT?
I would use the canonical name here, to avoid having two classes marked as equal but have a different hashCode
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 89-90. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 118-119. Do the same for the others.
acquisition of all locks should always come outside (just before) entering the try-catch. Because if something goes wrong, the finally block is going to try to unlock a lock you have not acquired. So swap lines 247-248. Do the same for the others.
this class doesn't have tests?
Can we remove this?
nit: this can be reused in other places, like ChannelStateSerializerImplTest#getData(int len), ChannelStateSerializerTest#randomBytes
specify charset?
you can make it public for not to use generateArtifact(packageId, packageVersion, 0) method calls below
Throwing exceptions (or allowing them to be thrown) is a rather expensive operation. Instead, maybe we could do a check to see if a decimal point exists in the string and parse a double based on that instead, though I don't know if that would be faster. It would neaten this up slightly too.
TODO: write headers
use braces even for one line blocks
Not related to this CL, but is there a reason this method isn't enforced on the main thread? It seems that since it is accessing the same data structures as bindToLifecycle() and unbind() that it should also be on the same thread.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Name inconsistency: HelixClusterSpectatorFactory should create HelixClusterSpectator.
Use slf4j style {}
Please check if it is non null and running before you cancel it.
Nothing to cleanup?
This method should only reflect the status of user suspention, not connection limit suspension.
You can replace the for loop here with values.forEach(result::add);.
As the getStitchList().stitch() always follows populateObjectLookupTable(), should this be moved into populateObjectLookupTable()?
Size the result list properly : final List<Object> result = new ArrayList<Object>(list.size() + 1);
Don't you check for array size >=1
I personally prefer to call one overloaded constructor. example: public BigtableSession(BigtableOptions options) throws IOException { this(options, null, null, null); }
Also, why we need this change on every call to the intentChooser?
filterRowKey should only filter based on the rowkey, here you are looking at specific values. This is most likely called only once per row. I'm guessing the current implementation wouldn't work on SPLICE_TXN, since we'd inspect the latest written cell (COMMITTED or ROLLEDBACK), see that it's not the ACTIVE state and filter it out, which would filter out the whole row.
nit: can replace both checks with CellUtil.matchingColumn
Use key.getLength() everywhere here (instead of key.getSize())
could we print the types here?
You might look to the git blame / history on this one - I thought the same thing as I read this. I wonder if it is a problem anymore? I mean, when AnkiDroid first started it was API1, and now the WebView is Chrome, so...could be this should either be deleted already or sunsetted with a Compat implementation and an API cutoff where we know it's okay (and I'd think any API number that has access to current Chrome WebView at least would be okay, if this was just a historical thing)
"ws" and "wss" must be defined as constants.
Please copy args here too
reset compensation?
Minor: move init to the beginning after the constructor
We will not show the 'saved' message because it is unnecessary. Could you also update the testplan?
Please simplify this just to nameModel.getObject() because it is a bit confusing at first sight.
Is the deployProcess() method doing something? if not we should start getting rid of dead code.
Just for consistency, we do not need the keyword this here, see the getter of isEditModeEnabled.
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
Raw type: Iterator<Item> should be returned from TREASURE_CHEST.iterator()
this is just a setter, why we need to update it?
I think I like the singleton approach best. It makes sure the ctor does not get called continously and leaves methods still static.
should rather be named currentContextClassloader
these setters should not be public
Can simplify this to: return partitionIds.stream().collect(Collectors.toMap(Function.identity(), partitionId -> new CloudReplica(partitionId, currentNode)));
computeIfPresent is atomic for concurrent map. This can be used to avoid heavy copyOnWriteArrayList
remove this
IIUC this is the same as before?
The super.close() method will close the executor, after which the task queues will be empty and all workers will have terminated. If we close the writer before we close the executor, we can risk racing with on-going work, can we not?
Also called twice here.
We have a removeConfiguration so let's not allow null value here?
I think we should only support push items.
You might want to repeat the containsKey check from above here, to allow the delegate to return a different Provider. My idea of using a Provider is to obtain "prototype" (new instance each time) or request-scoped objects within a request, and if we can only wrap a singleton service here, that's not going to be allowed.
nit: semantically 'Subscription' isn't a very obvious result from the 'onChange' method; would 'subscribe' work as the method name here? What is the terminology in RexJava?
Why didn't you provide fair implementation for this kind of spliterator?
Instead of two fields Double, you should use double with value Double.NaN when field is supposed to be null.
nit: Can this message be improved to state that one of them is null, how about "Either EnvironmentDto or NetworkDto is null. Neither them can be null."
todo is actual a destination
We don't log the exception in the other log statements. I also don't think it's a good idea, it just clutters the logs for operations, we should just log the message: LOGGER.warn(String.format("Error revoking all access tokens on auth-server %s: %s", authServerHome, e.getMessage()))
The 'when' can be dropped from the log statement.
Even if it wasn't in this commti I think e should be consistent regarding the logging.
We will probably run this from maven, and will use it to write to a "target/generated-metadata" directory, which won't initially exist, so please create the directory here if it doesn't exist: File outputDir = new File(args[0]); if (!outputDir.exists()) { outputDir.mkdirs(); }
Throwing RTE within finally might complicate debugging. Let's keep everything in try block:  private void recreateZKConnection() throws Exception { try { zk.close(); createZKConnection(newTaskCreatedWatcher); createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE + ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]); } catch (InterruptedException | IOException e) { LOG.error("Error recreating new ZK Connection for agent: {}", agentName, e); throw e; } }
I wouldn't do that, instead I might throw a RuntimeException and/or use our logging mechanism to log the exception. IIRC printStackTrace writes to stderr which could be not inline with our logging framework.
In this case that you read all files into memory, there is no difference between using this and using File.listFiles()... Just saying... Something like the following? :) for ( File file : new TreeSet( Arrays.asList( dir.listFiles( new FileFilter() { public boolean accept(File pathname) { return pathname.getName().endsWith('.properties'); } } ) ) ) ) { loadFile(file); }
you need to close this directory stream
how do we feel about using the public method regularFileFIlter in place of referencing the constant directly? It might make it easier for users to copy our approach in their own libraries.
defensive copy?
Consider to use an ImmutableList here
return Arrays.asList(....)
nit: might read better if you rewrite this as: WebMessageCompat webMessage = WebMessageAdapter.webMessageCompatFromBoundaryInterface( BoundaryInterfaceReflectionUtil.castToSuppLibClass( WebMessageBoundaryInterface.class, message)); JsReplyProxy jsReplyProxy = JsReplyProxyImpl.forInvocationHandler(replyProxy); mWebMessageListener.onPostMessage(view, message, sourceOrigin, isMainFrame, jsReplyProxy);
redundant
Please add final for exception, and rename e to ex
Objects.requireNonNull(arg)
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Why do we return the parents name instead of the name we store a few lines above?
possible exception
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
Pet peave of mine. I'd prefer Integer.toString(CLIENT_MAX_PENDING_REQUESTS).
seems as unneeded cast
rename to p, prop, currProperty
shouldn't this be throwing the exception ?
why this change? other places are calling getRelativeDir(ConfVars.something)
make this protected since its an abstract class
Why did you remove this call?
Hmm, is this missing the .incrementVersion() call?
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Starting with Java 8 you can do this: id = replacementIds.getOrDefault(id, id);
Remove this
these setters should not be public
Oh, I think those lines can all just be removed. The title in settings is already handled by StatisticsFragment (where you added a similar change). That's a leftover from the old statistics screen with only one single tab.
This commit appears to duplicate changes from the #430. Is this intentional? Which branch do these changes belong on? They should only be on one or the other. Please amend one of the branches to fix this.
Please make a null-ptr check.
Was this meant to be isValueDependent()?
Just wonder if this method check whether original state is empty value, why we still need to return the opposite value? In other words, shall we just return Objects.equals(emptyValue, Sets.newHashSet(getOriginal()))?
Boolean.parseBoolen(), twice
Should we alert the user that an error occurred here?
I know this is from a previous PR, but I didn't get a chance to review that, so I want to make sure to mention it before I forget it. I feel like this whole section should be under the else, because I don't think we should be handling both the error and the success cases together. Concretely, I think the plugin directory fetch can fail temporarily in which case since we are passing the event.canLoadMore it'll always stop asking for more data. Which might be something we want in any case, but it feels weird that it's a consequence instead of a direct decision. I've no idea if this explanation makes sense at all. I don't think it's too big deal of a deal, so feel free to ignore it if it doesn't make sense.
Nice! I really like all these explicit checks
Maybe call the data indecipherable instead of weird?
The persistence framework throws an exception because you should return a string here, because it can't convert a list that easily. Look at this for example: <LINK_0>
What if rosFiles is a file?
check for not null
requireNonNull
Can you maybe extract the following three lines to a separate method? Maybe private void createTableWithData(tableDefinition, tableName)?
Apache's _StringUtils_ has _StringUtils.containsIgnoreCase_ method
please move the isEmpty methods to the scimSchema
this creates an extra AsciiString object.
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
Could there be a case where savedInstanceState would not be null? If yes, how would we handle that case?
check if the fragment isn't already added
I think this already appeared before - maybe move the trenary if logic inside coco.getCommandEntity(guid) ?
should we place the created command entity in coco?
I'm missing an indication that the command failed because of a timeout. 1. for logging/auditing 2. to be able to react differently if the command failed because of a timeout (maybe in this case I'll want to retrigger it again in the future as opposed to command that failed because of permissions)
other methods like this put name first, then id. switch for consistency
Better to return "";.
The unit name "r|spm" is very geeky - every programmer knows the or-sign. But probably not the typical user. I would prefer the unit name "rpm / spm". Also in the diagram axis labels above.
You can use getDbFacadeMockInstance() instead of mocking it yourself
Note: There are *two* updateDatabase() methods (with different params) in this class, and it seems you only removed the synchronized from one of them. Is that on purpose?
why? let's format it properly, it was ok before. annotations and method definitions on different lines
magic number
Why does it need to materialize previous map operation as a List and then obtain a stream from it, rather than just passing down the pipe the stream coming out of the map?
Use TreeMap to keep the order.
again I don't think we should modify the generated methods. If we need to we should set this on merge.
style nit: no braces around single line blocks
Raw type List
The options are now rebuilt on every call. Did you want to leave the door open in case we ever need an option that would change for every new connection?
Why not initialize them at construction time instead of lazily on request?
This line should be removed
Pattern.compile should be done only once.
When can it happen?
nit: was gonna point out this should stop matching the parameter value at # to avoid including the fragment value, but probably all the querystrings passed here wouldn't have fragments.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Please add braces surrounding the for loop block. Otherwise this is confusing to read.
Don't initialize to empty when null.
better to return an Empty Map, otherwise callers would need to check
I think this stops admins from installing at for example /code/review/ on their server.
Why returning true if terminated?
is it not supposed to be ipBound(3690)?
I'd return suggestedId for the time being, but if you have reasons to keep it this way for the time being I'd be ok with it.
I think it should return Array here.
I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return "prev" than "oldValue".
null? why not just a () -> {} ?
Can make this into a singleton as we have with UNSET.
Can you please revert this file. It will cause bunch of conflicts with my changes.
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
Since this is recoverable, can it just be info?
use Collections.unmodifiableList and at similar other places
Wrong method name in the error message.
Typo: "visibiltiy" -> "visibility".
Is there a reason for not using the MoreObjects.ToStringHelper instead?
this line shouldn't be there on this branch (sorry, forgot to mention)
Better to replace -1234 with MultitenantConstants.SUPER_TENANT_ID
Shouldn't this code run even if mHasWifi is false?
Why is this necessary?
All other Store.Provider do some level of accounting - same should be done here.
just partitionToStore.get() should return null if the element is not present.
Same here, but check the max cook time instead.
checkNotNull(value, "value")
I think this can be private or at least package protected.
Do we want/need this method to be public? The check is pretty straightforward.
Same as with for. Spacepolice is calling :)
In Evidence, there is no attribute called shortDescription, and neither its corresponding get method. This cased an error when I tried to build, need to add it.
Style inconsistency: space after if
Style inconsistency: space after if
Style inconsistency: space after if
How about including Loop will be retried in the message (like WorkflowExecutorLoop's Uncaught error during executing workflow state machine. Ignoring. Loop will be retried.) so that we won't be shocked too much when server shows this message?
please remove or decrease log level to TRACE
You can clean the BlobStore via: java BlobStore blobStore = blobStoreContext.getBlobStore(); for (StorageMetadata metadata : blobStore.list()) { blobStore.deleteContainer(metadata.getName()); } blobStoreContext.close();
As for me, it will look a bit better with something like  final int offset; if (child.getMainAst().getType() == TokenTypes.OBJBLOCK) { offset= getBasicOffset(); } else { offset= getIndentCheck().getLineWrappingIndentation()); } return new IndentLevel(getIndent(), offset);
This new field isn't final after it is first assigned in the constructor. That means its possible the value can flip after the constructor, and it looks like it can be flipped in multiple areas. Is it possible usage of this field in one method can go down the true path and then another method could use it as the false path, and then re-calling the old method we first mentioned will then go down the false path the 2nd time through? If this is possible it would lead to some randomness issues in the check throughout a run.
I assume this is just a code simplification change and not necessary to this issue?
Nit: the else is redundant since the if block above returns unconditionally
It could be nice to ensure only one delegate has it...  delegates.stream() .map(delegate -> delegate.getSystemTable(session, tableName)) .filter(Optional::isPresent) .map(Optional::get) .collect(toOptional())  ?
I think we can write this as a stream java return Stream.of(partitionsTableHandler, propertiesTableHandler) .filter(handler -> handler.matches(tableName)) .map(handler -> handler.getSourceTableName(tableName)) .findAny();
return (algName.equalsIgnoreCase("DSA") && algURI.equalsIgnoreCase(SignatureMethod.DSA_SHA1)) || (algName.equalsIgnoreCase("RSA") && algURI.equalsIgnoreCase(SignatureMethod.RSA_SHA1));
I'd use a algorithmMap.containsKey(alg); instead.
throw ConfigurationException instead
Just a suggestion: Objects#requireNonNull(Object, String)
Wouldn't it be simpler to just use base 10?
Initializing as null is redundant, remove redundancy.
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
I know it's not part of this diff, but why isn't this function static?
It's not an issue but I think that it's better to put the both checks on a single line (if (!dir.exists() && !dir.mkdirs()))
Why is this now modified by this patch set whereas is wasn't earlier?
Why don't we instantiate the provider list within the constructor itself? It would allow you get rid of that "if" condition that always gets called whenever the getProvider method is invoked.
I think we should organise this method in a directly readable way: if (emtpyArg0) keep it fast getallNewEmptyExpression else if (compound getInterpreterForExpression(arg0) != DefaultInterpreterProvider.INSTANCE) interpreter to use is known do the standard completion else interpreter is not known yet (default interpreter .instance) try to propose new empty expression from arg0 with a specific "new empty expression" proposal provider. I also wonder if we do not just have to register this new empty expression proposal provider to the porposal provider extension points or declare it it in the proposal provider registryn and it will just have to return its proposals if the arg0 does not start with one of knwon prefixes.
isInfoDebug
are you sure you want to return the collection as is ? if that is so you must expect the client api to modify the list of properties manually. This may be fine. If you don't want it to alter the list please return a Collections.unmodifiableCollection
we should not modify the original properties. I would just return properties; here
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
We should not be throwing RuntimeException
what's the point in having a shell field in this class ? Why not just call this PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell() when a shell is needed, instead ?
invert this.  java if (List.class.isAssignableFrom(target.getClassType())) { return multiInstantiator.instantiate(target, parameters); } return conver....
I don't see where we handle HibernernateException.
I don't kown if amendPeerPrincipal shoud be in or out the if block :thinking:
I believe you should move this to inside the executor below. First, it will help deal with concurrency. Second, and more important, it will allow to fetch the latest model when the time expires, instead of being stuck using a potentially old model whenever the timer expires, since we use the model available at the creation of the timer, not at each run of it. Note that the old code used to "re-fetch" the model inside updateLoads(), so each time it was called.
Should we add an empty() check for ignore.value() as well, before doing this concatenation because if the user didn't specify any value for value(), then we will end up setting a description which looks like  : my regression which kind of looks odd. So I think we should add an empty check for value before we decide to use it to set descriptions.
Seems that's never overridden. Should it be private then?
nit: suggestion if (HeaderParam.class.equals(annotation.annotationType())) {
It may be cleaner to use Objects.hashCode for a single parameter, and Objects.hash for multiple (see the warning with Objects.hash, though that doesn't appear to matter here).
not consistent with equals, also the use of ID should be avoided
This is a private class used for tracking, won't change super fields, time is the only changing variable here, so only need to hash time here.
replace with return this == other;
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
Again, this could be written more concisely:  public boolean equals(Object other) { if ( other == this ) return true; if ( other instanceof JcrResourceAdapter ) return true; return false; }
the mafs often have the extension txt or tsv as well
Why is this needed?
Please group mr, ms, and mrs together
Should be ObjectId, as the mapping cannot be mutable.
Lets leave this get() however as its part of the public NoteMap API and some callers may prefer this variant.
Why is the copy here necessary?
Any reason to use an unmodifiable list as the list is already a newly created one?
probably better doc is requierd.
i think the api calls for return empty list if not found. so this check might be unnecessary. not sure if you want to check for empty list and do something if findall fails.
The pattern we're using in StreamDescriptors is to have the extending classes also override the toConfig method from the base class and call super.toConfig as the first step. Might be a simpler interface for extending classes since there is one less config related interface method. If we do that, you might also not need to call addTableConfig to mutate the passed in tableConfig map in generateConfig.
Initial size can be ownConfig.size() rather than +inheritedConfig.size(). And could create copy with with return Collections.unmodifiableMap(Maps.newLinkedHashMap(ownConfig))
there is a global value for the Charset to use in the utility packages. Please do not hardcode it here.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
No need to make createClient a method since it's a really a 1 liner and only use in 1 place
super.init() method never throw an exception.
remaining time only makes sense if the state is down. In the up case downUntil could be in the past and this could print a negative, misleading value.
Shouldn't we return immediately to save some unnecessary cycles? Or at least break out of the for loop.
public boolean hasValue(@Nullable String value){ if (adapter != null) { return (getAdapterPosition(value) >= 0); } return false; }  Not sure why we are instantiating a variable here.
for readability, consider using 'ImagesHandler.filterImageDisks' and check if it's empty...
I'd push the "{" up a line, but that's just me.
It's better to return a message upon canDoAction failure, something like "Cannot ${action} ${type}, this operation is supported only for image disks"
Missing strings to fill in the first three placeholders: suggestion System.out.println(String.format("Received event [%s] on channel [%s] with data [%s] and event [%s]", event.getEventName(), event.getChannelName(), event.getData(), event.toString()));
Should this just accept a Class? Then the caller doesn't have to instantiate an instance that's only going to be used to call getClass() and then be discarded.
It's a good update
Add the info log back after this line?
Deprecation was added in [1] but the commit message does not have detail. [1] <LINK_0>;a=commitdiff;h=18bcdf797dfba5e462413a6ccce9dd6d3da2025b
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
@Override
This should be imported.
this((Run<?,?>)owner, from, to) would be much simpler
This class seems to have too many responsibilities in it. It looks like that in addition to it being a model, it also has knowledge about how it should be displayed in the generated code. Split these two responsibilities out.
i think it's slightly better to add one more argument in AzkabanFlow constructor called type, and let builder handle the default parameter passing.
Can just store a boolean shouldSkipVerification instead?
Hm, we could do the same thing as suggested in UserPortal's SystemModule.java for consistency.
Just a question: will we ever have to switch between HA and non-HA?
No need for public setter as it's set in the constructor.
shouldnt this method be static?
Let's make this non-static. I.e.: spin a new context in @Before rather than using @BeforeClass and potentially bleeding state between tests.
I don't like the side effect within the if-condition (nothing wrong technically here). Could you please revert this to the form with a temporary variable like it was before. In addition, the code indeleteSilentAfterExtract and deleteSilentAfterCancel is identical. You could introduce a new private method private void deleteSilent(Path file).
Another occurrence of deleteSilent(file)
Catching generic exception is very much discouraged. Can it throw any other exception than NullPointerException? It'd be better to check the nullity of lm prior to further processing. <LINK_0>
Let's make this private and introduce two factory methods known(String, UUID) and empty()
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
Same here, maybe we can pass a LeaderRetrievalDriverFactory to this class and then pass in the leaderRetrievalStateHandler when we create the actual leaderRetrievalDriver.
I believe Role.SERVICEUSER would allow any service user to call this. Regarding rest of our API, you should check for FACILITYADMIN role and you should filter resulting list of facilities to return only those, where user is facility manager. Or to be more correct you should check, if user has READ right on attribute he search by on that facility. If not, do not return the facility.
The same question about ", " as above.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
Typo on attribute
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster.
I'd like to understand the reason of this extra MutableMessage creation object before encoding...
after saving can you broadcast, so as all other users on same note gets this save update ?
Gary, I have this test like: java //INT-2399 @Test public void invalidInlineScript() { Message<?> message = new ErrorMessage(new ReplyRequiredException(new GenericMessage<String>("test"), "reply required!")); try { this.invalidInlineScript.send(message); fail("MessageHandlingException expected!"); } catch (MessageHandlingException e) { Throwable cause = e.getCause(); assertEquals(ScriptCompilationException.class, cause.getClass()); assertThat(cause.getMessage(), Matchers.containsString("No such property: ReplyRequiredException for class: script")); } }  And it works for me on both Java versions, as well as from IDE and Gradle. Also this fixes the Travis failure.
you import ByteBuffer, no need to use the full package path
Ctrl+Shift+F this file
Do they use c_style_variable_names in CDT? ;) Coding style in LT is normally camelCase, so maybe something like signedFixture and unsignedFixture.
Send this exception to the log.
It's not needed to check null, also inside of QueryBy.valueOf has internal check if the item is not one of enum items, exception will be thrown, should be changed to something like:  @JsonCreator public static QueryBy of(String value) { return QueryBy.valueOf(value.toUpperCase()); }
Consider using a more informative message in the log, something like "The value \"" + value + "\" isn't a valid quota mode.". Also, try to use the slf4j {} mechanism: log.error("The value \"{}\" isn't a valid quota mode.", value); log.error("Exception", e); Using two lines is needed because the version of slf4j that we currently use doesn't support a mix of arguments and exceptions.
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
Please no, let's not have compactedChain being null legal. What is it buying us exactly?
So we can't know it's really an alias until it's wired , or runing, or ?
getAppDataSummary can be removed here as its contents are included in getAppData (same for device metadata)
Shouldn't we add the Transmit options field here?
Please auto format all files, so spaces are set properly everywhere
this.
Why is this a warn? Also spelling.
Perhaps use a self constructor (e.g. replace with this(new Util.Range(minSpeed, maxSpeed));)
Couldn't you just to do: setXyz(0)? Like many other config classes? Also if you just want to initialize the value to 0, wouldn't you simply default the field value to 0 instead?
No need to call super() since it currently doesn't extend anything.
it doesn't have a superclass
Hmm, why did we do this? I thought we'd have a try/catch block.
You need to remove the client.close() below too since this test class is using @AfterClass for closing client
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
I'm fairly certain that you could replace all of these with method references. e.g.: .map(this::convert)).
should this filter out null resources? (ie. bad paths)
can we use BeforeClass annotation?
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
I guessed this is by intention to double test null, right?
Do we think that overByAmount will actually be a useful/actionable piece of information for users? As opposed to just saying it's too big to upload without specifying by how much?
Duplicate getAbsoluteFile()
Now that the 7 lines above are duplicated in 3 tests in python-squid, maybe we can factorize them.
Line delimiter allows newline or (carriage return-newline). Imap protocol is always delimited by carriage return - newline. Change to use only carriage return - newline.
I think it'd be better to read something like than [probable | possible] size of data
nit: you can merge both lines above as checkNotNull will return the given argument
I think that the log messages related to extensions cannot be part of "pluginNotStarted"
This reads a little weird. "Not loading plugins: No plugin configuration file found: %s" where %s is the path searched.
pluginsSubsections could be inlined
There's a way to avoid that n+1: doing a query searching for all questions in (:ids) and, after that, using session.load to get the questions in the specified order as you're doing (the hibernate would get the questions from the first level cache once you already selected them before). (yeah, its not pretty, but works)
I just want to make sure the result of this call is not expected to be modified anywhere. I see one assignment to a instance variable this.excludeTags
If we'd like to call sendResultToOrigin(operation) when 1) the operation is not from local client, and 2) all sub operations have been complete, then could we change as follows?  try { // L104 if (!operation.waitOperation(TIMEOUT_MS)) { // L106 } else { // L108 if (!operation.isFromLocalClient()) { sendResultToOrigin(operation); } } } catch (final InterruptedException e) { // .. }  I don't think it's a good idea to synchronize a CountdownLatch only for getting the current value, especially when we'd like to check whether the value is 0, which is the terminating condition of await(). What do you think?
extra newline
Adding this to a field is good manner.
Adding this to a field is good manner.
Why use only w2? Why the right shift? Likely it doesn't really matter.
bad hashcode.
Use Guava hashCode function
This looks very user unfriendly. Does the UI really allow users to get this far?
Please use English only for messages.
suggestion String packageName = entityType.getPackage() != null ? entityType.getPackage().getId() : null;
Is this correct then?
so, you pass in a list of filters, call on which will add the new Filter into that list, so we now have a circle graph? list -> new Filter -> list -> new Filter?
"" to remove the last ternary
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
Can simplify the if(cond1 || cond2...) then return true to return (cond1 || cond2...)
call cleanup() instead, and move whatever code you need to there. there is code in two places currently and that can be hard to maintain.
This has nothing to do with your contribution. I would keep the class name as a String as it is clearer and avoid to import Serializable which is not required. Same remark for the other arguments.
you could have merged the expression of this if with the previous one.
delegate this implementation to the new method
No need to change. I feel that it's from the refactoring action
No need to change. I feel that it's from the refactoring action
I think that the log messages related to extensions cannot be part of "pluginNotStarted"
this("Safety Command")
The parameter needs to be 1 since the backup model node is one level below the cache
Would you mind making the constructor protected? Additionally, I think it should have the Builder as the sole parameter, from which it will pull the identifierAnnotation and versionAnnotation to set as it's own fields. I believe it's fair to introduce this as a breaking change as it's gonna be part of 4.1. @abuijze / @m1l4n54v1c please call out if you disagree with me here.
Will the behavior of the other fireActivity(...) methods change in the future? Otherwise, you could consider just having one fireActivity(IActivity) method and differentiate between the activity types internally. This would allow you to avoid the code duplication for the other methods.
Just a small remark feel free to skip it. It would have a nicer look if you keep if else logic direct like if (activity == null) { return Optional.empty(); } else { final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity; return Optional.of((CoverageReportView) coverageActivity.getWidget()); }
sorry about this, but how about just making this private? does it break anything? #Closed
are you sure?
We don't know for sure that there is such a field in that specific event. Should use ITmfLostEvent.getNbLostEvents().
and doing the instanceof check here instead (trace instanceof TmfExperiment)?
Are you aware that this very expensive use of String.format is executed every time, not only when debug is enabled?
waittimeout can be very low, let's add a min of 20-50 ms
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Please change this to  java return new ArrayList<>(failures);
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
This modification looks a bit suspicious without a testcase and definitely does not sound like a quality flaw fix.
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
you don't validate in other builders method (and you don't have to)
not public
Let's refactor Topic a bit to be able not to pass anything there. We'll have something like new Topic().withBody("ab") and therefore other fields like title will be generated randomly.
Duplicates in createTopicStubs
logger.info("Skipping creation of topic {} on brokers, topic already exists", topic.getQualifiedName())
nit: No need to print out organizationDiscoveryIntervalMillis.
Are we sure we want to thread interrupt if a FederationAdminException is thrown?
Don't use printStackTrace() and instead write to the logger using log.error("<Appropriate message>",e);
why is this public?
what is the testcase trying to do or what verifications are expected
Should we instead have two constructors, one with an SSLConnectionSocketFactory and one with an SSLContext? I find that to be a more common way of expressing effectively mutually exclusive arguments.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
JDT puts it there, but we usually but the @NonNull just before the type on the same line
Looks like the code that uses empty constructors (Annotation(), Video(), OptimizedVideo()...) is inside the entities package. Could it make sense to mark these empty constructors package-private so that it's clear that these should only be used in that way?
log exception
You don't block here until the server finishes by calling server.join() ? <LINK_0> BTW: nice work Cedric, you have made the code of Kasper a lot cleaner & well tested, I am impressed :)
Please change this to "Port XXX is disabled due to conflict".
Oh please, no! Don't ship a null object! :cry:
Instead of this constructor using the other, I would make the other to use this constructor with a null linkUrl. What do you think?
As a matter of symmetry I would expect a getter to return something of the same type as accepted by the corresponding setter, which in this case would be a Map<String, String>. In general I think difficulties in retrieving the correct results and putting them in an easy to use format should be handled by the API client and not by all callers of its methods.
Does this need to be a left join or would JOIN FETCH be sufficient? I don't think there would be an entry in this table if the association wasn't there.
wrong error text
"FROM" - we should make sure we are consistent when capitalizing HQL keyword.
why delegating
Should this method check motor.checkMCException()?
as is in 718
I would delegate to the new method directly
I don't think any of the add() methods should return void. The user of the ReferenceService should receive a result of which element(s) have been added. This is useful for example to select the newly created element, i.e. within a table viewer. Note: the result might actually be empty because the user pressed cancel in the wizard/dialog. So I would return an Optional here, similar to what I suggested in bug #115184.
why wrap the shoSelectInstanceDialog result in a Set?
You can do this instead.  proxyPorts.stream() .map(port -> "localhost:" + port) .collect(Collectors.joining(",", "terracotta://", ""));
Use Collections.singletonList() instead?
This will throw redundancy warnings in IntelliJ
This will call fireEvent() while the monitor is held, which will synchronously invoke registered event listeners. Invoking callbacks from a synchronized block is... risky.
Not sure this is right unless it's only supposed to work on *nix.
Souldn't it be lower case idx? hard coded directory name and file extension
nit, Collections.EMPTY_MAP?
What's the point of adding a copy here?
Generics on the right side are redundant since Java7
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
What happens with an empty string as a value?
no need to have this getter public
This should follow the normal exception handling path and let the caller handle the printing of the exception.
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Should this method be final?
See ByteByReference.java
See ByteByReference.java
See DoubleByReference
Maybe StringUtils.isNoneBlank() is better in this place, because with this code you can add keys and/or values like " ".
This is another behavioral change that I don't want to see in an unrelated PR.
value ! = null can be removed as StringUtils.hasText(value) does the non null check as well.
I think all these assert methods can be static
Same here, see if these can be static
You can use Collections.emptyList here
i think we had talked about swapping the order of these so we can short-circuit?
Why wrap OSUtils.isHuaweiDeviceType(); when we can just use it directly?
Are we sure a null never reaches this point?
You don't need this as compareAndSet will set it to true.
This shouldn't be needed as StatementClient.close() should be idempotent
Does this mean when pause method gets the undelete lock, the performHardDelete should be complete and token should have been persisted already?
add: import org.ovirt.engine.core.common.utils.Pair;
We already declare diskValidator in line 115
please replace tab with spaces
Thow applicable exceptions
sample still included into both populators?
Why remove the second param? It's useful when you actually encounter this exception (if you do).
Shouldn't the FBOs be disposed here as well, when they are created here?
Is this access modification potentially problematic at all? Could other things just start randomly removing screens, by chance or on purpose, or is it badly needed for something?
Given the plugin is called service-user, you might be OK just calling the screen create. Then the URL is "/#/x/service-user/create".
log and throw anti patttern
Can check isBlank()
log tenantDomain and idp name if possible
nit: Root groups cannot be fetched from the database
The logic using succinctNanos is easier to read.
Put these three blocks into a helper maybe.
Why not return getAnnotation(annotationType) != null?
This feels odd to me. I can see that you are going for functional style, but the empty function feels forced. This can be accomplished with a simple loop and lookup and that doesn't require the empty function: java for (Annotation annotation : targetType.getAnnotations()) { AnnotationProcessor processor = this.classAnnotationProcessors.get(annotation); if (processor != null) { process.process(annotation, data); } }  Can you help me understand if this is more than just a style choice?
I think that if there is more than one stereotype on the annotation (which is allowed), then this will override the variable and you will only inspect one of them which is incorrect.
please also add the GUID which is important.
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
This toString() is used when printing the query plan. We probably don't want to include the partition values.
This looks like an infinite loop to me?
You should do return true at the end of the method.
You can remove this since hasNext will call checkInvariants
I don't see where we handle HibernernateException.
I don't kown if amendPeerPrincipal shoud be in or out the if block :thinking:
we need to reset this property in a @Before block
remove empty line
style: unnecessary blank line
Why "Whatever" here, is this a left over, or final?
can also use a for each here
Is the limit needed? I think that you shouldn't limit this hardcoded.
So if we are in FIT mode, mMinimumScaleMode is set to Math.min( minimumScaleX, minimumScaleY ) Maybe we should be more explicit here, because we have to understand that we are not in mode NONE, nor in FILL, so we must be in FIT mode.
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
I assume this function must only be called if the service is activated. EventPublisher is a mandatory reference, so no need to check for nullness.
why do we need this new method?
Exception should be logged.
![CRITICAL](<LINK_0> Either log or rethrow this exception. [![rule](<LINK_1>](<LINK_2>
os.write(command.getBytes()); ?
CHANGE it to TypeConstants.JAVA_LANG_RECORD
let's have a check if iType is abstract or not at the beginning of this method:  java if (Flags.isAbstract(iType.getFlags())) { return false; }
Once <LINK_0> is merged we should use the signature's return type. Probably FunctionInfo will be gone once all functions uses the signature registry. Maybe we could wait a bit for #9853 as it maybe merged soon.
Possible deadlock: remove this call to sleep(). It's possible that no events will ever arrive.
why not use a simple while loop? thus removing the for and the if
public? And maybe put it next to the other setter.
You can simplify this by reordering the states.
Probably want to log an error here too because this indicates a programming defect
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
Why to call finish?
This method should really be called stubLocationPermissions. It's probably also good to have a test that checks what happens when location permissions are denied.
tabs vs spaces
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I still don't see why we need the 'if..else' here? both cases are the same
you can use instead: return Version.v3_5.less(version);
I'd add an isLocal() method to the StorageType enum and have this return getStorageType.isLocal()
Invoke validate()?
Ditto regarding only keys needed
Also only needs keys here so no need to return entire entities
Should we include organization here too?
I think this is probably the last item. Add organization to all the relevant log statements.
Should we just add the entire organization to the debug statement?
Again, I think this should evaluate against the standard special path info, not the stuff for the maven package
This looks like it will result in getPathInfo(..) executing and calculating the storage path of this storage path...I think we need to pass in the logical path here (the getPath() output).
Isn't it fatal if pluginInfo is null? There's only one chance to set static assets. I'd think we would rather not silently fail.
Simple for-each?
For new API I'd prefer to return an java.util.Optional<T> instead of null to avoid potential NPEs.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
why not use a ConcurrentHashMap instead of making all these functions synchronized ?
Can the connection or the context be null at this point?
should not lock everybody just because one thread is doing test connectivity
Since there are two places using "tree-item", consider replacing it by a constant just like you did on the other classes.
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
Need to implement
can just do new ArrayList<ICommand>(commandMap.values()); instead of separate addAll
can replace sync by false
Info? If so we need Log method.
new ArrayList<>();
Is this really needed? What can you do with this that you cannot do with get(int id) ? If your answer is: "Well you can iterate on them, dingus!", then I'll say you should return an Iterable here instead, and not expose the underlying data structure (this will allow you to change the underlying implementation to TreeMap etc. without breaking this API).
Just use images.forEach
addAll
Should we even both installing features in different subsystems if this is true? It might be better to just install all features in the root subsystem instead.
Throw the entire stack trace in the log and not just the message.
you could assert that the module that you loaded is in there. at the moment you assert that the number matches what you expect but it could as well have been the same number before you loaded the module. You did not check that.
Why is fModules static? The list of modules is really the same for all XML modules? In this case, the getAnalysisModules() method here should be a static method also (and not using the interface method). And the whole class ends up being a "static" class, so it could have an empty private constructor to prevent instantiation. Also this method should be synchronized, to avoid the risk of two threads calling it at the same time and both entering the if block.
Shouldn't you also assert that before the post, these modules are not started?
You could just call the other ctor
could be warn as @kuujo suggested?
this and step should be private
Yeah, here's where I was thinking of using our custom exceptions. IdpResponse.fromError(...)
1. Shouldn't it be new RuntimeException(e.getCause()) ? 2. Does this handle if e is IgnoreTransactionRollbackException and e.getCause() is null?
Does that enforce a specific QR scanner client ?
'isManagement()'? Please fix.
I think this method should check only case 'b' and have proper method to explain the problem. All the other case are covered by 'nicActuallyExistsOrReferencesNewBond(..)'.
this might result in a weird flow: user wants to update the ssh-key but the validation in UserProfilesOperationCommandBase#validate fail (for some reason) - then the error would say that the add profile operation fails, no?
Add the check here.
SetLevel method isn't implemented,
This should be moved below the LogContext.checkAccess().
Nit: Wouldn't it be good to move the settings to new lines? suggestion Settings settings = Settings.builder() // .put(loadConfig()) // .put("transport.type", "netty4") // .put("http.type", "netty4") // .put("path.home", this.pathHome) // .put("path.data", this.pathData) // .put("cluster.name", this.clusterName) // .put("node.max_local_storage_nodes", 100) // .build(); node = new TestNode(settings, Collections.singletonList(Netty4Plugin.class))
Consider making these 5 lines of code (allocating a byte buffer, filling it up, and flipping it) a helper method in this file.
Ummmm, my memory does not check out this time :\
You shouldn't expose your internal list directly, callers are then free to modify it. What's the use case for this method anyway, is it really needed? Should do ImmutableList.copyOf() or Collections.unmodifiableList() if you really need it (the latter is more lightweight, but the data can still change under the caller's feet, which can cause problems).
Need to implement
This "else" has created on me a nice debugging session :-)
Should use the log, maybe a warning.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
there is no need to execute initElements method, when you're extending BasePageObject
you can remove this
this is already called in BasePageObject so you don't have to call it
It could use StringBuilder instead.
Use StringBuilder instead. Also, you can use ToStringHelper in guava.
toString() formatting.
Help me understand the change below more. The one on the left seems simple.
This boolean expression is quite complex, maybe you could expand the code out to make it more readable.
nit: space after if before (.
there is a lot of duplicated code here, please use constructor or a private method for setting all these fields
How is this going to work if there are multiple test classes using this and they are run in parallel?
different value 50 versus 1. Is that intended?
extract getVmDao to getter
can you please add a helper method for performing it? this code is repeating itself in all of this patch edited classes.
you erased a lot of logic, can you please explain why ? secondly, IIRC getParameters().getRunAsStateless() is Boolean and we had a bug in the REST it's null, please check for null
not need for 'this'
Why? Just case tempObj
I would suggest naming this variable as 'serversArr' instead of 'temp'
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Yeah also we would have to keep the dump in sync. It's most comprehensible I think to only import the relevant data for testing, so it's easy to see what kind of data is expected. You can use e.g. jq to get the relevant data. Or if necessary to have the full dump, do a complete integration and use the actual data that we would import instead of having to sync this file.
Can we move this to initialize and reuse it? Is initialize() guaranteed to be called for the first time?
Please keep this.cell near the related fields (previousFamily & cell count) below
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Can this be private, or is there another use case for default attribute outside the builder's call?
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
returning boolean type is useless here because it can only return **true**, or throw timeout exception.
Same here, it should be false.
I think that's the same as new HashSet<>(vertexRegions.values())
Do we need the ...Function suffix in the method name?
Now it can be simplified to Set<Set<SchedulingExecutionVertex>>.
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
Please copy args here too
what if imageUri == null?
I think we should use the setEnableFeelLegacyBehavior here so that we have a single point where the flag is changed. This might lead to inconsistent behaviour if a user isn't carefull.
Please also delegate to setDnsConfigurationEditor
This should not be static. The choice of whether to use BMX should be per apache server, not per agent.
No need to declare the types in new constructor, diamond is enough
Looks like there is a working assumption that plugin manager is also the dispatcher. Why not combine them by having ApexPluginManager implement the dispatcher or add a method in the manager to return a dispatcher. In your current implementation of the interface it can return itself. In future, if flexibility is needed these can be separated and they can be bootstrapped accordingly as well.
else if on one line.
Is this important? Should we throw instead? Or just make this a debug message if it's not important? (same for seek)
why not to rely on AbstractCollection..toString?
s/occured/occurred/
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
null? why not just a () -> {} ?
Throw an unsupported operation exception here.
we shouldn't need the ?test param any more
can not -> cannot Maybe Chid name instead of Property name?
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
can we make this one configurable?
strictly speaking, this is not always ONE_TO_ONE e.g. what happens if my format string is "just-a-fixed-string" ?
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
suggestion Assert.notNull(id, "Labelset ID must not be null.");
Starting with Java 8 you can do this: id = replacementIds.getOrDefault(id, id);
Remove this
Remove this
these setters should not be public
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
Shouldn't this close the iterator before returning the list?
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
Raw type List
This code can be replaced by return str.matches("^[-_.a-zA-Z0-9]+$")
This expression can be hard to read. I'd rather break it out as: if ('0' <= ch && ch <= '9') continue; if ('a' <= ch && ch <= 'z') continue; if ('A' <= ch && ch <= 'Z') continue; ... return false; Or use a table to check the validity: static boolean validChars[128]; static { for (char c = '0'; c <= '9'; c++) validChars[c] = true; validChars['-'] = true; ... } if (ch > 127 || !vaildChars[ch]) return false;
Hmm, is this better than a switch?:  switch (ch) { case ' ': ... }
Should there be a second catch for ClassCastException? is art checked somewhere to verify that it is always a teamWorkFlowArtifact?
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
Don't need the boolean if you're throwing exceptions when input is invalid
Guess we may want to leave the log in the same state in-case any one of the log segments throws on close, and hence we throw right away is it? In other words, might get a suggestion as to why not close as much as possible even if some log segments throws exception.
We have different conventions. Please see the spaces around brackets and method parameters, and brackets on new lines. The checkstyle plugin would crash the build. Did you try to run "mvn install -P run-its"? It would take quite long time to complete the build, cca one hour.
Here is another use of sorting via TreeMap. It's just a debug method, but I don't like the functionality change
nit: I don't think you need fully qualified path name. it can just be CompletableFuture<LedgerEntries>.
please don't put any synchronous call in asynchronous method.
it is a weird pattern on how do we handle callback and completablefuture: we are using context object for passing completable future. isn't it clear just pass a completable future or having a completable future inside the SyncReadCallback? when the callback is triggered, the completable future is set. the transformation from Enumeration to Iterable can be done within SyncReadCallback, without attach a new apply function. also, counter should be renamed to ctx at least. the name were left before introducing CompletableFuture.
This doesn't have to be public. Just use default package access since only thee cache impl in this package has to see it.
this.
this does the same thing as createTransactionalBatch(). why do we need to have both as public? If createTransactionalBatch is the public method then this one should be package private.
This methods should return the index of the max/min axis: x = 0, y = 1, z = 2, but it would probably be better to remove them from the interfaces.
Should be final.
why are we casting to "int" ? it the value is a "long" we must return a "long" or we have to handle the overflow some way
Inline this
If I understand this "fix" properly, we were basically creating a new appender for each test, which you're now auto-closing. Plus, you're creating a new logger for each test. Would it be possible to just have LogFixture take in a level, and auto-generate the logger name, so it does not need to be passed in, even if just to avoid copy-paste errors?
Does this work with the typo?! CB.getConfugrationFilePath() Good time to mention it... before merging anything to dev, the commit must passes unit and system tests locally. Do you do that? 'mvn clean install' and 'mvn clean install -Psystem' -- other parameters may be requred depending on your local maven settings.xml file. There's a settings.xml file in the repo from voodoo2 if you want to use that -- and that goes for anytime you run tests.
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
constant
what if my value is " " ? should use trim
Call to default super() constructor is implied. This is only a question of style, but it make my eyes hurt... Feel free to ignore.
is this class going to be created by the user?
Please keep the getter and setter closer.
![INFO](<LINK_0> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_1>](<LINK_2>
StringUtils.isEmpty
Please call here just the other constructor:  this(name, new ResourceLoader(), clazz, language);  No need to duplicated the code here.
Should these have some kind of validation, e.g., non-negative, from less than to?
Doesn't look like conditions are same.
this((Run<?,?>)owner, from, to) would be much simpler
nit: you can merge both lines above as checkNotNull will return the given argument
how about  java return method.isTestMethod() || method.getTestMethod().isAfterClassConfiguration();
could store this in a field to avoid recomputing the same thing every time we call this method?
Can you add @NonNull @CheckResult @WorkerThread to these two methods as well?
It would be better to fix the indentation issues, can see in couple of places.
Returned topology not used, change the return type to be void?
Don't need to call here either
No need for second level of brackets.
Using Long instead of long could open the door for returning a null object.
In cases like this I would expect it to throw an exception instead of returning null. For error handling it's okay to diverge a bit from the canonical data (I believe they're trying to remove most error cases from the canonical data for this reason) since it can vary a lot from language to language how you'd want to handle invalid input. In my opinion it's better to throw an exception in Java than to return null since that forces to user to deal with the error instead of relying on them checking if the output is null :)
How to do ensure that by requesting .getConceptNameTagByName(null) for should return null if No concept nameTag is found?
This test checks "get" by using "get" so I would say that it's redundant to check it this way, perhaps it's possible to test it using another method to get an expected entity (say getAll and pick one from there).
Please enable run button in background tab
Why not use the method isStarted()?
### issue 1 I think we should place this somewhere else, because it causes inconsistent behavior. If user Click Model -> Overview -> Data Objects -> Background, then all buttons are allowed until Background is clicked. If user chooose different order Model -> Background -> Overview -> Data Objects. Then buttons are disabled immediately after second click.
What happens when we have a file named "pack-1234idx" in that directory. No '.' but ending in a well known extension. Such files would be deleted, or?
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
How about using MimeTypeMap.getMimeTypeFromExtension? That would work for more file types, just in case we used the class for more things later.
should we be returning the defaultValueForNull instead of 0?
I don't think it's actually possible for this code to get called as the parser will not accept *3 or /3 but NaN doesn't seem to be the right result. You can just throw a new IllegalStateException() to indicate that something has gone really really wrong.
If it's a negative number and we are running on-robot, I think we should take the absolute value so it's at least sane.
This is not correct. Component definition declares that component provides RETURN_TOTAL_RECORD_COUNT_PROP, but it doesn't really computes this value
Simpler: ArrayList<T> result = new ArrayList<>(collection);
is there no common place (at the broker level) we can add the unioning query runner?
instead of addAll(), you could just return the free vars from the definition. Same in VarDeclaration
Actually the name of the definition is not bound in the body --- at the level of the Core IL, recursive calls must be of the form "this.mymethod(...)" not just "mymethod(...)" [there is a sugar that makes this work at the source level but it goes away in translation to the core]
This is trickier. After getting the free vars of the body of the case, we need to take out the varName bound in the case. Then we need to add whatever variable is at the root of the path of the NominalType in the case, because we'll look up that variable to get the tag to do the tag check.
suggestion this.className = requireNonNull(className);
single quote '/' and remove //$NON-NLS-1$
Should make a differentiation of the name and id.
We might need is[Type] methods for each avro type. What do you think about it?
Should be super( NativeTypeEnum.STRING );
You can use StringUtils from the commons.lang3?
I'd change this to include the full name of the sender. Tickets were bought, so a filled in profile is guaranteed. The term "user" isn't really something you want to say. They're people! :stuck_out_tongue_winking_eye:
What do you do when checkState fails?
This method looks very much like the one in OlaBridgeHandler. Since you have the class DmxBridgeHandler with these methods anyway, how about implementing the core of this method there and a parameter if you need anything specific?
Just a thought is the contract for running that its fully started? As Camel has a state called .. starting which is the phase it do when it startup. But I assume running is after all the startup stuff and its really running.
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
Is it right to delegate to isActive() here? Might not make a difference in practice, but it seems confusing. Maybe always returning true would be better?
"You do not have any tapes"
Use a null guard here instead
throws RestApiException not necessary.
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Do we want to keep the method names like this or give it a more general name?
done for patch3.
I suggest encoding the above 4 assertions in a single call: assertEquals(ImmutableMap.of("1", "hazelcast", "2", "phonehome"), map);. In general it is a good practice to check the expected output in one assertion, instead of checking its pieces separately. Also, in these assertEquals() calls the expected and the actual values are mixed up. First should come the expected, then second the actual. Of course it works this way too, but if the assertion fails, then the output becomes confusing if the expected and actual are swapped, so it is useful to always put them in the correct order.
These 3 lines seem to be duplicated in all unittests. Can you extract it into a @Before method and have the node and phoneHome initialized as fields?
unused
can we use method reference here this::createHeathIndicatorForCircuitBreaker
Can we use return new CallNotPermittedException(message, writableStackTraceEnabled); instead?
Could you add space after ,? I think we need checkstyle.
the client could be null
This should be synchronized
isDebugEnabled
do we need new Array here? You can just use ImmutableList
use simple thenApply(...) instead.
I'm not sure how this works, but isn't the saveMany() completion stage completed before all entries are stored?
<code>Downloadable.get()</code> may return null. It is a mistake in the original code, but it makes sense to fix it.
Can Lists.newArrayListWithCapacity() not be used since the the length of List is known?
Do we support this for JSONObject? If not, we should not support it for JSONArray either.
as is in 718
No need for return here
Possible NPE here in case of default constructor. Let's mark the 'log' field as 'final' and initialize it in default constructor.
SecurityException?
To avoid NPE, could we use: java Objects.equals(field.getFieldName(), fieldName) || Objects.euqals(fieldName, field.getFieldBinding())
This is inconsistent with StoreProperties.isPersistedToDisk. Over there, it is "persisted" if it is not an in-memory store. Should we do the same here?
Those two methods are similar. Consider using one.
Add PageLogging
log
Value nor envVar wont be ever null, but empty strings, so that check will be valuable
Why not import the org.apache.commons.lang package and avoid some clutter?
So is there value of having a whole class that just does such a simple thing? Perhaps a static method in a utility class is easier and adds less to the heap?
SpeedController not CustomSpeedController
this.
SpeedController not CustomSpeedController
this.id -> id
This will run once every 500ms so there should be a loop sending all messages available at the start of the run. Just one seems delaying message delivery unnecessarily and substantially.
replace this line with LOGGER.error(e.getMessage(), e);
super. is unnecessary
Will you expose this in JDBC too? ( <LINK_0> )
I'm not sure what Java version is allowed to use in Daikon. If java 8 is allowed we may use java streams feature to make this method shorter
Why is this required? The test you wrote fails when I don't apply the change on PrimitiveType, but doesn't fail if I don't apply this.
This block could be shortened if using Ordering.nullsFirst()
other != null is redundant with other instanceof Module, which already returns false when other is null.
decrease to TRACE level
You can probably remove this at this point. It doesn't seem to be used anymore.
Assert.notNull() ?
Instead of exposing the data storage, I wonder if it would be cleaner to add a method to add something to the storage.
YOu can make this a local variable and use it multiple places.
Are you intending to be able to call DataRegistration.of(Keys.FOO)? because the varargs can have a length of 0 by omitting the argument altogether in this case (this is why Cause historically always had an Object, Object... method signature, to ensure there's at least one argument passed in.
I find this confusing given that soon we'll have searchable fields that are not indexed. Should we rather rename it to failIfNotSearchable ? And the error message? Or maybe isSearchable should rather be isIndexed ?
You can do:  if (message != null && transformer.isPresent()) { return transformer.get().transform(message); }  instead of throwing the exception twice.
No need to do this, long strings are fairly common and the checkstyle configuration accounts for them, so they shouldn't trigger a warning.
final
We could create a new ChatMessage with messageData and remote
You want g.add(null, checkBox) and put the display name onto the CheckBox widget. This way it shows [x] Foo instead of Foo [x] and users get a bigger click target (the label text) to mash with the mouse.
This should be doable with Allele::basesMatch without converting the allele and the transition base to Strings.
Duplicate non-null check (also done in Transition).
Similar to earlier, why not just check transitionFactory2.isFinal() here?
Should not be necessary as you remove it in deactivate already.
You could instead annotate a method with @ExceptionHandler(NotFoundException.class) and @ResponseStatus(HttpStatus.NOT_FOUND) to return the error page, and then throw a NotFoundException to trigger it, which would result in the proper HTTP status too. This method could go in a separate class annotated with @ControllerAdvice to apply to all controllers, though you'll want to exclude the REST controllers
Out of curiosity, why is the return type of this setter not void?
I wonder if this method should take the check one step further and verify not only at least one location provider is enabled but also that LocationManager#getLastKnownLocation(provider) returns a non-null value for at least one provider?
Why is this null checking before requesting locations? I would think it's ok to request new locations even if we didn't have a last known location in the GPS provider.
Is RebindManagerImpl ever be used with a NonDeploymentManagementContext? This will throw an NPE if it yes. Safer to return an empty iterable.
magic numbers
This should not be here. Commands should not be invoked directly from the view. I think you need to create actions instead.
I wonder what's gonna happen with scene metadata. The way this is implemented, each time you copy a scene you we'd need also to copy its scenemetadata object (See #132).
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I know you didn't add this line, but comparing a String with an operator will only work accidentally. Could you change it (and any other occurrences) to something like if (!("".equals(itemName)) or if (StringUtils.isNotEmpty(itemName))?
I would use log.infoFormat since it is the standard way. Also, I think logging this at info level is too verbose, this sounds more like a debug to me (and if someone wants to monitor this query specifically he can lower it's log level)
streams will be more elegant here
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
This would not be a performance improvement. (And a tab character has appeared in the file.)
Simpler: ArrayList<T> result = new ArrayList<>(collection);
I also can't understand it, but now result is always empty. will try to debug it.
I assume the substring(1) is to skip the leading /. Can we be sure this will always be there? I think I'd feel more confident if it was something like Arrays.stream(path.split("/")).skip(1).collect(Collectors.toList()), which won't blow up if it isn't.
The entire point of having a pattern start with ^ was so we can write logic like this: if (refPattern.startsWith("^")) { return Pattern.matches(refPattern, refName); } if (refPattern.endsWith("/*")) { String prefix = refPattern.substring(0, refPattern.length() - 1); return refName.startsWith(prefix); } else { return refName.equals(refPattern); } That is, the regex feature is only enabled if the pattern starts with ^, and otherwise its the old glob suffix style behavior. Then existing ref rules named "refs/tags/1.3/*" don't suddenly start matching "refs/tags/1a3/foo".
use stripWildcard(refName)
typo
and the param?
protected constructor was added with purpose not as a mistake.
should we also set myLocationEnabled = true here?
Why is the equals needed here?
perhaps if not has permission?
**USB**
**USB**
Do we really need this?
We could omit the second Integer.
Does it need to be package private? Can't we make it just private?
IntStream.range()
This method returns an Option<DRepresentation>, so the API clearly says it can be null. You must check 'if getRepresentation().some()" before.
we need to test if the target is null. We should use the DRepresentationDescriptor instead of the DRepresentation
to remove
For each?
For loop?
use Arrays.fill instead for loops
eror  -> error captions -> depictions
Creating a new empty Set and adding the correct media ids feels more natural to me than removing stuff from a copied array :). It's not a big deal we can keep this implementation.
Do we want to return here, or maybe we can continue instead, skipping the put to the map? WDYT?
What is this for? Feels like some unintended checked in code?
Probably we should check here for the class loader of the exception class, if it's the class loader hosting the test cases it should be GuardianException, otherwise we should transfer the exception using com.hazelcast.test.starter.Utils#transferThrowable.
is this needed?
please add PageObjectLogging.log method here
log()
Those two methods are similar. Consider using one.
@dalifreire join this with the previous line
it's more natural to use String.format() here
@dmzaytsev This is a confusing design. Why are we changing the Github URI? Instead let's pass a fake request that we can check as originally described in #42.
Windup/Discover/Java ?
To always be safe please use context.getApplicationContext()
this
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
It is not necessary to check value in compressed vector on zero. It is guaranteed that only non-zero values are store. Which means, that we only need to rename each to eachNonZero in CompressedVector class. Please also make sure that MatrixMarketStream uses the proper iteration method. TIP: It should be eachNonZero.
I don't this this is right solution. We don't need to to build and send a message only when there is no particular channel.
RevWalk would be sufficient here.
Use org.eclipse.core.runtime.Assert.isNotNull(revCommit).
I think Assert is not imported and compilation will fail. Also can we test the cases when number of parameter and argument doesn't match?
The value here should be com.example.PrefixPrimitivePropertiesNoJavaType
The value here should be com.example.PrefixPrimitivePropertiesNoJavaTypeSuffix
style nit: no braces around single line blocks
if we don't end up here we already know that the result must be -1 footers must be in the last paragraph hence we need to stop searching as soon as we find the first blank line
I think we should not trim here since this leads to strange effects when amending a commit message with indented Change-Id in the footer, e.g. test Change-ID: Ic4bfb17d790c1250b7bfc22589bfe473d1509151 in the staging view amending such a commit deletes the Change-Id which looks wrong
I think it would be suitable if some kind of padding is applied between messages, such as a newline
What's -2? It should have a psf variable to define it. Is -1 also used somewhere? If so, that should be fixed too. If I did it, I apologise...
POST and 202 CREATED is more appropriate here
I don't think you need this check. Just return size * 1024 ?
Looks like it should be opposite: drain only if new size < oldSize.
etc. for the rest
why do you not do this in DiagramElementEditPartOperation.activate(this); ?
Since we put a log in the app deployment time stating authorizer is null, there is no need for this log.
Session.of is particularly usefull when you don't know the object
Should't we call this incrementEntryRemovalCount? Other reasons can also be the cause to call this remove method like like expirations.
This will fail if the test that creates the account fails.
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
style nit: we don't use braces around single line blocks
This line sets the Item.image field which can be used instead of enabledImage.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
why gone?
this is identity projection, can you use something more complicated like a +1?
Construct this dynamically with a reference to the enum value for the error code instead of hardcoding 28
Given that this method is already dedicated to the audience claim, this change is redundant. Please rollback
use ... between 0 and 100., it's more user friendly
You should not need to call Arrays.asList at all. If the varargs were used instead of a String, it would be an instance of Array which can already be considered a "list". Similarly, if you could go ahead and fix the withAudience method which shouldn't be calling Arrays.asList as well. (same reason). Feel free to do it here or in a separate PR if desired.
foreach
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
1. Please export lines 82+83 to a method 'selecetLabelChanged'. 2. Please call the method also before add the listener.
This should actually return something, no? :)
I think I prefer "Invalid key" as exception message
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
@ekondrashev Same here, let's declare Exception being thrown.
@fanifieiev the same above.
I think that this is not a clear way to reset values to default - I think, that there should be something like: System.setOut(System.out);
can we remove this method and simply have the poolsOfString.take() where this method is called?
<LINK_0> Let me know if you have any issues managing or adding items to the project
It seems Math.abs() is missed. What about negative values? And also please, add {} arround the procedure.apply(...)
After refactoring ACTIVITIES. for(Page page : PAGES) { executePreformanceTest(page.action, page.title, page.displayName); }
Lets use the previous cleanUp method as discussed.
Nit: could be called e1.
Implement this
Don't really need this check which lets you inline the getInterfaces() call into the for
the put will remove the previous mapping
To avoid null checks every time, you can extract to a local variable and use that variable instead. It is safer to do so with fields, especially if they are not final. Here, the field will be final so it's less necessary, but it makes the compiler happy.
extract as a constant
We'll get NPE here if socket is null, right?
Looks like contract of this method has changed.
No need for the double (( and ))
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
why synchonize?
you MUST catch (Throwable) and not Exception, as you do in other parts. Maybe it would be better to have a common utility function to create all the EventLoopGroups in fact running without the native epoll support libraries on the library path make the test fail
no need for a final local var in this context.
nit: wondering if we should use the same IllegalArgumentException if property is missing as with getString. Seems like we always encode a default.. I am not terribly sure which is a better model, but this will keep it closer to existing behavior at the least.
Arrays.asList().stream() can be replaced with Arrays.stream()
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Why is this here with such a wide exception type?
constant
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "StringBuffer" by an unsynchronized one such as "StringBuilder". [![rule](<LINK_1>](<LINK_2>
likewise, this one can be static
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
Minor, but looks like this was for debugging and should be removed.
superfluous this
Note that I asked one of the authors of the "one sql to rule them all" paper. The only reason that they use wstart and wend was because of the layout for a paper. I got suggestion to use window_start and window_end. I also believe in a JIRA or an email (sorry I cannot recall which one it is) we agreed to switch to window_start and window_end. So I will suggest we keep window_start and window_end, which can be understood easier than wstart/wend.
Could we use getUploadQueue() here instead of mQueue directly for consistency (like in getNextMediaToUpload() below)?
Will queueSpinTake() ever return a null?
Should we still take maxPendingTasks  into account ? int remaining = Math.min(maxPendingTasks, taskQueue.size());
mixing tabs & spaces
This test data is a bit suspicious. createRecord alternately creates mapped and unmapped records, which means some of the records created here will wind up as "mapped/half-unplaced" and others will wind up as "unmapped/half-placed", due to having an alignment start but no reference index. Those are weird states for test data, and its not at all clear from looking at this method whether its intentional. Not that we don't want to test the "aberrant" cases, but we need a cleaner separation between valid test data and invalid.
<LINK_0> ?
the logic would be simpler if you just delete the key for revoked when is null
please use getEntity() instead of runQuery()
Map
suggestion  I would just have this call blockingClose() and move any checks in there as I think that makes blockingClose() and nonBlockingClose() more symmetrical.
It still needs some kind of fingerprint identifier in the message, e.g. just its ID/hash
redundant thisqualfier.
For executors that have a queue, we set the core size to be the same as the maximum size, so setting the maximum size should also change the core size. Maybe we also need attributes for the queue size and the maximum queue size.
yeah, I think definitely add a numberOfHosts field, that's @Value.Derived on each of the impls.
Where do the constants10 and 20 come from? it would be better if they were final items in the class with meaningful names.
Can we deprecate one of getURL or getUrl, and have the deprecated one call the non-deprecated one?
Here I would follow another approach, you get a ZIP file, and you interested only in its content, the schemas data directory providers I described above are the ones responsible to provide the location to store them, we got a ZIP or a file, we clear the current schemas directory content and drop the ZIP output or file in it. When handling the ZIP file, it may happens that the user ZIP the schemas as root or a directory, we shoudl vouch for the two use cases: 1. we have a directory inside a ZIP, we use the directory content 2. we have files as root inside the directory, we use whatever is there
1. Did you mean support only Firefox for _testing_ right? I assume the difference in behavior affects testing only? In that case we should keep the production code clean and apply any workaround in the test code. e.g. do an if-else based on WebDriver. 2. Yes, I think at some point we stopped using Chrome for testing. There are many other quirks between the two versions that gets in the way of comparing html. We can check if anyone is using Chrome.
Mock this also.
You need to create own exception, when requires to change the default behavior. Please use a standard one for your use-case.
can you break up the long line?
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
I don't think we use final for functions in our code base
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
replace with fType.add(DescriptorType.STRING); the idea with EnumSet is that as you see values you just add() them to the set, without having to care for the current contents. Then when reading you can check things like contains(), or the utility methods like isNumer() proposed above.
Need to implement
We need to have a backup plan here if type isn't a TypeVariable.
Collections.EMPTY_LIST
Not sure why we allow null for the event list when the monitor gets cancelled, but not for the link list?
Would Collections.unmodifiableList(submodels) be better in this case?
Even though it's java there is no reason for trailing spaces
return tid instanceof Number;?
whats special/the problem with those bundles?
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
Replace with Util.threadLocalRandomUUID()
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
we want to print to ex with the stracktrace, so do LOGGER.error("Error trying to close response", e) instead.
The method name for handleScheduleTask suggests the method deals with scheduling a task. It looks like something like handleScheduledTask is what actually happens.
add some message info
why do you deregister the trace?
Don't use fTrace, f prefix is for member variables. You could support the trace properties of traces opened in an experiment by adding an inner loop for traces in getTraceSet(openedTrace)...
{ on the same line
I think it's customary to add the encoding; UTF-8.. IIRC @psiroky went though the codebase a while ago adding missing encoding... might be worth checking.
IMHO we want to return the StringBuilder there... Odds are we will never use the raw string
Possible to use this? <LINK_0>
If this constructor is to be called only by the builder, remove the public modifier
should we have Objects.requireNonNull in these?
This is never going to happen because the if is checking that the period hours is <= 0.
isAbsolute is determined by if it has a scheme or not correct? Maybe use this instead? import com.google.gwt.safehtml.shared.UriUtils; boolean isAbsolute = UriUtils.extractScheme(url) != null;
Will * <LINK_0> * <LINK_1> work as well?
May I suggest this?  int i = url.indexOf("/#/"); return i == -1 ? url : url.substring(0, i);  It only searches the string once, and more important, doesn't duplicate the search argument.
Would prefer a tighter check here. As-is, setting to "no" or "FALSE" or "false " with some whitespace would make the coordinator be an overlord. How about throwing an exception if the property is set, but is not "true" or "false"? Or, at the very least, log a warning.
@ccustine After this line, I would also indicate the service type for the provider: properties.setProperty(SERVICE_TYPE, ServiceType.BLOCK_STORAGE);
Does that work when the test is run from the IDE? There is a test helper TestConstants#getTargetDir which gives you the target dir. If I understoof correctly these tests are also running in container, not quite sure how it would work then!?
Same thing than IntentBuilder.
new ArrayList<>();
can you add a final here please?
Refactor getRoles() and getPermissionTypes() to return the array and construct the response object here since methods don't really need the root as param.
This file would read better if you have handleAction before getGroupJSON() since handleAction is the access point that uses getGroupJSON().
It would be easier to instantly see whats going on if there was a method deleteLayersForProvider() and removeProviderFromLayers() which would be called based on the boolean. After the conditional statements you could call deleteDataProvider() that would return the removed provider. Then you could write the response based on that in handleDelete.
For future PRs, we use /* package */ to designate package protected methods.
These local fields could be declared final. <layout,review
If events is empty, exception will be thrown. Is it expected the caller to catch it?
EINVAL is expected for FileDescriptor.out / FileDescriptor.in. This is only expected to work for descriptors to "regular" files, and won't work if in / out are pipes or sockets (which they are, in some configs. The man-page uses weasel words to say this "EINVAL... or an mmap(2)-like operation is not available for in_fd,".
Use Assert.fail() instead
Due IAE still happen?
![INFO](<LINK_1> 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](<LINK_2>](<LINK_0>
This needs to check if the type is not a Class and throw an exception with a meaningful message. The implicit ClassCastException that's thrown here is unsatisfactory. Also, does this mean I can't use LoganSquare on a List of objects? That's really strange...
You should be able to use the diamond operator here, i.e. new ArrayList<>()
nitpick: _latestBrokerOffsetsFetcher = null; // after shutdown
return Promise just to symmetric with start()...
Why need to cancel the task while stopPeriodRebalance is called here?
Could the uses of "/" here be replaced with Region.SEPARATOR, to remain consistent with the rest of the codebase?
If you remove the parameter it won't be there for the test and it will always pass ;)
Very minor: is it a Lucene query even when using Elasticsearch?
If this was at the PaymentOutcome level it would use  Set<ConstraintViolation<PaymentOutcome>> constraintViolations = validator.validate(telephonePaymentRequest);  and then it could be passesValidationForNullPaymentOutcome and the assertion would be  assertThat(constraintViolations.isEmpty(), is(true));  , but it's not so it should test what the actual constraint violation is (applies to all validation tests). For other validator tests - they're not at the deepest validator level (which in some cases seem either impossible or difficult to do), and there is no general test for CreateTelephonePaymentRequest, so checking for the actual not null violation should be a part of them.
can use Ds3DocSpecEmptyImpl here
Is this for debugging?
Or maybe just the following?  return HashCode.compute(principal,privileges);
Could use Objects.hash()
I think this should be re-generated to be added with the id
> HTTP_API_VERSION [](start = 51, length = 16) also what does the http_api_version mean? :) #Pending
Remove the public modifier from the constructor and remove the null check.
I think we can keep one public constructor with just the mandatory parameters. This will be the most concise way to initialize the object and will work for most likely 80% of users. The Builder will just be for those who want to customize by using the additional option parameters.
You can write this shorter: int size = Math.min(raw.length, FIRST_FEW_BYTES);
Check buffer null.
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
it would probably be more appropriate here, since this is an async command
What is the purpose of this statement?
this "return;" statement is of no use.
Oh, right, that was me. Sorry!
In success response you return json, but when fail - trying to return plain-text. It is not an good idea
I'd go for: return ImmutableList.of("node", "show", "-l", nodeName, "--format", "json")
Why do you need the filtering here?
I'd have this in a different test. I'd also try to fetch the DiskVmElement of a floating disk and assert it returns null.
use getDiskVmElementDao(), please apply to all the dao calls in that class
Note that it would be clearer for this to be marked protected: the class is abstract so this constructor could only be called by subclass constructors.
This toString() is used when printing the query plan. We probably don't want to include the partition values.
Let's please avoid code duplication:  public String toString(boolean shortenTypes) { String type = getType(); if (shortenTypes) { type = shorten(type); } return getName() + ": " + type + " = " + getValue(); } @Override public String toString() { return toString(false); }
@jackyq2015 best to wrap things like this with URL encode as a best practice.
can we use sysprop or something for url?
nit: typo UNKNOWN_VM_VENDOR ?
In previous implementation, we had a different behaviour: all open traces will be updated in case their current time intersect with new range.
how about a single return instead of an if?
you have to get the current range from the new trace manager not from the signal
Multiline for statement should be wrapped with braces.
You should also return the value of GridQueryProcessor.idxCls to null (in case startGrid fails)
The test incomplete, because of two reasons: 1. It always checks empty cache iterators. 2. It doesn't check that we can actually iterate on the iterator() and spliterator() results. See suggested changes below, does it makes sense for you? (changes will made test fail).  IgniteEx ign = startGrids(1); IgniteCache<Integer, String> cache = ign.cache(DEFAULT_CACHE_NAME); cache.put(1, "1"); cache.put(2, "2"); cache.put(3, "3");
Only this check might be enough?
Suppose makes sense to convert value to lower case before comparing.
=
It seems that we are missing the resolved name for the getter case. I was thinking that we would need similar property as for the field to store the resolved name or am I missing something?
this(...,..., LogLevel.INFO);  apply the same pattern to other constructors.
this is pretty loose matching for an xpath - not case sensitive?
Better to return "";.
I'm a little concern about this. wouldn't be better to cache the string too?
I believe that other implementations are either returning an actual String representation of the operation, or the result as String. Could you double check that?
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Should this be implemented?
Should this be implemented?
If the BigDecimal multiplier values were static final class variables, you wouldn't have to "new" them with each conversion, which might be more efficient.
Same question about losing all precision here instead of during formatting %.1f
Better to have private static final BigDecimal constant instead of new on each conversion.
Why not extract assertThat... into separate methods: assertRoutingKeyResolver for example. If the requirement is not fulfilled, a message could be provided to be used for an AxonConfigurationException (I would argue that we could use the same message for both purposes: invoking the build method and validate method).
Extraction to a separate method.
Null values at this point should not be really reported as a property being null, but as a mandatory property for which no value was provided
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
@cristianoperez thanks! it really sounds better as a default value. I'd only keep a fallback strategy for users that for some reason want a new session to be created. for example:  request.getSession(createNewSession()) //... protected boolean createNewSession(){ return false; }  what do you think?
We have a removeConfiguration so let's not allow null value here?
throws RestApiException not necessary.
Variable not need, can be returned directly. And please initialize it with type (ArrayList<GroupInfo>).
neat
Please change to externalSearch =
suggestion return getInstance();
Returns an empty list if opacKatalog is still null (first start of meta-data editor). Fix: String catalogue = opacKatalog; if(catalogue == null) { List<String> allOpacCatalogues = ProzesskopieForm.getAllOpacCatalogues(); if(!allOpacCatalogues.isEmpty()){ catalogue = allOpacCatalogues.get(0); } } return ProzesskopieForm.getSearchFieldsForCatalogue(catalogue); ProzesskopieForm.getAllOpacCatalogues() can and needs to be declared static to do so.
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
Assuming they are all workspace files, this will work.
rename to contribution
change to arg
as we are changing how the digest is computed anyway, we can simplify this as buf.append(',');
Style-nit: Our toString style looks more like DiffEntry[ADD newName] DiffEntry[COPY oldName -> newName score] DiffEntry[DELETE oldName] etc... Please match it here. Of course this is a bit easier, you can do buf.append(type) to get the type part and not have to duplicate the name in both the case label and the string text.
Why MobileSelector.IMAGE ?
try/catch, return ResponseEntity.badRequestSomething(JsonError.of...)
Maybe we want to keep something similar to what id was before
please replace with verify(adminDAO, never()).executeSQL(anyString(), anyBoolean());
Is there a reason we need the executeInternal() method, given we could just use execute() in the executeToX methods?
why delegating
typo "cannot"
Join type check should be consolidated probably in the logical phase
You should not register listeners in a getter.
I think you want to call the new method which gives servers based on glusterPeerStatus
the functionality changed a bit... if runFunctions returns null we shouldn't return...
should be private. Also, move it below the executeQueryCommand() - it's not the "public contract"
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
Storing getClusterConnectionInfo within the ExtensionContext.store would remove the ThreadLocal dependency from the lookup.
use a constant
Vered - Good catch. s/proceeded/processed endAction is being handled only when all tasks for the entity were completed (actually, the usage of the word "all" here is not 100% correct, but let's not get into corner cases :) )
I agree with your point. Good catch. I want Ravi to review as well.
if we already called clearAsyncTask(), wouldn't we want to remove it from the list regardless of vdsmTaskId?
grammar nit: 1, not one, and no :
Here you could use Guava's [checkArgument](<LINK_0>,%20java.lang.Object%29)
You can use checkArgument here, same as <LINK_0>
Just use something like ZoneId.of("+08:00")? convertToZoneId should be removed eventually.
Visible should before start? Actually, why do we want to swap the order to make the session valid? It is totally fine to make use of methods inside TimeHelperExtension to make a valid session. e.g. Session visible from 3 hour ago, start from 2 hour ago, end 1 hour ago and visible now.
Was this needed to fix the test? If so, would an arbitrary timestamp be better than the special timestamp (I don't think the special one is possible in real usage)?
shouldn't actual <--> expected be replaced here as well ?
You don't need to use getStorageDomain().getstatus() != null condition
I suggest to just change the current message - currently it is "ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL" = Cannot ${action} ${type}. The relevant Storage Domain is inaccessible.\n\ which is obviously wrong - I suggest to change it to : Cannot ${action} ${type}. The relevant Storage Domain is in status $Status.\n\ and that would make that message readable without adding code here and would "solve" it for all the statuses.
suggestion assertkeyPair(file, null);  suggestion assertkeyPair(file, null);  suggestion assertKeyPair(file, null);
suggestion assertKeyPair(file, null);
suggestion assertKeyPair(file, password);
I'm not sure about the method name though. Why not "build" like in the state system analysis? Or "buildAnalysisSegments" for more clarity. After all, it is called only if it was not previously saved on disk.
Also here call this() with dependency level of 0
Note that this array will be bound by Integer.MAX_VALUE. Or maybe it will crash, I'm not sure.
Maybe this will already be immutable. And a list.
How is the receiver supposed to know what a blank hole is? Won't CtfTmfTrace receive the holes, is this ok? I think, for now, this method is called only once. Surely filtering nulls won't be worse than redoing the immutable list for every added event.
We could annotate the base method in TmfTrace directly.
Assert.notNull() - just for fail fast, since we really don't support null for this property.
This is a bit too strong. You should perform the verification of the true and false expressions only if the type of the expression is Optional. With the current state, the following code will trigger an issue, and it has nothing to do with optional and is perfectly valid:  public Optional<String> bar(booleab b) { Object myObject = b ? null : new Object(); return Optional.empty(); }  With the following, it should work:  if (conditionalExpression.symbolType().is(OPTIONAL)) { checkNull(conditionalExpression.trueExpression()); checkNull(conditionalExpression.falseExpression()); }
'static' could be added, since it doesn't rely on any particular instance of the class.
The remove method of the ConcurrentHashMap already performs its own synchronization, so the "synchronized" modifier is not required.
suggestion: triggers ->triggerIds
Why wrap an existing Set in a new HashSet? Is it necessary to do the put if there existed a Set already? The Set reference is unchanged, only the Set contents changed. Perhaps it is required to let ispn know for distribution purposes.
I assume these are no longer throwing UnsupportedExceptions because split is something we want to hide (e.g., not have users worry about it at all and make it a no-op)?
Why is this change? Should not this minimally depend on if this table is transactional or not? What happens if we call it on a non-transactional table?
Operation operation = snapshotTable(snapshotName, tableName); if (operation.isDone()) { return; }
@Before / @After could overwrite System.out :-P
This looks like testDataFormat(COMPONENT); Please see other tests for sample
I wonder if the subfolder "with_sample_data" is necessary. Couldn't the test app be placed just under direct?
Can created URL class loaders be cached, it should not be necessary to create a new class loader each time loadDependencies() is called.
Is this needed if the necessary artifacts are available in the launch dependencies
can there be a failure here? enclose in a try...finally?
throws APIManagementException
Formatting issue
caching an Exception?
I don't really see a need for constructing a File object with the path to an URL here, just split it yourself
Is there a constant you can use to replace the ".done" literal?
the batch utility service has a function to remove a done file by passing tin the data file name.
I think we should also perform the reverse operation here if possible: If only the new settings are set, also write the deprecated ones. This does not add much complexity but makes scheduler upgrade/downgrade paths easier to reason about.
Are you sure this check is not already made by the game and replay services? It should be imo. Have you tried removing this and removing the installation setting and the trying to play?
Should we return here?
This is a breaking change.
Our standard convention is to prefix with this for instance members - return this.context
Minor: move init to the beginning after the constructor
why not have the formatting method in UserAgent?
This syntax seems way more clunky
String.format is superfluous
This code involves a potential NPE.
Do we need || configuration.hasErrors() ?
Same here, add deprecation flag.
May be good to include a message for each of these exceptions.
nit: throw new RuntimeException(e); so if this ever happens (unlikely), the error will be more obvious in the test
To make use of a dynamic SSL context for an outbound connection on the server side, it looks like authentication-client configuration would need to be specified with appropriate SSL contexts and match-host and match-port rules. One thing that was mentioned in the description for EAP7-1121 was possibly being able to specify a dynamic SSL context for the JVM wide default SSL context. What would this configuration look like on the server side?
I'm not a big fan of this format. Let's keep things consistent and put curly braces around the throw new CandybeanException
Not sure if BitSet is a good choice here. Although _most_ code uses tags starting near zero, I've definitely written code that creates a tag at at 2,000,000 or so. BitSets aren't sparse like that.
Can be replaced by X.hasCause(): not 100% precise, but will work for this very situation.
Minor: would be cleaner to have an overload instead of multiple null versions.
Why new message stream instead of returning 'this'?
Would be nice to have all operator-specs being created consistently - instead of using statics for some and constructors for others. Also, would be great to do this as a separate clean-up so that it does not detract from the core-focus of this PR
This should instead be this.setJobMetadata(LoggingFilter.OWNER_KEY, owner.getKey()), since the owner is never actually used as an argument in the execute method, and is only used as part of the metadata.
Owner metadata is not being set here
I suggest utilizing <LINK_0> to handle i18n of error message.
Java does not contain the keyword null.
Use branch.getIdString()
Is that "m" in "m%s" a typo?
I don't like this arbitrary limit of 400. Instead, I would check whether the index of the last visible line is lineCount. How about: public static boolean isShowingEntireContents(StyledText widget) { if (widget.getTopPixel() != 0) // more efficient shortcut return false; int lastVisiblePixel= computeLastVisiblePixel(widget); int bottom= widget.getLineIndex(lastVisiblePixel); if (bottom + 1 < widget.getLineCount()) { // There's definitely more lines below return false; } // Check whether the last line is fully visible int bottomTopPixel= getLinePixel(widget, bottom); int bottomHeight= computeLineHeight(widget, bottom); return bottomTopPixel + bottomHeight <= lastVisiblePixel; } That should also be much faster since it would at worst compute line heights for the actually visible lines, and it doesn't need any arbitrary magic number.
Perhaps the two for loops reseting the signal array could be combined. Or you could explicitly set the whole array to zero and then only set the valid values on the loop below
I would prefer to write some explanation why the call is failed.
Oscars began in 1928 seems leftover because of copy/paste
grammar nit: 1, not one, and no :
peices -> pieces?
I would add the case with Long.valueOf (to justify the generalization you made in the code).
With longs it will be just java long id = ++nextId; if (id > Integer.MAX_VALUE) { throw ... }
Strings that are displayed in the UI should not be marked as NON-NLS.
nit: can you put "File connector started" instead?
Optional, but this null could be better. How about defining a SESSION_NOT_SET constant and use it here?
I think we should keep this synchronized.
Same as above, please move this line under the SetViewport line and add an empty line after it.
Please move...
I'd move this above the shader-related lines, as it is related to the FBO instead.
no need for this variable
why is this ^ here?
I think I expect here: if (!persistentAuth) { if (FiltersHelper.isAuthenticated(req)) { so the else will apply only if persistent auth... no? I also would have switch the conditions so you have the positive first.
It seems that we are no longer required to pass the session Id to the event?
Please extract a method for sync.
Still duplicated code. Let's have a single wrapper implement class for the IOItech interface.
Thanks for adding this!
correct, this API is now added in master.
you can use Collections.EMPTY_LIST
nit: make this final
Don't use literals for specific attributes. You could create a class in cdt.core StandardAttributes to contain such string constants (Suggestion P. Sommerlad).
recommend to use CollectionUtil
It would be great to have braces around.
minor: consider using startTimeNs as you did in another method.
This must be supported.
Wouldn't this just be retryContext.tries() and not retryContext.tries() + 1?
Yikes. I didn't see this before. Is it in master?! We shouldn't unwrap ExecutionException like this. It makes it look like the exception happened in this thread, rather than in the other thread. For example, if the other thread was interrupted then ExecutionException.getCause() will return an InterruptedException. Rethrowing the cause make it look like _this_ thread is being interrupted (and looks like the interrupt is being handled incorrectly, because it is just caught and wrapped without marking this thread as Thread.interrupt().
We could replace it by an throwable instanceof RetryDueToResultException
@paulodamaso the braces and return are not needed here
@komaz autoboxing will be used here, but maybe let's make it visible? .intValue() or equals()
probably this is an exceptional situation
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
This is hacky and might be error-prone. Since it is always a leaf node, it makes more sense to parse the string with path splitter "/" and return the last section.
Revert the changes here.
This means if the session is not for students, the closed email will not be sent. But is it a sufficient condition for the email not to be sent? A session might also contain questions only for instructors.
This fragment is similar to the one used in generateFeedbackSessionEmailBaseForInstructors so it would be good if you can extract a method to generate this fragment or use some sort of html template to generate this string to reduce the repetition.
I'm not sure you need this method at all.
After giving it some thoughts, could you change it to use Locale.ROOT? I think it emphasizes better what we want to do. After that, we're good to go! Thanks!
You could just call the other ctor
With compression on, the serializer may always return a much smaller package than the input size. So do we have to fail it here? It is debatable.
I was expectign that we were going to get here the address of the sender not as a string, but as a 64b address. Also, I was expecting that the app was going to display the data in hex and ascii format. Something like this... 0013A200:40AA33C6 -> 89 fa 76 43 23 23 43 56 76 54 34 23 23 34 | hello world! 0013A200:40AA2434 -> bb cc dd ee ff aa 11 22 33 | hi guys ... With the output properly tab and formated
we don't need this anymore
See earlier question.
exactly one sort key is required for RANGE units
For safer side, shall check if entry already exist before adding it.
A more clear approach is to return an initialized reference and set it to a final field, i.e.:  this.annotatedMethods = wrapAnnotatedMethods(delegate.getMethods());  Also the sets should be immutable.
Hrmm, this doesn't seem quite correct to me. Shouldn't it just be something to signify it is a byte array (protostream is more specific)?
I don't think we use final for functions in our code base
Gross! Could you change this to print the warning to the logger instead?
make static
Need more meaningful message
Possible candidate for bind() if that method is created.
you don't need the variable. you can inline
please add (Built-in)
This is a very interesting way of handling this. I'm not quite sure how to feel about it yet, so let's leave it as is and see if it establishes a pattern for general output processing of the Java rules output. If so, keep them all; otherwise I would argue this is probably an expensive way of doing a null check.
Let's not revert this code. The whole "release as an object" thing needs to go away, not be compounded. If this is causing difficulties in your code, let's discuss them and figure out a way to work around them such that we're cleaning this section up rather than doubling-down on the wrapped version string paradigm.
We should use this opportunity to upgrade this to the CandlepinQuery framework. We'll also need to update ActivationKeyCurator.listByOwner, but we'll be able to clean this method up substantially while getting some added benefits like paging and faster iteration.
Newline at the beginning of the string? For readability?
I would prefer "refresh" and "filtered" without the ?
I can't decide if StringBuilder is overkill. Seems like String concatenation is enough. What do you think @christiangoudreau?
same with the return code here, you could return a boolean to indicate success/failure. the user doesn't have to use it, but the API should provide this info. Res: Done, a return type of boolean to indicate success or not
This code should be:  this.channel.close();
Add a new line after the @Override please :)
Why use a full-name import here? I don't see any conflicts.
Typo: s/setPartiotion/setPartition/.
optString does not return null, it can return "null", "" or "value" <LINK_0> and I think it makes sense to move metadata.optString("flow_id") to var since you use it twice.
should this count be parameterized?
We can populate this in TenantManager level?
Suggestion: Keep it long instead of wrapper counterpart
Wanna use another example? It's likely we'll support top-level primitives.
Is this a method to be used in production? Or is it more for developing/debugging purposes? If the latter, we could create the webrequestMap HashMap within this method instead making it a field in the object. It would be slower for tests because we'd have to recreate it with every print, but would be a lot lighter for production (I guess the heap and garbage collector would feel it, given that we create a WebrequestData object for each web request). Also, it's likely that for each webrequest we do only 1 print, right? In that case, speed would be the same. Also, being annoying :P, I agree that we do not need the {"webrequest": <json>} wrapper, just the json object will be fine, no?
assertThat(got, is(want));
Assert.hasText() ?
extract to constant as you did below?
we could factor out a private getBinderForChannel() method given how many times these 2 lines are duplicated:  String transport = this.channelBindingServiceProperties.getBinder(channelName); Binder<MessageChannel> binder = binderFactory.getBinder(transport);
+ desc
Then we can use the name here to get a better description
This description should mention TC and SC, I guess.
Instead of casting the context to CategoryImagesCallback, should we consider actually passing the callback to the fragment ?
Hi @rezita, I think this should be isSHREnabled
Do you actually do any heavy lifting here that needs to happen in the background? If so, why do we still do controller.init() in connectToPlaybackService() which definitely is executed on the UI thread?
I think you should pass the numCompletedIterations to the last parameter of LOG.log().
Inconsistent log format. Use either {0}th or {0} th. {0}-th is even better.
terminated = true ?
same question about the list here
@timler I think that we should use do a class comparison using getClass() here instead of doing an "instance of" check so that different subclasses can't be considered equal e.g. a Donor and a Donation with the same id.
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
Variable attributeValue always contains null (see line 24), therefore this matcher will never match.
This line of code is useless.
Add there an example of valid value res:RESOURCE[:CHILD-RESOURCE1][:CHILD-RESOURCE2]...[:act:ACTION[,ACTION]...]
Could you replace the sole use of Guava's Files in this class with java.nio.file.Files.copy() and then avoid fully-qualified class name?
I think generic information map can be null
Let's make this a constant
Use the API method and pass all given ids as ListInstancesOptions.
...and again... ;-)
This will generate a call to inspect _every_ container, when you're only asking for a subset. Remove this and directly call inspectContainer on the provided ids.
same question as above
Would be preferable for this constructor should reuse the new one (i.e. this(name, durableWrites, replication, false)). Should also mark this constructor as deprecated as it looks like existing uses of it were updated to use the new one.
Please keep this.cell near the related fields (previousFamily & cell count) below
It seems that the logic related to ongoingSyncs has potential concurrency issue. The worker never sends sync reply message if the following scenario occurs: each statement is executed in the following sequence L193 (if clause is true) -> L204 (if clause is false) -> L194~196 (if clause is false) -> L207.
this.notify() would be consistent with L63.
Did you mean if (memoryStore < numInitialEvals)?
Check if inputStream is null.
To be safe you should read the bytes before assigning into data: byte[] d = new byte[len]; IO.readFully(in, d, 0, len); data = d;
I missed this... we should at least log the error if something went wrong
Since the menu item click has been handled, return true instead here.
Instead of finish(), you can just set the parent of the activity in the manifest to MITMainActivity, that way it'll navigate properly to the home activity
Thanks for changing this to a switch! When I originally added the Lite and Premium versions of the app, I had to implement this as an if statement because the R.id constants were not declared as final.
Maybe better to return null
What about data type here?
skipOnly is named terribly wrong. However as long as it means "continue search only when", you should _not_ modify this if.
Please use Collections.unmodifiableMap(metaDataQualifiedNames) here.
Also, it defeats any synchronization attempts. Returning a copy might be an option
I guess I'm out voted on using this. :-(
why? let's format it properly, it was ok before. annotations and method definitions on different lines
Should we let the validation query be set as a parameter?
i think we should just always use a validation query
Why is this behavior changed? It used to be NOT waitForWrite, but now it waits instead. Is that true?
Does the loadMaps keep on failing if it spans a trim, or does it just load partial checkpoints?
What if the implementations of release changes from no op?
rename to p, prop, currProperty
The default value of fail-on-missing-field is false, should set it to true.
It's better to put the value at the end rather than delimiting it: java "Duplicate property: %s"
Are you sure you pushed it?
I think we might want to pass an actual dummy value here rather than null. Although we allow the column in the database to be null to account for the fact that we did not record this data in the past, in the future we should always record a user when we create a refund, so there null will never be passed to the constructor. I think it would be clearer if the test reflected this.
Missing CAD.
same question
Use Optional here to avoid NPEs for caller, I think we introduced an option at some point, ask Edgar pls
nit: The ordering on the factories should be consistent (i.e. install/runtime/environment, or install/environment/runtime). I generally prefer install/runtime/environment as this is closer to internal server framework's ordering
create a buildServingTrucks method or something similar in the TruckEntry class instead of doing it here
Might be good to put these two lines in a transaction. No sense making an expensive operation even more expensive...
As an aside, you can pass a boolean here. Also in content values. They get converted correctly. No need to change it though
mmm, i think this whole method should just always true. an I/O problem and all the other things are different from not being able to handle the request.
nitpick: try to avoid using var++ if you aren't then going to use the var being updated in multiple places. In this case var + 1 suffices and tells the reader that you don't care about var being incremented anywhere else. Also, I always get confused by the difference of var++ and ++var. The semantics of var + 1 don't make me have to think at all :)
this could be data.config instead.
delay is already completed.
check if delay is completed?
BiasedEntryWrappingInterceptor is checking if the delay == null. Is it missing here?
Would be great if we can check if the envelope.getOffset() is not null.
nanoTime != epoch millis in nanos.
Why public? I don't see any external calls in this PR.
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
If Lars would see it, he would cry. How could you even think about using StringBuffer in 21 century? (I know, copy/paste).
this doesn't belong here. If we don't have a generic concatenation method available in foundation already, then either use [StringUtils.join from commons-lang](<LINK_0>[]%29) or [Joiner from guava](<LINK_1>
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
[minor] typo, you may not want the period at the end
Just return data.
change it to log.error
Can we throw the explicit exception not generic?
this should be error and use the constant and below
should this be in a finally block to release in the case where an exception occurs?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
throw UncheckedIOException(e)?
There's no operation on SenderInMap, is this line redundant?
ctx.close()
I think it should use Context#executeFromIO and also test handler is not null.
optional: consider returning this from setters to support chaining configuration.
static
can you please use {} for if block. I know the old code doesn't use this always, but in the new code we can do better.
Just asking, should we put it in the map too?
Should me make it default and use Objects.requireNonNull? The logic of the setter is a bit unexpected
Why this "if"? The original code does not work anymore? I should be a direct pass-through of the underlying curves.
Please move to a separate "Polishing" PR.
Please add curly brackets for the for-loop.
Maybe those two should be extracted to constants since they are used in two tests.
try block.
This call is unnecessary for the test - the exception gets thrown in the previous stmt.
It looks like all of the calls to createFakeHeader pass in the same empty metadata and additional columns lists, and fake seq dictionary, so this can be much simplified by just removing those and returning the fake header.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
not needed
This will be a pain for us if we ever want to add vanilla Java support, but we can't really get around it and the problem exists within it's parent class already.
Might be worth having a displayName?
Is this supposed to be <code>return "Bump"</code>?
Implement this
Need to implement
Pretty sure this is a Nonnull field. Just make it a Chest or Empty.
Might give this a shot, if the type parser is indeed fixed?
"Magic" here was just a quick and dirty way to assure modules and stuff are loaded before running the tests - could you check if it is still needed and remove it if not?
We need the group_id as well.
ALLOWED_CANCELLATION_REQUESTED vs ALLOWED_CANCEL_RE
Just putting it out there early in this review that I'm not too big of a fan of LongRunningOperationStatus - it's very long.
Duplicate code, would be better to call with\* method from here
Update this method to also return true if status is HALF_OPEN?
ok, I don't fully understand the class heirarchy in this connector. It's a bit confusing for me, but if you don't want to change this now it's ok. This review is big enough already.
what is this close and open curly brace doing?
Please include the JIRA link in this message and others like it.
This same as next test in terms of logic, since you're not actually testing the "default" min range is used since a min range is set on the annotation.
modify to static import ?
following the change above, i'd expect this one to look as: assertTrue(validate.isEmpty())
where did this go?
Can we throw an exception instead?
This should probably throw an IllegalArgumentException if it is provided a conf object that is not of type StatefulMongoDBRdfConfiguration because the code will not work if that is the case. Throwing an exception make it easier to hunt down that bug.
Should we keep a reference to the Bundle here?
"isSearching" should be a class level string
Would you mind making the "tabList" string a constant symbol since it's referenced in multiple places.
requireNonNull
keep requireNonNull
check for null
please validate ledger id
close should be implemented with asyncClose()
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
package or private access is acceptable since the inner class is private
Lot of repetition in constructors. Extract into private methods.
suggestion this.className = requireNonNull(className);
No idea why, but the loaded_template entry on quality gate has not been removed on my box
select return a SqlStatement on which you can call setLong to safely set the size to compare to
why select the id? It's not used
ArrayUtils.contains(pageTypes, component.getResourceType()) ?
||?
Ds3Element should have an optional constructor that does not require this extra null param
it looks like an universal operation, did we checked if sth similar is not performed in repo already?
Please add back the if() statement. In case the adapter version changes, this can crash.
It would probably be better to use a date parser for this. That way we'd also find problems such as trying to parse the date February 30th.
Should you check .endswith(g.getName())? I find Jclouds prepends 'jclouds#' to the names of security groups it creates.
What if the predicate returns false? Should we throw an exception instead of silently continuing? Apply the same reasoning to the rest of operations in this file.
Don't initialize to empty when null.
maybe it should be in a checkState as currently it would mean that there is a bug somewhere, no point of having parallel sort without a merge
Do you need to support SINGLE? Won't it be replaced before we reach here?
nit: add some line breaks, similar to the original formats. ditto for others.
@override and function declaration must be at same line.
You can do this just using what's built in to Java:  return String.format("Notifications [notifications=[%s]]", notifications.stream().collect(Collectors.joining(",")));  But ImmutableLists toString() pretty nicely, so you should just be able to do this:  return String.format("Notifications [notifications=%s]", notifications);
I don't think we need to call .toString() on objects passed to String.format - the method does that internally.
is uniqueness of channelTypes guaranteed? The former HashSet would have removed duplicates.
I don't think we use final for functions in our code base
Needs a null check. getRawClass() can return null.
Why not java static Builder builder() {  ?
I am guessing your builder needs to have isShared and isAudited set to default values (false) here. Also based on this: <LINK_0> Please add the corresponding docs for the properties here and in other places as applicable.
This method should be static and need not pass this as an argument to the constructor.
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
synchronized?
you don't want to convert the key to string, they can contain arbitrary binary data. We would end up with gibberish in our logs. If you really need a toString() method, maybe just indicate the size of the byte array, but don't print out the data.
log.trace
It seems we have kept these GoraHiveTestDriver setUpClass / tearDownClass? Is it possible to pragmatically control ( start/stop ) embedded server instance? With this setup can we guarantee embedded server instance is up and running before we start executing tests? There can be failures if we cannot have that guarantee.
Not your change - we should actually set this to the saved stdOut - ideally saved around L85 (now L97) System.out
This plays the current, not the next station.
This block cannot be removed.
You should use getSharedPreferences() to access the prefs in a way which is independent of the nightdream package. Derive a key from the key of the preference. SharedPreferences prefs = getSharedPreferences(); String key = String.format("%s_json", getKey());
Why this? Is this an hack to make enum object has a value field with as type the enum itself?
Objects.equals(NONE, modelName) would be more safe.
java return annotatedFieldName == null ? getProperty().getName() : annotatedFieldName
Need to take a copy of the context to isolate it from changes to the global context that may come later. It should be, current style:  this.context = ARQ.getContext.copy() ;
Please do not use ternary form, convert to more readable if then else form.
move this setter on top of methods. then should be all getXXXxxxToken then should be beginTree
Let's remove protected so it's package-private instead.
To follow the conventions of Spring Security, please change to "webClient cannot be null".
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
Shouldn't you be able to replace this with:  java return requestContext.getWebRequest()  If it's unset then there's a bug somewhere.
Should we handle the case where assignMessageId returns Message.NONE ?
side question, but do we really need to check for enabled anymore? should we just deprecate that feature?
Exception should be logged.
You might want to move this into a shared helper method for other tests which need a temp file with random data.
My guess is we should wrap this in an IOException wrapper, since we generally swallow stream close IOExceptions. (The method signature is eating it right now)
This can be done through one call to obtainMessage(what, arg1, arg2, obj)
This can be done through one call to obtainMessage(what, arg1, arg2, obj)
Now that we have more than one message, please use descriptive labels in place of 0 and -1. E.g. private static final int ENABLE_BUTTONS = 0;... DISABLE_BUTTONS = 1.
Just use !secondaryIndexes.isEmpty()?
Let's have this enforce that hasher is the equality hasher.
Change seems unneeded. And actually the unchecked can be removed as well.
Isn't this check is redundant?
this.
I worry that the the name is potentially confusing; size could be interpreted as the size of the batch, in bytes, or the number of events in the batch. My brain went to the first and had trouble reconciling with the code. Maybe consider something like numberOfEvents or countOfEvents?
This line is probably not needed at this point.
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
No if block required here either.
Multi return is forbidden.
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such name. And as a user I would expect them to have higher priority. Maybe it worth checking all TopLevel views first. I would also vote for making a parameterizable method View getView(String name, boolean recursive) and maybe changing only the API calls which are really related to search. Otherwise it it hard to predict the impact of the defaukt behavior change
It shouldn't be there. ProfileView should be shown in onActivityCreated of relevant activities in which we have to make it appear.
I'm pretty sure "" is probably not a Synapse-friendly name either. (Or if it is, it's not a particularly useful one.) Would it be better to just throw on a null input?
I think that with this logic it is possible that: - hyphen become the first char - hyphen become the last char Those cases are forbidden in hostnames.
hey, I'm not super comfortable with "%n" and "%p" as delimeters (It's totally reasonable to imagine that people might have "%n" in their text). Are those directly in markdown? If not, we should talk about how to do this differently
Since this is only used in tests, is there any reason why we can't just have this exception bubble up all the way to the top?
suggestion: rename to output
does this url have to be hardcoded? can't we use the link rendering code we use elsewhere for field links?
this.
More likely meaningless access changes
looks like you don't need these three variables at all. Just use this at line 41?  java List<String> boardNames = TestController.getUI().getPanelControl().getAllBoardNames();  You can probably follow it up with this (not sure)  java assertEquals(boardNames, Arrays.asList(new String[]{SAMPLE_BOARD})
This line could merge with the next line, making the next line return new UID(requireNonNull(v));
this doesn't look like it always compare values of the same type
Repo also should be taken into account during comparison
This is perfect. 2 things though. 1. You need to also add clones of actions in the composite action here. 2. PrepareView should call prepareView on all actions in actionList
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
please remove else, code will be more readable
Minor: same as in other number check, WDYT about checking for the decimal point?
I think this is a break, currently conjure-jersey allows null auth token values. It shouldn't, which is why we fixed it in conjure-undertow, however there are a few projects which rely (or at one point relied) on tokens being nullable. I am generally supportive of reducing friction migrating between frameworks, but we need to be careful about rollout.
More efficient is if (!dups.add(element))
Will need a @since tag.
I'm not sure I like the way it would work. You mean that before every request, I would have to call "login"? Doesn't sound very user friendly.
factory must close its cursor (which is closeable)
This is using scheduleAtFixedRate but task DirectoryScannerThread never terminates.
If this task throws, the reaper won't get scheduled
we don't need to change the Creation classes.
Looks like this field is never read.
Exposing the server stack traces to the client might be a security issue. Better to hide that information.
In the SmartMeteringMonitoringEndpoint I saw the response data being retrieved by a call to the meterResponseDataService. Calling the configurationService here to obtain the response data seems inconsistent at first sight. If there is no particular reason for this difference, I think it might be cleaner if obtaining the actual response is treated alike in different endpoints.
Should make a more proper exception for this get call.
This is an error: We do /not/ want to be sending the plugin class to super as long as we're extending FMLModContainer. Letting FMLModContainer know the actual class causes it to search that class for mod-related annotations.
You can use the EntityTypeRegistryModule instead here.
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
If this is just for test validation, why not verify the pojo instances instead of doing the toString conversion?
Do a fetch following the delete to ensure that it was actually deleted.
returning an empty list by default would be nicer here IMHO, no need for null check on the invoker side.
Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?
Maybe it's worth to return an immutable copy here.
checkNotNull
Could this be a static field?
Would be better to validate the seconds here again, because this is a public API, users may directly use it in JdbcSink.
suggestion assertSignalEventExecutionSet(emptySubprocess.getExecutionSet(), EMPTY_VALUE, NON_INTERRUPTING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptySubprocessEvent.getExecutionSet(), EMPTY_VALUE, NON_CANCELLING, EMPTY_VALUE);
suggestion assertMessageEventExecutionSet(emptySubprocessEvent.getExecutionSet(), EMPTY_VALUE, CANCELLING, EMPTY_VALUE);
UnsupportedOperationException seems reasonable here.
Style issue: @Override shuld be on line above the method declaration
null? why not just a () -> {} ?
I think that to be consistent the result of apply fn.apply(name) should also be checked using Preconditions.checkNotNull but maybe it is not needed?
The equals check is brittle, I think it'd be better to do a check against a query context key. Or alternatively, do something like groupBy does, and use mergeResults to modify the query to remove the post-aggregators. Then, everything downstream of mergeResults on the outermost node (typically the broker) will ignore the post-aggregators. That could be done by overriding doRun in the ResultMergeQueryRunner.
Why not call put in this class for atomacy?
Could change the return type on method to Collection
We might use a NavigableSet instead if a TreeSet is used, I assume.
Collections.singletonList
Please add { } even if its a single line statement.
Redundant double checking of the same key.
why not use @Inject ?
What's up with this last one? Should it be in the finally block?
I believe that many AsyncKTR's can share a single HBaseClient, so it should be 'owned' by the Kiji instead of being shut down here. Let me know if this isn't a clear explanation.
For future PRs, we use /* package */ to designate package protected methods.
This is where you should print a stack trace.
Why not just <code>getSafeParameters()</code> with all logic inside?
Throw exception if there is no Up server found.
Boolean vanished?
I think injectionTarget.getClass() does not make sense here. It will be better to simply pass the IT instance. And the same probably applies to extension. Also I think it would be better to log both the original and the new value for all ProcessX events, e.g. something like: ProcessInjectionTarget.setInjectionTarget() called by {0}: {1} replaced by {2}. What do you think?
fFocusPart can be null.
What is the general consensus around repositories with YELLOW health? Can those still be read?
I suggest removing the try-catch from this method and create another test case to verify that getting a non-existent code system will throw a NotFoundException. The other test cases seem to always expect the codesystem to be not null. This case you will get a nice NotFoundException exception with a nice message instead of NPEs.
Rename prepareSearchCodeSystemsInAllRepositories() method to prepareSearchAllCodeSystems().
Is this used anywhere?
What happens when someone is reusing the same instance, would tableId be overwritten? Can we add a check to avoid this?
remove this. The formatted strings are the same, you can write a method to do the formatting.
nit: move this after catch, so that .success() failure doesn't trigger failed()  T t; try { t = supplier.get(); } catch (TException e) { responseHandle.failed(e); throw e; } responseHandle.success(); return t;
Inline.
It's all histograms from now on, and IMO the per-site statistics should be in core, not extended-statistics (for sync backups too).
Please bring the braces back.
revert this unrelated formatting change
why not use new URI(scheme, host, path, query, null) to make it more clear?
why this is in vmCommand? should be in stopBase command
I did not talked about the field for which starting with "is" does not make sense, like you would not start it with "get".
isErrorIfHostDoesntExist => isNewHost
I think you need some synchronization around modifications to this data structure. If I understand correctly, the Chore will be run in it's own thread, while quota changes would be dispatched from an IPC handler thread.
Seems like this condition is "No table manager found"? Should this log be on a null check for tableManager.getTable?
also same lookup pattern as described before
Instead of the try-catch please use the ValidatingVisitor#getFailureOfSchema(Schema, Object) method. It can be a little bit faster, since it just returns but does not throw the exception, so the stacktrace generation doesn't take time.
Please use a more specific exception than Exception, and rethrow instead of logging.
maybe create JsonSchemaFactory in constructor and set variable as final?
What is the reason for this change?
Same id as in CatalogYamlEntityTest. Presumably doesn't matter because we'll have torn down and be using a new ManagementContext.
Does it guarantee that schema has Children? And what are each children schema representing?
It is generally a good idea to make sure dispose() methods will not fail if called two times in a row. Here you'll get an NPE.
Both lines dealing with the provider should be moved together, following the usual pattern: if (x != null) { x.dispose(); } x = null;
The job of a dispose method is either to free unmanaged resources / memory and to deregister stuff properly so that the object can be garbage collected. Of course you can set all references to null / clear datastructures etc. to help the garbage collector but this is just boiler plate code with little benefits.
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
Maybe extract System.getProperty("testng.timezone", "") in a variable to avoid the repetition?
Mmm actually I spoke too fast, it still fails on the command line...
In the page, projects are sorted by a comparator, so that projects.get(0) may look as a randomly chosen project. The same problem was solved in NewApplicationWizardModel.getDefaultProject() by applying the comparator.
can we avoid this null check and instantiate it on fields directly (+private constructor if we don't want to create it in any other way) - it's potential race condition if we need that for tests we could have it package scoped reset method
Please use atomics instead:  java private static final AtomicReference<Schedulers> INSTANCE = new AtomicReference<Schedulers>(); private static Schedulers getInstance() { for (;;) { Schedulers current = INSTANCE.get(); if (current != null) { return current; } current = new Schedulers(); if (INSTANCE.compareAndSet(null, current)) { return current; } else { current.shutdown(); } } }
we never use NULL, it is a bad practice in general.
If you make the EMPTY_EXPIRES, you could use it here.
Oh please, no! Don't ship a null object! :cry:
You forgot to add the address to the toString() as you did in the patch on the master branch
No need to create a ChangeData here, you just use it in toRevisionActionInfoMap to get a RevisionResource. Instead, pass in rsrc to toRevisionActionInfoMap, and have the other caller in toChangeActionInfoMap construct the resource at the call site.
Optional (and I know we're inconsistent elsewhere): createObject().cast().
How does the deadline in Context set by user? It seems to be harder to track where the deadline is coming from.
Optional.ofNullable could be used?
We could shorten to one line return Optional.of(new Context());
hope it will works here as well for this class
I think it worth adding a field on the template to indicate it is sealed
replace this with a provider: import javax.enterprise.inject.Instance @Inject private Instance<ConcurrentChildCommandsExecutionCallback> callbackProvider; ... callBackProvider.get()
Bad variable name! Variable names should be clear enough. Rename it.
Style fix suggestion public long getIgnoredPlayerTimeout(UUID uuid) {
Don't change these please
@vilchik-elena if you follow my suggestion on file.uri() you'll have to update here as well
String.valueOf
lib folder should be already on the plugin classpath, is it now working? this will not work on all OS because you use file.separator and then you hardcode the file separator in the next piece of string "/". Pass a File instance used to build the path
suggestion
add // NOOP or use the following syntax: new Runnable() { }
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
Please use SecurityUtils.getMessageDigest
Lets not catch the exception and just let the original exception propagate unto main.
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
maybe log an error message here if numConnections ever goes less than zero
@dawnbreaks You don't need to invoke channel close() method.
replace with ReferenceCountUtil.release(msg)
Looks like you are making double slashes here...
@dalifreire is this enough? What e.g about class name?
I don't think you need this new String
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
executor.shutdown() initiates shutdown of the executor and returns immediately, but submitted tasks will still be executed in the thread. There may be tasks still executed after the coordinator is closed. Is that an issue?
Maybe invoke shutdownNow()?
Sounds like a singleton?
My main concern with this is that for users who may not have access to ping v2, this is going to make performance of ping worse by a full RPC. It's not really the hottest codepath so this may not necessarily be terrible, but is there something we can do to avoid repeatedly trying if there is no ping v2?
This method is duplicating logic which is already contained in ZooKeeperLeaderRetrievalService.nodeChanged. I would suggest to factor out a method notifyIfNewLeaderAddress(String newLeaderAddress, UUID newLeaderSessionID). notifyLeaderLoss could call this method with notifyIfNewLeaderAddress(null, null).
I don't think this is atomic.
Why not all exceptions?
Just do this at the root of the database every time so you're sure nothing else is happening: mref.getRoot().removeValue()
not needed
return Optional.of(new Invocation());
nope!
avoid this containsKey
The usage of isInsideStructure should be isPositionInStructure here, the former is used to check if a position is in one of the components of a structure, currently only used by the advancement location predicate. While the latter is for determining if a position is eligible for spawning, with the default behavior being check if the position is within the surrounding bounds of a structure.
use info if it's not an error
Is there a reason why this. is used for calling the setter in all the constructors?
Why not get rid of configurableByScan entirely? suggestion if(StringUtils.isNotBlank(rawUrl)) {
Note to myself: That's the first time I see this method being used in a plugin.
How about setup(Long.MAX_VALUE)? 0ms timeout only works when we use wait(timeout) for checking timeout.
Rather than creating just an ad-hoc instance of NetworkCallTask, is there any possibility for us to use a TaskPool (Implemented using commons-pool, etc) and control instantiating the aforesaid objects?
Not your change - we should actually set this to the saved stdOut - ideally saved around L85 (now L97) System.out
Should also have tests for strong with preceding character content, and following character content. (those are areas where we've had troubles before)
should reverse order as follows: assertEquals("",html)
consider using assertEquals instead, since it's much easier to maintain here, above and below
to be extra careful with the set math, might want to test which capability was deemed to be not allowed
For mocking (even if not now) purposes I would rather have a getJobDao() method instead of explicit singleton call here.
suggestion: Paging fields have been added
uriHost is already a String. No need to call toString() on it.
PageviewDefinition?
mmm...legacyPageviewDefinition?
Why does it return void?
Can we guarantee that Res.get(paymentMethod.getId() + "_SHORT") will always find the translation? If unsure, should wrap in try-catch.
Is this actually possible? Under what circumstances?
simplify: return ...
The upgrade method should run all changesets from liquibase-master.xml...
simplify: return ArrayUtils.contains(...)
These can all use ~~milestone::isSelected~~ PickerLabel::isSelected.
Rather than call this with an optional, we should check here if it's present and call/not call it here.
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
why is this public?
remove 'throws IOException'
isn't used...so perhaps do not set?
"notation".equals(resource.getURI().fileExtension()) to avoid potential NPEs.
Again, I don't see anything wrong with the existing use of implicit casting. It's much easier to scan.
reportservice
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
Why add this here?
I guess we can't predict the optimal size to initialize the ArrayList at this point?
suggestion @Override public GridCursor<Row> find(Row lower, Row upper, BPlusTree.TreeRowClosure<Row, Row> filterC) { assert filterC == null; return find(lower, upper);
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
Yikes. Why not just new ArrayList<>(getImages()) ?
Is it worth having null checks?
What is the purpose of this conditional?
Can't we just log in DEBUG otherwise ?
Since the data set is the same for JobRecoveryTest (and because it is interesting to always test both JobRecoveryTest and NodeRecoveryTest on the same data set), maybe we could share this data set through a dedicated class, for example RecoveryDataSet?
nit: The keys should probably be constants, for consistency with the other tests? Alternative is changing everything to this style, but I think the later tests which use these as keys into a maps should have them as constants
nit: UnaryOperator<Transaction> across the board might save a bit of repetition
Shouldn't we propogate this exception?
Again, perhaps I don't understand the Java API, but IIUC client.flush(...) is explicitly telling ES to flush all memory associated with an index to storage, and that ES tries to do this automatically. If we have to do this, then commit() is definitely the place to do it. But is it really required? Do we want to force a flush to get the durability of the write to disk?
throw exception
For loop?
We're on Java 8, so: IntStream.range(start, start+length).toArray()
nit: what about java nulls[i] = i % 7 == 0  ?
Same here. Simple call to filter() is more readable
This may look better in functional form
why the leading { ? typo ?
Don't we need to the close the streams?
antipattern: using getBytes without character encoding
pass the whole exception to logger.errror
This should probably be java if (CliLogger.ROOT_LOGGER.isTraceEnabled()) { if(satisfied) { CliLogger.ROOT_LOGGER.accessRequirementSatisfied(toString()); } else { CliLogger.ROOT_LOGGER.accessRequirementNotSatisfied(toString()); } }  The toString() may be expensive.
i think the line below should be replaced with log.trace(addPrefixToLogMessage(arg0)); in order to justify the log.isTraceEnabled(). (as should have been added originally when addPrefixToLogMessage() was introduced in this file)
Do we need two debug logs here?
It turns-out this is not permitted. I now get an IllegalArgumentExcexception, saying high watermark has to be higher than low. I will add a small high watermark buffer, then.
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
I would prefer if int bufferSize is not a property of AbstractEmitter, but instead make it a property of BatchEmitter only. Then the SimpleEmitter can implement getBufferSize() as return 1 and the BatchEmitter can implement it as return this.bufferSize. I would even consider raising an exception if you try to setBufferSize on the SimpleEmitter. (I appreciate this has nothing to do with the current issue)
settings - > keycalok/settings?
Isn't pattern should be /user(/password|/)?$ ? (add extra $ a the end)
Since we want to throw unifrom Candlepin exception from the filter, I think better approach will be to create JAX-RS PreMatching filter and not use ServletFilter here. Then we can use SuspendException that will be handled by ExceptionMapper
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Nit please alphabetise.
please leave it that way - it's intentionally referencing the deprecated version.
Would it be better to use the getEndpoint() getter and thus maintain the access to the endpoint in one place?
sequence.getAndIncrement() should be rendered in hex
Can we introduce shutdown() to the _PartitionDiscoveryThread class. shutdown method can call the thread.interrupt() or any other mechanism to shut itself down?
should we make this 200 configurable?
seems this is the only place _runningTasks is accessed with synchronized. Maybe it's not needed given we're using ConcurrentHashMap already? Or we should add synchronized to onAssignmentChange and createKafkaConnectorTask too?
Please do *not* leave authorization turned off across test methods. This can result in unexpected behavior. It should only be temporarily turned off to create (or delete) test content.
Again, needs a context.restoreAuthSystemState();
it is more useful to test that the item is still here after a failed attempt to delete it
These checks would work better in PartitionHandlingConfigurationBuilder.validate(), logging warnings if the merge policy is ignored. Although I'm not sure the numOwners > 1 check is really needed...
Interesting wrapping style :)
no longer used as well.
getUsername().isEqual() make the same thing ?
You're getting a collection here, so just return those. No need for a wrapping response entity
Is it possible to create a ticket without async=true but with a ListenableFuture as a return type?
WithTasksContext
Why are class properties of parameters class set here? If this is something that is never filled by the calling side to the command ,why not define them and use just inside the command class itself? It can be confusing to the caller to see this object and wrongly conclude he needs to fill those parameters. If there is actually a need to fill those parameters from outside, then there are wrongly overriden here, and it's better to have a validation + appropriate error should be thrown if they are missing.
the validate() method should be updated to support that case, for example, space on the target domain shouldn't be checked (we might fail on it)
Is not safer to use Locale.US instead of ENGLISH ?
You are comparing java.sql.Date and java.util.Date here. What does it mean?
this is 12/21, not 11/21, a minor issue, but better to change it
That's not the correct message. The message should be: "Url cannot be null". And while you are at it, I believe null in the following two parameters is an error also.
We can do disruptor().setDefaultHandler().handleExceptionsWith(), so, maybe, not "mixing", but something like "callToDefaultExceptionHandler is not supported and useless after exceptionHandler has overridden by EventHandler specific ExceptionHandler using handleExceptionWith()"
minor thing, but this doesn't need the throws clause
for consistency with other classes, use Objects.hash()
We could make these less verbose by using Guava's Objects.equal and Objects.hashCode utility methods.
You could implement hashCode in Scale
This is breaking the existing conventions about allowing nulls. If we ever receive null inputstream we should throw an error here. To avoid them, we should change the calling site, not these utility methods, which operate under narrow set of constraints. suggestion
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
I am not sure we need to make the FileWatcher here thread safe. I think it is perfectly fine if it isn't thread safe.
Can we return a copy of the graph instead of a reference? There's also no point in using a read lock when returning the reference. I'm mostly worried that callers may alter the graph in some way.
should this be 3.5?
This supplier is potentially called twice, so the same data is fetched from the DB twice. It would be better to use MemoizingSupplier here.
how about to move line 439-441 to be before line 435 - not because of performance but to make it more clear that in this case we don't need the cluster version
pls. use Collections.emptyMap() instead.
You should be able to use the diamond operator here, i.e. new ArrayList<>()
Size the result list properly : final List<Object> result = new ArrayList<Object>(list.size() + 1);
entryId is not used, please remove
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
Here is another use of sorting via TreeMap. It's just a debug method, but I don't like the functionality change
I'd suggest we also log/throw an error here if anyone attempt to rename a permanent group. That way if the UI layer (or any caller) makes such an attempt, it will receive an error message in return, instead of no response.
Putting a cleanup here may result in weird behavior, since the interpreter.exec(pythonFunction) will no longer be called at each processElement
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
Typo? getTopologyMap -> getFaultZoneMap. And getFaultZoneMap throws an IllegalArgumentException when "The fault zone in cluster config is not defined" - it seems to be client error. Would you consider catching the exception and then returning a client error, instead of a server error. I think it'd be better to differentiate a client error and a server error.
this constant at least should be refactored into a field to avoid duplication here
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
i'd add "perform"
getMessage() and debug trace?
maybe proceeding with an inconsistent snapshot
If exception happens, the ByteArrayOutputstream will never close it. Please move it to final block.
- please remove TODO - please use propper logging instead of using printStackTrace()
Lets re-throw this as a RuntimeException instead.
maybe we could query this somehow from JobManagerMetricGroup but I am also wondering whether the JobManagerMetricGroup registration/query code belongs to scheduler and not to a separate e.g. SchedulingMetrics or so component.
Either hasNumberOfValues ? numberOfValues : 0 or add verify(hasNumberOfValues)
You don't need to make a variable here since you're not using it again. You could just do <code>new PhoneNumber("21234567890").getNumber()</code> :)
@ztravis synchronized scope, can be more smaller, like below.  private final Object getDateFormatLock = new Object(); public DateFormat get() { DateFormat dateFormat; synchronized (getDateFormatLock) { dateFormat = (DateFormat) threadMap.get(Thread.currentThread()); } ... return dateFormat; }
As this and other formats are not implemented yet, throw an exception instead of returning null value.
May or may not be necessary to e.getMessage() as well as , e ... you're going to get the message duplicated in logs.
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
The SSLContext should be exposed for configuration so users can set the keystore, truststore, protocol, etc. TLSUtils has some examples for doing that, used by SSLContextProvider for the internal HTTP client
reopen -> open
would be nice to try a few different configs here... like localhost, localhost/, localhost:9999/, localhost:9999, localhost/ .... maybe make the test do foreach(String zk : new String[]{"localhost", "localhost/", etc}
what about case clearTable = true and clearZK = false
why twice?
return queryId
![MINOR](<LINK_0> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "instance". [![rule](<LINK_1>](<LINK_2>
instnaceId -> instanceId
Why don't we just set the memory usage with the setGeometry call? It's easy to miss setting the memory usage after setting the geometry.
I modified the test to ensure that if intersects is symmetrical and the test failed with NPE:  @Test public void testIntersectsOnGeometryCollection() { assertIntersects("GEOMETRYCOLLECTION (POINT (1 1))", "POINT (1 1)", true); } private void assertIntersects(String wkt, String otherWkt, boolean intersects) { assertEquals(OGCGeometry.fromText(wkt).intersects(OGCGeometry.fromText(otherWkt)), intersects); assertEquals(OGCGeometry.fromText(otherWkt).intersects(OGCGeometry.fromText(wkt)), intersects); }  Here is the failure:  java.lang.NullPointerException at com.esri.core.geometry.RelationalOperations.relate(RelationalOperations.java:45) at com.esri.core.geometry.OperatorDisjointLocal.execute(OperatorDisjointLocal.java:31) at com.esri.core.geometry.GeometryEngine.disjoint(GeometryEngine.java:376) at com.esri.core.geometry.ogc.OGCGeometry.disjoint(OGCGeometry.java:275) at com.esri.core.geometry.ogc.OGCGeometry.intersects(OGCGeometry.java:280) at com.esri.core.geometry.TestOGC.assertIntersects(TestOGC.java:1007) at com.esri.core.geometry.TestOGC.testIntersectsOnGeometryCollection(TestOGC.java:1001)
This error message is confusing. Should "Geometries" be possessive? Also, should "References" be plural? And why is everything capitalized?
Should this check Collection as that is the super type for List and will capture Set, Queue, etc.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
Do this check in the constructor instead (or a static factory method). You'll want to be careful in how you calculate the baseType and you'll definitely want to throw if you can't find a baseType for which all elements are coercibleTo. You basically want to find the common base PDataType. Something like the first loop in CaseExpression:  private static List<Expression> coerceIfNecessary(List<Expression> children) throws SQLException {
Having users of the method forced to wrap the parameter into Collections.singletonList, I am thinking, why isn't there an overloaded method with , ... BibEntry entry added, which alles Collections.singletonList internally? -- Reasoning: There are more callers than callees, thus make it easy for the callers.
Constant for default config file name already defined in Config class
please use already defined constant for default config file name
minor: I personally think that 'this' is redundant here.
This should be synchronized.
I am concerned about this method. Isn't an exception generated if next() is called and the set is empty? Also, I see an unlikely but possible infinite loop if none of the MetricsMode.isAvailable() methods return true. I wonder if a less compact but somewhat easier to read method could work:  public MetricsMode toggle() { MetricsMode startingMode = getCurrentMode(); while(modeIterator.hasNext()) { currentMode = modeIterator.next(); if(currentMode == startingMode || currentMode.isAvailable()) { break; } } return currentMode; }
Return all of them
Are these isDebugEnabled checks necessary?
I'm missing a test for setting the branch from the URL into the generated project.
putIfAbsent or use synchronized block
What if dataGeneratorListMap.get(topic) returns null? (It could be null because of unsubscribing)
This looks suspicious. If it didn't work in the two lines before, why should it work here?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
maybe test first char for empty letter as well to reuse s if possible?
java @Rule public TemporaryFolder tmp = new TemporaryFolder();
other than the previous implementation in subclasses this doesn't create the directory anymore.
Do we need to make sure these file names are also Windows-compatible? If so, we should include a few more characters to the list. - Linux/Unix: / (forward slash) - Windows: < (less than) > (greater than) : (colon - sometimes works, but is actually NTFS Alternate Data Streams) " (double quote) / (forward slash) \ (backslash) | (vertical bar or pipe) ? ( question mark) * (asterisk)
perhaps a switch on severity.toLowerCase would be more readable?
Hasn't this bit of code been done elsewhere as well? Worth moving into some utility class to reuse, in case you ever want to e.g. add y or n to the list?
I wonder if adding actual "bad" value to the error message would count as a security violation. I think adding the value explicitly would simplify the debugging. Any thoughts?
I think this message can be reformulated to be less confusing. That's not really clear where which id is supposed to be. And yeah, pay attention that exception could be exposed to users. Then maybe something like User ID does not have permissions assigned to devfile ID
this block looks NPE fragile. Do you think it would make sense to catch NPE and rethrow with some meaningful message? Or check potential NPE places for null ?
@jjl014 User id is optional, unlike client id and session id, which are required for user info
Assertion seems to be missing?
I must admit that false to me carries little information. Maybe a constant with READ_ONLY in the name could increase the readability.
I assume it's false because you expect the Permission schema to be populated?
Dont use toString(). Our convention will be use the enum's name() function. Also please change the previous one.
Log statement here to catch missing/duplicate invocations of this.
Can we make merge into a static method on the implementation classes? Something like  java public static Configuration merge(Configuration ... configs) { MapConfiguration mergedConfig = new MapConfiguration(); for (Configuration c : configs) { for (String key : c.getKeys()) { if (!mergedConfig.containsKey(key)) { mergedConfig.setProperty(key, c.getProperty(key)); } } } return mergedConfig; }  That way each configuration would be trumped by the one following it.
Unnecessary this.
you can compute principals in constructor and store in field.
At some point I would like to change this, it is not critical for this pull request but I prefer a pattern where the code within the privileged action is also used for the non-privileged case. I did find a bug a while back where code that is split like this had diverged so you ended up with a bug only once the security manager was enabled.
null and empty API key should throw
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
what is the purpose of this line?
This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?
This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
do not log errors from a util class. Rather throw an IAE or log as debug, if expected and not critical.
Shouldn't appId and SecurityToken values be URL-encoded (or any URL parameters that could potentially contain illegal characters elsewhere in this source file)? I see the default app ID has / and + in them, for example. The appId might be only accidentally working at present.
handle exceptions properly with useful messages of each exception. (This was covered during the code review)
Create a new subclass of Exception instead of using IOException here, since it's not an I/O issue.
Should be !socket.isValid()
I guess this could be public as well? Might be handy in certain places, so one don't need to get the binder separatly.
I doubt this assumption is really true for all tree leaves. There might be leaves that are by definition containers, e.g. dynamic tests.
for single lines, we do not want to have brackets
There are utility methods in graph operators to get the kind of an operator invocation.
what's the point of doing this?
add non null validation
doesn't seem needed any more?
Nit: this could be: absoluteUri(DHCPV6_HOSTS, clientId)
A Repository can be opened through the RepositoryCache or in a standalone way. We cannot change the close method to not close otherwise we will affect the standalone use case. The repository will never be closed because evict will not be called in standalone. I see 2 options here: Repository opened through the repository cache could be wrapped in a class holding the usage counters (useCnt and lastUsed) and overwrite the close method to do the logic done in evict method. The problem with that approach is that wrapping repository in not possible when repository is added to the cache using the register method. For this solution to work, we would need to remove the register method (and break backward compatibility). Another option is when repository are opened through the RepositoryCache, we leak one usage counter(as it was originally implemented) so useCnt=1 would mean that repo is not used but still in cache. In the therminator thread we do: Runnable terminator = new Runnable() { @Override public void run() { try { for (Reference<Repository> ref : cacheMap.values()) { Repository repository = ref.get(); if (repository.useCnt.get() == 1 && (System.currentTimeMillis() - repository.lastUsed.get() > 20000)) { RepositoryCache.unregister(repository); repository.close(); } } } catch (Throwable e) { LOG.error(e.getMessage(), e); } } };
A possible problem with this is that it relies on the zoom thread, and you might have an implementation that does not use any zoom list or thread (could override createZoomThread() to return null). Also, it's not clear what value the flag should have if you have completed the zoom with an empty entry list, or if the entries are all filtered out. Does it work if the build thread has done a first iteration and called refresh() but hasn't discovered any entries yet?
Am not sure whether this way of count based thing also correct. Like say 2 times req roll happened before the actual rolling thread picks up this work. Effectively we need to do roll only once right. Even if 2 or more times being asked. But now as per this change it will try do roll again and again. So a boolean based thing is enough What we can do is make the requestRoll being synchronized and within rollWal have a synchronized block where you can reset it ad then go ahead with actual roll call. Or we just need an AtomicBoolean only?
s/isUserSelectVolumeType/isUserSelectedVolumeType
the "if" statement above seems to be unnecessary. Please remove it.
please check getStorageDomain().getSelectedItem() for nullity - iirc, can be null in case storage domain is in maintenance.
As a safety precaution, should we make this assignment just once to grab only the very first line number in case generated synthetic lambda method contains more than one line numbers?
consider being paranoid and prefix with "line.length() > 0"?
While the code here makes sense, I think it's not normally how the rendering code is structured. Something like the following is more common:  line("private ColumnSelection optimizeColumnSelection(ColumnSelection columns) {"); { line("if (columns.allColumnsSelected()) {"); { line("return allColumns;"); } line("}"); line("return columns;"); } line("}");
I'm assuming this constructor is combining the two maps? If so, didn't we just get the jobCoordinatorZkBasePath from config? Do we need to add it back again?
Any metrics we are expecting to report the CoordinationService? Seems it's only used by the application runner. If that's the case, we don't need any metrics so far so we should support pass in a null metrics.
It looks like you already call init in the shared constructor. Please call it only once.
Check for the existence of the file to delete?
The method can be static, and the "standard" implementation is: return PlatformUI.getWorkbench().getDisplay().getCurrent() != null;
As we are testing the method checkAccess, we cannot mock the carbonSecurityManager class. We need to create a real object of the carbonSecurityManager class and call upon the method.
missing @Override declaration.
Should be "InstaPost" actually.
If you have commons-lang3 in your classpath, you can use ToStringBuilder
This is another behavioral change that I don't want to see in an unrelated PR.
what if my value is " " ? should use trim
space
To improve, I think .warn is better.
Possible candidate for explicit IllegalArgumentException if invocation is null.
Possible candidate for bind() if that method is created.
any special characters to block in webhook name?
@Restricted(DoNotUse.class) wouldn't be a bad idea.
Catching a generic Exception is poor practice.
this must look at both request and session.
Sam as in the production code, matching on comp=blocklist seems redundant when matching comp=block?
Always called with (null, null) - so method and URI is never taken into account?
Nitpick: update variable names too, here and elsewhere.
This can NPE if commandLine == null.
Copy-paste error? Shouldn't this be "new MergeExample"?
Why is this loop necessary? Don't you just need to click a single element? However, I could be wrong since I'm not 100% sure what is being checked.
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
should this count be parameterized?
Hey, So it was definitely intentional before that there was a version of this function which *didn't* try to append domain credentials. If you've audited and it's clear that we never used the domain-less version, fine to remove it, although I'd change the name of this function to something that makes it clear that it's doing double duty (IE: Creating the basic auth credential string *AND* mutating the username to attach domain data). I think in the context it's used, it wouldn't necessarily be unambiguous that the username you pass in here isn't the one that's going to come back out, and am worried it'll be a source of future errors.
We don't return ResponseEntity, we ONLY return SimpleObject
throw log.xmlFailedToCreateCredential(e);
I think this should throw an exception instead of logging it. Otherwise, it would only be visible in a log that something was silently ignored.
@szczepiq Would you mind using the ExpectedException rule, this would improve the readability and avoid try/fail/catch blocks which distracts the reader from the test case IMO.
Use size of pruned for the array.
Feel free to ignore: Do we really want these this there?
how about to move line 439-441 to be before line 435 - not because of performance but to make it more clear that in this case we don't need the cluster version
should this be 3.5?
please keep the body of an if on its own line
suggestion return prev != null && !prev.nids.equals(nids);
is "id" Core.ID?
make the constructor package private instead of private to avoid going through a generated synthetic constructor.
Maybe its just me, but this calculation looks wrong, since we are assign a = b, then b = a % b will always be 0, since a = b. Shouldn't it be: long c = b; b = a % b; a = c;
I don't think this equals test is necessary
Another access change API violation, same a little below. If not needed then lets not change it here :-)
This method doesn't clone the extra components nor the formatting
Could you please replace event.getTarget with a variable to make it clearer
Multi return is forbidden.
Why do we need to do this. The Empty view should always be there
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such name. And as a user I would expect them to have higher priority. Maybe it worth checking all TopLevel views first. I would also vote for making a parameterizable method View getView(String name, boolean recursive) and maybe changing only the API calls which are really related to search. Otherwise it it hard to predict the impact of the defaukt behavior change
i'd add "perform"
getMessage() and debug trace?
maybe proceeding with an inconsistent snapshot
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Looks the same as Predicates.equalTo(0)
indexii? perhaps indices?
Why put at i-1? Wouldn't it be more natural to use i?
Recently, @yingsu00 removed all of the uses of the related form of getUnsetBits to not have an isNull vector. Her change had a good effect on memory pressure, and in some cases increased performance. I suggest we use the pattern she introduced in this new code.
nit, I think this can be simplified like this: java return Arrays.stream(line) .skip(1) .filter(component -> !component.startsWith("--")) .findFirst() .orElse(null);
Is ... depends from onTheFly parameter?
Should we use a more readable name dijkstrabi_no_sod?
Small typo: YubiKey? I think The K is capitalized elsewhere as well.
Cosmetic: You could extract Optional.of(artifact).map(a -> a.getHierarchyParent()).orElse(artifact) into a private method (i.e. private getArtifactHierarchyParent()?) and re-use it in removeArtifact to avoid possible future issues when this logic needs to be changed (i.e. forgetting to apply the same change in removeArtifact)
This asserThat will do nothing - you need to add something like isTrue()
Why setting the distro classifier?
This 4 lines be made into one line.
extract as constant?
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
I wonder if this does not already do the job done in the following for block ?
I don't think that it makes sense to add such logic with coordinator field here. The matter is that who is the corrdinator depends on the order of adding resources, and, unlike the case when it happens in the table, you don't see the effect.
We should handle the case where getDAnalysis() returns null
Same as above: .getAllOfTypes(new VDSType[] { null });
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
We need to have a backup plan here if type isn't a TypeVariable.
It is still public. Why?
This isn't really that performance-sensitive
I am concerned about this method. Isn't an exception generated if next() is called and the set is empty? Also, I see an unlikely but possible infinite loop if none of the MetricsMode.isAvailable() methods return true. I wonder if a less compact but somewhat easier to read method could work:  public MetricsMode toggle() { MetricsMode startingMode = getCurrentMode(); while(modeIterator.hasNext()) { currentMode = modeIterator.next(); if(currentMode == startingMode || currentMode.isAvailable()) { break; } } return currentMode; }
Immediately return the value here
What's "c"? Can we unabbreviate it?
I think you should also have if (c == null || c.length < 7) return; or else we'll hav an NPE
Might be worth having a displayName?
Is the  added here intentional?
Small typo: YubiKey? I think The K is capitalized elsewhere as well.
Adding this to a field is good manner.
Constructor needs to be private
nit: use capital 0L to make IDE happy
consider implement IntermediateResultPartitionID#equals(...)
looks like unused codes. please remove this
No need to download the dataset.
Perhaps we could look into making the deserializer more flexible with respect to encoding issues (just like it can be configured to accept unescaped tabs)? I have not checked if it is possible though.
maybe rename to FallbackableValuesWriter to make a distinction between the fallBackWriter and the writer that could fall back?
This should not call log.error(t). It should return ExceptionUtil.getStrackTrace(t);
this.m_
Assert.notNull() ?
decrease to TRACE level
Any reason this became package private? This seems necessary to continue a paged response set.
No magic numbers please. Can we move it into a constant and give it a proper name/description?
Seeing them in context, this validator class and the associated step should be renamed to FileLoaderStepXXX for consistency.
do most of these need the try-finally blocks (instead of only closing afterwards)? if there's an exception in these tests, does it matter if the file is closed?
log the object id as well.
Re-use temp file
This seems like a good use of ordinal since it's lifetime is expected to match app session.
Should we call super?
It seems that dialog.setArguments(args); is missing here.
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Please change this to  java return new ArrayList<>(failures);
ontology.listClasses().toList() always returns a list of size 0
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
just use LgoAdapters.adaptOrderBook(orderBook, currencyPair) directly
If we are not implementing, can we throw upsupportedoperation exception ?
I think we should not care about this situation (neither here nor in Excel) - if the file does not exist then we are not running any risks of overwriting existing data. So we should probably also name the configured property like that - instead of "overwriteFile" it should be "overwriteFileIfExists".
s3n is an older, but still supported scheme. should allow it too.
Typo: The file already EXITS :) I would also be more explicit in the message: "The file already exists and the columns selected do not match the existing records"
Hey Xabi, can you use an atomic boolean to set whether or not the ad closed? This prevents a situation where onAdClosed() is called multiple times and forwarded to the publisher. Similar to what we did on rewarded: <LINK_0> Please do this for both the OB and non-OB interstitial adapters.
onVideoStarted() should also be invoked here since you are also calling onVideoCompleted().
onAdLeftApplication() callback is missing for Interstitial Ads. Please use [this](<LINK_0> existing adapter for implementation.
minor static import isWhitespace for readability
Could be optimized: do not create StringBuilder if no replaces are needed. See com.intellij.openapi.util.text.StringUtil#replaceChar(java.lang.String, char, char) implementation
use append instead of +
Just a detail : I would use internalMatch instead of isToBeSent. (and so change internalMatch to protected) This make me read again internalMatch and - I still have difficulty to understand the inhibitNewConnection - is it possible to have an availableContext == null ?
Minor: move init to the beginning after the constructor
this is always true because you've set it to null in the line above. What was this intended to do / check for?
I think each of these two constructors should provide examples of the querystring's they construct.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Modifier 'private' is redundant for Enum constructor - needs to be removed.
Maybe wrap in an immutable map.
> When we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom. true
Please use Vector.ofAll() instead of Stream.ofAll(). See an explanation below (at the Option.sequence() change).
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
When you're using a local variable that shares a name with a class or instance variable, try to be explicit as to which you're referencing by using this.inputStream (or similar as appropriate). As an aside, the instance variable is never set, so this check will never succeed.
It would be better to delegate to the codec's makeSourceFromStream method here.
debug = Boolean.getBoolean("run.flaky.tests.debug"); does the same thing as what you have here.
-1 as this happens in case user provides loginTimeout property and it gets ignored. Does that really happen often? I think this log message would appear just in case one tries to put invalid value, and it would warn that the value is ignored.
Also too many dots
this usage does not seem very fine
If events is empty, exception will be thrown. Is it expected the caller to catch it?
In my opinion this looks little bit more clear: java switch(shapeState) { case SELECTED: case HIGHLIGHT: case INVALID: runState(shapeState); break; default: runStrokeStateHandler(strokeState); break; }
Guava has Objects.ToStringHelper() to make it nicer.
channelId => channelName
minor: don't need this. qualifiers
Let's just fix the OS by default. The default location should be configured by the jclouds *Implicit Location Supplier*. The default hardware is, by default, the smallest one.
Ccan we default to a more modern version?
How do locations look like in Azure? These looks more like Regions? I mean, zones in providers are usually in the form: northeurope-1, northeurope2, etc.
Wouldn't Collections.emptyList() be better?
Could change the return type on method to Collection
defensive copy?
Isn't this missing an implementation?
Becarefull with those assert. They will not fail if jvm is not launched with specific argument (-ea). You may use a Preconditions.checkState() instead.
Missing checkCallable()
"RuntimeException" I guess this is leftover of copy-pasting from other issue. Please correct here and below.
Indentation looks wrong compared to other test.
Why does test2 come before test1? Please swap their order.
this should go to super.reset(), shouldn't it?
This will basically do:  clearMapStore(); clearLockStore(); clearIndexedData(false); storage.clear(isDuringShutdown); mutationObserver.onClear();  The problem here is that we are clearing the data from the lock store and calling onClear for the mutation observers, one of which is the event journal. During reset, each service should clear only the data which it owns. This means that the LockService is responsible for clearing locks and the RingbufferService is resposible for clearing event journals. I also see this method is now calling clearIndexedData. Was that the leak?
Is this method really needed? It's similar to make init public
default method visibility OK?
Why can't you just return value here?
I think this should be > 0 since a value list item of 1=One does not work.
what about setColor(int progressAndThumbColor, int backgroundColor) if they alway need to be set together?
Yeah, you would need to do something like that since the text color will be white now always, what will change is the background.
This is probably not the right example. This specific problem goes away when you use the Right R class here. Can you modify this change to repro your case i.e have another module refer to the resource in its main code and this module invokes that piece of code in it's test?
Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.
Scheduling a message isn't part of the scenario. Do that as part of your // Arrange.
I noticed this and in other places, why do you use publishOn(scheduler)? It hasn't reached user code yet, so we don't need to perform work on their scheduler in the case that it is blocking.
In order that the test runs successfully is a debugger required or is this some artifact of the test development?
same as above. why wrap the exception for logging?
Null check for leaderElectorListener
Shouldn't we add the Transmit options field here?
I would call them attributes because that's how they are referred to in the XML / HTML world.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
please create a more specific exception that extends this one.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
factor out
use {} pattern for LOG statements. for example LOG.info("Starting PYAPEX with {}", StringUtils.join(args,' '));
This is not testing the frontend.
It is worth to include the port?
This piece of code really would be easier to read:  haxe ResultHolder typeResult = getType(null); ResultHolder resolved = resolver.resolve(typeResult.getType().toStringWithoutConstant());  The way my mind works, I read getType(null) to call a local function, and the following getType() I also presumed to be the local function -- which didn't make sense. It took at least a minute just to figure out what was going on in that line; basically that the return value of getType(null) was not the same type as 'this'.
You don't need to check for EMPTY. It does nothing useful in this situation. EMPTY.getHaxeClass() is a valid call that returns null.
I don't think we use final for functions in our code base
Ok if already stopped? idempotent?
Should be in a finally block?
In general you should call super.stop last, after all other cleanups.
Why are we configuring drawer in this activity. This activity shouldn't have it.
Good note. I think USER_PORTRAIT would be better so it works upside down too
The actual bug-fix: Use a style that inherits from AppCompat
Since earlier commits enhanced serialization to avoid losing multi-types this if can be removed.
replace with this 1 line: assertEquals(oreArtifactTokens.OseeTypesFolder, item.getItemId());
CI build shows 90+ failing tests, and they all appear to be caused by this change. Perhaps some of the other converters are lossy as well, and some of the failures appear to be for objects which do not have hashCode and equals methods defined, so the comparison fails because we have distinct references before and after deserialization:  junit.framework.AssertionFailedError: <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> vs. <camera name="Rebel 350"> <n> <name>foo</name> </n> </camera> expected:<com.thoughtworks.acceptance.AttributeTest$Camera@50d640dd> but was:<com.thoughtworks.acceptance.AttributeTest$Camera@447bf09d>  Also one small nit, I would change the spacing to make the failure messages a bit easier to read: suggestion assertEquals(xstream.toXML(expected) + "\n vs.\n" + xstream.toXML(actual), expected, actual);
Should we throw an error here?
This code has a race condition. Its possible that another thread creates a table between exists() and create(). The following avoids the race condition. java try{ create(tableName, ntc);  return true; } catch (TableExistsException e) { return false }
Any reason this is needed given we already catch Exception? (Also, it's only been added in a few cases - e.g. tableExists doesn't catch RuntimeException.) If we do need it it might be better to make this a DatasetException so we know it came from Kite.
should this be in some MathUtils class?
This asserThat will do nothing - you need to add something like isTrue()
please throw at least a runtime exception here
No need for super()
calling super not needed
I'm not comfortable with this constructor. It should be an absolute that all ProductionReferences have a non-null production
nit: can you put "File connector started" instead?
Don't use logger in shutdown thread, as the call sequence of shutdown is unknown, hence the logger can be stopped already, using the logger after it stops might throw exception.
Minor: This message would sound alarming in logs. Possible to add more context here about what might be wrong?
spaces on empty line
Alphabetical order of modules, maybe?
This method can be private.
The status of the pre-defined hook in fixtures.xml is already ENABLED. So maybe you should update it to DISABLED and verify the same. What I do to make such tests easier to read is, first fetch the current status and verify (assert) it, then update it to a different value, fetch again and verify the new value.
Maybe we can compare the whole object instead of just checksum?
Should be moved to the following if.
if you're gonna rebase this patch, please consider dropping those this. prefixes from getters.
If this is not used you might want to throw an UnsupportedOperationException
This doesn't need to be prefixed.
Can you check the String is not empty instead of length?
Can that happen? A TreeArtifact can only ever be created by one piece by an action. Can it maybe happen that only parts of it are materialized?
implement these 2 methods?
<LINK_0>
make sure all the if/else if cases in encode() are covered, e.g. '\t' is missing.
Should maybe other countries be added here?
How about simplifying this method back to IndexCoordinates.of(getIndexName())) and keeping the evaluation within getIndexName()?
@fuss86 it seems that previous implementation not assumed to return null, is there any reasons to do it now?
application.size() -> application.isEmpty()
IntelliJ IDEA tolds me to remove this unnecessary boxing.
redundant ";" character
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
A task without times is currently not allowed to recur, so RDATE, RRULE and EXDATE should also be set to null.
unmodifiable list
Also set allday flag and time zone.
Maybe just throw unsupported since this isn't used.
do we need negative mark here?
these arrays could be static finals. That would save allocating new ones all the time.
This can be improved by checking backup count:  @Override public boolean shouldBackup() { return mapContainer.getTotalBackupCount() > 0; }
I'd propose "boolean isSortOptions()" because you're also using the JavaBeans standard in the naming of "getUsageWidth()"
You can drop this boolean and use !prefixes.isEmpty(). If we have prefixes, we need to look deeper than the root.
Inside finally?
Since I already have implemented allOf in CfUtils, it had better to use it:  return allOf(futures).thenApply(x -> futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()));
IntStream.range(0, 10).map() looks better
I know this was pre-existing, but the variable is capitalized Map, but should be just map.
This will return an immutable map. Use new HashMap<> instead.
as this is not handled (it will always return null), I think it would be better to return a UnsupportedOperationException or to handle it (but it will take some time : db, rest mappings)
Exception is never thrown
Even though when translating from User to UserDTO we shouldn't be translating the password, when doing the opposite, the password should get translated and hashed. So I'd expect this kind of assertion here: assertEquals(Util.hash(source.getPassword()), dest.getHashedPassword())
Consider using the built-in parsing in the URL/URI classes
typo: of -> or
ow, this could be dangerous. We need to bluejeans to discuss.
Does this need to be public?
return (splitTime < fTime + fDuration ? new TimeEvent(fEntry, Math.max(fTime, splitTime), fDuration - Math.max(0, splitTime - fTime)) : null);
I do not like amount of UnsupportedOperationException , if we do not know what to do in such methods ..... is it better to put that to class implementations ?
It might be slightly more sensible to order by receive time: sent time is set by the sender, so does not necessarily lead to "newest first" behaviour (consider a friend being disconnected for some time).
Should the shadow not store this value and the one above in variables and provide setters for them, rather than just always returning false? The same goes for all values actually... Would be better to provide setters for them.
The getter is also intended to return a "Boolean" reference, so someone can test for null to check, if the default is intended to be used. You may check leshan builders to see, how it is intended to work.
This should always be read from the configs.
nit: add message.
Cool, didn't know about DeadEvent. When you switch to slf4j, make sure to use playerholders {} instead of string concatenation and follow the [logging format guidelines](<LINK_0>
It seems like passing the event id to the super class constructor and also making it a field might be a little confusing. Personally, I prefer the approach used in DataSourceAddedEvent where the id of the object is obtained in getNewValue via long id = (Long) super.getNewValue() and the "extra" field is not required. Thoughts?
I think I'd rather store the instance as a field than to have to loop through the projections with instanceof attempts? You can easily store the EntityInstance during populateWithEntityInstance.
You can't use super here
This also seems kinda pointless and a bit brittle. Just return resource.
return Long.compare(sizeInButes, other.sizeInBytes);
Please throw an exception if elementSizeInBytes == 0 because you are going to use it to divide.
- Integer.BYTES -> SIZE_OF_INT for consistency with getSerializedBuffersSizeInBytes - Any particular reason to not use SizeOf.sizeOfIntArray(positionCount) ?
oldValue should never be null; otherwise the merge function wouldn't be called. So, just use a putIfAbsent?
A little weird to inline the @Override here and not elsewhere in the same class (or really anywhere else).
Is this an outdated debug statement? If not, maybe add a similar line to onPartitionsRevoked() ?
nit: you could add .map(Math::toIntExact) instead :)
Cosmetic: Could you please change the indentation to be in accordance with the coding convention? (Here and wherever else it the PR it's not applied).
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
You can change the 28 case to a default case, and remove this.
Inconsistent Upper and Lower case in description
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on. However, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.
Throws an IllegalArgumentException if frameID < 0 or if frameID > 255.
Nullness of this is already tested in computeHashCode().
Shouldn't this be based on package name ? , getPackageName()+".depicts.contentprovider"
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
Unnecessary cast
Shouldn't this return a Page<T> instead of a List<T>?
I'd rather pass down the auth information to the QueryLifecycle. There's no harm in checking it twice, if it's good enough for Santa Claus then it's good enough for us. Checking it twice should also allow us to get rid of the no-auth path in QueryLifecycle, which would be good. Perhaps a good place to stuff the auth token is the PlannerContext.
Strange logging "cursor[input.getTime()]". Also maybe just remove this debugging line
No, not toString(). Please, study the SpEL
Can this be reduced to a single line?
HibernateUtilFactory.getAsyncMsgsHibernateUtil() call twice and it impact performance since we look up the bean again applicationcontext. Recommend to assign variable if sonar doesn't mark violation.
Looks like this toString() got generated before the tags field was added :P
Is there a reason for not using the MoreObjects.ToStringHelper instead?
I'd prefer to have the unknownFieldSet as the last printed stuff.
nit: Can we keep FilterSupportStatus() private?
Returning isAuthRequired by default sounds gold to me.
The return type is suppose tobe Response<ShareClient> based on the design. Is there any change here?
there is no other (more elegant) way of getting article name
Is there a need to have both asserts? The reason I'd prefer only one is that I don't want the user to get one error, fix it, and then get another. Since nonNull is implied by hasText, we can give the user only one error message that will repair both problems.
there is no need to convert to map. can we directly print headers ?
Is this line necessary? The radio group should already be visible.
More descriptive name
mSubContent -> mContent
Return from method Details at object that you found , and in place check for not null
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
Do this check in the constructor instead (or a static factory method). You'll want to be careful in how you calculate the baseType and you'll definitely want to throw if you can't find a baseType for which all elements are coercibleTo. You basically want to find the common base PDataType. Something like the first loop in CaseExpression:  private static List<Expression> coerceIfNecessary(List<Expression> children) throws SQLException {
Missing white space between ) and {.
Oh dear, I'm sorry, there's a change in it that I made for testing. Could you please undo it?
needs US-ASCII charset, or some other simple ascii encoding conversion
nit: we've followed the pattern where the sync APIs call their next max overloads -> this sync API should call the sync API overload with Context.NONE.
null? why not just a () -> {} ?
Style issue: @Override shuld be on line above the method declaration
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
Since I'm suggesting creating the Response with the input stream this could simple return it now
As you removed the openStream() method (replaced it with the openImageInputStream()), does that mean the BulkData now only works for pixeldata, and no longer for other BulkData like overlay data etc.?
Maybe better to return null
What about data type here?
Why do you return a new node instead of the failing one?
Can you please remove the non-vm networks from networks? Maybe removeIf would be nice.
no need to chain anymore: queryNetworkAttachments(); queryTLVInformations();
As I understand the code, this method ('initNetworkList') should be invoked only in case the selected 'dc' was changed. In this case it makes sense to re-initialize the network list (and seems your code is breaking this logic). I don't know what causes the bug, but you have to discover why this method is called after the 'dc' and the 'network' were selected (and I guess no new change to the dc was done).
not null check would be nice here
Then put an assert here? Just so there is an exception, that indicates that the connection was null.
need formatting.
!isEmpty ?
I prefer throwing AssertionError if this is a check against a future programmer error, rather than a protection against a state that the system could find itself in for an unspecified reason. But, it's not a blocker.
Should defaultValue be nullable? Null isn't allowed as the value of a result so it would seem consistent to forbid it here too.
I think we could have a better abstraction here for the list of possible values for a variable. We could consider this improvement for the next iteration.
Can't we ensure that we always set a List in the context and just do a cast when we get it ?
No need for super
You can add @RunWith(MockitoJUnitRunner.class) to the class, and then you"ll be able to use @mock on the declaration instead of this initialization. But it is just a matter of style, so as you wish.
public seems not required, only used inside vdsbroker
Doesn't it make sense to have those validation in the update use case as well?
Would the code be cleaner with  DetailAST node = lambda; do { node = node.getLastChild(); } while (node.getLastChild() != null);  ?
Return from method Details at object that you found , and in place check for not null
@dskalenko move null to right hand side
Maybe we should use a logger here, and print to a different file? In case there are issues with updating and we need to diagnose.
To keep same format, could we use Timber.e(message) ?
I think it would be suitable if some kind of padding is applied between messages, such as a newline
suggestion
getActiveInstance() does no make much difference, because there was Jenkins.getInstance() before. I would assign Jenkins to a variable
Just use java return HttpResponses.redirectViaContextPath(computation.getUrl());
This cast here is useless, Math.log10 returns a double already.
do we want to have actual percents? not rates as everything else is in Picard?
remove whitespace
public ByteBuffer reset(ByteBuffer input)?
Shouldn't we specify the UnsupportedOperationException thrown by this method?
Same as element-wise multiplication, breeze library seems supporting this operation. I've tested this in scala console (0.12 version).
This is not used.
Configure the tests and assertions in this class to properly verify that the DatacenterIdFilter is applied where needed.
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
You may also want a test case for a search value that is non-blank but invalid.
Also, when you do that, you'll be able to return directly from the try block, reducing the size of the method by nearly a third.
Please use com.palantir.logsafe.Preconditions. Granted this doesn't have any args, but it does mean the message will be visible in our internal logging infrastructure without us having to trace back by class and line number.
This adds the caps a second time.
Is the exception expected to be thrown when getHandledTypes() returns empty set? I thought it might be better if we explicitly check if (client.getHandledTypes().isEmpty()) and log the warn/info. I'm not 100% sure that will it throw an exception or just pass silently if the streaming collection is empty
This is not required unless you are initializing specific capabilites that apply to a Secret kind
Coding conventions: Let's have the @Override on its own line please
is volumeName optional parameter?
What about String commandName = null; if (forceRemove) { commandName = "GlusterVolume.removeBrickForce"; else { commandName = "GlusterVolume.removeBrickStart"; } JsonRpcRequest request = new RequestBuilder(commandName).with ?
one small edit: we should be using try { ... } finally { super.finalize() } here
50 means...what? Magic numbers are always bad.
Use parameterized logging instead of string concatenation.
Would prefer to store the quark as a member of this class and keep a getQuark method.
defensive copy?
Would prefer to store the quark as a member of this class and keep the getThreadQuark method.
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalInstance?
I generally like to have singletons to be synchronized. ClientPrefs is only instantiated in one place anyway, and that's single threaded, so this is more of a nit.
Mock is deprecated. If we're changing this code anyway, it's probably better to go ahead and phase it out, if it isn't going to add too many complications.
Minor: Collections.emptyMap();
no need for concurrent
Please do the List changes in a separate PR. This PR should contain only benchmark changes.
Ok, I see why you want to pass in null. But instead would be better to have a super constructor that takes just class, so if someone calls the other constructor with a null entity instance we can fail fast.
it's better to do this(clazz.getName()) here and get rid of this DEFAULT_LEVEL constant, being used only once
this(clazz, Collections.EMPTY_LIST)
log.info message is too general. When you have multiple bundles this statement may confuse you when trying to troubleshoot OSGi related issues. Instead, your message should ideally be "All required capabilities for web socket service component is available"
Is it necessary to make this an info log?
Do we need to check if debug is enabled? AFAIK this is handled internally. Please refer [1] for more information regarding this. [1] <LINK_0>
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
Is it possible to avoid this initial kickoff by setting the listener before we set the adapter?
Use strings.xml and don't capitalize by default, it is handled automatically by Andriod Tab Layout
I don't like this method. It looks like magic in the call site.
can this have an overloaded method please so we don't have to pass null around? suggestion StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId);
please check that creds.length() is 2 before access, do not allow exception in this case.
no static
Why not return "!this.id2descriptors.removeAll(id).isEmpty();" like in LegacyPropertyContributorRegistry.java?
In the original bitrate_bps is a pointer. I don't know how it should be handled here (since it is currently not used)
That is not necessary anymore as your other PR got merged already.
That is not necessary anymore as your other PR got merged already.
WTF is lala
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
I couldn't understand the need to get templates config and set it back again, is this required?
> That is a case I missed. Would adding a group existence check in canContinue handle it or would I need to add a check over here itself? Update: there is a check of canEditPipeline in UpdatePipelineConfigCommand#canContinue which will blow up if the pipeline group does not exist. I suggest moving this block to the update method in UpdatePipelineConfigCommand.java. Anything that updates the cruise config is best added in the entity command's update method. Similar to how CreatePipelineConfigCommand#update does it.
I think it should return Array here.
I think it should return Array here.
I think it should return Array here.
I would suggest using ConverstionPatterns.MAP_REPEATED_NAME here as well.
I guess we will also need a matching input type strategy such that the validation can work properly.
(minor suggestion) I think this func along with projectLeafTypes can be combined into one to make it more clear: private static GroupType buildProjectedGroupType(GroupType originalType, List<String> groupPaths, String currentPath) { .... }  Perhaps return null if none of the group fields get included.
That can't compile anymore.
Can you add a call to "DataCacheFactory.getCache().getCacheManager().clearAll()" as well? In the default configuration it will clear the same cache as the "report-dataset-cache", but if an OEM replaces the DataCache-implementation, we will cover their implementation too.
This is a global purge across all sessions.
to be consistent we should introduce constant for kmodule.xml
The image attribute is not supposed to be the text of the node. I'd rather keep it separate (the previous @Text attribute was fine). A practical reason for that is in the future, other languages may have a way to get the text of their node, in which case that wouldn't be fetched with getImage, for compatibility, but probably with a getText method, or getSourceCode like in #1728. Also we *may* deprecate or otherwise put getImage out of use as soon as 7.0, given its contract is super loose.
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
The factory methods can be package scoped like the class.
Maybe better name for this one would be CommandRequirementsFromConfigurationCollector
suggestion void validateSchedulingRequirements(  nit: not sure, why we need protected for methods in AbstractExecutionSlotAllocator if it is used only within the package
Please move this logic to the constructor so that we can keep request final.
} catch (Throwable throwable) { throw new IOException( String.format( "Failed to truncate table '%s'", tableName.getNameAsString()), throwable); }
Same as snapshot(), this is a LRO, we need to poll.
why add?
perhaps change to import instead of move
should be edit
check notNull?
You added this to the ctor's signature, but forgot to save it in a data member.
return queryId
Since we're now using bus events, do we need this anymore? (The whole idea was to send events to individual cards, and avoid having to rebuild the whole view hierarchy of the RecyclerView.)
style nit: we don't use braces around single line blocks
can this be a method reference?
typo
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
Restore to original. Also apply to the other similar throws.
It is generally bad form in Java land to modify the fields of another class directly. You should do this via getters and setters. While this introduces boilerplate, it makes for more extensible code: maybe you want to synchronize your setters across threads, maybe you want to cache computations and invalidate them when a setter is called, etc. Most importantly, this is convention: readers of code will not expect for class field mutations to occur outside of that class, and not look for it when they are trying to understand the code.
non-actionable: ... and this is where I complain about not having Java 9 Optional#or which does exactly what you need
Then OpenShiftPreferencePage and OpenShiftCorePreferenceInitializer cannot use that method, they need 'pure' search for default in $PATH.
Please add cmd.getDhcpOptions to the log message to assist with operational debugging.
Why are all unchecked and checked exceptions being caught? It seems like we should only be catching the expected checked exceptions, and allow unchecked exceptions simply bubble out.
Log the exception to error.
This should invoke the other constructor so that taskData can be marked as final.
I guess we can remove the unnecessary this. accessor from these getters as well.
Isn't it a bad design to have a method required by only a single concrete class in the generic interface? Can we fix it so that we don't have to do things like this?
If storageManager gets a value in constructor, then we don't need to check null.
Is setting up a new empty user object correct solution in any case an exception is thrown on initialising the test suite?
I'm not familiar with the UNINITIALIZED_WORKSPACE_ID and why it would have value -1. But if you wish to call a CB API directly, you should always use workspaceID 0. That will default to the tenant default workspace which should be already existing.
WTF is lala
Can you make an overload of the registerCriticalWarning method that takes only the non-null arguments here?
I think there should be a space after if here, looks like that is the convention used here.
BigtableFilter should probably have a com.google.cloud.bigtable.data.v2.models.Filters.Filter member variable. That would likely mean deprecating the current constructor that uses com.google.cloud.bigtable.data.v2.wrappers.Filters.Filter, and use a com.google.cloud.bigtable.data.v2.models.Filters.Filter in a new constructor. Also, please add a BigtableFilter.getFilter() which returns the models.Filters.Filter and use that getter here.
Actually, looking at our SDK guidelines, we shouldn't be doing this verification at all and allowing the service to return a bad request. <LINK_0>
Both addFilterBefore() and addFilterAfter() call the addFilter() method to add the filter which also does a pre-check before adding. However, the new addFilterAt() method directly puts the filter in the filters member variable avoiding the extra check in addFilter(). Although the first call to comparitor.registerAt() (if it succeeds) would ensure that the addFilter check will succeed too. So the current implementation would work the same way. But it's not consistent with the other 2 methods of adding. Is there a reasoning behind this that I'm not seeing?
Not that it matters but it would be "sourceFile"
Perhaps it is not necessary to execute the program to find if it is present. How about just checking for the executable file using java.io.File.canExecute()?
Avoid magic numbers. Make 5 a constant, perhaps something like LANG_FILE_EXT_LENGTH, or take the length of a string defined in a constant like LANG_FILE_EXT. I would probably opt for the second, especially since it has use later on in load().
This method (getUser) is equivalent to this.getUser(this.server.getPlayerProfileCache().getProfileByUUID(uuid), true);
nope, return true
Store value of gameProfile.get() instead of calling it twice
Remove timer.
minor: you can use == here since it's an enum (or change the == RestMethod.DELETE to .equals(RestMethod.DELETE) for consistency)
make line 112 an else if?
You can use FiltersHelper.Constants.HEADER_AUTHORIZATION here.
suggestion HttpServletRequest req = (HttpServletRequest) request; String lengthHeader = req.getHeader("Content-Length"); if(lengthHeader != null && !isSizeWithinBoundaries(lengthHeader)) { throw new MaxUploadSizeExceededException(multipartConfigElement.getMaxFileSize()); } chain.doFilter(request, response);
Shouldn't this be wrapped in a try... finally block?
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
I wouldn't change this line, by initializing as empty string, we don't have to worry about whether we've just created a Consumer with no serviceLevel in java(null string), vs loaded one with no serviceLevel from the database (empty string). Logically it probably shouldn't make a difference, just scary.
Optional, but this null could be better. How about defining a SESSION_NOT_SET constant and use it here?
Same here. At least returning a Collections.emptyMap() would be better.
Is this a valid return value? Maybe it is better to throw an UnsupportedOperationException instead of returning null.
Detail: FROM capitalized.
This does not match the endpoint in connector :(
suggestion return (map != null) ? HashMultimap.create(map) : HashMultimap.create();
I'm not hugely keen of the aesthetics on the syntax here but I presume that this is Java-8 syntax for applying the same filter? (I'm not asking for changes, just reassurances that this is "how it's normally done these days" as I've not seen that code pattern before)
suggestion return Objects.requireNonNull(nodeProperties);  Then you can remove the assertion above.
Technically it breaks the binary compatibility. Not sure it's important in this case. Maybe it makes sense to just use DescriptorImpl as a return type
Here as well, I think the two calls to this method can supply an element id.
java * @param error a potentially empty error message. * @param errors the List of error messages, which @code{error} is appended to, if @code{error} is nonempty.  @damithc errors description stills seems too verbose, ideas for a better one?
What's -2? It should have a psf variable to define it. Is -1 also used somewhere? If so, that should be fixed too. If I did it, I apologise...
can this be readSafely instead of readBuffer so that read uses readSafely
here for example could be remotePath.resolve(source.getName()) if pathPrefix was a java.nio.path.Path
RBAC failures could be logged at a lower level.
.endsWith("'sParty") has an implicit semantical meaning and therefore should be put into a dedicated method. I'd guess something like boolean isOwnPartiesChannel(String name) But just comparing the end of the name sounds really... odd?
Don't we need to do something slightly opposite? Check for data instance of List and always call onMessageBatch() since it is there on the MessageListener anyway.
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
Synchronization is needed otherwise there can be a race condition between getting the current count and updating the count (line 296 and line297) Also between this.assignmentFailures.clear(); and assignmentFailures.put(node, failCount);
Does the consumer not log this already within assign(...) ?
This function should throw an exception if the slot is already assigned.
Maybe this should be getOrDefault to avoid null returns.
This should return the PDataType for an element of the array
if (
Should we log the potential error?
You can also use IO.close(bb) as IO.close will not throw any exception.
Nevermind, I see it is the Future.get() that throws the InterruptedException.
I can remove and update. (from all the references.) These were just to let you know what was changed.
we should not throw an exception here, simply ignore
Optional: Consider renaming environmentConfig to something like pipelineEnvironment or environmentForPipeline?
public void fireEvent(GwtEvent<?> event) seems a bit redundant now. Is there a web bindery replacement for HasHandlers?
Multiline this annotation, it's too long now.
Wondering what's the benefit of catching java.lang.Exceptions for EventListener.handleEvent() when handleEvent doesn't declare a throw in its signature:  public interface EventListener { public void handleEvent(Event event); }  Should we make it more specific to catch java.lang.RuntimeException? Since there is no throw in the signature, we don't lose on any functionality, and it makes the intention clearer in the code itself.
Shouldn't the return type be int?
What is this config for?
Default access (no modifier) suffices.
Please remove the protected keyword because this class will never be subclassed.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Extract as a constant?
This method should be static and need not pass this as an argument to the constructor.
Shouldn't this be: this.limit = Integer.MAX_VALUE? Otherwise the default page size (25) will be used and only 25 users would be returned.
In #1294 (currently targeted for 4.13) we are proposing updating this class to collect assumption failure counts, so I am not sure we should make this change.
possible exception
stringutils.empty
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
@vilchik-elena shouldn't we test at least one case where we don't know the type of an operand?
If you test call to method reject you test method should include word reject but it include remove
Don't we want to keep this?
nit: you may keep the chain pattern as append returns the builder object. Do not have a strong opinion on the current or the chained version.
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
move it to be aside of deleteFolder
You won't need negation if you turn the order:  return binding.widgetAnswerText.getText().equals(getContext().getString(R.string.no_date_selected)) ? null : new DateData(selectedDate.toDate());
I think latestDate should be passed as second param, according to doc: assertEquals(Object actual, Object expected, String message)
We might want to consider calling the new method from this one so we don't duplicate code isPublishDateInTheFuture(dateCreated, new Date()) wdyt?
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
why change the readability status here?
I think we should TRY to move before we update the file path
use FileUtils.createNewFile() instead in order to check return value
java @Rule public TemporaryFolder tmp = new TemporaryFolder();
I guess that if "columnToBeSortedOn" is null (sorting is turned off), we should not write to a temp file. We should write to the final file directly. So maybe let's rename the "_tempFile" variable and call it something a la "_targetFile". And initialize it according to the null check.
you can make this a class member and then only load it once here and reuse it on execute
please do not shorten variable names. please rename to 'dcCompatibilityVersion' or at least 'dcVersion'
lines 76-81 can be replaced with the new method from line 85: getVnicProfile(Guid vnicProfileId) need to consider the possibility or a returned null value.
let's do it using lambda approach
let's do it using lambda approach
let's do it using lambda approach
use existing constant
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Can you please change it to '/'? This is faster.
Please change this line to: DbSession currentSession = HibernateSessionFactory.getSessionFactory().getCurrentSession();
@brayoh This query still calls Bahmni specific classes
Is it supported to resume transaction in another thread? If so, what will happen with the ThreadLocal in the TransactionImpl?
This can lead to NPE, better to swap the check.
![MINOR](<LINK_2> 'Severity: MINOR') Remove this use of "getBaseComponentId"; it is deprecated. [![rule](<LINK_1>](<LINK_0>
The file name was changed. Was this intended?
Can you share why we need to unsubscribe all here?
Should we do an Assert.assertTrue on the return value of verify()?
The path contains"/" symbol. Would that be OK?
We should return true here to ensure the menu is displayed.
Variable not used; please, remove this line.
this line doesn't do anything
Second parameter of Status is the pluginId. Why to pass path here?
This isn't the intended use of the API. You shouldn't use RepositoryStatus unless the error has a corresponding task repository.
we should log this before throwing it.
Camel can do this automatic in the setProperties(configuration, parameters) you do further below. If you want to set default values then set them on the configuration class instead
This shouldn't be done, we just need to setProperties on the endpoint, so the second one should be sufficient, take a look at the other components.
I think would be better to follow other components on how to set configurations, meaning that to configuration properties mutable and let Camel do the job of binding the parameters via setProperties(configuration, parameters);.
minor nitpick: Could we rename it to removeNullEntries() ?
an empty ArrayList is better than a null
Same here, never return NULL (very bad practice), throw UnsupportedOperationException instead
similar issue here. remove validation in client
we should not validate the hashtoken on client since we don't know the system password.
delete this function, we should not log tokens
that seems a wrong junit exception usage. test shouldn't suppress exceptions, it need only configure exception (that is Rule).
The getImage call is not cached (as opposed to the listImages one). Better get the image in a @Before method just once?
If we use TestcontainersConfiguration.getInstance().getRyukImage() here, we will not have to pull it
It should be this class' responsibility to register listener to AmbryStorageQuotaService. Instead of returning Listener objects, this class should create the object and AmbryStorageQuotaService.registerListener(listener). This will make things simple, as the only responsibility of AmbryStorageQuotaService will be to called listener that are registered by consumers. Also the AmbryStorageQuotaEnforcer doesn't need to do anything if it doesn't want to listen.
Based on how it's used, it's more like a listener not callback.
same here and please update whole class.
if you use a second client instance and do this remote operation, the test can be easily duplicated by non-java clients as well.
fail is missing here.
unused variable?
Docs here to please. I understand what you're doing here but given that they are public static methods it looks like "api" stuff
Are we guaranteed that tokenString and tokens will always be not null when the extractStringFromTokens method is called? If not, then while (tk.hasMoreTokens()) wil throuw a NPE. Reference: <LINK_0>,%20java.lang.String)
Can you use <LINK_0>
You are using Toaster everywhere in this class except for this message. For the sake of consistency, use the same class here as well.
change to charge_created_successfully
We have ToastUtils class which we use for displaying toast so we should use it here as well.
what happened to handling of nullables?
I would make an array of 2 with the index. with the check. but this is also OK as a reverse seek.
Please use class constants instead of strings. I.e. Use EXCLUDE_CACHES instead of --exclude-caches
I think the most likely case is that fboName is not the default frame buffer. But it's a very minor issue, so let's leave it as it is.
suggestion this.className = requireNonNull(className);
I can see what you are doing here, attempting to avoid an NPE if fbo is still null. However, an instance of this class doesn't need knowledge of the width and height of the fbo except when it generates the task or updates it. So, I'd remove this IF block and I'd remove the printout of fbo.width() and fbo.height(). Those can stay in the task. Also, I'd remove the private fbo variable: we can instantiate one briefly when we need to gets its width and height, in generateTask() and update().
keep primitive, it's not used in JSON and can't have null?
I would feel better if we check is dispatcher is null here like we did with sub
Please extract messages to public static final
minor: I personally think that 'this' is redundant here.
Moving that bits above and allowing the user to change the decorator via a public setter means you can completely shadow what AbstractTransactionSupportingCacheManager used to du using public API. Also, if CacheDecorator is a first-class concept, you should probably expect that more than one decorator can apply at a given time. This wrapping shouldn't be the responsibility of the caller.
This should be synchronized.
Hm... Migration feed is where it probably does not make sense to have Archive URLs. Maybe we can make these methods no-op?
latest from today's discussion: return URL
if you're gonna rebase this patch, please consider dropping those this. prefixes from getters.
No tests to cover this method! :open_mouth:
Could possibly do an assertion using StringUtils.hasText()
Could possibly do an assertion using StringUtils.hasText() here to tighten things a bit.
You could maybe use enclosingClass to save a few hops...
Any way to do this without instanceof? My read of the docs is that a single class is allowed to implement multiple types.
Throw here with an appropriate error message instead of returning null. Right now javapoet would throw an IllegalArgumentException in line 132 for passing in null.
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
Looks like this toString() got generated before the tags field was added :P
can we use MoreObjects.toStringHelper(this) like we do elsewhere in the codebase?
what is this String MediaWiki:RelatedVideosGlobalList?
goToArticleDefaultContentEditPage? what this method does?
Consider checking for ecommerce unit only because ad unit in MonetizationModule might be shown for anon?
This is not a good convention. How about changing internalNext() to be able to return null to indicate there's no more elements?
final
next() would return null if hasNext() is not called? I don't think Iterator contract makes invoking hasNext() and next() strictly in pairs.
One more empty catch(){}.
add missing java-doc
I think the test might be more robust if the bounds were read before indexing the trace explicitly.
Please check if this method really should be public in a private static final class. The parent method is protected.
Here group.getSelectedVersionGroup() is not checked for null, though in other cases the check is used.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
is this toConfigurer needed as a variable?
From big height the fix looks reasonable for me. But does it work really against real Broker? I'm just curious if that CustomExchange is robust. But, yeah, thank you @panchenko for the effort to support community and improve the Framework!
The name is very confusing, assert equals seem to indicate it should take 2 parameter and make sure they are the same. I know you mean to assert symbols from Expression and RowExpression are the same, but you really can't tell from here. Maybe just call this assertSymbols.
We should log this error by using our Log.e method.
should it be case insensitive?
Wrap all of this method body in a try finally: try { ... current code ... } finally { reader.release(); inserter.release(); } That way the caller doesn't have to release our resources via another method call.
Always use blocks! :-)
use rewrite than getVisitor
this loop is slow; why not convert ALLOWED_SPATIAL_JOIN_FUNCTIONS into a set of lowercase function names, then use Set.contains(functionName.toLower())
byteOutput.emit(tuple.getBytes()) ?
I like the builder approach because .build() can throw if modifiers has inappropriate modifiers like private.
why this? engine will handle it when nothing is emitted.
I don't quite understand why this call is needed. If LazyBlocks are not loaded, the data is not read, hence no stats to update.
should this be in a finally block to release in the case where an exception occurs?
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
Should be cached or initialized in a field.
remove this.
Spacing
This needs to return a completable future, not null
This won't evict the cache since the call isn't made through a spring bean proxy but directly within the class. To make this work, the service needs to have itself injected by @Autowired and use that reference instead
any reason for explicitly invoking super.toMap() ?
how can this be null? isn't there a check in the canDoAction to block this from being null?
The check for volumes count doesn't add any value. You'll execute one query all the time, and two when there are volumes. Directly invoking the removeByClusterId() will mean only one query in all cases. When there are no volumes, it won't delete anything, but still succeed. So it should work.
What if user has selected multiple volumes
Here should be NOT_INCLUDE_DEFAULTS
Please rename to something like originalBufferSizeResult or at least originalResult.
Please rename to something like originalBuffersPerSliceResult or at least originalResult.
This line is a bit too long, can you break it into two? I think most of the coding style has 100 chars line width.
see above wrt logging
calendar.setTimeZone(new SimpleTimeZone(timeZoneOffset, Integer.toString(timeZoneOffset))); ======== don't use string concat
please decrease log level to trace or better remove statement
please remove this statement or enhance it to something more context/meaningful
please decrease or remove this statement
Typo: "su*m*.misc...."
please create a more specific exception that extends this one.
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Change collectionType to iterableType?
We need to have a backup plan here if type isn't a TypeVariable.
Nit: I read "/" as "OR" which seems weird where we are both creating and starting. I think the message would be better as just "Creating NodeTypeWatcher" or "Creating and starting NodeTypeWatcher"
"This method is not actually very useful and will likely be deprecated in the future."
This is repeated several times. I suggest making a static parse function in the FeedScopedId.
can this use the MMX StringUtils functions?
Extract this into an AppPage method waitForElementVisibility? It can overload the one that accepts a WebElement. Accepting a By is so much more useful, as the element doesn't have to be present yet for us to use it.
return result.isEmpty() ? null : result;
length() - 3
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
This one needs to have context so you will need to have a method that takes an Integer object and a Character object.
In this sample the use of brackets is not consistent. Maybe use always brackets?
Wondering if we want to included more information about the locks, say the size of the maps, the size of the reaper queue, maybe the versionIds. This now just logs out your configs which should be immutable representations of what is on disk. If you're going to update this, may also want to consider not returning a Builder, feels off.
The variable feels weird. copied gives me the impression that something worked but then I see that you throw an error if copied == true. maybe use something else e.g. failedToCopy? or alternatively return the string and check whether its null?
I think we should TRY to move before we update the file path
Minor: BufferedOutputStream is correct?
Maybe we can compare the 2 images to check that this is the correct one?
This code is duplicated in removeImage too. You may want to extract it to a new method
The getImage call is not cached (as opposed to the listImages one). Better get the image in a @Before method just once?
It seems strange to deactivat errorCatch here ...
Agreed, makes sense to me.
will not work for all views if you have multiple. Rather pick the current view and see if it is a shell view. If not, try to find out if there is only one shell view and rename that one. If there are multiple but none of them is the active view you cannot rename anything
Instead of removing "bbbb" which is the longest element so won't have trailing spaces, try removing "a" or "c" as it's a better test.
assertThat(res, allOf(containsString("a"), containsString("b"), containsString("c"), containsString("d"))) would bring a better error message.
line more than 100 chars, plz follow the code conventions FYI: <LINK_0>
I continue to think that **aifc** should to be here...
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
Can you add getId() and mark id() as deprecated?
I see. I don't think there will be a guarantee that it will be unique even if randomly generated, right? So maybe it's not worth doing. BTW, in which case can this be null? Both the extension point and the XML require that Id I think? If I understand correctly, this could be null if the module is created by other means. I'm debating whether or not to throw a NPE when that happens but maybe a less violent solution would be to log an error and return UNDEFINED_ID as it is done in this patch.
need to pass Locale.ENGLISH here don't you?
Why do you wrap here unconditionally, why there is no isValueNode() as in other place?
Can you add a CommonHelper.assertNotNull("delegate", delegate); check?
It seems like defaultMessageConverter is not needed when constructing this with the provided converter. Might be use a boolean field instead, so setBeanClassLoader works only if default converter?
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
getRequestedSessionId is also controlled by front-end (client). <LINK_0> Maybe we should go with the changes you suggested so we can get rid of the implementation dependent removal of \\.node0$ Double submit cookie pattern is not safe under two scenarios according to this: <LINK_1> And none of the two scenarios apply to our case (usage of subdomain and HTTP instead of HTTPS).
Remove log message
Let's include the giver and recipient here too
please also add the GUID which is important.
Recommend to use ToStringBuilder
This could also be chained.
Even though tokenOwnerStats is a concurrent map, you may run into race conditions if multiple threads operate on this method at the same time. We can potentially make the method synchronized to avoid that. Not sure we should care much though since this is only for metrics.
build failing because capitalization, s/setIteminFrame/setItemInFrame/
this log seems useless, remove it
shouldn't we protect forkJoinPool accesses as it is static and shared between all ProActiveFileObject?
We always use brackets, even if the if only has one statement. Same goes for the else clause below.
With zero knowledge of the code, are you sure this object is not reused? Because if it is a scheduled task it be just reset rather than recreated, but you cannot reset the telescope client, you'll need a new one.
Read this if you didn't already <LINK_0> #38
I think you missed a {}
(purity alert) This two can be written inline
This "/d/" is not making this very descriptive without knowledge of our URL structure. I suggest to either create a method openDiscussions(), or - even better - a new Page object for discussions.
Use the logger to throw exceptions?
Instead of obtaining the Authentication, please use the SecurityContext so that the original SecurityContext is used (this ensures that if a custom SecurityContext was established it is used later on as well)
Mann knnte das auch ohne "username" machen:  java if(...) return authentication.getName(); return "...";
I think that means that they'll need to re-enter the 2FA code if 2FA is enabled.
Why is this necessay? it is called every 20ms! Why is it not sufficient to set it on top once?
Shouldn't this be using the builder pattern?
By checking the subtype of Source we're breaking the encapsulation of this class hierarchy. As an alternative, we could add a boolean canBeReloaded() method to the Source interface. Also, is this missing to check the Operation? It seems like it would show the button on the push tab too when the target is an Aggregate server. If this is true, it could bring back the need for having a new member of this class to remember (pun intended) if we want to show the reload button.
Can summarise to two lines: java WebElement sessionRow = waitForElementPresence(By.id("session" + getEvaluationRowId(courseId, evalName))); verifyElementContainsElement(sessionRow, By.className("session-resend-published-email-for-test"));
Can summarise to two lines: java WebElement sessionRow = waitForElementPresence(By.id("session" + getEvaluationRowId(courseId, evalName))); verifyElementDoesNotContainElement(sessionRow, By.className("session-resend-published-email-for-test"));
I would have put this line above the previous instruction to make sure #xtree can be found. WDYT?
super.stop() should really be in a finally block.
This got out of sync when I reverted the WFCORE-307 fix. The correct property is "jboss.as.test.disable.runtime".
Check so that server != null when tearing down.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
The result variable should named as result
"may" -> "must" "may" means that it's allowed to be empty.
Why allow a nullable input here? Users wanting a null content type can just call the String variant, no?
why public?
defensive copy?
you can use Collections.EMPTY_LIST
possible NPE
I really feel like there should be a descriptor in the name, e.g. getQueueUrl(), getBlobUrl, etc. Thoughts?
If this is not used you might want to throw an UnsupportedOperationException
child
I think your change works. Great. But there are optimisations I would suggest. If you have the array files in hand you have already all information in hand to detect orphans. No need to do again the expensive filesystem calls (the .exists() calls) in the isOrphan method. I would: - I would use the DirectoryStream with a filter for .pack,.index,.bitmap files as Matthias suggested - I would sort the stream to ensure packs come directly before corresponding bitmap/index files. Then it is easy to detect orphan index,bitmap files (if they don't follow directly a corresponding .pack file)
Would file.getName().endsWith(".java") work OK? And I guess if the case is a concern, maybe file.getName().toLowercase().endsWith(.java).
Same argument as with the DeadlineJob.
I think we should remove thread synchronization from here and let the client code handle it.
How about TimeUnit.MILLISECONDS.toMicros( )?
I wonder about simply adding a modifiersAST != null clause java boolean isStatic = modifiersAST != null && modifiersAST.findFirstToken(TokenTypes.LITERAL_STATIC) != null;  and then leaving the rest of the method unchanged/not necessarily introducing Scope.isInPatternDefinition Would that work?
Consider using AnnotationUtil.getAnnotation(...)
please move PRIVATE to the top of this group, to not mix visibility and "kind".
Can we change this line to this(0) and remove the if (port == -1) in the other constructor?
I don't really like this method being public, since it provides a backdoor around the state management operations in ModeShapeEngine. I understand that changing the visibility was required when we move the RepositoryFactory implementations into the org.modeshape.jcr.factories package. But I think having a cleaner API is more important than having that separate package.
give the thread a name by using Executors.newSingleThreadExecutor(new ExecutorThreadFactory("the name you want"));
squigglies ftw
this.stashedStarts.isEmpty()
Again, just return the boolean value.
It may causes two consecutive calls of onTracksChanged due to MediaPlayer L3008 in the same patch set.
Get it from the model now that we have one?
How about getTracks()?
OCD: missing space between ) and ?
The reason this is here is so that it doesn't get needlessly wrapped in a RuntimeException in the next catch block.
Use the new String(byte[], Charset.forName("UTF-8")); form to avoid the try/catch. Constify the UTF-8 Charset elsewhere for extra points ;)
you can't just fix all magic 2 :)
can we avoid writing headerOutLong file in cases where its not needed? may be, we can write headerOutLong on demand at the point when fileSizeLimit is crossed (and stop writing headerOut afterwards)? in most use cases, headerOutLong would not need to be written at all.
add {} while we're here
This test probably doesn't do what you think it does, because it verifies that EXT_ID matches with itself. (Same with several of the subsequent tests.)
What about the following cases? * External ID validation required, but not specified? * External ID specified, but validation not required?
It would result in less code churn to write dao.getExternalId(studyId, "AAA").get();
This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute.
use artifact.getAttributeById(attrUuid, includeDeleted)
make sure that we don't add a child named "..", that would be confusing!
Make this java fail("expected exception");
assertException doesn't really help here, I'd rather do something like this: private static void assertXaException(ExceptionRunnable runnable, int errorCode) throws Exception { try { runnable.run(); fail(); } catch (XAException e) { assertEquals(errorCode, e.errorCode); } } I'd also move the helper methods after the tests.
it seems the Exception is unnecessary, we can remove it.
java if (mapperReference.isUsed() ) { mapperReferencesForConstructor.add( (AnnotationMapperReference) mapperReference ) }
You can use the size of the fields as an initial size for the list
Remove this (ORDER_MAP_ENTRIES_BY_KEYS).
What is the need to make issueArticles nullable? It would be easier to understand this view class if we required it. If that's totally impractical, we should consider having a separate view class to capture the difference.
Issue.java  public Optional<String> getProduct() { return Optional.ofNullable(product); }  _issue.getProduct() != null_ is unnecessary, it returns at least an empty Optional if _product_ is null.
This should be rewritten to just change the key depending of filterAnyRule.
Why is the modifier private? We should set same modifiers to validateDatabaseName and validateTableNamet methods.
Could you change the "information_schema" to constants ?
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
move this out of this function to where showImportProjectsDialog is called, and only build a dialog if you want to show it
Could this just use showIfNotShowing instead? and call startStorageMigration on the returned dialog?
"our" => "out"
final
A method can be extracted which takes offset and len, which can be used in the two tests above.
final
if not blank
the need of warning is up to caller not this infrastructure component.
Is this System.out required?
are these setters used anywhere?
I am wondering if we should move the project towards scala or kotlin to make the data objects less verbose
Please make the constructor private (see Invalid).
Can you elaborate when long type can be nullable?
Please throw unsupported operation exception instead, this dao is not used. We're going to get rid of it.
Should we set a boolean like: boolean successfullyProcessed = updateAgencies(); successfullyProcessed &= updateProposals(); successfullyProcessed &= updateAwards(); return successfullyProcessed;
This method could be static since it does not depend on any local state. Same for hasCoordinatorMoved.
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
Can static import this method.
access modifiers?
10 is hard coded, should it be configurable ?
??? Does it work? Really it has to be super.. IDEA shows the recursion for me
you can use method getUrlForWiki (so you don't need to add empty string for article path)
please consider using Assertion.assertContains - it is more readable
You don't have to use homePage in homePage.getCurrentUrl() just use driver.getCurrentUrl()
nit: we don't usually use final on method. (Also, as a side note: we don't use final for tmp variables)
working with prefetched columns should be faster (and more stable) than using findElements every time
Use Seq now?
Status HALF_OPEN not possible here, as the updateAndGetStatus method will always return either OPEN or CLOSED?
I might have asked this already, but I forgot the explanation, sorry. Is it okay that we track EDITOR_POST_PUBLISH_TAPPED for all the actions (not just "publish")?
We can remove the unnecessary AnalyticsTracker qualification from AnalyticsTracker.Stat.QUICK_START_REQUEST_NEGATIVE_TAPPED to produce AnalyticsTracker.track(Stat.QUICK_START_REQUEST_NEGATIVE_TAPPED); for simplicity.
why can't the schemes be hash from starters?
Why is it a list of lists, not just a list?
There is a nice builder for ResponseOutput merged recently. You can take advantage on that.
For loop?
This array must be calculated one time only
int[] props would make everyone including the style checker much happier
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
Are we sure that we don't audit log in that case but only engine log?
iirc it's initialized in the ctor, check that it's not empty .
you already know that it is IMAGE, don't you?
check it like this - disk,getDiskStorageType() == DiskStorageType.IMAGE
Same - icsCode >= 1
Not sure why we're joining in the developerCertificationStatuses here. They're not used in the report that this code is used for
I was expecting to see "FROM DeveloperCertificationBodyMapEntity main " like you have in the method above. (ie. I think "main" is missing)
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
Could use the Apache CommonsIO FilenameUtils.separatorsToSystem(String path) to be safe & cut down on verbosity. Also, that same utility has a lot of other useful methods that we could be leveraging throughout: A few: normalize(String filename) //normalize unneeded relative paths to simplify the path. ex: a/b/../b becomes a/b getExtension(String filename) //gets the extension wildcardMatch(String filename, String wildcardMatcher) //allows you to compare extensions or file names easily via wildcard
What is the deal with the type converter?
@ILikeToNguyen Why the change in visibility here?
I think we need <K> here instead of <String>? Otherwise how do we deal with Integer query ids? But not sure if using <K> would eliminate the warning.
Could you move "community" to URLsContent and store it as a String constant?
Use fluent interface in here
Nitpicking: we can use a pattern and String.format() to make it more readable instead of concatenating it like that. What do you think about it?
This is problematic: If a user foo has access to pipelineA, but not pipelineB - (s)he can possibly craft this url for the pipeline history page and get access to pipelineB, because the impl seems to prefer using the query parameter, and ignore the path param.  GET /go/tab/pipeline/history/pipelineB?pipelineName=pipelineA
Though it will not make a difference for this class, but the correct implementation should be super.set / get Instead of this.getString(), all of the APIs inside this class should be calling super.getString() Here and below for other APIs - should be -> super.get*() and super.set*()
Just using the getString(ORGANIZATION_CODE) method (without passing the default value parameter) should get you a null value if the field isn't available.
If these queries are covered by TestJoinUsing, then maybe we could remove them from here?
remove extra empty line
If a unit test method needs checked exceptions, we normally just say throws Exception.
checkNotNull(value, "value")
If you're anticipating non-sponge implemented variants, you should throw an exception for a bad data transaction.
And here. needs some validation.
return symbol != null ? symbol.qualifiedName() : "";
"Modifier 'private' is redundant for enum constructors"
Before go through the loop make sure that position and symbol parameters are not null.
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
Is there a constant you can use to replace the ".done" literal?
It seems like == would be sufficient and faster than .equals() here since we'd be testing identity of the component rather than equality?
feedback session's course ID -> feedback question?
You can reverse the first if condition to reduce nesting. Try to avoid if conditions that swallow a very long chunk of code.
This fits 404 better.
backspace (bracket should be one tab back)
space
builder object is allready there - in base ....
==
Object
We don't want to actually use INVALID_ATTRIBUTE here. It'd be safer to just not initialize the variable at all. So that the compiler will make sure going through the try {} successfully is the only way of initializing the variable.
null? why not just a () -> {} ?
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Can make this into a singleton as we have with UNSET.
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Should be in a finally block?
you're right, not sure how I missed that thanks!
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
Looks like this changeset killed a small shortcut here: if the user shares text and have one only site, we didn't show the picker at all but we opened the editor directly.
please remove this
This method should be static as well. Also, comparisons of the form "0".equals(s) are preferred over s.equals("0") since if s is null the former won't throw a NPE while the latter will. I'm aware that the rest of this file doesn't follow this convention, but there's no reason not to fix it for new patches... :)
This switch can be reduced as follows:  java case 0: case 1: return Rotation.NONE; case 2: case 3: return Rotation.CLOCKWISE; // ...
You can change the 28 case to a default case, and remove this.
this.
Could be suggestion return !selectedBaseResources.isEmpty();
Can we use !mResponses .isEmpty()?
Should be a constant.
@Delawen Sorry I missed that, actually what you have now is perfectly fine from view. Just add @UriPath annotations on host, port and tableName so Camel can generate the correct metadata for the docs
This is using Pattern.compile() on something that was extracted with another pattern?
please use org.ovirt.engine.core.common.utils.ToStringBuilder.toString()
No need for the first +
Should be "InstaPost" actually.
An empty message is OK.
if (signed) is enough. We try not to compare boolean variables to boolean constants.
Is this really an internal exception? If the caller gave us a tag name that we won't accept as a reference name that is rather different than us encountering a form of repository corruption they cannot recover from easily. The caller just needs to correct their input. I'm thinking about the EGit UI case here. If the UI just passes through the tag name entered by the user, runs call(), we need to throw something that tells the UI it should backup and let the user correct their input. But if we got a valid tag name and crash because something goes wrong deep inside of the ObjectInserter, that's a totally different kind of error for the EGit UI to present to the human.
Can header name and value be null?
This constructor should call the more general one with a default value (3 in this case)
just return "" instead of new String()
I would suggest to use the vector's getter methods to get the entryX and the entryY properties.
url.endsWith("/") would be easier to comprehend. String comparison should be done with equals, not == or !=.
could you please revert this to how it used to be? <LINK_0> just a tiny tiny optimization.
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
Please keep these exceptions in the signature. We might want to complete the logic here by throwing the right exceptions moving forward.
It's better to assertInstance(value, CStringValue.class) first. This way, if the value is of the wrong kind, the test fails with an assertion failure rather than an exception.
It doesn't feel right. Why it is required?
Could this and the next logger statement be reduced to debug?
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
You should externalize the string
Unnecessary?
Add synchronized to this method
Restore visibility of this and other methods in this class when unit tests are moved to jaggr-core
Does this method have to be synchronized, considering that capacity is final?
should we assert that this value will never be positive ?
Yeah.... this is functionally ok, but it's very wasteful. Just use traditional if (color != null) logic. It reads better.
Use EnumDyeColor.byDyeDamage(stack.getMetadata()) - that's what ItemDye uses. This should fix what @Aaron1011 mentioned
You can use OptBool here.
this can be simplified to this.sparql = checkNotNull(sparql) and the others here too
Set these in the field declaration, and remove the constructor?
Enforce immutability
context.getExternalFilesDirs required API level 19 and above, our minSdkVersion is 14. You can use following support library function: <LINK_0>
We should avoid this build check, can use support library functions where possible.
Is this System.out required?
IMO this should move to the presenter in the first place.. i.e. where you call view.init( this ) add the next line that calls if(this.canUpdateProject()) { view.enableAddAssetButton( false ); }
Where here is just disabling and in the ifs above and below is hiding? Not saying something is wrong, just interested.
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Replace 1 with TokenTypes.EOF.
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
do you think it would add clarity to move "this::CallRequestAccessTokenEndpoint" to a variable: Function<Client, Response> endpointCaller
can infos be null? (the check in line 112 above implies it might be)
how about using DomainXmlUtils#USER_ALIAS_PREFIX instead? (just for consistency)
This supplier is potentially called twice, so the same data is fetched from the DB twice. It would be better to use MemoizingSupplier here.
Looks good to me. Can we do something to identify other occurrences of this issue?
Are our current http log files in UTC or CEST?
why anonymous class instead of simply creating an instance, and using: auditLogDirector.log(auditLogableBase, AuditLogType.IRS_BROKER_COMMAND_FAILURE;);
Isn't this test the same as saying "API.getDesignProcessDefinition() should call service.getDesignProcessDefinition()" ? In that case, it would only suppose you verify(service).getDesignProcessDefinition();
@erdemedeiros what do you mean? An order?
@erdemedeiros what do you mean? how can we reduce it?
why static?
Why not just simply "command.setVM(vm)"?
Could you mark the constructors @Deprecated instead of deleting them / reducing visibility? It makes it easier to transition between versions if we deprecate first, then delete later.
If I understand correctly, the purpose of the patch is to fix a specific problem - failure of migration because of 'refreshCaps' failure to take a lock. It is enough to take a waiting lock inside the ActivateDeactivateVmIntefaceCommand before calling the refresh, instead of locking the host for the whole migration period. You can pass 'lockProperties.withScope(Scope.Execution).withWait(true)' as the 'lockProperties' of the parameters you pass to 'RefreshHost' (the 'RefreshHost' should pass it the 'RefreshCaps').
understanding this code some more now: - it seems, that if perform() is called, then runningFailed() should be called in case of error so we have to: 1) on #232 catch Throwable, log it!, and then proceed to running failed. cleanupPassthroughVnics can be done withing runningFailed method. 2) this code needs to be broken. Usage of && might be nice to look at, but it's wrong. We need to call cleanupPassthroughVnics even if only initVdss failed, and we cannot call runningFailed, because there wasn't any run. Also we must not call cleanup twice. So this method should look like: try { if (!initVdss()) return; } catch (Throwable) { cleanupPass  return; } perform();
Shouldn't the endSuccessfully be in VmLeaseCommandBase?
Map.replace also runs a containsKey:  The default implementation is equivalent to, for this map: if (map.containsKey(key)) { return map.put(key, value); } else return null;  I think a simple put is enough: you want to make sure you have the given expiration in tokenExpirations
should be public
Let's include the giver and recipient here too
This is the only part in this PR that I'm concerned about. Rethink this change from <String, String> to <String, Object>. Talk to @pshivana. I'd use the @Load mechanism instead to provide a way to get this, or the GoApplicationAccessor. I know it changes per job, but only one job runs in the agent at a time. The issue I have with changing it to Object is that this is no longer serializable. If we want to move plugins out into a different process, we cannot. Ideally, this wrapper should not be an object at all (as we've spoken). It should be a message based API as well, that the plugin can use. But, I know why this is done (for convenience of the plugin developer) and I agree. But, I don't think this should be passed in through the request params.
Couldn't we just do sessionFactory.getCurrentSession().delete(plugin);
I think that the log messages related to extensions cannot be part of "pluginNotStarted"
Simply return the id. It's either a ticket id, or a JWT. Right?
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
Can we refactor both of this if else if into one condition ?  java if (!accessToken || (accessToken && expiresIn() <= 0)) { accessToken = generateAccessToken(); }
wait.forElementClickable() should be used before
Check if there is an appropriate constant for "no metakeys" mask.
findFirst(".event .btn-see-event-info")
I don't think we use final for functions in our code base
I think it would be nice to create a new task type for the hadoop indexer. (This is only really used for metrics emission, and I'd like to be able to separate them in mmx_metrics)
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
> Use this.mHandler.removeCallbacksAndMessages(null) instead. Done in Patch set 2
Do we want to keep the method names like this or give it a more general name?
"...but was: %d:"?
do we need to use static on this private method? Please update javac doc
Please replace empty string with a proper error message
Can the processor name be null?
suggestion assertThat(got).contains("Description");
Should the 3 contains be replaced by isEqualTo ?
Looks like after/tearDown suffered the same fate
delete() should be executed from within the future so it doesn't through right away.
FutureUtils.assertNoException missing
This is a good way to handle exceptions in the CompletionStage. However, as you mentioned below, it makes sense to handle Try.NonFatalException in a special way. Because FatalException and NonFatalException cannot be created outside of a Try, they are under our control and it is safe to unbox them. I.e. we know that their only purpose is to wrap exceptions in a RuntimeException. From what I see the code should look look this: java final CompletableFuture<T> completableFuture = new CompletableFuture<>(); try { completableFuture.complete(get()); } catch(Try.FatalException x) { throw x; } catch(Try.NonFatalException x) { completableFuture.completeExceptionally(x.getCause()); } catch(Throwable x) { completableFuture.completeExceptionally(x); } return completableFuture;
It isn't clear to me where this user is created?
Why distinct is applied since you create no duplicates with the r.createObject(AllTypes.class).setColumnLong(i % 5);
Simple for-each?
This utility class (even though it is used in the interceptor context) should not throw an InterceptorException but some other exception.
The trigger code should simply let the exception escape. The code calling the triggers must be robust to all exceptions anyway, or a single exception from a trigger would halt the main loop. Simply add throws Exception to Trigger#isDataAvailable. Likewise, exception logging will be done at the next higher layer.
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
Please simplify this just to nameModel.getObject() because it is a bit confusing at first sight.
And for new methods.
I got confused by this, can we move the second and clause of this if into a single line?
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
Indentation should be deeper. These are easier on the eye (the break is less jarring)  java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {   java protected static Object invokeMethod(Class<?> definingClass, String methodName, Class<?>[] parameterTypes, Object invokingObject, Object[] args) throws Exception {
Not sure we want this in the example?
As you already need to touch this file, I think this empty line could be removed.
As you already need to touch this file, I think this empty line could be removed.
What was going on here? This change shouldn't have been required, I don't think?
please use org.ovirt.engine.core.common.utils.ToStringBuilder
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
what about using IntSetsExternalization.writeTo() and IntSetsExternalization.readFrom()?
Please bring the braces back.
Is there any way that this may lead to a serialization format that is not backwards compatible?
inline permissions and then remove redundant this
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
Please add a check here that would simply return if the color being set is the same as the current foreground color (linkColor).
This resource needs to be managed and disposed when appropriate. Sometimes we use org.eclipse.jface.resource.LocalResourceManager. It also might be appropriate to change the org.eclipse.e4.ui.internal.css.swt.definition.IColorAndFontProvider interface so that it becomes responsible for managing the resource, if that can be done.
How about applying this method inside convertColor to avoid duplication and to make sure the same input sanitation is applied? Looks like in all cases color.trim() is desired before calling convertColor anyway.
What if a student or unregistered user calls this endpoint?
Similar to the other tests, assert that a feedback response with ID "randomNonExistId" doesn't exist.
break the line at high level. suggestion String[] invalidIntendParams = generateParameters(firstSessionInCourse1, 1, Intent.FULL_DETAIL, "", "", "");
And also here: refer to L55 of calcite/core/src/main/java/org/apache/calcite/rel/RelShuttleImpl.java. The accept method does not change anything on this instance; it returns a modified copy of child, which you then discarded.
we can't change this logic: it is essential for traversing a changed tree.
Objects.requireNotNull()
Could change the return type on method to Collection
Collections.emptyList()
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
This variable looks final.
I am not following here - why do we want this in sync block?
Can't we just log in DEBUG otherwise ?
suggestion Assert.notNull(consumer, "consumer must not be null"):  Parameters that are not annotated as @Nullable must be checked.
suggestion Assert.notNull(headers, "headers must not be null"); Assert.notNull(searchRequest, "searchRequest must not be null"); searchRequest.source().size(0); return sendRequest(searchRequest, requestCreator.search(), SearchResponse.class, headers) //  we should check non-nullable parameters and as we don't need the source in the response, we should set it to zero
if exception is thrown by validateRequest, thrown configuration should be done right before validateRequest is called
This seems to be outdated.
... that way when accessing them from the class we won't need to use "this." for example fString = string vs this.string = string
To make sure I understand: before, you would get SafeIllegalArgumentExceptions if this was not a string, but now you just get a plain RuntimeException that wraps an IOException. Is my understanding correct, and is this behaviour OK?
again, use 'guid'
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
instead of using uid.createGuidFromString(id), you can just give 'guid' (it's saved for you in the parent)
Please, reuse your extracted method for checking if a file is an Erlang source file.
Why do you not rename your extracted method's parameters appropriately?
- [x] What does this do since this is not building Java? Is this just copied from another project that this code is based on?
this line was probably copied from somewhere else but I think the message could be improved, for eg Charge with charge_external_id={} was updated from <old status> to <new status>
Not sure why PaymentDetailsEnteredEventDetails is used here ?
is this not just locking the charge? Don't we already have a method for that in charge service
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
I think dealing fire or lava damage consistently is better than a simple setHealth.
I'd call the variable entityClass
Delete can be better handled with this. <LINK_0>
What exception? To somebody reading the new version, this is confusing, this method doesn't throw any.
I'm mostly getting black image. Got valid image only once. :(
My bad, I meant to say: "to be able to **change** the page source". I will improve this exception message.
this can be package private
this
Nit : suggest having a local visibility int like you're doing in other places, or a ternary to inline, so you don't duplicate this code
You might want to store the view as a field in your class if used multiple time. findViewById has a non negligible cost.
(ListView)  can be removed
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
I think Local.ROOT is probably a better choice.
why is it Collection of Strings (instead of String)?
You may want to add assert size - toRemove.size() >= 0; (my genIntellijRuns task enables assertions by default)
For safety and future-proofing it might be worth including the set of potential answers as a list or enumeration in this class (or elsewhere) and using a count of that set. This seems like invisible/loose coupling to a concept that won't necessarily be clear when updated elsewhere.
Don't think items can be null, and ArrayList (as well as List and Collection) has an isEmpty() method itself...
This drops all rs and collapses all ns to  .
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
I think this pattern will work throughout the whole string, while we want that it only works for the suffix of the string, which is not enforced. To enforce it, it should be "_[0-9]+_g\$$" or "_[0-9]+_g\$\z" or something similar.
The message may be confusing as it talks about pushing and submitting. Perhaps for this class use: " To save changes you need 'Push' rights on " + REF_CONFIG"."
you can use standard java NotSupportedException
checkSpecificAccessControl() could also throw the UnauthorizedAccessException directly? P.S. check* sounds like a action rather than something returns a boolean.
Please do check on null for all such getters. I believe we previously returned null in such case, because object was a Date, now we return primitive long which isn't an object. We should probably return Long so its serialized either as null or long value.
All setters with Long as param should check on null since then Instant.ofEpochMilli() will fail on NullPointerException. We should safely set null to the base object instead.
Should be getStartTimeAsLong() and not getGenStartTimeAsLong().
Maybe 'cluster.hasRequiredSwitchType()' or 'cluster.isSetRequiredSwitchType()' without passing the 'null' as a parameter.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
here's a typo; it should end in 'Vdsm'
Keep this check?
For consistency, we always include curly braces for loops or if-else statements, even if only followed by one line.
Looks like this field is never read.
nit: wondering if we should use the same IllegalArgumentException if property is missing as with getString. Seems like we always encode a default.. I am not terribly sure which is a better model, but this will keep it closer to existing behavior at the least.
Style issue: @Override shuld be on line above the method declaration
Would it be the same to say lemmasList.addAll(keyValues) here?
why not just getResourceManagerRoot().toPath();
Maybe simpler: "return newRoot + " is not a directory.";
As you rely on semantic anyway, I would rather check if owner of method is abstract, that would avoid a loop. Moreover, what happens when there is no semantic ?
Null check for leaderElectorListener
same as above. why wrap the exception for logging?
Why are we wrapping the exception here?
Check error code/description
change "login" to "loginDropDown"
suggestion return login((String)null, null);
Instead of null can this pass in a simple Supplier of some simple ExecutorService? That's out of scope for this really but it will help clean up test noise.
decrease to TRACE level
Instead of null can this pass in a simple Supplier of some simple ExecutorService? That's out of scope for this really but it will help clean up test noise.
Guess return type should be void
.map(doc -> run(doc))
useless
Can just use mapper.readValue(partFile, Part.class). Would encapsulate this in a helper (i.e. readPart(partFile))
Re-use temp file
why change the readability status here?
you are calling stream.addLivePacketListener on the onStreamCreate but not removing it on onStremDestroy.
Since I'm suggesting creating the Response with the input stream this could simple return it now
Why is it public?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
checkState(mPut != null) ?
nit: you can do mLGNames = Sets.newHashSet();
@ribhavsharma please take a look at [this](<LINK_0> You will have to use the clone() method while returning the value which will also fix the travis-ci build failure :)
Do same for this one
is to possible to catch some Exception sub-type? I mean some ParserException..
why do you want to whitelist it at the end?
Minor nitpick (s/exist/exists)
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
please use for the positive tests the following convention: assertThat(validator.shouldVdsBeFenced(), isValid());
Perhaps consider to change the message so it will indicate, only one domain should not be active (instead Both domains)
is it better practice to do the following if (VDSStatus.NonResponsive.equals(vds.getStatus())) same for the check above
Looks like epoch and reset logic should be pushed to pool as generic solution. Isn't it ?
? should only interrupt on InterruptedExeption. Also, the waitForConfirmsOrDie() needs to be its own try block - it can throw exceptions (timeout etc), so the close() would be skipped.
And this one is good, too.
final
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
Add Preconditions.checkArgument checks to verify that the passed buffer is not null and that sessionProposedCapacity is greater than zero.
Nit: "Creating ephemeral nodes..."
Typo: "visibiltiy" -> "visibility".
nit: getAdmin method -> getAdmin() method ?
lookupHost is probably not the right name. It has other connotations and it doesn't really say what it's doing. v4IntToInetAddress? intToInetAddress? What do you think?
Indeed, that is better than my suggestion. Let's do this.
add check for tracker==null or get NPE when they try an unprovisioned network (ie try for wifi on a device with no wifi).
Don't you think there's a need to add a constructor with final SSLSocketFactory sslSocketFactory, final SSLParameters sslParameters, final HostnameVerifier hostnameVerifier
This removes an existing constructor. We can't do that. Hint: Keep this constructor, copy previous constructor from earlier code and paste it just before this constructor.
Symmetry (throw)?
Please use CommonUtils.loadResource(). It allows overriding config files by placing them into /etc/sw360
I find it a bad idea to add a dependency from sw360-portlet to a backend service implementation just so you can access some resource. Please move the resource elsewhere and remove the dependency.
magic constant
Make this package private and remove the redundant null check.
Maybe it's better to use Collections.emptyList() instead
you don't need use replaceAll, because above you used normalizeJson
Those two methods are similar. Consider using one.
Perhaps a good practice is that the driver is switching back to the defaultContent to reset the driver's state. That way, the next method that is being called after this method does not need to know anything about this method.
?? is it empty for loop or github is not showing the full code?
"return position;" maybe?
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
If we are not implementing, can we throw upsupportedoperation exception ?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
I prefer the ?: syntax, also I think isLight is a leftover from the merge, because it is not needed suggestion mSwitch.setIcon(mLinear ? R.drawable.ic_apps_white_24dp : R.drawable.ic_list_white_24dp);
Seeing this essentially duplicates the load code above, I feel there must be a more elegant solution to this - something that just retriggers loading of all the existing observable's data...
make it final. You don't want classes extending it to override this, as it's driving the analysis.
@vilchik-elena It may be preferable to check the kind.
the tree is necessarily a NewClassTree here, so you already know it's going to be of the good kind. You can drop the if.
What about to use constants for the key strings?
What if we return an empty list instead of throwing an exception?
ProductInventoryClientImpl does not return null but 0 when exception occurs. Perhaps returning null would be the correct way, so the change should be implemented in the client..
This should stay final
Should this method be final?
I would prefer toString to also write duration
Is this parameters really mandatory? I thought its default was false.
Keep this sorted alphabetically, same as in the validators declaration.
This should also test that the value matches one of those considered acceptable.
IntStream.ofRange(beginInclusive, endExclusive) .mapToObj(ImmutableList::of) .collecto(toImmutableList());
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
You should be able to use the diamond operator here, i.e. new ArrayList<>()
This is redundant, please remove.
Isn't it better to represent its name?
still for DAO
This test is wrong, check that the expected exception gets thrown using the expected attribute of the @Test annotation
The default matcher tests equals() AFAIK. So basically you can do: this: Assert.assertThat(myVar, Is.is("expected value"))
Looks like you didn't use the plugin to generate these test methods
I'm thinking the constructor should be public as well so that applications can use it in their own authentication providers.
Encapsulation
lists shouldn't be copied, best copy them; java this.targetContent = new ArrayList<>(targetContent);  as if anyone still holds access to the parameter list, it can modify it
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
This is a nit, but should this be "can reuse the buffer FOR the next stored procedure"?
Add Preconditions.checkArgument checks to verify that the passed buffer is not null and that sessionProposedCapacity is greater than zero.
Can we roll this into the parseJobId method and maybe rename that to reflect its purpose of creating a manager from config along with the attribute that its keyed on? E.g. getManagerFor... or getManagerFrom...
- Can we inject the EventHubWrapperFactory into the EventHubSystemProducer, EventHubSystemConsumer and EventHubSystemAdmin instead of class-loading them via config? It'd be much cleaner with types that way. Use-cases at LinkedIn that require tunneling can inject their tunnel-aware versions of the EventHubClientWrapper.
Maybe something like  String inMemoryScope = config.get(...); if (inMemoryScope != null) { return IN_MEMORY_MANAGER.computeIfAbsent(inMemoryScope, new InMemoryManager()); } return DEFAULT_MANAGER;
All attributes s values were -> All attributes values were
Since you log the whole object you can change ending to deleted for {}., since attributes toString() is like Attribute:[content].
Attribute object is unncessary enclosed in [ ], opposite to createAttribute() method/message. I suggest Attribute created: {} and Attribute deleted: {}.
&& isFile() afair more exact check
The config location is not ~/.motech , but ~/.motech/config - in Tomcat ITs we have no config because of this
Nit: static import recordDefaults
I think you've set fStateValue to nullValue in the constructor in this case, so this is pretty much dead code
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
This is not equivalent.
This should use a different match strategy.
Good plan.
please update formatting:  if (c.getId() == null) { em.persist(c); } else { c = em.merge(c); }  tabs instead of spaces missing curly braces additional spaces around braces all over the code
Instead of two fields Double, you should use double with value Double.NaN when field is supposed to be null.
Is the intention to change CalculationTask and CalculationResult to handle multiple values in a later PR?
measuresByTrade = measures.stream().collect(toImmutableMap(CalibrationMeasure::getTradeType, m -> m));
Should be : sizeInGiB
This will loop forever if the user sets a negative size.
No parens on condition.
Is it possible, that the context is null?
Please read up on the correct usage of WeakReference. get() returns a regular reference, true, but unless you save this returned value somewhere, the WeakReference you hold does not prevent the garbage collector from collecting the context your weak reference points to. So you have to introduce a new local var, write the result of contextWeakReference.get() to it and use this regular reference for the remainder of this method. Otherwise you risk running into a NPE
no need to assign this to a variable
shall we add some message here?
Can you make all of the accessors final?
Are result and errorMessage not applicable for workflows?
Do you think this is non-useful? I figured there would be cases where people would want to test code that behaves differently if the SDK claims to be something really old that we'll never fully emulate.
These naked if blocks without braces are causing the build to fail (checkstyle). Need to add braces. ~~Alternatively, since we depend on Java 7, you could use java.util.Objects.equals to simplify this method:~~ Apparently we still target Java 6 (that makes me a sad panda)  return Objects.equals(this.name, cacheKey.name) && Objects.equals(this.sqlObjectType, cacheKey.sqlObjectType) && Objects.equals(this.sqlObjectMethod, cacheKey.sqlObjectMethod);
Similarly here - I don't think people tend to subclass SAMSequenceRecord, but I think this class should continue to implement logical equality and not require type equality.
can it be made in one line?
Why is this needed?
Why does the newline have three backslashes in front of it, but the other control characters only two?
set twice
Why are you removing the setIDs here?
I'm not sure it's safe to change between fake and non-fake sequences. I'm having trouble working through it in my mind.
Assert.notNull() - just for fail fast, since we really don't support null for this property.
Assert.notNull() as well
was the system.out meant to be removed?
Consider using == maybe?
do we need traceId to identify the object? i think the previous implementation was fine
(Hmmm, I think both the original and the suggested fix might be wrong. <LINK_0> ) I think for now, continue the pattern. Create an issue to investigate whether we're affected by the issue described.
Please remove usage of .class, for the same reason as above.
wonder if smart or over cautious but the last operand could be replaced by isNullLiteral((TypeCastTree) arg).expression()) And this should be tested with something like : IOUtils.write(s, output, ((String) (null)));
@vilchik-elena Style: I would have created a variable for (ExpressionStatementTree) statement).expression()
Is it really filter name?
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
The type of the owner should never be null. Did you encounter one? Moreover I think that the first equality test is useless, as isSubtypeOf also check for type equality.
it cannot be a constant: it needs to be a variable (like timeout) so that it can be changed per test / per class and eventually adapted for EE
Can we return an empty list here instead?
Should this check to see if result != null and throw an IllegalStateException? If someone accidently uses this and gives it multiple results it seems like an exception would be more helpful than just having the last one win
@fanifieiev the same above.
@fanifieiev the same above.
@fanifieiev the same above.
It might still be nice to not add any network overhead to a request, even if it's time to fetch a new limit. Could we just have a background scheduled executor that fetches new limits, then updates the rate limiter when there's a change?
I want to method accessor to be package private :eyes:
Let's move the bundle stuff into the newInstance() method like:  ... newInstance(String permission) { Bundle args = new Bundle(); args.putBoolean(...) }  So the logic is contained entirely in that fragment
Is this intentional? You are forcing the value to 'true' Maybe a simple assignment is clearer
You may return Long type value, not Dto
Could delegate to base class instead, super.scan(msg, originalParam);
I think this can be set by spring application.properties without creating bean explictly.
I don't like putting a synchronized block in the line of fire on something like this that doesn't need to be. This is a global lock and exactly the type of stuff I find in our production environments.
10 is hard coded, should it be configurable ?
should this count be parameterized?
I think we should store ignoredRegions instead of ignoredLineNumbers. Single lines that need to be ignored can be stored as <LineNum, LineNum>.
Pull this into a static final variable
I think this can be a bit simplified: return getVm().getDiskMap() .values() .stream() .map(disk -> (DiskImage)disk) .anyMatch(vmDisk -> vmDisk.getDiskStorageType() == DiskStorageType.IMAGE && storageDomainStaticDao.get(vmDisk.getStorageIds().get(0)).isBackup());
Suggestion: Please change this method to be called isDiskType(DiskStorageType diskStorageType) and use it also for Cinder
unneeded checks
This is a stream range query (scans the bitsets on the sequencer), we should re-add that metric. Actually, there's a bug right now related to bitset queries #2747
ArrayList should be constructed with fixed capacity.
Here the check should be improved that the exception is only thrown if id **and** key are null
Logging.
Logging.
maybe dataStore variable name instead of people?
Can be static.
This drops the packet. This shouldn't happen just because it doesn't have the extension. I'd expect the wrapper to handle this logic.
this should be indented if so the god of eclipse permits.
Should use ToStringBuilder.
TmfWindowRangeUpdatedSignal
Extra ", "
shall we rename this as brokerUrl ?
We shouldn't be accessing all properties like that. First it requires permissions for all which is not a good thing as it exposes everything. We should only access those we really need. In addition, this assumes that the system hash table persist in the system when in fact, it could be changed from under you by someone else via System.setProperties()
if you don't specify the **this.user = null**, it will be null when the class is instantianciated, so this line is redundant
You could put these checks in a constructor so you don't have to repeat in these factory methods.
I think you should have implemented this method non-recursive as simple while loop. The parent line is linear and it should be quite simple. In addition, the non-recursive implementation would avoid creation of a new ArrayList for each level in the parent line.
The NamePredicate object is the same in every iteration. Hence only one instance is required outside of the for loop.
I'd simply call the property changed event "SearchEnabled".
nullity check here too :)
nullity check here too :)
scaledData, thread safety and all
Should we add some kind of bounds check here?
return a copy please
I can't remember our usage paradigm here, but I believe if the value is not null, we should use an assertion that the value is indeed a Map. Otherwise the caller of this method is probably trying to do something wrong (i.e. expecting a map when the property is not a map), which would be a bug and should be fixed.
Right.
Please use ConcurrentHashMap, the implementation behind Maps.newConcurrentMap() has higher overhead and is less scalable.
you aren't calling super class. add super(params)
This should be: if (info.status() == Status.MERGED) {
Are there unit tests for channelSignIn?
perhaps you need to trim first ?
this(...,..., LogLevel.INFO);  apply the same pattern to other constructors.
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
but this should probably use that mechanism, too?
would we need the lock if we used a ConcurrentHashMap and LinkedinBlockingQueue?
Local to this package? If so, remove the public?
Just putting it out there early in this review that I'm not too big of a fan of LongRunningOperationStatus - it's very long.
Was this detected by findbugs?
This test is exactly the same as testPublishWithNullUsername. I think you meant to pass in a non-null username into resource.publish()
@ham1 , would you please refrain from String#format? Technically speaking, it uses regexps behind the scene, and string+string would look simpler in this case
random.nextInt(this.totalWeight)?
I'm still looking for verification that this is the correct change. I can't find any information on what this number is supposed to be
rename tempVar
Please format the parentheses throughout the file, as you would have requested me to do.
message can be simply converted to a constant: s/Edit {0} Virtual Machine/Edit Virtual Machine
Make this method synchronized.
You can use ThemeHelper#isLightThemeSelected instead of hard coding it.
Shouldn't we check for isJetpackConnected and isUsingWpComRestApi at the start of this method? Don't we need that for the newActivateThemeAction dispatch?
Extra trailing comma.
What is SNP_COUNTS_FILE in this context?
same here, I think it should be Files.createTempFile
Should use the location.
I think most of the other new 'getter' methods can be removed in favor of package-private visibility on the field. Keeping the field access simple, rather than creating all these new methods, will help future code changes by minimizing the call stack one has to follow to understand what is going on. However, I think this one should stay, because it provides access to a non-final field, whereas most of the others are final already. It should be package-private, though, instead of protected, because they don't need access by subclasses.
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
Why don't you use String.format?
it wasn't handled before, but I would also add something like: if(lastColon == -1) { throw new IllegalArgumentException('Invalid endpoint format. Required format is<ip>:<port>.') }
Were the two other if statement just never executed because this is the MigrateVMCmd, which should only be migrating a VM from one host to another (i.e. no storage migration)?
Instead of changing the method that is getting called, the missing one in search query can be added here and it seems the updateDomain method in managementserviceimpl is not in use. It can be removed
please dont remove explicit initialization
Please use Collections.singletonList()
Don't check these in.
duplicate line...
Now mPrefFullscreenReview is used before it's loaded
This method looks horrible to me (and to whoever is a sane engineer, I should think).
should make a static final.
null-check
If position() gives anything other than 0 then this will give a LimitReachedException won't it? Did you not mean capacity - position?
Missing .duplicate() on byteBuffer
Missing duplicate
Are there any const that can be used instead of duplicating strings like this?
Move to update please. < layout
linebreak style is inconsistent here
consider saving the value of group 1 and group 2 here rather than the whole matcher
no need for final here
consider being paranoid and prefix with "line.length() > 0"?
Can we adhere to the coding style of this file and not have multiple return statements?
Try using StringUtils.isTruthy(this.path)? <LINK_0>
We can also move this up to the declaration and remove the meaningless initialization.
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
The value is not assigned to json?
I would avoid throwing RuntimeException here. Maybe it is better to wrap it to DevfileException?
Should be "InstaPost" actually.
If you have commons-lang3 in your classpath, you can use ToStringBuilder
Is there a reason for not using the MoreObjects.ToStringHelper instead?
let's make a meaningful constant for 5
Use threadFactory in ThreadPoolExecutor construction Also there was CallerRunsPolicy before. Keep it, please.
static
to avoid some synchronization here, try something like this:  private Semaphore getSemaphore() { if (sem == null) { synchronized(this) { if (sem == null) { sem = new Semaphore(maxThreadPermits); } } return sem; }
If storeThread == null concurrent tryCommit() or deregisterVersionUsage() may change its value between get() and set(), they are not synchronized like this commit() method. It looks like compareAndSet() should be used here too instead of set() or something else should be changed.
Shouldn't this be maxSize <= 0?
return array == null || array.length == 0
Why do we not use  java final Object[] array = new Object[length];  ?
A bit shift would be faster ? Also we don't check for integer overflow issues.
what if my value is " " ? should use trim
The constructor of DynamicStringProperty is package private. The reason is that we want people to use DynamicPropertyFactory to create instances where DynamicPropertyFactory will lazily install a default configuration source and attach to the dynamic properties, if none is explicitly installed. You might also want to make this constructor package private and provide a factory method in DynamicPropertyFactory. Or, try call DynamicPropertyFactory.getInstance() in a static block at initialization of this class. === update === After looking at the constructor of PropertyWrapper, it calls DynamicProperty.getInstance() where DynamicPropertyFactory.getInstance() is called. So the initialization of a configuration source is already taken care so it is not necessary to force it again. The constructor can remain public.
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
Re-use temp file
is this 10000000000l or 100000000001? Use upper case 'L' a lower case 'L' should not be used for Longs or variable names.
"The request cannot be processed due to the following issues"
could we instanceof here?? just a thought?
perhaps if not has permission?
code format
please also add the GUID which is important.
Why not just use the element.toString() instead? If we want to use something specific in the printing of the messager we should pass that in the arguments, and not do it in the toString. For debugging it would be much easier to just have element.toString() here.
Do you want to check exists?
I don't think the process deploy should fail in the case of temp file deletion fail
add block
Assert.notNull() ?
this.m_
decrease to TRACE level
this does not handle the empty 'lists', it will throw an exception
nitpick. Suggest to use a init factor " new ArrayList<>(batchSize)"
I also can't understand it, but now result is always empty. will try to debug it.
If this method is called with timeout = 5 seconds, and then getWaitTimeForPermit() returns 30 seconds, I think this implementation will incorrectly sleep for 30 seconds rather than 5 seconds.
i think this should be warning. it is not expected.
is this needed?
Sorry! I meant we don't need to pass the options in!
This is essentially one line of code, I'd prefer to inline this.
These assertions don't help much to validate correctness of the returned result. Could we assert on the content?
Not related to the changes from this PR, but now that the ValidatorFactoryImpl is cleaner, I noticed that there are some getter methods that are not coming from any interfaces. Like for example isFailFast(), isTraversableResolverResultCacheEnabled(), getExecutableParameterNameProvider() and maybe others. Hence I wonder if we shouldn't pull then to HibernateValidatorFactory ?
Should be passed in through the constructor or a set-method
Can we change this to setValidator() given that Jwt is implied with the generic
move inside of for loop.
Could you do:  String[] strings = new String[num]; Arrays.fill(strings, ""); return strings;  ? :)
We have a new U.nonNull() method.
Could change the return type on method to Collection
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Collections.emptyList()
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
hmm, do you test the rest service for update? What about if you try to update a given provider (without to change the name)?
if you create replacement here, and there's no new test in following patches, make this method private as it seems, that this is not use from outside of this class.
Can check isBlank()
why public? Are we planning to use it outside of this class?
This method can (and should be) private
Please use Collections.singletonList()
I don't think we should ever update the property map for bindings nor should we update the binding instance. What can we do instead is to return a copy that is populated with the default value (i.e. the value that is supposed to override the unset value).
Doesn't this reset the values set by the dataBinder (with spring.cloud.stream.default prefix) above? While this is what we need to override the spring.cloud.stream.default values with the binding properties provided explicitly (via cmdline for instance), the spring.cloud.stream.default values will also get overridden with the application default values here. For instance, if the application has spring.cloud.stream.default.producer.partitionCount=5 that would never be set eventually because of BeanUtils.copyProperties at line:192.
Can be simplified using Hamcrest.
I think this method could be private.
You could add a package-info.java file to the package
suggestion return endpointHost.substring("https://".length());  Just a but more clear than the magic numbe 8
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
@Override
Please use a [StringBuilder](<LINK_0> instead.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
This should return KeyValueFilterConverter<K, V, C>
I would add a checkNotNull here to be safe.
We probably want to hold on to a reference of the mapping context ( MappingContext<? extends ElasticsearchPersistentEntity<?>, ElasticsearchPersistentProperty> mappingContext) in the instance.
I don't think there's any reason to separate this from the constructor. It could be a different method within AffinityGroupModel, but it could be private and called from within the constructor.
Revert to a Set, List would negatively impact performance
I would move #163 afterwards, although the compiler probably optimize that anyway
EmptyConfig.INSTANCE?
It is still worthwhile to check if it's null or not to not recreate systemConfig object in later calls. But as it won't load anything it's not that big deal, so up to you.
suggestion return fileSystem;
Multiple method(*) methods
Multiple method(*) methods
Maybe remove the method("POST") as we are setting method("PATCH") almost right after it
intentional to remove the shutdownClientOnClose?
> ClientConfiguration doesn't have an addHeaderDelegate() method. Are you saying that we should add one? I don't say that we should add one. But I see these advantages of this approach: * easier adding of HeaderDelegate to client * we don't provide access to all ResteasyProviderFactory methods, but just to the one method, that is really needed (addHeaderDelegate) I currently doesn't see any disadvantage of this approach. Do you see some? WDYT?
We don't need this cast.
Very helpful
A few things here. For one, we're inconsistent in creating the local boolean methods like isDeleteInProgress. Above we mix using a local copy of the BranchState and locally created methods that do the same thing. This should be consistent. Secondly, This seems to not adequately be dealing with all possible branch states, I would think UNKNOWN and REBASELINE_IN_PROGRESS would also result in not being editable. Finally, all of that is sort of moot in that in reality I think isEditable should simply be the result of the branch state being either CREATED or MODIFIED, which is a much smaller set of tests, easier to read and maintain, and uses positive rather than negative assertions.
token.sum() can be replaced with getToken()
@tmarzeion you should start PatientDashbordActivity here with the created patient :)
Refactor the get id code to GenericDAO to remove the redundant logic.
@akolodziejski please use hamcrest matchers. They are much nicer. You would write something like assertThat(patientIdentifiers, containsInAnyOrder(hasIdentifier("101"), hasIdentifier("101-6"))); where hasIdentifier returns your own matcher. Let me know if you have any questions.
Just use bytebuf.writeZero(size); ?
nit: could you please perform the release calls in a finally block so the ByteBufs get released even if the assert fails?
Can we assert context == null here?
Change to ...sqlDatabase is not properly...
check for READ_ONLY style is missing?
I think you need to do separate request to the db to retrieve all cars of this person
getNodeEnd() will return Long.Max_Value is the node is not on disk... which brings us back to the original state. And as expected, the assert in the benchmark fails.
length - 1 ?
Why are these not returning mAlignmentStart / mAlignmentEnd ?
I'm not sure this is used for anything, I need to verify.
this should match with the place token
You could just do setAvailableInModes(ApplicationMode.VirtOnly); Refer VmListModel.java
Lets change the default to GRACEFULLY
handleExceptions();?
I think this is cleaner  public long size() { return writeOutBytes; }
The super() returns "" on null. Why should we differ?
Is this still needed? We don't add any other elements, so parent.get(anythingElse) should return null anyway.
Is there a chance of a NPE? could be getFile() null?
Should be sufficient to synchronize on entityBacklogs, right? Same applies for onChange method.
this is the exact context of the AbstractJpaDao.em() - shouldn't it be only the responsibility of the interceptor to set the entity manager to the dao ?
Maybe some not-null check should be added here.
this test failed for me during a parallel run. This parallelizable test should have a path which we know is there but is private to this test; we can have another one which invokes on a missing path. The full root scan should be run in the ITestS3GuardDDBRootOperations test, before any cleanup
Is this really needed? Is there a more deterministic way of waiting?
Use hamcrest.
Please externalize these strings.
Having the SWT.Read_only gives the text with context menu items {undo, cut, copy, paste, delete, select all , right to left reading order, show unicode control char , insert unicode control char, open IME, Reconversion} Since our objective is only copy can we restrict the text selection context menu to select all and copy ?
actually calling .layoutData(new GridData(......)).create... should be ok here, correct? like you changed from supplier to layoutData in addFiller()
No need to use ConcurrentMap.
Query %s failed. Also, I'm pretty sure we already log failures somewhere? Or if we don't, that there's a good reason for that.
Is it normal scenario to update tag without queryId? If not, then should we throw exception?
I would add a check if instance is != null, because with this, everyone can overwrite the current instance if its not null. Or only create a new instance in the getInstance methode, if instance == null
You can remove this to simplify it to getActivity().finish();
I recommend moving this logic to a static method in MainActivity.newIntent().
You should be able to use the diamond operator here, i.e. new ArrayList<>()
Same for this one.
Although not required, I prefer iterating such sources when the child subscribes and not when the sequence is assembled.
please create a more specific exception that extends this one.
make a helper method for this? closeUncaught(out) or something alternatively the close method could throw an IOException
should this be in a finally block to release in the case where an exception occurs?
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
reverting this change doesn't make anything to fail
![MAJOR](<LINK_1> Rename this method name to match the regular expression '^[a-z][a-zA-Z0-9]*$'. [![rule](<LINK_2>](<LINK_0>
There is a double ? sign here
It looks that the scheme is sometime _ChatScript_ and sometime _chatscript_. I would always use _chatscript_ in lower case as the scheme in annotations, examples, services...
@davsclaus , thanks, very desirable feature, but small misprint in vodka :smiley:
Let's make sure error messages are consistent.
Add the original ClassNotFoundException as cause.
Multimap returns an empty collection if the key is not found, which will simplify this code by removing the != null test.
Please, add { and } to the if statement. if (dialog.open() == Window.OK) { ICommand cmd = wizard.getCommand(); //command execution ? } Modifiy the inheritance of the action and add the command execution
Command cmd = getPatternCreationCommand(editingDomain.getResourcSet(), selectedViewpoint Eventually, the Wizard could have a getSelectedPattern (and configured of course) and then here you could write: IPatternProvider selectedPattern = wizard.getSelectedPattern(); editingDomain.getCommandStack().execute(selectedPattern.getCreationCommand(resourceSet, selectedViewpoint));
As already said, you cannot execute the command like this. In the previsou patch set I put some ref to existing code which execute the command on the command staticc of the current editing domain (to support undo/redo, ...) You should at least try ecitingDomain.getCommandStack().execute(cmd); And check the undo/redo works.
you need to put: fail("this should throw") in this try block -- if this never throws the test will still pass
The only change I think we should make here is use our Util.UTF_8 constant for consistency.
Looks like a DriverException is being hidden behing a NullPointerException.
The property name does not match the one in SystemEnvironment, may be you could use SystemEnvironment.GO_WEBSOCKET_MAX_MESSAGE_SIZE.propertyName()
you may add the error message as an additional third argument here, in order to give the users a chance to understand why that is
Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.
return ImmutableSet.of();
Please consider using constant from WorkspaceServiceTermination here
any reason to make a new HiveFilterPushdown object here? Can the same object be re-used in logical and physical phases?
If you use a concurrent map you can use: attestationValues.putIfAbsent(value.getHostName(), value);
there are two options here: a. (the better one) if value is not in cache - call addToCach(value) b. return a boolean value - was the value cached or not.
Reset fLabel to null to clear invalid cache?
default method visibility OK?
Why can't you just return value here?
I would prefer to use String.valueOf(value)
Consider to replace with "an allowed command".
How about a message telling the programmer WHAT action type he shouldn't have used?
Shouldn't it be just type here? Or perhaps extractedType. After all, it can be the constraint type _or_ the validator type.
Scm api has rules on the placement of annotations for methods
- Are you sure this is enough? Containers, which are started by scheduler, are not part of the cluster. Therefore they are not stopped. If I recall correctly, the scheduler gets killed by destroy(), but schedulers remain running - CLUSTER is annotated by @ClassRule, therefore stop() will be call through MesosCluster.after()
We can't change the signature of published methods
already passed in
Use constants
Let's inject TaskUpdater via constructor.
this is a query metric I think the metric should be "query/jetty/numOpenConnections"
emit() still shouldn't be concurrent. It should allow emitting only from the owner thread.
Same as above this should likely remain public.
but now you don't really need "new" - these classes are stateless, no risk of two (or more threads changing a state of a single instance, so u can definitely hold a single instance of a mapper. You should be aware to the fact that "new" is an expensive operation.
I think GetValue returns an "int" only, so no need to assign to Integer. Rather you can assign to int type and then pass to parameter creation code.
Apply default formatter
return asyncHttpClientMap.remove(name) != null
Instead of setting both, you can call this(okHttpClient, okHttpClient.dispatcher().executorService())
Use Dsl
You want to use FormField.getFirstValue() here and everywhere below.
why was this call webResource.init deleted?
Can you improve this message?
@fchauveau there is no null handling of source, is this intended ?
Looks like even the brackets around i == j is not useful?
This is bound to reduce severely performance when starts, counts, and blocks are not used. You'll need to make sure there are no performance degradation in that case.
columnIndex < getPrimaryKey() -> columnIndex <= getPrimaryKey()? If the column is the primary key, the cached index should be cleared.
I am picky, but why is this variable called baseColumn_1_?
I don't think getChildren() will ever be null. This can be safely omitted, or made into an assertion.
I see you"ve moved 'reportsWebappDeployed' but what about 'retryCount > MAX_RETRY_COUNTS'?
IMO, urlInitialized check here is redundant. I"m not sure how can you get to this point with urlInitialized=false. (And if it is false- don't you want to return?)
Would a switch be cleaner here?
this should go to login I think... 1. redirect to external 2. apache takes over 3. user press escape 4. we reach here 5. we should present login and not redirect to 1 and loop
Shouldn't this be wrapped in a try... finally block?
Shall we define a log object for this.
Guice best practices: make this constructor visible only at package level.
Do we have to make new instance of MLRCodec every time?
Do we have to make new instance of NMFDataCodec every time?
The streams created are T1 and T3, but the ones added here are T1 and T2. Something is not right?
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
It's better to use i18n
Update the toString to include ledgerIdAssigned?
Do you think its worth printing the time in human readable format? Also the amount of delay.
Does this need to be public?
- Integer.BYTES -> SIZE_OF_INT for consistency with getSerializedBuffersSizeInBytes - Any particular reason to not use SizeOf.sizeOfIntArray(positionCount) ?
I don't think you need this check. Just return size * 1024 ?
Should be : sizeInGiB
built
Strongly against restoring this insanity again. Currently we do not need to rely on individual admin monitor authors having their shit together, this would once again negate this.
Shall we print modelId in the error msg.
I think we need file with version 1.4. inside.
the first three lines are duplicated code - consider restoring them to the setUp() method above.
I find it safer to assert the exact output and not whether the output contains some strings. It's not like the input string is that long. It's also easier to see the difference between the expected and the actual value when the test fails.
Please change it to a normal null check and throw a IllegalArgumentException. This is more meaningful than throwing an NPE here.
Please change it to a normal null check and throw a IllegalArgumentException. This is more meaningful than throwing an NPE here.
Please remove
Can't this NPE as they're Booleans (i.e. objects not primitives)
isSecure() return true if "coaps is used and false if "coap" is used. The naming is not so good with the OSCORE addition (so maybe we need to rename it but later.) So in this case isOSCORE should not impact isSecure()
And ATMOS ?
Update this method to also return true if status is HALF_OPEN?
this line was probably copied from somewhere else but I think the message could be improved, for eg Charge with charge_external_id={} was updated from <old status> to <new status>
Unsure about adding this method to the this class just for the purpose of backfilling, I wonder if it could be moved to some utility of the history event emitter?
This pattern can be created only one time at constructor level
Could you please throw TalendRuntimeException instead of RuntimeException.
directly return "" is better
Why not rather package private visibility? Protected visibility seems to recommend subclassing of DeploymentsOperations. Was it your intention? Why?
IMO better to forward here to avoid code duplication. suggestion return parseLine(version, valueLine, expectedTagOrder, Collections.emptySet());
I think you could read the file contents with many fewer lines of code, especially in Java 8. Something like: java return Files.lines(filename).collect(Collectors.joining(System.lineSeparator()));
should check results here, not just size
This might be considered a programming error -- should we really assume null is empty list instead of a coding error?
I expect out to be empty here, yes?
We could shorten to one line return Optional.of(new Context());
return Optional.of(new Invocation());
suggestion return Optional.of("org.junit.platform");
just return "" instead of new String()
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
String name = StringUtils.EMPTY;
replacing this with helper method would be great
replacing this with helper method would be great
Same as the other write methods, it's safer to create a new ArrayList that modify it.
Again, use IOUtils.
You can do this with IOUtils.write(), too.
message seems misleading
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I get a NPE here, processModel.tradeManager is null.
remove this and do the check in the constructor to fail fast
Might want to return early to avoid large blocks
same as above, we should add throws IOException here and use ThrowingSupplier where this method used
And we can avoid new prefix then, it reads good: Given.eventBus()
I would say java if (storageFactoryForTests == null) { this.storageFactoryForTests = InMemoryStorageFactory.newInstance(); } return storageFactoryForTests;  That's one line shorter.
We should only be pulling down upstream changes here.
I don't know, but isn't the class also of interest?
Having the name of the class in the toString representation is useful, e.g. return "MutableDataPoint(timestamp=" + timestamp + ", is_integer=" + is_integer + ...);
I think Michael meant adding something like: "...using 'migrate' and 'stopmigration' actions..." (Michael said: "I'd mention the actual action used for that")
Update this message, user will not know about 'commit'; that's internal implementation.
please describe it as you did for other url params
don't wrap at .
extract method
extract method
@inverno Why public?
Use method reference
inline permissions and then remove redundant this
-> assertThat(file.length(), greaterThan(0L))
Won't work on windows
There should be an assertion I believe ;) assertTrue(conflicting.contains(...)); And probably alos useful to check that model.di and model.notation are not in conflicting state in the git repo?
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.
Can you update the generator to remove the modifier so that the constructor stays at the package-private level?
No need for super()
calling super not needed
Just some concern for security: should we output user/pass here?
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Please put @Override on the standalone line
Should use the log, maybe a warning.
Don't swallow exceptions here; requestStop() should just throw Exception (we catch them in maxwellContext.shutdown)
Shouldn't we propogate this exception?
isMatrix()? Also what about the row vector case? I've ran in to bugs in the past with subiRowVector being applied to row vector. May want to make this explicit.
we can define a constant MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
is there an implicit assumption that you will always move "forward"? i.e. that locusPosition is always greater than offset? if so, please assert this in the top of the method.
it should be cleanup, no ?
Is there an effective difference between awaiting 0 or just not awaiting?
We can give some more time, like 30 seconds.
MAXIMUM_CAPACITY is no longer used
we were supposed to transfer taskBytes only, but we transferred everything
Is it safe to set limit for buffer here? I'm not sure. Suggest to get a read-only buffer.
Should be size != -1 since -1 is an explicit value. If someone passes a negative value then the behavior is undefined (which is fine).
You can safe some lines by using ArgumentNullException.validate(..) which also gives you a nice standard message.
This will NPE if someone passes a list with null. Do we ignore or throw an exception?
this method should call projectDao.setReferenceGenomeDao as well
This method is for updating other objects' dependencies on the Project DAO, so this doesn't belong here. There should be an updateReferenceGenomeDaoDependencies method which sets the referenceGenomeDao for projectDao and referenceGenomeService
Please use injection- 'Injector.get(VdsDao.class);'
Maybe add regexp check about isNullOrEmpty() too
Should we set a boolean like: boolean successfullyProcessed = updateAgencies(); successfullyProcessed &= updateProposals(); successfullyProcessed &= updateAwards(); return successfullyProcessed;
nit: this is equivalent to commitTsIfCached.map(x -> x >= sweepTs).orElse(false) I think (and you can make the whole thing fluent if you want from there!)
Can't this be further improved to just Arrays.asList(values)?
Style issue: @Override shuld be on line above the method declaration
why is it Collection of Strings (instead of String)?
catch Throwable? When methods shouldn't throw, like where shouldThrow is false here, it's easy to end up with a hang because an exception type changed.
So this throws a new exception? Where does this exception end up going? I think this will convert an UnknownTokenException to a runtime IllegalArgumentException and so this will cause weird failures up the stack?
Please write auth-server instead of AuthServer because this is the default name
If we change the default value of getValueAsString we should change this one too.
Maybe return an empty list here instead of null?
this should be a warn
we might just follow the pattern how ArrayList works. throw ArrayIndexOutOfBoundsException when requesting an entry is out of the range.
Refactor the get id code to GenericDAO to remove the redundant logic.
return queryId
Preconditions.checkArgument() would be better form.
Is "percentage" necessarily the right interface? It's more natural from the implementation perspective to take a float between 0 and 1, and if the target audience is scientists, it may be more natural for them as well (just as, say, p-values are expressed as real number fractions, not percentages). Additionally, a "percentage" parameter leaves it ambiguous whether only integer values are acceptable (though the float type makes that obvious, but the type isn't visible in JSON query plans). Anyway, just being devil's advocate here, not saying you made the wrong choice.
This is not necessary as we have the control, suppress.
it'd be nice if we could use polymorphic deserialization, but i thinkthat is a bigger change
These should refer to constants rather than the string literals.
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
You can use StringUtils from the commons.lang3?
This return statement can live within the try and catch blocks (removing the need for the declaration-without-assignment on line 36)
How about "Type is not supported"?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Why an array? List<String> is just as fine
Why did you change this?
I don't like this method. It looks like magic in the call site.
this could be Lists.newArrayList(deviceId);
@vmaletta add final
@vmaletta TransactionDto already contains a lot so, you could set the lotId to TransactionDTO and avoid passing the lotId param. Also TransactionStatus should not be passed as a param. It should be inferred. All Deposits have Committed status
This shouldn't be changed, instead you need to change getAllCount() to return VisitService.getAllVisits().size()
I believe this should be zero
Please make this protected... No need for this to be private.
Also modify varchar?
remove !
Shouldn't this be AbstractExternalType so that it works with Json too
You should use ThreadContext.putAll() here.
This test would be useless if the map had been initialized in the class.
Where is this being called from? It's part of the public API, no? If anyone has pinpointManager.getAnalyticsClient().setCampaignAttributes(...) in their code base, this would be a breaking change. Like for the other method, you could _add_ this method, and have it pass to an @Deprecated public void setCampaignAttributes(....).
I think try with resources should be used.
Should this return Flux.error instead of throwing?
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
nit: this should be "f"
Shouldn't we check if position is Rect.NONE?
This means clockHand will be hot at initialization time. Intended?
No need to catch the exception here, it was already done in the overload.
No need to catch the exception here, it was already done in the overload.
Same here. Should this be a Mono instead of a PagedFlux as it's returning a single message?
Could null be used instead of a custom exception?
What bugs me is that you have to worry about the file path before calling this, this shouldn't be... You should be able to just call the preload with the same File as the one in addXmlFile.
Need to pass xmlEnvironment as second argument to XmlStringBuilder.
can you wrap this with if (log.isTraceEnable)
The ctx variable is unused anymore.
Calling System.exit needs to be carefully controlled or it will break embedded usage. "Quitting" an embedded CLI may not mean the user wants the embedding app to exit. On the server side we do this by using a SystemExiter interface, and all "exit" calls use that. We then swap in different impls of the interface depending on how the server is being used. The standard impl that is used when we know the server was started from the command line calls System.exit. Others do not.
I'm still confused. Why are we parsing as a long and then checking whether it's > Integer.MAX_VALUE instead of parsing as an integer?
Why add this change here? This wasn't part of the original issue was it?
What about l < Integer.MIN_VALUE?
Just a note. RedDeer has "shortcut" for this - OkButton (as well as CancelButton, FinishButton, NextButton, YesButton etc.). There is no need to edit this... It's just FYI.
We should avoid reusing labels from somewhere else. Create a constant and translation and use it here. See for example limitButton.setText(MarkerMessages.MarkerPreferences_MarkerLimits);
Can the method be called getLabelNames instead?
could this be 8? the size of a char?
Should be given/calculated
We can remove the fontSize/fontName and call the new methods instead (e.g. getFontSize(FontUtils.FontType.general)).
Consider using i18n for this title.
I realize that this was like this before, but can you make this title localizable like all of the others?
Well it actually applies, titles are allowed for connectors, not your fault sorry, but let's try to fix it plz
Constantes? Suggestion: EVENT_ID ou AN_EVENT_ID
It seems like passing the event id to the super class constructor and also making it a field might be a little confusing. Personally, I prefer the approach used in DataSourceAddedEvent where the id of the object is obtained in getNewValue via long id = (Long) super.getNewValue() and the "extra" field is not required. Thoughts?
Cool, didn't know about DeadEvent. When you switch to slf4j, make sure to use playerholders {} instead of string concatenation and follow the [logging format guidelines](<LINK_0>
TBH I am concerning of creating the temporary byte array for every buffer level, it might be not friendly for GC. And it also brings additional copy while reading. But i have not thought of a better option now. Maybe at-least to reuse the same buf for every wrap?
add requireNonNull for bytes
ABFS
Minor: For consistency: LOG.warn("Failed to read offset file in storage partition directory: {}", offsetFileName, storepath, e)
this is REPLACE_EXISTING, the other one is CREATE, if there is an intention to have such seperate methods, i guess renaming method names could be an option as well and only charset is the extra piece. wondering if this could be simplified to save a couple of more lines.
You may use FileUtils.contentEquals instead.
How about narrowing it to ClassNotFoundException and fail with other exceptions?
use -> throw Throwables.propagate(e); and remove the last throw statement
Can you get just the crn from the database?
Fix aliases = aliases = ...
I'd add an always-printed log message here too to make sure it's remembered.
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
Is this test about setting the redirect attribute or replacing _HASHTAG_ with # ?
can use Ds3DocSpecEmptyImpl here
Is this for debugging?
let's stick to if (style.isVariableHeight()) { return true; } for this patch.
If we do that, then this method doesn't return the actual line height any more, but an estimation. That's IMO not something we want to do as this method is expected to return correct value in multiple places. If you want to deal with average height, please introduce a new method and make it used when it's suitable.
This could just be return !(isDiscarding() || isCalleeData()) || isAsync();
What if this path actually exists on the user's workstation?
requireNonNull(path, "path is null)"
Yes, this will work. If I understand correctly, this is run by gwt... right? Does it support File::getCanonicalPath()? if so let's use it... If not... I would have gone with something a little more generic... path.replace("//", "/") without conditional...
Take care! arg.get().toString(). Otherwise you're passing the Optional object.
Can these 2 functions be constants? So we don't need to create new instances every time these methods are called
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
Use waitResponse()
What is this for? Feels like some unintended checked in code?
I modified the test to ensure that if intersects is symmetrical and the test failed with NPE:  @Test public void testIntersectsOnGeometryCollection() { assertIntersects("GEOMETRYCOLLECTION (POINT (1 1))", "POINT (1 1)", true); } private void assertIntersects(String wkt, String otherWkt, boolean intersects) { assertEquals(OGCGeometry.fromText(wkt).intersects(OGCGeometry.fromText(otherWkt)), intersects); assertEquals(OGCGeometry.fromText(otherWkt).intersects(OGCGeometry.fromText(wkt)), intersects); }  Here is the failure:  java.lang.NullPointerException at com.esri.core.geometry.RelationalOperations.relate(RelationalOperations.java:45) at com.esri.core.geometry.OperatorDisjointLocal.execute(OperatorDisjointLocal.java:31) at com.esri.core.geometry.GeometryEngine.disjoint(GeometryEngine.java:376) at com.esri.core.geometry.ogc.OGCGeometry.disjoint(OGCGeometry.java:275) at com.esri.core.geometry.ogc.OGCGeometry.intersects(OGCGeometry.java:280) at com.esri.core.geometry.TestOGC.assertIntersects(TestOGC.java:1007) at com.esri.core.geometry.TestOGC.testIntersectsOnGeometryCollection(TestOGC.java:1001)
this method deserves a description
I think I prefer "Invalid key" as exception message
Just in case, please make this method synchronized
could we solve this better by overriding send() in the TracingActor? I'd like if all this trace and replay code would be in that class.
From discussion above, would probably be good to imply VmSettings.ACTOR_TRACING being true if MESSAGE_TIMESTAMPS is set. That could simplify the check here to just MESSAGE_TIMESTAMPS. (same below)
All other code uses checks like if (VmSettings.ACTOR_TRACING), why do you do here something else?
nit: you can merge both lines above as checkNotNull will return the given argument
logging
This is probably safe because of how the code above behaves but there's a risk of problems later if it changes. Can you make a constant somewhere representing the KList separator and then use that in all three places here?
By default, it's enable, I didn't see you set it false. So, you can remove it.
Instead of a hack like this, maybe we need (or have) an "update()" or "refresh()" method somewhere that could be called to do this kind of thing, since it might be useful elsewhere, and it would be good to have it centralized and standardized.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Hehe, this is exactly the pitfall I pointed out :D If currentTimeMillis + timeout is actuall greater than Long.MAX_VALUE, you will get a overflow and the sum will become negative. Instead you should probably test, if Long.MAX_VALUE - currentTimeMillis() < timeout and if so, throw an error.
Do you think it is worth logging if there was an attempt to set the timeout below 2 minutes?
Please call the new constructor passing the dafault value to failSafeTimeoutDuration. That makes what you want to do clear.
This will break existing installations. Revert the name.
The ID is used to restore old files (from an older release) so this must not be changed!
The ID is used to restore old files (from an older release) so this must not be changed!
why not letting return null and check if the url is null on this method client? Will clean the code a bit
builder object is allready there - in base ....
use one more (...)
Use a list to access at index
Please make sure to verify the properties
Add checks for the warnings properties: checkWarning(...) Then we are sure, that the regexp works correctly.
len is unnecessary variable name
The field state should be read into a local variable outside the loop.
The field state should be read into a local variable outside the loop.
Doesn't a constant for the "system" exist?
Instead of throwing the exception and dumping it, I would rather prevent it by checking the list size before invocation of get().
It's fine to use extension class as the default bean class. We should however defer determining beanManager so that if a bean class is provided explicitly, we use BM for this explicit class. Current eager approach makes that impossible.
The @Override should be on this line.
String.format("%s", s) is s, therefore filePath() will always return fileName, so it is obsolete, and we should consider renaming fileName to filePath.
nit: spaces around + I'd also change / to use OS-specific path separator, i.e. [File.separator](<LINK_0>
you can simplify it with a single line by replacing the method's body with: return validate(hostExists()) && validate(hostStatusValid());
/s/verifyShareableDisksMoving/validateShareableNotMovedToGluserDomain() regardless i think that this check should reside in validateDestStorage() method
This validation prevents any updates to the management network. User should be able to change the network management configuration except its name. Please preserve previous validation.
@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));
If we are unable to delete a temp file is that a SEVERE error? Maybe this should be information or a warning?
I suggest using Paths and then below you can call toFile on the Path object.
There are different ServiceId objects with the same serviceId field? e.g. that contain different aliases?
suggest also being explicit about region (us-east-1).
I prefer to use streams for such loops
Why the + "\n*"?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
No need to use URI, just String will work
I think it's more neater to not write extra lifespan/maxIdle parameters, but instead to write them where you write lifespan/maxIdle already and just add the possibility to send a new option which defines the granularity of lifespan/maxIdle. Your current solution feels akward since you're adding two new fields and the existing ones are not used. IOW, just add one more flag to the flags parameter here and you're done on the client :)
It is not necessary to test REPLICATE region in this test.
I am not as familiar with the serialization process in hotrod, but couldn't you just pass the string either way? The only error case is if it is null, right?
Extract result variable.
nit: missing curly braces around one-line blocks
Just a proposal: java import static org.eclipse.jetty.http.HttpMethod.*; ... ... public static HttpMethod createHttpMethod(String httpMethodString) { Predicate<HttpMethod> isMethodAllowed = m -> m == GET || m == POST || m == PUT || m == DELETE; return Optional.ofNullable(HttpMethod.fromString(httpMethodString)) .filter(isMethodAllowed) .orElseThrow(new IllegalArgumentException("Given HTTP Method '" + httpMethodString + "' is unknown")); }
Can this return a List<JsonPatchOperation> instead?
We might use a NavigableSet instead if a TreeSet is used, I assume.
Could change the return type on method to Collection
@aschworer HEADER is used only here, you can inline it and remove static field
@xupyprmv shouldn't it be sections now?
@sebing please put spaces around :
For Symbol and DataType we've static methods to handle the ordinal handling.  public static void toStream(DataType type, StreamOutput out) throws IOException { out.writeVInt(type.id()); type.writeTo(out); }  Do you think it would make sense to follow that pattern here too?
do we want eventually to have a writeTo(ByteBuffer) ?
The @Override should be on this line.
this class doesn't have tests?
this class doesn't have tests?
is the value of bytes written actually used? since we only return -1 or 2 i'm wondering if a boolean indicating success or failure would be better?
I think you should use MISSING_ATTRIBUTE
GraphvizPrinter (and all other plan printer) should not expect an Expression. Rather than having isExpression here, let's fix the tests if they are failing.
AnnotatedTypes.getIteratedType is not longer called. The Checker Framework still compiles if I delete it. I think it should be removed.
This is not necessary.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
IntelliJ IDEA tolds me to remove this unnecessary boxing.
we can do away with the local variable here @rishabh-997
This list should only contain expectedConceptEntity1's since expectedConceptEntity2's name is different.
There will be other validation errors here so it's not enough to test if there are any, but you need to use the for loop as below to test there's a one with code "Concept.error.notAtLeast..."
I still think you should throw an exception if name is null
Are these fields mandatory or nullable?
format: remove extra space
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
Risk of duplicate transactionId. Resolution of currentTimeMillis is very low.
delete() should be executed from within the future so it doesn't through right away.
please use parameterized logging here :)
you no longer need these static references.
I'm not sure how useful it would be, but we could add a tiny bit of jitter here with a small random number.
I think the granularity should be 1 seconds instead of 5 seconds here.
Looking at the docs for Future, I think this should throw TimeoutException if !done.
log creation on each run() ? that is redundant
this is being called on a different flow now. is this intentional?
check if u can use 'getTaskIdList'
please replace the lines of order 237/238. also, please export this entire block to a function to ease the read here. thanks.
correct the type. it's not service
this might result in a weird flow: user wants to update the ssh-key but the validation in UserProfilesOperationCommandBase#validate fail (for some reason) - then the error would say that the add profile operation fails, no?
This startsWith seems a bit brittle because in the code base we'll occasionally spell it "DataFile".
static
Pull this into a static final variable
should this count be parameterized?
Not sure this is desired behavior if date time cannot be parsed
It would have been more readable to split this commit into 2 : - One about refactoring to sanitze code - One about using new format
Kan bare skrive: return ZonedDateTime.now().isAfter(header.getExpectedResponseDateTime());
Making use of Guava lib this can be simplified to suggestion Preconditions.checkNotNull(module, "ModuleMarkupScraper:getModuleTags() - Module must be valid.");  As the module name will appear in the stack trace if the null check fails, it may be enough to just do suggestion Preconditions.checkNotNull(module);
These methods should all delegate to the equivalent methods in ClassDef.
Would not use the work "type" here
do we want eventually to have a writeTo(ByteBuffer) ?
Looks like index type is not persisted and not taken into account in hashCode/equals, so basically all deserialized index configs are of SORTED type.
No need to implement these?
@AlexDBlack is this normal for transforms? Have we changed anything in the data vec transforms you can think of?
Use interface instead of concrete class. Either List<String> or more general Collection<String> as return type
declare throws please
this is nullable
Taking into account that you don't know final size of a list and you will dynamically add items you can benefit of using LinkedList. Though that would not have a real performance impact I would still recommend to consider that case here and further for production code.
Is it possible that machineNodes could be an empty collection?
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
ResourceSet<E> is correct and stricter than ResourceSet<?>
instead of just putting e.getMessage() as part of the new exception message, I think you should pass the entire e as the second parameter to the constructor of IllegalArgumentException.
I think you should also send the e into the BadRequestException. can you do that? That way, the root stacktrace isn't lost
Do we need to validate the config once in configurePipeline() and again here?
This is a clear programming error, right? If so, suggest throwing NPE instead.
Please add final for exception, and rename e to ex
Please remove "Due to" string from message: log.warn("Unable to get network interface '{}' status, pronouncing it unhealthy: {}", networkInterface.getDisplayName(), e.getMessage());
This is not correct for the same reason as i said above.
Declare Context.getService(IdentifierSourceService.class) at the top of the class.
same question
nit: simpler way: use noneMatch instead of ! + anyMatch. btw, it's better we can also update the matches method of PushFilterIntoTableSourceScanRule
what if a table contain a field named filter ? use str.startWith("filter=[")
!Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith("source: [partitions=")) can be simplified as Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith("source: [partitions="))
is everything in this block (inside this if) not the same as the superclass' behavior? If so please replace with super. getSuiteFilter(klass)
Currently HsacFitNesseRunner makes the system property fitnesseSuiteToRun 'win' from the string literal in the Suite annotation (even if the Java test class code does not reference the system property). This allows the developer to commit any value in the test class without breaking the build server's run (which sets the system property). The approach for (Exclude)SuiteFilter in this version is that the 'value' (literal value in Java code) wins from the system property. Can we change the behavior for (Exclude)SuiteFilter so that the system properties (with names you use as examples) always win from the annotation value in code (even let the filters become active is the annotation was not present on the Java class)? I believe all it would take is an extra (first) if-branch, turning the current first into an else if, checking whether the system property has a value and using that value if so. Of course this does also mean we have to override the current behavior for the SuiteFilter annotation. I also agree that the current code would be a good improvement for the FitNesse project's FitNesseRunner. Are you planning to send them a pull request with it?
again, not sure if there is any advantage in separating this into a method
It is shadow copy technically, but all fields are immutable (so there won't be any issue to directly use these fields).
You should leave gender here.
To me, this line seems redundant. Why not pass withStudentProfileAttributes(this.studentProfile.getCopy()) in the building process
I am sure you can replace this with Lambda.
Is it required for the upgrade?
static is missing
Missing call to super implementation of onResumeFragments()
onLowMemory is public, not protected
Hi @rezita, I think this should be isSHREnabled
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
what about check if sign in | register visible? :)
How about a String consisting of entirely spaces? Like this: java String empty = " ";
Please throw exception if ! nameLookupPossibleInAdvance() and getValueCardinality() == CARDINALITY_UNKNOWN, please throw UnsupportedOperationException. If ! nameLookupPossibleInAdvance(), but getValueCardinality() returns something non-negative, the code in the hot loop could be optimized, idForNull could be assigned as soon as selector.lookupName(index) returns null for the first time.
Agreed. Maybe an Optional<VarRefNode>?
Can the value returned by Java this.browser.syncRun(String.format("return %s.length > 0;", selector.getStatement()))  be null? If this is the case, you need a nullcheck before returning the value as the implicit unboxing needed to convert the returned Boolean into a boolean (which is the actual return type of the method) will throw a NPE if the value is null.
There is a weird inconsistency. Sometimes you start the String with a capital letter, sometimes not.
Should be moved with other not treated cases
Did you intend to make this public?
I missed this the first time, but no raw English strings in the code. Do + StatCollector.translateToLocal("pe.arcana.inactive"); and then put pe.arcana.inactive=Inactive! in the en_US.lang. So it lets the string be translated to other languages
I assume we can safely cast these to ProviderMethodBinding ?
Maybe we should return true exactly here (not sure if we can have more than one binding with that name) and false in the end of method to indicate that there is nothing to stop? Also how about to consider to implement this logic via Java Stream ?
style-nit; no braces for simple single-statement constrcuts
I'd prefer to add a parameter validation check that would make sure that start < end that would give an illegal argument exception with a meaningful message instead of StringIndexOutOfBoundsException. Another validation check suggestion: start char should be different from end char.
I think we should have the same condition as we have in getMergedCellsCount: java cell.getMergedCellCount() == 0 && currentIndex >= 0
Rebase error - should be used Helper.getCurrentUser.
We can probably partition on the QUERY_PARAMETER_LIMIT (may not exist in 0.9.x, but it's set to 32k by default) rather than the IN_OPERATOR_BLOCK_SIZE. If we opt to keep this as-is, we should probably drop use of CPRestrictions, as it won't add anything of value.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
I think this should be: java setCursor(Cursor.getPredefinedCursor(DEFAULT_CURSOR));
Would we want to preserve the previous selection (before archive radio was selected)?
We don't use old style RPC calls on new change screen. It should be migrated to REST API.
last argument needs to be ImmutableSpongeFlyingData.class.
last argument needs to be the implementation class, in this case, SpongeSneakingData.class.
Default value should be false.
I would suggest answer.toLowerCase() to make secret answer validation case insensitive.
This is not necessary as it is null by default.
if credentials is null on login we should throw IllegalArgumentException because null credentials and demo credentials is not the same case
We should include the topology name in the message as well: Topology foo already exists.
here again brokerName may not be equal to brokerName.toLowerCase() in which case the observers get notified but the connection is still in the map. You may call brokerConnections.remove(brokerName.toLowerCase(), connection) here and again check the return value. If the remove fails you may log.debug to give a hint what happened.
Do we need all modules from CliBroker? Seems to me that this class is mainly for running and canceling queries by directly calling runQuery and cancelQuery. In that case, I think all Jetty-related stuff (e.g. QueryJettyServerInitializer, QueryResource) can be removed.
Take a look at <LINK_0>
fix namespace
I'd add try catch here to continue removing other ones when a error occurs during removing one workspace
This and similar blocks could use the NULL_LITERAL constant
Here too - use Double.valueOf(0.0)
return StatUtils. sum(toDoubleArray(colName)) directly?
How about adding an UncloseableAggregatedMemoryContext that throws if someone calls close
We have too many delegations now: uncloseable context -> internal context -> local user memory context. Maybe we should add constructor arguments to InternalLocalMemoryContext and InternalAggregatedMemoryContext that tells whether they should support close or not (and remove the uncloseable contexts).
else if maxBytesInMemory < 0?
new ArrayList<>(causes);
This exposes the unicode workaround to the public.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
Why change here? You mentioned partial models in test as a reason, but this is not a test case. This file could have a different encoding set by the user. Recommend:  settings.getModelEncoding() != null ? settings.getModelEncoding() : StandardCarsets_UTF_8.name();
Exception? maybe a IOException at least
Should be settings.yml <naming
once again, equals/hashcode - does it make sense? please revisit in all value types you created
checkstyle
This doesn't check all fields. Use the super.equals() to check the parent class's fields and, if that returns true, then check this class's additions ((volumeSize).
ImmutableList.of
Collections.singletonList
Collections.singletonList
Should this be called id instead of store_id? Its a param and it shouldn't matter what it's called I suppose, but, id is the key we use in the response.
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
m... prefix should only be used for member variables
You can inline this variable.
The empty string in the constructor is redundant.
I don't understand why we need to perform sorting here. I expect that StudyEntryServiceImpl#getStudyEntries should return the entries sorted by entry number and in fact I see this code that's supposed to do that: // Return by ascending order of entry number. We need to perform cast first on uniquename since it's stored as string return this.getStudyEntries(studyId, null, new PageRequest(0, Integer.MAX_VALUE, new Sort(Sort.Direction.ASC, String.valueOf(TermId.ENTRY_NO.getId())))); Is it not doing that?
I see another bug - probably unlikely and maybe not even possible, but super.stop() is not called if serverChannel == null.
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
should the message include "command _with options_:" + this.options ?
is it better to use name instead of null?
can be simplified with Collections.singletonList(1000)
is it better to use name instead of null?
getHeaderData and getItem data need to check for anything. They just need to return whatever value is set in the constructor. All methods can be final as well.
Others are public, should this one be public or the others private?
You could combine the two checks, if (requestHeader != null && requestHeader.size() > 0)
Is it safe to set limit for buffer here? I'm not sure. Suggest to get a read-only buffer.
Does EMPTY_SKETCH.toByteArray() result in an empty array? Currently there is a discrepancy between fromByteBuffer() and toBytes() that looks suspicious when just reading the code.
Think we should also look at remaining() - it can be efficient to use slice, in which case the buffer doesn't go to the end of the array.
I think we should add some text here, to explain why we're rejecting remove() call. maybe something like "this iterable is immutable, can't remove anything"
If we log an error that doesn't have any vararg arguments this will throw an exception from what I understand.
no need for messages on these exceptions (detail will be available from the stack trace, and these throw statements will have to be removed as part of this review chain anyways)
if this is hit often, the String concatenation may slow things as opposed to using a StringBuilder. Also, would it be better to not append/concatenate the empty string "" if the treeId is null? Maybe do it like this: java StringBuilder sb = new StringBuilder(indexId.toString()).append("."); if (treeId != null) { sb.append(treeId.toString()); } return sb.toString().getBytes(Charsets.UTF_8);
return queryId
this is effectively a noop
Nit: use ImmutableMap.Builder, it's easier to read and modify, as there is no special case for the last item. I only use of() if there is one item. Same goes for the rest of this class (except the usages with exactly one item).
why are we changing the visibility of these methods?
Nit: declare as Map
new ArrayList<>(causes);
This exposes the unicode workaround to the public.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
could you please create another constructor accepting nameResolverProvider?
Assert.notNull since shouldFilter will throw otherwise
return Collections.emptyMap()
Please add ? and % as well
unnecessary array new: {{true}, {false}} should work here
Also, a test with an aligned with original OA to test the default overwrite will be nice here. Also with unmapped reads with OA tag because the current code won't overwrite them (and I guess it should).
Could you please use TextUtils#isBlank here instead of "".equals(s)?
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Something wrong is here: ![wrong_object_to_remove](<LINK_0> this.inUseConsumerChannels.remove(consumer.getChannel()); ?
I think we need to have a timeout here. Can't you apply the same as in RestFuncTUtils?
this is an internal API - @Nullable + plain return type would be sufficient
When replacing a single char it is better to use public String replace(char oldChar, char newChar)
Please externalize this to Messages
Will move suspended event and log into try {} block
I don't think we use final for functions in our code base
assertion for channel kind should be added.
Wouldn't it be better to do this in the constructor and have a final variable with it?
this will throw timeout if infobox is not visible. use wait.forElementPresent() instead, but you will have to create By variable from that selector
Right now it will never return false - in case votedMessage is not visible, this method will throw exception after reaching timeout. So please: - make sure to catch this exception and cast it appropriately to bool - decide whether you want to call it and expect false - in this case we probably don't want to wait 30 seconds (or whatever default timeout is)
inline raw() ?
Copy could potentially get very expensive. We normally just trust the modders not to screw things up.
Why?
> And here it is confusing, because we use Deques internally for the buffers (I don't remember why exactly, but I'm pretty sure there was a reason). My guess is that: You use deque because you want to insert first and remove last from the buffers (opposite of the proper sequence), and you do that because the iterator iterates on the inputBuffer (tail) before the outputBuffer (head), and if these were in the proper sequence, it would look weird, for example [I,J,K,L],[[E,F,G,H]],[A,B,C,D]. You could have used the buffers in the proper sequence (insert at tail and remove at head). Then the iterator would need to be a concatenation of the descending iterators. But you'd need a deep descending iterator for the middle queueIterator that uses Iterables, that would be a descending iterator of buffers in the inner queue that concatenates the descending iterator of each buffer... Already that middle iterator is 'incorrectly' in the proper sequence of the inner queue so it's not a true descending iterator: [P,O,N,M],[[H,G,F,E],[L,K,J,I]],[D,C,B,A]...
I think we should set isBound = false here. onServiceDisconnected is not called when the client is unbound normally. According to the docs, onServiceDisconnected is only called when the process hosting the service is killed/crashed.
hm, how about "...".equals(intent.getAction()) or TextUtils.equals(intent.getAction(), "...")? [fyi, commit amend + force push are fine]
Braces required by coding convention.
Could you please clarify the reason of this change?
Can you make the query (adding some filter) slightly more complicated to show the effect of more rules. For instance "select \"store_name\" from \"foodmart\".\"store\"\n" + "where \"store_name\" = 'Store 1'\n" + "union all\n" + "select ename from SCOTT.emp where sal > 0"
This looks like a plan degradation, doesn't it?
You can remove your factory class and use: return singletonMap("surrogate_merger", (isettings, env, name, settings) -> new TokenFilterFactory() { @Override public String name() { return name; } @Override public TokenStream create(TokenStream tokenStream) { return new SurrogateMergerFilter(tokenStream); } });
Why do we need a new CustomerToken here instead of passing the ref back directly? It should be read only
include retry template and do  return retryTemplate.execute(x -> remoteTokenServices.readAccessToken(accessToken));
You can create a constant to include the "http://" string and named as **HTTP_SCHEME** for instance.
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Very minor nitpick: Using charAt might makes this a bit more readable: if (url.charAt(url.length() - 1) == '/')
Are these errors caught somewhere else? Is there a reason that exceptions were just printed instead of being thrown previously?
Exception should be logged.
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
style nit: we don't use braces around single line blocks
Raw type JList
remove assertion and change ISelection to IStructuredSelection
Isn't there a better way to identify if an access right is inherited than checking is a UI widget is an instance of Hyperlink?
Could you load requested into a local variable here as well?
Probably want to add the filter here: if (objectFilter.include(this, r.getTree()) pendingObjects.add(r.getTree());
We want to always return '201' status Status.CREATED, but Response.ok() will set the status to Status.OK. You probably need to set the status by hand calling the status(Status.CREATED).location(.....) Would suggest to also enhance your tests below to also verify the status returned.
revert this unrelated formatting change
If it's of the form uri#lineNumber, wouldn't a simple uri.lastIndexOf('#') do the same trick?
assertThat(gosecSsoUtils.userName).equals("anyUser");
Please delete the right project.
you can use standard java NotSupportedException
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
super.init() method never throw an exception.
Overdid - setUp("redis")
I'm a bit perplexed: "dynamicStrict" does not match any field name... I wonder why this works. Anyway... Maybe there should be two different bridges here? It feels a bit strange that the name parameter in configureFieldMetadata is ignored. Same as before: I agree it can work as is, but it's more in case someone copy/pastes this code.
I'm worried that the current pretty print version of points is not only very verbose and will take more space in the index, but also that prettyPrinting is something that will change easily, and result in the need for index recreation. Perhaps we should have another method on Point for index printing that we do not need to change. The current PointValue.toString is actually a better choice, but could be copied to a different method for indexing only.
It would be nice if we can also check the error message of the Throwable.
save an iterator by using index loop?
why not list.stream().forEach?
we probably want to return the set itself in this case even if it's not the same behavior on List.
Exception Message like logs shouldn't be internationalize just use // NLS....
If this test evaluates to false, this is going to make the cache manager silently un-monitorable. There should at least be a warning about that.
No need to append an empty string :)
You don't really check much with this test. I think you can also mock cursorsCommitService. getSubscriptionCursors() and check that in response body you get what you expected.
If you use anyCollectionOf(PID.class) then you could skip the warning suppression
Should we fix this for all the other tests as well? * physicallyDeleteSurveyNotEmptySharedModules() * deleteSurveyPermanentlyNotConstrainedByScheduleWithMultiplePublishedSurveys() * deleteSurveyPermanentlyNotConstrainedByCompoundScheduleWithMultiplePublishedSurveys()
Perhaps change %s to '%s' or so to make nasty leading or trailing spaces more obvious?
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
shouldn't it interceptSrc and remainingPath follow same pattern to intercept as they both split from src path only? Whats the issue if I use same interceptSource method? Do we have some concerns? Could you explain me if I miss something here?
new fields should be added here, right?
This should be in.readBundle(getClass().getClassLoader()) to make the build pass. Since we're just passing in strings right now we don't actually need this, but it'll ensure we're future proof (and make lint happy).
Does this expect product ArrayList not to be null? You can use this instead <LINK_0>
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
these setters should not be public
Missing StringUtils.isNotNullOrEmpty() check
Replace URL_TICKER with URL
Please use getCurrencyBaseLowerCase() and getCurrencyCounterLowerCase() on checkerInfo
I would just use pairId here and remove second arguments from URL.
I would suggest to add the overloaded method with accepts Bus bus, there are many places where it could be provided from context. What do you think?
Can we use BinaryUtils#resolveClass instead of making this method public?
Is there a method for modders to share recipe types? An enum system with our extender or some form of get(ResourceLocation) would be good.
use rewrite than getVisitor
ImmutableList.of()
If possible, generally please make all values final. It is one of the main rules to achieve functional programs.
Please fix this codacy issue
Does it make sense to change this to getInstance(Context c) and merge this with createGlobalInstance?
What I was thinking of is that we had ServiceInstance<ZookeeperInstance> and now we have ServiceInstance<Object> I'm curious why did we go from ZookeeperInstance to Object?
Doesn't contain questionGuid.
Liran, Yevgeny, now that we're using hibernate and it creates a proxy for the entities, is there a need to enforce in the equals impl of methods "is instance of" or can we settle for getClass() comparison ?
I think you can swap the order of the conjuncts because name.equals(other.name) is less expensive.
Would be nice to create an integer constant and assign 400 to it, and than use it here. E.g. public static int WINDOW_HEIGHT = 400. It'd be more explicit for another person (no magic numbers).
log () here and after
click on element
Could you explain why you don't use just true ?
This assertion may fail if there is more than one public key on the repo you are testing on. I don't think that's a safe assumption. Better to use Matchers.hasItem() here I think.
do we need to specify content type here?
Read, not readed
No magic numbers please. Can we move it into a constant and give it a proper name/description?
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
does this method need to be public?
can we use BeforeClass annotation?
Don't use exceptions for control flow!
why not use builder.append(SEPARATOR).append(value) . In this way , there is no need to remove last ":" in build method.
Imho , some style inconsistency. On one hand you have a final char for delimeter, on the other hand you append hte literal '=' (no final char for it) why?
Although this is not a part of your pull request, this toString() method looks overly complicated.
I think this could be package-private: suggestion void enableOkButton() {
Since IabHelper has been modified to always have debug logging, this method really isn't necessary. But I think it would be better to keep IabHelper the way it was and only change the Log. calls to AppLog. calls so there are fewer code changes (since this class is provided by Google and will likely change).
allright that's reasonable. Can it be Preconditions.notNull(enableAcl, "enableAcl") then?
is it sufficient to have this c'tor package private?
This is not necessary as we have the control, suppress.
I don't think we use final for functions in our code base
defensive copy?
Since this constructor exists only for the JSON encoding, which will recursively process and populate the fields, there's no need to call this(). Just accept the default initialization of false/null for the fields and let the JSON decoder finish building the object.
Collections.unmodifableList()?
variable named abstractFile does not exist, which prevents pr from building
could you please use curly brackets after if? i think it is really common practice in java + it is java code convention
should be synchronized
mark this method private as this is only used in this class.
@Delawen Sorry I missed that, actually what you have now is perfectly fine from view. Just add @UriPath annotations on host, port and tableName so Camel can generate the correct metadata for the docs
Minor - we can do fb: and fbkey: as static final strings instead of hard-coding them here?
Better use Double.isNaN(double) here. Reads better, IMHO.
use ... between 0 and 100., it's more user friendly
Please throw NullPointerException instead (also, use braces for the if statement)
It should be new TajoRuntimeException(new InvalidCastException(...).
It should be new TajoRuntimeException(new InvalidCastException(...).
It should be new TajoRuntimeException(new UnsupportedDataType(...).
fieldName
Log this
This is unintuitive - why not return the number of characters you need and allow the calling function to decide what to do with it?
I think this should probably checkisSnappyAvailable and throw if it's false. It looks like maybe it used to check it implicitly by getting a NullPointerException if the constructor wasn't initialized. As this is now you could specify snappy.disable on the command line and then end up using snappy unintentionally if you didn't guard against it in your own code.
Can we make a SoftEndOfStreamException as an UncheckedIOException to avoid this wrapping? i don't mind for other branches, but at least for the master. Thanks
Why is this needed?
Use Assert.assertEquals
Use Assert.assertEquals instead.
Could we change this variable is may stand for input stream but it looks like _is_ (this _is_ a sentence)
return new StringBuilder().append()....toString();
Why removing failure? It is the failure reason.
What about using String.format instead:  String.format("Injectable type: Invoker, accessor: %s, method name: %s, invokes method: %s", methodLocation.name, methodName, mName);  Seems more readable to me
antipattern: using getBytes without character encoding
I liked this logic as it was -- in the ArtifactInputStream (or it's parent), as it was all contained in one class and you didn't need to know that there was a utility class for this. What's the benefit of this?
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
These will all break if A or B is null. Recommend using the autogenerated intellij equals + hashcode unless you have a good reason not to
I believe that this is the same as Objects.hash(readName, pairStatus);
If you find your analysis panel starts going a bit loopy (IIRC you said it does), you might want to check your hashCode implementations - you should try to use result = ~~result type construct.. I can dig out the original email if you like?
This is another behavioral change that I don't want to see in an unrelated PR.
I recommend using Collections.emptyMap() instead
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
add this selector to UI mapping at the beginning
Those two methods are similar. Consider using one.
Let's use waitForElementVisibility instead as waitForElementPresence only checks if element is present in DOM, regardless of whether it is visible or not.
this method could be static i guess? more relevant: is this method necessary? i only see one usage
use getContext() instead of this.getContext() ?
Could you follow the code style elsewhere and use braces please?
path.endsWith('/')
move it to be aside of deleteFolder
determining if path points to folder or file just to have different exception is not worth an effort. Drop that. And make exception message Object does not exist. The other question is do we actually want to fail the deleteObject method if we remove inexistent object. This can make use of such method in cleanup procedures problematic.
Just do sw.toString().
should be static
technically if you're PrintWriter throws the exception your StringWriter will never be closed :-)
I guess you mean to pass kryo, not to create another Kryo.
Can make this into a singleton as we have with UNSET.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
why are we casting to "int" ? it the value is a "long" we must return a "long" or we have to handle the overflow some way
Have you intentionally omitted index check?
s/getValue/getId
Should probably have a specific error code defined in ActiveMQClientLogger and use that.
why not simply add tcall the error.. we don't need a special logger here.
I think this was left by mistake.
Please kill this empty line.
Please make sure the word class is not added to the message before the class name.
How about having checkNotDefault(M extends Message), which does non-null and non-default checks? We are going to have it over and over again.
getServicePolicy shouldn't ever return null. Based on how the Python SDK functions we return a policy object every time. In the case that it is in fact empty ({"factors": [], "minimum_requirements": []}), we return a policy with all the minimum_factors set to false or 0.
why not use @Inject ?
Shouldn't be protected as this method is used only in tests + shouldn't be something editable no ?
Swapping these around breaks all other GUI's.
This is not correct, just change it to getRight
suggestion final int layerId = params.getRequiredParamInt(PARAM_LAYER_ID)
How to do ensure that by requesting .getConceptNameTagByName(null) for should return null if No concept nameTag is found?
Two different conceptNameTags can have the same description right? We can just assert that both of the objects are equal.
You no longer need to set this locale here since the save handler does this for you
Could return result of getCurrentJson to avoid repeating this line (same for descendRepeatToJson)
Great code org / helper method ordering on this method :+1:
this and step should be private
Again, probably out of scope for this PR, but I don't think these andReturn() statements are needed.
I'd then check the exception class plus parameters, not the message that isn't even sent to the user.
Test name says test should fail, but nothing in the test expects an exception. I suspect if you pull the latest changes in master into your branch, this test will start throwing an exception as expected.
I would move this to a constant so we can access it from tests as well.
One small change after running. Add "0x" to the beginning to drive home that people are looking at hex values.
Add reasonable toString() method, returning null doesn't seem as proper way.
double wait
Global listener catch each click. You don't need to log it.
please add PageObjectLogging.log method here
I want to method accessor to be package private :eyes:
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
Use logging instead of this.
I think you can swap the order of the conjuncts because name.equals(other.name) is less expensive.
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
Doesn't contain questionGuid.
This 16 is unrelated to cube size. This is vanilla chunk height. Populator pregenerate those cubes to let default world generators do a job.
What if the chunk getting fails? This would throw a NP
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
The order of the arguments is reversed - it should be assertEquals("Vds id is not empty as expected", "", result);
This test checks "get" by using "get" so I would say that it's redundant to check it this way, perhaps it's possible to test it using another method to get an expected entity (say getAll and pick one from there).
no need to chain anymore: queryNetworkAttachments(); queryTLVInformations();
I think we should reuse this File object, returning it, for example, and then pass it to the copy medhod, instead of the string.
Is there any way that this may lead to a serialization format that is not backwards compatible?
if the argument expected doesnt exist the code will take another argument as the value for the Input argument. Should we check and complain or default ?
What's the reasoning for returning a LocalVariable[] instead of a Map<String, Object> directly here?
Unnecessary cast.
This should be Repository.class. The method is supposed to return the list of adapterTypes, i.e., the types to which this adapter can adapt objects to.
Same question about unit conversion as earlier.
But for this case, it will lose numbers under a decimal point.
This lets you chain the tickers, though I don't think we used this functionality
I don't think you want this default. This default setting basically says "If debug mode is enabled (IE: You're on a dev machine), the default for the superuser flag is 'on'". You probably want it to just default to "no"
I don't think we want Debug to make this true by default, it'll make the dev apps and the normal apps look very different by default
@phillipm this should be properties.getString(ANIMATE_FORM_SUBMIT_BUTTON, CommCarePreferences.NO) in order to make it default to off
Why do we have different checks in these two tag methods ?
Since we will always need tagPage.getTag().getUriName() to get the uri, we could encapsulate this inside tagPage. Something like tagPage.getTagUriName() or a better name :P
For debug purpose, it is better when there is only one return statement in such a function. Something like...  java boolean result = false; if( ... ) { result = true; } return result;  In debug mode, setting a break point at the function end goes quicker than following all the possible paths.
The parameter can bee removed
This no longer needs to be public, that was only for MergeOp.
Need to update tablesUpdated for DropConstraint as well.
again, CoreUtilities.noDebugContext
again, CoreUtilities.noDebugContext
tagName is redundant. Use local variablesl later on if necessary
I think this should be ss.findAllRepositories(streamName)
That is true, returning all the fields when you only need some is inefficient. I see you already wrapped it with a call to convert as in findAll :smiley:
Not exactly. findmeans that the initialization should happen before.
style nit: we don't use braces around single line blocks
Interesting wrapping style :)
throw on negative
store these as member during init? although not that important, it is good as is.
suggestion Assert.assertThat(e.getMessage(), containsString("403 Forbidden"));  - to get better error message if that fails
please create an abstract method snapshot(snapshotName, tableName) that either performs a synchronous or async call.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
here we need to go through Optional.ofNullable(Plaform.getProduct())
Move the message to NLS bundle. And not sure about the text... Can you discuss it with @maxandersen?
If our setters in commands are going to fail-fast about single-execution, we should fail-fast here too about a null pointer being passed in for Repository. NPE right away in the constructor rather than deferred: Git git = new Git(null); git.commit().setMessage("Test").call() We should NPE on the first line of that, not the second.
Unnecessary parens around the return value.
I'm not convinced that showing the context (Workbench, etc.) is particularly meaningful to most end-users and adds a lot of visual "stuff" that in most cases you'll train your brain to ignore? Plus when using a screen reader it causes that context to be read at the start of every command as you scroll through the list, significantly slowing down the time and cognitive load. At the very least, maybe an option to turn it off both visually and audibly? Or maybe it has more value than I realize.
This method should be private or default as otherwise it is API addition.
Should throw at construction time instead.
Can you clarify why we have to remove this ?
I am still confused by this. The one place where this configuration is used is to construct IBuildPlans in the server beaviour. this map will result in build plans whose IDs are the Url or name (which is fine) and whose names are the URL. This is inconsistent with how the build plans are otherwise constructed from the model jobs. When constructing the build plans from the model jobs the ID will be the Url or name, and the name will be either the display name or the name.
Can you explain a bit more why this piece of code? It looks like we're doing twice the .setValue() call. I guess that it has to do with the issue #1695 that you say it's solved here? If that were the case, please remove this piece of code from this PR and create a separate PR for #1695, but anyway...please answer my question. Thanks!
I don't see much point in making db lazily created. It's not an expensive operation.
transactions should be enabled
concat empty str ?
Honestly, I haven't seen TIMESTAMP(0) in BigQuery
where is this used?
given/ execute/ assert
So looks like this will return a new desc factory object each time it's invoked. Is that needed? Because, that means, in the hRaven runs, for each job history file, a new job desc factory object would get created each time. I think let's not do that. Is this an option: can we keep the private static final lines that are being initialized above and only return the appropriate object in this switch statement?
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
You can use sketches.computeIfAbsent().
This does not verify the order. (The iteration order over expectedMap is undefined).
Ok so it looks like in COUNTRY_TO_REGION_CODES we have: java map.put(800, singletonList("001")); map.put(808, singletonList("001")); // ... map.put(870, singletonList("001")); map.put(878, singletonList("001")); // ... map.put(881, singletonList("001")); map.put(882, singletonList("001")); map.put(883, singletonList("001")); // ... map.put(888, singletonList("001")); // ... map.put(979, singletonList("001"));  So when we're looping through that map we would overwrite the 001 key with, 800 then 808 then 870 etc. So while the end result is OK because we do map.remove("001") I am now worried about our map inversion technique. Are there any other codes that appear multiple times that we would be overwriting? If so isn't that almost definitely a problem?
Thanks for changing this to a switch! When I originally added the Lite and Premium versions of the app, I had to implement this as an if statement because the R.id constants were not declared as final.
I dont see any reason for adding this to string.xml. It is not really a string resource, it is more of an id. We wouldn't want this to change if we decide to translate the App strings later. A better way would be to move it to the Constants class.
Same here, better in the constant class.
return SUPPORTED_INPUT_FORMATS.contains(inputFormat);
I think we can simplify this to java return getCompressionCodec((TextInputFormat) inputFormat, path) .map(fileCodec -> stream(S3SelectSupportedCompressionCodecs.values()) .anyMatch(codec -> codec.getCodecClass().isInstance(fileCodec))) .orElse(true);
This could just return (InputFormat) PigContext.resolveClassName(inputFormatName).newInstance(); resolveClassName throws only IOException.
you do not need to cast: just add a type like that:  Setting.NODE_CONFIG_DIR.<RawPath>getDefaultValue().toPath()
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
You're welcome! As you noticed the the wrong error message was a consequence of the wrong comparison. Since isNameValid(name) was returning true when it should be false, the second if statement on enterPressed() was executed causing this bug.
The exception also needs to be modified a bit.
Based on <LINK_0>, we should name groupName as "flowTrigger", and jobName to be "project_name+flow_name".
why job1?
Use same order as the field declarations.
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Are you aware that this very expensive use of String.format is executed every time, not only when debug is enabled?
Calling getPostListAdapter() will create the adapter if it doesn't already exist, so instead we should use mPostsListAdapter != null here.
It's not necessary to box media.getLocalPostId() in a new Integer instance here.
Just a note here, I realized that I don't see many usages of this approach where we check to see if network connectivity exists before utilizing the dispatcher. Do you know why this is so?
No need to catch the exception here, it was already done in the overload.
No need to catch the exception here, it was already done in the overload.
Publishers should return errors in error channel. This should instead be:  public Mono<Void> runAsync() { return Mono.error(new IllegalArgumentException(); }
unnecessary change
unnecessary change
unnecessary change
Can remove the throws IOException as it won't affect callers at all. They were already expecting the IOException -- if we don't throw that anymore, that's fine.
redundant thisqualfier.
redundant this qualifier
Same question as above.
I don't think it's sufficient to use just the width for 'scale' here. For instance, you will get isMatch == true for 1080 x 1088 and 1:1 aspect ratio, but you will get isMatch == false for 1088 x 1080.
Could avoid this local variable if you store fHeight inside the if clause, if you feel like it (also, this. unnecessary).
If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.
Detail: FROM capitalized.
There must be a more succinct way of doing this using streams.
instanceof check is enough, no need for null checks in this case
if from one run to the next, you cannot find the TIDAnalysisModule, you still won't be able to reproduce the analysis results. you should probably used TmfAnalysisManager.getAnalysisModules instead of trace.get... and throw and IllegalStateException if you cannot find it.
Sorry, I reverted this accidentally. I'll fix it
After the change to using JsonElement rather than String, to fix the bug with complex keys, you are implicitly relying on JsonElement's toString method returning a valid JSON string here for us as part of the URL. This assumption isn't part of the toString method's contract. Use gson.toJson to guarantee you are sending in valid JSON in the URL. The same goes for startKey and endKey, below.
Hmmm are we sure we want to depend on the Channel monitor... for property access it may be preferential to use properties as the monitor object
can we optimize this part? Now we deserialize key for every call.
"set up" as a verb is two words, so should really this should be setUpFilters
style nit: we don't use curly braces around single line blocks
Can we have spaces in the eventType field?
Duplicate code we have method in utils that gets name from SecurityContextHolder.
What you think to change to assertThat(validation.getErrors(), empty())? It's more readeable, sounds like "assert that validation.getErrors is empty". empty() is a static import from org.hamcrest.Matchers. If the assert fails, hamcrest matchers have a more pretty message than assertTrue from JUnit, that don't show any message.
What do you think about keeping "<LINK_0>" in class variable also?
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
I generally don't like publicly exposing new exception types especially as it encourages people to lock to instrumentation code types. Secondarily, the only effect desired is to add an error tag and allocating exceptions isn't cheap. If we think cancel is an error, which is debatable, please delete the exception and just add a tag("error", "canceled"); if there is an existing practice in webflux calling canceled things as exceptions, we could revisit this as well.
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
Check if an entry with the given key (name) already exists and throw in that case an exception.
This doesn't seem right... wouldn't this result in the file's path being the file path of the parent directory (and hence overwriting that directory)?
I think you're missing getDefaultConfigurationFile() here.
It would be cleaner to directly format the instant. Java 8 has a new formatter for temporals.
is getLastSyncTime() guaranteed to return non-null?
probably the date format string could be refactored since it's used in multiple places. I'm also wondering how expensive the creation of a new SDF is.
antipattern: using getBytes without character encoding
Objects.requireNonNull(arg)
this is a bad change: removig initialization, in what way should this be better?
Maybe we're going at this the wrong way, and trying too hard. If you call ProjectJoinTransposeRule on a MergeJoin (which requires sorted input), and the Project does not, after being pushed down, give sorted output, then maybe the rule should just abort. Just a thought.
Always use create instead of new directly.
It would be better to whitelist this for outer types (FULL, LEFT, RIGHT). @scarlin-cloudera Either we can create separate jira or we can make the change with this patch..upto you.
Use Paths.get or non os specific separator
Use Paths.get or non os specific separator
SonarLint is going complain about String concat
You should pass here message not group converted to string.
You can omit the this..
Would be safer to do something like this.groups = Collections.unmodifiableList(group) otherwise anyone can modify the actual path trough getGroup() which is not great for a public API.
Please don't do assignement and comparison within the same expression. You can also avoid the break by testing nullness and kind in while condition and doing the assignement in the body of the while.
Let's just use ParseObject.createWithoutData(String, String) instead here so it'll be more concise.
Why going for semantic here ??
Any worry about case sensitivity wrt to scopes?
Is there reason for throws Exception in signature?
Why not rather package private visibility? Protected visibility seems to recommend subclassing of DeploymentsOperations. Was it your intention? Why?
nit: still Sever here :)
Please change this to "Port XXX is disabled due to conflict".
It would be better to avoid casting here as it prevents class cast exception. Please rewrite first constructor instead.
These lines look the same as in discoverZone(). Could you extract it to a method String podName()?
Increase of nesting harder to read, so maybe next approach would be better:  if (!Boolean.parseBoolean(endpoint.getAttributes().getOrDefault("discoverable", "true"))) { continue; }  Apart from that, reading all the operations needed to check whether the server should be discoverable or not make code way less clean and harder too read. Even though you don't like single-use private methods I recommend using it to make code cleaner.
This line can throw a NullPointerException.
this is a public method so better perform some null checks, or at least use assert statements
Can you return listOpApps.size() > 0 ? listOfApps.last() : null; or maybe use listOfApps.pollLast() if you use TreeSet directly on line 354. I think this better communicates the intend of the code, and it removes the not so relevant variable declaration at line 353.
Make a copy of the keySet like ImmutableSet.copyOf(modes.keySet())
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Member variables should be prefixed with this -> this.databaseClient
I think it would be easier to use this instead:  .defaultHeaders(h -> h.setBasicAuth(clientId, clientSecret))  You could then remove basicHeaderValue
from the client point of view won't this just be getPaddingLeft() (and ..Right())? or is this the padding that's applied to each individual tab?
Aren't these static strings held and reused? We shouldn't have to charge for the weight of the merge strategy string. Actual memory used per entry is pointer sized not string length.
Why not call PairedReadSequence.getSizeInBytes() and add on to that?
I might have been confused, but shouldn't we have a new handleNewSession method that takes a session Id as parameter?
This should be package scoped, not public.
Optional, but this null could be better. How about defining a SESSION_NOT_SET constant and use it here?
I'm not sure that will work on import storage domain. The process of import is being done through one host first so calling HSMGetStorageDomainInfo should be done through this Host.
If getCurrentStorageItem() is null isn't getCurrentStorageItem().getRole() should through an NPE? I think that it should be like this if (getCurrentStorageItem() == null || getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)
No need for this since we only check destination storage
Might be worth having a displayName?
Make it localizable?
Nice2have: make it localizable
Still worth using Map<String, Object> commandParameters = Collections.singletonMap(LTK_RENAME_COMMAND_NEWNAME_PARAMETER_KEY, newName); It will perform better as 1. it has less fields, so will use less RAM 2. it doesn't require a hash to evaluate an object, so will use less CPU
Maybe in case newName is null, it'd be better to pass an emptyMap as commandParameters. What do you think?
Collections.emptyMap() will save a few bytes of RAM over a new empty map.
consider being paranoid and prefix with "line.length() > 0"?
@dskalenko when line can be null?
consider saving the value of group 1 and group 2 here rather than the whole matcher
updateAvialability() calls -> updateAvailability(SystemTreeItemType.System, null); Since the reports init is no longer blocking the ui there is no guarantee the system tree selected item is the 'System'. Calling updateAvialability() will update all the tabs (not just the reports) as if the system is selected. In my opinion, you should extract a method in CommonModel to update just the reports availability and call in from here.
1. Please export lines 82+83 to a method 'selecetLabelChanged'. 2. Please call the method also before add the listener.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
nice catch, I just recently wondered about our handling of singleTop
suggestion return new Intent(context, CustomTabsManagerActivity.class);
Should we create the handler on onCreate instead of per intent?
omit?
Why does next have to be invoked here?
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
nit: can be chained onto previous line's assertion
Could probably replace these hasSize+contains calls with containsExactly, but nbd, this is what the existing code had.
Removing test because you can not fix it is usually bad idea
suggestion return stage.thenCompose(ignore -> awaitQuiescence());
IMO it's clearer if we inline passivateListener
just write return stage != null ? stage.getStageId() : null; spare some lines : )
You can use ValidationUtils.nonNull for this.
I'm ok with this (and the 'expiresIn' value) being long, but have you considered making these use the new date / time types instead?
I think the - 1 should be moved to the previous line, to make it consistent with the nextStartTime line below. Also, as we discussed, this code could return two markers before instead of one. This works not but I think we should respect the contract of getMarkerList and only return one. Otherwise, another client of getMarkerList could fail in the unexpected case of having two markers before.
Can you maybe extract the following three lines to a separate method? Maybe private void createTableWithData(tableDefinition, tableName)?
If a test is going to disable the table (or do things that would interfere with other tests), I'd prefer a new one were created. Though, I am aware of wanting to limit table creation.
Please get the current descriptor here. Once you have that, we need to create an array of modifications that need to occur. Those modifications need to be sent in a single RPC. There's a method in AbstractBigtableAdmin:  protected void modifyColumn(TableName tableName, String columnName, String modificationType, Modification... modifications)  Please use this method with an array of modifications. That will send a single RPC.
remove exists variable and just return !tuples.isEmpty();
Please return List<ArtifactToken>
Is there a reason this can't be a Set<ArtifactId> instead of a HashMap?
Maybe assert that #put() returns null
We should announce support here, as per XEP-0231  3.
Don't do this. setup the cache in the constructor itself. or bring the default setup here and set it up here. Doesnt look right to just put in a static function in the otherwise instantiable class.
can we use messageFormat instead of string-concatination? String result = MessageFormat.format( "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.", planet, new Date(), event);
It is perhaps just my personal meaning, but we could drop the call to the default constructor of the parent.
use parameterised logging
There is no need to make this injector public.
I'm not sure we need a message parameter for RequestCanceledException ? (same thing for sender at server side)
java this.onPostServerTick(this.getMinecraftServerInstance());
I would suggest putting a more sensible name for the channel name like "Review reminder", the name will show up in settings for people to toggle.
Could you move the channel creation outside, maybe in getNotification(), right after we call getNotificationChannel() ? If someone overrides this method, the creation won't happen
mNotificationManager can be null
let's not modify this. looks like the classes that use this method implement buffered writing
My guess is we should wrap this in an IOException wrapper, since we generally swallow stream close IOExceptions. (The method signature is eating it right now)
do we want to preserve the file or delete original after in the TAR? or is this done in the cleanup?
This is the only place that add entry to the pool, is it the only way to fill the pool?
Please don't use orElse(null). The point of optionals is exactly to remove null values (and thus prevent NPEs). Here, I would propose the following code: java Optional<String> citeKey = entry.getCiteKeyOptional(); if (citeKey.isPresent()) { startSearch(citeKey.get()); } else { searchError.set(Localization.lang("Selected entry does not have an associated BibTeX key.")); status.set(Status.ERROR); }
I would recommend refactoring the tooltip creation to the following, which prevents display issues, if some text exceeds the screen width :smiley:: java Screen currentScreen = Screen.getPrimary(); double maxWidth = currentScreen.getBounds().getWidth(); Tooltip tooltip = new Tooltip(description); tooltip.setMaxWidth(maxWidth * 2 / 3); tooltip.setWrapText(true); entryButton.setTooltip(tooltip);
you're testing binary branching, i.e. an if. A switch is meant for more branches. java's switch can be linear or can sometimes binary search or a lookup table. Javaslang's is always linear. Please test them properly.
The whole 4xx range (400 until 499) is defined for client errors.
You would need to add it to the appengine-web config and feed it in through the EnvServlet.java
Are these returns used anywhere? If not, might as well make the method void. Applies throughout.
Don't you need a super.setUp() call here?
There's no need to compute the error message in the general case when there's no failure, so please move this (duplicating if needed) a few lines down to where it's actually needed.
Instead of "Not implemented yet", I would suggest "Iterator is read-only"
As this operation is optional, just say it won't be supported because it's not mandatory.
Please fix your copy/pasta.
@exper0 full path HmRsHeader.VALUES_STR
@pstorch can we describe mismatch better here?
@olenagerasimova it should be appendText(this.text(item)), this.itext may point to wrong value, if text(item) != this.itext
How about move the check of null into setBookmark method and invoke the method from here? So that all the places where we want to set bookmark will just call a single setBookmark method.
delegate to the new method
delegate to the new method
Incorrect error message.
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Having the List<String> smsMessageId it will be redundant to wrap array to String
The indents are still incorrect.
suggestion }
Why have you updated this test instead of writing new one?
please make list of strings that will contain internal modules, please place this module in that new list
nit: import toSet static for consistency with toList (see L46).
It is possible we will have other checks join this list. Please move it to a field.
suggestion return cachedBody.next().map(ByteBuffer::array);
Remove @NonNull annotation.
if (mBodyContent.equals("null"))
We'd use { and } here or just fold the conditional into a single return statement.
We must find a solution that works in all languages.
isActivated() already checks if dateActivated == null, so you don't need to check if it is null again here
add this (also below)
access modifiers?
10 is hard coded, should it be configurable ?
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
A bit late now, but these should really be KafkaHeaders constants with prefixes (kafka_*).
Consider to do this only once in the onInit(). Even if it is void method call, it is still a CPU tick on every single incoming message.
Just style, but I like wrapping conditionals in () for this statement. In my view it improves readability in the ternary operator that is already somewhat tricky.
I'd rather not synchronize it here. It sounds better to check in the constructor whether config is null and instantiate the default object with new ZKClientConfig() in the constructor, in which case we can remove this if block from here, or at least keep it here just to assert that clientConfigis never null. If we do it, then we can also make clientConfig final.
nit: this is building an object on every method call - it could just be a constant
better: authz (profile, profile, profile) but this requires more logic... so compromise... :) profile (authz)
synchronized?
String.format might make this a little neater and easier to read.
We should mark this as private.
This will NPE if input is null, yet the parameter is marked @Nullable. Should we remove the annotation, or explicitly check for null (e.g. to return null if input is null)?
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
Can't this be further improved to just Arrays.asList(values)?
I'd use startsWith(prefix), rather than calling this constructor directly.
I believe it would be the same exact logic if you use Call.create(Collections.emptyList()) here instead of clone, but would let you avoid having the extra static constant.
Maybe it would be better to make it clear that it is CopyThreadLocalRunnable? Something like return "CopyThreadLocalRunnable{" + wrapped.toString(); + "}" WDYT?
This should stay final
It may be better to return an empty string here instead of null. Unless others look into this code, we may be pushing the null pointer higher. Thoughts?
the static modifier could go away
Can't this be further improved to just Arrays.asList(values)?
why not instead of 3 lines just one? return fence(FenceActionType.STATUS, Arrays.asList(fenceAgent) ) ?
Just a heads up - I tried using this in the server and found some dependency problems. You will need to create an integration test, with some suitable source span data, to try this mechanism out running in the server, just to be sure.
Are you comparing an Encounter object for d.encounter with an Integer for encounter.getId()?
The result of this call is unused. I don't think it should be here.
Every time we change a JSON test using JSONPath a cute kitten is born.
This is less noisy and reads better:  import static org.hamcrest.Matchers.startsWith; ... startsWith(BASE_URL + "/customers/")
I believe the Auth system should remain on in this method.
Lines 1068-1088 are redundant.
Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).
According to <LINK_0> .gitignore files can exist in any hierarchy level of the repository. Also precedence has to be properly taken into account.
if we don't compare value - there is no point in keeping it AtomicReference. Volatile can ensure new config will be propagated to all threads.
No need to call get twice. FileBasedConfig result = systemConfig.get(); if (config == null) { systemConfig.compareAndSet(...); result = systemConfig.get(); } return result;
It is still worthwhile to check if it's null or not to not recreate systemConfig object in later calls. But as it won't load anything it's not that big deal, so up to you.
We could omit the second Integer.
no need to specify type on RHS
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
InputStream.close() doesn't contain any implementation so you can drop that call (but it doesn't matter). But I am pretty sure that the base class close will not get an implementation some time because it would break all previously working subclasses.
Better to organise this in a double empty try-with-resources idiom: java try (Closeable ignore = level1; Closeable ignore2 = level2) { // Just for closing }  To delegate boilerplate exception and suppression handling to the Java construct. If it appears unnatural, you could extract this in a utility method, e. g. called  void closeBoth(Closeable, Closeable) throws IOException
Remember to revert this file, it should know about the transport class.
I think it can be logged with WARN as this is situation that we create ourselves and we are aware of it, so it's not really an error.
ex.getMessage() VS "Feature is disabled"
declare throws please
Perhaps I'm being daft, is this condition backwards? Why set 'played' to false when position is greater than 0? Should it be setting 'new' to false?
1. position should be able to equal count which means the end of the stream. The current logic will never be able to seek to the end. 2. Shall we throw an exception if the position is invalid, for example negative case?
don't need newPosition... You can just put that operator inside setSetpoint
Please fix indents and use assertNotNull
What about data type here?
Shouldn't the two lines above resolve to true?
Should make a differentiation of the name and id.
all these methods can be private
nit: name = tableName or this.name = name
can we leave this package private? This will make future refactorings easier, because we don't need to care about changing public interfaces ;-)
do you think it would add clarity to move "this::CallRequestAccessTokenEndpoint" to a variable: Function<Client, Response> endpointCaller
This should probably log the stack trace (perhaps separately on FINE). Otherwise this information is useless. It's also called when viewing the configure page of a user with a legacy token so I'm not sure a warning is appropriate here.
We should handle the case where getDAnalysis() returns null
not important, but that could be "return Optional.ofNullable(ispnResource).map(IspnResource::getResource)"
This also seems kinda pointless and a bit brittle. Just return resource.
I don't really like using null as a sentinel if we can avoid it (since it's nice to be able to use empty objects to avoid crashes around null references). And I don't think the server makes any guarantees about whether children is nil or just the empty list.
Returning isAuthRequired by default sounds gold to me.
What is purpose of this method?
How about "Type is not supported"?
Why are you creating an instance of the class to perform the conversion? Why not just use a static method. This seems like it's creating an unnecessary object.
combine with assignment this.outputType = requireNonNull(type, "type is required");
is something missing here?
For me the fix above is not enough. It continues and I get a null pointer exception in this line. Adding the lines below fixed it for me: if ((wb == null) || (wb.getActiveWorkbenchWindow() == null)) { return; }
Why only adding it to the active window and page?
equals() is not usefull for enum, == is sufficient.
As mentioned in <LINK_0>, I would claim that setting the status ONLINE is many cases a bug. In the example of the hue binding, the handler determines the correct status in onLightStateChanged. So either we do not set a state here at all and wait for the next update (triggered through the regular polling) or we set it to UNKNOWN for the time being. Same should be checked for the other bindings.
Would a switch be cleaner here?
Just putting it out there early in this review that I'm not too big of a fan of LongRunningOperationStatus - it's very long.
needed in the synchronized block?
I don't know which pr will contain the final setting for this, but the 2 FAILED statuses should be here also. cc @hreeve-cloudera
This should happen within the future
I suggest inverting these two calls, so that the instance no longer is in the created collection.
Spacing is off here, do you have the code templates installed?
assertTrue instead
Are you sure this test passes?
There should be an equality test for identical requests with different dependency levels
Usually (especially for loop conditions) I like this style but in this case this is a mask, so if we ever go up to the top bit this becomes broken unexpectedly. Let's use == instead.
I would prefer to have the splashscreen immediately hide when the error occurs, so you are only left with the exception.
@prondzyn you can return numberth element of the collection
Why is this returning null?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
Make this public too, to be consistent with getVersion() and the other classes. (Not sure if they have to be public, but the class is package private)
Maybe a check here that getLeft() and getRight() have identical schema?
I know this is how the other hash aggregators do things, but I wonder what the perf impact (cache misses/RAM footprint/GC) of IntObjectMap vs. IntIntMap is here. Given that the hash function is MurmurHash3_128, the collision probability is negligible (you would need ~2^64 entries before the first expected collision), so I wonder what harm there is in assuming that collisions never happen?
How can this succeed if tupleWriter.open() isn't called (when dataSink is null)?
Operation can have InputStreams attached. There's a way to translate that to HTTP, we should figure it out. Or at least throw an exception if there are attachments.
When is the executor shut down? I guess the ...AsyncFutureTask doesn't shutdown the executor after it's completed, so you'll keep leaking threads. Given that this class has a close method, maybe it would be better to have one Executors.newCachedThreadPool() executor for the entire instance of this class, which you could shutdown in the close method?
This method can be return Util.createEmptyOperation(REDEPLOY, address);
elapsedNanos.
You should probably leave this part in: java if (coll.isEmpty()) { container.delete(dataKey); }
Put the cast on the same line
extract actual.getModifiers() to a local variable.
add () to group && conditions for clarity
static import shouldBeEqualWithinPercentage, it makes the code more readable applies to the other classes
ParameterNameProvider=ClockProvider Or, better yet, let's just move to getUnableToInstantiateException(), I don't think there's much value in having the dedicated versions really.
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
if getExternalNetwork() returns null, you'll end up with NPE.
Why is this removed?
Use this.removeCallbacksAndMessages(null) instead.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Should this fire regardless of if the prior delete succeeds?
I am still confused by this. The one place where this configuration is used is to construct IBuildPlans in the server beaviour. this map will result in build plans whose IDs are the Url or name (which is fine) and whose names are the URL. This is inconsistent with how the build plans are otherwise constructed from the model jobs. When constructing the build plans from the model jobs the ID will be the Url or name, and the name will be either the display name or the name.
We're just swallowing this?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
It seems this variable is not used, can it be deleted?
Do this check before the for(), because if this.notificationConfiguration.isEnabled() or this.notificationConfiguration.areEmailsEnabled() are false, you don't event need to load the descriptors and so on...
Even if we have currently only a 2 state discrimination here I would maybe use an enum (like SitePickerMode). Wdyt?
Just a note here, I realized that I don't see many usages of this approach where we check to see if network connectivity exists before utilizing the dispatcher. Do you know why this is so?
I think should be post instead of this.mPostToReblog.
looks the variable originalStream is not used.
Check if data is null.
may be try-with-resources?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
This could be calculated on invocation instead of unconditionally allocating a HashSet for it for every statement.
What about :  names = new ArrayList<>(attributes.keySet());
You'd probably dispose your stuff, and call super.dispose() at the end.
Some particles effects might not need physics: the architecture should not assume they always do.
I think you should dispose the ShapeRenderer here.
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
declare throws please
![MAJOR](<LINK_1> 'Severity: MAJOR') Either log or rethrow this exception. [![rule](<LINK_2>](<LINK_0>
How about putting the condition in the 3rd param to avoid duplication?
Log the exception and pass the exception into it rather than doing a printStackTrace. Then, are we checking for null after build? Better wrap this into a Runtime exception with a descriptive message.
This can cause problems for some KnowledgeBase implementations when reporting statistics since the list of found causes can contains causes that are not in the knoledge base and hence has no key in whatever database it uses. A QnD way of fixing this could be to not include them in the statistics logging at all, i.e. add them to the list after the stat logging call.
copying and rebuilding the list everytime an element is added to the chain? Maybe chains are not long to see the adverse impact of this now. But when long chains are build this could be seen as inefficient. Something to think about in future refactorings.
List<WebElement> els = Lists.of(mockElement) We already know they're web elements because of the strong typing.
Please add String type args: new ArrayList<String>()
Why not use name as the key in CACHED_ENCRYPTION_KEYS?
return String.valueOf(this.properties.get(key)) perhaps? to protect from null...
I would prefer to use String.valueOf(value)
There no whitespace around <=. Also - good to enclose blocks of that that if/else in {}.
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Same question as above: since this assumes HTML formatting, this is less a RawType and more specific to representing raw image data in a way understood in HTML.
It can be like: java if (o instanceof AdHocActivationCondition) { AdHocActivationCondition that = (AdHocActivationCondition) o; return Objects.equals(value, that.value); } return false;  instanceof operator check null value as well.
equals should also check dimension ?
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
Should use .equals() to compare contexts. However you could be dealing with null, so you should check that first.
Use HandlerUtil.getActiveWorkbenchWindow(event).getService(IWorkbench.class) to get the workbench.
Why do we need a snapshot of the world? Isn't it possible to just use getCurrentState() to get the selection?
why not compile once in field?
Please consider updating of java docs as well. I don't see any java docs that would explain how we store machines names in annotations. I guess, previously java doc of MACHINE_NAME_ANNOTATION_FMT const has some short info.
![MAJOR](<LINK_0> 'Severity: MAJOR') Replace the synchronized class "StringBuffer" by an unsynchronized one such as "StringBuilder". [![rule](<LINK_1>](<LINK_2>
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
Extract the building of the ResponseMessage to it's own variable (in eclipse, select the text, right-click > refactor > extract local variable / select code + shift+alt+L). This will make the code a bit more readable, especially when you'll be passing in other things besides the ResponseMessage.
I agree with sonar
remove when the export button is implemented
if there are errors at this point, an exception needs to be thrown. This will just ignore the errors, which will cause a confusing error later in transform. call context.getFailureCollector().getOrThrowException() after this line.
It doesn't feel right. Why it is required?
can this be just (time - this.lastModifiedChecked.get()) > this.refreshDelay) should always be > 0
not sure if it will matter for your tests, but calling value() is not what normally updates access time. It is the Cache/Store operation that returned the value.
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
You can combine these 2 lines into 1
I think these null-checks are redundant, otherwise we should also check email.isEmpty() and maybe do some more validations. Also, the error message "Identity cannot be null" doesn't relate to email or resending email confirmation - this will confuse the users in case they encounter it.
Does getEmails2 always return a collection? Take a look at code to be sure. Concerned about possible NPE.
Is takeLast(0) meaningful? If so, it can be routed to ignoreElements(). BTW, ignoreElements() can be optimized by making it singleton and be very simple (i.e., its onNext does nothing) instead of filtering with always false.
maybe it's better to use XemblyLine here for exact formatting..
Put suppress warnings annotation to method and change to direct returning the getted value to avoid temporary store the return value.
Minor: Or code conventions typically favor this style:  try { ... } catch (Throwable t) { ... }
Can bytes be negative?
~~Unfortunately we can't do this. There is no guarantee that getBytes will return a byte[]. For example when using off heap this will always be null.~~ This was thinking the old off heap, it should be okay for now.
This probably will be replaced by <LINK_0> ?
This seems like it will cause problems for BamReader.queryUnmapped()
Since this is a legacy record, deleteHorizonMs is never going to be set. It seems we can avoid loading the full batch? Ditto in isDeleteHorizonSet below.
fyi: if we counting everything, fs.getContentSummary(path) would be the most efficient.
Seems we have changed to log2, the computation will be accurate but now what is the plan to show all files < 1 MB query? Seems more computation to be done in UI. From the user point of view, 1KB, 2KB, and 4KB is all noise in UI. The 10s of bytes makes it more readable!
I'd use << 3 to match MemoryAddressHash
requireNonNull(defaultValue, "defaultValue is null")
This should make a defensive copy of the list.
This is not necessary.
two places where partition is serialized? Not very comfortable with that - this is repeated code that needs to be kept in sync.
final
I know this code was just moved from elsewhere, but is 10 meaningful here ? Although harmless, it seems like random over-allocation by half. Is there any way possible this can use more than the max possible # of bytes in an ITF8 encoding for an int, which is 5?. Can this use the new MAX_BYTES constant ?
Include the bit in the toString(), e.g. maybe 1<<getPosition()
You should instead use return ""; It would avoid creating new objects everytime the method is called, since all "" refer to the same object (string literals get internalized). Or you can have a private static final String EMTPY_STRING = ""; in your class and use that instead, if you use a lot of them in the same file.
I don't know, but isn't the class also of interest?
This can be simplified to Optional.ofNullable(id).
suggestion return Optional.of("org.junit.platform");
Consider removing the "Optional" part. Seems better to return an empty map, if not present.
maybe add a null check that it's not already detached?
can optionally add this to setup
If you're loading www.google.com, you need to enable JavaScript
What is this for? Feels like some unintended checked in code?
should this count be parameterized?
Use Assert.fail() instead
As a nit, should have a null guard here.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Let's remove the wrapping finally (including HibernateUtil.closeSession) also
please decrease severity to "debug"
unneeded if clause
To be consistent I would remove the "this." in front of bridgeHandler (it is also missed in the if clause already).
Please use lambdas where possible.
Not sure why you need this. If you're getting a leak here lets try to work out what's causing and see if there is a better way to solve it!
Nice, I like this.
Please use Objects.hash(...) (<LINK_0> instead of manually hash coding everything.
return (id == null ? 0 : id.hashCode());
What about hashcode and equals, should they need to be regenerated with the new boolean
if getExternalNetwork() returns null, you'll end up with NPE.
why not encapsulate with getProviderDao() and not getDbFacade().getProviderDao() ?
shouldn't provider be validated for existence prior to accessing it?
Please remove this extra line
Any worry about case sensitivity wrt to scopes?
This method takes a varargs of String. There may be zero elements in this varargs, but you don't bounds-check and may run into an exception on line 88. I'm also curious if there is information being thrown away if multiple scopes are provided?
Use Optional.fromNullable(marker) instead?
should be ofNullable
are spaces OK in namespace strings?
a table without db is not invalid? is it only needed temporarilt - until this whole thing is done?
put an empty line after
this log could be misleading, makes someone think that the table is being deleted. how about "Deleting table %s for truncation"?
!(parent instanceof MGenericStack) || parent.getSelectedElement() == part
Money is a reference type and needs to use .equals() instead of ==. Also we need to make sure calculateCost is called first. suggestion return part instanceof CombatInformationCenter && getStickerPrice().equals(part.getStickerPrice());
Pedantic: changing this to c = new ArrayList<M>(); and not returning would save an object creation. Pedanticer: creating the array in the outer scope would allow you drop the branch on each invocation of the aggregator.
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
suggestion logger.warn("Could not add {} with key '{}': {}", element.getClass().getSimpleName(), uid, ex.getMessage(), ex);
suggestion logger.warn("Cannot add {} with key '{}' cannot be add. Provider '{}' unknown.", element.getClass().getSimpleName(), element.getUID(), provider.getClass().getSimpleName());
any reason to accept null? consider checkNotNull(initialAttributes,"message")
Could return an unmodifiable list
Wouldn't ArrayList be much more efficient here?
Use UTF-8 Charset here and the getBytes(Charset) implementation (it doesn't throw an exception). This use depends on the default system encoder and if it were to change it'll be trouble.
Wondering what this will do to large file upload support.
return ?
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
space before catch
Redundant assertion
As a nit, should have a null guard here.
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Should be immutable by making a copy.
"{" is used to indicate object boundary, but in all other object.toString methods "[" is used.
Why we should change behavior for the deprecated method?
You can use StringUtils from the commons.lang3?
probably && rabbit.isValid OR npc.isSpawned() then use npc.getEntity again
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
should this say throws PatternSyntaxException ?
Please use LOGGER.debug because this error is kind of expected.
Nit: No need for final.
I'm iffy on having this here. This is partially because we let the status update handler write to pending tasks, and partially because it means we are reusing a pending task id. Generally we let the SingularityScheduler do all of the work of creating a pending task to keep responsibility for those types of operations separate. We actually removed bits from the status update handler a little while back so that it would avoid mutating the pending task queue. Instead I'd suggest using requestManager to add to the pending request queue. This will let the scheduler do it's normal thing and rebuild a full new pending task with new unique ID from that pending request
optional: I find it more readable to break the line at the || so that the visual grouping is the same as the semantic grouping.
Deprecate? And if anyone is using this method, what is the current thread pool size in the live instance node?
It might look better to start the new line from the .show() instead of breaking in the middle of the arguments. Also note that you aren't breaking the lines in other places.
I want to method accessor to be package private :eyes:
Same here, better in the constant class.
Don't we need to do the caching here?
If fileContext is not Cacheable then caching should not be used. hiveFileContext.isCacheable() would provide information at runtime if the caching should be used or not.
We should avoid fileSystem.openFile in case validation is disabled.
Should this not be nested-projects?
:bug: surely you meant delegate.getCategoryId()?
please use constants here and for the getType
Maybe, but I like simple and dumb unit test, this test checks that the service is started and well initialized, we don't need to test that on all tests. I don't see cases where a Before something is useful to understand failure in this case.
This test case in error-prone. Both the first and the second statement may cause an AssertionError. Try using try-catch instead. This may help us to determine that the AssetionError is thrown from the second statement.
we likely want specific edge-case as fixtures to ensure deserialization works as needed.
Redundant else blocks.
This should be simplified to just: >return value;
I can't remember our usage paradigm here, but I believe if the value is not null, we should use an assertion that the value is indeed a Map. Otherwise the caller of this method is probably trying to do something wrong (i.e. expecting a map when the property is not a map), which would be a bug and should be fixed.
Objects.requireNonNull
Here we should return Polygon or MultiPolygon or create two implementations?
all these methods can be private
evaluatedAnnotationValue or evaluatedValue?
computeIfAbsent would reduce possible multiple queries to the Kubernetes master, <LINK_0>
I assume this lazy initialization should never happen as we will always initialize this field in class constructors, agree?
missing @Override declaration.
Should be "InstaPost" actually.
repeated ...
There's probably some edge cases where this isn't true. Consider the case where there's 1 discrete parameter to optimize, with possible values {A,B,C}. In this case, there's only 3 candidates - and the candidate generator should terminate once all 3 have been generated.
I think you have failing tests because this isn't true. The HashBasedIndex coerces all numbers to doubles, and thus looses precision.
What is purpose of this method?
Be aware of close() issue, ie: input.close(), output.close(). I cannot remember if we need to do that. Please check the IOUtils.copy() to do so.
@apc999 This needs to be public or reflection will not work
Does this need to be a member variable? It is only used once and comes from a static method so it could just be a local variable down in createNotification().
change this to options.put("pem", Arrays.asList("pem"); depending on your ultimate approach.
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Wasn't this initially a bug? Maybe it would make sense to extract this change in it's own patch.
can be final field of this class
Can this be private, or is there another use case for default attribute outside the builder's call?
Same code as in the method above, factor it out?
Shouldn't this check be at the top of this method. Should we ignore working copies all the time?
well this could be changed as JDK will always be 8 or more.
& let's not forget about this.
Unnecessary log.
java @Override protected void setUp() throws Exception { super.setUp();
The job of a dispose method is either to free unmanaged resources / memory and to deregister stuff properly so that the object can be garbage collected. Of course you can set all references to null / clear datastructures etc. to help the garbage collector but this is just boiler plate code with little benefits.
it --> window
instead of setEngineSessionId - why not having it at ctor?
Throw an unsupported operation exception here.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
This an API change, perhaps best to convert back into a MultivaluedMap for backwards compatiblity
Collections.unmodifableList()?
defensive copy?
This is returning a mutable collection but SpongeRootCommandNode is returning an immutable one. Is it intended ?
This is already done for you by the super class you extended
This needs to be new Request(Request.Type.OPEN) now.
honestly I think it would be a lot cleaner if you just release stuff in the tests itself.
Either of the events should be raised I think.
on IOException|RuntimeException you could add a binary annotation of "error" -> message, as that will turn the thing red in zipkin's UI
Maybe length instead of bytes?
defensive copy?
working with prefetched columns should be faster (and more stable) than using findElements every time
We could omit the second Integer.
computeIfAbsent would reduce possible multiple queries to the Kubernetes master, <LINK_0>
StringUtils.isEmpty(namespace) will take care of both (not important, just FYI)
can we please limit this loop to some finite number of tries and fail in case it runs out? It's a bit scary like this.
size is calculated here. Do you want to change sizeCached to true?
No parens on condition.
Should be : sizeInGiB
What if fileName doesn't have any .?
@pwillworth why not use File#separatorChar ?
Added code to print an error message and exit.
seems like message is invalid (really draft-03/04 in this use-case?)
Don't need toString()
there is already a constr, which takes (id,groupId,resource, dataSource,interval) Can we use that in indexTask, instead of adding a new one ?
Use a list to access at index
can we use BeforeClass annotation?
I would suggest making this method synchronized
returning null cause null pointer exceptions
nit, Collections.EMPTY_MAP?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
Better to rename RoutingTable.removeWriter to RoutingTable.forgetWriter?
Oops, good catch!
FYI ImmutableList.of(address) is more efficient, but it's no big deal, that's just a note for future reference.
probably unrelated here, but if the class gets getParamaters() all at once, it seems unrequired to feed it with each getParamaters().getter as well.
I would add the following condition VMStatus.Up != getVm().getstatus()), only for setting the parameters. The call to internalEndFailure should be from endSuccesfully. I think Calling logic from the constructor is wrong.
You have this "OR" in several places. Consider extracting it to a helper method in VMStatus.
extract
if the properties instance may be null then you have to make sure the code in the line above does not cause an NPE and check for null before calling the *refreshLayout*
I would really appreciate if you rewrite this so it doesn't use -1 as startIdx. A year from now I won't remember why we want to load from position -1.
I wonder is there a reason this is specifically a BlockingQueue? We don't block waiting for elements to be added, we instead use the semaphore and we don't have a bounds (besides Integer.MAX_VALUE). Can this not just be a standard ConcurrentLinkedQueue ?
Could we have two constructors? One with and one without an executor? This way it is obvious to a caller that they executor is truly optional.
I guess this should be configurable.
Not sure why you need double quote unquoting, but this probably suffers from the same issue like the single quote unquoting above.
Please revert this. The implementation is incorrect. Quoting a single quote works by using doubling it. The SQL literal '''' which are 4 single quotes, produces the string ' i.e. a single quote, which is not covered by your implementation. Why did you change this anyway?
Wouldn't we want to call s.beginTransaction() inside the try-block and then add a catch-block to determine if a transaction is active and rollback?
Why an array? List<String> is just as fine
Should maybe other countries be added here?
@Nadahar Right, text/vtt, i was too fast...my bad.
Does it really need to be 'public static'? Is this method used from somewhere outside?
This is ok but can be made more compact: java try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()))) {
Do we want a space here before the brackets?
Same thing here. I don't think mProducerContext != null should be a precondition -- setup() may have thrown an exception and we still want to do our best effort to cleanup by allowing super.cleanup(context) to be called.
@apc999 This needs to be public or reflection will not work
minor thing, but this doesn't need the throws clause
I'd feel better with this if this method was still protected. Why was it made public in Netty 5?
Should we prevent setting the executor while the connector is running? Otherwise we get concurrency issues with hasInternalExecutor flag. Is it even necessary to have this setter instead of setting it in the constructor? Then we could make the executor field even final. atm we are accessing the executor from different threads without appropriate locking or making it volatile.
same here, why only these two methods?
Would be great to have it part of the TestableObject directly; so when we change the build tool one day, this feature would still be present.
run -> status
that will fail when we only have 2 arguments in the request, because line 3 is expecting 3 arguments and line 17 only handles less that 2. i mostly do it the other way arround, so if(args.length==2) return call(pc, Caster.toString(args[0]), Caster.toFunction(args[1])); else if(args.length==3) return call(pc, Caster.toString(args[0]), Caster.toFunction(args[1]), args[2]); else throw new FunctionException(pc, "StringSome", 2, 3, args.length);
Use assertEquals
compare object instead of reference? Why don't we just always wrap it since it is cheap now?
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
These might look a bit tidier as static imports
Probably want to add the filter here: if (objectFilter.include(this, r.getTree()) pendingObjects.add(r.getTree());
Isn't there a better way to identify if an access right is inherited than checking is a UI widget is an instance of Hyperlink?
Add messages: checkNotNull(id, "id"); etc.?
Typo. And I think we mainly use the arg name in this situation, i.e. checkNotNull(mbean, "mbean")?
Constructor should be private. Make a static factory method
suggestion LOGGER.warning("DNS multicast capability has been removed from Jenkins.");
suggestion this.install.classList.remove(DISABLED_CLASS);
disabledSince is never reset.
bleep
Use java.util.Objects.equals().
can be shorter image name filter not specified
Generally with these kinds of constructors you'll end up calling the other constructor directory, passing in null for the ignored param.
public constructor in non-public class
Please keep this.cell near the related fields (previousFamily & cell count) below
responseStr might as well be inlined here since it's the sole use of this variable and it wasn't any less readable before.
This assertion is probably not buying us anything
s/duration/size/
Binary output length can also be calculated.
Looks like this is the only use of expired, it could just be:  return false;
Shouldn't this be <= 0? The decrementBombs doesn't have a 0 check.
Should this be one line down after site?
(Boolean)null -> boolean = NPE. ParcelCompat.writeBoolean() works with primitive types, we use object types to have three values.
I think this second parameter is meant to be flags and should be passed to the parcel.writeParcelable calls.
no need to assign the client to a var here since it's only used once; could collapse these 2 lines to 1 instead
You could use ZooKeepeerUtils.wrapAndThrowIgnoring(e, NoNodeException.class) here in a single catch block. Not necessary, but simplifies this common pattern.
The checkExists method returns a Stat object if the path exists, null otherwise. The return value is not being evaluated. If the path does not exist, do you want to just throw NoNodeException , or is there a different exception we can throw? It can either be NoSuchContainerException or perhaps some other generic Spring Data exception that indicates the absence of an entity in a repository.
We will probably run this from maven, and will use it to write to a "target/generated-metadata" directory, which won't initially exist, so please create the directory here if it doesn't exist: File outputDir = new File(args[0]); if (!outputDir.exists()) { outputDir.mkdirs(); }
Should maybe other countries be added here?
Since a single String string is required at each test, please use following code: suggestion return Stream.of("", "Knuth", "Donald E. Knuth and Kurt Cobain and A. Einstein");  This is more readble than String[]. The return type will be Stream<String>.
I don't think we want to propagate the exception in this thread. We just want to return the throwable. It wasn't this thread that had the error.
This can be removed now.
Do we need a checkArgument on the input here, or do we know that it will be a set? And should that be checkNotNull(input, "input")?
please put each parameter in separate line :)
put each argument in separate line
consider renaming to "simpleParagraph", or "placeholder" The base class extends TestCase, which makes the annotation unnecessary. Consider going with annotations only and removing TestCase as a base class in the hierarchy. Also prefixing the method with "test" is somewhat redundant with the annotation present.
why rewind?
Add Gst.checkVersion(1, 16);
it looks like we're releasing it twice here. release calls allocator.release as well.
You should use a variable to store this 5, so that when you want to change it, you only have to change it in one position instead of 3.
This method can be private too
WTF is lala
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
why we need to check for getVm().isInitialized() ?
wrong lock - this is UpdateVmTemplateCommand.. so LockVm is wrong call.
any reason not to combine this method with isReadOnlyPropertyCompatibleWithInterface ?
You could use ternary if for this: return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
Consider extracting this to a method since it's used again in isDiskInterfaceSupported.
Should be "InstaPost" actually.
Looks like this toString() got generated before the tags field was added :P
technically "status=" should be "state="
I would just use pairId here and remove second arguments from URL.
java this.clientInfo = Objects.requireNonNull(clientInfo, "ClientInfo must not be null");
We should catch NotAliveException and return null if it happens This is to keep the syntax consistent with original implementation
Either use assertEquals() or better just verify at least a single nic returned: assertFalse(interface.isEmpty()) ; in addition, you could iterate over the interfaces and verify that all of them belong to the desired hosts: for (VdsNetworkInterface nic : interfaces) { assertEquals(VDS_ID, nic.getVdsId()); }
Null-check
This is the only place that add entry to the pool, is it the only way to fill the pool?
nit: imageName field can be changed to DockerImageName, to make tests' bodies a little bit smaller
suggestion removeImage();
what happens if one passes SHA1 here?
I'd really like to see those unrelated fixes - thanks for that - in an extra commit, since they are unrelated to this change.
most -> must
Wouldn't it make sense to check the argument in front of using it?
It would be nice to have a configuration file locally, like looking to see if a ~/bridge-sdk.properties file exists, that would override default props. Then environment variables can override both of these (don't know if Apache config does this but it looks like you're doing something like that here).
I would add an empty space after the "exist" word to better read the configPath
can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.
We are not splitting files between individual tests yet. Please remove the duplicated file and have them point to the same one.
can we use here some simple words like variable, parameter, instead of cryptic lc1?
Please keep line numbers ordered.
java value.trim().isEmpty()  would be more clean IMO rather than java value.trim().equals("")  WDYT?
So, you're going to hate me for this, but this is a little inefficient as it compiles the regex every single time. Something like this should be more performant: java private static final Pattern ALL_DIGITS = Pattern.compile("[0-9]+"); //   return isBlank(value) || ALL_DIGITS.matcher(value).matches();
I think we might need to ask the Metamodel for whether this is a managed type at all. Could be a class unknown to the persistence context.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
java boolean result = false; final DetailAST parent = colonAst.getParent(); if (parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT) { result = true; } return result;  ----> java final DetailAST parent = colonAst.getParent(); return parent.getType() == TokenTypes.LITERAL_CASE || parent.getType() == TokenTypes.LITERAL_DEFAULT;
@dskalenko can you post me this tree? You can nicely visualize it in Checkstyle GUI: <LINK_0>
getLastSibling == parent.getLastChild(), no reason for new method here.
Should be ClassNotFoundException. Catching all exceptions and disposing them may miss unexpected exceptions.
an expensive way to check if it exists ... if there's no other way, then this will probably do
How about narrowing it to ClassNotFoundException and fail with other exceptions?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
You can use CollectionUtils.toImmutableList
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
use symbolic name for whatever the last feature supported in that release is (along with <= instead of <)
use translateText
Use .getOperator() in place of m_operator?
Remove this
Same here; will probably not work with controlled models
Please get the current descriptor here. Once you have that, we need to create an array of modifications that need to occur. Those modifications need to be sent in a single RPC. There's a method in AbstractBigtableAdmin:  protected void modifyColumn(TableName tableName, String columnName, String modificationType, Modification... modifications)  Please use this method with an array of modifications. That will send a single RPC.
I would retain the existing indexOf body to to avoid indirection in the most common case.
There should be a white space before else Also you could use word.charAt(i) in both the if and else statements (e.g. word.charAt(i) == 'y') instead of using substring, that might make it a bit more obvious what you're doing
You can immediately return target here, simplifying method code.
what if none found? are we sure there is at least one?
Is this enough to guarantee that the call works? Shouldn't we better check if it is empty, or setup the test in a way that it returns a non-empty list, so we can assert that everything (including deserialization) works?
There is already an ApiRoleList type local variable - roles - which should be re-used and initiated here.
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
what about if {} is first, followed by x++? it should be treated as a standalone block. please add it to all options.
Isn't this going to throw even if one of the ids is bad? Do you want to change that to continue processing valid blob ids?
If blockIds.contains(blockId) is false, we should not allow adding this blockId to movedBlockIds.
why?
static import
wrap
Why now is proper? If whole predicate is pushed down, then I would expect to see TupleDomain.none() here.
One thing to note here is that since shutdownProducer() requires obtaining the lock, this operation can get stuck waiting on this lock. Operations such as flush can take a while (up to 15 minutes for BMM with the current flush timeout). Once concern might be that unassignTask() is called from the onAssignmentChange() threads, right? And have a limited time of 30-60 seconds within which it needs to complete?
Do we need to delete task mode mapping wherever this is being called? In general, would it make sense to get/put/delete them together as a complex value?
It is the same in this line, leave a blanck space before "+"
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
according to rsdl_metadata.yaml you should be validating these fields: action.name: 'xs:string', action.service_type: 'xs:string'
disk has image_id property, you do not need to run extra query to fetch it
use instead, please, implements IntegrationEvaluationContextAware
No reason to check for nulls over here - the createStandardEvaluationContext() can deal with BeanFactory as null
No, this. when you call methods.
suggestion throw new UnsupportedOperationException("removeNotificationListener not supported by Jolokia");
Note: This is not always true. We use 'utf8mb4_bin' for mysql and 'Latin1_General_100_BIN2' for SqlServer, because we need case sensitiveness on various places. The unit tests of ebean will run here at foconis also against a database with these settings. This means, the tests will fail here. What do you suggest? - can you change your mysql/sqlserver test setup to use a case sensitive collation? - can we introduce a flag (Systemproperty), so that I can run the tests against a case sensitve version of mysql/sqlserver? There are some special things to pay attention, if you change the collation/charset: - the maximum index length on mysql is 767 bytes, this means ~191 chars on 4-byte UTF-8 charsets - setting the collation on sqlserver to case sensitive, means also that the columns are case sensitive, I had to modify some tests for this. (I can diff the code and create a PR for this, if you want)
Is this class really needed? I've not looked 100% but perhaps ServerInterceptorFactory/AccessAuditContext could be extended to record that the request was a remote jmx one. Then these checks could be done in ModelControllerMBeanHelper.xxxNotificationListener().
typo
this should be extracted to a method
We should not catch generic Exceptions. Can you make this more specific?
use namespace instead of DEFAULT
Should be a SamzaException with a message, not NPE.
assert.NotNull ?
A message might be helpful
typo here: bntegerRangeRandomizer -> integerRangeRandomizer
This could actually be backward compatible with the existing API if this method (and the monitoring equivalent) simply replaced the first notifier.
brr... I don't understand this ctor. it should do just this: this(new RqFake(), dispositions). why it's doing something else?
@dalifreire making a static method is a workaround not a solution. Here you could store the stream as a field and create Channel in requests method and pass the created variable to copy and make.
@fanifieiev the same above.
I would use InterfaceUtils.isSubtype() has a main method to confirm that it is a LocalBroadcastManager. The check !getClassConstantOperand().endsWith("LocalBroadcastManager") can still be present. It will be useful to have fallback when the complete class hierarchy can be loaded (aka missing classes during the scan).
@xpdavid is this the right thing to do?
Can this be private, or is there another use case for default attribute outside the builder's call?
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
And if you keep this field, I think this one should be DATA.
By using the above naming convention, we no longer need to use this. to disambiguate which variable that we're referencing.
instanceof?
could use a better error message like "Failed checkForChrashes call" also could dump the stack with a line "e.printStackTrace();"
This check is unnecessary. context can never be null for a properly constructed object.
The true parameter causes the contents to be appended to the end of the file, instead of re-creating the file with the new data. This can simply be new FileOutputStream(file, true), which defaults to false.
again: removing the explicit initialization: worse, not better
@sebing let's use try-with-resources feature here since we're now on Java 7. Make sure to include both input and output.
wrong formatting - every parameter should be in new line
wrong formatting - every parameter should be in new line
Flo will probably tell you to remove this extra line :D
Will these methods ever be performed separately/one and not the other? If not maybe makes sense to combine to one method?
suggestion: Paging fields have been added
Is it better to initialize latch to CountDownLatch(0) instead of null? Also initialize it in line 45, when latch is declared?
please add call to populate: addLinks(populate(connection))
This will create 0 connections. Didn't you mean < ?
please user assertEquals
failCanDoAction?
I'd push the "{" up a line, but that's just me.
This should be: if (!getStorageDomain().getStorageType.isBlock()) You are duplicating the logic in StorageDomainType.
This should be at least a constant, and more probably an instance variable.
Aren't there cases where people might be changing/removing breadcrumb metadata in a callback? The case which comes to mind is intent extras from the EventReceiver.
It is not possible to change field after instance creation. Why you create unmodifiable map each time this method is called? I would prefer use it once.
Fuse container?
I don't think you should exit if the check fails (exceptionMessage() does a System.exit). I think you should just silently ignore this error and continue.
This should use Assume to correctly skip the test.
Taking into account that you don't know final size of a list and you will dynamically add items you can benefit of using LinkedList. Though that would not have a real performance impact I would still recommend to consider that case here and further for production code.
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
I have personal preference for just doing the cast, rather than first asserting. The cast will fail with an exception saying what type it actually was. However, the assertTrue doesn't have a message so will just say something like "false".
Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?)
on IOException|RuntimeException you could add a binary annotation of "error" -> message, as that will turn the thing red in zipkin's UI
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
should this count be parameterized?
Instead of using String += otherString, it's more efficient to use a StringBuilder and .append() (especially when in a loop), then return sb.toString() at the end.
PlayerBackpack is redundant here, no need to specify the class you are already in.
This method should be private or default as otherwise it is API addition.
Minor: move init to the beginning after the constructor
Our standard convention is to prefix with this for instance members - return this.context
As above: private, 100 chars, use error result instead of doOnError.
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
I prefer the ?: syntax, also I think isLight is a leftover from the merge, because it is not needed suggestion mSwitch.setIcon(mLinear ? R.drawable.ic_apps_white_24dp : R.drawable.ic_list_white_24dp);
This method has an external annotation now.
I believe there is no need to re-register the listener on each entity assignment since field setDnsConfiguration is final. And thus clearing listeners can be omited.
The same DEBUG concern is here, too, for otherwise
Can have a isRef(Expression) and isLit(Expr)
I would suggest to declare at least callExpression.arguments().get(0) in a variable to avoid all this casting
This is a bit too strong. You should perform the verification of the true and false expressions only if the type of the expression is Optional. With the current state, the following code will trigger an issue, and it has nothing to do with optional and is perfectly valid:  public Optional<String> bar(booleab b) { Object myObject = b ? null : new Object(); return Optional.empty(); }  With the following, it should work:  if (conditionalExpression.symbolType().is(OPTIONAL)) { checkNull(conditionalExpression.trueExpression()); checkNull(conditionalExpression.falseExpression()); }
The NO_OPTION test isn't needed given you test for YES before taking action.
Same here with merged if cases.
Better use switch-case Throw a new Exception for the default-case.
Nitpick: I would simplify this to return compoundAssignmentStatement != null && isAccessingExpression(...)
getNonStrictParentOfType
I don't think that it makes sense to add such logic with coordinator field here. The matter is that who is the corrdinator depends on the order of adding resources, and, unlike the case when it happens in the table, you don't see the effect.
The first object in the database may not necessarily have an id of 1. I think a better implementation would do a find with an order by ascending id and limit the query to a single item.
Exposing PojoProperties (an internal class) to API
Recycling a digest to which we still have references (namely in the member variabledigest) is bound to give problems at some point: another thread may obtain it by means of HashType.get() while we are still using it! If you insist on recycling digests, I guess this could be done in the finalizer of Hash. Note that the semantics of finally don't have anything to do with finalizers!
Let's add the partitions parameter to the message as well and verify the expected partitions are revoked.
Is this an outdated debug statement? If not, maybe add a similar line to onPartitionsRevoked() ?
I would suggest to use a mock Subscriber here. Then the test should just verify onCompleted() is never called. Also you may want to test the behaviour for onNext() and onError()
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
suggestion this.className = requireNonNull(className);
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
This should be called addName(String name) since it's mutative. Also you can achieve this with a single names.add(name) call.
They are mutually exclusive? Or is that a micro optimization?
Qualify this.uri
change to List
change to interface List
Perhaps nameToDataType.
shouldn't provider be validated for existence prior to accessing it?
Please add can-do-actions for provider existence in addition to AddNetworkCommand validations
Shall we have a "fallback" to use the vmName in case the FQDN is empty? what are your thoughts around this?
Speaking of sanity checks, is this: (100 - lastVerified) + 1 OR 100 - (lastVerified + 1)? I assume the latter, although I'm never certain on how it determines this - so maybe bracket it?
What is difference this w/ getLastOfflineTime?
nit: Please include e
Can we also have a test for LUCENE -> NATIVE -> LUCENE
should repo be set here to null as well?
Should we set a boolean like: boolean successfullyProcessed = updateAgencies(); successfullyProcessed &= updateProposals(); successfullyProcessed &= updateAwards(); return successfullyProcessed;
If the o1 is diff than null, o1 must equals o2. If the o1 is null, return "o2 is _diff than_ null" ? I think this second part is wrong?
Should be "else if (o2 == null)" only, shouldn't it?
I think the correct translation for "null" is null, not a blank string
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
I could not understand why is this mock doThrow needed. Are you sure it's needed?
why you get here a list of of event types? I think it would be more straightforward if you get a single event type, then it will be possible to use something like .andExpect(jsonPath("$.options.retention_time", equalTo(150))) instead of StringContains matching
Please considert moving this to line 238, and change this to positive condition
formatter?
why do we want to restrict it? the error messsage is relatively harmless and doesn't really alter the flow
Is this System.out required?
if you would put that into a helper method, the code would become clearer. I had to read it two times to see what is to be returned
Should we wrap this if-condition block inside <code> if ( ! noMediaFile.exists() ) </code>
This method should return RemoteCache<K, V>
This method should return RemoteCache<K, V>.
The RemoteCache interface has a getRemoteCacheManager(). However, this method currently returns a RemoteCacheManager (ugh...). I've opened <LINK_0> to rectify this. Once this is in place, we'll need the getCache() methods to return a ManagedRemoteCache decorator whose getRemoteCacheContainer() method returns this instance.
I would have this return an Optional<String>, and make the caller responsible for throwing an exception. Seems odd to have lambda exception being thrown from a method that parses a string.
could use matcher.matches here I believe
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
What's the reason behind this change? changeListeners and pools are also GuardedBy this, and this change removes the synchronization on them.
I'd need to check, but this might fail in when poolId is null or empty. If so we need to wrap this (and other lookups in similar methods) in a null or empty check.
check null?
Make it final static
Ordering does provide nice abstraction, but you could use ComparisonChain for a similar effect. Or, Java 8 now has a thenComparing() method, so you could also do: return SegmentComparators.INTERVAL_START_COMPARATOR .thenComparing(SegmentComparators.INTERVAL_END_COMPARATOR) .compare(this, arg0);
NullPointException for getUrl
nit: we could extract this into it own method or extract the message in a constant to avoid duplicating it bellow.
It might be worth mentioning that if there is a partition-level failure, then the first one is returned.
This can be "package-private", i.e. no access modifier.
why not just repo?
This method should be private in visibility.
@since 9.3 originSystemProps.put(key, System.setProperty(key, newValue));
Why are we using Math.min/max() here but not above in unionBlock()?
I wonder whether the upper bounds should rather be: x < this.maxX and y < this.maxY as current this is inconsistent with the int version of this method, yielding for exact integer coordinates false with the int version and true for the float version (for exactly float-representable integers).
I guess we can't use the Joml-object to do the calculation due to the "Max + 1"-circumstance. But what's the rational behind not using Math.min()/max()? Is it supposed to be faster not to have the function call? This implementation surely is more error-prone.
Why not just return the condtional?
Yes, I'll use a regex
Will always start by "file", so you can directly return true
this method still only supports one layer of children.
inverting the if-condition allows an early return and thus saves a level of indentation
seems like this could benefit from using your new flattened method (once moved elsewhere like I suggested) eg. for (plan : plans) { found = flatten(plan).findAny(p -> id.equals(p.getId())); if (found.isPresent()) {return found.get();} }
this is always true because you've set it to null in the line above. What was this intended to do / check for?
I think throws Exception can be removed
This is a breaking change.
Doesn't the remove() function return you the UpdateHandler which you want to call onCompleted() on?
Might be nice to inform people that the update handler will be removed entirely, so that they know that they cant expect any further updates after this.
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
onAdLeftApplication() callback is missing for Interstitial Ads. Please use [this](<LINK_0> existing adapter for implementation.
I'd rather AsyncTask holds a WeakReference to mLogTV instead of accessing mLogTV itself. Check <LINK_0> . I don't really understand why Google uses WeakReference in some examples, but not in others.... The method dismissLoadingDialog() should be called only when WeakReference.get() is not null.
I really hope that adInterstitial here is NonNull. It'd be silly to crash with a null pointer exception just because adInterstitial.toString() null pointed. Or even better, don't have the toString() and it will print "null" if it actually was null.
It would be better to move this line to _ensureUserIsWorkspaceOwner_ method because it is part of it. You can name it as _ensureUserIsWorkspaceOwnerByName_
ThisSTACK_ID code looks overweight. Maybe we can remove it at all? @sleshchenko @mshaposhnik @metlos wdyt?
If it is clearer then method name clear looks more natural for me than remove
introducing double retrieval from thread local, unnecessary perf hit
You already get the data once, processSpanContext.getData("scope"). You can save this in a local variable so you don't make the call twice.
IMO, this method should be removed, no need to have a getter in a builder pattern
This is vulnerable to a race condition, since a mutation could sneak between the flush() and closed.set(true)
@Override would be better on a separate line.
Not ImageJ style.
I would just make 2 calculateHrefs, one that takes Tab and one that takes GroupedTabData. Or convert the GroupedTabData into a Tab somehow. Passing in Object seems wrong.
please extract this magic number to a named constant
refreshJob field should also be set to null on dispose.
Wouldn't Assert.hasText() be more appropriate?
maybe this is a small piece of code, but to be more clear can you be more clear with the name of **_r_** variable ?
Isn't this going to throw even if one of the ids is bad? Do you want to change that to continue processing valid blob ids?
please use org.ovirt.engine.core.common.utils.ToStringBuilder
why not print the attributes as well?
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
ResourceSet<E> is correct and stricter than ResourceSet<?>
add the instance size/object overhead of MergingPageOutput
Would it make sense to have a method that returns an Iterable<Block> so that for-each loops work?
Style-nit: no brackets around single-line blocks
Why does this method use contextId as a key for serverEvalIdToCtx whose key is an evaluator id?
shouldnt this method be static?
I don't think this is correct. This looks like you are trying to use either class or style. It is entirely possible to have both. The style always takes precedent over the class.
The title should be HTML escaped here if it's going into an HTML constant (which is presumed safe)
please use BrowserEvents.CLICK instead of string
return tags;
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
- log warning that option is not supported by SNMP
This isn't a Messaging component and from other side using this one within a Messaging component, raising a MessagingException from here, we prevent re-throwing a correct MessagingException with failedMessage context. So, for me simple RuntimeException is enough in this context. WDYT?
Who does the datatype conversion from Hive to Phoenix?
Typo: a**c**quire Also, shouldn't we iterate in this method until we don't obtain the lock in DB? Or do you mean that TX guaranties the blocking wait for us?
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
This doesn't need to be prefixed.
Same here: should be Branding, not ProductBranding
somewhat confused, if you've specified serviceName you can no longer specify sid meaning that you get screwed over here whenever you call namespace i.e. you go from having a namespace to *not* having a namespace. What are the implications of this in atlas? If anything it feels like getConnectionDataString should return the service name if it is specified, otherwise it returns the sid and that sid is *always* provided OR that if you specify serviceName, then you *need* to specify namespace explicitly when migrating over. Let's chat about this face to face.
Yes, we need to ensure they are unique. But this is only possible if we introduce the technical id you mentioned earlier. From my point of view the uniqueness is given by the context and the internal id. Maybe we even need a more complex search suggestion implementation to differentiate better.
Namespace should never be null, please check for it, via Objects.requireNonNull(namespace)
Raw type here, generic in the base
Any constraint on the range of lambda? The formula calculating weights breaks down in some cases.
Please add final for exception, and rename e to ex
I think you can plug in the User directly as a method argument. @MatthijsKok figured this out somewhere. Maybe we can even make it a Class field as every method in this Controller needs the User object.
return authentication.getUser(username);
so this could overwrite the tenant set in forcurrentuser? isn't this wrong as the tenant should be the tenant of the user to log for?
Is there a reason for this to be protected?
make this private and move it after public constructor
(int) -> toIntExact (from Math)
Not necessary.
This should be the check class.
You can remove one of these two lines.
Can combine the 2 above lines and use the constructor which accepts disk-id
this should not be a member. A function at most (as it is computed from the value of another member) or just inline it
why not call this(parameters, loadDiskById((Guid) getParameters().getEntityId())?
seems false is also a valid response.
I think the current behavior is that if captionColumn is not defined, we fall back first to name, then to finally to key.
Choosing method names that deviate from the Java Bean naming conventions causes problems for the Orika mapping framework's default mapping strategies. For a field named actionValueObjectResponseDtoList the getter ehould be getActionValueObjectResponseDtoList() (or a field actionValueObjectResponseDtos with getter getActionValueObjectResponseDtos()).
Same thing as above, let's split out a config for this.
The getter is also intended to return a "Boolean" reference, so someone can test for null to check, if the default is intended to be used. You may check leshan builders to see, how it is intended to work.
suggestion return Framework.getService(FileManager.class).isUnicityEnabled();
The value is not assigned to json?
Should make this ObjectMapper instance static. For this method should use a writer(), for the deserialize case use a reader(). Does the mapper need any configuration to handle empty/null values?
ObjectMapper is a thread safe object. You can create a static instance and reuse it.
Minor: Use this. consistently in the class.
A side note: Is the planner class loadable from config? It would be good to consider that option in the long-run.
Not sure, why not use @NotNull?
Remove?
Immutable copy!
I guess this can be replaced by a public CommandImpl(String name, String commandLine, String type, Map<String, String> attributes) constructor call, what do you think?
Could you please add curly braces?
Minor: we can deduplicate the codes by generating the singleton list before switch.
Maybe you can use .putAll(map) method to simplify this code.
Looks like this will incorrectly log the requestExpiryTimeout for control actions. Can you update the log to use the expiry timeout computed from the previous line?
IMO, Request and Response object are short lived, so, feels like any gain we would have memory usage by creating a new request, we would loose on GC time for 2 objects.... If someone decides to keep the Response in memory for some reason, I think, they would like to have the whole Request. Lemme know your thoughts
"has expired" "{}. Re-requesting again"
I really don't like the user of instanceof. Why not overload the method to recive VDSExceptionBase? In both places this function is used, you already have that information.
it appears that this change can be reverted.
why this null check ?
In what way is this an improvement?
Why do we need to check again?
Looks odd to use buffer a couple of lines above and payload() here since both refer to the same thing.
But for this case, it will lose numbers under a decimal point.
Maybe try to wakeup the consumer before you try to interrupt it's thread? I would imagine that that would tend to deal with stopping more elegantly (in terms of the kafka client side, not your code). In fact, I think you could probably do without the shutdownNow altogether. Edit: well, okay, the shutdownNow is clearly necessary in case we're waiting for topics or something like that
Although correct - this looks a little confusing - using the passed-in time unit, but converting to millis. The timeunit is only ever used outside of here for the initial delay. Suggest moving the TU to setInitialDelay, or remove it altogether and just work with Millis.
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
you introduced dependency between WebClient and RestTemplate - why? do they really depend on each other? making this method public means it becomes part of a contract and can't be changed. as Go proverb says: "A little copying is better than a little dependency."
In the situation, when the session never gets reestablished, handleNewSession will not get invoked. So, handleStateChanged with state EXPIRY needs to be handled.
IDEA shows a warning for this line that it can be simplified.
nit, it could be simpler to be: _zkClientPathMonitorMap.values().stream().foreach(...);
wait.forElementClickable() should be used before
public PostsListPage and return this for chaining purpose
add wait condition for shell
return SUPPORTED_SERDES.contains(serdeName);
This can be replaced with  java return newName.isEmpty();
How about narrowing it to ClassNotFoundException and fail with other exceptions?
add wait condition for shell
This can be a class variable instead, using the @FindBy annotation; especially since this same element is used in another method.
The login/logout test fails for me at this step when I'm testing on a smaller device (I used a Pixel). The test isn't scrolling to the logout button, so it fails because the button isn't on screen. It looks like something like this should fix it: logoutButton.perform(scrollTo(), click());
I'm not sure why this variable is needed here. Could be: java public static String getAttributeValueFromString(String string) { if (string.length() > 0) { return string; } return null; }  This functions also will fail if string == null. Should be something like this: java if (string == null || string.length() > 0) { return null; }
I would move this to a constant so we can access it from tests as well.
use constant for UTF-8
convert to private constructor and a static create method
convert to private constructor and a static create method
This method is only used in the scope of this class, so you don't need a public setter for it. You can use the private field directly.
should either read: "Must set either both SslSocketFactory and TrustManager, or neither" or "Must set either both sslSocketFactory and trustManager, or neither"
You need to also reject if keyStorePassword is present but keyStorePath is not
doesn't this NPE when type=http and no host is specified?
I think that checking tree.expression().is(Kind.PARENTHESISED_EXPRESSION) is kind of redundant here. I would remove this condition and adapt checkParenthesisedExpression accordingly (and then rename checkParenthesisedExpression).
I don't understand why next. Rename to constructorName or prototypeName?
@m-g-sonar I would move isMethodInvocation(tree.body()) inside isUsingLambdaParamAsArg method because right now the cast to MethodInvocationTree happens inside isUsingLambdaParamAsArg which makes the rule a little unclear.
This looks like testDataFormat(COMPONENT); Please see other tests for sample
Maybe pull this into a static method that pgm.Archive can invoke without having a BundleContext. Then we don't need to maintain this list in two places.
we might here just get rid of the String result declaration and combine these two lines into return percentFormat.format(value);
Looks like you are making double slashes here...
this is confusing, it is called router but actually it is routerUrl.
Should have a period on the end of the string for consistency.
Similarly, would be nice to log the class name of the input stream.
off should be p here, and since len isn't adjusted during the loop this should be len - n. This sort of bug is often why I just modify the arguments even though this is against the JGit warning policy in Eclipse. Whoever enabled that warning in our project settings is a bit too paranoid and in many functions trying to follow it actively hurts the readability of the code.
It's redundant to check delegate.isNull(), because delegate.getFloat() should care of that itself. Compare with NullableAggregator.getFloat().
Why Level.CONFIG?
Should this be in the try? For consistency, have the LOGGER messages in the same place for the start and stop functions.
-1 as it might highlight configuration issues. On the other hand, it could make sense to make this one-time-only log message (e.g. static boolean sspiUnavailable in SSPIClient class
Shouldn't jobName and jobId be always available? Would prefer to throw if not instead of defaulting to arbitrary values.
possible exception
This doesn't work since it's for naming and the alias (full project name) is not likely to pass validation when used for naming
suggestion return Arrays.toString(value);
It's better to introduce a new variable to complex stream operation and use string format for a final message
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Instead of introducing a new ITranslationUnitProvider interface, it's simpler to get the editor's input and check if it is an instance of ITranslationUnitEditorInput.
same as previous: compile error
We could just return true here and let auto-boxing take care of the conversion.
I don't quite understand why you verify something here and in all cases in this class when we expect a exception. Execution of this test will never reach to this line.
Better to use the same name for both: "sluggedName" or "uriName"
Consider provide a forward compatile interface public void setTag(@NonNull Object tag). Because Extensions is not releasing with Core. The change will break previous version of Extensions even it's restricted to LIBRARY_GROUP.
filters method argument should be passed to isMessageInLogFile as an argument
@vzool one more printStackTrace ?
This should probably fail the test, no?
thanks to AssertionsUtil.expectAssertionError, this can be written in a better way, see Objects_assertHasAllNullFieldsOrPropertiesExcept_Test as an example (you will have to rebase your branch on origin/master): java import static org.assertj.core.util.AssertionsUtil.expectAssertionError; @Test void should_fail_if_one_field_or_property_is_set_even_if_another_is_ignored() { // GIVEN Jedi jedi = new Jedi("Kenobi", "blue"); // WHEN expectAssertionError(() -> objects.assertHasAllNullFieldsOrPropertiesExcept(someInfo(), jedi, "name")); // THEN verify(failures).failure(INFO, shouldHaveAllNullFields(jedi, list("lightSaberColor"), list("name"))); }
refactor the test with AssertionUtil.expectAssertionError as in <LINK_0> Could you also do that for other should_fail... tests ?
extract actual.getModifiers() to a local variable.
println should be changed to a logging message
Please use constants defined here: <LINK_4>
This can be replaced with  java return newName.isEmpty();
To follow Spring Security conventions, please change Raw password to match the variable name of rawPassword.
It is best practice to use editor.apply() as commit() should not be called from the UI thread.
Are we still using a bcrypt salt anywhere? If not, for this PR or a fast-follow, we can clean up the configuration that was intended to inject a salt: - <LINK_0> - <LINK_2> - <LINK_3> - <LINK_1>
Do we wanna return ImmutableList.of(address) or this is intensionally?
else is redundant
Maybe constant will be suitable there?
Encapsulation
why this is changed?
I'm gonna be picky, but could you extract a method to compute the separator and have a single place where we call getConcatedTypeNameValues ?
The synchronized can be removed.
The methods to add or remove a listener are usually thread-safe in Smack. This is not the case here.
@szczepiq Is this really needed? [MockingProgressImpl.mockingStarted()](<LINK_0> filters already for MockCreationListener.
Should use the Value constructor that takes String
Re-use temp file
Not sure this is right unless it's only supposed to work on *nix.
Map<TableScanNode, Void> result = new IdentityHashMap<>();
again I think you can use the diamond operator
again I think you can use the diamond operator
It'd probably be worth logging if is an invalid value rather than silently ignoring the input value.
That would still log a warning, which should not happen. Also if the prop is not set, I think we should keep it this way.
In what scenarios is this actually possible ?
> I'd prefer to have a consistent behaviour, and to modify it everywhere if we feel the need. I totally agree with you. Note that I'm not against the current version (i.e. it's not a blocker for this pull request), I'm just wondering if we should also include (or replace with) the date or not.
I don't see the point for a wiki page, if the wiki page did not changed then why could we need to invalidate the cache ?
please change Preconditions to static import.
Extract this into a method, given that it's called twice
@ivanarrizabalaga why do you extract this bit of code into a method? Is it not better to leave it as it was before the fork?
Are both of these lines required? I'd have expected we'd only need the attachBaseContext
it looks like far more deeper in the stack from where it should be - let's say that we got an event with a latter time than another one we already processed, when the code is done here it means we'll process it and will just not save it to the DB. I think it should be much higher in the stack - maybe even not to call the perform method in this class if the fetched stats are the latest
This is a very costly operation finding the event size every time, can't we do any other optimizations
why synchonize?
question: have you found a benefit to using throw-away anonymous instances of things like Runnable preferable to either A) creating a single instance as a member variable and passing that instance to .post, or B) implementing Runnable and passing bare instances e.g., .post( new RenderTaskPostExecuteRunnable() ); i'm not saying it has to be one way or another, or even different than what you've done - just asking your opinion. i personally believe it to be most efficient (in this case) to use alternative A - define the Runnable once as a member variable of TileCanvasViewGroup and pass that to Handler.post each time, but am definitely open to other ways if there's a reason to. @peterLaurence feel free to weigh in here too
please remove this. on this line and the next
when a condition just determines a value (rather than an "action" - think: method), i think ternary is appropriate:  int buffer = shouldRender ? TileCanvasViewGroup.FAST_RENDER_BUFFER : TileCanvasViewGroup.DEFAULT_RENDER_BUFFER; mTileCanvasViewGroup.setRenderBuffer( buffer );
lambda?
Should be dispatched from UI thread, TimeGraphViewTest:304 is also wrong.
Do we actually call init multiple times on a trace or is it a safe-guard? Just curious.
remove(Object)
remove(int)
remove
Change to: > Unsupported DMN asset
else if
I guess we can add one more constructor to pass expression only
this. maxRetries = Math.min(5, maxRetries);
Could this method, and setPurgeTimeout, be package-private? Still testable, and reduces risk of misuse.
Why maxSize + 1?
maybe some kind of separator would be nice here?
no need to extract this out to private method if it's only being used here. same for onClusterRemoved
This isn't needed. Actually I think that one constructor is enough, put everything here: super(ClusterFeature.class, ...); this.clusterId = clusterId; Also consider using Guid instead of String for the type of the "clusterId" field. The caller of this constructor will probably have converted it already.
Change this variable declaration to something with meaning in the context. map is unclear here
addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshotName()); return super.getCustomValues();
Can this call Client.getMetadata rather than require a separate method to retrieve MetadataState?
Can use constant for "4". More importantly: if the blob is not already encrypted, the config flag "requireEncryption" is true, and cryptoService is null, upload should be skipped. (You'll see some of this logic when you merge with master.)
Should handle -1 return value. ReadableByteChannel could return -1 if the end of stream was reached early for some reason
if(deleteMsg == messageInfo.isDeleted())?
warn seems too relaxing for this kind of exception. maybe error?
It should throw exception
As a nit, should have a null guard here.
I recommend using Collections.emptyMap() instead
Nit: make (ns != null ? (ns + ":") : "") to be a local variable, say, "prefix" for better readability?
Bug, you're setting description instead of summary.
change to IAdaptable
Lines 1068-1088 are redundant.
perhaps it is better to check selection.isEmpty() first before continuing to other checks and also eliminating the need for null checks.
FYI, magic number 2 can be replaced by constant ComponentContainer.COMPONENTS_IN_EMPTY_COMPONENT_CONTAINER
this method should not be public, otherwise doesn't make sense the arguments for the flush(ClientSession, String) method, as each session (editor) will have a different associated FormsContainer instance, which could not be the one set in setCurrentContainer... Can you please change it to package protected access (so no access modifier set)? Does it work/make sense for you?
not needed, can't happen (don't trust your IDE on this one ;))
can you refactor that in a test utility class?
For each?
For loop?
why null check here? ... oh, it's because super.setSelection() takes a @NonNull. Just declare list as @NonNull instead. Then suppress the warning, because we know that Collections.singletonList() returns a nonnull, even though the compiler doesn't. (This looks uglier, but it's the better long-term solution.)
For an experiment, the parameter trace is the experiment. However, later on when handling the traceClosed signal the traces of the experiment are used to remove from fTraceSSMap.
fTreeViewerReference can be null
The same is here regarding Double.MAX_VALUE. Or have I missed anything ?
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
Please keep this.cell near the related fields (previousFamily & cell count) below
Good one! :)
Seems we aren't testing Scattered then?
Seems this can be simplified to just call super.clusterConfig and then invoke jmxStatistics.enable().
Is this supposed to be <code>return "Bump"</code>?
use keyword "this" in these methods before member names.
Is replacing separators enough? We should look into something that will work for any special characters.
Was this intentional?
The method RassStringToJavaShortDateTimeAdapter.parseToDateTime() is already returning a DateTime, so extracting its Date value and re-wrapping it in a new DateTime seems redundant.
invokeExact is @PolymorphicSignature, thus can return primitives directly. If you change (Long) to (long), you will be able to avoid boxing, and you will be able to use the more efficient invokeExact.  return (long) getLocalMillis.invokeExact(localDateTime);
could we refactor the above into a setUp() method and not having to repeat for each test
Throw the entire stack trace in the log and not just the message.
You should not add the type in between <>. Static analysis will complain.
This will create 0 connections. Didn't you mean < ?
no need to specify type on RHS
I don't think the poolId check is needed, if it is needed we need to verify that first and throw if it's null..if its null we dont check anything here.
Please check if this method really should be public in a private static final class. The parent method is protected.
Here group.getSelectedVersionGroup() is not checked for null, though in other cases the check is used.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
I would change the 'by ourselves' into 'synchronously'
Could you use one check of CoreUtil.isNullOrEmpty() here?
Variable name choice is confusing because it shadows the field key
No necessary. + operator with a string operand (the prefix) performs auto-stringification of the other operand.
You should pass here message not group converted to string.
Would be safer to do something like this.groups = Collections.unmodifiableList(group) otherwise anyone can modify the actual path trough getGroup() which is not great for a public API.
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
contains(null) case?
Is this needed?
these setters should not be public
Oh! No! You have just introduced this setter :innocent: Why don't make it just public and avoid that MutableCorrelationData and just have the if (this.correlationData != null) { in the CorrelationMessagePostProcessor? Although that may be just my tired mind to be so nit-pick...
We can add a checkNotNull here.
I added method in Utils for that
Since the data set is the same for JobRecoveryTest (and because it is interesting to always test both JobRecoveryTest and NodeRecoveryTest on the same data set), maybe we could share this data set through a dedicated class, for example RecoveryDataSet?
It is not necessary to test REPLICATE region in this test.
this method should be defined in Menu interface
This part can be made less verbose. Method names can be shortened (customPanelDetails?). If needed, you can also give names to intermediate values.
Since SWTBot APIs are generally wrapping SWT controls and usually not exposing them in the signatures, it seems to me that this method would rather be a private or a protected one rather than an API.
OK to return the empty set - the JavaValue is a value, thus no variables inside.
Minor: Collections.emptyMap();
Should this be implemented?
Is this line here on purpose? It doesn't seem to make much sense as the action is not relative to the currently selected entry.
reuse method I proposed to introduce above
The problem with this.... While it is quite ugly to just create a new thread when you create this, but the loading will start immediately. Now instead the loading is governed by the framerate. Well, not really that big of an issue. But what if you load the app minimized or alt tab away. Loading basically never starts because it waits for the screen to draw.
"%s/_job.%s.%s.log" is used in all the cancel methods. Should we make it a constant for ? It will be good to create getLogFilePath(workingDir, execId, getId) as it is common as well ?
Maybe deleteLogFiles could take a long parameter? This could avoid the need to downcast without reason.
Update the toString to include ledgerIdAssigned?
Maybe this whole if statement could be simplified a little
This will throw a NullPointerException when state is null. Reverse the equals checks to prevent this. if (STATE_ERROR.equals(state) || STATE_FAILURE.equals(state) || STATE_PENDING.equals(state) || STATE_SUCCESS(state))
You dont need to persist sessionGap and allowedLatency as they are input parameters
why this.writeLock().unlock() is not enough?
suggestion ReentrantLock getLock() {
This check feels a little weird for a few reasons. It behaves like a factory (in that it returns new instances) but sLock is not assigned here. It also initializes a static field from an instance method and that feels strange. I suspect that if the lock is not being acquired in one method and released in another, and there aren't any waits involved a more primitive synchronization technique may be sufficient (such as a synchronized method or block, without the use of a ReentrantLock) -- I'll leave this up to your judgement but this looks dodgy
I hope you do not kill me, but as this is infra component it is good to know the practices... you should not allow caller to modify collection. return Collections.unmodifiableList(errors);
can be java public Seq<E> getErrors()
Please add a check Objects.requireNonNull(supplier, "supplier is null");
Aside: I'm assuming this was generated. What IDE are you using? Most of them should be able to generated Java 7-style equals that use java.util.Objects.equals(Object, Object) to avoid these null checks.
since you are changing this, I would use:  return addressNum == that.addressNum && Objects.equals(name, that.name);
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
Gson doesn't run on these versions so I don't see any reason to include them.
maybe move the various implementations to use a static EnumSet field and EnumSet.contains?
You can change the 28 case to a default case, and remove this.
Use fluent interface in here
Could consider adding logging after the assert.
I think we can make this private
Why do we return the parents name instead of the name we store a few lines above?
possible exception
This would be safer if rewrite it in the following style: java return getMetadata() == null ? null : getMetadata().getName();
Let's change it to get the child commands CommandEntity rather then the CommandBase, it's slimmer (doesn't require to build all the command objects) and contains all the data you use in the calling class.
Add final keyword.
Use MultiValueMapUtils
While you're at it, fix the initialization here, same way as you did with the singleton for Device Custom Properties.
I would prefer static initialization, and not using this double check. You can getInstance() for the first time at InitBackendServiceOnStartup bean.
Can be simplified using Hamcrest.
And here. needs some validation.
Same here, but check the max cook time instead.
checkNotNull(value, "value")
Let's inline this: return doGetInputFieldsForPMMLStream(modelInfo.getPmml());
empty output
Instead of adding this injected ctor here, I would add a new class that extends ImportNetworksModel and has this ctor. So the base class will have the general ctor and the children will have the injected ones with the explicit model type. The way it is implemented now is a bit confusing.
we should probably Assert.notNull here to ensure that a simple toString call would never end up with a NPE
Likewise here, make sure you include the default arg of "".
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
n["+fTimeArray.length+"]("+min()+'\u2025'+max()+')';
This will fail if link.isPresent() is false.
Your best friend Joda has already solved that for you:  java final Duration duration = new Duration(DateTime.now(), DateTime.now().minusDays(1)); return duration.toStandardDays().getDays();
please use try with resources as in ConfigurationHolder
Can be simplified using Hamcrest.
Maybe it would be useful to change level to info. It would be hard to debug this configuration running on CI server.
suggestion if (keyedStateBackend instanceof CheckpointListener) {  Since the instanceof operator always returns false for null, there is no need to have an additional null check.
What happens if a checkpoint fails? Wouldn't cancelAfterCheckpointId <= checkpointId be more safe?
It's correct but it might be easier to do  cancelledId > currentCheckpointId || (currentCheckpointId == cancelledId && numBarriersReceived > 0)  So either it's a future checkpoint, or it's the current checkpoint and not yet canceled.
since "acceptedType" is of type list i would suggest to rename it to "acceptedTypes"
It seems like it would be better to only iterate over a sublist that excludes that first item (which is the commandType). Saying a parameter is okay if it is equal "commandType" would allow someone to do this following command: "INFO INFO INFO" and it would not care about the extra INFO parameters because they match the commandType.
What's happened to the -k flag?
write nullable on the same line or don't write it
All the way man!
switch/case here too It's not just for the sake of it ;) But for example, if we ever add new types of ITmfStateValues (which we've done before), we would then get warnings here asking us to handle them, which is exactly what we want.
style nit: we don't use braces around single line blocks
We should still warn that setVisible is not implemented, since setting the value doesn't actually have any effect (just like setFocus).
Since we're now using bus events, do we need this anymore? (The whole idea was to send events to individual cards, and avoid having to rebuild the whole view hierarchy of the RecyclerView.)
You may want to make the default smaller - like 0.01.
Stopping
throws InterruptedException not needed
can use Ds3DocSpecEmptyImpl here
Is this for debugging?
You can use an instance of spring's MockHttpServletRequest here
allExtensions instead of getLoadedExtensions()
style nit: we don't use curly braces around single line blocks
0 is magical number
Iterables.all(toolGroup.getTools(), Predicates.instanceof( AbstractToolDescription.class)); allow to return false if all items are not of type AbstractToolDescription
We can slightly simplify: java return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
StringUtils.hasText(name) && StringUtils.hasText(groupType) ?
move 0 to private constant as you use it in many lines, it will be easier to change it in the future if needed
Add Pagelogging
Perhaps a good practice is that the driver is switching back to the defaultContent to reset the driver's state. That way, the next method that is being called after this method does not need to know anything about this method.
better to set it to the default and log a warning
using a toString() is probably better than building a string
suggestion if (null == connectTimeout) {
throws TaskException is part of the interface, did you mean to remove it?
I'm not a very big fan of HashMap and HashSet, as you have no guarantee regarding the order of the elements in them. Is there a particular reason to be using this instead of LinkedHashMap? If there is no particular reason, then would you mind replacing this here and below (I've seen a few other places in the changed code that uses HashMap and HashSet). If I'm missing the reason, could you please elaborate?
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
Not sure if it matter much, but the 'better' way of getting an empty list is: return Collections.emptyList(); In this case however we need to specify the type: return Collections.<CertificateInfo>emptyList(); As the compiler cannot infer the proper return type.
if you write new code please use java formatting
This converter does not have any effect
You can drop these from the throws clause. Not only are they not thrown, but they are RuntimeExceptions.
This should be the other way around, the default should be the new method which would call the old method (older implementations wouldn't have the new method).
Instead of new MakeBucketArgs().builder(), this should look like MakeBucketArgs.builder()
Can we avoid the switch as its not common practice and maybe people dont know about how it works and would think that remove and put does nothing in this example etc. Make the code understandable and maintainable for everyone.
nit, don't need to be public.
1. "not implement" -> "does not implement" 2. Maybe we can extend the exception message with "Illegal use of @Publish interface" or even more specific descrption, so that the stacktrace very clearly defines what the problem is.
Same here, what's the purpose of getRoot()?
Maybe we should limit it to the attribution window value (since its changeable) and not just 1 day?
You're missing 64 here. <= would be better.
formatting
should not be this private?
You could just call the other ctor
This is an expensive call. Is it really necessary? Maybe we can get the session ID cheaper by a direct call to zooKeeper.getZooKeeper() - (checking for nulls)
instead of an early assignment which might be overridden in line 2355, it can be set as the 'else' part of the if statement below (line 2356).
I agree that my proposal was awkward phrasing...I like your proposal better than mine.
I don't like it. For me it should be very simple:  return "ExpressionEvaluatingSelector for: [" + this.expressionString + "]";  The compiler optimizes it to the StringBuilder
Then this one could become java return ImOption.apply((Focus) getValue()).map(f -> f.getStringValue()).getOrNull();
I am wondering if we should add the author and text to toString method in the case where we log a sensitive data I mean. what each person says :)
nit: now that we are passing in the processingMode, we could potentially use this check as a helper function as:  private boolean0 eosEnabled() { processingMode == EXACTLY_ONCE_ALPHA || processingMode == EXACTLY_ONCE_BETA; }
the type of pollTimeMs is *Duration*. It seems to me that the "ms" is a bit redundant.
It's not from the changes in this pull request, but to clean up a bit more, the superfluous super() call could be removed.
No need for second level of brackets.
This dependency currently [brings spring-cloud-stream](<LINK_1> and [spring-cloud-stream-reactive](<LINK_0> which makes that an effective super-set of Reactive Cloud Stream (with id reactive-cloud-stream). That boolean check looks incorrect to me unless I am missing something.
You can do criteria.add(Restrictions.eq("experiment.ndExperimentId", experimentId)) I think
Fix logging level here (error)
we just log, update metric and move ahead with next iteration?
Since you'll already be in this file, can you pull this out to a constant?
Same with the ( and )
This is very fragile, and will break when we add new storage type. Better check for the storage types (block or file?). Also, this change is possible only when creating volumes with vdsm supporting deferred preallocation, or it may cause very bad performance regression when creating big raw images. This is probably not the place to do these checks, we probably need to modify the code creating new volumes, or the code creating and copying volumes.
maybe consider putting this check into a method
M-m-m. Seems for me we don't have here in this application context any other listeners. Am I missing anything ?
What might be helpful is a new method in AbstractInput to check if the input is the current AJAX trigger. This could be useful for many input components that do this check....  /** * * @return true if this input is the current AJAX trigger */ public boolean isCurrentAjaxTrigger() { return AjaxHelper.isCurrentAjaxTrigger(this); }
I think the following would also fix the leak and will not call the removeAction twice in any code path java @Override public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) { synchronized (removeListenerActions) { if (destroyed) { callRemoveAction(removeAction); } else { removeListenerActions.put(registrationId, removeAction); } } }
should probably check the app name does not have any chars that are not allowed in a zookeeper node name
Just return commandName if collection is null. I'm not sure but don't expect the JVM to optimize the stringbuilder away for this pattern.
Should make a differentiation of the name and id.
This is not how you make an [unordered list](<LINK_0> in HTML. Example:  html <ul> <li>Coffee</li> <li>Milk</li> </ul>  produces - Coffee - Milk
Why the unparse SQL is different ?
The unparse SQL is different.
Need to pass the exception object.
Checkstyle violation:  [ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-integration/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpSession.java:157: 'if' construct must use '{}'s. [NeedBraces]  You can verify yourself locally using gradlew clean :spring-integration-ftp:check
It doesn't look to me that httpClientBuilder.insecure(true) can throw an Exception, is it not just setting boolean variables?
suggestion ReentrantLock getLock() {
mb, "lock1" -> "unfair lock" "lock2" -> "fair lock" here and there
Would this cause problems later on? Shall we define "UNKNOWN" for example?
Is there a constant you can use to replace the ".done" literal?
Since partitionedFileName is assigned in setup() there is no need to do it here; in fact, since these setters are typically called before the operator is serialized, physicalPartitionId will always be 0 here.
You may use FileUtils.contentEquals instead.
Style points as before. In this case the class has existing code in a certain style.
using cpuCost(...).memoryCost(...) is much easier to read
Squash it, for the same reason
Should we pass in MAX_VALUE to avoid introducing test flakyness?
nit: Intellij recommends using setProperty() instead of put(). I guess it's because the parameter type is more strict.
Ah, yeah, there are some limitations to the linter. Thanks for taking care of it.
can we use method reference here this::createHeathIndicatorForCircuitBreaker
you can use method reference eventConsumerRegister::registerEventConsumer for better readability
ArrayList is non thread safe. We should use a CopyOnWriteArrayList
I don't think you want to keep this print in here and the rethrow as a cause
I'd like to see our Throwables.throwingOnlyUnchecked used here
That would create a warning. The only safe way to do that is casting from the caller.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
shouldn't the last part be (getVm().getCustomCompatibilityVersion() == null && !newVersion.equals(getVm().getCompatibilityVersion())) ?
reusing the variable here seems a bit confusing to me. It's creating a new versionRange object so why not declare a new local variable "newVersionRange" ? this way you could clearly name it "(old/original)VersionRange" and "newVersionRange"
Would be better to use a listiterator's hasprevious and previous methods. This would also protect us from non-random access lists where retrieving the "last" element can be very costly.
Odd I would expect xml <files><file>a.txt</file><file>b.txt</file></files>  or similar.
This empty check can be removed if you add one element to values in the constructor.
Consider writing a header for backward/forward compatibility.
This method should call the other encode method, right?
Can we just do ByteBuffer.wrap(b, off, len) and save one more copy?
Readability is concern here, lets keep it as it is.
I was just suggesting if we could use a different data structure than the Context type here since the Context object is a linked list representation and if its populated enough could result the getData to get slower.
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
Is it required for the upgrade?
The getString() function itself lets you add parameters into it. You don't need to use String.format().
Just return commandName if collection is null. I'm not sure but don't expect the JVM to optimize the stringbuilder away for this pattern.
Same issue as above.
hmm, that method makes somewhat sense in core java, but I'm not sure I like that behavior for selendroid. We're expecting a boolean value, but essentially we only care about either true or "true" coming across... everything else is false. Is it going to be confusing to any users? I'd almost rather add an additional else clause to check for the string of "true" or "false", otherwise raise the exception. Since users of other programming languages (like javascript or python) may have a different impression of what a truthy value should be.
Boolean.parseBoolean
I believe the order is guaranteed in partitions by the sort order of Partition which is on the partition ID.
Please change this to  java return new ArrayList<>(failures);
Extract -> Extracts
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
It is still public. Why?
why are you removing the response, some of the thing we have figured out is that the request must be always coming together with the response, even if it is not used at this time, could be in the future
populate with meaningful data. Version should fit to artifacts versions automatically Licence: <LINK_0>
Should we/can we remove the terms of service link while we're in here? Or link to something that actually exists?
Inline?
unneeded throws Exception
since you have to rebase anyway, could you rename this to connectorRestApiClient
Can we name this in a way that makes the distinction with shouldSuccessfully_authoriseForAChargeRequiring3ds clearer? shouldAuthorise_whenRequires3dsAnd3dsAuthenticationSuccessful or something?
If the format is null then we need to check for the translation type first. Anything not a text translation type has a format of markdown. If the type is text then if the project id is obs the format is markdown, otherwise the format is usfm. We cannot completely depend on the resource type here because a REGULAR type can be either obs or a non-gateway language translation of a Bible project. > NOTE: In the android app we don't directly support translating to a ulb or udb resource type. However, the desktop app _does_ support this. Therefore android provides just enough support so we can import a translation from the desktop app without breaking.
Same here with length() == 0 -> isEmpty(). I'll stop mentioning for the rest of these :)
format should default to "tar.gz" is null or empty and not throw an exception.
Unless I'm missing something, testFinished(class) == testStarted(class) (either a test starts and finishes, or it never starts). Can we just have one method (perhaps named wasRun)?
How would I build a description that doesn't map to a Java class? Perhaps another public static method named forNamedDescription(String displayName)? (if you do this, I can understand if you decide that describing the defaults in the with methods no longer seems like a good idea)
use logger
This will destroy performance. We cannot allocate a new byte array with every short read. You could use an instance field buffer of sufficient size to avoid the issue.
Same: performance will tank. Need a small reusable byte[] as instance field. This should be OK, since these methods are already not thread-safe.
Check buffer null.
>byte[] [](start = 11, length = 6) DecryptResult
Sync clients cannot use withContext. You need to explicitly add a Context to the API args. Note that Context is supported only for APIs that return Response<T>.
s/operaiton/operation
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
why not compile once in field?
nit: was gonna point out this should stop matching the parameter value at # to avoid including the fragment value, but probably all the querystrings passed here wouldn't have fragments.
I think it's wrong. Maybe state when a.hashCode() != b.hashCode() but a.equals(b) is true.
I think it should be NegativeLocationFilter (like the class name), as there is another class called NegativeNodeLocationFilter
Shouldn't this be at line 134 ? Replacing .getClass() check instead of obj == null check ? Like in User object ? I know it will return false for null anyway, but this will also return false if you compare Member and RichMember which we wanted to be comparable. In User object you just continue with params comparison when you compare User and Candidate or RichUser. I believe implementation should be at least equivalent in both Member and User objects.
whitespace/style
Do these lines conform to our formatter? If not, we need to format. If so, we should update the formatter. This can make it difficult debugging the result of the condition because there's a chance the stack context gets lost immediately. You don't want the stack to immediately change in the debugger window when this == o evals to true, you'd want an extra frame to verify that flow without losing your stack.
I see that there is annotation @NotNull, but still, it is better to write something like  Objects.equals(this.type, that.type) && Objects.equals(this.path, that.path)  The same goes to hash code - Objects.hash(this.path)
Since this is a String, perhaps you could use Collections.nCopies
We should probably do this in a finally block.
The original commons-codec MurmurHash3.hash128 (like the Guava code) has a sign extension issue with the seed value. Since the seed is 104729 (for some reason) the hashes will work correctly. However a fair amount of work has gone into commons-codec recently and v 1.14 fixes the issue. Because of the change several of the MurmurHash3.hash128(x) methods have been deprecated. It is probably cleaner to call MurmurHash3.hash128x86( input, 0, input.length, MurmurHash3.DEFAULT_SEED) or MurmurHash3.hash128x86( input, 0, input.length, 104729L)
Since this class only works with Numbers, we should throw an exception instead of returning null.
Should we not assertOpen _before_ we readValue?
Maybe  { needsConversion = !value && value instanceof NodeReference; return value; }
this is not good, you've removed the information from the nested exception! :)
change
Hrmm... I understand why this was changed and what the issue was (ID generation is only done on persist), but this isn't correct either -- the implication is the default state is "queued," and we're creating by default; neither of which sits well with me. At the very least, we should move this down to the try block with all the message sending.
Could change the return type on method to Collection
We might use a NavigableSet instead if a TreeSet is used, I assume.
Collections.singletonList
Pay attention that most methods of this class return the null as String, but this method returns "null" as String.
@dalifreire is this enough? What e.g about class name?
Why can't you just return value here?
no checking flow when user sets grace period in the action
please verify response on remove()
no need to supply "dataCenter.name|id"
You could save a few lines by moving the return null into the default case instead of break.
Remove all "null" cases. There is a default case for that.
You can change the 28 case to a default case, and remove this.
This should never be null as DMR always returns something
why would we have a default case? what is the point in updating metrics for an "unknown" datanode?
suggestion if (treeNode.getDataObject() instanceof View  instanceof already checks against null
Probably it should just return false
I think it should be return true, as well as in sqlCompatible, because returning different in non-sqlCompatible and sqlCompatible in fact makes this method dependent on this config, that you mentioned during the previous round of review shouldn't be the case .
According to the current way how those methods are implemented, it should be return false
@yesamer Hard to demonstrate with few calls, but as general rule it has better performances (and I think readability) if - instead of invoking multiple times the same _getter_ - it is invoked just once storing the result inside a method variable (in this case I would call _getCurrentContext()_ once and store the result in a _context_ variable). As a side note - in this and the following cases, the number of lines to change (and detected as changed by git) would be much lesser, and so the overall impact.
@jomarko If it is possible to move all those "context.getScenarioGridPanel().setFocus(true);" inside commonExecution, then move this "verify(scenarioGridPanelMock).setFocus(true);" inside "commonExecution" Test
adding analysis_uuid column in the migration called "make ce task uuid column nullable" is not wise, imho at least, it is highly misleading
You might want to consider creating a ViewAction1<T> abstract class to contain the reference to the WeakReference<View> and avoid having a Field for the view in all your Action1 implementations?
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
Create a constant.
if you set this variable to null then calling twice this method will result in an ugly NullPointerException what about  try { if (txnLog != null) { txnLog.close(); } } finally { txnLog = null; }
Are our current http log files in UTC or CEST?
i might be wrong but I think you need a synchronized bit here so all threads will see the new reference. i need to come back to this part.
use ShellIsAvailable
use ShellIsAvailable(this)
use ShellIsAvailable(this)
dont think a setter type function should return the "this"
I'm not sure how anyone can create a class where isTTransport is true?
@dmzaytsev We should be able to inline user, alias, and inbox, since they are just one-use variables.
- please remove TODO - please use propper logging instead of using printStackTrace()
Should use the log, maybe a warning.
Log using a java.util.logging.Logger at the warning level and swallow. There's nothing sensible to be done on the way out.
This also seems kinda pointless and a bit brittle. Just return resource.
Declare this abstract or with a default implementation, then override in subclasses. VarDeclaration always contains a resource; ValDeclaration contains one depending on it's type; TypeDeclaration never contains a resource.
This should be private, as we don't want the resource attribute to be set externally.
not use this to reference class members
oh wait, can we put shutdownNow() to finally block? Even without that it should be executed but just in case in future, more Exception handling might be lined up or if ZK client close throws some runtime exception, at least we will perform shutdown of threadpool in finally.
We have thread executors. It is important it must use these. Also this solution uses up a thread permanently which goes agaisnt some of the thread modelling. Look maybe to use schedule thread executor
right; logically correct I would still add a public static String toFullId(ConnectorId id) or something likethis (this can call to string then on the instance given into the method)
Should be "InstaPost" actually.
Looks like this toString() got generated before the tags field was added :P
Please, don't reload the text in onResume(). Do it in onCreateView() or onActivityCreated(); onPause() and onResume() may be called when other windows partially hide the fragment (such as the menu showing apps to open the file outside of ownCloud) even though it stays visible.
Hi @rezita, I think this should be isSHREnabled
Do you actually do any heavy lifting here that needs to happen in the background? If so, why do we still do controller.init() in connectToPlaybackService() which definitely is executed on the UI thread?
before click, make sure element is clickable
I may be wrong, but it looks like these two methods you added before are no longer used?
We could change the first parameter passed to PageObjectLogging.log() from "wikiDiff" to "showChangesModal".
You could add a text here to show what the output means. You probably know, but me running this benchmark, I'd need something more verbose ;-)
adding an extra pair of around endTime - startTime would be nice for those of us who never memorized arithmetic operator precedence, like me :)
I would replace this by System.nanos() instead of doing a call to nanos. To prevent running out of inlinining budget.
org.apache.wicket.request.resource.ResourceReference#ResourceReference(java.lang.Class<?>, java.lang.String, java.util.Locale, java.lang.String, java.lang.String) cares about the non-null name. No need to check it here too.
How are splits handled? this should take split start and end into account?
Having a builder instead of a public constructor is usually better
assert.NotNull ?
Not sure, why not use @NotNull?
Should be a SamzaException with a message, not NPE.
can you wrap this with if (log.isTraceEnable)
Keep this check?
Looks like this field is never read.
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
we can make this more efficient if we first do something like: int startSura = pageSuraStart[page - 1]; then start the loop below from i = startSura instead of 0. also, once you hit a sura with the start page > page, break out of the loop.
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
should probably throw a NotSupportedException instead of returning null.
This can be done in functional style if you prefer: java return optional.map(Stream::of).orElseGet(Stream::empty);
return toStream(ele, eles).collect(Collector.toSet());
suggestion return new String[] { "^(?!private-encrypted-).*" };  I think the final - is a compulsory part of the prefix
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
notice that after previous alterations, this can be now easily rewritten using stream api to do filtering and applying method to all items. If you like it better, you can do this, not important.
will never be true, because of Objects.toString(null) == "null"
The 'modifiedInterfaces' contain just the existing nics with label changes. The list you should check is 'getNetworks()'.
We should just check for >= ICS instead?
I'm starting to question whether this is a good idea. Generally we shouldn't use it but I understand I left it in my previous PR. Will investigate.
As [mentioned](<LINK_0> in #408, this variable should be renamed to "args" to be more descriptive.
maybe same logic can be addressed in less lines by using Streams, it would also help to read this method faster... Eg: Streams.stream(groups).filter(...).map(...).collect(...)
This should be a singleton.
Strange name. Why not simply groupId? We generally don't use hungarian notation (putting type info into variable names). Same below.
I think isDisposed should also be checked here, right?
By default, it's enable, I didn't see you set it false. So, you can remove it.
Always enclose if (and other conditional) bodies in curly braces.
Shouldn't this be correlated to 'expectedClass'? Then an unchecked conversion wouldn't be needed.
this is unused.
ImmutableList.of()
why are you changing this line ?
ha! this is a new construct for me. I thought that.id is a private field ...?
Also needs to compare left and right?
config is a non-primitive object, cast to Map<String, String> here before serializing and adding into the map; similar to how containerModels are added above.
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
EmptyConfig.INSTANCE?
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
Why don't we handle that via the Filter? I dislike having a special treatment of certain stacktraces. I think it is OK to add them to the filter (with wildcards) but hard-coding them, seems wrong.
Please use blocks for control statement blocks, i.e., {}
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
Is a public setter necessary? Can the abstraction be the CentralRepositoryAccount instance itself, rather than the primitive?
[existsById(long id)](<LINK_0>
Collections.emptyList()
defensive copy?
constant?
We should leverage the appropriate org.wildfly.security.manager.WildFlySecurityManager method here.
commit.name()
This handler is at the application level. That means with multiple windows, you need to return the build action for that window and also add a window listener so that you can clear a window entry if that window closes.
This does not need to be changed.
subject.getUserName()?
Put this static method after instance methods.
Maybe legacy version of SetDigest can not be cast to HyperLogLog
What's the behavior when the input is not between the min/max values?
I did a bunch of investigation and had quite a discussion with @martint. We decide that crc32 will return a number (instead of binary). I'm sorry for the change. Please change accordingly. I looked into PHP, java (java.util.zip), Java (Guava), C++ Boost, Python (binascii), and Ruby (zlib). It turns out there is no general consensus on byte order for representation of the result.
requireNonNull?
This is redundant, you can just return cardinalityLimit without the null check.
couldn't this be: java if (getNumDataChunks() > 1) { notifyForFirstChunkCreation(); }
Not in prod, no way!
As you mentioned on chat, and also as I start to understand TaskValueDelegate now, the recurrence fields should be added here, too, to make sure they are not updated. Right?
Error should be logged as log.error("unable to initialize adapter + emailAdapter, e);
Could have @VisibleForTesting annotation. Also could public be removed?
Should properties be setable? Also what if properties argument is null?
Make it immutable. new HashMap<>(properties). Otherwise clients can still be able to mutate the state of WireRecord using the provided map reference.
How about adding a param to constructor for this?
Maybe you can just rename the member variable instructorId to id since there is no ambiguity in this class.
This is wrong. getUuid should return the uuid in the class. Since this one has none, you can just return the string version of its id
Not null, not empty, no blanks? There should be a pattern for a valid Java method name.
Why you will need substring() when Class.getSimpleName() would only return the class' own name without package? Please remove.
Can we reuse this logic from MethodArgumentsProvider somehow?
use new Guid(String) - this literal can't be null
use new Guid(String) - this literal can't be null
use new Guid(String) - this literal can't be null
If we modify this changeset, then we could give a try to using Optional here
Pls swap with setupAPI2, unless there it is required beforehand
Style-nit: Static methods should appear at the start of the class, before instance members.
It's better if you could make a function like getStringWithFormFieldId(String formFiledId). You could call the function getStringWithFormFieldId("clientID"); getStringWithFormFieldId(clientSecret);, ....
Be careful of nullable fields!
Be careful of nullable fields!
do we care to check the length to be positive here?
is length == 0 allowed? then it is expected to be "non-negative" not "positive"
In this case I'd prefer to see  java if (currentBufferPosition >= currentBuffer.length) { allocateNewBuffer(); }  This leaves the check in the main loop and puts only the allocation (i.e., the slow path) in a separate method. Of course you should validate in the allocate method that there is not remaining space and throw and exception if not.
2 nits: - this should use remoting's WebPreconditions so that we can toss a 400 at the user here, rather than the 500 the current implementation would give (in a sense it's the user's fault!) - because TableReference.createFromFullyQualifiedName() itself does a (normal) preconditions check, this should go _before_ the table reference is created
No need to convert from byte[] -> String and then later back to byte[].
I think we can write this as a stream java return Stream.of(partitionsTableHandler, propertiesTableHandler) .filter(handler -> handler.matches(tableName)) .map(handler -> handler.getSourceTableName(tableName)) .findAny();
Turn this into one or more helper methods. The simplest thing to do would be to have something that returns and List<String> or Iterable<String>. Then you could use standard Hamcrest matchers to assertThat the list does or does not contain the expected outputs. Alternatively, you could make higher level helpers such as assertSleepCount(expectedNumThrottles) and so on. Or even assertCount("Sleeping", 0) would be okay. But for more complex scenarios, you might need to check the order and count of messages. Your call on the specifics, just need something a little easier to read.
Name of var is misleading - it is a recipe that may contain a number of services.
won't this log bearer tokens?
Use same pattern as above?  if (... == null) { // do null case } // do non-null case  ?
[minor] maybe resourceGroupName?
You could use computeIfAbsent: java mavenGroups.computeIfAbsent(groupId, k -> new ArrayList<>()).add(bundle.getId()));
So does it work for ADMIN client port? If a client connects a node using admin port, then this client will try to connect to other nodes not using admin port. Right?
@vbradnitski the value can be NULL, will be better to use PRIVATE.name().equals(value) or Objects.equals(PRIVATE.name(), value). Also you can use ProjectReadAccessType.valueOf(...)
I don't think we should relax validation checks just because we trimmed it in one place.
Is reentrancy a problem? It looks like it would be possible.
shouldn't we add into names?
Btw, it seems that we are changing the behavior of RESOLVE_CANONICAL_BOOTSTRAP_SERVERS_ONLY as well, right? Before, we would only use the first DNS IP for that option in the non bootstrap path. It would be good to make that clear in the KIP.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
This whole check is fundamentally wrong. We should return all facilities for PERUNADMIN/PERUNOBSERVER and filter response only for FACILITYADMIN.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
Why do you use 3-argument constructor here?
magic numbers. Some explanation would be good.
Same here: before the codec was set previously to traffic shaping... Maybe this is the right place there ?
Super minor but no conditional needed here since properties is either null or non-null.
why are we doing a bean lookup here?
Without the access modifier this method will be visible inside the package but not by subclasses or classes outside the package. Is this what you want?
Why this change?
Why this change?
Why this change?
you can check the cache file exists (check line 147, which checks the output report), and you can check the output for the cache warning to not be present
consider renaming to "simpleParagraph", or "placeholder" The base class extends TestCase, which makes the annotation unnecessary. Consider going with annotations only and removing TestCase as a base class in the hierarchy. Also prefixing the method with "test" is somewhat redundant with the annotation present.
Enums have two kinds of properties (it may or may not be possible to distinguish between the two kinds in this pass, I'm not sure). The first kind is the properties declared in the enum's object literal. These are the enumerated values, and we should not allow nocollapse there (if possible). The second kind is the properties added after the enum declaration. This is when the enum is treated as a namespace, and we can allow nocollapse for these properties. Actually, John mentioned to me recently that maybe we should stop supporting enums as namespaces. So, if you can't distinguish between the two kinds of enum properties here, you can even disallow nocollapse on enum properties altogether.
newVmStatic ?
Is this really correct? ASCII characters would include all 128 defined ASCII characters, but the actual limits are smaller: <LINK_0> Perhaps this message should just spell out the requirements exactly: A letter or number, followed by letters, numbers, dashes, dots and underscores (underscores are not listed in the whitelist, but anything else is replaced by an underscore, making the underscore implicitly allowed). Maximum length is 63 characters.
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Source ids are supposed to be unique. CachingFederationStrategy doesn't really care, but it's not accurate to how the system is supposed to behave. I'd prefer to mock normal behavior by making these ids unique within the scope of each unit test.
"before lookup source provider provider"?
why? let's format it properly, it was ok before. annotations and method definitions on different lines
private static final int FIVE = 5
Feels a bit odd that we specify the average maximum but don't really control the actual maximum - I think we really want to control the maximum and have that be 30. You could either cap everything at 30s, or take 30s as the maximum, then calculate 2/3 of this and apply the +/-50% from this value.
@aklish what do we expect if both initializer and injector are defined?
Probably it's better to throw an exception here, like it's done in getName. The index config is not really defining the decorated index.
Is it an exceptional case for ConfigLoaderFactory to not be present here?
I couldn't understand the need to get templates config and set it back again, is this required?
Could you please throw TalendRuntimeException instead of RuntimeException.
My preference would be to remove e.printStackTrace() altogether and let the 'error' filters determine if they want to log the error.
We should be using standard format strings for this instead of rolling our own formatting.
If item is null, the code will enter here and we'll have a crash. The condition must be split in two; it item != null, all the code is done (including the if (sendEnabled) ... else ...) ; if it's null, do nothing
is this value hardcoded?
Instead of returning here based on course access, we should make setHasOptionsMenu() dependent on it like: setHasOptionsMenu(courseData.getCourse().getCoursewareAccess().hasAccess())
shouldn't this be an else if?
Fine to move the command, but since you try to refactor the code, this method should be private
space and pull back the }
Local variable not required. You can directly populate the class level variable this.servers
I would suggest naming this variable as 'serversArr' instead of 'temp'
this could be changed to foreach sytle
This and other setters don't have to be public, could be private.
here you should get the selected pattern and get the command.
Just like serviceDiscoveryManager in the line above, you do not need to qualify the field with this. here.
@phillipm Bumping on this
I'll take this occasion to mention this. This kind of variable extraction does nothing for performance and often hinders readability. please avoid them (they're cluttering most of these "performance" patches). Simple getters like this are only highlighted by profilers because of the instrumentation.
You can remove the casting to ConflictTxStream which is redundant.
nit: we could use putIfAbsent here
Same. No need to autobox?
Some of the partitionObjs entries can be NULL if the table is not partitioned. Need to handle it.
copyOf does not necessarilly copy (I know name is misleading). Also we value readability, and old version is way more redable than the new. Finnaly we prefer relying on guava's collection. So I disagree with this commit.
Yes, that's what I was thinking: HMV could be set at any time, including between cap-fetch and selector-creation. By the way, it looks like StringDimensionIndexer's handling of hasMultipleValues is not thread-safe (it's updated by the indexing thread and read by querying threads without locking). It'd be good to fix that too.
This this isn't needed. Generally, we only use the this keyword where it makes code unambiguous.
@ivandalbosco Is it possible to have invalid line? and as a consequence a parsing issue on file level?
This kind of detailed logs can be done at debug level. Furthermore, try to record what exactly was changed (i.e. the new values). Can be helpful in debugging cases of 'missing labels' etc.
![MINOR](<LINK_0> 'Severity: MINOR') Specify a "RuleKey" parameter instead. [![rule](<LINK_1>](<LINK_2>
@ekondrashev move this assignment to line 103 above.
this is not safe, what if there will be HTTP/2.0? I would rather do .split("\\s", 2)[1]
@fanifieiev please, fix the indentation here.
either change the method name to refreshMetadataDevicesInfoIfNeeded or better yet add the if condition here.
You don't care about the order, and you're doing several remove operations - better use a HashSet
it's kind of confusing to have a set named with "List", consider change that.
As here we now want to compute generic cognitive complexity, not only for functions, why should we not increase complexity outside of functions?
@mkordas , what do you expect there ? If it is just counting of metrics - please switch it off. We need notification only if method is more then approved limit.
is it more readable form:  if (isOperatorNode(ast)) { if (option == WrapOption.NL) { if (TokenUtil.areOnSameLine(ast, getLeftNode(ast)) && !TokenUtil.areOnSameLine(ast, getRightNode(ast))) { log(ast, MSG_LINE_NEW, ast.getText()); } } else if (option == WrapOption.EOL) { if (!TokenUtil.areOnSameLine(ast, getLeftNode(ast))) { log(ast, MSG_LINE_PREVIOUS, ast.getText()); } } }  user who debug certain option will not need to real long expressions at all.
Minor: can specify the initialCapacity constructor arg as 3
I'm concerned about the stopTimer method. My thoughts: - the get() method of optional generally should be avoided. This is a pretty good article on optional usage: <LINK_0>, it sums up a number of similar points. I think one to help this is to mark startNanos as @Nullable and just use a null value and do a classic if( null )  type of check. Though, we still have a lot of internal state going that route. Even if we allow for disabled timers, assigning startNanos always to System.nanoTime would not hurt that much (we are still talking a ns operation, that is not a place to make performance improvements).
we don't need to change the Creation classes.
Normally we would do this to prevent accidental bugs to trigger the wrong failure:  private RealmConfiguration.Builder builder = configFactory.createConfigurationBuilder() try { builder.rxFactory(null) } catch (IllegalArgumentException e { //... }
Please use [ExpectedException](<LINK_0> You can look at the [phone-number tests](<LINK_1> for an example of how it's used
In the wonderful world of JUnit4 ;) you can use @Test(expected=IllegalArgumentException.class) public void testCallsiteCopy2() { new TmfCallsite(null); }
The flag is being set to true always, the previous statement does the right thing - Did you leave this by mistake?
Any specific reason why this throws not implemented exception? Wouldn't delegating it to updateTo like the other scms be enough?
You should probably make sure this is an instance of ApplicationContext.
@essobedo once used variable can be inline
make this static and private I think
the old(LinkedList) is not thread-safe, multi-thread addAll might be wrong. You should protect it.
Unnecessary call to super
Unnecessary call to super()
IntelliJ IDEA tolds me to remove this unnecessary boxing.
I would use method reference as per below suggestion String[] nodeIds = logs.stream().map(NodeInstanceDesc::getNodeId).toArray(String[]::new);
I think there are some not necessary white spaces, could we update as: java query.setExpression("select p.PROCESSINSTANCEID, p.PROCESSID, p.PROCESSNAME, p.PROCESSVERSION, " + "p.STATUS, p.EXTERNALID, pr.STARTDATE, p.USER_IDENTITY, p.PROCESSINSTANCEDESCRIPTION, " + "p.CORRELATIONKEY, p.PARENTPROCESSINSTANCEID, pr.LASTMODIFICATIONDATE " + "from PROCESSINSTANCELOG p " + "inner join PROCESSINSTANCEINFO pr on p.PROCESSINSTANCEID = pr.INSTANCEID");
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
Do we have to use the configurator for fetching 'MaxVmsInPool' value? A lot of configuration values are fetched in 'VmModelBehaviorBase' (e.g. GetMaxNumOfVmSockets) - try to retrieve it once 'PoolModelBehaviorBase' if it's not too cumbersome.
after the former validation, add this line: if(getModel().getNumOfDesktops().getIsValid()){ getModel().getNumOfDesktops().ValidateEntity( } remove union (like you did in name validation)
I think also the description needs validation: getDescription().validateEntity(new IValidation[] { new AsciiOrNoneValidation() });
All of this can be replaced with an ExecutorService
As the generated mask is read only and privately used it might be better to create once and reuse the same array.
use Arrays.fill instead for loops
this assumes that field.getRegister() is the same string as the fieldName. it might fail specifically for the registry field which links to the public-body register, not to the (non-existent) registry register
This test would be useless if the map had been initialized in the class.
The user is going to have no idea what "Key has multiple values" means.
Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap
How would you get the next batch for pagination?
I would probably not use pagination to avoid any confusion in the test. I would create a separate test for pagination.
Might want to call out (method name? or at least docs) that this is non-daemon since a lot of the other methods in this class seem to use daemon threads
For executors that have a queue, we set the core size to be the same as the maximum size, so setting the maximum size should also change the core size. Maybe we also need attributes for the queue size and the maximum queue size.
![MAJOR](<LINK_1> 'Severity: MAJOR') Make "createExecutor" a "static" method. [![rule](<LINK_2>](<LINK_0>
There should be no need to recompile the RegExp for every file.
Would be better to have all these methods return a primitive long rather than an Object Long.
I think "No value was found..." would sound better. When I see "provided" it makes me think of a value that I should have provided as the caller.
s/String splitKeyValue[]/String[] splitKeyValue
should check that there are exactly 2 items in the array, and throw an IllegalArgumentException if there are not, with a descriptive message.
Since split returns an array, it shouldn't be necessary to manually assign elements? Just assign the whole array since it will always have length 2 here? java splitArray = layerName.split(":", 2);
Use ClientLogger for throwing exceptions
This is out of scope of this PR but while you are modifying this file, could you also instead import the package and remove this fully-qualified class name?
Does this get overridden in the subtypes?
I wonder if this change would result array allocation and extra cpu/memory consumption issues
Are there any non-IOExceptions that thrown in doResumableUpload method by gRPC?
I might be missing something, but it seems that this method doesn't throws a SAXException. Perhaps it should "throw e" at the end?
Should this executor specify the Looper too?
This doesn't seem quite right. If the logger.setUseParentHandlers(true) is set elsewhere this could override it.
@zxw1962 assert will not work in production, if you could change this to an actual if() statement it will be great.
Maybe better to generate N random bitmaps with a fixed seed. That way, the test is deterministic (but still tests decent variety due to the N factor).
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
java buf.put(bytes, position, bytes.length);  Should do the trick here.
senderId => fromuser
This isn't what we discussed and implies mod_cluster can no longer work in a profile meant for 6.x hosts.
return new StringBuilder().append()....toString();
Same as above: could use searchPacksAgain
You could factor this out. Arguably uglier because you'd have to use instanceof instead of separate catch blocks, but I think the reduced code duplication would be an overall win. } catch (IOException e) { handlePackError(e, p); } ... private void handlePackError(IOexception e, PackFile p) { String tmpl; if ((e instanceof CorruptObjectException) || (e instanceof PackInvalidException)) { tmpl = JGitText.get().corruptPack; // Assume the pack is corrupted, and remove it from the list. removePack(p); } else { tmpl = JGitText.get().exceptionWhileReadingPack; // Don't remove the pack from the list, as the error may be transient. } StringBuilder buf = new StringBuilder( MessageFormat.format(tmpl, p.getPackFile.getAbsolutePath())); ... }
break if found?
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
Collections.singletonList
better use Strings.isNullOrEmpty(item.getLargeImageUrl())
there are multiple uses of these values in different tests would be nice if you could move them to constants with a descriptive name. especially height and width because they are always the same
I would set lookPosition > 0 as first condition here, since it is more likely to fail and results in less evaluations during runtime. It won't make a lot of difference here but getting used to think like that may help in other situations
nit: use List rather than ArrayList
If you like, ri -> ri.getShortNameToLog() can be replaced with method reference RegionInfo::getShortNameToLog. Same other places. Good to have class type before method so I personally prefer that.
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
Same as above for toString(): <LINK_0>
Guava has Objects.ToStringHelper() to make it nicer.
we could avoid some concatenate as it's always starting with "MachineLogMessageImpl{machine=''" or maybe MachineLogMessageImpl should use class.getName so refactoring will rename automatically the toString
I wonder if it wouldn't be better if we *never* used null as key, and instead use the empty string. Then this 3 LOCs could be removed.
I think there should be a space after if here, looks like that is the convention used here.
WTF is lala
Missing null check on sampleClass
Since the creator isn't modifiable, it doesn't need to be loaded from the database for an update. (It'll already be fully loaded in the managed dilution [here](<LINK_0> ).
"/pool/{id}"?
Are you using a mix of tabs and spaces?
Is this a programming error? Should it throw an exception? There is a similar case above.
Missing opening "(" before getDescription().
checkState(mPut != null) ?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
This logic is same in all cases, can you remove the switch statement and do this only once?
This does not take a message, it takes the id of the resource that is missing. Here I would just use the no-arg constructor.
what's the difference between checkAuthAttributesAreValid and areAllAuthorizationsForResourceValid? I thought that the plan was to replace the former by the later, right? Since areAllAuthorizationsForResourceValid can perform all of the work that checkAuthAttributesAreValid performs. And in fact checkAuthAttributesAreValid only makes a number of calls to isAuthorizationAttributeValid. I think it may be the source of potential security breaches if we maintain both methods and a user ends up thinking that it's safe to only call isAuthorizationAttributeValid when in fact, areAllAuthorizationsForResourceValid should be also called. Please, correct me if I missed something.
This is a horrible idiom. Here is a cleaner way to write it: Repository git; try { git = mgr.openRepository(allProjects); } catch (RepositoryNotFoundException e) { ... } try { assignChangeOwnerPermissions(git); } finally { git.close(); }
Shouldn't you be asserting the UNWRAP_KEY permission?
change to Futures.errored()
I don't agree with this change. I'll push a fix.
why is this necessary? why onTouch? please do not use espresso onView or onData operations in setUp.
mResultCode could be defined as a constant too.
this "closeSoftKeyboard()" is not doing anything, because you are using the wrong import. you are using android.support.test.espresso.action.ViewActions.closeSoftKeyboard, which is a ViewAction, so it has to be done in a perform. if you just state it outside, you create a new ViewAction object and not doing anything with it. the correct one for this would be: android.support.test.espresso.Espresso.closeSoftKeyboard, which is a standalone action like "pressBack()". so either: import static android.support.test.espresso.action.ViewActions.closeSoftKeyboard; ... .perform(replaceText(validName), closeSoftKeyboard()); or: import static android.support.test.espresso.Espresso.closeSoftKeyboard; ... closeSoftKeyboard();
Replace with logger
rename to child
This can now become package private and be annotated as @VisibleForTesting I think.
Can this be within the if statement above?
Is this conditional necessary? Maybe we could set the width unconditionally?
Should we check for systemConfig.isOutdated() as well?
else if (SecurityUtils.isHadoopWebSecurityEnabled())
Why is it necessary to have Configuration and YarnConfiguration? Can this code be simplified to YarnConfiguration = StramClientUtils.getYarnConfiguration(getConfig());
i don't think its a good idea to include password in exception message
Could you please rename also _result?
Use the foreeach syntax, it's be more readable
Instead of Integer.valueOf(int).toString(), just use String.valueOf(int)
we should probably check in the canExecute whether we reached the end of the list
you have a get editingdomain methid in the abstract table ;-)
Now we only support copying one object? Why?
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Sorry, I forgot that the re-enablement wasn't done automatically. Please set this back to true. Technically, double-clicking on the button _could_ trigger two dialogs to come up, but in this case, the command is fast enough that it does not happen. If you want to see it happen, you can set a breakpoint in the code that executes the command, then double-click on the command; because of the delay of the bp, you will see two dialogs. FYI, the way we handled this before is by extending RefreshableDebugCommand (written just for that case) and mimic the logic in GdbConnectCommand. But it is overly complicated in your situation, which does not need it anyway.
Are you sure we need to check the session is ours? We didn't do this before and I believe the platform only gives us the selection that are relevant to our session.
It seems you can remove the IOException now.
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
getOrDefault(element.getKind(), Collections.emptyList());
The Exception is never thrown.
The Exception is never thrown.
The Exception is never thrown.
LOG.info("endpoint : {} , timeout : {}, connected successfully", endpoint, timeout);
nit: I know this is following existing test case, but since we now have a logger, we can use this:  LOG.info("Got expected exception", uhe);  Sytem.err in test code is not friendly to test output/log interpretation.
I think it is better to keep e as an argument, not just e.getMessage()
Add the attribute only if blocking is true
Can you repro this on master? If yes - definitely worth filing.
Possible API change, will this have any major impact?
What about creating:  private static final Future<RecordMetadata> COMPLETED = CompletableFuture.completedFuture(null);  and then returning that instance in all of these places. Since it's already completed, immutable, and we don't allow cancellation, it should be fine to reuse in this LogReporter.
Cast.
I realize this isn't being used in code yet, but this isn't doing the correct thing, since it is only grabbing the first record that is returned by consumer.poll() when there could in fact be multiple records. I also noticed the BlockingQueue records isn't being used and this is probably why. Since RecordSupplier.poll() only returns a single item, the rest of the results from consumer.poll() would need to be stored in a bounded queue somewhere, and you would only call consumer.poll() if the queue is empty (or if the consumer.poll() call is slow, you might want to consider using feeder threads similar to the Kinesis implementation). Alternately, another approach would be to change RecordSupplier.poll() to return a list which would simplify the logic in this class.
Again small thing, but "the existing file" sounds better IMHO.
the openConnection() call returns a DatastoreConnection. This needs to be closed in a finally block once you're finished with the operation :-)
This array must be calculated one time only
Why not just use " " + System.lineSeparator() ?
variable name is not good. Can you rename it to identifierSource?
We could create a function that returns the first character of an identifier and accounts for the escaped case (since we're doing this in a couple of places).
The unit test params have a difficulty interval of 10. It looks like Block.createNextBlock() doesn't take that into account (yet). If it's an option to you, try running the test with TestNetParams/MainNetParams.
after the loop, we should check that the iterator is done?
consider a assertSupported(BlockTypeStrategy) as altenative to all the instance of checks
Please add java doc
the resulting code looks strange. can we just do:  case PLUGIN_TOOL_TYPE: case KUBERNETES_TOOL_TYPE: case OPENSHIFT_TOOL_TYPE: case DOCKERIMAGE_TOOL_TYPE: // do nothing break;
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
Basically the same issue as mentioned above, I believe.
not useful I think
Where in the code updates the connectionIdToRequestInFlight queue when a request gets timed out?
we just log, update metric and move ahead with next iteration?
Use reportError rather than report.
AnnotatedTypes.getIteratedType is not longer called. The Checker Framework still compiles if I delete it. I think it should be removed.
no need for if as 1 - 1 gives 0 to add to cpuCost
InfrastructureException can not be thrown here
It's not actually container creation but machine starting which includes container creation, machine bootstrapping, server checking.
this call can be also replaced by contentTypeAPI.find(inodeOrVar)
This isn't right. You'll stomp all over anything passed to setAlpha and always revert the image to 0xFF. There was a reason it was an instance var that was mutable.
This logic doesn't look right. Skin and Family choices should not be mutually exclusive with having specific fonts and colors. I have to admit I'm still uncomfortable with the UIList approach. This doesn't feel like a solution that should be in engine as an example of how to do things, nor something designed for extensibility. Even given the examples of what you're using it for - why is durability coloured text? Why not an indicator bar?
What does b stand for here?
I think we should treat this like we do in Data, and assign currentTime if ctime <= 0. Don't let bogus ctimes be passed in.
maybe a log here and for getRemainingBadInstances would be nice.
Is that "m" in "m%s" a typo?
This helper function seems to only be used by fetchUsers and perhaps it could live as private instead of public until someone really needs it. Cheers!
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
This is a minor detail but the the assertZZZ methods work like this assertZZZ(expected, actual), this is valid for the whole of your test files. Also please format the file as some "," have no space after them.
Please also exclude any fields starting with "$"
what happens if pojoField is null? Please check if this will cause problems when no matching field is found.
Please use the java foreach construct
misspelled. plus why are we leaving the first character capitalized?
added a default clause : default: // Do nothing
it should not give owasp zap catcher (0W45pz4p) chances are quite less however.
I'd prefer if you put the Headers here in a local and did isSameAs just like is being done with body.
Don't we want to keep this?
isTrue()
rename 'variableName'
Include the file:// as constant.
This can be reduced to java if (!new File(path).isAbsolute() && relativeTo != null) { return new File(new File(relativeTo), path).getAbsolutePath(); } return path;
Do you think we can continue with the exceptions refactoring you started in repository level and throw these exceptions to controller level catching them with exception handling mechanism?
declare throws please
For me this is a bit mixing of layers. I think DataAccessException should be caught at repository level and throw more business-ish exception.
Please log the exception. Do not print it. Log it like this: logger.error("Some message..." + e);
We could inline encoding.
Added code to print an error message and exit.
I don't think this is possible, if the cache is not defined it will be created with the default configuration.
you have the assertEquals(expectedValue, currentValue) (or the other way around)
how expensive is this call? Should this be cached at all?
Could refactor this to something like the following, this would reuse code in super class. java @Override CompletableFuture<Boolean> getMainOp(CommitData cd) { return super.getMainOp(cd).thenApply(b-> { Preconditions.checkArgument(b); //expect this to always be true.. was not sure about adding this but decided its good to make few assumptions about the super method cd.commitObserver.committed(); return true; }); }  I was trying to make this shorter by using thenRun() but the void return type threw me off.
Looking at <LINK_0> Do you really want to swallow "Error" ?
s/A submitted/The submitted/ s/task/event/ Also, is it possible to add some info here? perhaps the event's type or something like that?
This is too broad and is swallowing exceptions that need to be propagated.
This can be moved outside the try block (by making it final).
you can directly check if loaded != null in the next line.
Maybe add a description for the error here, something like "Error occurred while requesting purchases for deletion check: " + error.toString(). I think it'd be easier for us to find the issue from the logs, especially for the HEs.
Hard-coded string here. Also, it would be good to write the error to the AppLog.
I don't think we do a very good job with this, but I think AppLog.v might be more appropriate here since it's probably too valuable during debug. I also find it interesting that you chose AppLog.w over AppLog.e while handling the error, I think it [has the lowest priority overall](<LINK_0>
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
I believe the return values from getInputs and getOutputs should be empty _unmodifiable_ collections.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Would it make sense to add a String.class entry to POJO_TYPE_MAPPING instead?
Minor: same as in other number check, WDYT about checking for the decimal point?
Do we need to handle BigDecimal as well?
Does this method need to be public?
log the object id as well.
dir.toPath() may throw InvalidPathException. Since it is an API method, it has to be handled and wrapped to IOException
@ikhvostenkov please name it json
@ikhvostenkov please name it just json
@ikhvostenkov again json, maybe this part with mocking MemberProfileJson and adding when to it could be moved into single private method that would accept just the filename as a parameter.
we're used to write it as if (!t.isFree()) .
use description only, remove " - "
FIXME: Don't cast getActivity(), use an interface.
We should mutualize a hasTag (probably in stats)
I think Local.ROOT is probably a better choice.
Replace by Collections.singleton
Can be replaced with call to computeIfAbsent.
ack vs association
This should probably be issued after the call to alarmDao#delete. Won't situation.getRelatedAlarms() still contain the given alarm we deleted.
Why not just pass in only the message?
Isn't obs.getObsId() already tested on the previous line?
Shouldn't we put back the check for getData() not being null? Of course in addition to what you have just added. :)
instead of calling here to a function that only set the status to connecting (without any callback meanings), just getVds().setStatus(connecting..) does the same thing. otherwise change the name of it, because it's not act as callback function does.
better I think is : if (ec != null) { ec.setJob(this.getExecutionContext().getJob()); super.executeCommand(); this.setExecutionContext(ec); } else { super.executeCommand(); }
please add braces ("{" & "}")
I would just not negate the condition.
Using DBMSType.values().stream().filter(...equalsIgnoreCase...).findFirst() is more readable in my opinion.
I prefer flatMap for this. It sucks they left out Optional.stream() in Java 8 java return FACTORIES.stream() .flatMap(factory -> JdbiStreams.toStream( factory.build(expectedType, value, config))) .findFirst();
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
stray system out
Why change to "unacceptable value"? Should we say specifically say "Request has a null value for header"?
I didn't highlight this issue in previous nodes as it isn't overly important but perhaps we might want to decide if to consistently initialize the two rendering configs either by first obtaining the Config object from the context or, as you do here, by having everything in one line. I guess on one hand I feel that having a local variable helps with the readability given that getRendering() and getDebug() are a bit ambiguous as method names go. On the other I like the compactness of the one-line in this case. I'd say I'd prefer readability over compactness though. What do you think?
This line can go with the playerCamera line below.
I'd move this above the shader-related lines, as it is related to the FBO instead.
Could you replace this and any occurrences of printStackTrace with logger.warn in the code (since you are making other fixes)? Bindings should not print to stdout or stderr but instead use log4j.
shouldn't we be logging this instead ?
from L257~262, you can use Strings.repeat
should this not be "Unsupported operation for Admin service"?
ambry does not support PUTs. You should do the same thing you did in AdminBlobStorageService here.
Is this message correct? It seems like the IDConverter is expected to at least remove/add leading slashes. I guess this might not really be conversion, though.
Perhaps swap the branches here, so you can drop the repeated return?
Hm, you are using cardinality "at least one". Your code in remove item factory removes the item type name from the respective maps. So, the logic in removed acts as a item type name exists in one item factory only. If two item factories use the same item type name, it exists only once in the map and is removed if one item factory is removed. A simple solution would be to maintain a collection with all injected item factories and rebuild the maps all the time a factory is added and removed.
typo: factotry
You only want to use closeQuietly() on an OutputStream when an exception already occurred. Otherwise you mask exceptions that happen during a close(). Those should be treated the same as exceptions during write() calls.
Unsafe cast to int, may lead to exception, suggested Ints.saturatedCast(numBytesToPutInFile)
I think FileOutputStream should be created with try-with-resources, just in case.
Is this related to metrics? Or something else?
FakeVertxMetrics and DummyVertxMetrics factories should be updated to reflect the new expectations (return null if metrics options is disabled)
Can't see where this is ever unregistered. Memory leak?
This line now exists in the else statement as well [here](<LINK_0> I don't think this isOnline check is helpful. Because of that we have a hell of indentation here. I think shouldn't have getAsync from model 2 times. What we can do is that, we can first try to get it online, if that is unsuccesful, we can try to get from the cache, if that fails, we can use setIsloading(false)
onListLoadMore(1, 0) alone is not that understandable. Can you extract this into a separate method sayin something like loadFirstPageOfEvents()
Can you load these strings from string.xml to prevent the lint warnings/allow for android-level translations?
Formatting?
add whitespace suggestion ignoreErrors.forEach(s -> args.add("IGNORE=" + s ));
This might be always true.
If we provide port value of "0", each time we call start(), it generates a new NettyContext, which has a different "address" - "port" value. So if the caller first calls start(..) and then asks for the "address" value, while another caller also calls start(..) and asks for the address value, then there will be a race condition. Other than that, when we call start(..) at the inside of a single thread, the address value of the initial call will be lost. It seems we only need the "address" if we pass port value of "0", otherwise address can be created by merging "bindAddress" and "port"? If so, we might have a overload method which also provides the address value back? If caller really needs the address back, the caller can call this overloaded one. So we will not need any class member and it will still be ok for multithreading?
Do we need to do that ? I'm wondering because we are opening the door to a new way to retain channels: - Is there a use case where the server life is shorter than the application life ? - If so, should we just shutdown event loops to force channels to be closed ? - Is this related at all to the OOM since this is only doing anything when the server is closed ?
This would become a little nicer if FragmentationDuplexConnection(...) was a sub-class of ReassemblyDuplexConnection
this change also needs to be made in KMeansPMMLUtils.read()
Lists
ignore if you'd like: Bookmark bookmark = getModel().getSelectedObjects().isEmpty() ? null : getModel().getSelectedObjects().get(0); BookmarkModelProvider.this.getModel().setSelectedItem(bookmark);
Can you replace IDs with names in this log message?
This could probably also be a static final member, but it's probably not that important.
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
consider using a mixpanelPushNotification.isValid() that checks for errors inside
Why change this method from static method to class method?
Definitely. I've implemented this quite rapidly. This is clearly a bug. if this is implemented this way, multiple alarms will be set, right?
Spacing java for (FMLMissingMappingsEvent.MissingMapping evt : event.getAll())  The variable is better called entry instead of evt (event)
Throw an exception if the event is not found?
This test would be useless if the map had been initialized in the class.
ProductInventoryClientImpl does not return null but 0 when exception occurs. Perhaps returning null would be the correct way, so the change should be implemented in the client..
I wonder if we're getting to a point where we should have an isComplete method on our entities to check this kind of thing without needing this kind of code in a number of places.
We are passing an owner here, but we are never adding it to the collection.
This check should be outside of the synchronized block. No use grabbing a lock to throw an exception. Also, super nit pick: can you flip the order of the conditions so the less than zero check is first?
I would like it if it would first look at args to see if its length > 0 and if so grab the first arg as the file (could be absolute). It was the first thing I ran into when trying this out. It could also perhaps print which file (absolute path) it's working on when starting up. And should it really delete the file in the end, always? What if want to try out what happens between restarts, with generations and all that?
I guess that this test cases should also be with intervals only.
checkIfResoruceHasThisTagType
What should we do when these operations fail? If we just log a debug message and move on, we will be missing events and nobody will even know that resource events failed to be processed. Should we retry? Log an error? @clockard, could we generate some kind of alert here?
Is this change related with the PR or it is just an unrelated fix?
I think this is meant to be moved within the if (executor.inEventLoop()) { block below?
should use safeExecute here?
do we need to unvoid..?
This assertion could be removed as it seems to test the Java type system rather than our code
what's the difference compared to testEditEdit() ?
I don't think that you need this, since your NoteEditFragment.getNote() saves the note automatically, when called (I don't like this, but that's how it's currently works).
Embed the caught exception in the newly thrown exception
This should re-throw, eating the exception will cause confusion.
What happens if it isn't valid? No exception will occur and owner will still be null. What if you combine the if statements:  if (autoCreateOwner && ownerService.isOwnerKeyValidForCreation(ownerKey)) { owner = this.createOwner(...); } else { throw new NotFoundException(...); }
can be reduced
can be reduced to context.getParentLock().covers(buildLock(), getLockProperties().getScope());
Can we have a log message here saying we skip due to a concurrency issue?
So my suggestion to only allow terminate for a single selection when there is no MultiTerminate service causes a problem with multi-process. In that case, when selecting the launch, the code converts it to multiple processes and then does not allow to terminate with the launch selected because it looks like there are multiple selections. This is a pretty rare bug: 1- someone replacing our IMultiTerminate service with one that does not support multi-terminate (maybe they don't want to support it) 2- running multi-process I wanted to let you know, but I am ok with leaving this in. If someone wants to replace our service, they would have to replace this class as well.
If there is no MultiDetach service, maybe we should revert to the previous behaviour of not allowing detaching when multiple elements are selected? It may be confusing to arbitrarily allow to detail because the first selection allows it. We would just need to add a check here if (contDmcs.length != 1) rm.done(false);
Add the exception to the Status message
prefer  String operation = isFile ? SASTokenProvider.CREATEFILE_OPERATION : SASTokenProvider.MKDIR_OPERATION;
this is replicated enough it should be its own method, e.g  maybeAppendSASToken(path, operation, querybuilder) if (authType=SAS) { appendSASTokenToQuery(path, SASTokenProvider.RENAME_SOURCE_OPERATION, queryBuilder); }  and use wherever needed
You could combine the two checks, if (requestHeader != null && requestHeader.size() > 0)
IOException will be thrown if MappingMetaData is not valid json, right? (populateColumns doesn't throw, so don't forget to update its signature). Then we can rename this error code to sth like ELASTIC_SEARCH_CORRUPTED_MAPPING_MEDATA, what do you think?
Does this work if Column A or Column C has trailing whitespace? It might be better to split on comma and then do a colName.trim() or something along those lines.
This variable is not needed and in a scope where it's not needed. Iterate the return of the method directly.
Echo the keyVersion that was checked to help users
Add the original ClassNotFoundException as cause.
Lets not catch the exception and just let the original exception propagate unto main.
You will probably need to change this auth and the accept type when completing teh request verification in the mock tests.
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
We want to make sure that every request is made to the right endpoint. In this case, just add here a common assertion to verify all requests are done to "/"?
I realised that the session visible from time is never supposed to be after the session start time: <img width="940" alt="screen shot 2018-04-04 at 4 58 11 pm" src="<LINK_0>"> Hence, it is the start time that we need to set to a hundred years later. The visible from time can be set to TIME_REPRESENTS_FOLLOW_OPENING so that it follows the start time.
Better to have a meaningful name?
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
Not critical, but for simple maps like this it can be nice to use Collections.singletonMap to keep it concise.
you don't have to do this - you can directly get the PartitionId.getPartitionState() right?
nit: suggestion TimeZone timeZone, String suffix) {  I know the rest of the formatting is screwed up but whatever.
Not a fan of this if within the try which makes the try completely useless if charsetMatch is null. How about a check to see if it is null before the try and returning new String(bytes, Charset.defaultCharset())?
What about the other forms of this? meta name=charset value=, and meta htt-equiv contenttype? There's code in DataUtils for that, should be able to reuse.
Can we not use connection.getConnection().getContentType()?
I think it would be nicer to call darker only once, although it is not really critical.
This change seems unrelated - could probably be its own PR.
you could make this a getRGB() method in ColorEntry if it's used more than once.
Same exception text adjustment suggestion as above.
Might be nice to inform people that the update handler will be removed entirely, so that they know that they cant expect any further updates after this.
Nit: I always like to wrap the failing bit in square brackets to clarify the _thing_ which didn't work, so something like this: new NoHandlerForCommandException(String.format("No node known to accept [%s]", interceptedCommand.getCommandName()))
Isn't this better done at the beginning of onResponse() instead of here?
metric?
Should be log.debug, not info.
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
It seems isNewPost() is invoked just for DRAFTS in the getSaveButtonText(). But we invoke it even for PUBLISHED posts here. Can you please just double check it's intentional? Thanks!
There's a possibility that - if this test group is executed in parallel with another - the post created above will not be the newest on the list. So the assertions below would fail. Do you think we could find this particular post by first getting to a page with posts by this user?
Rather than printing it out, use an assert*() test method. Simplest might be asserting the string is not null; you could possibly String.split() on the delimiter and assert that the resulting array has a length of at least 4.
add prefix to "About to invoke" message too
I know this is from before, but in your tests now do you notice this? If not, let us remove this.
<LINK_0> should be used
Is jobTask.getHostUUID not one of jobTask.getReplicas?
actually there was a mistake in this string, I should have used T(java.lang.Runtime).getRuntime().exec( ..
in theory this should be newTableHandle.getLayout . But if we decided to squash these commits it might not matter..
These are not equivalent.
nit: isRecoveryEligible Is this only checks input? -- maybe isRecoveryEligibleForTableScans?
This is really not needed. CommandBase#1256 sets CommandEntity.commandStatus to FAILED in this case.
I'm not sure if it is needed - wouldn't the command status be set to FAILED in this case?
Please a a warn log here, so we can know there was a failure for the specific child command and the command status
[minor] ImmutableList.<Segment>of should also work and avoid the cast
The test would be somewhat more robust with an expectMessage too.
This test is good, but please also include another test on something other than __time. __time has special-case handling so it's not a good exercising of general long columns.
This is generated code, please remove this or adjust the EMF code generator.
Using stringbuilder and then a + op is pretentious ;)
I don't think these are mutually exclusive. The manual shows them here: <LINK_0>
This may not fail if anything in #rename or nested calls moves to a different thread. Have you tested? I'm not sure how JUnit handles this. A simple #get call on response and a subsequent fail("Rename should have failed when it did not find the current name") would work otherwise?
Log on warn or info instead of error.
typo: perfrom -> perform
Why don't you initialize this where you define eventHandlers? This saves the null check on every call to this method.
we have lambdas for this now.
do we want to schedule the timer for _all_ types of native events?
this must be disposed
The dispose() could be called from a finally block, to ensure it is always called even if an exception occurs during the getText() (which is possible given that it may call user-specified code outside of our control).
I would argue these exceptions are too fine-grained
Duplicated?
What about having a loop that checks for the expected value, with a 100 ms sleep? This will make the test faster and less flaky Maybe we'd better have an utility method, but can we do it in a separate work
WSTUtils.LIVERELOAD_SERVER_TYPE.equals(server.getServerType().getId()) is even safer, as it covers the _unlikely_ case of having a null id.
This method sums over the second and third dimension.
Looks like even the brackets around i == j is not useful?
potential NPE, the public constructor does not initalize the keys array.
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
the logic would be simpler if you just delete the key for revoked when is null
Shouldn't this be warning instead of info message? The message "kieMap not present with compilationID and container present" is a bit confusing Is the kie map not present? Or is it present but doesn't contain complationID? Imagine that you are a user who sees this log message. If the message is good he'll immediately know what's wrong and what and where should be fixed. Otherwise he'll have to look at the source code to understand what's wrong :( Also there is probably duplication of log messages on line 194: getLog().info("Kie Map not present"); - we should probably only log this at one place.
iteration over the entrySet is faster
In what case would this return Optional.empty()? It's creating if not present.
getBinderForChannel(inputChannelName) can be done before the iteration.
Shouldn't we throw an exception here ?
this method throws an exception - how is this error shown to the notebook user?
I've patched hellbender SparkContextFactory.getSparkContext to fix this problem. Update to <LINK_0>
Just put runningQueries.keySet() here in the for loop. No need for the extra queryKeys array list that you copy it into.
OQ: do we want to enforce a capital letter for a first word?
I think we don't need to log anything when we throw RuntimeException with original exception included in it
Unnecessary. There is nothing in the Guice world to start or stop.
Another example of setting null before loading...
Is trim really useful? Maybe a util method boolean isEmpty(String s) could be helpful (a method may already exist).
Can't tell how this works from this RB alone. Is this going to become the logical id for the stream when you create a spec for it in the Planner? And then the physical name by default appends the JOB_NAME and JOB_ID?
minor: it seems that getNextOpId(code, null) was repeated many times. Might be better to add another getNextOpId(code) to avoid typing null repeatedly. But, you call.
Why new message stream instead of returning 'this'?
There's an inherent race here, if the following sequence occurs: 1. Thread A: getRealmIdentityForUpdate 2. Thread A: removeFromCache 3. Thread B: getRealmIdentity 4. Thread A: modify credentials 5. Thread B: authenticate with wrong credentials, which are cached forever The entry should only be removed from the cache *after* modifications occur, i.e. ModifiableRealmIdentity has to be wrapped as far as I can tell.
It's better to change the signature of AuthenticationService instead of using type cast.
database filename should ends with .realm.
Maybe you should look into "logic of detecting directory" which is really used for meta data editor. Not in any case used directory is named with process title.
Throwing an exception here could make the analysis fail in setups which currently work well. I would only log a warning.
Please keep those final
Seems like this configuration is being created and not used. Does this test pass?
you can also test for number of attributes.
~1 minute & ~3 minutes respectively?
Minor nit, shouldn't this also be at debug?
Either of the events should be raised I think.
Unnecessary parentheses
Lines 56-71 shouldn't be indented while they are inside if statement from in line 55?
Should we maybe check with instanceof GitCompareFileRevisionEditorInput.EmptyTypedElement directly?
again same typo
Please assume usage of org.drools.workbench.screens.guided.rule.client.util.ModelFieldUtil.modelField method
Is the deployProcess() method doing something? if not we should start getting rid of dead code.
This may chain to the next (more complete) constructor instead.
I think it is better to use static import here
Just asList is enough no ?
Another minor note, any reason not to merge this into a single check? if(values == null || values.isEmpty()) return true ;
StringBuilder please
Or even simpler: java Iterables.transform(branches, from -> Util.fixNull(from.getName())));
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
s/id/ID
I think this is unnecessary => "profile =" + this.profile is sufficient.
Same as above for toString(): <LINK_0>
We are passing an owner here, but we are never adding it to the collection.
Same here; subscription should be updated to do redirection rather than forcing everything that uses it to manage it.
Use null instead of Collections.emptySet() here
This code assumes that the first 8 bytes of pcapPacketHeader have already been read... It's true in practice but not very safe.
Where are you trying to position the file channel? I think it is already at the end of the packet data?
That is Original Packet Length. According to spec, the included packet length is minimum between this and SnapLen (for Interface ID = 0).
I prefer to keep the static import.
Why 5? With the minimum connectionTimeout of 1000ms this will generate a constant load of 5 connection attempts per second (200ms apart). / 2 gives a much more reasonable retry value.
It's already calling Math.min(long, long).
Avoid hard coding the path, use Environment.getExternalStorageDirectory() and the local path as a string resource.
Can you use a toast here instead? It'd be great to allow the user to see what's happening without having to fire up a log catcher.
The method signature doesn't specify the Exception which could be thrown.
this branch is redundant, can be replaced by if (op2Zero)
equals() should be used to check the string names are the same. != checks if they are the **same** object: same memory address, etc..
StandardCharsets
If container is IWorkspaceRoot the scheduling rule must be WorkspaceRoot.
style nit: we don't use braces around single line blocks
we should at least break here, possibly even return this and avoid the duplicate, shouldn't we?
I thougt we had a function to print that string
This is a full catalog scan, would be terrible when used with JDBCConfig. Should be using specific method to take advantage of catalog filter. @smithkm can you suggest a replacement here?
Should this be added to the messages file? Maybe it intended to use warn.install.license after that is fixed in the properties file?
wouldn't all start times be invalid then?
Make all infos debugs.
I don't think you need the sychronized blocks (the concurrent hash map is good enough).
remove !=null since null instanceof WrappedMessageContext will return false
use error message as in startMemoryRevoking
equals() should be used to check the string names are the same. != checks if they are the **same** object: same memory address, etc..
field.getChildren().get(0) is an Optional and we just call get, is a value guaranteed to be present in this optional? On L176 we do a isPresent check, but not here (and below around L156)
Same question about optional above applies to here and to L159 below.
IIRC there was some issue with case sensitivity when we added this feature to the Parquet reader. I think the issue was that Presto lower cases the field names in the type, so we may have to lower case when building the structFields map in the constructor. cc @nezihyigitbasi @zhenxiao for context on Parquet
NACK. this undoes #1272
Small formatting issue here. Can fit on line above.
if I understood right, there are only shared ents in this list. would it make sense to change its name to sharedEntitlementsToAdjust?
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
Rubbish
Isn't it a good idea to be explicit about the exception being caught? In this case "ClassNotFoundException"
Looks from the conditional block above like ref can be null - should we be handling that here?
Isn't this quite ineffective? We are implementing a method which explicitly expects a fully qualified ref name and which therefore does not have to deal with iterating SEARCH_PATH. But the implementation is done by calling the expensive method which does all this iterating over the SEARCH_PATH and to throw away the results if we see the input ref name was not the a qualified one. Maybe an internal getRef() method should learn to use a explicitly given SEARCH_PATH.
can you put braces around if block please.
nit: this can be private synchronized Optional... and we wouldn't need the synchronized block below
Why was this removed?
@kishorekasi Generally wondering if this will increase the latency of the operation since we are not failing and retrying connection?
It'd be nice to clean this up a bit and have a single constructor.
Is it required for the upgrade?
In the code base, even just in this file, I saw it prints debug log only when logger.isDebugEnabled() is true. The only exception is that few places print debug info for rare case or failure case (actually it should be changed to info or error log). You might want to add if (logger.isDebugEnabled()) { ... } too for printing debug log.
Precondition to check page Offset is positive?
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
Can you add assertInDirectory(file); ?
what if valuelist is empty? should you check for that?
See ByteByReference.java
The current implementation doesn't really make sense to me. Can I suggest something like this instead? java public void cellValue(ByteString newValue) { // Optimize unsplit cells by avoiding a copy if (nextValueIndex == -1) { this.value = ByteStringer.extract(newValue); nextValueIndex = newValue.size(); return; } Preconditions.checkState(nextValueIndex + newValue.size() <= value.length, "Cell value is larger than expected"); newValue.copyTo(this.value, this.nextValueIndex); nextValueIndex += newValue.size(); }
nit: put with the previous line
Why not return Optional.of(ImmutableMap.of()), like we do in FileHiveMetastore? It's expected that statistics might not be available for tables.
java Map<String, HiveColumnStatistics> columnStatistics = partitionColumnStatistics.getOrDefault(partitionName, ImmutableMap.of());
You don't need to repeat lines 67, 69 and 70 as this will be invoked by this(resource) : this(...) invokes the other constructor first so no need to repeat it's content.
Please, add { and } to the if statement. if (dialog.open() == Window.OK) { ICommand cmd = wizard.getCommand(); //command execution ? } Modifiy the inheritance of the action and add the command execution
What happened to setHelpAvailable()? Looks like somebody had once started with help pages, and set the help contexts on the PushWizard pages. But that work appears to be incomplete, and the wizard hasn't isHelpAvailable set... But removing the setHelpAvailable() is a step backwards. If somebody wants to pick up this incomplete help work, he'll have to undo these changes here again.
Doing these instanceof checks in Java is normally considered an anti-pattern. You want to find ways to avoid it best you can using interfaces and inheritance etc. In this case I'd consider doing leveraging function overloading to make this code have less conditionals.
Since you return in each branch, you don't need the elses.
We need to keep the throw exception as we are not changing the existing behavior
Good catch :)
We are not passing tags, description as arguments in this constructor. So we shouldn't be initializing them here.
:o
No need for a null check here, instanceof would allow both the class and null check as one.
same here, i bet noone needs all of them to be equal. don't make test code/reqeuirements leak into the main
the surrounding brackets aren't needed.
This should be more than a LOG.Error? if we don't recognize an ACL shouldn't we return an error to the caller instead of ignoring and continue?
We should not use this to set the BitSet size *aclInfo.getRightsList().size()*
what about putting this in the default: case of the switch (switches without default, you know...)
This comes from when we pull the body out the camel exchange right? If somebody sends in the wrong type, the exception message does not seem accurate.
We could declare message in the try-with-resources, then move the null check inside and delete the finally block.
@rcordovano I'm wondering if we should log this as severe? I know that typically we try to reserve severe for errors that compromise the case, but I think if we are unable to instantiate FileTypeDetector class, then it definitely needs to be investigated.
Remove unnecessary variable.
As "<LINK_1>" appears multiple times it could be reused by declaring a static final.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
The Kafka client library has constants for these strings, would nice to use those.
The producer is create using try-with-resource clause thus, the producer should be flushed on the implicit close() anyway? Thus, I don't think explicit flushing would help?
Zookeeper connect is not required by new kafka AdminClient, we can remove it.
Since this is a separate check anyways, I don't see a benefit in comparing with FFFD instead of 10000. Use >= Character.MIN_SUPPLEMENTARY_CODE_POINT instead. It's also more evident what the code is trying to do that way.
I think this would be clearer as a while loop, or a for with an empty third part. Certainly the codePoint declaration without an initializer brought me up short.
I think this might return an unexpected value for say ? and #
Cannot this be changed to orElseThrow?
json.toString().isEmpty can be very expensive. Just null check is ok
I think CancelNodeInstanceAction is used in multiple cases, boundary escalation and boundary error events, not sure I grasp the meaning of TIMED cancel type in this context?
While we're in here, could you replace that with this: for (Object selectedObj : structured.toList()) {
You could also use for(Object nextSelection : structuredSelection.toList())
Even if it's very unlikely in this context, you could test whether the getViewer() return null or not (the return contract is "the EditPartViewer or null") before calling deselectAll()
Should initialize list size with children.length
Optional: better to invert equals to avoid potential NPE
rename to child
It's possible between null checks that someone sets the subscriber to null when you retrieve it a second time.
You don't need any logic to be in here. In the onNext() override, is where you would call emitter.next. And wherever the flux is attached to the Emitter could be the messageReceivedEmitter. MessageReceivedEmitter shouldn't have to exist.
final for both the variables?
I think it makes sense to limit Che container name like to 50 characters and if preliminaryName is too long then get first 12 characters from Che Plugin Name concatenate Che container name along with '-' separator. @garagatyi Please pay attention to this. Maybe you can suggest a better way.
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
I am not sure if we want to return null here
check if volume is null and log and return.
setReturnValue can be Guid? As the snapshot entity is not populated apart from Id, so is there any need in returning this?
endDate.before can be used
The empty string in the constructor is redundant.
There are too any places that we use the data folder and refer to it via the string. Can we instead create a constant atleast on the agent side as a part of this PR. Its difficult to see where all we use the data folder. The only way to do so is to look up for the string "data" and that gives back way too many results.
inline these locals, it will be shorter code?
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
can you default to the value in R.bool.show_sura_names_translation
Would you mind improving this test to use executeFile() instead of executeString()?
This nice plan nesting looks like you mean a specific query plan (joining tree) shape. Is it guaranteed? See com.facebook.presto.SystemSessionProperties#REORDER_JOINS
I think the <zookeeper> argument comes after the other arguments. Also, it'd be good to add one more example with your -d flag.
It seems that the following does the same thing with super.unparse(...).
IF EXISTS should be reflected in unparse
is this line useless?
This annotation should probably stay, and again for parse below
how about remove the null check and just have: "case".equalsIgnoreCase(name) ?
Should we be throwing any sort of error or warning if the fixture schema wasn't actually included in the restore? Right now it looks like IndexedFixtureXmlParser just silently creates no indices in this case.
Put ITEM in front of OTHER_FUNCTION .
I'd be concerned about this mapping. CrateDB's BYTE type corresponds to a single byte, but the JDBC BYTES type really corresponds to an array of bytes.
Please add single quotes around fieldName and urn
we might avoid using this new getMacPool method by using AgrumentCaptor and verifying that the expected macPool object is being passed.
the captor isn't in use anymore
Some nit picking (so feel free to ignore) The test name is absolutely puzzling for me (I know this is a legacy thing, but as we already modify it, we could fix that) Also the test tests two things: - that 2 requests with the same decorator actually result in the same decorator - that the same locking instance is used Maybe we could divide it into 2 tests, and rename to something like: testRequestsWithSameDecoratorAreEqualyDecorated testRequestsWithSameDecoratorUseSameLock The same for the other test: testRequestsWithDifferentDecoratorAreEDifferentlyDecorated testRequestsWithDifferentDecoratorUseSameLock
static final String
if this is defined in tier 1 SDK, should we just use that instead of defining it again?
@fchauveau there is no null handling of source, is this intended ?
@inverno can we drop it?
Since there is no marker, It seems that containsMarkerForEmptyTxn should be false.
PMD/Sonarqube: Avoid concatenating characters as strings in StringBuffer.append
You didn't want to use minDateTime() and maxDateTime() huh? :P
We should guard this with if (mEndTime != null) and in the block, return false if it fails.
To avoid repetition, you could - Make the super method protected - have it use getStartTime() / getEndTime() instead of fSht.getTreeStart() / fSht.getTreeEnd() That way the reimplementation of getEndTime() in this class is re-used.
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
If disabled, we should not the forceRefresh attribute nor the representationToForceRefresh list.
Nit: this is actually a completely unrelated change that might have been done in a separate commit.
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called.
Add a check here to verify that the serialDataReceived method was not called.
I think this exception should be about a @ResultHandler annotation, is that's what's being verified in the MessageHandlerInterceptorDefinition#wrapHandler method.
What does "tl" stand for? Thread Local per chance?
You can remove InterceptorSequence from this message, since it doesn't exist anymore.
This does not match the debug log below. We should ignore a remote Ack if we are the master.
Simplify it as " if (m_isLeader || isForLeader)"?
Can you please move the cleaning method up to the ChannelProcessingManager:290 and clean the channel.getName() value. The current approach causes path separators in linux to be converted to underscores and causes an illegal filepath. /* Setup event logging */ List<Module> loggers = mEventLogManager.getLoggers(channel.getEventLogConfiguration(), StringUtils.replaceIllegalCharacters(channel.getName()));
To go up before the first "for" to avoid to call this code several times.
This should better be initialized with a size of 3. The reason being the load factor defaulting to .75. So unlike intended, the second put() will trigger a resize of the internal table.
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Please move this to DBUpgrader. Also, use oldVersion < 1090001. Users might skip AntennaPod versions. When checking for equality, this skips the migration when coming from, say 1080100 instead of exactly 1090000.
If there's a failure and rollback, the ongoing migration flag will be true until a relaunch, right? Does that mean that if the failure was caused by something that can be fixed, the user will need to also kill the app and relaunch for the migration to run? If so, that doesn't feel right to me.
strictly speaking, probably not needed since this would indicate a framework bug
This is in general a bit tricky. This check implies, that the namespace is contained in the properties. Is this really always the case? The namespace should at least be enforced before trying to equal on it Besides this, an edge can connect the same vertex, so pointing to itself. This may not be used often, but AFAIK it can already happen within linkd.
Sorry, already removed this :flushed:
Consider wrapping this into the constructor, and getting rid off the setter? StreamEdge(isIntermediate)
is this really a requirement that in().dimension(2)==3? actually it should work for arbitrary dims, right?
Seems like this will compare 1.0 and 1.1 as equal. I think this needs making protected and some tests written.
Extraneous space after (
please remove alias setting (should be encapsulated in addManagedDevice
this is probably not needed
please use getVmtGuid
Tool tips can be slightly more detailed. Sometimes just a one word may not be enough.
"Save board as ..."?
Isn't this the default max width? In any case I would prefer to see these definitions in the css files.
The hashCode() and equals() implementations depend on the current position in each payload's ByteBuffer. The implementations can also process the same payload bytes as it recurses through the child packets. The payload should be processed only when there is no more child packet, and it should process the whole payload regardless of current position.
I think you should keep the try
I think you should keep the try
Inserting line breaks in log entries can cause pains when reading the logs. Can we remove the \n?
not the correct class used to get the resource
No need to create String errMsg
Did OSCORE specify to use ACK (and not RST) even if the message processing caused an error?
In the meantime, we use NullPointerExceptionfor that (even if there is a lot of code not updated according that).
Minor thing: I'm generally not happy with reassigning method parameters.
is this supposed to be deadlineMs - System.currentTimeMillis()?
No need for final
exception can be improved a bit - "failed to flush within X ms, successfully completed Y/Z batches". wuold help distinguish between slow connection and no connection.
you're synchronized on shutdownGracefully. Is it possible we are active at this check, but then become inactive ungracefully? I'm assuming that is also synchronized? I see that the handshake case is covered below in the else{}
Why did you take out the isTraceEnabled() checks? Do you check for that elsewhere, or just decided to always write traces?
What do we want to achieve with this throttle? Do we just want to backoff for THROTTLE_PERIOD_MS whenever we can't find a connection you sent? I think we should simply use a Thread.sleep call. To be concrete, I recommend we instantiate a org.apache.kafka.common.utils.SystemTime class and use both its sleep() to sleep and milliseconds() to get the current time
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
return an unmodifiable view with Collections.unmodifiableList
What is this proving? If you  groovy sh 'cat /any/file/at/all'  your log will contain  + cat /any/file/at/all
And why would you do that to begin with?
We talked about using docker-fixtures for tests in this PR, though it is more work to set up.
IOUtils.close
You can also use IO.close(bb) as IO.close will not throw any exception.
I'm almost tending to use VRaptor specific exceptions for this case, instead of reusing IllegalArg and IllegalState... We're doing this only because of validations, right? We could create a ValidationFailedException.
If the Deserializer is named, Deserializer. The Serializer should be call Serializer!
change to this(proxifier, ...., new NullEnvironment())
Maybe use a proper error msg
Please, add spaces between get(i) > Vectors.EPS. And having a {} arround procedure is also a good practice.
should this count be parameterized?
Pull this into a static final variable
Use parameterized logging instead of string concatenation.
Why did you catch any RuntimeException based class here? So far as I can see only ClassCastException is official thrown.
VertexInfo vs NodeTopologyEntity.
you can move this line out of the loop
i think we should have a else here so we dont print the cwd if the user has enabled the help option.
Throwing an exception without any message is a bad programming style.
I take it a CborLong is 32-bits long?
Remind me: does this get called for any other ops than signup?
p -> path
nit: for all of these, can you do assertEquals(addresses.getStatusCode(), 200); to avoid [yoda conditions](<LINK_0>
This should use LinkedHashSet, which would reduce the LOC since the !contains() check can be avoided.
at least or exactly one address?
Can we rename this.policies to this.customerPolicies? This method is hard to follow with two different lists called "policies"
May need defaults.
Does shareName or directoryName need to exist here?
remember Logger.debug(getClass(), ()->"luceneQuery: " + sanitizedQuery);
Looks not nice)
Is it needed here? Doesn't line 764 do it?
newMappings is not used. You can avoid all this synchronization by atomically replacing channelMappings with newMappings.
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
We should probably delete the shaded class that I was using from testing with my monitoring utility and provide a way for users to configure their own class names here.
I assume this fetches VLAN devices properly, i.e. if the iSCSI bond only uses eth0.101, this won't return eth0 right?
I don't think the poolId check is needed, if it is needed we need to verify that first and throw if it's null..if its null we dont check anything here.
This will create 0 connections. Didn't you mean < ?
s/unexpetedly/unexpectedly
The given state does not imply that the device is active. If you are going to make sure the device is active, I would prefer "an active device with DeviceID..." so you the scenario matches exactly what happens.
remove "throws Throwable"
we should log this before throwing it.
asRuntime(getRuntime()) doesn't seem very clear to me. Maybe asRuntime(getInternalRuntime())?
won't exit the loop. You need to return here
Do we want to return here so as to skip the older File.setWritable call?
Can we add a throws declaration to an existing public API, even if it's deprecated? We just reverted a change [1] because adding throws broke backwards compatibility. [1] <LINK_0>
private static long Sorry, missed that one.
You need to make sure the revisedOrder has the correct action of REVISE
very long if, split that to 2 ifs
Copy this value from the previous and ensure the previous' value isn't null
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
What about &gt; and a bunch of other encoded string elements? wouldn't it make more sense to use a generic encoder/decoder?
That is not necessary anymore as your other PR got merged already.
The point I was trying to make is that you know this data in the constructor. You can do this logic in the constructor and simply return a copy of the binary data. Before, you were iterating through the Iterable of BinaryData each time, creating a new List object and then throwing it away to get the first item before copying it.
This returns an optional. We should actually check if there are none in findFirst().
I missed it to change to return BinaryData.fromBytes(amqpAnnotatedMessage.getBody().getFirstData()) BinaryData will always have data, a null is converted into empty byte array inside BinaryData, So we do not have to check for payload.isPresent(). BinaryData store data in byte[] variable. so calling getFirstData will be efficient.
Nit: could you avoid static imports for non-obvious cases like this?
this method (clue of your PR) always returns null. Write tests, check if they fail, and then implement a new feature.
Admittedly IllegalArgumentException isn't the most appropriate type for mapper annotation misuse, but IllegalStateException isn't either: - IllegalArgumentException: _Thrown to indicate that a method has been passed an illegal or inappropriate argument_ - IllegalStateException: _Signals that a method has been invoked at an illegal or inappropriate time_ Between the two, I'd rather keep IAE for the sake of backward compatibility.
why replacing lockKey by lockKey? shouldn't be lockValue by lockValue?
can someone review this condition? I don't think the log is printed correctly. If I understand correctly, it should be leader.getAndSet(isLeader) && !isLeader. leader was true and it was set to false.
I don't understand this logic. If weakReferencesTolocks.putIfAbsent(lockKey, lock) returns a value, then you already have a reference to the lockKey. OR am I mistaken about this?
![Codacy](<LINK_0> Issue found: [These nested if statements could be combined](<LINK_1>
Immutable?
set to final
Remove unnecessary blank line
It seems strange to test for null in this test, since it is testing the happy path. Can you create a FilterStub?
You should call this right before the line you expect to throw the exception, and have no code after that line.
I don't think there is a need for this any longer - Files.move() will copy the file if necessary - I tested it on OS X and Files.move() moved the file to another physical disk. But I suppose it doesn't hurt to leave it here. WDYT?
The Exception message should contains the original IOException ?
Why do we have the full name here? I did not see another FileUtils being used here.
Please remove initEditors
add: UploadImagePopupView.ViewIdHandler.idHandler.generateAndSetIds(this);
Remove public. Also let's reformat all the ctor to our latest code style.
Should be Localized in Android framework.
Need  java .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread())  before this
Create Activities using Robolectric.setupActivity()
We have another NPE here
This has to be cleaned up.
It is possible to write this and preserve types (e.g. avoid SuppressWarnings). I'm pretty sure it can also be written using generics (vs Object) but didn't have a chance to finish that.  public static Object[][] cartesianProduct(Object[][]... dataProviders) { List<List<List<Object>>> lists = Arrays.stream(dataProviders) .map(Main::nestedArraysToNestedLists) .collect(Collectors.toList()); final List<List<List<Object>>> product = Lists.cartesianProduct(lists); final List<List<Object>> mergeProduct = product.stream() .map(list -> { List<Object> result = new ArrayList<>(); list.forEach(result::addAll); return result; }).collect(Collectors.toList()); return nestedListsToNestedArrays(mergeProduct); } /** * @param dataProvider a nested Object array * @return an equivalent nested List */ public static<T> List<List<T>> nestedArraysToNestedLists(T[][] dataProvider) { return Arrays.stream(dataProvider) .map(Arrays::asList) .collect(Collectors.toList()); } /** * @param lists a nested List * @return an equivalent nested array */ public static Object[][] nestedListsToNestedArrays(List<List<Object>> lists) { return lists.stream().map(List::toArray).toArray(Object[][]::new); }
I need to hit ARROW-DOWN twice to get something selected if there's no selection yet. Perhaps select the first item then?
This won't do. It logs PatternSyntaxExceptions. Just enter [ or \g.
Please externalize these strings.
Existing code use null as the sentinel for this field, so I think you should keep using null here. suggestion this.apiUri = null;
Let's have the message a bit more explicit here ... "clusterUri cannot be null" or something like that
Maybe isSame()?
same question here, do we account for the colo with single replica?
missing break after assignment.
It would be great if you could put this query in its own sql file like I've started doing in other areas. It keeps the code separate from the sql.
This should be validated with an assertion as well
Is the deployProcess() method doing something? if not we should start getting rid of dead code.
Please simplify this just to nameModel.getObject() because it is a bit confusing at first sight.
any reason for this change?
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
line 1176-1182, 1185-1192, 1196-1204 are having duplicated the logic. is it better to abstract this logic into a util function, rather than duplicating the code?
This may cause a breaking change. Until now, the "type" of a DomainEventMessage wasn't used. I suggest accepting unmatched types when the aggregateModel doesn't define any polymorphic types. In that case, we can silently accept "mistypes". If the model _does_ define multiple polymorphic types, then we should throw an exception.
Ideally, this test wouldn't require any change to pass. The aggregateType wasn't used in the past, and unless polymorphism is used, the type shouldn't really matter.
This blocks multiple invocations from the same unit of work, but will not prevent different UoW to trigger the creation of a snapshot....
This seems like a significant refactoring - why? Can we do it as a separate change or is it required for the java8 migration?
Since I already have implemented allOf in CfUtils, it had better to use it:  return allOf(futures).thenApply(x -> futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()));
I'm not sure what this indirection with the t -> business buys us
Can you set the message inside the method avoiding passing it as an argument?. It's always the same
Should we also issue a warning to have a log of plugins to be fixed? I think we should, but do not know if this is going to generate just a few lines, or dozens or more of them.
Should deserve a @VisibleForTesting ?
Shouldn't we use the material library version to get sexiness pre-L? (And consistent behavior in general.)
Should use Box.createHorizontalGlue() instead of the panel.
Will this be OK across different screen sizes? Should we put the 35 in dimens.xml?
The registration1 doesn't care about the value other than it is different than registration. For this case, registration3 needs to use the new variables, so (if it is kept around) it should be named more explicitly.
you can also test for number of attributes.
I'd rather not synchronize it here. It sounds better to check in the constructor whether config is null and instantiate the default object with new ZKClientConfig() in the constructor, in which case we can remove this if block from here, or at least keep it here just to assert that clientConfigis never null. If we do it, then we can also make clientConfig final.
objectRefs.get().acquireReference(object) -> objectRefs.get().releaseReference(object) I think you want to decrease the reference count here?
result, not object
result not object
not necessary to add "due to"
in finally? You're not unlocking it at all!
Use logError(String, Throwable)
You could combine this into the for loop conditional using && and removing the negation.
Wrap the one line if with curly braces.
what is the purpose of testing a while loop? :)
Should we use one of the core executors here?
That can't compile anymore.
When we call stop this map we might wanna empty this map. WDYT?
@inverno We have 2 times "Second argument" :)
be a good citizen and call System.exit too :wink:
add a System.exit(-1) after the usage output
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Shouldn't this close the iterator before returning the list?
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
i18n
newVmStatic ?
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Could use a mocked Model to avoid the need to tidy up.
you could forceMock(RequestBuilder.class and @Inject it as a field of DefaultRestRequestBuilderFactoryTest
isn't protected sufficient for this method?
Will always start by "file", so you can directly return true
Yes, I'll use a regex
possible NPE?
why do we need to make a copy here? just use props directly?
Let's simplify this condition
Should these define the default value? If so, then addDefaults shouldn't be needed, right?
new String() is redundant.
might be removed?
No need to convert OperationCanceledException to status. Just allow it to propagate.
No special need for final and please use interface. No need to know implementation. I would even recommend to use ImmutableSet from guava for safety.
Do we have any test coverage for this?
We should use this opportunity to upgrade this to the CandlepinQuery framework. We'll also need to update ActivationKeyCurator.listByOwner, but we'll be able to clean this method up substantially while getting some added benefits like paging and faster iteration.
Shouldn't this be Calendar.getInstance() instead ? That way it's truly a no-op.
The addition of the "active = 1" check, is that because we actually expect id=:id to potentially return multiple rows or is it just being uber explicit?
503 Service Unavailable would be more appropriate I think
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
sorry to bother you again, but wouldn't this make the complete URL lower case? Shouldn't we make only the part before ":" (if any) to lower case?
Can be replaced by: return script != null ? "" + new String(getHash()) + "\n" + script : "" + new String(getHash()) + "\n" + url;
this is not needed as done internally in the ItemService.delete <LINK_0>
This is not necessary. It is done in the RestResourceController, indeed the value here retrieved is not returned
Bad code. Remove try - catch.
Can the method be called getLabelNames instead?
I would recommend refactoring the tooltip creation to the following, which prevents display issues, if some text exceeds the screen width :smiley:: java Screen currentScreen = Screen.getPrimary(); double maxWidth = currentScreen.getBounds().getWidth(); Tooltip tooltip = new Tooltip(description); tooltip.setMaxWidth(maxWidth * 2 / 3); tooltip.setWrapText(true); entryButton.setTooltip(tooltip);
Does the null here translate into an empty Optional result?
If you follow my advice above about disposeLookupSourceIfRequested you will end up with a method called disposeLookupSource, which you could call here... Also as above I would put the if in the call-site
"before lookup source provider provider"?
rename from to nonTrackingSupplier and static import
I think we can just go with the  @ContextConfiguration @RunWith(SpringRunner.class) @DirtiesContext  and avoid extra loads for the the same config in each test method. I that case the outbound-gateway-parser-config.xml should be renamed to the MongoDbOutboundGatewayParserTests-context.xml
Rather than deleting these assertions in all these tests, I think I'd rather see us do something like  java MessagePublishingErrorHandler errorHandler = TestUtils.getPropertyValue(taskScheduler, "errorHandler", MessagePublishingErrorHandler.class); errorHandler.handleError(new Throwable()); assertEquals(context.getBean(IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME), TestUtils.getPropertyValue(errorHandler, "defaultErrorChannel"));
Why ISE instead of IAE? This is a setter. Assert.isTrue() ?
We need the group_id as well.
"Couldn't rename [" -> Fail to rename
move this check at start of the function.
I'm missing the new field in the toString method.
scheduleTimes --> scheduleTime
Should be checking that the container shows up in the UI. Same for removing container and adding/removing/changing pool below
Maybe turn these three into a single if?
TextComponentTranslation allows ITextComponents to be passed to it, so the user's name should remain as an ITextComponent.
Never use uppercase letters in a resource location. It may be ok in this particular situation but in general its not a good idea and will result in forge yelling at you and the game not starting. use toggle_shield
DefaultStainCategoryService calculates whether to add the 's' or not, could this one too?
Does it make sense to do all the checks in case there's some database shenanigans? Worst case, they'll be zero.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
wrong order
This should be a singleton.
should be closed
This expression (nano % 1000 >= 500) is used in more than one place, why don't extract it to a function?
Unnecessary else.
@davecramer Would it be better to do LocalTime.MAX.equals(localTime) here, instead of using the reference equality? Otherwise there will be a difference in write behavior between a LocalTime that has a value of 23:59:59.999999999 and when using LocalTime.MAX, even though they are value-equal.
The 'Network' should be omitted from this context since this is not a specific provider.
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
do you need to add CRC here?
Share the string.
It know it's part of the original code but it's better to clean it up. Remove these two lines, just let the Exception be thrown, it'll give clearer test error messages if there's a failure.
Use this instead of the two if blocks: Throwables.propagateIfPossible(e.getException(), NamingException.class);
I guess you want to return Optional.empty() here
Not good to use Optional for collections, just return empty collection
It's considered bad practice to have an optional around a list. Just return an empty list, instead of an empty optional.
Change LIKE to =
Make sure to test when 10.0 is in the array and you're removing with a 10 int argument.
Same as above - make sure 56L is in array and is removed.
You could probably check Jenkins core version here: Jenkins.getVersion().isNewerThan(new VersionNumber("2.64")) in order to optimize the call on the agent side. and to check JNR version before it . But it's rather polishing, which may actually break some use-cases with pre-loaded JAR files
I assume linkRegistry can be null here.
for the case where the file is being thrown away (abort is called rather than commit) we could get away with not calling force. (that is the ATF.commit could call a force method which does a flush, force, and then subsequently call close)
you directly use the member variable tcpSocket, but shouldnt it be the parameter socket?
Arrays.asList seems a bit simpler
Why overriding it here? If you don't really want to add, don't initialize the variable when declaring it and use copyOf here.
this test is failing in JpaStoreFunctionalTest. I believe you have to use String in the keys and wrap the value using wrap("k1", "v1")
I would make that example a bit more evolved, getting the TTL and only if different than default above set it.
address.toString() uuh... why?
ExecutionException wrap the actual cause on loading the file channel. so you need to unwrap this.  if (e.getCause() instanceof IOException) { throw (IOException) e.getCause(); } else { throw new IOException("Encountered unknown exception on opening read channel for entry log " + entryLogId, e.getCause()); }
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Compare this and change to what is done in src/main/java/com/salesforce/phoenix/query/StatsManagerImpl.java:132, wrt the sqlE.setNextException(). If an exception occurs now here during finally block, we'll lose the original exception.
We should probably add 1 more new line to separate from the error itself more in the dialog and make it stand out. Also, will this get localized properly for our translations support?
if you allow planned date to be null this change won't be needed
use constant for key/value separator
Should StringUtils.EMPTY be used for these lines?
try/catch, return ResponseEntity.badRequestSomething(JsonError.of...)
Seems like this won't work for versions later than 2.8 because this method is overridden and super isn't called.
This whole block can be simplified, no? You're effectively checking for negative health twice now.
Less than or equal to. Just in case.
If possible, it would be nice to test also the expected result of a call instead of just that the response is not null
Please, make sure all the code follows [project style guide](<LINK_0>
Since we have a constant for the solr.data.dir, maybe we should consider having one for solr.http.url as well?
This "ensureTrailingSlash" logic is duplicated in DescriptorImpl#getBaseUrl below. Consider calling that method or extracting a helper that both sites call.
We should mention this default value in the getter and setter
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
why not check for null?
why not check for null?
check is unnecessary
Method should be synchronized probably?
Typo
cat > \"" + filepath + "\" ... would be preferable to handle paths with spaces.
Is Windows going to be handled? It probably needs to return 501 from the REST endpoint
Two things: - This change looks spurious - We shouldn't be adding new uses of ProcessBuilder in the codebase. You didn't do this here, but I'm letting you know. We should be using ProcessExecutor or ListeningProcessExecutor instead.
System.out.println ?! Is this the only option ? Isn't possible to use some logging library instead ?
nit: If we make this method synchronized, then this synchronized statement is unnecessary.
this.notify() would be consistent with L63.
this method is called in the src Evaluator, when the data has been sent out. Could it be the case the data type is missing?
Try to use CollectionUtils.isEmpty instead
if you push another patch-set, please replace this with writeElement
It would be good to fix also the typo here ("Memeory").
I think you can replace this with import com.android.internal.util.CollectionUtils; public String[] getLocalOnlyIfaces() { final List<String> list; synchronized(mPublicSync) { list = CollectionUtils.filter(mTetherStates, state -> state.lastState == IpServer.STATE_LOCAL_ONLY)); } return list.toArray(new String[0]); } (note that passing a new String[0] is typically faster than passing a new String[list.size()] thanks to intrinsics, but it's really marginal)
I'm not comfortable with this block of code being duplicated from the extremely similar one in the method below this. Can you find a way to keep this modular?
again, you need to print the state if you want this to be debuggable
IIUC, the reportedConfigurations are relevant just if the networks is out-of-sync. Why passing reported configuration of a sync network? The network may be even moved to another nic, so the its original reported configuration doesn't relevant anymore.
Not sure how that tests your new code. updateLinkProperties() is supposed to manage the new property and to overwrite it. Shouldn't you instead make sure that a LP with the WIFI_WOL_IFNAME interface gets this new property set, and that one with some other interface name gets it cleared, regardless of what was sent through sendLinkProperties ?
You are executing the same code as the previous conditional sentence _(if)_. Is that correct? Is it a **OR** clause?
It seems that we could replace these methods by an AssertJ call. (Perhaps first converting the Issues to Strings using a very simple, clean stream.)
This condition is surprising. At best it will cause some confusion with usage.
Unused variable assignment
I think this condition makes sense. Can you update the code to match the surrounding formatting (hard tabs, and use braces)?
this and step should be private
If I'm reading this correctly, if the AST is not fully built yet, this is going to freeze the UI thread since this is being called from detectHyperlinks. See bug 324232 and CElementHyperlinkDetector for a similar problem. It's probably better to use WAIT_NO and not allow Step into Selection while the AST is being built.
why did you change to final here? should be outside of the scope of the patch.
on your next rebase, returnValue is not needed any more, no point to keep it
this is not good enough, if for some reason the execution will fail before this method is called, or will fail not because of this run, there will be no error for audit log failure.
@essobedo once used variable can be inline
can you change name of this list because 'l' says nothing to me
why is it Collection of Strings (instead of String)?
after you changed that dao call the if condition is no longer neccessary the loop can be removed completely - replace it with use of Entities.businessEntitiesById
this is probably not needed
please use vmDisksSource here as well
Just inline the variable here.
Could this be a single try-with-resources block with two resources and a single statement in the body?
There no whitespace around <=. Also - good to enclose blocks of that that if/else in {}.
Most of the methods are synchronized. What's the point of using ConcurrentMap, then?
Given numUnits, can the driver compute what ranges it wants to move? Did we decide to delegate the range computation to the evaluator?
I may just be missing it but is there a test to validate the setting of the identityProviderId via the get identityProviderId() method. A check on that seems to be missing in this test class?
this condition would always succeed when there is a transformation, because getLayout would return the transformed layout. That is probably not what you intended.
Should we report error for the else branch ?
nit: we could use putIfAbsent here
we should figure out the best way to handle defense against this endpoint being called repeatedly and bogging down the server
(optional) Could decrease indentation with if (!iter.hasNext()) return;
currently you're creating new object in every loop execution, it would be better if WebElement n and nTitle would be created outside the loop
I think we should rename Identifiable. It sounds like an interface, but it's actually a class. Maybe just BaseModel or something like that. By the way Extensible is also probably a bad name. Maybe we should rename it into ExtendedModel or something like that.
rulesList will never be null, widget#getVisibility always returns a list instance.
I know you just re-factored this code into another method, but I am asking myself why the getItem() method is called on the itemRegistry vs itemUIregistry in case of the basicui.
Why are you retrieving data from a newly generated intent? Also, I saw this function is often followed by a putExtra(VideoPlayer.PLAYER_TYPE, can't playerType be made an argument?
Use ?: here suggestion playPreviousButton.setVisibility(playQueue.getIndex() == 0 ? View.INVISIBLE : View.VISIBLE); playNextButton.setVisibility(playQueue.getIndex() + 1 == playQueue.getStreams().size() ? View.INVISIBLE : View.VISIBLE); queueButton.setVisibility(playQueue.getStreams().size() <= 1 || popupPlayerSelected() ? View.GONE : View.VISIBLE);
You can actually remove setName(name) as this is already taken care of by passing name to the constructor. The bug here is that setName(name) is actually called instead of setAddress(address).
I'd like to see tighter bounds on the test. The first 10 invocations should say it is expensive and then is should switch back.
You can cache the value of Application.get() into a local variable to avoid making two ThreadLocal lookups.
Why do we need this? if we really need a different method for Hex Id, then why not _zkClient.getHexSessionId directly return the Hex(_sessionId)? This embeded calls looks a bit weird
Typo? What does this do? If partitionCapacity is null, this would throw a NullPointerException.
Why leave the capacityMap read logic outside of the validateAndGetPartitionCapacity? Note this will diverge the behavior of the check API and real rebalancer API. So maybe, the check pass but rebalancer fails. Let's just keep them exactly the same.
you don't have to do this - you can directly get the PartitionId.getPartitionState() right?
Using this magic string here with the concatenation is a bit brittle. It would be nice if we had a centralized place where the prefix lived, ideally with three methods like: 1. createSourceElapsedPropKey(String): String 2. isSourceElapsedPropKey(String): Boolean 3. getSourceFromKey(String): String The first would only be needed here; the latter two would be used in SourceMetricsImpl.
Why *NodeStartTime* changed during it's request?
All setters with Long as param should check on null since then Instant.ofEpochMilli() will fail on NullPointerException. We should safely set null to the base object instead.
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
newVmStatic ?
Why negated? couldn't you just flip the branches?
Cannot render banner ad. -> Cannot render interstitial ad. AdMob console -> AdMob UI. Please apply this across all messages.
This should be mBannerPlacementId.
I think this is not needed since it is already initialized as false.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
This is the second use of these strings, specifically with a trailing space. It would probably be best to extract constants for them.
> P(i=1:i=N)NP(Statement(i)) NP= (Statement(1)=1) * (Statement(2)=3) = 3
Couldn't this if block move before the other if block? If the data has a size of 1 then the lower index will always be data.size() - 1.
Why did you get rid of using luceneOptions?
||
No need for this.
this constructor can be package protected if it supposed to be used for test only
@olenagerasimova it's not correct usage of Hamcrest-matchers, it may cause inconsistent state of matcher. You can check correct value to describe in describeMismatchSafely argument.
Use emptyList() instead new ArrayList<>()
I would add more detailed information about the sample here:  if (ioSample != null) { parameters.put("Number of samples", HexUtils.prettyHexString(HexUtils.integerToHexString(1, 1))); // There is always 1 sample. parameters.put("Digital channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getDigitalMask(), 2))); parameters.put("Analog channel mask", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogMask(), 2))); for (int i = 0; i < 16; i++) { if (ioSample.hasDigitalValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " digital value", ioSample.getDigitalValue(IOLine.getDIO(i)).getName()); } for (int i = 0; i < 6; i++) { if (ioSample.hasAnalogValue(IOLine.getDIO(i))) parameters.put(IOLine.getDIO(i).getName() + " analog value", HexUtils.prettyHexString(HexUtils.integerToHexString(ioSample.getAnalogValue(IOLine.getDIO(i)), 2))); } } else if (rfData != null) parameters.put("RF data", HexUtils.prettyHexString(HexUtils.byteArrayToHexString(rfData)));
Log in logger, not just print in console.
why do you need to start another processor? The monitor should trigger job model regeneration, shouldn't it?
Same as PR 117: Prefer using mocks for these instead of anonymous inner classes.
check JavaFxUtil.runLater()
I think this could use exactRef()
exactRef
Please use builder.xxx(...) instead of new ....
It would be good to check whether the header was defined first.
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
IWorkbench.getService(ICommandService.class)
Also add group.setType(AccountGroup.Type.SYSTEM)
You don't need all the finals here.
Undetected error condition where multiple groups match the name?
"is handled as if"?
seems worth throwing an exception if the file isn't found, no?
is it possible to use hash here to accommodate the case where gradle cache may have different versions of the same artifact present?
I think we should remove ObjectTriples... Originally, I created it as a Map. Perhaps we can modify ObjectTriplesIterator to TopicIterator that returns a Topic object when .next() is called.
should there be a filter step in here, so only accounting lines without an override code get the value set to none? Just to confirm, do we need to do this target lines?
I haven't tested it, but I don't think this will compile.
With those 2 lines, you'll instantiate a new FilterInputStream whenever this method is asked. Instead, the generated filtered inputstream must be stored as a field and returned if already existing.
Since the "shouldLog" is already checked before instantiation in LanguageServerWrapper, I think it's clearer if we remove it from here now and to assume that any instance of this class will automatically create proxy streams.
possible to using stringbuilder or stringbuffer class, string concatenation is very expensive in Java
Can you use MediaType.PLAIN_TEXT_UTF_8 instead?
It would be also good to set the content length here, if known.
Assert that the parameter has the expected value, just for completeness?
I would have inverted the check but that may be unnecessary
REEEEEEEE STREAMS suggestion if (ess.getSettings().getPerWarpPermission() && sender.isPlayer()) { List<String> list = new ArrayList<>(); for (String curWarp : ess.getWarps().getList()) { if (sender.isAuthorized("essentials.warps." + curWarp)) { list.add(curWarp); } } return list; } return new ArrayList<>(ess.getWarps().getList());
I would prefer ArrayList here, as it's faster, have smaller footprint and we don't need fast insertion in the middle.
missing the byte order: pcapPacketHeader.order(fByteOrder);
Why this one is not abstract ? This implementation is only working with old file, and ng override it anyway
If there are less than 28 bytes left in the file, it returns without advancing the file position. It causes an infinite loop when calling this method from a while (e.g. getTotalNbPackets()).
object -> function?
why removed?
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
is this even necessary given that we use new URI(...) ?
why not use new URI(scheme, host, path, query, null) to make it more clear?
how would you feel about making this an actual URI builder instead of a string builder?
nit: No need to declare these exception types now that we're calling getMajorVersion directly.
how about: assertTrue(new RpmVersion("").getValue().isEmpty())
ah, was going to suggest a test to guard our assumption :) Nicely done !
Curly braces in the same line of if statement. Add spaces between variables and operands, such as cursor != null
Maybe we can consider failedMedias or failedMediaList ?
I don't understand why localMediaId is a string in several places when it should be an int, but as long as it's being passed around as a string we need to play it safe and catch any potential NumberFormatException if it fails to be parsed as an int. The simplest way to do that is use StringUtils.stringToInt().
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
Why can't the action be stop?
So to initialise a single plugin it looks like we do **three** server round-trips; and given you have a number of plugins; opening a Guided Rule Editor instance could be come pretty slow (on a _real_ environment; i.e. not localhost)
-1 would be more correct. AFAIC you can skip this.
This will retain the entire page. I believe you want to build a new Page by calling getSingleValueBlock on each block.
You could just call the other ctor
Let's take this out as the user can already do jwt -> jwt.claim("scope", Arrays.asList(scopes))
I think that means that they'll need to re-enter the 2FA code if 2FA is enabled.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
I would use stronger wording after the last comma, like "which usually leads to bad query performance." (Additionally, I'm not a native speaker either, but I believe you either need a "that" after "Despite" or use some other word, for example "Although".)
The long name should be "help".
possibly we need to look into later, but jupyter is not always python - it could be running R kernel for example, or any other kernel like Spark/Scala etc.
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
You should use .setText("and gains trample until end of turn"), otherwise the text is gonna be all wrong
There are already GainAbilityAttachedEffect, ProtectionChosenColorSourceEffect and ChooseColorEffect. Even ProtectionChosenColorAttachedEffect. You must use existed classes as much as possible.
"Inventory amount" could be extracted as a constant
This is a bit limited since it only supports guava and java 8's. Could we make it more generic? (Unless AutoValue only supports these two, then it's fine. My memory's fuzzy)
Do this check in the constructor instead (or a static factory method). You'll want to be careful in how you calculate the baseType and you'll definitely want to throw if you can't find a baseType for which all elements are coercibleTo. You basically want to find the common base PDataType. Something like the first loop in CaseExpression:  private static List<Expression> coerceIfNecessary(List<Expression> children) throws SQLException {
do we really need this catch block ?
DateTimeZone.UTC
In case if ex.getMessage() is Null for some reason, then the error won't be logged (I know that everyone is using it like that), maybe it makes sense to add method TracingService.logErrorInSpan(span, ex) that will not have this problem.
Please add null check for volume.getAsyncTask()
possible NPE
use runVdsCommand method of superclass
If we'd like to call sendResultToOrigin(operation) when 1) the operation is not from local client, and 2) all sub operations have been complete, then could we change as follows?  try { // L104 if (!operation.waitOperation(TIMEOUT_MS)) { // L106 } else { // L108 if (!operation.isFromLocalClient()) { sendResultToOrigin(operation); } } } catch (final InterruptedException e) { // .. }  I don't think it's a good idea to synchronize a CountdownLatch only for getting the current value, especially when we'd like to check whether the value is 0, which is the terminating condition of await(). What do you think?
Never. The thread sleeps in L454 until all remote sub operations are finished. We can unlock before handling result.
Let's change T to V.
Here is another one.
result seems to be implicitly type casted.
Nit : use isEmpty instead.
In practice, nobody with deep knowledge of EMF uses interface EClasses, but we are technically susceptible to letting them slip through here.
Nor will classes be resource roots.
I would suggest reference.getEReferenceType() here, for pedantic correctness.
Could use return ParameterUtil.toMap(StringUtils.split(processArgs, ","), "="); .. does the same thing.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
COuld this be gotten using @OsgiService DynamicDeckConfigurationService configurationService ... feels weird not using the annotations?
if (f.isCancelled()) {...} else if (f.error() != null) {...} else {...}
There is possible deadlock with the doChangeMasterKey method in order of locks acquire
1. We should add {} braces for each multi-line if branch. 2. How we expect callee handle the IgniteCheckedException we throw?
With the requireNonNull, the null check would be redundant... I think...
"bytesWritten" on similar lines to bytesRead
Not your change, but I think we are doing this wrong. One of these variables should be forced to float; I suspect this resolves to 0 most of the time - with 300KB written (~ average size we see), even with 60 ms send time, this would resolve to 60 * 1024 / (300 * 1024) == 0.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Sadly checkstyle isn't as strict as I would like. We could probably do a custom regex for it.
The list supplier should fail, calling onError and onCompleted this way is just a plain protocol violation. Do something this instead: java Observable.empty() .buffer(10, 10, TimeUnit.SECONDS, Schedulers.computation(), new Callable<List<Object>>() { @Override public void call() { throw new TestException(); } }) .test() .awaitDone(5, TimeUnit.SECONDS) .assertFailure(TestException.class) ;
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
This should return the entity shouldn't it?
I don't get it. If application is null, isn't it to throw a NPE when invoking getStatus?
I believe that this will always return a not-null value, so you could use isEmpty() instead of checking equality to "".
@dkayiwa Are there any visits without patients? Should this not fail with an error?
Where are you calling upon VisitValidator.validate()?
For consistency let's use braces on all conditionals and loops, even if they're one line
Space between if and (
I think this can be called multiple times in the current design, which might cause bad things to happen. Potentially this should only return files that are not already in the queued files set?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
@tarilabs I usually like to check that the ServiceResponse succeeded before doing any other assertions. It helps to quickly narrow down environment issues when the test suddenly starts failing for no apparent reason.
You can annotate the test method with @Test(expected = IllegalArgumentException.class). That way you can remove the try-catch block and the fail(...) call.
@jomarko you are asserting the result to be the string literal "true". The actual result is the literal boolean true. from "true" to true
you can mutialize this code
mutualize code
lambda?
what if input.length is a multiple of 256? wont this add an extra 256 bytes?
It's not at all guaranteed that the filename extension will always be three (3) characters. Simple counterexample: <LINK_0> I'm pretty sure the path structure of the thumbnail URL is stable, so we can probably assume that the second-to-last path segment will be the filename. (and not require any regex)
Does the code that caches the endpoint state (lines 258 through 259 above) execute in the next() case or only in the output consumer case?
Overdid: "foo" is String already :smile:
This is fine during initialization, but sounds strange at runtime. The notNull() throws IllegalArgumentException which doesn't reflect reality for the current message. We should use here Assert.state(), because it is really IllegalStateException during handling message. OTOH I have changed my mind and decided to have this code after one more review:  private volatile Expression expression = EXPRESSION_PARSER.parseExpression("payload"); ... private volatile EvaluationContext evaluationContext = ExpressionUtils.createStandardEvaluationContext();  This isn't Spring Context aware, but lets do not have these asserts at all. Plus such a change reinstates the previous behavior. Therefore the next 4.3.5 will let you to upgrade without issue here :smile:
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
We promise the produce json output. Plain string is not valid json.
Also here. If you let the StateVariableValueTooLongException be thrown but add exception mapper you can keep the return type as CreateWorkflowInstanceResponse
Would it be better to throw the StateVariableValueTooLongException out and add an exceptionmapper instead?
why do you add the tags to the reportModel and the scenarioModel?
Wow...if I'm getting this right, the "transform" simply validates each entry? In that case perhaps simply write:  for (String cidrBlock : cidrBlocks) { checkArgument(isCidrFormat(cirdBlock), "%s is not a valid CIDR", cirdBlock); } Iterables.addAll(this.cidrBlocks, cidrBlocks); return this;  ? Intent seems much clearer here to me...
The jclouds fallback always returns a list (or an empty one). Should we better add some assertion to verify that the list has the expected elements?
doc
BlobProperties already has isEncrypted() which is added in this patch. You can call into it.
why not use BlobId.DEFAULT_FLAG directly here.
what if WebFaultException caused by absence of permissions to execute this query?..., i'd suggest using runQuery() and analysing return-value instead.
1) Please catch WebFaultException (not the generic 'Exception') 2) Please rephrase the TODO in a more informative way: "'getEntity()' always throws an exception if the entity is not found. It should be refactored to make it the programmer's decision. In this context it's legal to not receive a payload for this VM, so the exception is caught and ignored."
- i'd suggest using vm.getGracefulTimeout() in the backed as default instead of forcing all clients to fetch VM and find it out for you?
maybe lets use the new name text?
String#format is very slow. For running perf tests I suggest to use '+' operator which underneath is replaced with StringBuilder or use it directly.
I don't think we need to repeatedly assert isJsonObject in all the tests. After the first one, we've proved the point. Let's only have it for the first time it's demonstrated.
IStateEx or IArgumentEx.
How is this related to [CRUNCH-82](<LINK_0> Would be good to note why it is safer with this and under what conditions it can be removed.
I think this if-else can be replaced with return createTypeConverter(classInstance)
email is still here?
Only admins can search instructors, and we have no reason to hide anything from admin. This line can be removed.
Note that primaryAccounts.removeAll() returns a boolean value rather than inconsistent accounts set.
suggestion filtered = StringUtils.replaceEach(input, searchList.toArray(new String[0]), replacementList.toArray(new String[0]));
Can't this be simplified in  List<String> items = Arrays.asList(idListString.split(",")); ?
why is it adding null?
Why do you fetch the task again?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
@slubwama provide an error message description of what has failed in addition to the stack trace
Usually we use RequestMonitor.isSuccess(). Is there a reason you use the IStatus directly?
Sorry, I forgot that the re-enablement wasn't done automatically. Please set this back to true. Technically, double-clicking on the button _could_ trigger two dialogs to come up, but in this case, the command is fast enough that it does not happen. If you want to see it happen, you can set a breakpoint in the code that executes the command, then double-click on the command; because of the delay of the bp, you will see two dialogs. FYI, the way we handled this before is by extending RefreshableDebugCommand (written just for that case) and mimic the logic in GdbConnectCommand. But it is overly complicated in your situation, which does not need it anyway.
I feel that isM is not mandatory too. But in other hand, the translation of early negotiation in the spec is M=0,NUM=0: _" To influence the block size used in a response, the requester MAY also use the Block2 Option on the initial request, giving the desired size, a block number of zero and an M bit of zero."_
why change the readability status here?
I think we should TRY to move before we update the file path
@vilchik-elena do we really care about that?
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
Exception Message like logs shouldn't be internationalize just use // NLS....
Log the full exception
why did we use cast here? can we change it to -1L?
Somehow I am not a big fan of the name. It is too specific to what it is doing. Tomorrow we might add more criteria to exclusion of bookies (Say based on load etc); i am OK with it as-is but why not the name to me "compileComprehensiveExclusionSet" So it is generic; Anyway.. just a suggestion.
the key set will be modified in #newEnsembel(). It seems to me you have to create a new set from current quarantinedBookies's key set
One of the need for acceptSession() API was to show user that it can fail. if session does not get accepted they need to do something? Either go to next session or have some code to log message about it.
Remove these debug statements and dofinally.
Why is this thread.sleep here?
if the original is missing should we not just add the new copy?
I would change this like to return Utils.copyAttributeToVirtual.......
Could use a regex instead of two calls. Ex. toString().replaceAll("\\[|\\], "") We might also want to make sure that [ and ] are not allowed as values - if they are allowed, we need to make sure that we're only replacing the first [ and the last ]
Isn't it enough to mark the RealmChangeListener interface with @Nonnull ? Doing it at every call site seems a bit excessive?
Perhaps refactor looperThread.realm into its own variable:  Realm realm = looperThread.realm; ...  It makes the tests easier to read.
Please convert this constructor and the one above it into constructors that delegate to a single, third, constructor.
style nit: add a space after if
Instead of loading the classes here, why. not just iterate over compiledObjects.values()
The second parameter should be set to false to avoid excess startup overhead.
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
minor: could you add disabledReplicas as well?
This change is on purpose ? or just automatically re-create the toString() ? I remember those fields helped a lot in debugging scenarios (and IIRC this method is invoked on tracing/debugging only contexts).
useless
useless
Please simplify this just to nameModel.getObject() because it is a bit confusing at first sight.
why not instanceof ?
You could merge this for with previous by using TmfTraceManager.getTraceSetWithExperiment(trace)
{ on the same line
Can be delayed to after the following check, avoids creating the strings unnecessarily.
This is the same as isSMimeEncrypted except for checking for a different value of Content-Type, so you should create a common method that takes APPLICATION_PKCS7_MIME or MULTIPART_ENCRYPTED as a parameter
How about adding the toLowerCase() here and then it wont be needed later?
Shouldn't those line be removed?
Please return the break
You can use the 2 parameter Vlan ctor here, instead of setters
checkList ? u mean errors ?
Should this mention why it isn't valid, something like Value [%s] must be of type boolean for path [%s]'
this is a bit oof but #justjavathings
@Oak committers: Would it make sense for SessionContext.getValueFactory() to return ValueFactoryImpl right away, so we don't need the cast? SessionContext always creates a ValueFactoryImpl in its constructor, and AFAICS SessionContext is an internal object that isn't required to stick to the API interfaces (but I might be missing something). Alternatively, we could add a new interface BlobValueFactory that ValueFactoryImpl can implement, and which would provide Binary createBinary(Blob) and String getBlobId(Binary) (used below in getHttpDownloadURL())..
Result of replaceAll is ignored. Please, assign it to a variable. suggestion maxUploadSizeString = maxUploadSizeString.replaceAll("\\s+", "");
How about check that whether digest.getSizeBytes() is the same as chunker.getSize() at the beginning?
Don't need to call deleteOnExit
This should be part of the try-with-resources block.
I just realized that bos isn't used for anything. You should remove that, and I'd suggest instead moving the declaration of writeFile into the try with section so it gets autoclosed
Should it be "if (numConnectAttempts >= maxAttempts) { ... }" ?
Thread name should use actual port.
Can you try swapping below two lines in DefaultBlockWorker::stop() instead of this logic?  // Stop heart-beat executors and clients. mResourceCloser.close(); // Stop the base. (closes executors.) super.stop();
Rubbish
Please remove this line
Also works with a ternary operator: setTitle((cond) ? title1 : title2)
int mapSize
Remove the blank lines. The "break" statement provides ample vertical space for readability.
Need to just add a assertEquals(i, range - res.size()); and these should be good.
Are we sure newValue is always non null?
could you remove isValueEquals method (line 89/90)?
This is not thread safe. Is it guaranteed that this will only be called in a single thread? Does this guarantee still hold if Nimbus is sweeping many products at once? We should either make this safe or make it very clear to our future selves that this is an issue we need to fix.
We'd better not fail here and just return null.
Why is there a space between function name and parameter? AFAIK it should not be there  checkFBMD (String
Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?
assertThat(build.getConsole(), containsString(customWorkspace))
Shouldn't there be also a check that old name does not exist anymore?
We're just swallowing this?
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
createPackage mapping should take the toolsection in parameters and create a ContainerCreationDescription tool.
baseId +diagram
Why is it better to use more than one scope to test?
A single test shouldn't run the context twice ideally.
@domhanak TL;DR: simplify to assertThat(mavenRepository).isDirectory(); Just 3 nitpicks about assertj usage: 1. The whole point of SoftAssertions.assertSoftly is that you don't have to thing about calling assertAll at the end (it does it [internally for you](<LINK_1> 2. You don't event need soft assertions for doing multiple asserts on one object, you can just do java assertThat(x).assertionMethod1() .assertionMethod2()...;  3. The assertion isNotNull() is redundant, because most assertj methods that rely on object being non-null [call it automatically](<LINK_0>
Shouldn't it be logged in debug only?
What about this else case. Here also scheduling fails but we are not showing any error?.
For mocking (even if not now) purposes I would rather have a getJobDao() method instead of explicit singleton call here.
Let's not send BAD_REQUEST for Remote exception. We can throw a RestAPIException for that, since it will be an internal server error.
I think it should be the event type name rather than /event-type here
Why do we want to have runtime exception in the signature of the constructor?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
I think that if (in == null) return null is a slightly better way to deal with this...
Who is responsible for closing the streams? In the normal case, and when there are exceptions?
1 -> numInputChannels ?
Use LinkedList instead, as we need to remove its head frequently in endInput.
lastReadInputCheckpoint is never used anymore. Could you remove?
one-liner
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
} else {
Unless this needs to be protected it should be made private
Unless this needs to be protected it should be made private
Missing final
Consider to use negative condition here, so it will just return false when the super CDA will return false. Also use the formatter on the if condition (add space between the if and the call to super)
Don't know if this is just a gerrit foobar, but the indentation seems fishy here.
This is no longer paramConnection, just connection.
suggestion Assert.notEmpty(query.getIds(), "No Ids defined for Query");
Let's stick with T instead of Optional<T>. A huge number of folks already asked us to roll back the Optional change at findById and Optional isn't being loved that much.
What is the difference between queryForPage and queryForList?
formatter
I think you should filter out clusters with undefined architecture, in order to prevent the user from making mistakes and receive a failure in the canDoAction() of the command later.
getDataCenterById query shouldn't be called on each disk selection. Instead, call it only once - per VM selection (on setEntity method). Can be fixed on a separate patch, but please don't forget :)
can you also test the case with begin > end?
so is everywhere using sample_value for human calling method?
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
This is strange. Why would we go to the preference store of the Linux Tools Docker plugin when we are fetching an ID that is defined in CDT? I believe the prefStore should be the one from DockerLaunchUIPlugin, no?
This new getImage interface is based on image id whereas the RunImage launch configuration and wizard seems to be using image names from the pull-down. You are asking for image name above and using it to feed to getImage().
All configuration attributes should be taken from the model, not the widgets.
Isn't a LinkedList better if we don't know the size (to reduce reallocations and copies)?
Just a suggestion but I think this is a bit more readable and Optional is a bit nicer to work with than explicitly passing nulls around:  public static Optional<InetAddress> getLocalLoopbackAddress() { try { for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) { if (iface.isLoopback() && iface.isUp() && !iface.isVirtual()) { for (InetAddress addr : Collections.list(iface.getInetAddresses())) { if (addr instanceof Inet4Address && !addr.isMulticastAddress() && (addr.isLinkLocalAddress() || addr.isLoopbackAddress() || addr.isAnyLocalAddress())) { return Optional.of(addr); } } } } } catch (final Exception e) { LOG.warn("getLocalLoopbackAddress: an exception occurred while attempting to determine the local loopback" + " address.", e); } return Optional.empty(); }
will this be used outside this class? if not, make private
The detach was done because info was retrieved after deletion. I swapped things and retrieved the info before then it went fine
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Here you test findByName method. I believe the bootstrap is better to perform not using EventTypeRepository, but just using jdbcTemplate or prepared statement.
fos can be inside try ()
This is also a problem on linux. When leaving /dev/null it works.
The Exception message should contains the original IOException ?
final
tokenCacheItem.getUserInfo was checked for null earlier. you should add it back
NPE if getUserId returns null?
what does -1 signal here? i don't see a good explanation of this in the solr docs
Detail: FROM capitalized.
This becomes unreadable with so many chain of logic operations and ternary blocks. I believe proper if statements would be preferred and more readable
Need to use parameterized logging instead of string concatenation. This should also be a warning and not an error.
This changes logic paths for SSLD devices as well. Some time ago an UnregisteredDeviceException was thrown when a device was not _activated_. The change in behavior to throw an InactiveDeviceException in such cases has been discussed with @kevinsmeets. Now with the check on whether a device is _active_ the logic for throwing any exception does not take _activated_ into account. Updating and keeping a proper value (and meaning) for all these status fields (here isActive and isActivated) has to be clear (and tested) across all domains.
At line 99: instead of throwing an IllegalArgumentException can't we throw a FunctionException !?
Remove extra semicolon.
Having execute{Head,Get,Post,Put,Delete} are just wrappers to execute() for convenience and readability across APIs Spreading the logic of type checking will lead to confusion in future and its not a good idea.
Why is ssec not used ?
Good spot! We could actually do this: java authCardDetails.getAddress().map(AddressEntity::new).ifPresent(addressEntity -> { //   });
java this.billing_address = cardDetails.getBillingAddress().map(Address::new).orElse(null);
Minor, but could you make the height and width different? It provides a little bit of protection against the values being accidentally transposed.
34 and 36 should be in one line
How are you confirming that the stop date and time of the visit is set?
same as below use test class field visitService
assertThat(entries).hasSize(3); the same for several occurances below
assertThat(c.getParentCount()).is(2);
Use "assertEquals(List.of(bibEntryExample3, bibEntryExample4), entries)". Hope, this works. Otherwise, a conversion to a set and comparing that could work.
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
.toString() isn't necessary. + will call it for you.
Looks like this toString() got generated before the tags field was added :P
How about passing in groupBy instead of just groupBy.isUngroupedAggregate() as I think we'd want to get more info eventually out of the groupBy (for example, if it's ordered or unordered which impacts memory usage substantially)?
It seems like this happens even if there is no filter. Is that right?
lower case notation more frequent 0d, but its up to u of course.
Typo #xpected
seems like this could benefit from using your new flattened method (once moved elsewhere like I suggested) eg. for (plan : plans) { found = flatten(plan).findAny(p -> id.equals(p.getId())); if (found.isPresent()) {return found.get();} }
static import graphvizLogicalPlan
replace with persistCommandIfNeeded
please have all the mutual behavior (locks/check if the execution has ended) in performNextOperation()
this is relevant only for live merge (after we modify the command parameters)
Is Itemizing (or promoting parts of) request option, to limit to applicable ones?
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
Why decryption is excluded?
Extra space again
This does not cause performance issues? <LINK_0>
Is this needed?
Do we need String.format here? Seems like String concat would be fine.
other methods like this put name first, then id. switch for consistency
You forgot to add the address to the toString() as you did in the patch on the master branch
ps is not closed. Should be DbUtils.closeQuietly(rs, ps, connection);
entity
Can you add some error handling for the username parameter? Such as:  java if (username == null) { return Response.status(Response.Status.BAD_REQUEST) .entity("'username' query parameter is required for getUser").build(); }
Don't put chatcolors into the block data :NotLikeThis:
Use if here instead. We don't nest LazyBlocks
- partitionCount and geometries variables are not needed - no need to use makeGeometryBlock method  Block geometryBlock = GEOMETRY.createBlockBuilder(null, 0).build(); Block partitionCountBlock = BlockAssertions.createRLEBlock(10, 0);
guessing this block of code also repeated: private static SSLContext createSslContextFromTrustManagers(TrustManager[] trustManagers)?
why is this public?
what is the testcase trying to do or what verifications are expected
Please do: acitivity.startActivity(CreatePostActivity.newIntent(activity));
You could use getEndTimeAsZonedDateTime here for simplicity
We have such code in Application.onCreate(). Why do we need it here?
Variable naming. Be consistent across the entire codebase. why sc? sock or socket?
@exper0 why empty?
@sebing let's use try-with-resources feature here since we're now on Java 7. Make sure to include both input and output.
error message should be changed to reference actual problem of "not a leap year". See existing implementations.
resolvePreviousValid(...) - to better guard against future failure, don't check day-of-month for year-day/leap-day, just coerce it:  if (month == -1 && isLeapYear(prolepticYear) { return createLeapDay(prolepticYear); }  (because there are situations where day-of-month may not be set). Month/day-of-month can't be out-of-range, and don't need the full checks (ie, just instantiate via constructor, don't route through static factories). The whole point of this method is speed and leniency.
Please add on-demand static import for Calendar.
can be replaced with String configValue = StringUtils.removeEnd(config.getParamValue(), "%") which basically does exactly the same.
Can't we throw here something more meaningful? Where are you using this query? how does it feel in this case?
if volumeId is null then we will have NPE here i think its safe to send null to getById method, no? if so then the null check on volumeId can be removed and this will prevent NPE
Why is input generator called modifier??
if original does not have a line, do we want to still set our line?
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
if(!(o instanceof LegalInformationComplete)) is better, will not break the equals contract in case of inheritance.
Why include the name in the comparison? fullName should be enough.
Is this meant to compare the item stacks beyond object equality, given ItemStack does not override equals *or* hashCode
No worries... we have all done it a bazillion times. :smile:
Better initialize in an else block
Why an array? List<String> is just as fine
same here about this.
HashMap should be good here I think.
HashMap should be good here I think.
These two lines should come before the if. (Remove in the other branch.)
can we set some UTs for this function
Why return as an object ? Wouldn't it be better to just return a String[] ? Saves the trouble of casting ?
overall the commit is very good, but this method might be misleading - it doesn't set anything if the field belongs to a probe.
Same concern as above.
I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
We need to solve the problem with the _extraction result column_ name that you mentioned previously. I see that you are renaming the result of the _extract_, but that will not be enough. If we do not solve it but we check this patch in, this will result in incorrect results in those cases, right?
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
This should be replacable by switch (solverStatus.get()), as all the actual state mutation happens in solvingTerminated()/solver.terminateEarly() as I've suggested above.
either was not submitted or already finished solving?
Misspelled 'failed'
since we did not advance so the event is not thrown away really.
It doesn't seem very reliable to me, because sometimes interruption status may be consumed (due to bugs). So in addition suggested to add "stopping" flag to RealtimeManager and check it here in addition to interruption status.
can we flip this around for readability's sake and put the isIgnoreInvalidRows outside the if?
@bharatviswa504 can we make some test utility methods for this that hide the detail that table/cache are being updated directly?
OMAction should be APPLY_ALLOCATE_KEY.
keyName can be used here, as keyPath was derived from that.
Make this an assume
you can create a temporal file by using FileUtil.createTemporalFile instead of handling by yourself. If you need to do this way anyhow, you could probably add a delete in a finally sentence
fail
We should have tests that pass FieldAttribute.PRIMARY_KEY or FieldAttribute.INDEXED.
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
Wrong condition. I think you like to check if (predication == null). Also, better call the variable predictionField.
can this be turned into lambda?
Also notice OpaqueObjectsNode.java needs the same treatment.
this usage does not seem very fine
They are mutually exclusive? Or is that a micro optimization?
Now we have isEmpty method for Strings in Utils. Is it good idea to use it here as well? <LINK_0>
Fine but you should then add FormValidation DescriptorImpl.doCheckName(@QueryParameter String name) so that users of **Pipeline Syntax** will see that a _proposed_ step configuration is invalid.
start
ms
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
A bit a matter of taste but I'd remove the spaces here around the =, it would look more consistent with the "Contents" column, i.e. field=123, foo=345
You can also use single quote '[' to avoid putting //$NON-NLS-1$ at the end
If we continue to use a StringBuilder here, we should use it in a way that makes sense.
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
same here: why storage exception?
It can be written as return restTemplate.postForObject(verificationUrl, request , JsonNode.class).path("success").asBoolean()
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
can this happen? why not checking before cloning the whole list?
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Something like:  if (this == object) { return true; } else if (obj == null || !(obj instanceof RowProcessingStream)) { return false; } else { return Objects.equals(_analysisJob, other._analysisJob && Objects.equals(_table, other._table) }  Seems quite a bit more readable to me.
suggestion if (o instanceof PredicateEvaluator) {
This equals implementation should include attributes from the Command super class.
Is it worth moving the reporting out of the synchronized block (though I wouldn't expect convention on that span)?
for these down, you don't want to early return as they remove data from the map (we want that data removed even in noop in case a span started before the tracing component was set to noop status)
Should this add the attribute if the parsed name is ""? It appear in the policy it doesn't.
This array must be calculated one time only
We could simplify the operations a bit (read delegate length, subtract 1 and subtract i) like this: java final int length = delegate.length; for (int i = 0, j = length - 1; i < length; i++, j--) { arr[j] = delegate[i]; }
This method sums over the second and third dimension.
Use logging instead of e.printStackTrace()
Can we define a final CONSTANT for the MD5 ?
This is not an illegal state, and this is the wrong exception type to use for this problem. How do we know SHA-256 is supported? Does the JDK promise this?
We should guard this with if (mEndTime != null) and in the block, return false if it fails.
Is the idea to wait until all the threads are done before assigning any new work? That won't be optimal since a long running partition can keep the other threads idle for a while.
I think the granularity should be 1 seconds instead of 5 seconds here.
please consider instanceOf check?
out should be closed.
This is a bit dangerous, as you may match *anything* that is ending with /monitoring. Example /myapp/roadmap/monitoring ... will end up in JavaMelody instead of displaying (example) the monitoring stations of a road-map :-)
You can use CollectionUtils.toImmutableList
This filter lead to me to look at the factory again and ask about why/where the exception would be thrown! It seems strange that a factory could NOT return a concrete object.
Wow. This method is much more elegant that it was before :tada:
I think this one can be defined at the time declaration as well. Please make it final.
nit: In java, only constants should contain _ characters
You can avoid String.format inside logger and use the formatting specifiers directly
@bxf12315 same as above, please use assertThat.
@bxf12315 the same as above, please use assertThat from the AssertJ library.
suggestion to retrieve the actual column from the table.
Here should be NOT_INCLUDE_DEFAULTS
Please rename to something like originalDirectBuffersResult or at least originalResult.
Renaming it to origValue would make more sense as you've changed it from default value to actually the original value, which might be also undefined value instead of the default value.
return new StringBuilder().append()....toString();
return new StringBuilder().append()....toString();
The default toString on the List doesn't do the same thing?
use constants.
Why we should change behavior for the deprecated method?
Would it be helpful for debugging purpose to log out a statement when this method is called. This way, we can easily tell from the log.
why not process all files?
Should we be caching the scaled image as long as height/width don't change? Or do we scale them a lot?
Should we put the resource.getInputStream() inside of a try-with-resources block so we don't have to manually close it after copying?
You can change the 28 case to a default case, and remove this.
Should be moved with other not treated cases
Gson doesn't run on these versions so I don't see any reason to include them.
I am not sure but maybe it is better to save result, and close outputStream. i am not sure
catch and rethrow IOException catch and properly handle all other exceptions as .handled().
should this be package private?
{} missing
Can you try swapping below two lines in DefaultBlockWorker::stop() instead of this logic?  // Stop heart-beat executors and clients. mResourceCloser.close(); // Stop the base. (closes executors.) super.stop();
- [ ] You may select log level debug or trace. Because the developer intensionaly sleep thread and InterruptedException has no meaning here.
is this check necessary?
!isEmpty
highlight this and extract maybe into a method that return bool
I think we should TRY to move before we update the file path
map is also whitespace separated, so should be not split on tabs only
I guess that this test cases should also be with intervals only.
I don't think this will work if the claim name requested is a standard JWT date field, because that value is required to be in seconds (not millis) since epoch. In other words, if I do:  java claims.get("iat", Date.class);  It should work. In fact, the other get\* methods that return a date should probably delegate to this method so the behavior is guaranteed.
ParseUtils.isQuoted would be good for this.
In driver 4 the contribution guidelines mandate that if/for/while blocks must be enclosed with braces. Same thing for the line below.
If the store is already started, I think we should return true. Same for stop (return true if the store is already stopped and don't try to stop again)
please double check that marking the end of things are being done in the right place (that is, do it in the finally if you want to cover all exit paths).
deregister after the log is closed?
Use constant
What happens when an exception is thrown before sc.close()? Could this lead to a resource (descriptor) leak?
> Sorry @javornikolov but I didn't understand what you would like to test. These are all the rows that exists in query 2 but not in query 1, so they all are marked as error (missing) and are chained to each one, and the first is chained to the last rows processed. > How can I help here? Sorry. I think I described it the other way around. I'm testing with following and I'm getting only 1 missing row, when 3 are missing:  !|Execute|create table TESTTBL (N int, TWON int)| !|Insert|TESTTBL| |N |TWON | |1 |2 | |2 |4 | |3 |6 | |4 |8 | |5 |10 | !|Store Query|select * from TESTTBL|q1| !|Store Query|select * from TESTTBL where n in (1, 2)|q2| !|Compare Stored Queries|q2|q1| |N |TWON?| !|Execute|drop table TESTTBL|
why not set serverCnxnClassCtr to NIOServerCnxn by default to avoid looking up the right constructor every time we want to create a new connection (a bit of a hot path)?
isTraceEnabled is missing here?
What about having a loop that checks for the expected value, with a 100 ms sleep? This will make the test faster and less flaky Maybe we'd better have an utility method, but can we do it in a separate work
I believe this line can be replaced with DMContexts.getAncestorOfType(ctx, IExecutionDMContext.class)
Should we make it easier to overwrite version parsing for custom GDBs by adding a new method: parseVersion(String text), for instance? I think it's quite common for vendors to have their own version formats. What do you think?
Use a guard condition to reduce nesting
Suggestion: "--active and --inactive options are mutually exclusive."
more clear to put in this way: !containsMacro(Cassandra.USERNAME) && !containsMacro(Cassandra.PASSWORD) && (Strings.isNullOrEmpty(username) ^ Strings.isNullOrEmpty(password))
Are you sure that String.format is one of the effective ways to concatenate three strings together?
Map
This is actually the session request body, not the cookie body.
suggestion private static HandlerRequest<EmptyRequestBody, TaskManagerMessageParameters> createRequest() throws HandlerRequestException { Map<String, String> pathParamaters = new HashMap<>(); pathParamaters.put(TaskManagerIdPathParameter.KEY, TASK_MANAGER_ID.toString());
need type name
We should throw. I think this method could eventually go away.
same question
Perhaps we may as well add the sequence number below to this message.
This function is called in line 432 of Sender as well, should the return value be evaluated there?
nit: not from this patch, but topicPartitionBookkeeper.topicPartitionBookkeeping is really annoying. Maybe we could rename the field to just partitions?
Let's move this line below, just before the requiresFBO line.
ResourceUrn into static final field please. Here it is not strictly needed as this would be the only usage, but it would make this node more consistent with the others and it will be easier to eventually make a big bunch of all of them and handle things differently.
This line can go with the playerCamera line below. The following line can go closer to the block starting with the requiresFBO line.
formatting
Locally, a ./gradlew test now fails on many tests. Does it work for you? I believe this test keeps a server running. Is that indeed the case? If so, please ensure it is cleaned up after the test completes...
Is this fixed to 20 seconds deliberately? Why not use reuse the default from ProxyConfiguration?
can be static
Should be findValue() not findField(). This will then default empty schemes.
I may just be missing it but is there a test to validate the setting of the identityProviderId via the get identityProviderId() method. A check on that seems to be missing in this test class?
Should we consider other measurement units, like kg?
What if the string doesn't end with a " or '? You'll strip the last character.
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
There is no need to mock api calls to implement this test.
There is no need to mock api calls to implement this test.
Try to avoid conditionals like if (condition) return true else return false. Just return condition.
Do we have only two types of disks? Even if we have, this code will fail when we add another type. I think we should check for LUN type before trying to update one.
I don't really see any reason to add this else, but if you already decided to add it, it should not be in the execute phase but in the CDA phase and prompt a proper message to the user.
You should use if (!isDiskImage())
This is fine but I would prefer iterators[i++] since that is a much more common style in the code base
Please use static imports when qualifier neither add any context nor improve readability. This is also true for Values.isGeometryValue().
I think IllegalArgumentException is better at least.
It feels to me that there is much code duplication between this and DateTime.truncate
This expression (nano % 1000 >= 500) is used in more than one place, why don't extract it to a function?
invokeExact is @PolymorphicSignature, thus can return primitives directly. If you change (Long) to (long), you will be able to avoid boxing, and you will be able to use the more efficient invokeExact.  return (long) getLocalMillis.invokeExact(localDateTime);
Under some conditions I'm running here into an StackOverflowError: java.lang.StackOverflowError: null at com.google.gwt.user.client.ui.TreeItem.getChildCount(TreeItem.java:371) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:538) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:528) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:310) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) ... One scenario in which I'm getting this error is when I filter for projects having the parent 'parent2' while having the following project structure: -- All Projects -- -> parent1 -> parent2 -> (project1, project2, project3)
That doesn't look correct. Should be currentNode?
this is rather arbitrary... why the limit? we are always going to be able to get up to the basenode given that the childNode is guaranteed to be a descendant
This variable is very badly name if it's supposed to be the serializedUserReference.
why is it Collection of Strings (instead of String)?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
also these *xx things should be constants.
minor typo: SEPARATOR
The call to super() is unnecessary.
return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM) if it needs to be modifiable - add new ArrayList<>(...)
Here should contains all the process type which may contains CDP DISTRIBUTION. e.g SPARK_JOBLET,SPARK_STREAMING_JOBLET,TEST_CONTAINER(only spark process related) Please ref to: public List<ERepositoryObjectType> getTypes() { if (ERepositoryObjectType.PROCESS_STORM != null) { // test if spark streaming is available (not the case with TBD license) return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ERepositoryObjectType.PROCESS_STORM,ERepositoryObjectType.SPARK_JOBLET,ERepositoryObjectType.SPARK_STREAMING_JOBLET,ERepositoryObjectType.TEST_CONTAINER); } else { return Arrays.asList(ERepositoryObjectType.PROCESS_MR, ,ERepositoryObjectType.SPARK_JOBLET, ERepositoryObjectType.TEST_CONTAINER); } }
Better to not use a list here: Queue<Type> next = new ArrayDeque<Type>();
Unless I'm reading this wrong, if the user provide a rootPath ending with \* this will add another /, then it will add another *. We shouldn't add the slash if it already ends with *
for this to work well with router nodes, filter implementations must be able to handle async servlet request propertly. Maybe we should add a note in the ServletFilterHolder on that.
wow, what does this mean?
Please return an empty RepositoryDTO here
remove!!!! please don't use sysout (unless you remove right after you've check what you wanted to check).
I don't think you need that here, the publisherService.publishCategories() is more likely what should consume the model and pass the categories to the right method to get them generated.
It's advisable to start variable names with lower case
If there is a problem with one of the channels this would just silently remove that one. I think we should let the exception out and make the whole Source removed from the config.
This class shouldn't make a dependency on specific implementation details. That could be handled within the existing updateState. Also I'm not sure if it's tread-safe or generally good to allow the caller's thread access and modify the channel object... (it seems that everywhere there's a barrier of the thread executor queue).
@dmzaytsev try to use org.apache.commons.lang3.StringUtils#join() here. It could be more visual
Put a new line in after every \n to make this readable. Or alternatively put the blueprint in a file in src/test/resources/path/to/file.yaml and load it with new ResourceUtils(this).getResourceAsString("classpath://path/to/file.yaml").
Would be better to avoid ".jar" here, Remotig lib may have another name && may be packaged into WAR/*.jnlp/whatever
why?
I personally prefer to check once if(!(obj instanceof Attribute)) instead of two checks for null and class.
not sure that the outerType is needed as we are trying to compare two Host instances
Can you also include the workspace ID in the message? Just in case.
brokersResult.brokerResult looks a bit unclear. Please consider renaming to something like addResult, registerResult
2 lines up workspace ID is fetched too. Can you move this assignment higher and reuse the result?
You don't need to set the Id here as it's done in the setup() method (but does no harm and makes the test clearer!)
unnecessary line break
any reason you have to remove these, the methods are the same i guess
@tbagz104 i guess you should make the links as a string resource and refer them from the strings.xml file. and please remove the extra spacing present in this file
I think you are right, exception best fits this case :).
Can we either do ACB & ATL, or CERTIFICATION_BODY & TESTING_LAB?
This class has no superclass, so I'm not sure we need to call super() here.
You shouldn't be modifying EventRefs in place even the model allows for it. We want our models to be immutable and someone could change content.events() to return a copy of the internal collection. Instead get the events collection, modify it and set the value back in Content
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
Please rename this to eObjectMatchEngineFactory or something closer to the real use.
Can you call initialize on all of the engine's dependencies here instead of just the metrics one? It'd be nice to have that option for everything.
So we change the default conflict detection engine when calling EMF Compare through API, but not when invoking EMF Compare through the UI. Isn't that inconsistent?
is it possible to use hash here to accommodate the case where gradle cache may have different versions of the same artifact present?
space
You're welcome! As you noticed the the wrong error message was a consequence of the wrong comparison. Since isNameValid(name) was returning true when it should be false, the second if statement on enterPressed() was executed causing this bug.
why synchronized?
The interface docs specify this should be a read-only reference; should this be transformed into an ImmutableMap or copied before being returned?
The base implementation should throw UnsupportedOperationException, since the feature is always provided by an overriding method in a derived type.
Extract properties.getRest() into a variable.
Not clear to me. If this instance is already instantiated then this Object cannot be other thing than a Access Token. If the underlying logic is creating an AccessToken when the JWT is not really an access token then that is a bug. This class should not have to check anything. It should always return true if it gets asked "are you an access token"? If there is a chance that this code ever returns false then this is a bug. I think this method must be removed. What I would do (if necessary) is to have the constructor asserting the JWT, that way this object will be never created unless the jwt is really an access token
space after if. If it's not materialized, then nothing happens here. What's the circumstance where the access token would not be materialized? Is it an error if this method is called and the access token is not materialized?
better at least add a debug logging here
Add log.info "connecting to ATSD at host:port"
Could you format the code in intellij?
I would say just Template expressions are deprecated for ExpressionRetryPolicy . We really can't say *literal expressions* since that is going to confuse and users just because there is really a LiteralExpresion to return just plain string all the time. So, we can't say that here to bring end-users in the situation when they may decide that this is trealy going to be only about simple strings.
I believe those parenthesis around conditionalExpression are not necessary
Summary: 1. Removed @throws IllegalArgumentException when alias is null. as it is not required to declare throwing a runtime exception. We haven't declared this in other places e.g. Database class as well. 2. Remove an extra empty line before if(<variable> == null) {. 3. Add a space between if and (. Should be if (<variable> == null). 4. Add . (full stop) at the end of "... is null" -> ... is null. 5. Do the same for the other methods.
I don't think this optimization of repacing .equals by '=' is correct. I suspect there are cases with dynamic metamodels where we won't have the same instance of feature on each side of a comparison...
It seems .equals() has been replaced by == I believe this may be a problem, because it assumes that the same instance of meta-model is used on all sides, and I believe this is false in some weird use-cases (with dynamic EObjects involved). I may be wrong, @laurent.goubet should know.
Can be replaced by List<FeatureMap.Entry> entryList = Lists.newArrayList(featureMap.iterator());
NP: As this is now abstract, it should say "...json data for component ...".
isn't used...so perhaps do not set?
Would the new Path, FIles API be easier to use than the old File API?
you could do i++ here and remove the line 1886
Is having Utils.Infinite_Time here ok? Should we add a valid time?
do we need this check. Guess the next condition should encompass this (implicitly). Anyways, just a suggestion
@xpdavid is this the right thing to do?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Minor, but can you create a util function that checks if key.getOffset() == 0 && key.getLength() == key.get().length and then just use the byte[] directly rather than copying? You can put it in ByteUtil.
This resource needs to be managed and disposed when appropriate. Sometimes we use org.eclipse.jface.resource.LocalResourceManager. It also might be appropriate to change the org.eclipse.e4.ui.internal.css.swt.definition.IColorAndFontProvider interface so that it becomes responsible for managing the resource, if that can be done.
Please add a check here that would simply return if the color being set is the same as the current foreground color (linkColor).
Please version guard this check with < 3.16.0. Playing too much with css esp. when every theme from 3.16.0 is just css is dangerous.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
Drop this ImmutableList.copyOf wrapper. It reduces clarity and we do expect random-access lists here anyway.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
suggestion }
not sure if this makes sense, the query is  Select floor(\"__time\" to YEAR) and the result is T=1420070400000 isn't we should expect something like 2006-10-01T00:00:00.000Z? Do we have to add a cast? is that the SQL standard or this how Calcite handle such queries? @jcamachor and @nishantmonu51
@Serranya same here. See above.
@raphaelln I'm not convinced about these finally blocks... Can't we just invoke multi.body().close(); without finally?
@Serranya use JoinedText to break this line and remove the checkstyle supression.
Perhaps the '104' could be a constant?
Should we build the entire bean and just do .equals for validation?
What is the use of the last assertion on line 69?
Please rename this layout file as well removing _new_api.
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
Needs a better error message.
Why not prefer the new one (spec) if it's set?
suggest rename to innerHadoopShardSpecLookup - "hadoopy" is easy to mistake for "hadoop" when someone is reading this code
if we make this an arraylist, can we just pull from the list directly and avoid the map?
I am failing to see the bug. You will be iterating while (responses < commitList.length). CompletableFuture.anyOf() will be invoked for all CF which do not execute exceptionally.
I don't understand why we need to explicitly handle TimeoutException here. What about NetworkExceptions and other exceptions? Besides, the caller of this, namely BootstrapUtil.bootstrap() already logs and handles all exceptions: <LINK_0>
Log for both catch blocks or neither.
Minor: please move private utility methods to bottom.
Remove throws Exception
speces before and after "+" :)
You can do BuildTrigger buildTrigger = BuildTrigger.forUser(username.or("unknown"));
what do you think about instead logging it where the other log statements go here? <LINK_0> I don't think passing a listener down to the publisher is great as its mixing two concepts, the listener has nothing to do with it
You could try the method getLastBuild(ObjectId sha1) of the BuildData and pass the result of getLastBuildRevision().getSha1(). If this works we would get rid of the ugly reflection stuff.
I don't think this is the right test... you should do something like if (superclass instanceof ParameterizedType)
Why return as an object ? Wouldn't it be better to just return a String[] ? Saves the trouble of casting ?
Check if byte[] b is null.
You can replace the for loop here with values.forEach(result::add);.
this seems like it should be exception != null or result == null
callback can be null.
As mentioned above, why don't we making it a non-static method?
any reason we are rounding up/down to the nearest integer?
add a message in case it ever fails
velocity..
You can just let the loop below handle the waiting - it'll all be logged, then.
also incorrect.
The error message doesn't match the actual behaviour.
Should be moved with other not treated cases
Less error prone to iterate over values().
Extract this try-catch block to a method to avoid code duplication
It is just my personal taste that I dislike static methods: they are harder to mock. Were these non-static methods, one could mock them the usual way.
I'm not seeing the added benefit of this one since AuthenticationWebFilter displays the same information. Is it necessary?
These variable names are pretty confusing to me. @haozhun you have a quick suggestion?
Use more values, 4-10. See TestBigintType, TestVarcharType, TestBigintArray for ideas.
nit: you can return in the if block and get rid of this else.
Is this line always safe for NPE?
nit: Can this message be improved to state that one of them is null, how about "Either EnvironmentDto or NetworkDto is null. Neither them can be null."
Please remove the if here and use the composite pattern to determine the specific cloud-api that is needed to delete the prerequisites. Move every azure specific implementation to the cloud-azure module.
Use .isEmpty() rather than .size() < 1
why is it Collection of Strings (instead of String)?
I think we should not return an Optional here. We should return an empty list instead.
Unnecessary else.
@aschworer same here, once used variable minTime can be replaced by delay
@aschworer why we need this variable? it used only once
action should fail when a problem with post request occurs, so please throw this exceptions
What's the purpose of logging and throwing exception? By checking the calling stack, I don't think it is necessary. ConnectTimeoutException also extends IOException which is already caught. The upper method getHealthStatusFromRest catches this exception and logs. If you log and throw here, there would be two error messages which are confusing and redundant. Eg, in the test you write, we would see the error log in our test output if we set logging level to print errors. And it is quite confusing.
I believe everywhere else we write it as 'authorized'
Preconditions.checkArgument() on all non-null arguments to prevent bad config
Is there a reason why you don't use [Collections.emptySet()](<LINK_0> here?
this is odd, these DTO object should represent the exchanges response and should not do any premature mapping nor have data coping logic
please decrease log level to trace or better remove statement
please decrease log level to trace or better remove statement
what about putting this in the default: case of the switch (switches without default, you know...)
what is your opinion about that you convert only the different value and you are using the .name() any other case?
Return Optional<String> for methods that can return null
The error message doesn't match the actual behaviour.
This can be optimized to a simple messages.get() if the underlying Collection is a Set.
This remove will not occur if the group or store removal fails and the scheduled future is already "spent". We need to reschedule in that event. Same delay?
What happened to this method? Why isn't it a private anymore?
We don't really need to create a new deserializer for each request.
Same here , please change value to StringBuilder
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
I _think_ this is ok - typically for netty applications, you want to avoid blocking the main event loop - but I guess in this case, we want to avoid the acceptor event loop blindly accepting connections when the worker group has to deal with a potentially blocked queue. I wonder if, given that the act of adding an item to a queue in logstash can block, whether the work group would be better in its own thread pool, but I think this should be ok in the short term
Maybe just keep it the way it is right now and add a task for migrating to PooledByteAllocator, so that we can benchmark it. I can take the benchmarking task if you want.
@praseodym maybe we should make sure that if workGroup is != null before this line, we will shutdown the "old" worker group first so we don't leak any theads here? I think it's not impossible to get to that situation since the reason we get to a reload is effectively always an Exception in the code that should shut this down right?
Do we need to check which button triggered the event?
Use strings.xml
I'll add the cache in SMBJ, as it should be there (see section 3.2.4.2 of the MS-SMB2 spec, the TreeConnectTable). It will be there in 0.0.6
Method duplicated
What's the advantage of static method vs. constant?
Was this intentional?
Another null test of the response. I won't mark any others I see below this point, but they should all be fixed.
As above, this should not be null. If it can be null, the Client.searchGenotypePhenotype method, or the server endpoint, are behaving in a manner unlike the other Client methods or server endpoints.
response can never be null, can it? The call to searchGenotypePhenotype should either throw GAException or return a valid SearchGenotypePhenotypeResponse.
Can you extract this to a method? There is code duplication here.
Don't need a line break here as well.
I'm guessing previous level of indentation will bust the line length limit. In that case, align the other two parameters below.
baseId +diagram
createPackage mapping should take the toolsection in parameters and create a ContainerCreationDescription tool.
Create the tool section between the layer and the first mapping. Then pass it as parameter of each createXXxMappingYYY method and in those methods, you will have the possibility to create a creation tool correpsonding to each mapping, link it to the mapping and add it to the tool section. ContainerMapping -> ContainerCreationDescirption EdgeMapping -> EdgeCreationDescription NodeMapping -> NodeCreationDescription
Nit: would it make sense that this constructor calls the constructor on line 63?
Guessing that after setting the axon_code_style.xml, these changes would be reverted.
This recursive invocation never ends.
"Couldn't rename [" -> Fail to rename
Why create a list above and then return a tree set? Why not simply create the tree set above and add to it before returning?
move this check at start of the function.
GitHubSCMNavigator. suggestion NamedArrayList.select(all, Messages.GitHubSCMNavigator_withinRepository(), NamedArrayList.anyOf(NamedArrayList.withAnnotation(Discovery.class),NamedArrayList.withAnnotation(Selection.class)),
You should be able to use the diamond operator here, i.e. new ArrayList<>()
@idelcano I don't think this constructor is needed (unless you are thinking about adding something else later on). Just initialise the variables. Also the variables should be private if we have getter/setter.
I suggest changing "doesn't exist" to "not found" or "nor available" in all these methods.
why change the readability status here?
Same here. The only possible checked exception here is IOException and can be propagated. Please don't catch all types of exceptions. They will be propagated anyway.
Seems we have changed to log2, the computation will be accurate but now what is the plan to show all files < 1 MB query? Seems more computation to be done in UI. From the user point of view, 1KB, 2KB, and 4KB is all noise in UI. The 10s of bytes makes it more readable!
I would cap this to MAX_BATCH_SIZE.
if rowsize is always positive the check for -1 is not necessary
The amount of duplicated logic we're amassing is concerning. This is going to be painful from a maintenance standpoint.
Not sure why we are passing connectionProcessor and connectionProcessor.getRetryOptions().getTryTimeout(). If the session manager has the connection processor, it should be able to get the retry options from it anyway. Also, it's weird to see retry options in connection processor.
The options don't seem to be propagated here.
Same as above, the for loop would throw a NPE if methods variable becomes null.
Same as above, the for loop would throw a NPE if methods variable becomes null.
Same as above, the for loop would throw a NPE if methods variable becomes null.
Can't we use stream here?
Looks like this file isn't formatted correctly. Are you using the Eclipse Java editor (it should format on save).
Same question
Why do we have to check read scopes when we commit cursor ?
I think it's possible to do that more elegant by streaming one list and using iterator of another list in that stream.
Strange that SubscriptionCursorWithoutToken has method withToken. Why not just create SubscriptionCursor hear?
We can throw the exception to client.
It looks like this behavior was pulled from existing code and refactored into this method (good idea). But it doesn't look like the way the existing interface actually behaves... does it? Categories & groups are empty, correct? (Just verified.)
Undetected error condition where the personAttributesGroupDefinitionDao found multiple group definitions matching the name?
suggestion PodTemplateUtilsTest.assertQuantity(PodTemplateBuilder.DEFAULT_JNLP_CONTAINER_CPU_REQUEST, requests.get("cpu")); PodTemplateUtilsTest.assertQuantity(PodTemplateBuilder.DEFAULT_JNLP_CONTAINER_MEMORY_REQUEST, requests.get("memory"));
This test class is used to make sure jclouds is up to date with the Image offering of the providers. Given that this works only for local images, it does not really make sense to have this test class.
This local variable appears to be shadowing the field variable
Can you please convert this to throw specific exceptions instead of PerunException ? Thank you.
Bad indentation for this method.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
don't you want to add a/b?
expected value is the first argument, hence I think the arguments should be flipped here same for all changes below
why is it called 'symlinkA' . This test doesn't create symlinks. I took over this test into a bugfix commit which is now a predecessor of this change. There I changed this variable name to fileA
@Override
I wonder if this should be BatchReadTimer.... I know the Astyanax does Batch, but Datastax doesn't.. so...
Why not use CassandraModel.CF_METRICS_LOCATOR_NAME ?
double check that the group is still here
double check that the group is still here
double check that the group is still here
I'm assuming we can't use something from Joda because there are sometimes stupid dates? otherwise ISODateTimeFormat.basicDate() should work.
It would probably be better to use a date parser for this. That way we'd also find problems such as trying to parse the date February 30th.
SimpleDateFormat might help make this a lot simpler. <LINK_0>
break is missed. If smth illegal is found - we should stop search/matching quickly. Please update all other cases below.
rename to editGroup
rename to cu
did you want to remove this throws IOException as well?
but you didn;t ask it to leave a CID file...
Please add isDebugEnabled() and have spacing before and after "+"
Why is this not based on context.getCurrentUser()?
I think we should not be hardcoding the type here again, and instead use IndexableClaimedTask.TYPE or similar
Shouldn't this call AuthenticateServiceFactory.getInstance().getAuthenticationService() .allowSetPassword(context, request, null); ? It seems odd here that *anyone* can update a password as long as the EPerson exists and can login.
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Not sure whether we should transparently fall back? I think using this interpolator should be an active choice, especially since it does not even handle all default constraints out of the box.
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
I think the granularity should be 1 seconds instead of 5 seconds here.
might be better to have this test if the thing actually logs skew, since that's the critical feature
This expression (nano % 1000 >= 500) is used in more than one place, why don't extract it to a function?
"error".equalsIgnoreCase(...)
constant on left side
Wouldn't it make sense to give errors a priority HIGH?
Could you please change the name to indicate it is responsible for startpoint registration? "StartpointVisitor" can be anything that needs to act on a Startpoint, so just using KafkaStartpointVisitor isn't specific enough.
nit. Just a suggestion, should metadata store api have method for deleting multiple keys? May be more efficient for some types of storage.
Could you please make the exception message more descriptive?
we just log, update metric and move ahead with next iteration?
Why are we not importing these classes at the top of the file?
> This Topology Provider displays all defined Applications and their calculated states. Source <LINK_1> Also refer to its implementation <LINK_0>
As with others, I would not assert on the return value of the operation
Here it is going to depend on the resilience strategy ... so hard to say. I would drop the operation result assertion though.
As with others, I would not assert on the result of the operation, only on the resilience strategy being invoked.
Removing test because you can not fix it is usually bad idea
I'd prefer if you put the Headers here in a local and did isSameAs just like is being done with body.
Why is this setThreshold and not threshold? It is a builder method not a bean setter.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
Please add also VOOBSERVER.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
getSourceVmFromDb can return null..
You can remove all the following code: if (!(.... return false; } return true; With simply : return super.canDoAction() && canRemoveVm()
How about the user trying to enable a hook which is already enabled? Also if there are no up servers, command should fail
Unsigned types are not used in the current implementation. So, you can omit them.
can you add some docs around this method.
This should probably return different implementations.
add principal name to message?
I still don't understand why the key cannot be the session id
Please change to sessionInfoMap.keySet() .stream() .filter(sessionId -> getUser(sessionId, false).getId().equals(user.getId())) .filter(sessionId -> getSessionValid(sessionId, false)) .count();
This assert statement is always true. Not needed here. Rest code changes LGTM.
This value can be static, no need to look it up every time.
That print stack trace would be useless if just printed so better to ignore it too.
I am not familiar with the script cache stuff, but this will delazify the cache contents and hold it all into memory. Is this okay?
Can we not get a buffer that is already a Flowable so that we don't have to call fromIterable?
Again, IMO this would look better (and be more efficient) in a for loop.
I don't like that we must first call "getSelectedFile" and then additionaly "confirmFileSave". Could we have a method that merges the logic of the two above? It could be named "getFileWithConfirmation".
Looks that works OK, but for me it's hard to read. I would rather see better readable return.
We have the file mode included in the checksum at line 506 which is cool... But here, when we walk the contents, are we only walking sub_files_ (i.e. direct child files and child files of subdirectories)? If that's the case then we'd not capture the file mode of subdirectories - is that the correct interpretation?
Once we have a pre-inited EnumMap we can do away with this null check.
style nit: remove curly brackets
These two checks are redundant, only the "poison pill" can be by itself in a chunk, and only it can have a start time of -1 (right?). You can keep only one of them.
It's not necessarily a build script - only if the resource is a file.
e.getMessage()
I would mute this error, because it will most likely pop up if the resource or marker was deleted diring the decorator run.
@mykelalvis please, rename to server. s is meaningless :)
Why is true passed to setMustExist? What happens if the repository does not exist? I thought that false ensures that the method succeeds and the next three lines will generate the repository.
I would suggest defining this file name as a constant because it is used more than once.
monitoringId will be null if split fails
why filter is applied only to plot names, but not to summary? we are going to show monitoring params in summary when decision maker will be ready
switch should contain all possible enum values
Why are we getting BigtableClusterName and BigtableInstanceName from two different places? Are they V1 and V2 names? If both are V2 name we can get InstanceName from ClusterName.
nit: Add "I_" "D_" prefix
Same as snapshot(), this is a LRO, we need to poll.
can you add metrics to this?
why do you need to take the lock if the file does not exist and you don't need to take it if it exist?
I think it might be useful to have this as info
same, would inline here and extract a common method with just the Activity class that you want to start, two lines of code.
Remove this if it's not needed.
Is this project specific? Because it is generally ok to do so.
I'd extract this into a method isUnset(Diff) as well. Don't we have util methods for determining whether it is an unset? They seem to be very generic and maybe should go there, if we haven't them yet.
Same as above (avoiding multiple returns).
I think it would be good to avoid multiple returns by either enclosing it within the negated if or, which might be even easier to read, extract a boolean variable: final boolean hasOpposite = diff.getReference().getEOpposite() != null; final boolean isOneToMany = hasOpposite && diff.getReference().isMany ...; final boolean isManyToOne = hasOpposite && diff.getReference().isMany ...; return (isOneToMany || isManyToOne) && ...; Also I think the convention in EMF Compare is to try to enforce final wherever possible.
I would prefer not having to deal with string parsing. What do you think about the approach we use for Neo4j? We use a Neo4jParameter class and check if this is an instance for it. This actually connect to what I suggested before and we could keep the code consistent between the two dialects.
It would be better to whitelist this for outer types (FULL, LEFT, RIGHT). @scarlin-cloudera Either we can create separate jira or we can make the change with this patch..upto you.
Frustratingly, this isn't even enough. We need to do likewise above for collections, as on 270.
'map' name may be problematic. e.g. following line results in an error : a = load 'a.txt' as (map : [chararray]);
example (with an a)
we can refactor this if and the one below into more compact code by checking nonnullable using ternary operator
please don't do in the middle of method return. use else instead. also you can always refactor the branch into a separate method if there is too much condition
Could you please add support for updating balancers through filter and list?
You may load only load balancer and get information about data center from it
What is the purpose of this logic? From the xml file I can tell that the 0210 thing has this channel, so why do you have this check and addition logic here?
remove this "if", only keep the "else" - you must not set yourself HANDLER_MISSING_ERRORs, this is done by the framework.
Doing the refactoring of the OH2 bindings, this default implementation does not appear to be helpful. In most cases, the Thing is simply expected to go ONLINE once the bridge is ONLINE. This means that this method needs to be overwritten, so the question arises if super. bridgeStatusChanged() should be called at all or if the logic isn't reimplemented. Both variants are not really nice. I think we should change this line to ThingStatus.ONLINE as this will be the expected behavior in most cases. Whoever needs something else, should override the default impl. @sbussweiler WDYT?
This seems like it should handle the exceptionsl ike the RuntimeException block from above. Why make the distinction here?
Missing final
Use the for each style for loop.  java for (final CliCommand implementation : getAllCommands())
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
Mid return may worsen readability
This is the same as downloadBatchMap.containsKey(completedDownloadBatch.downloadBatchId())
TransportException is not just a wrapper for other exceptions, so where it is thrown and it's (sub)class is important, just pass it as the new cause.
we should not declare to throw generic Exception
optional: can narrow scope
You're not passing in the message even though you have a marker there. Think that might throw weird RTEs.
Is this log needed if it's being described above? Perhaps this moves to debug level? I just don't want "delete" log messages showing up in the log without some context.
Can we use the logger to log the error and not just e.printStack..
rename to key
Maybe turn .ds- into a constant?
new HashMap<>() will do
If someone calls offset.reset() (topN does this sometimes) then this will be wrong. I think you need some logic to detect the offset going backwards, and resetting the iterator in that case.
Align logic and method order with double and float.
Please align the logic with double. And if there is just one method, it checks anyway and returns an optimized impl.
Use TreeMap to keep the order.
Doesn't look like limit needs to be re-parsed each for loop (I realize the old code did this)
Same here for not needing to do re-parsing each for loop
why not initialize this in the constructor (and only set the herder in the Worker#start() via a setter method in connectorStatusMetricsGroup)?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
task.getId() shouldn't be called by each for loop, and it would be better to change this method to a lambda style. java final String taskId = task.getId(); return taskRunner.getPendingTasks() .stream() .anyMatch(t -> taskId.equals(t.getTaskId()));
You also need to update the text of the menu button here.
FIXME: All front facing strings go in strings.xml.
NITPICK: There is a class for this that already exist, can you reuse that.
You can remove the surrounding brackets.
It does not seem right that after calling this function, the value of question.numberOfEntitiesToGiveFeedbackTo is changed.
Is it possible to determine if the real question number should be shown or not, and pass only the appropriate value to the constructor here? For example, int trueQuestionId = isShowRealQuestionNumber ? qAttributes.qNo : qIdx & ${question.trueQuestionId}. Will it break anything? If it works, you won't need to store isShowRealQuestionNumber and it will clean up the tags slightly too.
why return a candidate if it is not a factory for an object or an eObject ?
this must be disposed
Here, you have no excuse for not using ImmutableListMultimap, you already create a copy (with ArrayListMultimap.create(...)) and then make this copy unmodifiable. Use ImmutableListMultimap.copyOf(Multimaps.filterValues(....)).
why use ellipsis?
Core.ID
why the 0 what's magic about it :trollface: ?
Why are you suppressing exception here? Let the runtime exception bubble up. This is changing the behavior of the wrapped processor.
NIT: unnecessary space before ;
Is a used anywhere?
Do we need this method public ? The place where it's used is in the same package so protected/default should work ?
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
any particular reason why this method doesn't require an IJavaProject ?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Same thing, using this method here may cause the getLinePixel method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
Throws AIOOB exception when called with index = line count.
consider being paranoid and prefix with "line.length() > 0"?
It seems there is some compilation error here. Or some pending change in AQL ?
I would delegate to the new method directly
This will throw a null pointer exception if targetType is null.
I this refactoring, very nice. Could make this method protected.
Better to extract local variable for URL to avoid noise from Sonar that we defer NPE calling the method several times.
please fix the whitespace. You just need to return the options here.
getBigtableWriteThrottleMs() returns a ValueProvider which will always be non-null. I think it would be more correct to use a NestedValueProvider that transforms the opts.getBigtableWriteThrottleMs() ValueProvider into a "true" or "false" for the google.bigtable.buffered.mutator.throttling.enable value
There's a BIgtableExtendedScan that needs to be considered here. This approach doesn't seem like it would work.
Can we not hardcode this?
The first message will show 0 / 5. Should we set the currentRetries to 1? For the message, we should log something useful for the user to know what it is happening. Can I suggest you this message: - Attempting to acquire the DB log notification lock: 3 out of 5 retries
same as others: log should have Exception as arg
RuntimeException will be sufficient
Could above if/else be replaced by  java return modelId != null ? modelId.toString() : null;
Why do we need new DefaultDataService every time. One is enough, is not it ?
what ? you should specify session in which you are looking for parentId! In this case you take first one all the time
Probably we should log the exception here (debug or trace), just to help with troubleshooting
Can created URL class loaders be cached, it should not be necessary to create a new class loader each time loadDependencies() is called.
url should be checked for null.
bridgeUID is the only property which is interesting from the bridge handler here. I suggest only giving this ThingUID in the constructor.
delete.
Drop all the unnecessary use of this. throughout.
Be careful. This is not a preference but an option in a dialog.
You can use ThemeHelper#isLightThemeSelected instead of hard coding it.
rename to theme
You're better off pokemon-catching these.
printStackTrace directs output to the console and should be replaced with logger debugging
Could you replace these with SalesforceSDKLogger.e(...) calls?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
Use Sytem.getProperty("file.separator") instead of "/"
Is this going to cause a problem upon restart? Should we log something higher than debug?
the default should be made a constant somewhere instead of being defined in multiple places
set to 'null' and create a default in AbstractObjectConfigurationProvider
Same here: should be Branding, not ProductBranding
This null check should only be applied to the loadProfileImage() call. The profileImage variable should be assigned regardless, as the whole point of it is to store the image for when the view is initialized.
We should probably handle failure as well, at least to hide the loading indicator if nothing more.
Same here about checking null value in binders.
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
suggestion Pattern argPattern = Pattern.compile("^\\$(?:\\{(.*)\\}|(.*))$");  Align with start and end of the string. Otherwise you would also match bla$ad or ${foo}bar
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
"due to".
It's better to use "Preconditions.checkArgument" here. And it's missing a period "." before "Transaction".
use %s
Is there a functional change here, it seems like we lose the error message of failing to close the block reader?
I think with "L"ong (as opposed to "l"ong) you should use .equals instead of ==. Not 100% on that but I feel like I've been burned before by using ==.
Start with a Capital letter. This is missing in all the other calls to receiveError too. We should look into a uniform way of handling Service exceptions. Because in the case where the app is closed, we cannot show toasts. Maybe store errors and show them on the next app startup ?
This line will always evaluate to false as we are comparing ExitCode with String?
check for not null in parameters.
You can avoid code duplication by making isStartable call getStartable:  protected boolean isStartable(StepExecution stepExecution, ExecutionContext context) throws JobExecutionException { return getStartable(stepExecution, context); }
typo in DATAPAAKCAGE
There's a typo here, it should be no authenticator jar files.
Why not throw a NuxeoException here?
Would this timing logging be better within PageCacheWarmer#reheat? PageCacheWarmerKernelExtension is the only other place to call this and contains identical logging logic, with a different instance of Monitor.
Is this worth making configurable?
Instead of checking a field (which is set in another method), I suggest calling peek(), so that the knowledge of that field becomes more "local". To prevent the creation of Optional instances, we could create a private "peekNullable" (or any better name than that) method, which just returns null. That would also allow the do ... while to be refactored to a while, which is generally considered cleaner:  while (peekNullable() == null && System.currentTimeMillis() < deadline) { ... wait for data } return peekNullable() != null;
Integer.SIZE here as well
unnecessary semicolons here and in some other try blocks for page cursor creation
pageId + 1 should really be 0, right?
suggestion Path relativePath = Paths.get(referencePointPath).relativize(Paths.get(filePath));
is it possible to use hash here to accommodate the case where gradle cache may have different versions of the same artifact present?
Same question here but regarding isDebugEnabled() instead of trace.
change variable to something more meaningful
Bad variable name! Variable names should be clear enough. Rename it.
please use line number of lamba in argument of method , it is really cool idea to make it more visual.
Extract -> Extracts
Does this method have to be public? Maybe we should use private.
calcFilterAndProjects  -> calcProjectsAndFilter ? Because projects are the key part.
Remove.
@bhaisaab as the _completedTestCount_ is incremented at the _oneMoreTestDone()_ method, I think that this log could be moved to "_com.cloud.utils.testcase.NioTest.oneMoreTestDone()_"; this would remove the need of _Thread.sleep(1000)_ and let the log clean.
Ideally we should exclude these responses before sending any message, we also just need to check once per base message.
break the line
I think the standard way of instructing a command to work on a database, is to use the withDatabase argument. I think we should do that here as well, instead of assuming that the configured default database is the one we want to build a configuration for in the particular invocation of the command. Unfortunately, withDatabase does not allow you to override the description. I think that should be added, because the description you have here is really good.
Setting a default constant value inside a private function that is invoked with different keys at different places in the code is not a good idea. It can be set in Constants.java similar to DEFAULT_YARN_SCHEDULER_MIN_MB . Also the next if for memoryMb == 0L needs to be updated/removed accordingly.
Since the near-duplicate indices level is now configurable, can 2 be changed to indexChecker.getWarningMismatches()?
If all the changelogs are created via triggers, do we need a DAO method for creating them?
<LINK_0>
what is adding items into the cache?
For new code, it would be good to stick to Java 8 lambda syntax now that the patch from @julianhyde has landed. That is rexNode -> rexNode.accept(NotLikeConverter.this).
[String.join()](<LINK_0> should be sufficient here. Util class is pre java 8.
Browser.CHROME
Should it be closed via #close() ?
'k' is hard to understand => please rename it 'metric' or 'metricKey'
Would it be the same to say lemmasList.addAll(keyValues) here?
I think the Java 8 way is as below: List<String> list = Arrays.stream(items).map(item -> (String)item).collect(Collectors.toList());
Default size not necessary.
reset compensation?
Possible candidate for bind() if that method is created.
Could you make this method protected? This will allow override it when needed
I am wondering should we use a ConcurrentLinkedQueue here instead? It is a collection that provides duplicates but in a non blocking fashion.
@wburns I don't think we handle correctly the scenario in which passivation is disabled. In this case the entries in memory are a subset of the entries on the disk, so I think we should rather use the store instead of the memory for these operations.
Ah yeah it is a set of ICE :)
nit: instead of the boolean here, would be better to use an enum (would make the test clearer) or two methods runSslConnectionTestWithoutClientAuth, etc.
Might want to add doPrivileged calls around the InputStream initialization and the truststore.load down below.
This requires all substrings to be present, we want containsAny
I would be more defensive here. I would check if the num of containers returned by getContainers() is > 0 and if the value returned by getImage() is nullOrEmpty
PARAM_DATA is used to retrieve the data, but PARAM_SELECTORS is used in the error message.
this log seems useless, remove it
Never handle exceptions like that. If you can't handle it, request user help, or rethrow it, thel log it via plugin activator.
@inverno containsOnly?
Refactoring should not ask question in the process. All questions should be answered on the preparation screen.
suggestion ensureYellow();  Shouldn't be needed to retrieve the index mapping. The create table only returns when the cluster state has been updated (shard initialization is async, but that's not required here)
Why have you updated this test instead of writing new one?
Can we get rid of the inline Json please?
One more times(1).
the component creation is duplicated for save and update
Could you please replace event.getTarget with a variable to make it clearer
I think illegalKeys is better than illegalKeyValues.
You can use advancedCache(0, CACHE_NAME) and fit it on one line
Did you want to log the time here?
Please remove BaseAsyncTask::AddOrUpdateTaskInDB:
can be refactored into commcare task
It would be simpler to have a dependency collection Task (like base code) after each event tasks instead of making a long dependency list. It is more readable too. Also, it is confusing how the dependency is set if parentTask already have a child. So, it is better to have the tail of parent task chain to add dependents.
We need to enforce TCP connect timeout and read timeout, apply reasonable defaults, and make the timeouts configurable.
Please use either parameterized logging, or the method signature that takes a Throwable as second argument.
Use Slf4j API: log.warn("Error while closing tcp stream {}:{}", serverName, port, e);
Can you use a more relevant variable name?
There's no need for this.
What is the use of this second list String[] items?
No, This is not right place to dismiss the dialog, do it <LINK_0>
Perhaps the '104' could be a constant?
since the index of returns, the first occurrence is there a chance this will break in CDATA inside CDATA scenario?
we can create lazy iterator here instead of collecting updates into array list and pass that iterator into apply, so we can avoid one top additional for loop
I think this condition makes sense. Can you update the code to match the surrounding formatting (hard tabs, and use braces)?
replace the if with checkIndex(toIndex)
What you think to change to assertThat(validation.getErrors(), empty())? It's more readeable, sounds like "assert that validation.getErrors is empty". empty() is a static import from org.hamcrest.Matchers. If the assert fails, hamcrest matchers have a more pretty message than assertTrue from JUnit, that don't show any message.
Cosmetic: Braces on a new line, please. :)
Wouldn't it be better to redirect the user to wondergem root in this case? I seems to me that this triggers a user being logged out instantly.
obsolete when naming loopvar 'console'
Returning null will likely generate an ugly stack trace in the result. Check that please.
We should use console class member not ask for the active.
can we move getMethodOn().getWorkflowGroupForRole(UUID.fromString(halResource.getContent().getUuid()) outside the for to optimize a bit the code execution?
I think Local.ROOT is probably a better choice.
You should use ThreadContext.putAll() here.
This is a little hack for me. Could we avoid these kind of hacks?
No need to create the directory if it doesn't exist. The file.exists() check below ensures that the file will only be deleted if it actually exists.
Please create a temporary directory and remove it in @AfterClass.
i don't think they are all supposed to be uppercase. in fact, i think in the wiki the acceptable values are: -beta -alpha -RC -RC2 - same as the three above but with a version appended
Minor: can we check if the number contains the decimal point instead?
There's no need to compute the error message in the general case when there's no failure, so please move this (duplicating if needed) a few lines down to where it's actually needed.
1. Change Exception to exact exception you get 2. throw the exception after log or don't catch it here
Why not just join() the thread?
We should call sweepOutcomeMetrics .registerOccurrenceOf(SHUTDOWN);
a piece of thought for discussions: in the loop above (line 1018-1021), should we put the node id of ALL running attempts here into unhealthy nodes (instead of just the earliest attempt)? since by the time we got here, a redundant attempt was deemed necessary, that must be suggesting all the unfinished(running) attempts for this task are potentially problematic/long-tailed.
prop: suggestion final boolean followupRebalanceNeeded = assign( TASK_0_0, TASK_0_1, TASK_0_2, new TaskId(1, 0), new TaskId(1, 1), new TaskId(1, 2), new TaskId(2, 0), new TaskId(2, 1), new TaskId(2, 2), new TaskId(3, 0), new TaskId(3, 1), new TaskId(3, 2) );
This inevitably is linear. What about key-ing tasks contexts by their ID (maybe as a separate structure in this class)? Or persisting returned value in UpdateSystemMemory?
Log in logger, not just print in console.
This can be inlined.
Suggest using instances of java.util.AbstractMap.SimpleEntry instead of making a bunch of anonymous classes.
Possible candidate for bind() if that method is created.
Although bound() may be the "better-named" method to call here, it involves two operations (a set and a get). Since this method does not actually read/use the return value of bound(), maybe setContext() is still a better choice (more efficient anyway) ? If the return value of bound() was assigned to a local variable and compared to invocation.getInvocationContext() (to confirm the context was bound as expected to the ThreadLocal) it might be a different scenario. Maybe an additional method with a similar naming convention:  public static void bind(ActionContext actionContext) { ActionContext.setContext(actionContext); }  could be a compromise (named to indicate an attempt to bind, which does not provide a return value to confirm it was actually bound as expected) ?
Elsewhere local variable ses was replaced with session (e.g. as in before()). Maybe it should be the same here:  Map<String, Object> session = ActionContext.getContext().getSession(); if (session != null) { unlock(session); }
Suggestion: Use an else-if for these two and provide the missing braces. And instead of length() == 0 I'd use isEmpty().
Does this Listener mean we can only process one event at a time from qpid? I.e. we can't get another event until the EventManager stores it? Hrm maybe this is why registers are slow.
Use LOG.debug, because this data does not contain much information.
There is no need to create an odd variable
I think it is confusing to put this above instead of in doCreateProject (right before the RPC call). If there ends up being another way to trigger the create (via keyboard...), it will be missed, or have to be duplicated.
I think there is a mistake, it should be "/scheduler", no ?
suggestion throw new IOException(MESSAGE, (Exception) DummyClassLoader.apply(TestCallable.class));
should this be in a finally block to release in the case where an exception occurs?
Can we make a SoftEndOfStreamException as an UncheckedIOException to avoid this wrapping? i don't mind for other branches, but at least for the master. Thanks
What happens here when mergeOldAndNewHistory() returns null. Looks like it will fail in writeHistoryToFile() later.
can you assert something more - contanins some string, minimal length? it relies on the serialization and when it's broken you wouldn't catch it.
So if history.entries.isEmpty()? Would be more readable in my opinion. (Maybe even add an isEmpty function to the history class.)
I'd instead throw TestException("Forced failure") and then simply  java Flowable.just(1).collect(...) .test() .assertFailureAndMessage(TestException.class, "Forced failure");
As far as I understand, we can get rid of explicit type parameters is such calls
Isn't it easier to reuse AsyncIterablePublisher with a Collections.emptyList?
Can we move this above cGroupsCpuResourceHandler.prestart()?
"org.jbpm:Evaluation:1.0" is repeated, it could be in variable.
"org.jbpm:Evaluation:1.0-3" is repeated, it could be in variable.
"Entity" + id
please use StringBuilder
let's remove this
This noneMatch(notVisited) seems rather convoluted for no practical reason : wouldn't a Collections.disjoint be enough in our case ? and/or maybe Guava Sets.intersection (maybe applicable to sets only) ? Ideally encapsulated in a "visitedAllParents" method ?
I am not really sure this is the place where we actually want to check this and I don't really see what's the risk you address with this invariant.
Mmmh, I'm not sure to follow you here. What is bothering me is having two times the same message on the same tree (so a duplicate of Location). So why considering the kind of the tree and only the message value? It's probably way simpler to rely on equality of locations to filter out, with a LinkedHashSet for instance.
Is this still needed if the value gets overwritten in the next line?
In other places in the code we check if the client is null first, so that we don't do any unneeded computation if the client is null.
do you need the RMNodeStarter prefix ?
Using stringbuilder and then a + op is pretentious ;)
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
you can simplify this with String.join(",", getSortedList())
Does {this} instead of the name of the card not work in this case?
Must be AIDontUseIt (otherwise AI discard all hand). Same for effect's constructor (AI can't use that card at all).
There is a simpler this.getEffects().setTargetPointer() method for this.
Try something like this  private Set<ID> toSet(Iterable<ID> ids) { if (ids instanceof Set) return (Set<ID>)ids; Iterator<ID> itr = ids.iterator(); if (!itr.hasNext()) return emptySet(); ID key = itr.next(); Set<ID> keys = key instanceof Comparable ? new TreeSet<>() : new HashSet<>(); keys.add(key); while (itr.hasNext()) { key = itr.next(); keys.add(key); } return keys; }
nit: I'd probably put all the CLIENT_1 and CLIENT_2 things in order (which you do in the assertion)
We provide 'user friendly' messages on NullPointerException, here:  java Objects.requireNonNull(values, "values is null");
Like above, using the absolute path should accomplish this properly
Can you just change the return type of this method?
any reason to change this? Not sure what /:denied does compared to :/denied
A method similar to this but with first parameter Connection<T> would be more convenient for use in CPPSemantics. Such method could be moved to /org.eclipse.cdt.core/parser/org/eclipse/cdt/core/parser/util/CollectionUtils.java
But the function actually finds element's index, not the element itself. The more appropriate name can be indexOfElement
Looks like this inserts the element in ALL null fields of the array. Also, docs.
I can see why this is necessary, with the change a few lines above from 'indexOf(".")' to 'lastIndexOf(".")'. However, there are two things I don't like about it: * what about, say, "model.profile.profile.di" ? (granted, unlikely, but handled by the previous version of this code) * more seriously, this hard-codes an extension that is defined in a <diagramCategory> contributed by some plug-in on the org.eclipse.papyrus.infra.core.papyrusDiagram extension point. Other plug-ins can define additional extensions that aren't enumerated, here. Rather than hard-coding this, we should look up the extensions that need to be trimmed off in the DiagramCategoryRegistry
Added code to print an error message and exit.
Looks that works OK, but for me it's hard to read. I would rather see better readable return.
suggestion LOGGER.trace("The service with name [{}] is not found in the cache, try to find it from [{}]",
You can make this method more functional if you want :)  java return Arrays.stream(services).flatMap(service -> { Collection<Class<?>> serviceInterfaces = serviceProcessor.extractServiceInterfaces(service); return serviceInterfaces.stream().map(serviceProcessor::introspectServiceInterface); }).collect(Collectors.toMap(ServiceDefinition::serviceName,def -> "service"));
can you remove this and add e as cause to ISE instead?
LZ4FastDecompressor requires the size of the uncompressed data as the last argument to decompress, vs. LZ4SafeDecompressor requires the maximum size of the output as the last argument, so we should only use lz4Fast if we know the size of the uncompressed data, which is not the case in this method.
Not sure if we rather want Cipher.getInstance with second argument to be "BC" security provider as used for example in AesCbcHmacShaEncryptionProvider? AFAIK that may have bigger probability to avoid issues that some stuff doesn't work as expected on various JVM versions etc.
Should avoid catching NPEs here and below.
This is inherently dangerous. sharedList is a CopyOnWriteArrayList which is _safe for iteration_ even while it is modified. However, once you abandon the iterator, it is possible for the sharedList size to decrease while you are in the loop, and sharedList.get(i) will generate an ArrayIndexOutOfBounds exception.
final, Lists.newArrayList(), etc
i think it is probably better to just get the whole thing as lrange(...) in one shot, and probably best to not bother fetching the size (again, doing it as a two-step you are leaving yourself open to concurrency problems. imagine that while thread A is in the middle of iterating through a peekAll, thread B starts rapidly popping members out.)
squigglies ftw
Again, just return the boolean value.
I guess we need a null check as well.
can we put this line just after line 119 -- nc = (NameCallback) callback; ? then we can remove this if statement. Also we can remove line 115 to 117 I think. if (callback instanceof RealmChoiceCallback) { continue; }
Any reason why we want to iterate all the call backs and then throw an exception?
You don't have to change this, but one cool trick you can do is: final String token = credentialCallback.applyToCredential(BearerTokenCredential.class, Credential::getToken); and save a couple lines of code; then you only have to check if token is null.
It would be nice to create constants for these props in AccumuloProps class.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
I think this call to byteArrayOutputStream.toByteArray() can still blow up memory. I would recommend using guava's [FileBackedOutputStream](<LINK_0>, and calling .toByteSource().openStream().  private void writeMetacardToZip(ZipOutputStream zipOutputStream, Metacard metacard) { InputStream inputStream = null; try (FileBackedOutputStream fileBackedOutputStream = new FileBackedOutputStream(THRESHOLD); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileBackedOutputStream)) { ZipEntry zipEntry = new ZipEntry(METACARD_PATH + metacard.getId()); zipOutputStream.putNextEntry(zipEntry); objectOutputStream.writeObject(new MetacardImpl(metacard)); inputStream = fileBackedOutputStream.asByteSource().openStream(); IOUtils.copy(inputStream, zipOutputStream); } catch (IOException e) { LOGGER.debug("Failed to add metacard with id {}.", metacard.getId(), e); } finally { try { inputStream.close(); } catch (IOException | NullPointerException ignore) { } } }
Should we put the resource.getInputStream() inside of a try-with-resources block so we don't have to manually close it after copying?
close in finally
Coding best practices: Interface i = new Implementation();
Log the error cases.
IntelliJ IDEA tolds me to remove this unnecessary boxing.
maybe it would be more readable of you had isEqualFilter(PlanNode node) method which would do all the checks but not on a single line?
if ! isDeleteQuery, the optimizer should not change anything; here it empties distribution type
not needed else block. Here in other rewrites as well.
@maria-farooq we should provide a description to the log message
@maria-farooq we should provide a description to the log message
@croufay why you check if object parameter is not an instance of Sid? What is the point here?
Single pass is needed here.
Is it possible to count the number of violations instead? There is no need to use MaxSchedulerWeight anymore.
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
missing space after if
I think you should throw exception if somebody calls setEvent and give an empty event name. #Pending
PerunClient is valid only for OAUTH2 clients. Otherwise its half empty object, especially client ID is not present. I would prefer logging whole PerunSession, but I understand, that this message should be rather short. But neither PerunSession or PerunPrincipal within it have a short toString(). Please add method in PerunSession like: getLogId() which will return value of actor property, so we will see user identity. If it won't be sufficient in a future, we can safely change such method to return also extSourceName or other properties. Thank you.
I would prefer the format to use id next to the entity type, like  log.info("{} removed attribute {} from member {} in group {}",...
Any reason to log facility.getName() ? Since you then mostly use otherEntity.getId().
I'm really sorry for your work, but in my opinion a simple TextInputDialog should be sufficient (instead of a custom dialog): <LINK_0>
maybe something like this instead?  File file = new File( directory, targetFile ); if (!file.exists()) { fail( "Could not find file " + targetFile ); } return file;
is this 10000000000l or 100000000001? Use upper case 'L' a lower case 'L' should not be used for Longs or variable names.
If you ever make this public this _ will break the JavaBeans specification.
Can be replaced with: hosts.stream().map(VDS::getName).collect(Collectors.joining(",")); ?
I think you want to call the new method which gives servers based on glusterPeerStatus
So this throws a new exception? Where does this exception end up going? I think this will convert an UnknownTokenException to a runtime IllegalArgumentException and so this will cause weird failures up the stack?
Please write auth-server instead of AuthServer because this is the default name
We do the exact same thing twice? Why?
f.isFile() is better since it checks if .project isn't a directory accidentally.
Not sure this is right unless it's only supposed to work on *nix.
Not that it matters but it would be "sourceFile"
Isn't this problematic, since the byte-array may not be a string, and it may not even be decodeable as a string, so this could throw.
Using stringbuilder and then a + op is pretentious ;)
If this is called before recomputeDigest(), we will get a different description string than the original implementation. Is that you want?
you fetch vdsDao.getAllForCluster(getClusterId()) and then fetch it again in runAnsibleReconfigureGluster() (line 304) you can save it to a local variable and save the second call. Also, it seems that you rely on host 1 and host 2, therefore you can just pass them to the method runAnsibleReconfigureGluster(firstGlusterClusterNode, secondGlusterClusterNode)
you can move the declaration to the initialization.
why changing the behavior here? what's the motivation around it?
Not really.
After your change we do not need to check type and cast.
Add final keyword.
this will go to the char after '[', is that OK?
suggestion }
Isn't this constant and shared across all producers? Then can't it be static?
Since Rx is optional, would be great if you add a check, I've added this in Hawk.java but that can be moved to utils and used here as well.  java private static void checkRx() { if (!Utils.hasRxJavaOnClasspath()) { throw new NoClassDefFoundError("RxJava is not on classpath, " + "make sure that you have it in your dependencies"); } }
We need to subscribe here, and it would be good to chain this with the return observable.
nit: space before {
remove this..i already have a pr with the fix
what if task.getTemplates() == null ? Also you can java8  java if(task.getTemplates()!=null){ dto.setTemplates(task.getTemplates().stream().map(TemplateShowDto::new).collect(Collectors.toList())); }
It is the same in this line, leave a blanck space before "+"
MaybegetOrFetchToken if the csrf token has been already loaded?
should be called resource
should be named resource
I think get was more approriate here
Use the jclouds predicates2.retry construct. If this is a common thing to be done, consider creating the predicate and make it injectable so other classes can benefit from it.
Wouldn't this be true? Value is apart of ipValue on declaration.
Sorry, but I don't think this is right: IMO the new eventually calls should be exactly where the sleepThread calls were
assertNull? And the withTx... though I know you've just moved this code from another test.
I don't like having to use eventually* for both, it feels like we don't really know what the code that we're testing does. Since the listeners are always invoked after the availability status changes, I suggest using a regular assertTrue(pm.isAvailable()) after checking the listener.
No LOG
Class<?>
Bad idea to not rethrow exceptions in a generic helper like this. I also don't think it's necessary to log the exception here - let whatever handles the final exception do logging.
Could you rename DirectDebitConnectorCreatePaymentResponse to remove "Create" as it's now used for both create and get
I wouldn't use this error, this will return a message like "wrong field: agreement_id", but all we are doing is checking that the gateway account is not direct debit. So if somebody searches for anything with a dd account, we would be complaining about agreement id, which is not really intuitive. I would create and return a new error that says something like "Refunds are not supported for direct debit"
feels like this should be all done within createTelephonePaymentService
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
NullHandling.defaultDoubleValue()
This code performs unnecessary unboxing/boxing cycles. I suggest to use Comparator.comparingDouble(Number::doubleValue) as COMPARATOR, and special-case retVal == null
state.setInt( state.getInt() | combinedValue.getInt() )
data is never assigned, so this method always returns "". How about instead use: public String toString() { try { return getDN(); } catch (NamingException e) { return ""; } } as then you can't forget to return the proper value, and you aren't duplicating the logic which appears in the getDN method above?
Generics warning on the @Bean method return type. Or @SuppressWarning or specify them. From other side this can converted to the Lambda as well:  java @Bean public RxJavaProcessor<String, String> processor() { return inputStream -> inputStream.map(...) ... }  And no need to worry about Lambda argument type - just because generics on the return type do the stuff!
this method should be explicit about the encoding that the resource will be decoded as. ( utf-8? ) or the system default? I worry about internationalization issues with this method. we should force utf-8 (unless for some reason we don't want to do that?)
final is unnecessary here
This can be null. E.g. if a mail address was matched but the account was not added to the result because the account is not visible to the calling user. Due to this SuggestReviewersIT.suggestReviewersSameGroupVisibility and SuggestReviewersIt.suggestReviewersViewAllAccounts are failing.
Nit: extra blank line.
Could you please add clear message for case when assert failed?
Could you please add clear message for case when assert failed?
Could you please add clear message for case when assert failed?
Any value in:  int start = getInitialStub().isPresent() ? 1 : 0; int end = periods.size() - (getFinalStub().isPresent() ? 1 : 0); return periods.subList(start, end);  If necessary, you could check if start and end were zero but would be surprised if there was much perf impact from not doing so.
Use unadj.stream() ...
I think we can be more general here. If accrualSchedule.getFrequency().isMonthBased() and rp.getResetFrequency().isWeekBased() then...
Squash into one line? unregisterAndCloseRepository(i.next().getKey(), null)
Maybe turn this into non-abstract class that accepts two constructor parameters: priority and lambda. Looks like it should simplify most use sites.
We can move this outside of the synchronized block.
use Arrays.fill instead for loops
Same here, stage-->i is pointless.
Would be nice to also display "generation rounds" as previously.
You need to also store the lastStartTime: long lastStartTime = prevFullState == null ? -1 : prevFullState.get(statusQuark).getStartTime(); Also, lastEndTime can change for the same attribute while it's being build and below...
Yes! Drive by fix!
redundant with scope in parent class
Should it be ColumnIndexType.DICTIONARY?
The current implementation doesn't really make sense to me. Can I suggest something like this instead? java public void cellValue(ByteString newValue) { // Optimize unsplit cells by avoiding a copy if (nextValueIndex == -1) { this.value = ByteStringer.extract(newValue); nextValueIndex = newValue.size(); return; } Preconditions.checkState(nextValueIndex + newValue.size() <= value.length, "Cell value is larger than expected"); newValue.copyTo(this.value, this.nextValueIndex); nextValueIndex += newValue.size(); }
Would you mind to add coverage for this method?
not really needed for test. just keep it simple
Are you sure about this change? It looks suspicious.
Check style issue, please fix
locks can only be non-null if we entered the if block and reached the line between 187 and 188 :-). At that place it is also guaranteed to be non-null. Therefore, move this code below the line 187 and remove this check.
This is why I suggest passing in List<String> to RefDirectory.
Like below with the compareAndPut I don't see why we need to mark ourselves dirty if we successfully wrote a ref. We should have had the object in order to do the command.
Here, size is the number of currencies.
I imagine there will be bulk conversion methods eventually, but best to add them as needed.
Could this be  return reportingCurrency.getCurrency().flatMap(function.naturalCurrency(target));
Why not initialize them at construction time instead of lazily on request?
Maybe mention dataflow? Why IO?
remove ClientCallService.DEFAULT
just use context as synch obj
just use context as sync obj.
Why did we switch out the old code back to this?
It would be slightly better to check that project is opened first instead of letting it throw CoreException in hasNature().
rename to element
Please don't print the stack trace.
From big height the fix looks reasonable for me. But does it work really against real Broker? I'm just curious if that CustomExchange is robust. But, yeah, thank you @panchenko for the effort to support community and improve the Framework!
Should we also bubble up this exception or solely log it down?
Duplicate entry
FIXME: Don't cast getActivity(), use an interface.
Nitpick: AS is complaining about the unnecessary rootView variable.
I don't like this side-effect. Can you do it in a static method rather than ctor?
I see a default value for version in PartitionLayout but not here. Is this on purpose?
Is this System.out required?
You can use StringUtils.isEmpty (...) as a convenience method that does both of these checks
@tmjee the same
It looks like active state is also tracked by Executor. Is it possible for the state to be stored in one place, instead of both Executor and FlowRunnerManager? There would be less chance of the states getting out of sync (if Executor is set but not FlowRunnerManager for example, or just before FlowRunnerManager is set) if there is just one state.
Did you mean ("executorService may be shutdown");?
return (this.sslContextDependency != null) ? this.sslContextDependency.register(builder) : builder; :)
Rename to "dependency"
Same as above this should likely remain public.
There is already a method called getProperty() in same class. You just need to do getValue on that. We don't need a whole new method for that. However do the improvements in this method to the old method itself.
Missing space after if. There are other cases in this PR.
As Alex suggested, this should just be a continuation of the above if (as another else if) rather than a new if.
The existing return output.repeat(2, (long) getN()); should be replaced by:  try(MemoryWorkspace ws = workspaceMgr.notifyScopeBorrowed(ArrayType.ACTIVATIONS)) { return output.repeat(2, (long) getN()); }  We don't want this to be detached instead.
Please put this conditional back because we only use DropConnect when training is true
Don't create this temporary ret array. Use gainParamView.assign(gainInit) instead.
This part is mostly duplicated with part of the isLoading block. The duplication can probably be removed by restructuring the code a little.
Declared but unused.
checkIntegrity() ?
Why is this change necessary?
In my proposal, the temporary file was deleted after the temporary directory was created. That way we wouldn't have a race conditio if the user is using an older JDK where File.createTempFile() was sometimes returning paths that were returned from previous calls.
If this logic is need, please find a way to reduce the code duplication. see azkaban.test.Utils#initServiceProvider
When assumption fails it emits an exception that is ignored by the runner (effectively, later part of this test method is not executed)?
I think it is more useful to the user to see the types of arguments rather than the value of the argument. If we want to push this further, we can even inspect the existing constructor arguments for the class and list them out to the user. I don't find it necessary to merge this change, though. Food for thought.
I prefer new Address[0] because I think it's easier to read than new Address[]{}.
Could you please replace event.getTarget with a variable to make it clearer
I think better code would be: component == null || component.length < 1 || ( component.length == 1 && component[0] == null ) Doing this validation in this method isn't ideal, but at least this way we don't allow things like: transform(player, null, <component> to accidentally become valid
**When using DelayedActionTriggeredEvents it's not enough to just filter by component. You need to set and check an ID for the event.**
Can we reword the error message for recovery?
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
again about redundant things - else block here and above is not needed,
Avoid hard coding the path, use Environment.getExternalStorageDirectory() and the local path as a string resource.
Need to exit the function here if the table was null.
Can you use a toast here instead? It'd be great to allow the user to see what's happening without having to fire up a log catcher.
list could be edited by other threads therefore it is not thread save maybe make a copy before iterating?
can't we use optional?
Instead of wrapping in the another collection, should this just add a synchronized block since it's a Collections.synchronizedSet()?  java synchronized (this.ejbClientContextListeners) { for (final EJBClientContextListener listener : this.ejbClientContextListeners) { this.ejbClientContextTasksExecutorService.submit(new Runnable() { @Override public void run() { try { listener.receiverRegistered(ejbReceiverContext); } catch (Throwable t) { // log and ignore logger.debug("Exception trying to invoke EJBClientContextListener " + listener + " for EJB client context " + EJBClientContext.this + " on registertation of EJBReceiver " + receiver, t); } } }); } }
The true parameter causes the contents to be appended to the end of the file, instead of re-creating the file with the new data. This can simply be new FileOutputStream(file, true), which defaults to false.
Since this is an exception block, please leave as println().
When we are on it: The catch(e) throw e is unnecessary here.
We don't need another ImmutableList.copyOf. You are doing this when parsing.
We shouldn't be accessing all properties like that. First it requires permissions for all which is not a good thing as it exposes everything. We should only access those we really need. In addition, this assumes that the system hash table persist in the system when in fact, it could be changed from under you by someone else via System.setProperties()
better to return an Empty Map, otherwise callers would need to check
Would it be possible to retrieve only message keys? Not sure if that is possible here
Can we change this to debug as well?
You should inverse the two lines above to avoid executing the BiFunction on each first time.
Does HQL have an "EXISTS"? If so, using EXISTS rather than IN may produce a faster query, and you will not need the DISTINCT fi.ingestion.
t'as besoin du WHERE exists(g.id) ? y'a des groupes sans id ?
I'd prefer to have the unknownFieldSet as the last printed stuff.
@tumijacob Rather invert this logic and throw if the user is null. You can then remove the else block and indent the remaining code one level less.
We don't return ResponseEntity, we ONLY return SimpleObject
@timler The reason for this is because one is an Exception that must be managed and the other is a RuntimeException like you have pointed out. Thanks for picking this though
need to pass Locale.ENGLISH here don't you?
Another check would be good to see if the requested VNFR is part of the given NSR.
HttpServletResponse.SC_NOT_FOUND
Agreed, makes sense to me.
Don't use DiscoveryUi.ID_PLUGIN here, we're not mylyn
Does removing an element from a collection inside a stream operation work or can this also lead to ConcurrentModificationExceptions? Use removeIf() instead? Also, the new logic removes all matching entries while the old logic only removed the first found entry. Does this make a difference or is there always only one match?
We don't need the AccessController.doPrivileged call anymore because this is now done inside of ReflectionUtils.accessMember. Just ReflectionUtils.accessMember(initMethod, () -> initMethod.invoke(viewModel), "mvvmFX wasn't able to call the initialize method of ViewModel [" + viewModel + "]."); should work.
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
@Nullable but actually, why allow null here?
Is it necessary to call this again?
you don't need use replaceAll, because above you used normalizeJson
Do we need to handle empty string?
This is probably not the right example. This specific problem goes away when you use the Right R class here. Can you modify this change to repro your case i.e have another module refer to the resource in its main code and this module invokes that piece of code in it's test?
what about setColor(int progressAndThumbColor, int backgroundColor) if they alway need to be set together?
Can you check the material color guide and maybe get a more interactive and interesting color?
Is order important here? Should the 2 collections correlate each to another?
should be: new HashMap<>()
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
should be singular, VTIDSection. It's not like in French (ex. un magasin de souliers vs a shoe store).
==
throw an error
I would rename the original createAuthConfig() to a private method with a distinguished name to clarify that this should be the single entry point.
What If both "docker.io" and "index.docker.io" are present?
See also DefaultDockerClientConfig::dockerConfigPath field
Will it not be a good approach if we get object using function **getItemAtPosition(position)** and then check from its attribute if particular video or group of videos has downloaded ?
Should be updated to use getSupportActionBar() instead of getActionBar() as in the [guidelines](<LINK_0> to ensure backwards compatibility.
you have already got listView as parameter, so no need to call "getListView()"
You can create mock mannually with SelfReturningAnswer instead of this code. To wit jsonRequest = mock(HttpJsonRequest.class, new SelfReturningAnswer()); P.S. SelfReturningAnswer is from org.eclipse.che.core:che-core-commons-test
Can you use Collections#reverse instead ? We're trying to not use Guava.
Can you move all these calls to the setUp() method?
I think we should TRY to move before we update the file path
Static import
remove else
@inverno We have 2 times "Second argument" :)
add a System.exit(-1) after the usage output
be a good citizen and call System.exit too :wink:
Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable
Using printedTable might make these assertions a bit more readable.
suggestion  refresh still shouldn't be necessary.
TimeUnit is easier to read than the SystemTime constants: timeToLive = SystemTime.getInstance().milliseconds() + TimeUnit.HOURS.toMillis(1); I had to read your code twice to pin down that TTL is creationTime + one hour. With TimeUnit, its one read to understand.
are we allowing negative values other than -1 for timeInMs arguments?
can you define a constant for -1 and name it as INVALID_TIME_REF
set to 'null' and create a default in AbstractObjectConfigurationProvider
That can't compile anymore.
I think the cache name would work better as an NDC set by CacheImpl.start() or ComponentRegistry.start(). And I'm not sure why you're using this.getClass().getSimpleName() here, do you expect DefaultConflictManager to be subclassed?
Casting to MenuItem is redundant here
If the feed is null, the menu items should still be setup. Just the feed title can be left out. That prevents possible flickering when menu items are displayed/hidden for some feeds.
Variable not used; please, remove this line.
Leave out this line, the processException will already log it.
Leave out this line, the processException will already log it.
Perhaps also log the stacktrace, it is useful in a lot of cases.
I think It's needed to convert to milliseconds.
This if statement can be replaced with user.setAvatar(parseImage(jUser, "image")).
Should we multiple 1024*1024 to get the number in bytes?
@cuenyad use factor variable
use StringUtils.SPACE
add final
Check: <LINK_0>
Not sure how just the host, especially if extracted from a URL object, could have a trailing slash.
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
It might be interesting to allow CNull here, actually, to allow for more flexible code. Setting a CNull would clear the command.
Does this make sense with just one value? Also, here's a neat trick, you can turn insufficient arguments into a compiler error. implement optimizeDynamic, throw a ConfigCompileException if children.size() < minSize, then return null.
CastException, not format.
final IPath pathString = Path.fromOSString(path); is needed and pathString needs to be passed to the createLink() method below. That's why the Unit test fails.
When opening a trace in the unit tests, the resource is often set to null, it is not required. But then we'd have to see where the supplementary files are stored... (path of the state systems of analyses generated for this trace), so that we don't have orphaned files. Does having the resource make the supplementary files deletable?
is this the tracetype id or something else? if so consider trace.getTraceTypeId()
Interesting. Since we're guarding for null here, it might also make sense to log this in case it is null. Wdyt?
Rather than hiding just the completion button for teardowns, should the entire conclusion fragment be removed? I don't think there is any conclusion text so the only thing we might want is more sharing controls if we ever add those.
Passing in a null here should probably be allowed as a way to clear this box.
ERR_DELETE_ERROR, add if there isn't one already
Be explicit about e.getMessage here? (and perhaps enclose it in double-quotes)
With these changes e can be DbException.SQL_OOME, I don't think that it's a good idea to accumulate suppressed exceptions in this constant.
Not required
The event bus should be registered on onViewCreated(), and unregistered in onDestroyView() since we only interact with the views in the callback.
I think we should try and find an alternative to exposing onCreateAware and wrapping its call in a try/catch. When possible it is good to avoid wrapping large pieces of code in try/catch statements because doing so lets us be lazy about when things fail. I'll poke around and see if I can come up with any ideas.
style-nit: remove curly brackets around single line block
you can use IStructuredViewer::getStructuredSelection
Okay then I will apply a patch for your proposed bug report.
What about new File(internalFileDir, fileName.name()).getAbsolutePath()? I think we should not create paths by concatenating strings
if (WHITELIST_REGEXP != null) Isn't checking a constant for null too defensive?
I think we can still end up with < max threads in the following case: there is only 1 thread doing work, rest are waiting on queue.poll the thread is going thru files or the list responses are slow. it is yet to queue up any subdir. The rest of the threads timeout and fall of their thread main
This would probably work 90% of the time, but the value that should be tested against the current value is the response from 'asMessage(text,args).
In this case text.get() is the empty string "" - why are we prepending a newline here? Should it rather be: java if (text.get().equals("")) { return arrayText; } else { return text.get() + "\n" + arrayText; }
Could you possible make a TextMixin for this? I think that we would use it a lot more for other widgets. With this approach, we can get rid of the HeaderPanels and such that were created, right?
use translateText
setRotation() requires API 11, but min is 7. Guard the use of this newer API?
Change this to null instead and add auth_rsp != null check in getIccSimChallengeResponse(). That function can return null if auth_rsp is null.
Not necessary. The web plugin should be bound in the Gerrit-HttpModule.
Bind these in the system module, aka Gerrit-Module. Its much less complexity for anyone to deal with.
please try to line wrap lines longer than 80 columns why not the more direct: ClassLoader parent = PluginLoader.class.getClassLoader(); new URLClassLoader(getPluginURLs(jarFile), parent)?
It seems this log is for your debugging. Do we want to remove it then?
shouldn't we check for if (_closed) before we check for if(_next)?.
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it.
why not use walk.parseCommit() instead?
Should we be reusing the walk we've already setup? Why create a new pool of revision objects when we can just reuse the one we already have? On the other hand, a walker could dispose of object bodies, and a reset and reuse might confuse the caller because the bodies are gone. That's actually a bug in RevWalk that we should probably address and fix there rather than forcing an entire new pool to be created for a second invocation. Likewise, RevWalk discards the starting commits when it resets. We probably should allow those to be retained somehow, so the same walk can be executed again without needing to maintain our own copy of the starting points (RevWalk calls them "roots" inside of itself.) Finally, RevWalk's implementation of Iterable is probably wrong. It only works once. Creating a 2nd Iterator fails. So we probably should fix RevWalk first so its iterator() method resets the walk and starts it over again.
method.getMethod() is already clear. You don't need to extract this method. Please get back to method.getMethod()
this comparison is not required to avoid NullPointerException?
What is the purpose to catch it? can we remove the try-catch?
is this really necessary? you destroy the activity anyway.
FIXME: All front facing strings go in strings.xml.
no.
You can make this method more functional if you want :)  java return Arrays.stream(services).flatMap(service -> { Collection<Class<?>> serviceInterfaces = serviceProcessor.extractServiceInterfaces(service); return serviceInterfaces.stream().map(serviceProcessor::introspectServiceInterface); }).collect(Collectors.toMap(ServiceDefinition::serviceName,def -> "service"));
suggestion var service = getCandidateServicesToMatch(serviceId)
this should check null and return empty list no?
it's duplicated by convertSampleListToTreeNode
IMHO it's better to explain proposal of setup debug id here to prevent occasional removal in future, like the follow: > do not remove debug id; it's needed for selenium tests
Actually, I just re-read the spec, and in Section 14.16 it says "If a query matches two or more nodes in a shared set, whether all of these nodes or just one is returned in the query result is an implementation issue." Up to and including 3.x, we only returned one of the nodes in the shared set because it was the easiest to do with that implementation. IMO, that behavior is the hardest for clients to deal with, because they're going to get back one of the nodes in the shared set (and which one they don't really know). Perhaps it's time to change this in 4.0, and return all nodes in the shared set.
Does the segment delete need upgraded locks?
Should we do an eic?
I think you could make SegmentPublishResult.fail() a static object instead of a function that returns a new one
Never swallow exceptions without at least logging them. In this case: Why not throw them?
can we remove the version completely?
I *think* that adding the disco feature is unnecessary in this place, as the ServiceDiscoveryManager already should announce that by itself.
i think you could use only the timezone variable, set it inside the if here, and nothing to do in the else
maybe also expect the correct olsonTimeZoneId here?
see above wrt logging
on the catch, let's add a servere logger
Should the whole stack trace be logged? This exception is handled by the notificationSenderCallback
log statement has to be changed.
I think we should prefer a setter here rather than member variable access.
Seeing this essentially duplicates the load code above, I feel there must be a more elegant solution to this - something that just retriggers loading of all the existing observable's data...
I prefer the ?: syntax, also I think isLight is a leftover from the merge, because it is not needed suggestion mSwitch.setIcon(mLinear ? R.drawable.ic_apps_white_24dp : R.drawable.ic_list_white_24dp);
It would be good to verify that each export dir contains a disjoint set of file names. This may be a good place to do this check. If the check is not done and someone make mistake it seems like it could lead to multiple entries for same file, but I am not sure.
Doing importDir + "/" + sa[1] repeatedly has the potential to use a lot more memory than just sa[1]. Maybe this could be an issue for really large imports. This could be addressed with a value object that points to importDir. Something like fileNameMappings.put(sa[0], new Pair<>(importDir, sa[1])).
Should we throw an error here?
ignore if you'd like: Bookmark bookmark = getModel().getSelectedObjects().isEmpty() ? null : getModel().getSelectedObjects().get(0); BookmarkModelProvider.this.getModel().setSelectedItem(bookmark);
what is the point of setting path to null here. It looks like it is only needed in the if statement above
rename to delta?
- Use isNotBlank() better? - Long? for sure integer is enough. - Check safely if it is a number?
We could check the envelope first.
You did not introduce a handling for NumberFormatException, something you removed from the calling site. Was that deliberate and if, why?
Missing opening "(" before getDescription().
Is it legitimate to see null master here? if yes, this change can lead NPE.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
Keep this static imported?
This can be private again.
@highker typeManager member variable can be removed now
Better to write unit tests for these conditions
Why not just pass in only the message?
Shouldn't we put back the check for getData() not being null? Of course in addition to what you have just added. :)
endIndex
I would change is back to 50 for consistency with CDT.
Why maxSize + 1?
Again, don't clone a new event. In the new code change, the "else" will only be executed in very very small time windows. You have proved that when the sender is shutdown, the eventProcessor will be kept. So enqueue will not go to the "else". We will never worry about the tmpDroppedEvents become too big.
Make the returns in-line with the cases for conciseness. eg.  case KeyEvent.VK_UP: return UP  And make UP/LEFT/etc. static final variables.
Not necessary
It's always a single item collection. Why not add another one even though our current implementation layer does not support it.
Could we please use non empty expectedDataTypes? Test in the current form will pass even if we change this line to when(dataTypeUtils.defaultDataTypes()).thenReturn(new ArrayList<>());
Perhaps nameToDataType.
Perhaps also desirable to call track(Node, Credentials). (For BindingStep, just inject a Node; for SecretBuildWrapper, use the method on AbstractBuild IIRC.) @stephenc any guidance?
nit: Maybe change the wording slightly to emphasize "exact". suggestion listener.getLogger().println("Masking only exact matches of " + overrides.keySet().stream().map(
why ConfigurableApplicationContext, not ApplicationContext?
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
don't wrap at .
Shouldn't this be a field, not a local variable? It looks like it will get instantiated every time you process a temporal phrase.
Note that I asked one of the authors of the "one sql to rule them all" paper. The only reason that they use wstart and wend was because of the layout for a paper. I got suggestion to use window_start and window_end. I also believe in a JIRA or an email (sorry I cannot recall which one it is) we agreed to switch to window_start and window_end. So I will suggest we keep window_start and window_end, which can be understood easier than wstart/wend.
Suggest you don't create the defaultCall outside the loop. Most calls do not need default arguments. You could in-line the defaultCall method, because it's very simple.
Please invert if condition and put shorter branches to the top in the cases like that. The following is better than heavily nested code:  if (canCastFrom){ return true; } if (!throwOnFailure) { return false; } throw ...
not necesary
We're returning the same exception message here right? Hence, can we catch Exception only without catching all different exceptions? There's a typo in the message. /s/Faile/Failed
Java reader = new InputStreamReader(is, StandardCharsets.UTF_8);
It might be better to use Collections.emptyMap() instead of new HashMap()
why index is needed? what if multiple devices? all with index 0?
please replace with String.valueOf(vmDevice.getIsReadOnly())
Sad times, but I don't think we can easily work around this.
Where do these constants live? (it looks a little weird without e.g. AbstractTransactionTest.CONSTANT) (edit: answered myself by scrolling down a bit. but it still looks weird)
All of the setup above is also duplicated, so setup should take no arguments and return a TransactionManager instead.
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
Shouldn't this need to be done in the refresh instead of during the creation of the controls?
Can use Optional to avoid null checks!
could we catch a more specific exception? What kind of exceptions should we expect?
This can be a stream - filter - collect expression.
Nit: this is duplicated at line 48, I would get rid of this line.
I'd prefer if you put the Headers here in a local and did isSameAs just like is being done with body.
We should leave these as assertEquals and just add the MariaDB check since we are not making the global change to assertj on 2.1.x
Use type.getObjectValue to print the indeterminate in the error message to help user debugging: java throw new PrestoException(INVALID_FUNCTION_ARGUMENT, "map key cannot be indeterminate: " + mapType.getvalueType.getObjectValue(session, keyBlock, i));
I'd restructure the code to decode first, then write the entry (so you never have to worry about it being inconsistent because it can't throw during the write)
nit: you can return in the if block and get rid of this else.
There seems to be a convention established to update these metrics. For e.g. replicationMetrics.updateMetadataRequestTime(metadataRequestTime, isRemoteColo, isSSLEnabled, remoteDatacenterName); Is it possible to follow the same kind of convention here (updating via a function)?
why is this not final anymore?
getReplicaLagInBytes
Maybe mix multiple timezones? The idea really is to trigger a failure, so let's not make it easy for tests to pass... In particular, I would use local date/times that are not ordered, but become ordered when you take into account the time zones.
Here too, using at least two different timezones would be nice, be it only to check that the timezone is not retrieved as "Europe/Paris" by chance, because it happens to be the JVM default time zone.
Looking at this code, the FRA and FxSwap cases are clearer without conventions ;-( Please revert
This introduces a bug: since there are two possible SegmentWithOvershadowedStatus for each underlying DataSegment, now the same segment can be in publishedSegments twice for a period of time. There's a few ways to deal with this: 1. Make publishedSegments a TreeSet<SegmentWithOvershadowedStatus> and update the entire map atomically. This is a super clean solution but would burst to higher memory usage (it would need to keep two entire copies of the map in memory when replacing them). 2. Make publishedSegments a ConcurrentSkipListMap<DataSegment, CachedSegmentInfo> where CachedSegmentInfo is some static class, defined in this file, containing the updated timestamp and the overshadowed boolean. If you do this, the SegmentWithOvershadowedStatus won't be stored long term anymore. You could minimize memory footprint of CachedSegmentInfo, if you want, by making the timestamp a long rather than DateTime. 3. Make publishedSegments a ConcurrentSkipListSet<SegmentWithOvershadowedStatus>, make SegmentWithOvershadowedStatus mutable (in a thread-safe way), make its equals, hashCode, and compareTo methods only based on the dataSegment field, let its overshadowed field be modified, and add a timestamp field to it. When syncing the cache, get the current object and mutate the overshadowed field if necessary. Btw, a ConcurrentSkipListSet uses a ConcurrentSkipListMap under the hood, so the memory footprint savings of this aren't as much as you might expect relative to (2). (2) is the variant that's closest to what the code was doing before this patch. One thing I don't love about it is that it is racey: it means that if a set of segments is overshadowed all at once, callers will not necessarily see a consistent view, because the map is being concurrently updated. They'll see the overshadowed flag get set for the underlying segments one at a time. But the same problem existed in the old code, so fixing it could be considered out of scope for this patch.
minor: logSegmentNamesToReturn
Should the log say "unknown segments" instead of "unused segments"?
Is it a conscious decision to throw an unchecked here?
You may also want to verify that the dir is writable.
Include the path in the failure message?
It's java.util.Objects.equals(dims, that.dims)
does it matter that you are not comparing owner (PublicKeyHash)?
Please annotate DruidServerMetadata.getName() as @Nullable. Please use Objects.equals(), or regenerate equals and hashCode using intelliJ
why if is here?
If you are using synchronization to control access to the session data, than I would suggest reverting the map type to a simple HashMap and synchronizing around the map as opposed to this whenever you read, put, remove, or alter it.
I just noticed that this should be updatedSessionData.getAllAttributes(), not sessionData. It's not a big deal, just a minor performance tweak, so I think we can address this in a follow-on PR.
Don't use addFileUrls, just add to your urlList
We shouldn't ignore an invalid enum value.
You get it right. Per code conventions, I like to see brackets around if and else clauses.
Minor: tweak the spacing here? i = 0; i < 5; i++
Why are you not using your UsbSerialDeviceInformationGenerator?
PlayerBackpack is redundant here, no need to specify the class you are already in.
not even e.getMessage() ?
Unkonwn => Unknown
Unkonwn => Unknown
String concatenation here as well ?
Use workspaceId here and below
If it is clearer then method name clear looks more natural for me than remove
It would be better to strictly align these variable names with the method names. Since there are methods of both Resource and ResourceInfo, I would suggest to also include the class name. E.g., - resourceSetResourceInformationMethod - resourceInformationGetNameMethod
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
This was purposely catching both checked and runtime exceptions, hence catch of Exception, because if this were to have a fundamental flaw causing a runtime exception it could conceivably kill all sling resource fetches.
I would rename it to something like migrateLegacyPreferences to make it more clear what it actually does.
The value checking is not needed here, only the preference. We already check the value in the other test.
Please use lambdas where possible.
create a method called getOrCreateContext() and use that
I would always suggest logging the full exception at DEBUG level for troubleshooting.
Unrelated to your change but this whole finally block is a crazy amount of thread reset state!
well, the probability is very low, I know, but shouldn't be >= ? in terms of readability I would prefer to have if (fetchTime.compareTo(vmManager.getLastUpdateDate()) > 0){... } else {.. } - but that's subjective I guess, so for your consideration
it would be safer to take the lock first and then check-and-update the time stamp
super.getVm() will do dao call...
So you have default settingsfor userId and NetworkAccessPointId and NetworkAccessPointTypeCode, if an exception is thrown but not if the url is null. why is that?
You line wrap MUCH later a couple lines down; should this wrap later on this line, or wrapped earlier down below?
This is the only place you put an "else" after the "if" returns -- for consistency, change this to not use an else statement.
The check item.getUrl() != null is not needed.
typo: factotry
Bad code. Remove try - catch.
On line 133: partitionSession = getPartitionSession(subscriptionId, eventType.getTopic(), cursor); you take topic from event type. I think it does not make much sense.
Why is it required to do it for every event type in the subscription?
This looks strange that we can not provide comparator for that and instead we have a separate class to hold the values. I see that EventTypePartition class is used only in CursorsService, do you think it will be good to have it as an inner class?
Why didn't you add it to 'ExternalRegistrationConfigurationMapper' like the other mappers?
in /export action we use action.isExclusive(), please do the same here.
why you making storage_domain mandatory? - doing this will break api, import() has default logic when no SD specified
does this mean that we won't try to flush the last session counts when the application shuts down?
Can use ThreadUtil instead.
Create a queue size property (with a default value).
looping with a char is kind of weird?
If metadata was not already 0, the old bits are not cleared. Also metaData should be range checked (or just & 0xF'd).
Something is wrong with this method: 1) it has code duplication that can be extracted to another method 2) it always tries to load both tables 3) while assuming Section.SHT_SYMTAB has a priority for some reason
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
Feel free to ignore: Do we really want these this there?
how about to move line 439-441 to be before line 435 - not because of performance but to make it more clear that in this case we don't need the cluster version
We don't need another ImmutableList.copyOf. You are doing this when parsing.
could use  java packages.addAll(pkgs);
Optional nitpick to be aware of in the future: you can simplify  List<Package> sortedPackages = new ArrayList<>(); sortedPackages.addAll(pkgs)  to List<Package> sortedPackages = new ArrayList<>(pkgs);
I have a strong negative reaction to assignments within conditionals. * They are surprising and therefore liable to be overlooked or misinterpreted, especially given that "=" is a mathematical symbol for equality. * They are hard to reason about. Please rewrite this code to avoid assignments within conditionals.
nitpick: rename _expression_ to _functionCallArgument_
having dedicated method in method matchers would simplify this
Please kill this empty line.
I'd call the variable entityClass
Having short class name may be confusing. There can be cases of large applications that have the same name of things, but in different bounded contexts. E.g. consider "Order" for in two parts of a larger app that deal with different kinds of orders. Please pass FQN.
nit: it would be more efficient to keep a local variable with the count, and update the meter at the end. i don't have a great sense for how expensive that getMeter call is, but i assume it has to access a couple maps
Remove conditional + exception. Uniqueness is guaranteed here.
please correct me if i wrong here: on each batch of updates now we will try to take a lock to select correct populator from cache while that is required only first time when we need populator for that key. As far as i can see particular populator accessed from one thread only (population job itself) - would it be possible to keep local cache of already selected populators, since those never change as soon as they created?
Isn't this going to throw even if one of the ids is bad? Do you want to change that to continue processing valid blob ids?
Strictly saying, this should be new ArrayList<>(count);
A method should have only one return statement instead of two. Use a local variable to get the result and return the local variable. Change in other methods as well.
Do we really want to catch Throwable here? How about ClassNotFoundException?
Strictly, should also do if (resolve) resolveClass(result); (in case a class has been added that has not yet been linked).
Why the sub string ?
maybe, it would be better to inline that actual following way:  java Matchers.containsString( new StringBuilder() .append("<a>") .append(System.lineSeparator()) .append("<b/>") .append(System.lineSeparator()) .append("</a>") .toString() );  what do you think?
Don't use final here.
Isn't there some simple little library for generating JSON output? This seems icky, who knows whether item.getItemID() returns something nasty containing backslashes and whatnot...
The purpose of this test is to throw inside the onError block. I don't understand why you removed the IAE
"old" is the user identifier, right? I would rename that
IllegalStateException
Strings.isNullOrEmpty can simplify the code.
Check for eTag.length() >= 2?
Better to use the same name for both: "sluggedName" or "uriName"
> When we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom. true
Please use Vector.ofAll() instead of Stream.ofAll(). See an explanation below (at the Option.sequence() change).
We provide 'user friendly' messages on NullPointerException, here:  java Objects.requireNonNull(values, "values is null");
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
The collection has been already initialized on line 189.
We shoul get the exception (most likely if different type as DynamicUtils is in jbpm-flow so ProcessDefinitionNotFoundException is not available there) here and then wrap it with ProcessDefinitionNotFoundException and rethow it
What would the previous code have returned?
in this test, you can use the object Dimensions to verify no only the pattern, but also the rest of the class logic
why not give this class scope?
Have String headerKey = key.toLowerCase(Locale.US) only once to avoid repeated case conversion.
nodes should be declared as Map, not HashMap (the cast should also be to a Map)
this can be done simpler using a sorted stream of param entries to produce output string
@xpdavid is this the right thing to do?
Can this be private, or is there another use case for default attribute outside the builder's call?
have a default constructor with reasonable default values
This is completely redundant as the Listener which calls this method already checks if it is cancelled. Also missing brackets.
Another example of setting null before loading...
Don't you want to give count as the capacity hint?
that's invalid anyway, isn't it? what's the meaning of CLUSTER_DEFAULT on cluster, you can never set it. autodetect==null, and then only concrete values are allowed
For each refactor
What's the advantage of Optional here over returning null or the groupUUIDuuid?
please also replace UserAgentContainer.AZSDK_USERAGENT_PREFIX with hard coded value for the test
@brunoliberal We already have a class to do that. Take a look at TechGalleryUtil
please always put new line at end of line.
getMethod(methodName) can throw a SecurityException as well.
This is recursive, do we need to worry about an infinite recursion?
This isn't really expected, but we can recover from it. I think this would be better using the error level.
is /./ necessary?
NIT: File has a constructor with two params for this kind of usage: java new File(j.jenkins.getRootDir(), "config.xml");  should be equivalent FWIW
rename to automationContext
code dup. would be better to move it to private saveInternal()
Fire the event outside of the monitor.
Nit: would you like to say "flow pause requested by user"? It's not given that it will be paused at this point, right?
Mmmh, I'm not sure to follow you here. What is bothering me is having two times the same message on the same tree (so a duplicate of Location). So why considering the kind of the tree and only the message value? It's probably way simpler to rely on equality of locations to filter out, with a LinkedHashSet for instance.
I think that domains.stream().anyMatch(d -> d.isAssignableFrom(lc.constraint.getClass()))) really deserve a dedicated method. It's not that easy hard to understand what it does, and a named method could be more explicit. I wonder about using direct access to the field rather than method call. Seems not coherent to use both approach, as both field sv and constraint are visible from here, I would also change the lc.symbolicValue() by lc.sv
Under some conditions I'm running here into an StackOverflowError: java.lang.StackOverflowError: null at com.google.gwt.user.client.ui.TreeItem.getChildCount(TreeItem.java:371) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:538) at com.google.gwt.user.client.ui.TreeItem.setState(TreeItem.java:528) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:310) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) at com.google.gerrit.client.admin.ProjectListScreen.expandTreeNode(ProjectListScreen.java:313) ... One scenario in which I'm getting this error is when I filter for projects having the parent 'parent2' while having the following project structure: -- All Projects -- -> parent1 -> parent2 -> (project1, project2, project3)
I think you meant LOGGER.debug("Initialized debug logging"); ?
This is sort of awkwardly phrased, should change to something like: "Should have failed if session.execute called when cluster was closed."
Don't think we should add methods for such fine-grained elements.. getClusterValidity().getStart() should do (of course, with a null check).
Hmm. do we log tags? Probably a good idea but C Git doesn't.
please invert the conditional operator to get rid of the negation
TagOperation.execute() and RefUpdate which it is using will fail if the tag already exists, points at a different commit and the force flag isn't set
suggestion if (isZipFile(Files.getFileExtension(filename))) {
Nice. The intent is more clear than using a file in the previous version.
end should probably be private static final String. Doesn't make sense to create new local variable in a while loop..
we set Logout only if a displayable id is present? What about ADFS?
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
Instead, use <code>android:textAllCaps</code> property for the <code>TextView</code> in XML. This is good, if this dialog class is supposed to show some other contents where buttons do not have text in ALL Caps.
EditedStyleItem item = (value instanceof EditedStyleItem) ? (EditedStyleItem) value : null;
You will probably want to ensure an ItemComponent exists on this first before doing this check. This has bit me more times than I care to admit.
Could you please replace event.getTarget with a variable to make it clearer
is logics correct here?
I think you have a potential bug here because you didn't include a file seperator. Did you test the feature in a real environment?
indentation is 4 characters/1 tab length too far and the way this is spanned is odd. Also, when you're chaining multiple calls and you hit the line limit, split it on method calls:  envId = this.getEntityManager() .createQuery(jpql, String.class) .setParameter(...) .setParameter(...) .getSingleResult();
viewName and viewIndex don't seem to be used in the tests below - probably testGetSourceTableName_index() and testGetSourceTableName_viewIndex() ought to use these instead of tableName. If not, consider removing them.
Are we doing to remove this? Since this leads to a bunch of hosts looking like leaders due to metrics, it becomes extremely difficult to debug for people not familiar with these issues and the symptoms of this change. The last oncall who had to debug this kept thinking we have multiple leaders, when we actually don't.
Why do we need this? if we really need a different method for Hex Id, then why not _zkClient.getHexSessionId directly return the Hex(_sessionId)? This embeded calls looks a bit weird
only if name changes?
Does IOException means invalid blobid?
I am not 100% convinced if this would be a trace info. We probably won't need this information to debug the internal work flow, but whenever this information is needed, there should be some error (or complaint from users). So from logging perspective, it more looks like an error.
Not relevant for this PR, but I'm curious: why is the TrustAllX509TrustManager necessary?
Let's test some older version like 1.18
We are already in an instance of this object and yet the method you are calling creates a new one just to call a method that is already defined here. This leads to un-necessary object creation, plus the cache used is different then this one which means that the property are reloaded multiple times. This applies to all your static methods you use like this. May I suggest that you provide and internal non-static method for those and that your static version (if still used outside of this class uses that one after creating a dummy instance).
Redundant replicationSpec.isInReplicationScope().
Need to set it only if !context.isDbNameEmpty().
in 3.0, the external tables are created inside warehouse directory. context.warehouse.getDefaultTablePath .. takes if the table is external or not as a parameter.
Should we log a warning or throw an exception in the else of this if? I don't think we want to just quietly ignore a put call...
The current implementation doesn't really make sense to me. Can I suggest something like this instead? java public void cellValue(ByteString newValue) { // Optimize unsplit cells by avoiding a copy if (nextValueIndex == -1) { this.value = ByteStringer.extract(newValue); nextValueIndex = newValue.size(); return; } Preconditions.checkState(nextValueIndex + newValue.size() <= value.length, "Cell value is larger than expected"); newValue.copyTo(this.value, this.nextValueIndex); nextValueIndex += newValue.size(); }
what if key is null. I don't see any tests for this. What's the reasoning for shallow copy of the map? This changes the result and possibly impacts people who assumed it would not be a shallow copy.
Above three lines are duplicated.
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
These can be in the field declaration.
The empty string in the constructor is redundant.
Should this be expectedException = rule ?
You could use assertNull(...) here rather than assertEquals(null,...)
Instead of getting the matrix every time you update it, build the matrix entry-by-entry and *then* put it.
throw RuntimeException?
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
once this iterator(true) returns.. then aggregate(key) is called.... is it possible that the iterator then returns unsorted result? (however, it wouldn't be a problem because iterator is generally called after all updates are done)
Why is the purpose of this line?
do we even need to report this given there is a whoAmI which reports this in a much nicer way (and most users won't check the headers, and most scripts can't take any action)
Use enhanced for loop here: for (Header header : headers).
add final?
Mid return may worsen readability
Do you need the inOrder here? You're checking for a never and then for a single call. Wouldn't it be the same if they were not in an inOrder?
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
The bounds here should adapt themselves On all your controls of your two wizard page, try to use some layout data elements. For exemple control.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); Look for examples in Sirius code base (property section, wizard, dialogs)
We should have at least some kind of detail here, e.g. "Rebase this patch set against master head?"
types --> type
why use domain id from parameters and not from storage object from method parameter?
Could you please rename also _result?
e.getCause() can be null, causing to NPE. please use here e.printStackTrace()
Do we need any tests for the changes in this plugin info builder and others?
Can you make this show a useful message back to the plugin?
log this instead?
This change looks unrelated to fluids? Seems like it belongs on a separate PR ;P
Is there a reason for this short circuit? I know I'm probably nit-picking here, but I feel that this would be "slower" than not having it, due to extra complexity preventing JVM optimisations.
I think this method can work just like set(). You complement the intMask with ~ and then &= it.
is this ok? Shouldn't we return null / empty string here?
This is easier to read as: return type.getClass().isArray() || isList(type);
This method can be static, as all the methods it calls.
rename to sash
This is triggered by an async task. The control may be already disposed, so we must check if it is still alive before we start doing something with it.
I think you can write this as java tableColumnReferences.computeIfAbsent(accessControlInfo, LinkedHashMap::new).computeIfAbsent(table, HashSet::new);  This also avoids creating empty maps when one already exists.
I would rather have the toolchest stay in control of the merge operation, it seems odd that some merge operations would be defined within the toolchest, and others outside of it.
It should be possible to drop the DefaultDataSourceProvider Service interface and simply replace with with serviceLoader.onlyOne(DataSourceProvider.class, JndiDataSourceProvider.class). That will use JndiDataSourceProvider if no other DataSourceProvider is found
Perhaps create a named constant for the interval since it's in the asserts for several of the new tests
You may want to use assertEquals directly?
You want to use assertEquals instead?
nit: there is a static import for assert.* above, you can avoid having Assert.
please remove.
it might be worth having this as a constant with a quick explanation for why it is needed (emulator's deletes are not instantaneous).
@simplynaveen20 Non-blocking, what are your thoughts about combing these?
I'd consider writing a helper like this to remove boilerplate:  private <T> List<T> nullToEmpty(List<T> list) { if (list == null) { return Collections.emptyList(); } else { return new ArrayList<>(list); } }  and then call it in constructor like this.mavenOuput = nullToEmpty(mavenOutput);
Is this wanted functionality? Making a new list will mean that this won't refer to same object anymore, which was what was done in the original situation.
Is this wanted functionality? Making a new list will mean that this won't refer to same object anymore, which was what was done in the original situation.
debug/trace/remove?
I'd prefer overriding of setEntity() method to listening for events in this case.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
It isn't clear to me where this user is created?
Shouldn't we check an error code or something before we do this lookup? otherwise, we will end up doing this lookup for all exception scenarios, isn't it?
same... no need to check is existing
I think we should TRY to move before we update the file path
Why do we have the full name here? I did not see another FileUtils being used here.
we cannot do this. :(
The last ask about using ZERO_ constants was particularly about makeObjectColumnSelector() methods, because they return Object. This method returns primitive so the change here is pointless (and in some other places in this commit)
0.0
0.0
This cannot be removed. The scheduled task needs to be saved.
The method name for handleScheduleTask suggests the method deals with scheduling a task. It looks like something like handleScheduledTask is what actually happens.
rename "synchronizeTimeRequest" variable.
Could you please add curly braces?
Seems like this is only set on the business object does underlying method set it on the entity and persist the change?
Why the sub string ?
One of 2 things should occur here: - Opt A) throw the exception ( add it to method signature ); not the generic Exception, but the IOException one - Opt B) set file to null, so it ends up getting returned as a null object, rather than a corrupted one If none of the above occur, and in a scenario where some exception takes please, the person leveraging this method would never know of it, and rely that the returned File object is a solid one.
either move this to finally or use try-with-resources
The true parameter causes the contents to be appended to the end of the file, instead of re-creating the file with the new data. This can simply be new FileOutputStream(file, true), which defaults to false.
I think this might lead to unused space on the right, when one of the columns has a higher preferred width than it's maximum (because you don't redistribute the difference among the other columns).
Could you add a system property check for Linux? See line 448.
Isn't this equivalent to the below? java final GridColumn<?> uiColumn = newRuleNameColumn(makeHeaderMetaData(column), Math.max(column.getWidth(), 150), true, true, access, gridWidget); uiColumn.setMovable(false); uiColumn.setFloatable(true); uiColumn.setVisible(!column.isHideColumn()); uiColumn.setMinimumWidth(150.0); return uiColumn;  We could declare 150 as class constant if answer is yes.
Is this idempotent? PUT should be idempotent. What happens when we call failQuery for a query that's already failed?
is this the right check?
Move this method above, so that it's directly after killQuery. That will make it easier to read, since the long helper method will no longer be splitting them up.
you don't really need to get explicit index tx state twice
Stream#of() can help here as well.
Why check isEmpty()? I guess empty index names have been eliminated before getting here.
This method need not be static
We could make this as static method.
suggestion if (password == null) {  Code style
this should be outside the loop? Otherwise it will only check for the first brick in the list
Guid should be compared with equals.
It will never reach here, as you break after found=true. Add the found = false after for (GlusterBrickEntity paramBrick : bricks) {
Name it folder, or reuse doc maybe? domain is misleading.
Why do we need this ? Should be done by DublinCoreService
Is it possible to assert the message against a string ?
What about extracting this block of code into a private method? Ideally, public methods should be like pseudocode (no conditionals, fors, etc.).
if we move unsubscribe to onDestroy, here it is not necessary invoke it again
Here you are setting activity argument to a presenter but the presenter is only presentation logic and a presenter should not know anything about Android Framework
Hard-coded. What if we add another format in the future?
Minor thing: please use "something <operator> null" convention.
I suggest to improve the debug message in this case, and mention in it also the returned value of "lookupSupportedLocale(locale, getLocaleKeys())", especially if it is != locale.
Don't add a rollback handler, override rollbackRuntime, which is called by the RollbackHandler added by the superclass.
WFLY-4294 says this op will fail in runtime on a server. But it looks like this one is still adding services.
The core version doesn't actually process capabilities, but I can't think of a reason it shouldn't. A JIRA should probably be filed to enable it. Also we should process the attributes too.
You should be able to pull the conflict overrides directly without needing to rebuild from the string array. If that's not working, there's a problem in the new serializer paths that we need to address. Ideally the following line should work: ConflictOverrides overrides = args.getAs(CONFLICT_OVERRIDES, ConflictOverrides.class) If so, the setter above should also change accordingly.
Does it make sense to validate before we schedule the job as well?
![MINOR](<LINK_1> 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable "jobId". [![rule](<LINK_0>](<LINK_2>
If you don't return here, this will run only after current repl dump execution? What is the order of execution in the current case?
what if delete fails /system goes down after the dump ..how to cleanup the previous dump directory ?
why cant external table copy task goes in parallel to other tasks
This should probably be an error since it is fatal and that way it will be seen by apprunner
Minor: These statements could be merged to 1 if
Fix message
Since it is major websocket endpoint it should be logged as error
I think e as a variable name would be prettier than executor1.
let's make a meaningful constant for 5
You omitted that blank after the == on purpose, right? ;) But without jokes, that means one cannot retrieve a node entity without explicit @NodeEntity.
please reformat. the line is too long.
I support doing the same here, yes
Shouldn't you add the colums disposition, disposition_type and disposition_log_guid?
Instead of returning a modified selectionArgs but not selection please switch this to follow the existing pattern of returning an Object[] that has both the updated selectionArgs and selection. Less risk of bugs from the two being out of sync.
Can be written shorter as while (cursor.moveToNext()) {   }
I think we should also display the involved branches/commits which the user tried to merge (in the same way we do that for a plain merge operation failing due to merge conflicts)
it looks like createMergeConflictInfo() always shows the warning, then adding the warning should be an implementation detail of createMergeConflictInfor() and the mergeResult needs to be passed to it as a parameter
use multi-catch ?
Isn't the devfile detached from the JPA session when it leaves this method anyway? Why do we need to create a copy of it?
an exception while resolving an exception (INCEPTION)? Is warn the right log level? Or should we go error?
Why cant we just cast to (Map<String, String>) keep the null as it is instead of creating an object
make this one final maybe? there should never be a reason to override this
findMaximumTickLabelWidth & findMaximumTickLabelHeight are identical to PercentileLogAxis.findMaximumTickLabelWidth & PercentileLogAxis.findMaximumTickLabelHeight. Perhaps they could be extracted to some other class (e.g. AxisUtils)?
just minor thing, but all these methods are duplicating code... probably you can create a common function that takes the shape and a Function<Bounds, Double> and does the different null checks etc, and then the methods xOfShape, yOfShape etc would be refactored by using as a second argument the function (bounds) -> bounds.getX(), and so on...
Not directly related to this PR. But at some point, we need to update <LINK_3> <LINK_0> They say " It is the average amount of time it took for ack or fail to be called". But the latency is only calculated on ack not on fail. The original code <LINK_1> is implemented the same. I believe this is a mistake introduced in <LINK_2>
that's redundant because of the call to the empty constructor at #192
Can this be private, or is there another use case for default attribute outside the builder's call?
Should be updated to use getSupportActionBar() instead of getActionBar() as in the [guidelines](<LINK_0> to ensure backwards compatibility.
Format this file with A.S. default formatter.
More descriptive name
Start message from capital letter.
Add a try/catch block and log any errors. Don't want logging to affect any normal operations.
Any reason why not to move these events firing to WorkspaceProjectServiceImpl as well? At first I think it would be better, so REST changes are also observable by the screens.
is 404 not valid anymore?
Please consider adding a Precondition.checkArgument to check that key is not blank.
you can use the constructor with three args ( public GetObjectMetadataRequest(String bucketName, String key, String versionId)
sgtm
Same question, why not just use TEST_CALLBACK_TIMEOUT_MS here ?
Why keep timeoutMs at all ? It looks to me like it just was forgotten when we switched to the constant. Is there any particular condition in this test where 200 is not enough maybe ?
hardcoded value. Can you move this to a constant or get it some other way?
I would say use a flag  @garrettjonesgoogle thoughts?
Add better error message: at least explain that the configuration key may be missing (if so) or the class cannot be found
you have the batch service already as a class attribute
move outside the if please
How about using snaeService.wait(500); instead and calling notify(); in the event handler?
Is this expected to be just single udnerscore? Bbecause other chars are replaced by double underscore..
Tag @leeyimin here, I'm not too familiar with sanitization so I'm not sure if this is okay.
I know it's done in plenty of other places in the code base, but I would prefer not to use parameter assignment.
System.clearProperty can be used instead.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
I think this would be clearer though more verbose:  final Schema inputSchema = getChild().getSchema(); final Schema groupingSchema = inputSchema.getSubSchema(gfields); Schema aggSchema = Schema.EMPTY_SCHEMA; for (final AggregatorFactory factory : factories) { aggSchema = Schema.merge(aggSchema, factory.generateSchema(inputSchema)); } return Schema.merge(groupingSchema, aggSchema);
use VectorUtils.SPARSE_SCHEMA
Instead of the try-catch please use the ValidatingVisitor#getFailureOfSchema(Schema, Object) method. It can be a little bit faster, since it just returns but does not throw the exception, so the stacktrace generation doesn't take time.
Can you add a call to "DataCacheFactory.getCache().getCacheManager().clearAll()" as well? In the default configuration it will clear the same cache as the "report-dataset-cache", but if an OEM replaces the DataCache-implementation, we will cover their implementation too.
This is a global purge across all sessions.
Magic number
I think this line is too long. Did you apply the formatting rules?
There's a third constructor with a third parameter - variation. Not sure if it's widely used though.
Method must not be public as this method is only used inside this class.
I am assuming nestedActivity is already defined elsewhere in the project
Why is an exception variable named t?
You dont need the " result.getElements() == null " condition
Please consider adding the following Preconditions.checkArgument checks: * alias is not blank * cert is not blank * privateKey is not blank
Since we don't usually run with assertions enabled, please consider converting assert to Preconditions.checkArgument.
Minor Nit: certs is not an argument to this method. Please consider throwing an IllegalStateException instead.
I think it is better to perform instanceof: java if (value instanceof Integer) { generator.writeNumber(value.intValue()); } else if (value instanceof Float) { generator.writeNumber(value.floatNumber()); } else if (value instanceof Short) { generator.writeNumber(value.shortValue()); } else if{ //.... Long / BigInteger / BigDecimal etc.. } else { // use double by default writer.writeNumber(value.doubleValue()); }
I would put this on the failure path: if (!d.mkdir()) { if (skipExisting && d.isDirectory()) return; throw new IOException(...); } Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet. If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.
Isn't there some simple little library for generating JSON output? This seems icky, who knows whether item.getItemID() returns something nasty containing backslashes and whatnot...
nit: rename to runner?
Does this need to be public? If you need in tests, could you make it package private and mark as VisibleForTesting?
Minor: IllegalStateException.
Can you add the user to the logParameters as well please (there is a .user(String email) on the log builder so no need to do addParameter. Can you do this in all places where you added the new field (all places where it's already logging something)
Should this throw an exception or error? Instead of just printing the message?
add .log()
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
suggestion if (filter.getRelationshipDirection() == Direction.INCOMING) {
This code is almost a duplicate of getIncrementedSegment(), could be extracted to a method.
rename to child or childElement
rename to child or childElement
double parantheses should be obsolete here
StringBuffer is so 1900-ish. and adding the ", " is I think cleaner if you add it conditionally
- use RemoteConfig here which knows how to parse a remote section - maybe you need to enhance RemoteConfig to support renaming
1) When would getCause return null? 2) Why drop the exeption message and use the cause' message?
You can highly improve the performance of this line by calling the Vm.isCreated() method. Check issue #188 for details. suggestion if(broker0.equals(vm.getBroker()) && vm.isCreated()) {
getVm() might return null at this point
Not sure why we check if vm can be null here, it should be verified in the canDoAction when executed, and if the VM has disks then the VM should not be deleted, so I don't think vm can be null
You can use Collections.singleton.
Can you change assertTrue by assertFalse ?
Use 2-arg doc.setPropertyValue instead of 3-arg doc.setProperty
lock user_point
Just thrown an Exception.
I wonder if there is a method to check if a point is within a rectangle.
Can you do a more precise check? Comparing the string with exactly what you expect? You should check a specific blob as well, not just the first one (not sure you'll have a deterministic order).
My bad, not needed :)
Could you convert this to two assertTrue ?
What about to use 2 methods authorizedInternal in 1 if clause with different objects? Like:  if(!AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(user)) && !AuthzResolver.authorizedInternal(sess, "addSpecificUserOwner_User_User_policy", Collections.singletonList(specificUser))) { .. }
Same question like above.
This is an unintended grant of permissions to all users. If the owner doesn't exist, this should instead call throwIfNonAdmin
This should return a command exception.
List<Filter> idsToDelete = ids .stream() .map(filterBuilder.attribute("id").is().equalTo().text(id)) .collect(Collectors.toList());
May I suggest inverting the predicate and returning the empty list here early, while getting rid of the larger indented code block?
It would be better if we would show the user some message as toast as well!
This is missing a line return true;. Otherwise, it will fall through and execute the next case, too.
Not being able to set the timer due to an unknown exception is a critical error, so it is ok for it to crash the app and open the bug report screen. So this whole piece should be converted into: updateTimer(this);
This should be replaced by something like, as you can see for content assist for instance quickAssistProcessors.addAll(GenericEditorPlugin.getDefault().getContentAssistProcessorRegistry().getQuickAssistProcessors(...))
This has to be cleaned up.
Why no assertions on the channels?
Instead of hardcoding path, can you check if Files.createTempDirectory() works?
Does this need to be addConfig as well? Users might be setting a default system descriptor in their application themselves.
I don't understand this method signature. Why should generateJobConfig take executionPlanJson? Also, why is it being added to the config?
Other places in MISO use owner to refer to a user, but it's used here to refer to the associated QC-able thing. What do you think about changing the field name on the DTO from owner to entity to match the QC model?
ipAddress not set
BoxableDto doesn't have a position attribute; is this perhaps doubling up on the setBoxPosition() call below?
final
This should be more efficient as rows.toArray(new Object[rows.size()][] so that the list doesn't have to allocate a new array to populate
It is not necessary to test REPLICATE region in this test.
typo: you have two "f"s To avoid such typos, please copy from the config directly. These are quite hard to catch and we are not always looking for them.
Unused?
This should be a Duration not a Long
We should add local vars for position.getX/Y() and entityPosition.getX/Y() to make this a bit easier to read
non-actionable: ... and this is where I complain about not having Java 9 Optional#or which does exactly what you need
suggestion final World world = ((org.spongepowered.api.entity.Entity) entityIn).getWorld();
ImmutableMap.of()
This is wrong, we should not have static fields (it's a problem for Fragment lifecycle). Please remove static ...and see what is done on TripPlanDetailsFragment ..that's the right way. Three non-static fields and should read all them inside onCreate methods ...like that: if (getArguments() != null) { mTripPLanObjectId = getArguments().getString(ARG_TRIP_PLAN_OBJECT_ID); }
These are not equivalent.
Remove this?
We expect this test to return null, so just assert that the URI is actually null and forget about the rest..
Remove this or use the anonymous logger
make all local vars final if possible
Simpler: ArrayList<T> result = new ArrayList<>(collection);
It seems you have to choose between @sputnikci and @codecov-io complaining :p Could we open a @codecov-io issue instead of making the code uglier?
Can you explain what problem this is solving? The jira does not tel much about leases.
I wonder if we should not create a new lock object with a different name for this. The batched name let us believe that it will be a batch operation (fast) while it is a sequential operation (slow) the difference of performance can be quite important and I think it would be marked more clearly by having one called batched and the other called something else.
Looking into this again, why can't we use leaseManager.getLease(shardInfo.getShardId()) here?
printing contextId in the message will be helpful for debugging.
should this be LOGGER.error(message, e) - so we log the actual exception too?
else-if?
This can be replaced by StringUtil:isNotBlank
reuse method I proposed to introduce above
Can this be private, or is there another use case for default attribute outside the builder's call?
Let's swap to use Guava Hashing instead of DigestUtils.
Line 626:628, collection type can be auto inferred.
*style*. same line
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
maybe? return session != null && Boolean.valueOf(session.getAttribute(".."));
To avoid potential clashes with other session attributes, I suggest to use some naming convention for attribute name, for example: ui_{key} Otherwise, we would allow UI to override arbitrary session attribute, even ones that are potentially used by other systems/components (not meant to be accessed by UI).
Extra new line.
Can you extract this to a constant?
There should be a check of scheme here i.e. 'org.edx.mobile.innerlinks' before getting the relevant data.
Nit: Just printing the additional paths should suffice, just so the information does not get drowned.
Does this support array types ? You can't pass a name with pairs of brackets to this method, or even the binary name of an array. Using [ClassUtils.getClass(classLoader, clazzName)](<LINK_0> would probably be more robust
Multimap returns an empty collection if the key is not found, which will simplify this code by removing the != null test.
Can we just do ByteBuffer.wrap(b, off, len) and save one more copy?
Do you need to handle the case that delimiter is part of the data (i.e. do you need to add escaping logic in case delimiter needs to be escaped?
Perhaps this should be a constant field instead of a magic number?
Can't we do that in the EnvironementInitializationFilter to avoid adding this top all the sites?
ThisSTACK_ID code looks overweight. Maybe we can remove it at all? @sleshchenko @mshaposhnik @metlos wdyt?
If it is clearer then method name clear looks more natural for me than remove
The interceptors must not try to access the TM transaction via the thread-local, only via the invocation context. So it's safe to suspend the TM transaction before calling invokeAsync.
Same here, it's better to suspend the transaction before invoking the interceptors.
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
From the code of extractValue(), it could also be Memory.
Could use ISE
Add instanceof check
Fully-qualified class name not needed.
SA == SERVICE_ACCOUNT? avoid abbreviations
google style is to not use final on local variables unless it's required
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
not that critical , but why not for (Entry<String,object> entry: tasksMa.entrySet() ) instead of using iterator?
missing final
final
![MINOR](<LINK_2> 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](<LINK_1>](<LINK_0>
I don't get how what is replaced maps to a checkAndMutate instance? There is no matching in previous impl?
would it be better to put checkMutationType() and checkRow() in doCheckAndRowMutate() method?
Oo now that this takes a stream, can we just remove the collect above?
Hmmm this test depends on the ResponseStatusFromPayloadHttpCommandExecutorService fixing the response code. Even if the _real_ provider returns a 500, I'd just configure a 404 response to make sure the API works, without coupling it to that class. The ResponseStatusFromPayloadHttpCommandExecutorService tests should take care the status is properly fixed and that should be enough.
[minor] This is redundant. Test will already fail if the method throws an exception.
bad name
Lets use VectorUtils.of(...).
In both this and the test above all changed values are expected to become 1, due to the highest diff being 100. Maybe we should test with some other value as well.
Should we be ignoring the template tests?
Start with a Capital letter. This is missing in all the other calls to receiveError too. We should look into a uniform way of handling Service exceptions. Because in the case where the app is closed, we cannot show toasts. Maybe store errors and show them on the next app startup ?
Since ContainerPlacementMessage.equals includes statusCode, this step is not needed.
Will the exception thrown also contain the message contents/headers that could not be extracted for logging?
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
FIXME: Don't cast getActivity(), use an interface.
More descriptive name
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
nit: You could do:  int finalLength = stream(positions, offset, offset+length).sum();
missing checkValidPosition(positionCount, position); below?
final missing
I think it's ok to return null here, looking at how the GerritTableView is handling the result.
lambda?
This will fail if the key is an empty string.
String#getChars probably faster than this loop
I would pack this entire branch in a differet method
extra line
I am not 100% convinced if this would be a trace info. We probably won't need this information to debug the internal work flow, but whenever this information is needed, there should be some error (or complaint from users). So from logging perspective, it more looks like an error.
you could get rid of the whole if block actually, as this check is taken care of within the BlobId constructor and you hare handling the exception from that anyway.
In all cases of this pattern, we're throwing away the NotFoundException. It would be better if we could pass it as the "cause" argument when we eventually construct the RestClientException object.
This variable isn't needed. You can still do return contentRepoService.getRepoObjectMetadata(manuscriptVersion); inside the try-block.
This looks wrong, it needs to be a core version, not a plugin version, right? I think it should be replaced with new VersionNumber(p.requiredCore).
Small point that I think this should be >=. There could be a situation where the old resource and new resource have the same version and the old resource is on the way out. In that case the signal that this current resource is installed (because it is being initialized, which only happens to installed resources) should imply that this resource is valid, so with no other information about the installed resource we should presume that it may not be.
This seems like a bit of an odd time to fail on this to me. Can't we validate that this path isn't empty when it is being set, rather than when it is being used?
I got confused by this, can we move the second and clause of this if into a single line?
We don't need this, the ConfigSaved would handle this already.
I think removal of the observers should be done by the client - as they may add the property back, expecting the observers to still be registered. i.e. if the client adds the observer, it should also be responsible for removing it.
I don't think the semicolon there looks nice =P Maybe something shorter like just (In Use)?
Check methods do not return boolean. As we are using them, they always end with or without error without any returned output.
Shouldn't it be "in resource" instead of "of resource"?
same... no need to check is existing
Another lambda-ing opportunity:  source_.withSaveFilesBeforeCommand(() -> { server_.startBuild(type, subType, new SimpleRequestCallback<Boolean>() { @Override public void onResponseReceived(Boolean response) { } @Override public void onError(ServerError error) { super.onError(error); workbenchContext_.setBuildInProgress(false); } }); }, () -> {}, "Build");
As discussed before you can use WorkbenchContext for this
Should we enableStartedCommands() even if we didn't start profiling?
it should use integer parameter instead of true i think
We could avoid the containsKey() + get() cascade by just checking the result of the latter on being null.
Bit strange to do this every time a font cache is created?
suggestion
This will send an individual message for every stack in a bulk sell. I don't think this is desirable behaviour?
I suggest to you to use metadata to check the item is checked correctly that not similar to other items that have "Fireball Arrow" name.
OOC, in what ways does findSpecial differ from unreflectSpecial? are the two functionally equivalent (ignoring the JDK bugs), except one stards with reflect data (Method) and the other with a signature (MethodType)? if so, is it worthwhile simplifying this to _just_ use findSpecial? also: does this change have any impact on the calculus of who has access? if the types (args or return) are private, package-private or protected, will unreflectSpecial|findSpecial fail whereas the reflected approach would have succeeded, because we explicitly set the modes to all access levels?
Can be static
I would say we don't need to cache this result, just return false and try in the try catch
I think we should consider the case sensitivity here.
This can still return HistoryReferencesTable.
can this be narrowed to some kudu related exception?
cannot convert to double value, same reason
We cannot convert to Double for the same reasons motivated below.
cannot convert to double value, same reason
Please use "something <operator> null" convention
remove file==base as the entire tree should be effected.
This should be logger.fine or removed.
Could lines 154 - 170 be checked once outside the loop? It doesnt seem like they would change based on the sync path?
Strange that two URIs are unequal even if they both have no port, but one happens to have been created from a string that had a "naked" colon.
Only this check might be enough?
static import
Please format the code according to our standard. You can load the eclipse format file into your IDE.
Might be better to just call node.toString() here instead of passing in null. Otherwise, the getJsonAsString() and toString() methods will allocate a big string on each call.
Is this placeholder correct, looks like if my search includes a ' I can SQL inject here?
This should use a specific Locale.
not seeing the Locale.ENGLISH setup, also exceptions are not handled. is this intentional?
Does k need to be a new hashmap here? Looks like it is initialized on line 343 already.
This can be replaced with java Arrays.stream(keyValue[1].split(",")).map(String::trim).collect(Collectors.toList()));  because you can use stream directly instead of after asList.
This Exception is never thrown. It may be that while developing, you had a change here that required the throws clause, but it isn't need in the proposed patch. I would have expected that would have reviewed your own change before proposing it here, and that you have removed this change.
Inconsistent format! space after comma
This could be null, we should probably handle this if the JIRA api changes again
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Shall we use expected exception here, instead of asserting the exception?
please use  log.warn("Unable to set user-data to [ {} ]", EVENT_DATA, e);  instead string concatenation (much more readable).
suggestion return getImage().get();
Should at least have a DEBUG statement in this catch.
Any benefit we can get by changing this?
logger.debug can be more appropriate.
move this to the previous line
extractGeometry converts code into GeometryTypeName and checks if it is GEOMETRY_COLLECTION on each loop iteration unnecessarily; let's check this once  if (input.readByte() != GEOMETRY_COLLECTION.ordinal()) { ByteBuffer buffer = input.slice().toByteBuffer().slice().order(LITTLE_ENDIAN); Geometry esriGeometry = local().execute(0, Unknown, buffer); return createFromEsriGeometry(esriGeometry, null); } else { <the original while loop> }
You can use an utility method introduced in #10626
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Extract this to some utility class, as it's effectively duplicated from ConjureTimelockResource, and also exists in ALP
Let's include the group name and say it's getting the ids that failed.
Best to avoid logging any passwords, some end users will actually audit log files to ensure no passwords are logged.
Can we declare global final variable for "JKS" and refer in code?
Do not use e.printStackTrace(). Log the exception. > this.logger.severe( e.getMessage()); > this.logger.finest( Utils.writeException( e ));
With the overloaded constructor, this change is no longer necessary
SimpleDateFormat might help make this a lot simpler. <LINK_0>
Making only this message a constant only makes it less readable, and is essentially meaningless. It's a good idea to undo the fix or standardize the argument checking.
System.clearProperty can be used instead.
This sets the system property to the empty strings but does not remove it. To make extra sure to leave nothing behind, best to use [clearProperty](<LINK_0> instead.
One more unnecessary "save and restore" of system property value. Please remove it to be consistent in the entire test suite and use clearProperty below.
Could we go with the name finalRequestConditions or something? conditionsReal sounds a little odd
A message might be helpful
Replace with Objects.requireNotNull
Don't we want to check if it's a 401 first?
Call requires API level 11 (we are on 10)
Simpler: ArrayList<T> result = new ArrayList<>(collection);
These 2 if conditons can be merged
I don't like to define code as a String. This looks quite ugly and hard to maintain. Is there another way to set this?
better collect all XML-Snippets as constants with substitution marks and use String.format() in order to replace these marks. This will increase code readability (also change for all subsequent XML Snippets)
I'd like to see what the format of the output is for JFlat. We may have specific requirements around how the JSON is flattened - so would also be good to see the customization options.
Consider using StringJoiner and/or Stream API.
This seems to be an unrelated "fix". Can you please move this to a separate PR outlining the rationale for the change?
Great catch! Instead of maintaining another Set could you just check processToContainer.values().containsKey(container.getId())? That guarantees that we're always in sync with what startExecutor has started, since it updates processToContainer.
![MAJOR](<LINK_0> 'Severity: MAJOR') Assign this magic number 100 to a well-named constant, and use the constant instead. [![rule](<LINK_1>](<LINK_2>
not needed, can't happen (don't trust your IDE on this one ;))
use compare - that is every version implementation implemented.
Space after comma.
use Code. ReadException for -1.
Replace SizeOf.sizeOf. You statically imported it.
Write  if (value == null) { continue; }  instead
Ideally the decodedBlock filed should be of the type Block. I'm not sure there's a real reason we want to use ColumnarArray/Map/Row. For example the only non trivial operation the toColumarArray does is just taking a region of the unrelaying block: <LINK_0> This can be done inline.
Theoretically it would save a memory allocation and garbage collection to just return value;. Maybe Hotspot will optimise this in practice. Same in the other file.
Please remove the formatting changes in a separate patch. Understanding real code change is very difficult otherwise.
unnecessary array new: {{true}, {false}} should work here
Does only the dot trigger the special handling? Or any non-digit character?
Useless blank line.
initialize() or schedule()
why not use the logger for this?
I don't think we need to retrieve a liveChatId here (lines 69-78). (The liveChatId is not used elsewhere in this method.)
The space before the period was intentional, so that people can click on the URL without their tools interpreting the "." as part of the URL.
lots of loc here :) this method was only present for toString ordering
The 'Network' should be omitted from this context since this is not a specific provider.
Although this is not a part of your pull request, this toString() method looks overly complicated.
You have two placeholders in the stream but only one argument, is this intentional?
no need to catch exceptions. just let them propagate.
ObjectMapper is thread safe, it could be member of a class and have only one static instance
This does not verify the order. (The iteration order over expectedMap is undefined).
Should add more assertions for boundary values.
Note that all message parameters to the assertion functions are really just error messages displayed on test failure. Thus I do not think "Returns an empty map" is descriptive enough to assist with troubleshooting. Perhaps something like:  format("Expected the returned map to be empty, but got %s", entries.toString())  Also with assertThat and Hamcrest matchers, this assertion no longer needs a call to Collections.emptyMap() because the test conditions can be better communicated.  assertThat(entries, is(empty()));  Much more concise! And readable!
BasicMessages have no type property, so just use empty string for logging the message type (the second parameter in this method call)
Please update this string to say "developer mode" instead of "debug build".
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
rename to simpler variable name (columns).
extract a local valuable
Recent scatter chart updates checks the "new" way first, and then falls back to the legacy implementation. Should we do that order here too?
Ravi, if you just initialize this with false before the creation of the tasks then your fix will be perfect.
this is being called on a different flow now. is this intentional?
check if u can use 'getTaskIdList'
Would not use the work "type" here
in this place you can inject your generator as Treewalker filter to config.
should be executeIgnoredModules
this else seems redundant
Having a builder instead of a public constructor is usually better
same as before, why not simply if (input instanceof EditPart && ((EditPart) input).getModel() instanceof Resource)
rename to delta
I think all this can actually be removed, including the then unused import of org.eclipse.core.resources.IResource. Additions and deletions are always interesting, and GitResourceDeltaVisitor.isInteresting(delta) does return true for them.
This would be set on the event. A PRE_DELETE event doesn't have a delta, so you'll never get here. Just remove this.
We should set connection and socket timeouts here. By default there are no timeouts, so in case of network problems this may hang forever, which is pretty long. ;-)
not sure why content length is considering header.
Shall we log the whole exception (so that stack trace will be printed)?
Do we not want to log the exception that was caught here?
I don't think this closes the client if there is an exception. (Can try a try with resources)
Don't ignore exceptions
I noticed that you use this on many places, shouldn't this be NPE instead of IAE?
add some message info
Please add logger.isTraceEnabled() to prevent invocation of getters when log level is too low.
Use already defined Constants
Wrap the exception
'e' is not logged
there is a potential race here: free the mac on line 102 than it can be used by other Vnic and than you do updateHost() which is a long operation during that period the freed mac address is taken from the pool i think that releasing the mac addresses better be done at the end
it can be inlined as done in other places: new ExternalNetworkManager(oldIface).deallocateIfExternal();
this method isn't needed, it can be replaced by a call to: getVmDeviceDao().clearDeviceAddress(getInterface().getId());
I just had a look at the callers of this method. I suggest to just return a java.util.List here, as the callers do not need the concrete ArrayList implementation.
This may be replaced by: java return new ArrayList<>(this.vanishedPlayers);  I'd also like to question the validity of returning a modifiable collection. While changes to this collection might not cause changes, returning a modifiable collection in getVanishedPlayersSet() *would*, which may confuse some people. I recommend perhaps using Collections#unmodifiableXYZ(...) to wrap the result instead.
You could use the list collector directly.
why not use a ConcurrentHashMap instead of making all these functions synchronized ?
should this check that the queue is not 0? Why acquire a connection if there are no waiting exchanges?
We can just return connectionDetails here.
if (repository == null || repository.isBare()) { is more concise and gets rid of the {}-less block below.
This is a pretty drastic change in the logic here and I'm not sure this is what we want to do. So before your change, this would first check if locationGP has text and if it does, try to load that location. Then if locationGP didn't have text or the the location specified by locationGP couldn't be found, it would try to get the default location by calling the private getDefaultLocation() function. If none of those methods returned a location, it would try to get Location 1 (whatever that is) and return it. With this change, this will check if locationGP has text and if it does, it attempts to return that location. If locationGP does not have text (the check on location == null is actually redundant because at this point, we know location is always null), it will call the private getDefaultLocation() function. The function will then return the result of either getLocation(locationGP) (if locationGP has text) or the result of getDefaultLocation(null, locationGP) (if locationGP does not have text. In other words, I could simplify the logic in your change to something like this: java return StringUtils.hasText(locationGP) ? Context.getLocationService().getLocation(locationGP) : getDefaultLocation(null, "");  I don't think there's much to gain from trying to simplify this method much more than it already is... At a certain point, methods get too "simple" and the logic becomes hard to follow.
Before returning, we should stop monitoring the buffer with locationMap.remove(location);
Please replace all tabs with spaces and indent consistently.
This can be replaced by !Strings.isNullOrEmpty() in furnace-api
You mean startsWith()? Also confusing if positioning, looks like an else if.
Restore visibility of methods in this class to package level when unit tests are moved to jaggr-core
Explain.
I would use getTreeItem you have defined below to access treeItem, since you implemented it. Instead of direct access.
I would probably split this up and check the token type prior to getting and checking for credentials. It's a personal preference, though.
include retry template, and do  return retryTemplate.execute(x -> remoteTokenServices.loadAuthentication(accessToken));
Is it possible to throw a more specific exception?
You need to pass the auth option along when doing the resolving, also consider the options in the call
I think the whole method can be simplified by  public Result getRpcResult() { try { if (resultFuture.isDone()) { return resultFuture.get(); } } catch (Exception e) { // This should never happen; logger.error("Got exception when trying to fetch the underlying result of AsyncRpcResult.", e); } return new RpcResult(); }  what do you say?
I think lowercase l should also be considered
I would go the other way around but that's my preference
You are getting the JSONArray two times in each iteration. You can extract it as a variable.
This can be a bit cleaner with Java8 streams: return getPluginProviderRegistry().entrySet().stream().collect( Collectors.toMap( Entry::getKey, e -> e.getValue().createLocalFileIngestPlugin(e.getValue().createOptionsInstances())));
Can you please also make this block contribute the the dynamicRegistration map?
Cyclic dependency bewteen serverCommand, serverScheduler and scheduledFuture slightly bothers me. Not a big deal, but it feels like we could fine a cleaner way to organize all this.
Maybe inline this local variable?
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
We have too many nested try/catch/finally blocks here mixed with throws statements. Could we simplify this?
Instead of doing and then undoing, would it make sense to add a "boolean quoted" parameter to the getSpatialIndexName method? A simple refactoring in the IDE should do the trick, with default to true, and then only this call point gets fixed. Also, what if by any stupid accident one manages to get a quote in the actual name? The above would get rid of it.
Why not just: java for (String msg : msgs.toArray(new String[0]))  ? No need to make a new ArrayList. Just the array.
Can you break this block of code into smaller sections by adding newlines in between - just to help with readability.
should we just use StandardCharsets.UTF_8 here to avoid having to deal with UnsupportedEncodingException?
same here for hasArray
Shouldn't the return type be int?
Something that I noticed. If there are no connected device this will continually show the "No Connected Devices" Toast. Another reason for having a button for starting notifications.
check for isDestroyed().
Same question. Maybe you can check my implementation in #632 to see if it works for you.
Should we show the dialog of merging articles and lists?
The cursor iteration block can use a try-catch-log-finally, so we can see errors if read fails.
Does this really throw a IOException given the try...catch below?
Need to ensure ordering, per our conversation re. hashcodes :)
try isnt necessary here
- [x] throw is missing. --- It was modified. bd4f804b9c372d711df571b2c3551406f2cef8c7
I think ; is a typo
if it isn't too much change, lets get rid of SecurityServiceCallback
I think we should continue to let AmbryBlobStorageService set these.
this is a BadRestRequest() which is bound to fail. This test should be similar to the one in AdminBlobStorageService in the sense that it should create a valid request with the PUT method.
So that is getting a thread that is local so as to get the classloader?
Such worker threads should be daemonic. Daemonic thread will die when all non-daemonic threads are done. In this case when startProcess() is blocked to some reason the application may hang and you won't be able to exit JVM :( Such kind of worker threads as you are creating here should always be daemonic unless you are 100% sure it can be done and will not block e.g. on reading stream. java Thread t = new Thread(..) t.setDaemon(true); t.start();  <LINK_0>
Not a loop anymore. doWatchdog is enough
please use more concise methods like Arrays.asList
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
I'd prefer if you put the Headers here in a local and did isSameAs just like is being done with body.
The config location is not ~/.motech , but ~/.motech/config - in Tomcat ITs we have no config because of this
We seem to be marking partials as valid before checkin. In case checkin fails for whatever reason, the caches wouldn't be updated but the partials would be marked as valid.
what is additional_neo4j.conf and why do we need it? how its correlate with other tools behavior?
I think we should assert two more things: 1. The value of getMillis() and getDecimalMillis() is the same. 2. This is the *correct* value (i.e. it's the same as cal1.getTimeInMillis()).
This should be fine on the previous line.
This will crash if the dateTime has no time zone (I didn't have Optional back then) like it's the case for all-day tasks.
use Map interface instead
Consider a streaming implementation: final Optional<List<Rule>> match = rules.entrySet().stream() .filter(e -> e.getKey().includes(length)) .map(Map.Entry::getValue) .findFirst(); return match.isPresent() ? match.get() : null; Not much clearer, but any time I can avoid declaring Map.Entry<A, B> that's reason enough.
may be only rule name here would be more clear ? i.e. \w+ only? possibly case insensitive too.
this should be private also
final
suggestion
Minor: suggest moving port == that.port && xid == that.xid to the position close to Objects.equals(sslPort, that.sslPort). We can compare instanceName first. The port and xid are usually same.
is it not empty if for example type is an valid empty string?
Technically I think you should use the get methods on info to access its variables.
This actually brings up an interesting question. If user wants to store the point with column lat, lng as double, is it possible to create an index for them?
just for my understanding - in a multi-segment scenario, what would this do? Set the end offset of every segment based on the end offset in its index?
This code is almost a duplicate of getIncrementedSegment(), could be extracted to a method.
It is minor, but to me this new name is not very accurate. I would call it assurePathExists.
The same as with previous - make it final, don't check for null (reduce amount of lines)
Is just checking zookeeper enough? In the extension, I check both zk and kafka ports are listening... <LINK_0> Plus it's fast and doesn't produce log garbage when they are down.
Replace with Util.threadLocalRandomUUID()
The loop iterates over the mutable array, which is guarded by "this" lock, but the loop itself is not guarded by "this". If we are going to fix MT issue here, we will also need to guard against the inconsistent data we might see in the array, which is changed in two synchronized sort* methods. At the end we might see less entries in the entryMap because we might see same elements multiple times while sorting of the array. So probably the easiest way to fix the original issue is to make the getMarkerItem() synchronized.
Not your code, but should probably be renamed "hasExtraLocations"
add <> to "new ArrayList()" to avoid warnings
I would put the "magic number" into a static var.
Typo on attribute
can you add some docs around this method.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
Please move this logic here: <LINK_0>
@since 1.0.RC5
We should guard this with if (mEndTime != null) and in the block, return false if it fails.
userMembershipModel != null
log.error("xxxx {}", e.getMessage()) ?
Remove entire wrapper finally block
Remove entire wrapper finally block
Hmm. Took me a little while to figure out that isExtension everywhere really means is a static extension. is_Static_Extension would be a better name. Not a big deal, though.
Are you sure you don't want to be using [HaxeReferenceImpl.]resolveHaxeClass() instead? (for lines 33~37)
You don't need to check for EMPTY. It does nothing useful in this situation. EMPTY.getHaxeClass() is a valid call that returns null.
better Exception
TogglzEndpoint.java:[58,63] lambda expressions are not supported in -source 1.7 <LINK_0>
question: would we want if symbol == something and offset == null to have it return fSymbol+??? instead of null?
Again, these should not pass validateInputs()
this logic should be in RegisterVds I think and depend if the default cluster is not valid or not mentioned in the vdc_option table
s/new Guid/Guid.NewGuid/
Given that we are not loading just genes but also transcripts, and IIRC the stored object is called FeatureCoordinates, I suggest renaming this class to LoadFeatureCoordinatesStepParameteresValidator. Related classes such as the step itself may also need to be renamed accordingly.
Let's simplify this by merging the 2 methods?
Seeing them in context, this validator class and the associated step should be renamed to FileLoaderStepXXX for consistency.
the steps 35, 36 and 38 are not neccesary
The steps 36, 37, 38 are not necessary, please check this.... you should omit this steps
Assert structure is Assert.assertEqual("actual","expected") please check this in of all your test cases
suggestion return spanBuilder.start();  immediately return
Is it worth moving the reporting out of the synchronized block (though I wouldn't expect convention on that span)?
this is not an obvious way to distinguish 'process' span from others. If there a more explicit way that does not rely on presence of context or span name?
which exception are you avoiding?
Why do you need to pass the executionContext? runInternalMultipleActions(ActionType.SyncAllHostNetworks, params) should be enough for your use case.
you could think about changing the createStitchAction(sprite) to a static method in the ActionFactory, there is no internal state anyway so you don't really need an instance of the ActionFactory here.
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
rather than format to a string wouldn't it be better to test for something like this: number >= 1.273f && number < 1.274f
NullTimeEvent should not need any properties...
You only produce String values here so the map can be using String.
Can this be written more simply using a predicate to filter items where input.trim().isEmpty()?
You can skip the part with instanceof String.
instead of calling String.trim() multiple times here use map(), e.g.  Files.lines(p).map(String::trim).forEach(...)  You could also filter there too, e.g. .map(...).filter(s -> !s.isEmpty()).forEach()
RuntimeIOException maybe?
This does not smell right. Have you even tested this when using remote agents?
what about !selection.isEmpty() instead of selection.size() >= 1?
ArrayList should be constructed with fixed capacity.
ArrayList should be constructed with fixed capacity.
nit: do you need AuthMethodPickerActivity.this or could it be just this?
Hmm this seems a little strange to me. We call a getListener method and then observe a listener? I think what we want is something like an Observable<PasswordResetState> and the state can include properties like boolean success and String errorMessage. Also avoids passing down the Task and lets us encapsulate the error instanceof logic higher up.
Maybe I'm not fully understanding the idea behind these pending data, but wouldn't it make more sense to keep those around in the ViewModel? That seems to be what you're trying to do...
Same as above here: use .isEmpty() rather than .equals for the empty checks.
Avoid breaking up a string like this for wrapping if possible, as it makes searching for error messages harder. If the string will fit (and I think it will, ignore me if I'm wrong), use this style instead:  throw new IllegalArgumentException( "collection contains null or incomplete branding objects");
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
why use ellipsis?
The name of the MetacardType could also be null in this case.
I would change this like to return Utils.copyAttributeToVirtual.......
The givenBattleState is still odd, it probably should at least return a builder(). You can make list values non-file and use @Builder.Default to initialize them to empty lists. Also consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:  MockBattleState.builder() .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class))) .defendingUnit(givenUnit()) .defendingUnit(givenUnitIsAir()) .build();
should the SortExpressionExtractor be renamed as well?
Why is this the case? A more specific description could be the key, what is special about the new unit exactly that makes this assertion the case?
Recheck the condition, it should be 0 <= pageIndex && pageIndex < getChildren().size()
isEmpty()
Since we're invalidating the entire dataset in the adapter (a few lines below), which will cause all the views to be redrawn, do we really need to do this here?
Can you make these variables final and they can be used for both methods?
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can it final object when the class get loaded?
Can these be declared at class level and used for both methods?
A warn as well. I am not even sure we need the stacktrace here
suggestion } catch (InvalidFolderNameException e) { .... } catch (Exception e) { ... }
Use File constructor with separate parameters.
This method can be private
cat > \"" + filepath + "\" ... would be preferable to handle paths with spaces.
Can we point users to some kind of regex about how to specify these options, or what the valid values are? I don't entirely understand the format based on the docs and usage string here.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Maybe we should use a specific ID/token (e.g. "HTTP", "WebSocket") instead of the class name?
Could use the ternary operator like in the setters (it would avoid the duplication of the name).
suggestion 749, // CWE-749: Exposed Dangerous Method or Function  Or maybe: CWE-676: Use of Potentially Dangerous Function ?
Who does throw this exception?
It should be splits.
MemStore is used for tests, so we need to implement this function.
Perhaps call getProxyHost and getProxyPort once only - else you risk the logged message masking a different version that is actually used. Potential future bug should someone change what getProxyPort and getProxyHost implementations.
No need to use FtpURLConnection here?
Use URLConnection here too.
NPE for: <LINK_0>
make public static
Don't initialize to null. Let the compiler require us to ensure the values are initialized in every branch below.
Why test canUpdate here? It's not necesasrily linked, is it?
If you want to make some more improvements in here we could fix these log levels. maybe debug?
is this supposed to be result.toArray(...) ?
Don't you think that set in a static field will be simpler?
Maybe "Default instance resource, CPU: %f, RAM: %s, DSIK: %s"
Please make sure that java doc of this constant[1] is up to date and all usages are correct, I suppose here should be pluginPublisherName/pluginName instead of pluginPublisherName [1] <LINK_0>
Maybe add @Nullable to taskExecutorManager.
optional: I find it more readable to break the line at the || so that the visual grouping is the same as the semantic grouping.
suggestion .thenCompose((ignore) -> registerTaskExecutor(tmResourceId, taskExecutorGateway))
I'd use the Consts you defined in HibernateConsts for these values.
Would Rule(*) cover this?
1) These 2 methods should be one setScore(Score) method and the wrapper should split it up to ScoreClass and ScoreString. 2) Why is ScoreWrapper mutable? Score's are immutable ror multi-threaded reasons. I think ScoreWrapper can be made immutable too, by simply creating a new instance here and add a constructor new ScoreWrapper(score).
forgive my ignorance, but how does this solve the issue? Isn't there still the org.hibernate.Query vs org.hibernate.query.Query issue in the source code?
Should be human readable message
Same here: Avoid calling a function of httpsession if it may be null (Reason: catching exceptions is more expensive, and NullPointerExceptions may occur at many places).
log me?
synchronized
synchronized
Doesn't look like the false param should be here anymore (onMediaUploadProgress wasn't changed) - also in two more places in this class.
I think that is not enough. The attachment could be binary, but no image (e.g. a ZIP file).
is this 10000000000l or 100000000001? Use upper case 'L' a lower case 'L' should not be used for Longs or variable names.
Yeah, I think it makes sense. IIRC, netty swallows the throwable silently, so it's difficult to figure out what's wrong.
Is it better to pass e.getCause() to handleError? This brings the real cause on top.
same as others: log should have Exception as arg
This would be false if newlyDisallowed && prevDisallowed && !tetheringActive What does "status" actually represent in this parameter ? If it represents whether tethering is disallowed, maybe just newlyDisallowed would be appropriate ?
Wouldn't it be a serious bug if m_activeSegment != null && m_segments.isEmpty()?
I prefer the ?: syntax, also I think isLight is a leftover from the merge, because it is not needed suggestion mSwitch.setIcon(mLinear ? R.drawable.ic_apps_white_24dp : R.drawable.ic_list_white_24dp);
Why do we need this Map mutable?
booleanValue() is unnecessary?
Should it be closed via #close() ?
This won't do. Schema is in request body, not part of uri. Parse string to json, and set the request body. Also, overload the schema constructor to get a JsonNode schema, because body is json in AbstractListhblueMEtadataRequest
why not use new URI(scheme, host, path, query, null) to make it more clear?
is this even necessary given that we use new URI(...) ?
Once we cache new DDF, do we need to uncache old DDF to claim some memory?
Same here: should be Branding, not ProductBranding
Try using StringUtils.isTruthy(this.path)? <LINK_0>
This ID is not the chargeId suggestion logger.info("Offered payment state transition to emitter queue [from={}] [to={}] [chargeEventId={}] [chargeId={}]", fromChargeState, targetChargeState, chargeEventEntity.getId(), charge.getExternalId());
could we make the getStructuredKeys method you've added on ChargeEntity public and use it here to get the basic keys?
Even though it will end up with Connector going to the database twice I think we should use the emitter process here instead of manually emitting -- it takes care of handling multiple events created for a given transition (refund availability etc.) and will keep up with changes to the PaSTEE code.
You seem to be reusing this code in the other method overload as well. How about moving this logic elsewhere into a separate method to minimize duplicate code?
You only want to use closeQuietly() on an OutputStream when an exception already occurred. Otherwise you mask exceptions that happen during a close(). Those should be treated the same as exceptions during write() calls.
please use try-with-resources, you could also use apache commons for the copy suggestion try (InputStream in = input == null ? new ByteArrayInputStream(new byte[0]) : input; OutputStream out = virtualFile.getOutputStream(this); ) { IOUtils.copy(in, out); }
unnestChannelInputBlock -> newInputBlock
after the loop, we should check that the iterator is done?
This results in calculateEstimatedSize being called twice.
See earlier question.
you don't need this anymore.
Indentation is supposed to be spaces-only.
We should write a real test cases for dropping connections.
If it is possible, let's try to restructure this a bit so that it is a little more intuitive.
we just log, update metric and move ahead with next iteration?
If the error happen that early, can you map the error in early phase before mapping page result?
Should it be fine to log PII information here?
nit: can replace lambda
I am not sure if this solves the problem I was raising. Eclipse only creates a single instance of BndContainerInitializer. Not one per projects. So the constructor is only called once and the model listener is only added once. This change calls addModelListener multiple times. But since the method wont add if already added, it is not harmful. However, I think the cleaner solution is to make an onWorkspaceInit call in the constructor to add the model listener rather than piggy backing on the initialize call which is called many times.
Consider allocating a local SubMonitor here.
so you're returning something on the very first iteration. Not sure of the consequences of that.
suggestion boolean notInGraphAtAll = candidatesForDeletion.isEmpty();
suggestion if (reader.relationshipDirection() == Direction.INCOMING) {
should we use an equals here?
This should call all  java return all(params, (RequestOptions) null);
you still didn't apply my hint to all the other methods that use this try / catch
> public abstract class ExecutionStrategy { this super(); call doesn't need to be here
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
What will happen if the user calls this method to get an attribute other than RG?
This seems defensive also, and it's also just a sample in a test. If the underlying method the handler invocation returns isn't expected to return null, then we shouldn't check for null and we should let the NPE happen.
Could we add a check on the node being replaced having a null parent?
Can we reuse this logic from MethodArgumentsProvider somehow?
OOC, in what ways does findSpecial differ from unreflectSpecial? are the two functionally equivalent (ignoring the JDK bugs), except one stards with reflect data (Method) and the other with a signature (MethodType)? if so, is it worthwhile simplifying this to _just_ use findSpecial? also: does this change have any impact on the calculus of who has access? if the types (args or return) are private, package-private or protected, will unreflectSpecial|findSpecial fail whereas the reflected approach would have succeeded, because we explicitly set the modes to all access levels?
Would it be worth adding a break; after this line, or is it possible to have more than one note with a matching id?
replace the if with checkIndex(toIndex)
Probably related to this change: You can now configure Menu Bar like this: 1) set fixed number of levels (so that some groups don't have submenus displayed) 2) set target div -> The menu has items corresponding to groups, but clicking them does nothing. It doesn't make sense to show Groups in menu bar, when there is "nowhere to go" from the group.
I think we should find a way to do that differently, without needing AmbiguousSymbolImpl to store symbolsByDeclarationTree.
To allow further reuse I would split this into a method getting a name from TypeSymbol.
Maybe this package symbol can be factorized.
Move this if block after all if blocks.
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
these arrays could be static finals. That would save allocating new ones all the time.
Swapping the order of parameters would be more consistant with the standard method this replaces/wraps, ResourceSet.getResource(URI).
You can use "resourceExists" method which works in the same way as checkResourceExists, but it returns boolean instead of raising an exception.
I think this is dangerous, because it makes a resources that's not loaded yet accessible by other threads, that will try and use it with the assumption that it is fully loaded.
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
I think it would be nicer to call darker only once, although it is not really critical.
Superfluous empty line.
hmm, ugly workaround. If it is not / cannot be final, leave the field nullable and mark it null here. It would be more representative.
checkNotNull not needed
better to replace the original call to Files.deleteIfExists(f.toPath())
why not use IDE generated toString() ?
I think we don't need to change this.
I think this stops admins from installing at for example /code/review/ on their server.
I would change the text to say "The encryption algorithm is not strong enough."
If cfgMap will never be updated, I would suggest using a com.google.common.collect.ImmutableMap, rather than a LinkedHashMap. For example:  Map<String, String> cfgMap = ImmutableMap.of( "host", hostname, "started", startTime.toString());
What about using something less specific here like Map?
Is it possible to throw a more specific exception?
not related to this PR but is this really a "remote DC selector"?
hmm. Don't think this should just throw the exception but don't know a better way of handling this. since this should be a fatal error.
Why do we use iterators? I know the base class does, but why in the first place?
This immutableSet could be defined statically, instead of recreating a new Set every time this method is called.
!traceEvents.isEmtpy()
const for 5 .. use here and on line 445
Only need to create one Admin for this whole method, not two per data table. Docs say they're lightweight, but no need to churn.
Nit: Instead of passing-around entry to all these helper functions, they would be much more intuitive if you passed them (String tableName, ArrayList<String> indexNames) explicitly - one of both of them, as needed by these functions.
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
You should put default tenant here if it is single-tenant cluster, similar to addTable() You may extract this part into a helper method
Suggest leaving them as null if not set
Likewise don't need the if statement since the optional value will return empty.
Delete the if statement.
Providers will know to filter on SpellType.NONE, so just call the api method for the current spell and the ifPresent will know if the value is empty or not.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
I don't think sorting of this kind is the responsiblity of the service. I think it's either the UIs responsiblity, or at the very least, the controller.
better: return entry.getCiteKeyOptional().map(this::getCitationsByKey).orElse(Collections.empty())
also include in the error message the build you found
I'd just pass e, so the stack trace also gets logged.
this should only be done if METRIC_FILE !=null since it needs a more thorough parsing of the bam-file than downsampling...
To do the check you should not use permission but resolvedPermissions. So Arrays.asList(resolvedPermissions).contains(WRITE). And you should not check Write, which is a high-level permission containing many low-level ones. You should instead check for the presence in the list of the low-level permission like WriteProperties which are the ones actually checked by code in AbstractSession.
suggestion log.debug("Principal not found for: {}, author);
Add validation of s3a:// when using IAMRoles
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> base64StringToSerializable(entry.getValue())));
Typically we use Map on the left hand side rather than HashMap
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> ObjectToByteConverter.ObjectStream.convert(entry.getValue())));
It would be nicer to extract it to an init method (e.g. initEditors())
extract to an init method - e.g. initEditors()
Please use prefered declarative approach - attribute in *.ui.xml
One thing that I've just checked is that you can also use br and not just rb. Can you check that too?
This doesn't seem to be included in the assertEntry below.
nit: cast(... as BOOLEAN) (sometimes you use uppercase)
AbstractSnomedRefSetImporter.createComponent(String) already initializes the UUID property (probably also applies to core components, not just the reference set members). It could be removed from all classes implementing applyRow.
Is it possible/problematic here when the member is force set to the same effective time it currently has?
Do we have to accept import files where the source ID gets changed? Is the SCT change processor prepared to properly index these changes?
Iterate over all the terms in map.baseTerms
- this.ephemeralCount = new HashMap<>();
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
channel.close().sync();
If this fails, it doesn't mean that the SWTBotNatTable (that we are testing) is wrong, it means that the test setup is not correct for a particular graphical setup. If the font is really small, it could happen that the visible row count is equal to the preferred row count. So here I would just check that rowCount <= 32, and columnCount <=2. If we don't see 14 rows, I think it's better to let the other test (that reads row 14) fail.
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
do add a null check for options before invoking the getter for ifMatch.
FYI: using a map here would have given us: .map(voidDigitalTwinsResponse -> null) Even though Mono<Void> is the same as an empty Mono -> Mono that doesn't return anything, I feel Mono.empty() is a better representation of the transformation we are doing here. However, I want to point out that the end result from both would still be the same.
We should add a log statement here, before returning the error.
Anything we can assert here?
RandomUtils.nextString(20) instead ?
you can reuse the constant in HostModel..
4 spaces
4 spaces
Use same order as the field declarations.
Hey, So currently there shouldn't be an assumption that there are any "universal" strings in the localization engine like this, so wee should likely move these to something like loggerInterface.logXPathParseError, loggerInterface.logXPathException() or moving the errors to be non-localized.
directly return "" is better
suggestion conversionError = new IllegalStateException("'MqttMessageConverter' returned 'null'");
"Gerrit does not currently support generating diff output for this kind of change."
Actually I think 8k is too small here for est. size. It may force the ArrayList to grow slowly from 1 to 2 to 4 entries as the diff is built. Perhaps do: Math.min(32*1024, args.settings.maximumDiffSize) as the estimate?
Did you want to inform the user, like "An error occurred formatting the patch"?
no need to write "VmHandler::" in the log, the logger already write the class name (also for the other logging below)
after you changed that dao call the if condition is no longer neccessary the loop can be removed completely - replace it with use of Entities.businessEntitiesById
please add brackets after the 'and'
is this log at the right level ? also line 41
If all the changelogs are created via triggers, do we need a DAO method for creating them?
I assume this is left over from tests
log and throw
Is it helpful to log the error as a warning? if understand correctly we assume the error is going to be an auth error, maybe log helps to debug if it ever fails due to some other reason.
We have a [SimpleTokenCache](<LINK_0> that can be used here. It refreshes the token when it expires and also ensures that the refresh happens only once after each expiration period.
allowing flight is different from the player flying, I think you meant capabilities.isFlying instead.
Likewise here. Removing a PassengerData from an Entity should unmount the passenger.
While this method does read ok, it is wasting a lot of resources and generating unnecessary objects with each line.
you can simply use Predicates.notNull()
I don't know how segments == null is possible here, but if dataSourcesSnapshot is already non-null, probably this assignment should be skipped. The cause may be intermittent database unavailability or failure. This condition should be logged.
Please factor the DataSourcesSnapshot()'s argument out for better formatting
Doesn't account for this odd behavior: > If the first few arguments (up to four) are specified simply as values without identifying the arguments, they are assumed to be, in order, x, y, z, and r. Thus, the following two commands are identical: > /gamemode creative @a[x=10,y=20,z=30,r=4] > /gamemode creative @a[10,20,30,4] Edit: applies to entire function, making a working version
What about caching the list? AFAIK this method will be called multiple times on the same connection.
I'm wondering if it might be a useful optimisation to retain this as a short-circuit just before the main return statement?
Why would you pick a linked list here instead of an array list? Since you know the number of qualifiers upfront, you can even initialise the array to the exact size you need.
Is it possible to list all "acceptable" exceptions (e.g. NumberFormatException) in the try/catch? "catch Exception" would catch exceptions that show problems in our code (e.g. NullPointerException) that should stop the execution.
This helper function seems to only be used by fetchUsers and perhaps it could live as private instead of public until someone really needs it. Cheers!
but you didn;t ask it to leave a CID file...
Move the logic to the [ExecResponse constructor](<LINK_0> This way the approach would be ssh driver agnostic.
I think it is better letting this method throw the exception.
We could avoid cloning here? (The message is not modified by the view?)
- Can use the variable uri; - Should use getEscapedPath(); - toString() can be removed (it's already returning a String).
Certainly getCanonicalPath() provides clean path. but this method always returns absolute path. It may need to confirm the logic is no problem or not...
hopefully the close isn't necessary?
typo, and nit-picking: it's fine to just declare rowIdx to be an int
If we allow this, then imports with un-even lengths will be an issue, right? One example is java.util.Map and java.util.Map.Entry. The 2 are equal in every position, except one has .Entry on the end, which makes it have 1 greater length then the other. The method will see the 2 imports as completely equal which is incorrect. Can we add something after the for loop like:  if (result == 0 && import1Tokens.length != import2Tokens.length) { result = Integer.compare(import1Tokens.length, import2Tokens.length); }
revert this string
speces before and after "+" :)
dont catch, better fail
Why do we need extra comma here?
This is not related to computed attributes in any way. Also, setting attributes would clear existing attributes, so I don't think it's correct. Also, I don't think using special keyword is a good idea. We need some different way of copying all attributes. For example, if copyAttributes is not specified it would mean copy app.
rename cmdResult to commandResult
Can we have some meaningful messages to accompany the tests please?
Why did we switch out the old code back to this?
The only reason this should be null is if the Activity context was used instead, so in that case we should throw an IllegalStateException or RealmException saying that the application context should be used, otherwise all the import logic will fail silently as far as I can tell.
Should at least have a DEBUG statement in this catch.
maybe  java public ServicePortAdapter(ServicePortAdapter port) { this((IServicePort)port); this.routePort = port.isRoutePort(); }  would be better here. It becomes clear what the new constructor does additionally
But that goes against the NAMED PORT first, the core port of this PR
rename to res
rename to launch
rename to res
Use org.apache.flink.table.utils.EncodingUtils#objectToString
Null is a valid return value ?
why hadoop's StringUtils.byteToHexString is not used ?
maybe this can be a set, so that duplicates get filtered out
activeContext was registered into activeContexts, when an event of ActiveContext happens. Why is it mentioning about running tasks?
Make this magic number be a static variable.
If this property is set, shouldn't the classpath have been updated before? I'm not sure why we need this code.
This method has RequirePOST but no permission check.
I am not convinced this is the correct permission, given that an AbstractProject would be @AncestorInPath.
Could you also test what happens when the data isn't Base64-url-safe-encoded, with labels, collision with an existing secret, etc?
Compare assertEquals(secret.getExpiration(), expiration); where expiration is a Date object
nit: Nesting builders like this can hamper readability. I generally prefer to build anything that isn't a single line (or sometimes two) prior to building the request.
I think this is incorrect - we shouldn't be placing files for variants of the same blueprint in the same directory. Can we add a pre-install command to create run.dir earlier than would otherwise happen?
trackerDirectory.toPath() would be simpler. The same for line 545.
Could use the Apache CommonsIO FilenameUtils.separatorsToSystem(String path) to be safe & cut down on verbosity. Also, that same utility has a lot of other useful methods that we could be leveraging throughout: A few: normalize(String filename) //normalize unneeded relative paths to simplify the path. ex: a/b/../b becomes a/b getExtension(String filename) //gets the extension wildcardMatch(String filename, String wildcardMatcher) //allows you to compare extensions or file names easily via wildcard
Update log messages to refer to timer instead of commit, here and elsewhere in this class.
Can we store the returned objects here, so we don't have to repeat database call in line 593?
why not initialize this in the constructor (and only set the herder in the Worker#start() via a setter method in connectorStatusMetricsGroup)?
The other examples all use ASCII table output - is there a reason for switching to CSV or has this just been left in after testing?
No need for try-with-resources
Would be clearer with a local method to create the baseMarketData()
ideally put operations would be done asynchronously so we don't have to wait for them to happen, but it's ok if jedis doesn't support that, we can always do it in asynchronous manner elsewhere in druid.
my experience with redis, is that listing keys by pattern can take a long time. This could be a problem, since we don't want those operations to lock up the query side. Is there a way to issue asynchronous operations with jedis, or we might want to create a separate threadpool to queue up those operations.
ex will always be null here
Why the dir variable ? I think you can inline it and concatenate it to the file name.
Why not define a ThirdPhaseVisitor (or any better name) and write fileInput.accept(new ThirdPhaseVisitor()) to for consistency?
Does this print entire file path when printing statistics? NDK version only prints the filename (excluding the path). We may need to preserve just the file name and pass here.
why not entity?
dont do this but let the exception be propagated back up so we can have a better error reporting about not possible to generate jacoco report due to .... Also these methods can be static methods
Not in spec.
This code is duplicated in removeImage too. You may want to extract it to a new method
you could remove the package here
If we use TestcontainersConfiguration.getInstance().getRyukImage() here, we will not have to pull it
It looks like a publish buffer, thats set to infinite during reconnect. I don't believe there's an analogous buffer in the other clients.
This sould be retrieved from the plugin, not instantiated here. Only the plugin should instantiate this class (which should be called ModelDependencyProviderRegistry)
Can this be private, or is there another use case for default attribute outside the builder's call?
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
why is it Collection of Strings (instead of String)?
Generics on the right side are redundant since Java7
formatting should be num = Math.abs(num);. Even more, from my point of view it would be better not to change value of the method input parameter and just rewrite the line in cycle int chunk = (int) (Math.abs(num) & 0xf); WDYT?
I would suggest checking == 0, like for (int i = 0; i < s; i ++) { exitTasks.get(i).run(); // in case previous task cleared the list if (exitTasks.size() == 0) { break; } } Another qq, no tasks would be added when this function is called? I think onExit() might be safe but executeTasksOnWakeup() is a concern.
if you take my advice, then this will be Math.min(maxTasks, numInstances * dsLimitTaskPerInstance)
< 0 doesn't seem like a great overflow check, maybe be more explicit?
why warn here always?
BufferUtils.byteToInt?
Throw an Exception on _else_ and check explicitly for the udp enum. Just in case we add a 3rd enum type, which should never ever happen...I just like being explicit :-)
optimize
Same thing here; if oc not null, ocn must be.
Space after comma.
isn't it copy paste mostly of another assertException method? why not reused that?
This exception is probably not thrown for method jdbc.query.
Those looked like good tests? Why remove them? Hash collision?
This wrapping makes it hard to read. Put it all on one line. Maybe use format().
This looks strange. I don't think breaking the line here improves readability.
The variable name - may be something different?
use stream api here too? and this time, there is no reason for null values to be present in profiles :)
This doesn't look right; a better solution might be to simply weed out all null values while keeping the rest.
no need for the if..diskimage is diskimage :)
/s/Disk/DiskImage
the if clause can be removed, see from where this method is called
If every other variable is in PascalCase, we should keep the convention in the file. Use TirePressureObject instead of tirePressureObject.
Please put @Override on the standalone line
should this have a ,  to match the rest of the pattern?
Where is the aggregation?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
* What happens when task.call() throws exception? Not call onTaskEnd? Is it safe to assume that task is never going to throw exception? * Is there a scenario where only onTaskEnd/Begin() is called or called out of order?
use Java8 stream anyMatch() instead of this loop.
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
Constructor that throws an exception is pretty ugly. Especially because it is created and injected via Guice.
perhaps, combine these if statements
In my opinion, it is bad API design on hive metastore to have those methods that take partition names. All of them should really be taking partVals. But anyways, that ship sailed. When using this API, care needs to be taken. I don't think it's acceptable to make all these extra getTable calls. * Based on my brief reading, the pre-existing getPartitionStatistics don't need to turn partVals into partition names, it should do all the conversions the other way around. * For the new addPartitions and alterPartition, I'm thinking maybe the right way to approach this is to use include the partition column names in the thrift-API-side (as opposed to the extended-side) PartitionWithStatistics. Otherwise, all these calls are going to turn into a significant number of getTable calls.
Throw HIVE_METASTORE_ERROR
It would have be easier to review if the refactoring to use an ExpectedException would have been done in another commit
minor: rename to ws
Please use consumer, it's more easily readable :  db.rules().insert(rule -> rule.setStatus(REMOVED)
What does this do? The result is passed directly into Datasets.load above so it should produce a dataset or view URI. But it appears to check if the URI is absolute (assuming that it has a scheme) and remove the beginning '/' if so?
Should maybe other countries be added here?
this method should probably be final. Also it is missing the @Override annotation AFAICT
I think most of the callers of normalize() convert the String you return to a BytesRef. So maybe it would be better to drop the extra utf8ToString() call and make this method return a BytesRef directly?
You should check whether the type is assignable in all cases. Just, when the projection converter is disabled, you will call isConvertedTypeAssignableTo on the *raw* converter. Note that your tests didn't fail, so you're missing a test where you try to pass the wrong type to rawField(String, Class).
This seems wrong, it should be rawField( absoluteFieldPath, Object.class ). And tests do not fail, so you're missing a test here.
suggestion scopes = new Gson().fromJson(responseString, ScopesList.class).getList();
Interface Map<String, String> will probably be more appropriate.
after saving can you broadcast, so as all other users on same note gets this save update ?
I would prefer some brackets around the logic elements for readability
The name is now no longer accurate. Maybe don't replace the line delimiters inside this method.
Use org.apache.flink.table.utils.EncodingUtils#objectToString
isSameAs() instead of isEqualsTo()
isSameAs() instead of isEqualsTo()
@szczepiq What is tested here? I can't see an assertion.
Since IBlock is a thing, I'd definitely call this blockstate or something.
!block.isIn(BlockTags.LOGS)
ArboricultureBlocks.SAPLING_GE.blockEqual(blockState)
Given the FBO manager is passed in anyway, why not leave an additional constructor that takes the FBO's URN as input, retrieves the FBO from the manager and simply passes it to the constructor being used here? It would shorten this line and others like it.
Let's move this line with the FBO-related state change. Just double-check if it needs to be before/after setupConditions();
We discussed this already, but please remind me: update() is executed, for example, when the user resize the window. Why not to avoid any form of memory allocation in those circumstances, even if it's admittedly small in this case?
and the param?
typo
Shouldn't this code run even if mHasWifi is false?
use <LINK_0> to avoid the build version tests
can these key strings be public static final String in this class?
I think it would be better to let the stream figure out or not whether it needs to send a priority frame internally. Indeed the HTTP/2 stream knows if the first header frame has been sent or not
getLong?
Null-check
Null-check
Why would we want to silently fail here? Why not throw an exception on any update operations to tombstoned relation metadata?
Where do we delete the corresponding entries from the relation_schema table?
lang is already a FunctionLanguage number why do you need to check for MyriaConstants.FunctionLanguage.values()[lang],null)?
nit: perhaps, include column name in the error message
I don't see why this method should return something. It could simply check if (newStatistics is != null && !Objects.equals(existing, newStatistics)) and throw an exception in this case. And the calling method above can always use existing, when the validation is successful.
This is not needed, since the constructor already checks it
nit: usually we put everything in one line or follow this pattern: java PlanBuilder planBuilder = subqueryPlanner.appendLateralJoin( leftPlanBuilder, rightPlanBuilder, subQueryNotSupportedError(lateral.getQuery()), true, LateralJoinNode.Type.INNER);  Just like what you have done to appendApplyNode
A future commit introduces a RowType enum. Is there any reason that change is not part of this commit?
Aren't there any test methods that require compatibility?
move else if next to closing brackets.
I think that this method deserves to be protected and tested.
This is apparently out of date.
1. what about creating the device/mocking vmdevicedao? 2. when you do, please add assertion that the device.readonly is false also. 3. please add verify() that shouldUpdateReadOnly() is being called.
This device seems unused. Can it be removed?
1. you compare with vmDevice in the command. 2. please also use assert to check the return value shouldUpdateReadOnly(). thanks!
getCurrentVariables() => currentVariables
uuid can never be null here because if EntityPlayer.getUUID(player.getGameProfile()) were to return null you'd already get a NPE in line 44. Maybe use something like java UUID uuid = EntityPlayer.getUUID(player.getGameProfile()); if(uuid == null) { uuid = EntityPlayer.getOfflineUUID(player.getName()); } if(uuid == null) { CrafttweakerAPI.logError("Could not get UUID for player " + getName()); return ""; } return uuid.toString().toLowerCase();  Also, since I don't know these vanilla methods that well, can player.getGameProfile return null, and if it can, will getUUID(null) throw an error?
Since we're modifying this line, feel free to remove the String array creation, just like AS suggests (Array.asList is a varargs method). Thanks!
Would it be too nitpicky to question why there is an intermediate rolls variable? dice.getRolls() is just as descriptive and it's only used a couple times below. Removing intermediate variables is often a good thing, one less thing for a maintainer to keep on their mental stack when reading code. At this point when reading the method, there are 3 variables in scope, soon to be a 4th one, leaves little room for much else!
Why is this necessary? Why don't you move the getAbsolutePath() to where TEST_INPUT_VCF1 is declared?
Get rid of the word "exome"
you could use executeGet()
This should be done in execute()
You would need to error out or S3 service to error out, not to delete with Set()
combine the two lines and return the String
Formatting: we use 4-space tabulation in files
Move this check into getPropertyValue(String key, String name, int index), gut this method and have it just call the other one.
I am having a hard time understanding the reason for this change?
The property name does not match the one in SystemEnvironment, may be you could use SystemEnvironment.GO_WEBSOCKET_MAX_MESSAGE_SIZE.propertyName()
jobErrorHandler -> each
Can we log the case of "dg" is empty?
Although Java allows this, It will really help code readability and future refactoring if we need, if you could avoid accessing these internal variables outside.
Can we introduce shutdown() to the _PartitionDiscoveryThread class. shutdown method can call the thread.interrupt() or any other mechanism to shut itself down?
You need to go through the persistent resource (instead of the data store), to ensure security is invoked.
You don't need the else statement here. You can remove it leaving the LOG statement and the code will be exactly the same.
for the sake of having the same naming format as other Azure SDKs, can we use '.' as a separator everywhere? E.g. 'Appconfig.getKey' rather than 'Appconfig/getKey'
assertThat( query ).assertThat( query ) ?
assertThat( query ).assertThat( query ) ?
assertThat( query ).assertThat( query ) ?
URL Decode would be necessary for parameter name and value
Should look into having a ConnectionStringParser class in Azure Core, I've been seeing this functionality in a lot of places.
I recently learned about tokenizeToStringArray, may help clean this up a bit.
Instead of having this be a part of every authorizer, we probably want to push it up a level and have it be a part of the code that calls the Authorizer.
Please only log at debug or trace
If we are always dealing with character-based payloads (and maybe we aren't) then logging the decoded version of the payload in a toString() would probably be more useful than the raw byte array
Do we need this catch block at all? I think exceptions are handled up the stack anyway.
Why don't you want to do this in constructor? I see you use static configuration as a dynamic, but I think it doesn't right too.
this should be catch (Throwable t)
no need to handle failure (rollback, log, etc..)?
This sounds as though we have a technical debt here. How about "isn't required for file based domains"?
this should be called only in endWithFailure()
The values are sometimes a list and sometimes a comma-delimited string?
Why is this here with such a wide exception type?
soft suggestion: this first check for nullity is unnecessary as it can be handled by the if-else statement on the next line.
You should handle the exception here, report the error and report the whole process as failed.
Isn't this the part for which we added a breaking changes entry in master?
Add final keyword.
possible NPE
Minor - can use getAuditLogTypeValue() here.
Please add null check for volume.getAsyncTask()
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists.
use Arrays.asList(...) for short lists.
I test fails than container will remain started and port is busy. So, good practice is to enclose tested code in try block and stop container in finally
@cvrebert don't we need to stop the container in finally block? What if some method will produce unexpected exception?
let's stop container in finally block to be sure
It's wired the method getXXXList does not return a list but a set instead.
Please mark resource parameter as final.
Shall we return Collections.unmodifiablemap?
Add this logic into the certificatemanagerserviceImpl class.
Why do we need this method?
why do we need this method
please log in error
new CommandContext().setExecutionContext()
calling this command will not move the host to up. need to think of a way to activate the host and keep a flag it already been attested i thought using the non-operational reason but i think it is cleared in ActivateVds command
Use IASTUnaryExpression instead of CASTUnaryExpression.
The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.
Use an interface instead of a concrete class. Same below. Space is missing before "else".
Typically we use Map on the left hand side rather than HashMap
Is the order for entrySet guaranteed to be the same every time its called? I know it will for HashMaps, but I'm not sure about other Map implementations.
Only set the map if non-empty.
This can be simplified when we remove the enableDoAs logic.
nit: Maybe Connecting to kudu with kerberos authentication?
nit: This will result in double logging
ExtensionNamespaces.LBAAS to be consistent with the alias name.
Do we need any printStackTrace() here?
why it is not a constant!
Missing final
Missing final
Missing final
Please double check all methods that modify the LinkedHashSet. From what I read the iterator might need to be regenerated every time something is added or removed from the set. If that is the case it might be appropriate to have additional register(ArrayList) and unregister(ArrayList) methods to pool changes together and regenerate the iterator only once.
Static import?
This could be private to prevent instantiation. If sketch classes are loaded statically, it can be probably be empty.
Set this only if session details not null??
Apply default formatter
Feature support check can be done here itself
Suppose there are two interfaces:  public interface NamingServiceV2 extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.implV2.Param param) {} } public interface NamingService extends Service { default void testMethod(org.apache.ignite.internal.processors.service.inner.impl.Param param) {} } public class NamingServiceImpl implements NamingService, NamingServiceV2 { }  so, metric names will be: void_testMethod(Param) void_testMethod(o.a.i.i.p.s.i.i.Param) How should I understand which method the metric refers to? Also, there are possible names collision on different JVM's. Possible solution - use mtd.toGenericString() as metric name. However, this will have poor readability.
use append instead of +
Why change to use the String instead of char?
One other thought. All 3 tests share the same fundamental logic for inspecting the results of splitting. Would it make sense to create a private function that takes a Stream<StringHandle>, a Format, and the String[] array of file lines and is called from each of the three tests to perform the inspection common to the three tests? If that's possible, that would make maintenance easier (with the cost of having to break out separate tests if we ever discover a need for different inspection down the road).
There's no need to do the additional (String[]) cast here, T[] toArray(T[]) is generic in T.
suggestion // <LINK_0> private static String readHexString(ProtoReader input) throws IOException {
Can we also have a test for LUCENE -> NATIVE -> LUCENE
GraphDatabaseInternalLogIT.INTERNAL_LOG_FILE instead?
this can be not enough on latest 3.3 version
Suggest adding an assert that the only task name in the list corresponds to the last invocation of setTaskName(...).
Tests are expected to run quickly so don't use Thread.sleep(...). Signal a mutex to let the UI thread know this thread has reached this point and then block this thread on a mutex which you signal from the UI thread when you're ready for this thread to continue.
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Put these two assignments in order so it's clearer
size should be k to be more intuitive. Or vice versa?
Just a thought, but you could push the expression parse logic down into this class. I could see Condition having the following public static methods: * public static Condition fromExpression(final String conditionExpression); * public static Condition fromStrings(final String field, final String operator, final String object); * public static Condition fromEnums(final Field field, final Operator operator, final String object); Or something along those lines.
No reason to store in a local variable if only used once within the method. suggestion
Can we log the debug message in one line? Those multiline messages could be interleaved with multiple processes.
We don't need a wrapping if - it is redundant by the reason of a constant for a message.
If instead throwing an exception when policyParameters[3] == null you log the error. I think it will return a NullPointerException when you do credentials = (byte[]) policyParameters[3].
replace toString().length() > 0 by ! toString().isEmpty
empty array is better than null? AIOOBoundsEx is better than NullPEx? Is this if necessary?
use LinkedHashMap
Please move this at the end of before() method.
Only Ickle queries will be supported
Shouldn't you return early when you find a non-null interval so that you don't have to map every remaining quark for nothing?
I'm not happy that this state-specific code is in generic method of the CircuitBreakerStateMachine. Maybe we can add a postTransitionHook or preTransitionHook to states which are invoked here in a generic form?
OpenToHalfOpenAutoTransitioner.scheduleAutoTransitionToHalfOpen() should be invoked in the Constructor of OpenState.
Run formatter
this doesn't belong here. If we don't have a generic concatenation method available in foundation already, then either use [StringUtils.join from commons-lang](<LINK_0>[]%29) or [Joiner from guava](<LINK_1>
Another FYI, not a required change: note that there are some "gotchas" when using String.split with a regex. [Here's a nice breakdown](<LINK_0> If this was high-performance code, you'd probably want to compile the Pattern ahead of time, and split using that instead. I only learned about this a couple months back.
Could we simplify the 2 lines above as if (FileKey.resolve(gitDirOf(name), fs) != null) {
dir.getName() returns just the last segment of the path, since project names can be hierarchical (e.g. a/b/foo) I think this is not enough. We should rather include the full (encoded) project name into the file name.
This case is not so uncommon. I reported it because developers do mistakes in all weird ways. And this type of mistake causes confusion. If you push to plain git repo then you will get an error. Gerrit should do the same. Throw an error. So please don't give up :)
nit: perhaps, include column name in the error message
Perhaps, check that rowCount >= 0
move ColumnStatistics.Builder columnStatistics = ColumnStatistics.builder(); here
you can call getLocalClusterRoleType
Negotiation -> metadata
are we missing the setType(LogReplicationMetadata.ReplicationEventType.FORCE_SNAPSHOT_SYNC)?
This should be changed to @%s usage warning: found unsupported restricted type <%s> on %s. instead, or something similar, since these APIs aren't official supported APIs and are subject to change at any time.
This condition needs a test.
Better use Class#isAssignableFrom(Class) which is like instanceof
This log ends with a period, the corresponding does not, they can be unified. Perhaps these messages could be more "parsable" visually. What do you think of the following? [Signal(id)] Created consumer for {}. [Signal(id)] Deleting consumer for {}. (and so on)
*was created ;p
Maybe it's better to use LOG.debug("Failed to find subscription: {}", subscriptionId, e); to avoid unnecessary string concatenations.
Just do getAndSet(null). Then shutdown the returned value.
include isShutdown here in the log?
Just making sure: this line automatically cancels the scheduled runnable in _scheduledRefreshFuture right? If the refresh period is right after this line and before the next line, it's okay?
I think here you can do something like steps.stream().findFirst().orElse(null); If findActions receives null, return a Collections.emptyList();
Immutable
we are trying to use meaningful names, you can rename to workflowAction
Same nesting questions
I want a "nest" emoji; can't find one...
I'm confused. Assuming this is a "non-pending" reviewer, then if the TT is !null and retired, we give a warning; great. When would we give an error? If it's null? Are TTs required? If that's the case, then the error message with the name "testToolNotFoundAndRemoved" is either the wrong message or named badly. If this _is_ a pending reviewer, then we're still not removing TTs; we should just give them an error and make them remove it themselves, which also doesn't match the error name
Please inline the variable numberOfArguments (which is not used elsewhere), remove the finalmodifier (we internally don't use them in such context), and use type ProgramState.Pop instead of Pop (in order to avoid import of type Pop, and simplify understanding of the context). I would also prefer a variable name close from what it represents, like unstack, which is the name used everywhere in this class.
This makes me wonder a bit if we are not creating a new way to access semantic model rather than relying on what's existing.
this branch is redundant, can be replaced by if (op2Zero)
No need to mock, this is the default value.
I'm not really sure what exactly you want to calculate here. If you just want to find any grabbed or visited log, then neither the continue nor the break should be part of the loop, but just the if. If you want to calculate something else, you still should rework it, to not have a continue _and_ a break in the loop. For me, at most one of those is allowed in a loop to make it understandable.
I would just get of any semblance of support for Apache.
I think this solves the problem, but why aren't we removing the processor field from this object? If it's dangerous to reuse it, and the one stored here isn't necessarily the one used elsewhere, then surely we shouldn't store it for later access?
why not just use putAll?
Can we move this to the @BeforeClass so all setup and initialization occurs in the same place?
This is the second use of these strings, specifically with a trailing space. It would probably be best to extract constants for them.
"camelize"... that's flowerly...
please also add the GUID which is important.
Don't catch Exception or Throwable, that's overkill. If any of that code throws a checked exception, catch that, optionally with RuntimeException too if needed. If you want to catch 2 exceptions, use java 7 style "catch (FooException | BarException e)" Catching Exception is bad because if the code has no checked exceptions, then you could just catch RuntimeException. If it has, you can catch those and optionally RuntimeException (if the latter makes sense and often it does not make sense to catch RuntimeException) Catching Throwable would be even worse, as that catches OutOfMemoryError etc, which need to bubble up the stack.
even though data is a HashTable, it's best to cast it as a Map since that's all that we require.
should use Number instead of Long
can you change this impl to be addJobProperties(job.getConfiguration()) ?
Use map.forEach
why not just use putAll?
Should these go to logcat?
pass the whole exception to logger.errror
Don't we need to the close the streams?
A SashWindowsManager can contain several TabFolders. Only iterating on the Active one will miss some (opened) diagrams To reproduce, open 2 diagrams in Papyrus, and layout them side by side, and control them both. Only one of them will actually be opened in the resulting controlled models (The one from the "active" tab folder)
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
style not: we don't use braces around single line blocks
nit: maybe better to check the newSegment has a newer version than the old one.
is this line useless?
Please retain assignment order.
use multi-catch ?
The key for the externalized text has Push in its name, since this command is not related to push this key should be renamed to "ChangeCredentialsCommand_writingToSecureStoreFailed"
I would prefer it if you don't add final to method arguments and local variables. As of Java8 variables are effectively final by default and IDEA will underline non-final variables. So the final keyword only clutters the code.
Collections.singletonList() might be more concise. List returned is immutable if that is of any importance.
[Checkstyle] INFO: Line is longer than 140 characters (found 146).
How are you planning on setting this flag? Does the application need to know whether fetched offsets have taken into account ongoing transactions?
I have to admit that I don't understand enough about this, but could this be a binary compatibility issue?
Right now you're swallowing all exceptions, which may hide problems that have nothing to do with servers being unavailable. Perhaps check for IOException and UnknownHostException, since createConnection() declares that it can throw them?
Not blocker: please put a space after "catch"
Here you should check the result metadata first and only if it is not INT, directly call super. transformToIntValuesSV() which will do the type casting. Same for other methods. You don't need a separate switch inside the method.
You don't need to check data type here, but directly call evalInts = transformFunction.transformToIntValuesSV(projectionBlock);. The transformFunction can handle the type casting. Same for other places
So this is gathering the bitmap by invoking the BinaryOperatorTransformFunction?
lots of these to cleanup
Same here: The new flag withAttempts is not passed (used) the paymentProcessor#getAccountPayments
why the braces removed?
How about we use the isBetterOrEqual method from GeneticAlgorithm class?
Why is list necessary? The number of elements is passed, so array may be allocated at the beginning, it is not necessary to rely on ArrayList to determine the final size of the array.
This is inherently dangerous. sharedList is a CopyOnWriteArrayList which is _safe for iteration_ even while it is modified. However, once you abandon the iterator, it is possible for the sharedList size to decrease while you are in the loop, and sharedList.get(i) will generate an ArrayIndexOutOfBounds exception.
This is where the if statement should be for checking the property for allowing for corrected times.
Same here, why public?
Why is this public?
It would be better to write group by clause at the next new line.
Do not add the check here. Add the check just for dateuploaded.
I think this need to go into troubleshooting string, rather than just Exception.toSTring() @simplynaveen20
Use the whole path IPv4.Availability.PUBLIC
Use the whole path IPv6.Availability.PUBLIC
encodings ?
This is the line of code from the else branch. Since the version is above honeycomb you should use findPatientView = (SearchView) mFindPatientMenuItem.getActionView(); from the if branch.
Please move listener to desired mode
Can you not just check for searchView.hasFocus(), instead of having to set this flag?
Oh yuck. ;)
If every other variable is in PascalCase, we should keep the convention in the file. Use TirePressureObject instead of tirePressureObject.
minor: could you add disabledReplicas as well?
This will always be true right now, you'd have to setNofityRequestNeeded(false) also in buildManually of the history builder. I'm not sure what this adds, it's one more call the module developer will have to make, just to avoid calling this twice.
I don't think refreshing here is sufficient. The way I understand it, if the job is sleeping, cancel() will not call cancelling() and the refresh won't happen.
I think reference assignment is atomic so this change and some other below don't make any difference.
why the magic right shift? is this based on experience?
The readability of the test can be improved by extracting a method subGroupsOfCurrentThread @Test public void threadGroupNotLeaked() throws Throwable { Collection<ThreadGroup> groupsBeforeSet = subGroupsOfCurrentThread(); evaluateWithWaitDuration(0); for (ThreadGroup group: subGroupsOfCurrentThread()) { if(!groupsBeforeSet.contains(group) && "FailOnTimeoutGroup".equals(group.getName())) { fail("A 'FailOnTimeoutGroup' thread group remains referenced after the test execution."); } } } private Collection<ThreadGroup> subGroupsOfCurrentThread() { ThreadGroup[] subGroups = new ThreadGroup[256]; int numGroups = currentThread().getThreadGroup().enumerate(subGroups); return asList(subGroups).subList(0, numGroups); }
As we are testing the method checkAccess, we cannot mock the carbonSecurityManager class. We need to create a real object of the carbonSecurityManager class and call upon the method.
add java doc explaining the packageName is used for finding the package and if it is not found it is created. method name should be reflect this. Maybe this should be split up into separate fucntions
rewrite use '?' and split out id var
suggestion String packageName = entityType.getPackage() != null ? entityType.getPackage().getId() : null;
For the sake of saving some network traffic, let's not call logNavigate in this case. We can simply assume that, in the case of version 0, a linkClick event also implies a navigate event.
We should probably have an empty source?
this seems safe enough...TBH could not find the path that can trigger this code ...happy to learn in case you want to share, thanks
You should read <LINK_0>
can this be logged instead? or removed if not needed?
variable names here sound confusing. Would suggest to change:  for (final ColumnConfig columnConfig : columnConfigs) { final ConfigSource columnConfigSource = config.getConfigSource();  Or something like that to show column config and config source
if (
please test other types as well..
final
What about caching the list? AFAIK this method will be called multiple times on the same connection.
My feelings for using exceptions as flow control aside, this log statement is forgot to include the exception e.
Why did you use ConcurrentHashMap here?
Unless a good reason for this, the following is considered more correct:  java if (getClass() != obj.getClass()) { return false; }
why don't you use the other class members directly? why go via the public interface? I also think I asked several times, why AbstractMap::equals is not enough for compare?
buf may be null here because we discard it in toObject. We should be more aggressive about converting from buf to object format. T thisObject = toObject(this, this.codec, other.codec); T otherObject = toObject(other, this.codec, other.codec); if (thisObject != null && otherObject != null) { return thisObject.equals(otherObject); } else if (this.buf != null && other.buf != null) { return Arrays.equals(this.buf, other.buf); } else { return false; } private <T> static Object toObject(SerializableProtobuf<T> sp, ProtobufCodec<T> codec1, ProtobufCodec<T> codec2) { if (sp.object != null) { return sp.object; } ProtobufCodec<T> codec = codec1 != null ? codec1 : codec2; if (codec != null) { sp.object = codec.decode(sp.buf); sp.buf = null; return sp.object; } else { return null; } }
return builder.toString();
Please keep using old "for loop" style to reduce GC
Why don't you instantiate the builder here?
just a reminder about the db lock for better user experience so we can see more opinions about that
please add a log which indicates that the update process was ignored
that should be inside an else clause, no?
How are you planning on setting this flag? Does the application need to know whether fetched offsets have taken into account ongoing transactions?
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
i am a little concerned about how often this is going to be invoked. It seems like a huge waste that most of the result would be thrown away.
You don't have to implement entire getCurrentToken() in each TokenCreator. Each TokenCreator is having the exact same code. Instead add this logic to a method retrieveCurrentToken() to AbstractTokenUtil and then just invoke that method (azureTokenUtils.retrieveCurrentToken()) from each TokenCreator:: getCurrentToken()
It's nice to have expression lambdas, but using node.findFirstToken(TokenTypes.IDENT) results in evaluating the same node twice. Assign to a local variable.
Replace 1 with TokenTypes.EOF.
could this be replaced with return JodaUtils.umbrellaInterval(usedSegmentIntervals) ?
Line exceeds limit.
Can you drop the -1 and just use less than, instead of less than or equal. I think its more clear that way.
Should be dispatched from UI thread, TimeGraphViewTest:304 is also wrong.
You could merge this for with previous by using TmfTraceManager.getTraceSetWithExperiment(trace)
{ on the same line
Although we don't gain that much from wholeWord, we may need to implement it to be consistent with the options available.
Can be replaced with contains()
Do we need to send the tab key here? I looks like all it does it focus the dropdown. Are we testing for something besides the strings matching?
Is it possible to make a check if we need to migrate outside a transaction. Transactions on init are pretty dangerous in multi-process scenarios, since they most likely happen on the UI thread.
Wrong wrap?
Shouldn't we remove the Realm and its management files?
Perfect! :+1: Just a few things. I'm a little picky here :grimacing: No need to extends Object. Please use Map as declaration type. java return new ArrayList<>(uniqueMap.values());  The method is a perfect text-book example for tests. :wink:
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Consider to use an ImmutableList here
this, too.
after saving can you broadcast, so as all other users on same note gets this save update ?
maybe we can come up with a better implementation here like revision.isEmpty() or Revision.isEmpty(revision) what do you think
necessary?
Would be nice if we will have a ctor for all of those properties
You have one redundant space after the private modifier
What are these annotations ?
I prefer short log messages for events. Would suggest to change it to  return itemName + " changed from " + oldItemState.toString() + " to " + itemState.toString() + " through " + memberName;
These are not the node metrics
just do not catch anything, you test throws exception
It is better to throw a MessageException here. It is implemented exactly for such purpose.
We could just always use the body instead of flipping based on the payload size.
There are quite some AccessResultCodes beside SUCCESS. If the result is included with the exception this could provide useful information about what exactly went wrong.
Share the string.
The same thing here regarding the passing of exception to the new one that is thrown.
@gitgabrio can you please explain why you removed this? I see you added scenarioGrid.clearSelections(); to clear the selection @ line 133, but scenarioGrid.deselect(); modifies a different status.
Local variable could be declared List instead of ArrayList. Is this worth caching?
new uses the platform default encoding. This is often UTF-8, but it's definitely not guaranteed, so unless it's always ASCII, there will be problems. (Also for getBytes, Unicode can come from the application and would then result in a mess in binary)
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
We can rename this constant to something like TASK_STATUS_EVENT_TOPIC since it's not kafka specific anymore. Same thing with DEPLOYMENT_GROUP_EVENTS_KAFKA_TOPIC.
remove return val never checked. Suggest adding in log (info maybe?) if task is attempted to remove but not removed.
types --> type
if this is cancelled should it still be disposed?
Generally, rather than catching the AssertionError, we've had two methods for each operation on RepositoryContext: one that expects to succeed and returns the result and another that expects to fail with a given error code and returns nothing.
Please do a table.put(List<Put>) instead.
minor: no need for final?
parseInt()?
This line should be removed
Does hostNames always contain one element? The contains operation is expensive...
you can reduce it to (null != hostId)?hostAPI.find(hostId, user, false):null;
"belonging" -> "which belong"
"belonging" -> "which belong"
"belonging" -> "which belong"
why is the first parameter a LayerCommand if we only need the resulting Layer?
Since they have to pass force=true as an argument, we should make sure they specified "true" not just anything
please rename both variables: sortFilterCmd and updateFilterApplicationCmd
also assert the cause attributes
need to handle case where fieldMapping is a macro, so output schema is not available in configurePipeline
Do you need this while configuring pipeline?
Should we add: Objects.requireNonNull(record)?
When we merge the InternalMock with MockInternal would this be okay? cc @cadonna
I realize this isn't being used in code yet, but this isn't doing the correct thing, since it is only grabbing the first record that is returned by consumer.poll() when there could in fact be multiple records. I also noticed the BlockingQueue records isn't being used and this is probably why. Since RecordSupplier.poll() only returns a single item, the rest of the results from consumer.poll() would need to be stored in a bounded queue somewhere, and you would only call consumer.poll() if the queue is empty (or if the consumer.poll() call is slow, you might want to consider using feeder threads similar to the Kinesis implementation). Alternately, another approach would be to change RecordSupplier.poll() to return a list which would simplify the logic in this class.
I recommend throwing the list into dependency resolver instead. This also will allow the user to not have to specify the full dependency chain.
This logic looks suspect. And why the separate private method?
Explain.
why causeOfDeath is empty ?
do not add this
remove this
Are you sure that you should add this file, too?
Origin is never checked, also the original ticket talks about implementing the CORS preflight which is used by SPA frameworks like angular, where they do an OPTIONS request in that case the request should not continue the filter chain since it only needs to respond with the CORS headers.
suggestion HttpServletRequest req = (HttpServletRequest) request; String lengthHeader = req.getHeader("Content-Length"); if(lengthHeader != null && !isSizeWithinBoundaries(lengthHeader)) { throw new MaxUploadSizeExceededException(multipartConfigElement.getMaxFileSize()); } chain.doFilter(request, response);
Can we name this something other than it? Even i would be better to me than it.
I think a variable should be introduced for this long expression.
why is it Collection of Strings (instead of String)?
HQL/JP-QL
do you think we should handle multiple semi-colons? Or is that overkill? Also, is the problem with only semicolons or with a set of characters at the end?
Detail: FROM capitalized.
{} for blocks
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
this should be tableViewerFactory
This is not needed. In super.tearDown(), all the replaced stuffs are restored automatically.
This doesn't make sense, just use observe(options.getOwner(), ...).
Do you also need to wait for any handler threads to process outstanding messages?
what if the acl is not found? we should skip metadata update in this case and return false?
should we return false if no such acl is found?
@bharatviswa504 can we make some test utility methods for this that hide the detail that table/cache are being updated directly?
Message should probably be sent before actually unloading chunks. :)
it should be  java if (TFM_AdminList.isSuperAdmin(player.getName()))  Correct me if i am wrong
I might be nitpicking here, but could you lowercase that last 'W'?
You could use getEndTimeAsZonedDateTime here for simplicity
Why not just pass the enum, will that not work?
If two threads concurrently conclude that the day activity is missing, we end up with two entities for one day. We need to figure out how to handle that. I propose to create a separate ticket for this.
Could you please assign the URL to a local variable before opening the connection? This helps while debugging problems.
"this." is not necessary.
DANGER WILL ROBINSON, DANGER! Is the password really passed as an URL parameter? Any proxy on the way could record your password. Please check whether the API allows the password to be passed at least as a POST attribute...
suggestion Pattern argPattern = Pattern.compile("^\\$(?:\\{(.*)\\}|(.*))$");  Align with start and end of the string. Otherwise you would also match bla$ad or ${foo}bar
suggestion Pattern pattern = Pattern.compile(Pattern.quote(attribute) + "\\s*(.*)");
Pattern compilation is relatively expensive operation. Could we make this pattern into private static final field of the class?
Are we expecting more than ILaunchConfigurationTab? The exsd file mentions that we should get CLaunchConfigurationTab, although I think it should probably be AbstractLaunchConfigurationTab
The question for me: is this xml configurable or should it be the part of the interface? I personally prefer to use interface and ask the object, which might have some dynamics regarding whether it needs UI or not.
Here again, instead of scattering the code with if() statements, it would be more robust to have a wrapper method replacing all the calls to "Platform.getExtensionRegistry().getConfigurationElementsFor" which does the check and then return an empty table if the platform is not running.
missing braces
I would prefer ArrayList here, as it's faster, have smaller footprint and we don't need fast insertion in the middle.
We should be using StringUtils.emptyToNull here.
Why do you need this cast? Is it because ScreenLoadCallback implements both interfaces and its picking the wrong return type for the old style RPC call? If that is the issue maybe add a 3rd method addOldCallback() that calls the old type add() version so the compiler can't guess wrong for a ScreenLoadCallback?
Thanks for digging in to the cause. I know I wrote some of that code, so sorry. In this case I think 204 None is an acceptable compromise.
why did you put this in a local variable? Why not just inline?
how would you feel about making this an actual URI builder instead of a string builder?
optional: use buffer.append(msg).append(key).append("...")
why not use new URI(scheme, host, path, query, null) to make it more clear?
Consider adding an additional layer of abstraction for this block. This has very similar lines as the other two methods.
use finally
I think you should add proper custom error message in this case.
don't we want to copy the name from the model to BE?
1) To be consistent with the way enums are handled in the API layer, please create VmPoolType enum in the API, write mapping methods for it here, and use them. You can take example from any other enum in the API. There are several examples in VmMapper, you can jump right down to the end of that file and see NumaTuneMode 2) The possible values for this enum should be displayed for GET .../api/capabilities. See BackendCapabilitiesResource for examples
This should be 'isSetAutoStorageSelect' ...
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
resolvedImges can't be null otherwise the next for loop would fail with an NPE. Actually I would either put this into an extra method which returns early in this case or put this into an if-else with the following loop.
what if imageUri == null?
can be inserted to the if bellow (redundant if build is not captured)
If we are going to use System properties shouldn't we reset them when the test tears down? We don't want any unexpected side effects when other tests run.
System.clearProperty can be used instead.
This is not working on my system as I have **space** in the path:  java.io.FileNotFoundException: /.../tc9.0.x%20(trunk)/.../org/apache/juli/logging-non-rotatable.properties (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.<init>(FileInputStream.java:138) at java.io.FileInputStream.<init>(FileInputStream.java:93) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:469) at org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoaderLogManager.java:309)
I would dump this iterable into a variable just for clarity. It looks more than a tad clunky in-lined...
One concern that I have is whether this method is only used for the determining the next billing period start date. I want to make sure it does not inadvertently affect offer parts of the application.
Do same for this one
I fail to see the difference to the previous test. Is there any?
Would you mind improving this test to use executeFile() instead of executeString()?
Can you use an anonymous name for the maintainer? Not something from production
System.out.println("...... and path id (optional).......
return -- no needed
VoiceCallFlow has to be imported, no need NotFoundException import
I'm really used to the builders creating all their children all the time, is it really worth doing it differently here?
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
I would create default-visibility setters on the configuration instead of passing things in the constructor and inline the getProducts and getFields methods: config = new BRConfig(); config.setProducts(getContainer(...)); config.setFields(getContainer(...));
We should probably also add a message saying that you cannot barter with piglins using Slimefun items.
No need to cast a Player to a Player here.
Enums must always be compared using ==, not .equals()
it would fit easily one line
Could we please use Objects.equals also here?
dmnGraphUtils.getDefinitions() can return null, please protect from NPE on this line.
Don't duplicate the error messages and again, in almost every case I think just throwing without context is fine. The code well explains what's wrong and we don't expect it happens under on any reasonable Android device.
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
I like the noInstanceBecauseStaticField you used for methodsField.set(noInstanceBecauseStaticField, allowedMethods); maybe you could do the same there with methodsField.get(noInstanceBecauseStaticField)?
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
did you mean to make this change?
Can we store the returned objects here, so we don't have to repeat database call in line 593?
This exception is not ignored, so can you fix the variable name?
extract private method boolean waitForOperator(Operator operator, Duration timeout):  try { operator.isBlocked().get(timeout.toMillis(), TimeUnit.MILLISECONDS); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException("interrupted", e); } catch (ExecutionException e) { throw new RuntimeException(e.getCause()); } catch (TimeoutException expected) { return false; }  and build assertions around this method
Is this worth making configurable?
nit: what about java nulls[i] = i % 7 == 0  ?
Do we need to check Null of the input parameters?
In the #valueOf(int,int) method, we could simplify the resulting bytecode slightly by eliminating i and using fromIndex as the index variable within the loop. As in: java for (; fromIndex < count; fromIndex++) { ...
I'm surprised that getRequestParameter does not return an Optional :)
take advantage of flatmap to avoid calling isPresent and get
This is not necessary as it is null by default.
Unneeded empty line here.
Does mean there's no signal for "the user typing out a correct entry, not clicking on the entry in the list, and then clicking on the next question" which results in the value being set? Clicking the ">" or swiping would do it, since that triggers a "get answer", but I wonder if, say, losing focus should also attempt to set it?
Use Zlog.LogException(e) wherever Exception is caught!
Looks like addEdge(), removeEdge() has the same logics as the base class. Why do we need to override here?
Consider wrapping this into the constructor, and getting rid off the setter? StreamEdge(isIntermediate)
Do you think the EdgeIterator.isValid is more clear here (and in the calcMillis)?
toTraceId already returns a string, on need to call format()
why is this changing to s from x? also, maybe you can use context.toTraceId()
In your @Test, you can use @Test(expected=IllegalStateException.class) and _not_ do the try/catch within the method. This is cleaner and more appropriate :)
Shouldn't it be CONF_DEVICE_ID_TOPIC?
I may just be missing it but is there a test to validate the setting of the identityProviderId via the get identityProviderId() method. A check on that seems to be missing in this test class?
These should be inline - not required for testing
Not worth debugging for this QS
Not worth debugging for this QS
Not worth debugging for this QS
Use class-level constant.
I don't like that we must first call "getSelectedFile" and then additionaly "confirmFileSave". Could we have a method that merges the logic of the two above? It could be named "getFileWithConfirmation".
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
This line of code, view.getOverlay().add(this); is repeated in every single HighlightDrawable. For symmetry with ViewHighlightOverlaysJellybeanMR2.removeHighlight(), why not just put this into the ViewHighlightOverlaysJellybeanMR2.highlightView() method?
This doesn't seem right to me. What if this view is in a context where its parent doesn't have MarginLayoutParams? It is still highlightable, no, just perhaps not with this new margin highlighting?
@Nullable but actually, why allow null here?
Better to replace -1234 with MultitenantConstants.SUPER_TENANT_ID
you should remove the listener from the registry too
Can you call initialize on all of the engine's dependencies here instead of just the metrics one? It'd be nice to have that option for everything.
do you need to add CRC here?
return new StringBuilder().append()....toString();
return new StringBuilder().append()....toString();
Spaces after commas
Might be safer to do File derivative = Paths.get(derivativeBasePath, binarySubPath + ".txt").toFile(); in case of stray slashes.
Fedora uses 4 levels of hashed containers for identifiers, does it just use 3 for file storage?
else { is redundant
Really tiny thing, but I prefer that we log more descriptive error messages. For example, this could be something like: log.error("Error filtering metadata based on permissions", e);
Why do you need to return the metadata? You are updating the own object, it should be part of the method getMetadata if you want to obtain this data after an update on it.
This (And other filters) need their type as well. The reason being we could have a TagValueRegexp with a filter like .* and a FieldRegexp filter with the same filter and want them to hash to something different. For this and other regex filters, you can omit the pattern from equals and hash as those are just compiled versions of the filter field. It's ok not to use the parsed version even if someone puts a space in front or back.
ArrayList<>();
this can be done simpler using a sorted stream of param entries to produce output string
assertThat(list).containsExactlyInAnyOrder(item1, item2, item3...) can simplify this
nit: Nesting builders like this can hamper readability. I generally prefer to build anything that isn't a single line (or sometimes two) prior to building the request.
Could you also test what happens when the data isn't Base64-url-safe-encoded, with labels, collision with an existing secret, etc?
Shouldn't the setup happen from the loader? Seems like an anti-pattern to trigger this from the sync adapter.
This if condition should actually be in authorizationManager.checkCanSyncSolr(studyStr, userId).
Won't this throw an IndexOutOfBoundsException if the previous check above was true?
You don't need it in every Exception since you have a finally clause that will get executed at the end.
you don't need to rename anything
Why Arrays.asList()?
Can you factor out psInfoFactory.get(db, pId).getAuthor() into a variable? I think it would be better than to have it in 3 places now.
Can't you get the name of the author like this: psInfoFactory.get(db, pId).getAuthor().getEmail() ?
authoId -> authorId
This should be a triggered ability of the enchantment, not a trigger gained by the creature
This needs to be a sorcery
This needs to be "up to" one target creature or planeswalker, so you need to set the minimum to 0.
Can be shorter: Collections.singletonList(mock(DataType.class));
You have insertAfter(..) and insertBefore(..) on DataTypeList and its View however use insert(Field)Above(..) and insert(Field)Below(..) here.. would a consistent term be better?
Could we please use non empty expectedDataTypes? Test in the current form will pass even if we change this line to when(dataTypeUtils.defaultDataTypes()).thenReturn(new ArrayList<>());
possible NPE?
Please use 4 space indentation suggestion NTCredentials ntCreds = new NTCredentials(proxyCredentials[0], proxyCredentials[1], null, null);
Code formatting issues.
Use new lines.
Use new lines.
Possible deadlock cause.
this is not vdsm, should be another configuration or setting within database, but we kill this code anyway, so not that important.
Might want to also support the square bracket syntax?
Not sure how just the host, especially if extracted from a URL object, could have a trailing slash.
There is a singleton for OK Status: Status.OK_STATUS
The boolean is not detailed enough (It doesn't explain why the profile is not valid. File does not exist? File is not a Profile? Profile is not defined?) The usual pattern for this is to return IStatus instead of boolean. The IStatus can contain a status code (OK / Warning / Error), as well as a message and an optional Java Exception. The UI can then print proper messages depending on the exact status
Unnecessary?
Does this logic also need to be replicated in AvroParquetFileReader?
Setting this behavior should be done in your MsAccessSchemaReader class. After all you want to customize the behavior of the class, not make it adaptable by the user.
This looks like code duplication. Can you please factor that out of if statement? For instance: 1. determine schema name 2. return candidate
@aertoria Can you change all the variable names in test method to not have _1
Once you move to using the metrics prefix, you'll need to modify this. Plus you should use a regex for matching: <metrics prefix> + MetricsAware.KEY_REGEX + <metrics name>
This function can be inlined.
Please use Collections.singletonMap here.
NIT: move these to separate lines?
This should be handled by the setupOkbuck Task. root okbuck task description should be more like "okbuck task for the root project"
Same question about maintaining type information.
directly return "" is better
Can you mock this? <LINK_0> . It is a little overkill to load the whole context for a test.
try {
These two calls to parser.next() are strange... can you explain that a bit ?
what is this close and open curly brace doing?
Better return 0 ?
Nit: Worth log for which peer the given source reader is sleeping?
Can the increment value be zero? In this case we will fall into infinite loop. I think we need to prevent this by adding some kind of check on increment value and maybe throw an ChromeCastException when increment value is zero.
I don't think it's a good idea to make a special case for this. We can POST the options in the body for all changes requests
@kcooney, is this how you were hoping to add descriptions, or would you rather Noel hold off and let you add descriptions when this is done?
BigtableFilter should probably have a com.google.cloud.bigtable.data.v2.models.Filters.Filter member variable. That would likely mean deprecating the current constructor that uses com.google.cloud.bigtable.data.v2.wrappers.Filters.Filter, and use a com.google.cloud.bigtable.data.v2.models.Filters.Filter in a new constructor. Also, please add a BigtableFilter.getFilter() which returns the models.Filters.Filter and use that getter here.
optional: this can be outside the try{} block
you need to * actually verify the data * assert that the source file is stil there
same here, I am not sure why we are closing a file channel under a write lock. so the question is what does lock is actually locking.
We might want to consider logging something into the log so it's trackable. Wdyt?
I'd rename the peState to something better :-)
Shouldn't this null check come after the getPostByLocalPostId() call below?
style nit: missing braces, since a while we use braces around single line blocks, change this only for new or modified code
* fail earlier by moving this check to DfsBlockCacheConfig.setBlockSize() ? * I think we should also prevent blockSize == 0
// We want to override the concurrencylevel only
Class<?>
Why not to use the constant: Charsets.UTF_8 as on the line 111 above.
Shouldn't we be "save" and test if configurationObject.get("properties") returns null?
We are calling close even though it doesn't do anything just to avoid warnings? Where are the warnings coming from?
Why not just use " " + System.lineSeparator() ?
nit: for all of these, can you do assertEquals(addresses.getStatusCode(), 200); to avoid [yoda conditions](<LINK_0>
This doesn't ensure the file was flushed. Which means it may be stuck in a buffer and isn't shared with the other open file handle created by the Compiler. It also might not work on Windows, where files cannot be open for both writing and reading at the same time. You need to ensure the file is written and closed before you call the Prolog Compiler.
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
any reason for this change?
Need to have Assert.hasText for taskName.
Internal class should go after the methods.
This is broken and less readable now. And it loads cubes. It should NEVER load cubes. First: it doesn't tick entities when they are outside of world border - once you fall out of the world you are stuck there forever. Second - leave the 32 block thing. Entities can access nearby blocks, sometimes a lot of them like the ender dragon. They need some buffer radius.
Exception#printStackTrace goes to stderr by default.
Same as before, you can bump this up to "1.8".
Have we confirmed that the Apache HTTP client will return -1 when the content length is not set?
@vilchik-elena Why not use the expression stack?
No special need for final and please use interface. No need to know implementation. I would even recommend to use ImmutableSet from guava for safety.
I'm not entirely sure how the uniqueness constraint for Points was implemented, but does this mean that we will disregard points which are unique but happens to have the same 1D-value as an existing point? For me that sounds like an important case to test.
This is wrong map, one from change info and not one from revision info, that you need. The right one would be the code that you have removed: RevisionInfo revInfo = info.revision(revision); if (revInfo.draft()) { NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo> create(); }
Let's create a new ArrayList and copy the attachments. If the "client" needs to alter what is in the attachments, that would be logic they would need to implement. A clone should be a full copy.
These are UI widgets and should be passed through init() not set(). Passing during init() matches the pattern used by Labels.init() from ChangeScreen2 to gain access to additional UiFields outside of itself that its set() controls.
long nextBackOffMillis = backoff.nextBackOffMillis();
Just createBackoff()? You are not doing further modification.
logger.warn("stopping container - restart recovery attempts exhausted")
Why are these changes required? I think that keeping it at just Segment should be fine (and more correct, 'cause it's totally possible that someone chooses to implement Segment without using AbstractSegment).
if we enter this loop, then its reasonable to assume that we have just one segment file right? Just to avoid confusion, can we make it two code blocks. One, to deal with one log segment of old type and 2nd code block for the new type. Just a suggestion. Something like this  java if(segmentFiles.length == 1 && (LogSegmentNameHelper.nameFromFilename(segmentFiles[0].getName()).isEmpty())){ LogSegment segment = new LogSegment(LogSegmentNameHelper.nameFromFilename(segmentFiles[0].getName()), segmentFiles[0], totalCapacity, metrics, false); segmentsByName.put(segment.getName(), segment); totalSegments = 1; } else{ for (File segmentFile : segmentFiles) { String name = LogSegmentNameHelper.nameFromFilename(segmentFile.getName()); LogSegment segment = new LogSegment(name, segmentFile, metrics); totalSegments = totalSegments == -1 ? totalCapacity / segment.getCapacityInBytes() : totalSegments; segmentsByName.put(segment.getName(), segment); } } remainingUnallocatedSegments = totalSegments - segmentsByName.size();
This is too much synchronization - it makes parallel segment loading impossible.
Can use validatePrimaryLanguage here and below.
remove empty line
suggestion .parse(StringUtils.isBlank(metadataLanguage) ? metadataLanguage : "en");
If you change this to be a VariableReferenceExpression builder it will save me a few lines of code when I get to this part for symbol to variable refactoring, lol.
No need for this logic - Guava does it anyway. Just call copyOf. This method will then reduce to a single stream operation.
Why add this here?
These 14 or so lines - the various superclass fields - are already set via super(builder) and should be removed here. <LINK_0>
Do you want to rename the fields, too?
private, should only be called from the builder.
can be removed now
Why don't we store the build folder as a full path, so we don't have to relativize again and again? We need to keep in mind that this is called for every folder that is ever added/removed/changed.
Nit: coding style, add spaces around keywords
using the payload as the assert failure message might be confusing without more context
just hit heath check manually and put exact string, assert must match exact string, all these new String and then trim are really redundant.
doesn't seem right, should be something like "{\"foo\":0,\"additionalPropertyExampleKey\":\"string\"}"
super.init() method never throw an exception.
assuming this was for debugging, should remove.
This is somewhat confusing to read - why does setup() call something named validate(), instead of setting up the cluster? One has to go to inside validate() to figure out what is going. Perhaps it can be named setupClusterAndValidate(), or something more readable?
empty hashmap.
Instead of defining this same block twice, do the logic check on opaqueUser above and save the user principal (or null) in a local variable.
empty hashmap.
Instead of creating a couple of extra Timestamp objects, move this as the first line in your if statement and just return true, like this:  if(divBy > 1) { return true; // As in this case, we've already got the correct value in ptr }  Also, another good optimization would be to check the last four bytes being non zero without creating a Timestamp object. You could do this like this:  int nanos = PDataType.INTEGER.getCodec().decodeInt(ptr.getBuffer(), ptr.getOffset()+PDataType.LONG.getMaxLength());
Subtle difference for the ptr.getLength() == 0 case. Return true in this case as an indication that the expression was able to be evaluated, but the answer was null (as opposed to returning false which means that you weren't able to evaluate the result because you don't have enough information). Often both cases end up evaluating to null, but during filter evaluation on the server side, where we're operating on partial data, it'll cause the expression not to continue to be evaluated as we see more key/values for a row.
Can you change the rhs to be array. This will be consistent with how you implemented ?| and ?&
One concern that I have is whether this method is only used for the determining the next billing period start date. I want to make sure it does not inadvertently affect offer parts of the application.
This the objects have to be rehashed this can be expensive ~5-10x For a map of 1 million entries it: 1 million iter 0 [guava] elapsed(ms) : 463 [ImmuableListSetWrapper] elapsed(ms) : 61 iter 1 [guava] elapsed(ms) : 402 [ImmuableListSetWrapper] elapsed(ms) : 63 iter 2 [guava] elapsed(ms) : 388 [ImmuableListSetWrapper] elapsed(ms) : 52 iter 3 [guava] elapsed(ms) : 394 [ImmuableListSetWrapper] elapsed(ms) : 54 For a map of 500 thousand entries: iter 0 [guava] elapsed(ms) : 233 [ImmuableListSetWrapper] elapsed(ms) : 33 iter 1 [guava] elapsed(ms) : 184 [ImmuableListSetWrapper] elapsed(ms) : 38 iter 2 [guava] elapsed(ms) : 197 [ImmuableListSetWrapper] elapsed(ms) : 31 In this experiment, the map uses a UUID for both key and value, but for complex types, this can be much more expensive. This is excluding equality checks on collisions, which only adds to the bottom line.
I think you could use MorePredicates.transformingPredicate(TermporalField.toValueFunction(), IS_PRIMARY_IMAGE) here.
This null check should in fact be avoided. The only case where a method symbol from a method tree can be null is when semantic is not available. In the ruling that happens for package java.lang of JDK. If it is not available, then it makes actually no sense to run this check so, in fact at the beginning of the visitNode you can have a :  if(!hasSemantic()) { return; }  You can test this by using JavaCheckVerifier.verifyNoIssueWithoutSemantic (which you already use).
Type param can be removed.
![MAJOR](<LINK_1> Merge this if statement with the enclosing one. [![rule](<LINK_2>](<LINK_0>
I don't like here that you include parameters that had to be omitted. If something will change this could be a cause of a problem.
Should look into having a ConnectionStringParser class in Azure Core, I've been seeing this functionality in a lot of places.
@Override
If you see opportunity it would be great if you could refactor the methods with many parameters.
duplicate call to getStatus()
Can you add this
Nit: wouldn't it be safer to check that it's not equal to "https"? No other protocol would/should work, so maybe it really doesn't matter in the grand scope of things but it fits the error message better.
nit: missing spaces before and after +.
we'll need to plumb this change in custom Token Credential Auth policies too where a cache is being maintained. We can open an issue, for now, to track this work and get that change added to Track 2 SDKs when Identity is about to GA.
Suspicious null here. Instead of getType(null), why not just Type.STRING?
Bodies of most test methods are very similar. Extract common logic to avoid code duplication.
"this" is redundant here
Ah, and CheckStyle allows it? Rewrite to the long but more readable form:  java if (result.IsEmpty) { return emptyList; } return callDao();
What's about renaming purchasesAndSalesList to purchasesAndSales?
@NonNull or Objects.requireNotNull?
nit: The mocked environment creates 3 nodes (by default) that you can use so you don't have to create them. You can get them with env.getCluster().nodeById(..).
we can use TestUtils.assertFutureThrows() here too
This constructor is a little weird right? You have a addRemoteReplica() - why do you need to send one remoteReplicaInfo here?
If you're at it you can change it to: return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
Please replace with getStoragePoolDAO() which exists at AuditLoggableBase.
You're removing here the call to checkStorageDomain(), which is fine because if getStorageDomain() returns null, a NullPointerException is thrown when initializing storageDomainToPoolRelationValidator. So no harm is caused by removing it, but wouldn't it be better if we moved it to the beginning of the method? Something like: if (!checkStorageDomain()){ return false; }
Isn't this the number of mappers? Can the reducer get it instead and compare with it?
I've added a check for null, in case some extender has replaced our MIStack service and does not yet implement IGDBStack
if it's mildly unexpected but fine to continue without, should be Timber.w I think. Unimportant in the grand scheme, but just want to either have a good debate on or harmonize on log levels. I consider 'e' to be things where you need to bomb out of an activity entirely, almost completely unrecoverable but not quite a crash.
Minor: Maybe extract local variable with the size. Will be more understandable.
Shall we just warn the user instead of throw exception for this case? Also change line 120 to be: double effectiveRate = (double) e.getValue() / numTasks;
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
"e" is an exception. Per definition. :)
to STDERR
add prefix to "About to invoke" message too
Missing null check on sampleClass
This check should be in the Service alongside alias validation
No need for these fetches - DTO conversion copies the IDs over and Service fetches all of these during save already
Null check required?
TABs
I may just be missing it but is there a test to validate the setting of the identityProviderId via the get identityProviderId() method. A check on that seems to be missing in this test class?
Same observation as WCS and WFS tests
no need to check for testName != null. I think it can't be null and if it is, the getTestResources(testName) will throw a NPE when accessing the map.
When replacing a single char it is better to use public String replace(char oldChar, char newChar)
isEmpty
Delete the second point
you could test that isMigrationNeeded returns false
This error message is not very useful. How about "no matching files for folder with regex: " + regex.
Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files
I think you just use an AsyncTask and imperative code in the doInBackground. It'll be like 7 lines instead of 20
I think lowercase l should also be considered
I would recommend an else if here to avoid comparing against a string unnecessarily.
I'd like to avoid calling get() multiple times since it may be costly to compute the array.
Modern Java does not need StringBuilder any more. Simply use += to build a regular string, this is fast. It may even be possible to use StringUtils on an array of longs, but I'm not sure about this.
I would prefer "refresh" and "filtered" without the ?
Newline at the beginning of the string? For readability?
Should this use a try { } finally? Otherwise other Throwables leak.
Should we wrap this if-condition block inside <code> if ( ! noMediaFile.exists() ) </code>
Minor: please move private utility methods to bottom.
This should be EntityNotFoundException#byName instead of EntityNotFoundException#byId
why did we change this. SchemaResource should be unrelated to MLRegistry. We require having topicName + ":v" for schema registry to work with
@priyank5485 Why are we assuming the schema is already registered? This can return null if it is not registered yet.
Is this better than Assert.assertEquals?
Perhaps create a named constant for the interval since it's in the asserts for several of the new tests
why? let's format it properly, it was ok before. annotations and method definitions on different lines
Lets use APILifeCycleAction.PUBLISHED.getAction()
Shall we use the constant - APILifeCycleState.PROTOTYPED.getState() here?
shouldn't the message be "API has been published using a CREATOR role" something?
This looks like different logic. You only have one serial read. putChar also writes two bytes into the buffer. This seems weird in the first place. We could maybe jut write:  return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).put( new byte[]{serial.read(), serial.read()}).getShort(0);
Do we need this instance whenever the method is called? Can't we reuse it?
same here, we might want to move some of the common memcached / redis cache code to druid-processing and reuse it.
setGameState( BOT_VS_PLAYER ). make final int
This condition is not needed; NSU and Const.POINTS_NOT_SURE are one and the same thing so the else clause suffices. In fact from the previous code you can simply change points == Const.POINTS_NOT_SUBMITTED || points == Const.POINTS_NOT_SURE to points == Const.POINTS_NOT_SUBMITTED and it would have worked as expected.
Looks like even the brackets around i == j is not useful?
maybe mention the field type?
You can declare this in the scope of the if, when it is being used
switch/case here too It's not just for the sake of it ;) But for example, if we ever add new types of ITmfStateValues (which we've done before), we would then get warnings here asking us to handle them, which is exactly what we want.
Collection<?> cpuCol = (Collection<?>) cpus; return cpuCol.stream().filter(c -> c instanceof Integer).map(c -> (Integer) c).collect(Collectors.toSet());
if (!selectedItemList.isEmpty()) { selectedItems = selectedItemList.stream().filter(o -> o instanceof Integer || o instanceof Long).map(o -> (Long) o).collect(Collectors.toList()); if (selectedItems.isEmpty()) { return null; } }
should return true b/c you handled the click
Why the extra parenthesis? It's a single parameter lambda.
I think the granularity should be 1 seconds instead of 5 seconds here.
Possible NullPointerException if maxWaitTime is null
Not sure but I think this would only happen if there is an error in the business logic on the client side when processing the closure, even if the request itself succeeded. So this might not warrant marking the span as error.
Should this one be turned into Throwable as well?
Is this one missing Call.propagateIfFatal(e);
These should be inline - not required for testing
Using this magic string here with the concatenation is a bit brittle. It would be nice if we had a centralized place where the prefix lived, ideally with three methods like: 1. createSourceElapsedPropKey(String): String 2. isSourceElapsedPropKey(String): Boolean 3. getSourceFromKey(String): String The first would only be needed here; the latter two would be used in SourceMetricsImpl.
quasiIdColumns and infoTypeNames  should be inlined
If you are in Java 8, it is nicer to use .then.
Unnecessary; you can just pass a name argument to createProject.
For fix tests on Jenkins you need to create project directory, like here PerformanceTestBuildTest#testFlow#L38
Is the intent here to make tracing table transactional? What would happen to the existing tracing table i.e. on a cluster with existing phoenix deployment with tracing enabled? You will likely need some kind of upgrade path to update the metadata of existing tracing table to mark it as transactional.
Hardcoded "Folder:", are you sure? Also check [this](<LINK_0> out.
Maybe a wider exception would be better idea here if anything rather than sql exception happens. Since we don't deal with the exception itself.
Test for last four digits as well?
Can we also have test for /v2/api/accounts/{accountId}/charges ?
And this one
If we keep this approach, encoding should be a module option
What is 1? Perhaps have a static var describing what this signifies?
Map
Let's use request body rather than request params for this. You can use getAndValidateRequestBody method with List<String> or String[] as the type.
Similarly here; use request body.
Unnecessary line move
please rename to performOpenMoreOptions
Please click on the drawing surface. What purpose does the click have? If it's supposed to stamp the picture, use onDrawingSurfaceView().perform(touchAt(DrawingSurfaceLocationProvider.TOOL_POSITION));.
this "closeSoftKeyboard()" is not doing anything, because you are using the wrong import. you are using android.support.test.espresso.action.ViewActions.closeSoftKeyboard, which is a ViewAction, so it has to be done in a perform. if you just state it outside, you create a new ViewAction object and not doing anything with it. the correct one for this would be: android.support.test.espresso.Espresso.closeSoftKeyboard, which is a standalone action like "pressBack()". so either: import static android.support.test.espresso.action.ViewActions.closeSoftKeyboard; ... .perform(replaceText(validName), closeSoftKeyboard()); or: import static android.support.test.espresso.Espresso.closeSoftKeyboard; ... closeSoftKeyboard();
you can use tasksByPriority.entrySet() here
suggestion if (attribute.isMappedBy()) {
We need more tests. What happens here is what I've written about in email - if order by has non-literal columns, advice must be empty. We must not give selective advice to the sub=query
should rather be named currentContextClassloader
Can created URL class loaders be cached, it should not be necessary to create a new class loader each time loadDependencies() is called.
This seems a strange place for this. Shouldn't the string reference be resolved inside the resource loader?
Should maybe be "SocketException has occurred"
This should be outside the try. lock.lock() are always put just before the try
also debug
any reason to not do this in the constructor? Is it null in the normal flow?
shouldn't the state be set in the MockReplicaId here? Same as the helix version, this needs to check if ReplicaId is an instance of MockReplicaId, cast and set I think
all services are closeable, so use IOUtil.cleanupWithLogger() & let it handle null checks and exceptions
It should be openDeleteConnection, shouldn't it?
try (final CloseableHttpClient httpClient = HttpClients.createDefault()){... if we are fixing this lets fix it properly...
I'e tried with this url and it didn't worked: <LINK_3> this url was OK: <LINK_0> but it required 5 and 4 http requests to get the final answer each time. I think we should start search from the begin of the path and not from the end to avoid spamming on server and delays on client side. I also would propose that we should recognize http*://git.eclipse.org/* urls and only try <LINK_2> in this case: Eclipse web master and also end users will be really happy to need only one single shot to get the result. Additionally as the example above shows the automatic Gerrit config for git.eclipse.org/gitroot/ URL's doesn't work at all.
This catches too many exceptions. 1. I think exceptions from formatPath should be a fatal error. Users should notice that path includes an invalid syntax. 2. If listS3FilesByPrefix throws an exception, it's also fatal. Otherwise the result will be invalid.
How about prefixing this with "tasks" like the other logging routines here?
toString usually is a "human readable" version of an object. Could you make a separate method on StartpointKey which generates the key for the store? Then someone won't accidentally change toString. Also, it will allow toString to be more verbose while keeping the store key concise.
why new a map here, is it OK to do like this?  final Map<String, Object> aggMap = toJson(node.getAggregation()); aggMap.put("class", node.getAggregation().getClass().getName());  And you only need to add class info for UDAF, for system aggregate function, you do not need to add class info in the map.
Nit: Map on the LHS. It doesn't matter a huge amount, but I'm curious why you've used ImmutableMap elsewhere and not here.
this should be able to reused. it can be a static field
Just realized that in SQL, we directly exposed the system.stream format of names to the user. This is slightly different from the Java fluent API where we are changing to use logic streamId to uniquely identify a source in the program. Let's discuss to settle this one.
Would be nice to provide actual serdes as params since these are meant as examples (however undiscoverable).
Consider having constructors delegate to each other. For example, this line is repeated in all of your constructors.
Add the command that is being executed to the log
Do we need two debug logs here?
catch throwable in activate method
I think everything from Optional<Status> statusMaybe =   could be replaced by: java return statusMap .flatMap(StatusMap::getToStatus) .map(status -> { if (status instanceof ChargeStatus) { return new MappedChargeStatus((ChargeStatus) status); } if (status instanceof RefundStatus) { return new MappedRefundStatus((RefundStatus) status); } return new UnknownStatus(); }) .orElseGet(IgnoredStatus::new);
Unsure about adding this method to the this class just for the purpose of backfilling, I wonder if it could be moved to some utility of the history event emitter?
Would a switch be cleaner here?
This needs to be new Request(Request.Type.OPEN) now.
We generate the token, but we don't actually store it anywhere. So when the user goes to verify their phone, they will always get the "token invalid" error. Also, VerificationData currently doesn't distinguish between phone and email. This allows users to receive the token on their email, and then use it to verify their phone,
Should we also have the same tests for the email template?
suggestion server.getFileStreams().forEach(UncheckedFiles::closeInputStream);
If you go the stream route we can remove this variable
new ArrayList<>() ?
do you think debug is enough to report this problem? I would use warn.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
For consistency, I suggest to write this forEach in the same way as loop above.
Needs to be in an else-clause, otherwise you'll count twice (newChild() and worked()) and thus reach 100% before the last path.
No need for else here.
Second parameter of Status is the pluginId. Why to pass path here?
you can use Schema's isNullable and getNonNullable methods to help out here.
Type for Field + config.field + must be String
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
As the inspection says, what is this variable for? Why not just use packetIn
I think this needs to take the fecPacket offset into account
The check above doesn't include the fixed header length
Do either of these two 1. Add address.equals(InetAddress.getLocalHost()) to the check as a local inet address may still not match the two specified conditions above. 2. Create an unresolved InetSocketAddress in getRMWebAddress with canonical hostname and check for null InetAddress here
ArrayList should be constructed with fixed capacity.
Here the check should be improved that the exception is only thrown if id **and** key are null
if it existed in containers, is it not sufficient?
change to package
rename to root
NaN if outputRowCount is 0
nit: there are other places where we for symbol %s, without :
empty?
We should either do a info log to inform users that we are still waiting for the operation to complete or we should timeout at some point.
why do you need retries on stop but not start?
Why change this? Also it is strange that i can see from CI log the ROS docker has been started/stopped correctly:  + docker logs ros info: Integration test server listening on: 127.0.0.1:8888 info: Starting sync server in /tmp/ros117014-6-g5ntk9 info: info: stdout: 2017-01-14T07:37:58.674Z - [32minfo[39m: Logging to file /tmp/realm-sync.log at level 'all'. info: Sync server stopped info: child process exited with code 0 info: Sync server stopped  But the CI still failed because of waitAuthServerReady return false.
nit: better to add ledgerId into the log statement, so it is easier for troubleshooting.
This seems not used
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
Please use new File(basePath, ".gitignore") Instead of string concat with the platform specific "/" character.
Bad smell here; should be .getPath().
this seems like it's going to be incredibly verbose. Can we nix tihs?
since we use instance variables for most part to construct BlobId, may be you can introduce a privateMethod which takes in non-instance variables and version to construct BlobId is the specified version
extra line
I am not 100% convinced if this would be a trace info. We probably won't need this information to debug the internal work flow, but whenever this information is needed, there should be some error (or complaint from users). So from logging perspective, it more looks like an error.
Should we consider the value of "length", it should be > 0, and for Oracle [<= 4000](<LINK_0>
How did you come up with the particular numbers? (I ask because no 2 people seem to recommend the same thing)
better: startsWith
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Independent of whether we use 0 or -1 as default position, we must validate the messageWithPosition.getDesiredCaretPosition() here. What if it is -300?? Or the message has 100 characters, but the position is 3000? ICommitMessageProviders are untrusted code; they may or may not return sensible things. EGit must not fail or wreck havoc when there is a misbehaving ICommitMessageProvider.
Why this underscore?
Convert Unspecified to constant. And there's probably a framework constant for this string somewhere.
There is a genuine risk that multiple sources will try to set the lookup at the same time ? Just wondering since now this will synchronize ALL access to storing attributes to the vaadin servlet context, not just the lookup. Just wondering if synchronization access go through another API, but then again also the getAttribute is already synchronized. So probably this is fine and I'm just thinking out loud.
Same here: return Utils.copyAttribute.....
why couldn't we return results before the analysis is completed?
space
what do you do with this response?
Why is this here with such a wide exception type?
What does the above line mean?
what if my value is " " ? should use trim
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
type.toString() isn't a null-safe call, while sb.append(Object arg) is doing 'String.valueOf(arg), so it has a null-safe Object-to-String conversion. So we just shouldn't call toString() here.
If Lars would see it, he would cry. How could you even think about using StringBuffer in 21 century? (I know, copy/paste).
This feels weird to me - why are we manually setting the height like this?
use description only, remove " - "
Same for the above 3 text strings.
Why bcast when it can be sent to Admins only? Ops could use it to spam.
Is there a reason for not using the MoreObjects.ToStringHelper instead?
minor: could you add disabledReplicas as well?
why is this necessary? Isn't better to fieldCache.put below here?
maybe this should no longer be named pliList
Consider to use an ImmutableList here
You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized.
This null check is something we can get rid of, I believe.
' ' should be enough, no need for a String object
Can you add a way to signal this runnable to finish?
Do we really want to sleep for 1 sec? Also, with a constant sleep time it is possible that one thread gets starved of locks, if other threads keep jumping in. Might be worth sleeping for a random amount of time, say between 50 and 300 ms. Also, you're not converting time to ns here.
Nano time is prone for overflows. Millis should be fine.
Shouldn't the exception bubble up in these cases? Fail fast fail hard!
why not using addAll?
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Shouldn't this be getKeyStorePath()? And that should mean that if keystore is used as truststore then getTrustStorePassword() need the same logic
move it to be aside of deleteFolder
Any reason for doing this?
how did the previous version work? Use FileUtils.mkdirs
The check is not necessary, File.mkdirs doesn't attempt to create the directory when one already exists.
"protected void processFiltered(File file, FileText fileText)" is a signature that all Checks have. So it is still possible to call file.getParentFile(); and got NPE. So this is not a fix for a problem in general, it is just custom fix for custom Check. If that is not a fix , why we change api ? It is a problem of certain collection + nuance with file.getParentFile. Check need to handle it himself as it did before 8.2.
As said in previous review: Add here a condition on isSequenceElement, the below code is unnecessary if isSequenceElement == false
Suggest renaming some methods: suggestion if (isMultiValue(value)) { return convertMultiValue(value); } else if (isMap(value)) { return convertMap(value); } else if (isRecord(value)) { return convertRecord(value); } else { return convertSingleValue(value); }
can use org.apache.commons.lang3.StringUtils.isNotEmpty(value.textValue()) ??
maybe change "== -1" to "< 0"
This should be >= UnitType.SIZE
Yes. Without it, the retry may land on MAX_VALUE - 1 on restart and not take the fast-path in certain sources.
Is this System.out required?
Path and File.toPath[] aren't available in Java 5
Do something with the exception. At least log at error level.
static import?
I think here we could actually return the new KillableCompletableFuture. Otherwise the call-site has to know that this might implement Killable, that is not very common. By changing the interface to return CompletionStage I was referring to loadNextBatch, but that could probably be a dedicated PR, as it isn't involved here at all.
why?
We better not have the supported/unsupported versions hard coded here. Please check whether discard is supported using the FeatureSupported class.
you can remove the redundant brackets
1) /s/executing/Executing 2) I think it will be better to add this log in the buildStoragePoolDomainsMap method so it can be also used for reconstruct and we can get more information about other storage domains statuses.
just for consistency, can we use final int?
Now that you're encoding the ID are you missing decoding it somewhere? I don't see it anywhere
NoSuchElementException is more accurate
Just a FYI - I've only recently learned (credits go to @nbradbury ) that by setting the callback to null here in the setNegativeButton method call will lead to the same effect (closes the Dialog), probably adding some clarity to the code as well
Minor nit, feel free to ignore: I prefer setCancelable(true) so you can hit the back button to leave the dialog.
This isn't quite right. The version number is supposed to be interpolated into the text. That said....due to refactorings of the text it looks like there's no longer a placeholder for it in the EULA text. That's not the end of the world, but we could just remove the String.format and getVersionName altogether.
Could you use just one RevWalk instance for all selected commits?
Since it now is a closeable and java 7; I think we should use the "try with resource" form instead.
This should behave the same as getSelectedCommit when multiple commits are selected
it's better to use registerAndRefresh() because registration can be done async in monitoring server depending on when voltron is calling us.
return Long.compare(sizeInButes, other.sizeInBytes);
same here, make sure we have room to fit the new element
should not error if docker doesn't exist?
It's kind of unconventional to instantiate impl's instead of factories, but I'm not strongly opposed to it.
Should the log level be error instead of warn?
id is the unique element in a HTML page. Therefore, there is not need to have a chain to locate it. Check if there are similar case in your PR.
Follow the more general approach of getCellValueFromDataTable (include a table index instead of hardcoding 0).
Could be renamed newFreestyleJobWithStandardMavenStep because I first though it was with Maven publisher
Adding an immediate return after appending in the isEmpty case would get rid of the else:  if (validationResults.isEmpty()) { validationResultSummary.append("Invalid - ").append(NO_PACKAGE_IMPORTS_FOUND).append("\n"); return validationResultSummary; } for (ValidationResult result : validationResults) validationResultSummary.append(result).append("\n"); return validationResultSummary;
what if we determine the non-matching character with e.g end() and give it back in the validation result? The methods start() and end() will give the indexes into the text where the found match starts and ends. Actually end() returns the index of the character just after the end of the matching section.
Debug still needed?
Neither here, nor in the interface, does it say as to how much data is read into the buffer. Let us be clear: unlike other similar apis, it is not "read as much or till EOF", but "read exactly buffer.remaining() or throw".
Should be "!= 0" instead of "> 0"
just remove the fileSize from here... and that's the only change you will need.
Can be moved to if block above
You could use computeIfAbsent: java mavenGroups.computeIfAbsent(groupId, k -> new ArrayList<>()).add(bundle.getId()));
I may just be missing it but is there a test to validate the setting of the identityProviderId via the get identityProviderId() method. A check on that seems to be missing in this test class?
It would be nicer to provide an alternative constructor of ComputeDiffsToMerge without criterion and let this constructor create the default criterion (which is null at the moment). I'm not in favor of the null value as default and would prefer an instance of a default class.
Can this be nested in the last if statement instead of calling isDebugEnabled twice?
After giving it more thought, I really don't thin k the responsibility is well placed here. I think the CompareCopyCommand created should be passed all the context information needed by the merger to perform his job. I know that this probably reprensents a heavier rework but it seems much more healthy in terms of maintainability and robustness. Can you study more in details the impacts of such a decision before we decide what to do?
Yay, so this worked for you I assume?
might it be useful to log the response body as well?
gt 120
Do we want to close the closer when server fails to shutdown?
SpScheduler already does that in SpScheduler.shutdown(), you just need to offer a null task to MpScheduler. MpScheduler owns m_tasks which can be used to offer null task.
NIT suggestion throw new IOException("Failed to await LockPool evictor termination", e);
Exceptions.launderedException instead? This would not wrap RuntimeExceptions one more time.
I know this is lifecycle code and not performance sensitive, by why no do the remove to a local var and check it for null to throw?
Best to avoid logging any passwords, some end users will actually audit log files to ensure no passwords are logged.
We could omit the second Integer.
@NonNull on its own on line above
This is inherently dangerous. sharedList is a CopyOnWriteArrayList which is _safe for iteration_ even while it is modified. However, once you abandon the iterator, it is possible for the sharedList size to decrease while you are in the loop, and sharedList.get(i) will generate an ArrayIndexOutOfBounds exception.
Can we add a log message with the iteration number, size of workload, and computationSpeed before each iteration? This could help authors debug their optimizers. (Since the computationSpeed doesn't change, we could log that once, on initialization if preferred.) Maybe we can even log this once on start and once on exit?
Please move this magic number to a static variable.
Maybe use an uppercase in the text: 'Thread sleep was interrupted'.
same question as before, about the value of heart beat..
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
maybe its better to use the storage-pool competability version instead of some default, i think will be better choice.
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
Minor: this could be a bit simpler if you used a private implementation method and passed in the map container to use. Then toQueryMap could pass in a LinkedHashMap and the normalized version could use a TreeMap.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
This (the whole method) could keep the same indentation char.
Check isDebugEnabled()?
Generally we only add final when really needed.
This is where you should print a stack trace.
We should also find a way to pass through all of the @Parameter variables from the current mojo, since those might not be default if the user had specified them from the command line or from the pom.
Don't we need to copy the kill command array here into cmd?
s/vdsGroupId/clusterId
doesn't really matter but i'd do - Guid vdsGroupId = getParameters().getVdsGroupId(); if empty(vdsGroupId) ... instead of the else
check here also if the groupid that you got is actually exist..
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
Could you change your code so that super.getHandler() is called only once?
I would prefer to see this logic broken up into a couple of lines, it is a bit hard to parse. As well, then you could avoid the need to create the empty set to pass in for the other getProducts(page) call.
We do the same ternary operator above - how about breaking this out into a seperate function.
I know it's trivial, but would be much nicer if this mapping was extracted to a separate function.
I'm afraid this could spam the logs. I made bad experiences with logging when developing the DOIConsumer. Please reduce the log level to debug.
Here too, you could use getTraceSet() and check its contents. That way, you wouldn't need the 'experiment' field at all.
I am not following here - why do we want this in sync block?
These aren't equivalent. The StringUtils version checks for null and "" in one call.
i think ovf can be null (looking at previous code)
maybe add some commas and/or white space in toSTring? e.g. .append("Key-").append(key).append(", ")
Collections.emptyList()?
Add a empty line before this.
mFormatType is not a member variable btw
Copy this value from the previous and ensure the previous' value isn't null
Minor point, but shouldn't we really be testing here that the accession number is not "12345"?
Why do you have to include this test data for reason concept? Is it required for this test?
The protocol file is not allowed when using live streaming. The session creation fails. We have to make sure that this combination is not allowed.
not sure, but just thinking should isContentResponseOnWriteEnabled add here?
why do we make a copy of the user-provided options here?
![MINOR](<LINK_2> 'Severity: MINOR') Add logic to this catch clause or eliminate it and rethrow the exception automatically. [![rule](<LINK_1>](<LINK_0>
I would rather have another internal method that does what's in lines 398 to 400 and back in 406 to 407 but indeed takes the ClientState instead of looking it up - and being racy indeed.
Whether or not this fix is right, you should use the constant FTPReply.TRANSFER_ABORTED, not a magic number.
Consider moving to the Enum, also a bit confused on this - is it an "id" used for wicket communication - or is it human readable (in which case it should be translatable).
Yes, that is correct.
Please put assume as the first line in the test, makes the precondition clearer.
I think that using containsOnly could hide the fact that duplicates are not preserved. Inspecting the variable load.getParticipants() I get this: > 0 = {Programmer@4134} "Programmer{nick='fax4ever'}" 1 = {Programmer@4135} "Programmer{nick='phone4induction'}" 2 = {Programmer@4136} "Programmer{nick='telegraph4eternity'}" I think that duplicates are lost even in a @OneToMany. Aren't they?
This is not naturally readable. What about to rename the project() method to something like hasSameIdAs(). The same naming problem is also in the other matchers.
[optional] you may remove the else to save one level of indention
I am just wondering whether this snippet should not be surrounded by try-catch (as it was previously)
missing .withPort(Hosts.RIAK_PORT)
I'd probably change this to "ovirt-host-check-for-updates"
Is it suppose to use config.m_getOutput as path for target file?
Nit: "Archive license file..." is an imperative, seems like you're telling someone to do something. Maybe "License file archived to..." is a better way to report what has been done. "Archived" seems a little odd to me, it's like you're putting a copy away that we will never use. Do we say "archive" elsewhere? If not, I suggest "copied". Or even "staged", since that's what you say in the error message.
I would add an empty space after the "exist" word to better read the configPath
this should probably fail on receiving interrupt
Log for both catch blocks or neither.
${result} and ${summary} need converted to Java
Use WebUtils instead of casting this yourself.
This is not an error. you can set it to info
Probably don't need package name here
I like the approach; but I'd like the TLS 1.2 and allowed CipherSuites to be only limited to API 24 (higher API levels might want to use TLS 1.3 for example)
We don't want stack trace prints as part of tha code flow. I suggest throw new RuntimeException(e) instead.
If I understand correctly, setting a HostnameVerifier means using a TlsConfiguration. What do you think about extracting TlsConfiguration to a local mutable variable?  java TlsConfiguration tlsConfiguration = configuration.getTlsConfiguration(); if (tlsConfiguration == null && verifier != null) { tlsConfiguration = new TlsConfiguration(); } final SSLConnectionSocketFactory sslConnectionSocketFactory; if (tlsConfiguration == null) { sslConnectionSocketFactory = SSLConnectionSocketFactory.getSocketFactory(); } else { sslConnectionSocketFactory = new DropwizardSSLConnectionSocketFactory(tlsConfiguration, verifier).getSocketFactory(); }
The null will clear the current start time from the db.
We promise the produce json output. Plain string is not valid json.
Also here. If you let the StateVariableValueTooLongException be thrown but add exception mapper you can keep the return type as CreateWorkflowInstanceResponse
Why not pass regionInfo instead of table, then encoded name and replica id?
Thinking out loud: - This method is doing almost everything we need: it creates a CompletableFuture that is completed if the callback is called (send success/failure). - The only missing bit is canceling future after timeout elapses if future.isDone() is false, which can be accomplished with a ScheduledExecutorService. I know this is exactly what CompletableFutureUtils.failAfter() is doing but I think the logic over there is more than what's absolutely necessary; we don't really need the other CompletableFuture failAfter() creates or the additional logic in within(). We can just cancel this same future if it isn't done when timeout elapses. java scheduler.schedule(() -> { if (!future.isDone()) { future.cancel(); } }, _sendTimeout, TimeUnit.MILLISECONDS);  - future.cancel() causes a java.util.concurrent.CancellationException to be thrown, which means we don't have to construct a TimeoutException ourselves because a CancellationException can only mean we cancelled it after the timeout elapsed. This seems like something this method can do with a private executor service. I am not sure we really need a utils class just for this purpose.
This formatting looks off
It does not seem to matter what the disconnect message is, or does it? We probably do not need to assert a specific message.
If the connect call happens on a background thread, does that mean that the updates will also come in a background thread? is there a way for us to make the updates come in the main thread?
Not sure I like this. This starts a new thread where we retrieve the access token. I'd rather we do the token retrieval right at connect time. If we need to spin off a background thread (which it looks like we do) we should do that and complete the connection stuff in a callback to ensure things are done in the proper order.
wouldn't it need to sort the list in this case, too? (I wonder if using a self-sorting list here would not be the better solution.)
Fairly certain that the tankCenterX and Y don't need these constants anymore, since getX() and getY() are returning the center. Placing the bullet should be simpler now, since it's just a slight offset from tank center. I noticed that it's spawning in the wrong spot since we shifted the textures, and this is likely why. I forgot to fix it -- my bad!
I think I prefer "Invalid key" as exception message
Use the pre-existing localized string R.string.multimedia_editor_popup_cloze, and definitely follow up on the "TODO" by using a static constant value instead of a magic number.
I thought all of these were changed to com.ichi2.anki JSON classes to avoid the try/catch since we just throw RuntimException anyway? #5550
Something wrong happened. Shouldn't we log something in order to warn the user ?
Class name is not needed when calling method on same class.
Should use a constant instead of a raw String
shouldn't this be GraphSession.GRAPH_KEYSPACE_KEY?
Why is this not a if condition
validation is only required if error port is connected, the condition can be schema != null && err.isConnected()
if output is not connected, will your parsedRecords will be zero? Same for validRecords. They should be incremented if there is no exception.. Why have two different parsedRecords and validRecords when they are same?
suggestion setValue(relativePos / rectangle.width);
Please, refactor this abreviation. <naming
I wonder whether the upper bounds should rather be: x < this.maxX and y < this.maxY as current this is inconsistent with the int version of this method, yielding for exact integer coordinates false with the int version and true for the float version (for exactly float-representable integers).
can this be a method reference?
Won't this fire an event for every terminal handle after the current one?
Shouldn't that code be in ControlContribution.setVisible()? Client code shouldn't need to bother with that.
For me, It's strange to see that if exception during parsing of jwttoken failed - then authentication should be skipped. Is it supposed that this token will be validated by the next authentication filter?
Use CharacterEncoder.getSafeText()
should the request be closed after return? meaning moving the finally to the outer catch-block?
(minor) You could add an explicit .setPrivate(false).
since we already perform checks on the project there, I'd put this in searchProject for consistency
Can't we use findMissingEntities?
Same as above for toString(): <LINK_0>
String.format
Can we make toString a little smarter and print out what's appropriate for weather or camera?
I think the order of the checks here is relevant to minimize the work. We should check "firstParent" first, then SEEN and then parsing the headers if needed.
I think it makes sense to skip the parseHeaders, too, with the logic being that we haven't traversed into the other parents at all. If it causes trouble, we can make a followup change. :)
1. Should this be continue? If not, if the 2nd parent is not uninteresting but the 3rd parent is, the 3rd parent won't get added. 2. Put braces around single-line "if" statements [1]. [1] <LINK_0>
ugh again ..
The pattern is to have the init before the try: AdminClient client = AdminClient.create(getDefaultAdminProperties()); try { ... } finally { client.close(); // no need to check for null if the factory never returns null } But if AdminClient is AutoCloseable you can just use try-with-resources.
isDebugEnabled
Arrays.fill(filler, '0');
String#getChars probably faster than this loop
We could use a Matcher here and re-use the Pattern. OTOH this would not be thread-safe anymore and we would need synchronization or ThreadLocal. Probably not worth to be changed.
I don't understand why you don't use the sonarUsersGroupId and have simply the query:  "SELECT u.id " + "FROM users u " + "WHERE u.active=? AND NOT EXISTS " + "(SELECT 1 FROM groups_users gu " + "WHERE gu.user_id=u.id and gu.group_id=?)"
IMO "deactivated users" is enough
you could add and p.enabled = true
Why not return getAnnotation(annotationType) != null?
Same deal here: use this version as the base, and have the extended versions just call into it with each arg.
isPresent() is expected to be used here.
Could we add something like: if(System.getProperty(PROP_UUID) != null) { return System.getProperty(PROP_UUID); } Then product creators can disable by setting the property to whatever value they want.
you can put FileInputStream stream = new FileInputStream(fileNamePath); to the try as it is AutoClosable, I guess..
Is this going to cause a problem upon restart? Should we log something higher than debug?
why is the lower bound 0? Should it not be at least 1?
probably best to use getIntInRange() here too to avoid negatives (I think I didn't know that the function existed when I first wrote this).
32 * 1024 * 1024 here as well?
Let's explicitly check whether numBlockOwnershipByEvalIdForWorker contains workerId. Same for storeServerMetrics().
We use synchronized block when accessing *Params map. How about to use simple HashMap instead of Collections.synchronizedMap?
Same applies here; could we move the if statement in [L251](<LINK_0> down here?
Maybe just via backspace? I've never really used the case list search functionality on older devices.
We're no longer calling throwableToFailedResult so we're changing the contract. Before, an IOException would be reported as a failed result; now it's going to be an exceptional future. The details of how this works are being discussed in the API proposal, but in the meantime, can you wrap this callable in a big try/catch like the old code used to be?
I'm confused by those. Those fields (as well as geocodes, error and totalCnt) would have been copied already by the new SearchResult(search) constructor, wouldn't they?
I think this is a bit too early. We support loading from many places other than the internet.
Since mContext is required by so much of the code, it would make sense to throw an IllegalArgumentException exception if a null context is passed.
requireNonNullElse is better
Apache commons is already present; can replace with if (CollectionUtils.isNotEmpty(contentParts))
Creating a local variable for the second argument would improve readability.
Would it make more sense for these error messages to end in periods since there aren't any related messages added after them?
We should not use Optional
Remove braces
I don't think this should be changed since it does not yet support anonymous
Why do you need to do this?
@zcervink lines 60-64 were related to setting settings.xml in preferences, and now this code is useless, so please remove it.
use ShellIsAvailable
This is still needed and should be retained.
it is not the best solution. Try use getDetachedField to retrieve roles object
Where is this being called from in the new code that is requiring a user to be logged in when it's called? Could the place that's calling it just go to the DAO instead of the manager?
Missed it at previous review. Question - why via getVmDao()? and not via VmStaticDao()?
isn't there dupContext() method in CommandBase ?
Should be a single call to removeQuotaFromCache that receives list of quota ids.
Should this test that explicit exception type is thrown not just any old exception. As probably should fail if an unexpectes exception is ever thrown.
The TimeBudget should have been created before the call to ConnectionFactory.connect(), otherwise you are just timing getting the lease, but the budget is supposed to cover the whole connection. Ideally there would be a way of passing the TimeBudget into the ConnectionFactory.connect(), but as it is the first call, it can manage its own TimeBudget.
I don't think we need this since we could just get direct access to the publisherCF delegate in the producers.
I would put the "magic number" into a static var.
@ryandawsonuk here you got it right.. variableTypeMap +1
Do we need to log the exception here? I would expect the calling code to handle it.
extra space
I think this can be simplified to experimentFolder.getFolder(experimentName);
space before catch
Perhaps safer to construct a new List using subList as you otherwise have to make an assumption that Files.readAllLines will always return a concrete List that supports the optional remove operation.
check for null before adding it
nit: the ArrayList size is know in advance, it would be nice to add as constructor parameter to avoid resize
provide style as parameter to above methods
add style as parameter to initLayerIcons
Fixed java @Override public void onMapReady(@NonNull final MapboxMap mapboxMap) { this.mapboxMap = mapboxMap; mapboxMap.setStyle(Style.SATELLITE_STREETS, new Style.OnStyleLoaded() { @Override public void onStyleLoaded(@NonNull Style style) { // Set bounds to Australia mapboxMap.setLatLngBoundsForCameraTarget(AUSTRALIA_BOUNDS); mapboxMap.setMinZoomPreference(2); // Visualise bounds area showBoundsArea(style); showCrosshair(); } }); } private void showBoundsArea(@NonNull Style loadedMapStyle) { GeoJsonSource geoJsonSource = new GeoJsonSource("source-id", FeatureCollection.fromFeatures(new Feature[] { Feature.fromGeometry(Point.fromLngLat(AUSTRALIA_BOUNDS.getNorthWest().getLongitude(), AUSTRALIA_BOUNDS.getNorthWest().getLatitude())), Feature.fromGeometry(Point.fromLngLat(AUSTRALIA_BOUNDS.getNorthEast().getLongitude(), AUSTRALIA_BOUNDS.getNorthWest().getLatitude())), Feature.fromGeometry(Point.fromLngLat(AUSTRALIA_BOUNDS.getSouthEast().getLongitude(), AUSTRALIA_BOUNDS.getNorthWest().getLatitude())), Feature.fromGeometry(Point.fromLngLat(AUSTRALIA_BOUNDS.getSouthWest().getLongitude(), AUSTRALIA_BOUNDS.getNorthWest().getLatitude())) })); loadedMapStyle.addSource(geoJsonSource); FillLayer boundsAreaFillLayer = new FillLayer("layer-id", "source-id"); boundsAreaFillLayer.setProperties( fillColor(Color.RED), fillOpacity(.25f) ); loadedMapStyle.addLayer(boundsAreaFillLayer); }
Can we inline getArguments().providerInfo below? (Trick: use Ctrl + Shift + N)
You could also make FirebaseAuthAnonymousUpgradeException have a constructor that takes AuthCredential since you're just converting the credential to an IdpResponse
What about when this call fails too? Feels like we could get a case where the Resource never gets to a final state.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Extract notification to own method notify...
explain a bit more in the message please
typo: perfrom -> perform
Looks like it will throw NPE if undefined.
Does it make sense to cache the result?
please use templating for logging instead of concatenation - it simplifies reading
We should always do a null check before doing an empty check. Better yet you can use NullChecker.isNotNullish here.
I think !isNullOrEmpty(stream) can be removed
Consider using .vBuild().
Code style
Check code style for building mvc test rules on my latest commit on PR #556
Code style
Does it need to be public is protected not enough ?
Has already said on branch v2 patch set : 2 access to eResource() --> Create a local variable for this
Don't catch Exception or Throwable, that's overkill. If any of that code throws a checked exception, catch that, optionally with RuntimeException too if needed. If you want to catch 2 exceptions, use java 7 style "catch (FooException | BarException e)" Catching Exception is bad because if the code has no checked exceptions, then you could just catch RuntimeException. If it has, you can catch those and optionally RuntimeException (if the latter makes sense and often it does not make sense to catch RuntimeException) Catching Throwable would be even worse, as that catches OutOfMemoryError etc, which need to bubble up the stack.
aren't you confusing the size in chars from the size in bytes? I'm not seeing the right encoding being applied.
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
Could the method getBlockBlobClient(String containerName, String blobName, boolean autoCreateContainer) be used here?
It'd be nice to use a constant for this, e.g., NO_ENCODED_LENGTH?
Remove the catch block for IOException.
You seem to be reusing this code in the other method overload as well. How about moving this logic elsewhere into a separate method to minimize duplicate code?
It seems strange to test for null in this test, since it is testing the happy path. Can you create a FilterStub?
You should call this right before the line you expect to throw the exception, and have no code after that line.
Why did you add 'FORWARD'?
The logic in lines 37-64 is common between C and C++ and should be moved to VariableReadWriteFlags.
Shouldn't this be synchronized?
private static final int FIVE = 5
To me it would be a bit clearer to use append chain here.
retList is not actually used so it will always be empty. Should it be passed into the call to addTabCompletionOptions?
This seems more readable, giving the same result (if I'm not missing something):  for (Entry<String, List<String>> en : pathEntries.entrySet()) {
Why aren't you using 'createNic(..);
Why aren't you using 'createNic(..);
Why aren't you using 'createNic(..);
I think you need to do this and the next line in a finally
Is this System.out required?
No need to create the directory if it doesn't exist. The file.exists() check below ensures that the file will only be deleted if it actually exists.
This should be done through a custom method on ActiveMQServerLogger.LOGGER rather than through the generic warn() method.
The original exception here may not be related to InvalidClientId, seems a bit dangerous to catchall and throw like this. Maybe bubble up or convert the exception, at least link the exception and add the intial cause.
It will be good to avoid converting the node to a JSON and then to a String which is expensive. We should just define a toString if it is not already defined and log(this).
We should not wait for Active here
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Calling values() creates a new List, if you're iterating the objects, simply call using forEach method on the collection.
Style-nit: Parens aren't necessary around the conditional.
Please don't use platform encoding in tests.
ex
you don't need this. the "+" operator does this for you.
fileNameBytes is interpreted according to platform encoding. Give it a StandardCharsets.UTF_8 to pin it down.
In what case can the file exist but be too long? If we are on a system with a longer filename limit, we should just use the existing file and not worry about the length, I think.
I think this can be truststorePasswordAlias instead of the string?
How about using snaeService.wait(500); instead and calling notify(); in the event handler?
Can we have only one try-catch-finally block?
I don't think it's a good idea to swallow an SQLException. If you can't throw it or print entire error trace for some reason, at least get error message from 'e' and append it to warn log.
I believe this can be simplified to java catch (OperatorNotFoundException e) { throw new OperatorNotFoundException(...); }
s/conn.getstorage_type()/connType/
These tests should also check the name and url are showing up correctly in the TaskData.
can be inserted to the if bellow (redundant if build is not captured)
The complete method could be stripped down to:  try { this.buildStatus = StashBuildState.valueOf(buildStatus); } catch (Exception e) { // ignore unknown or null values }
Why adding unneeded braces?
I think the granularity should be 1 seconds instead of 5 seconds here.
How about while (!stateMachine.getCurrentState().equals(STATE_CLOSED))?
Shouldn't this be generalGroup now?
I don't know what to do about it right now, but I would be a lot more comfortable if the Model lifetime was connected to the PsiElement lifetime. In my ideal world, the models are just a veneer over the PSI. That's not to say it's the _right_ way to do it -- just a gut feeling. I worry that local caches in the model can become out of date as the PSI changes (the user types, and/or refactoring). Maybe my concern is unwarranted. Do your concerns match mine?
Listener not Listner (typo)
The selectSQL method is called for normal data extraction, there is already a separate method to handle visitors, the problem is that one of the various wrappers between GeoServer and the datastore is not passing down the visitor and thus breaks the optimization.
":where_clause:" and 14 are sprinkled around, maybe best to add a constant for both?
No need this code
Don't branch on the exception message, let WindowsFileOperations.readSymlinkOrJunction throw the right exception instead.
I think IPath.removeTrailingSeparator should work here. so new Path(path).removeTrailingSeparator().toString(); ?
seems worth throwing an exception if the file isn't found, no?
Not sure this is strictly necessary, @efge?
Context should be in a try-with-ressource statement, such as:  try (var context = new OperationContext(session)) { ... }
Name it folder, or reuse doc maybe? domain is misleading.
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
nit: change to AccessControlException was expected.
Right now you're swallowing all exceptions, which may hide problems that have nothing to do with servers being unavailable. Perhaps check for IOException and UnknownHostException, since createConnection() declares that it can throw them?
optional: this can be outside the try{} block
You should throw an IOException here, because the source directory can't list the content.
Can you add the exception as the second parameter? Otherwise we won't be able to tell where the error happened from just the message.
Log and throw is considered to be anti-pattern: <LINK_0>
Pay attention that most methods of this class return the null as String, but this method returns "null" as String.
could you consolidate unnecessary string concatenation here pls. Much of this can fit on one line.
This will get in an infinite loop if it ever happens :-1: If we want to ignore the interrupt we need to set a boolean and then reset the interrupt flag after we are outside of the while loop.
Come to think of it, this may read a bit better if the lambda were a method reference, e.g. super( delayInMillis, retries, logProvider, this::sleep )
This can be taken out. When the StreamThread goes into the runOnce method and the state is PARTITIONS_ASSIGNED the StreamThread calls taskManager.updateNewAndRestoringTasks(). If the lock is held by another thread still cleaning up this call will return false and the state will not transition to running. In the next iteration of runOnce() the StreamThread will attempt the same operation again since the state has not yet been set to RUNNING
We should remove previous call to setOnPageChangeListener a few lines above as it will be re-set here as well.
Please remove the unused parameter as well
Is there any way to avoid this call on every swipe?
How about using try catch instead of if else?
Use LinkedList instead, as we need to remove its head frequently in endInput.
Good idea to use a stack here instead of a Vector (which would require a size hint). I suggest you use pushAll instead of foldLeft:  java List.<T> empty().pushAll(iterable).iterator();
Can we invert the conditions to be able to use early returns and thus avoid the nesting?
Do we want to create a new object when getConfiguration() methods are called? I am thinking of the use case where user code passes around the ServiceEnv and calls getConfiguration().get() frequently would create too many objects. Shouldn't we create a single ConfigurationImpl object in the ServiceEnvironment constructor?
reverse params order.
log should say store is not initialized.
maybe reverse?  (isFullStatsEnabled() && this.sendCount.getAndIncrement() % this.sampleSize == 0)  Because we always getAndIncrement() independently of full stat enablement. Have I missed anything?
why does this servo listen to itself when it starts up?
not important, but that could be "return Optional.ofNullable(ispnResource).map(IspnResource::getResource)"
Is a service user required here? Doesn't the request require enough security context to be able to derive the Resource type anyhow? Could this simply be:  return resourceTypes.stream().filter(rt -> { if(slingRequest.getResource().isResourceType(rt)) { return true; } else if (slingRequest.getResource().getChild("jcr:content") != null) { return slingRequest.getResource().getChild("jcr:content").isResourceType(rt); } ).anyMatch();
We should handle the case where getDAnalysis() returns null
toString() is not overriden in GridClientClusterState. I think it's better to use here state.state().toString()
I'd suggest to make this configurable as well, but blocking by default anyhow.
hmm can we just use: java executorService = MoreExecutors.listeningDecorator( Executors.newSingleThreadExecutor());  ?
nit: add some line breaks, similar to the original formats. ditto for others.
what was the issue here?
static import
You might want to add 2 more things here: - double check if sock is still not null - make sock = null after the close to prevent further usage of the object and let GC collect it
Nano time is prone for overflows. Millis should be fine.
Maybe could use some logging here? We don't expect any to happen if there's only a single mutation happening at a time, but when there are many, it would probably help with figuring out what's going on.
This should be getModified.
I'd call it referenceChange
The name of the variable contradicts the way it is created. It should be called "unresolvedRefinedDiffs" or sth like that since we keep the diffs that are UNRESOLVED, not those that aren't...
-> could not **read**
Tracking cost for getKeys() seems necessary. computeTracer.recordTime(0)?
It looks like you are returning an empty ArrayList keys
suggestion .filter(Objects::nonNull)
could we rename this violatingStatuses... or something like that?
there are others in this class too
This will not include the line break. Probably should append('\n')
It is the perfect case for a try-with-resources.
Are you sure about the encoding here? There were some UTF-8 references earlier.
Potential alternate wording: "If these messages are no longer available (perhaps you deleted and re-created your Kafka topic) you can use the supervisor reset API to restart ingestion." your choice if you want to use it or not.
is this the only line that requires KafkaOffsetsRepository to return a mutable map?
There were info logs for these in the original code. Any reason to remove them?
We can move this audit log to the common method. As this is common code for all ACL requests. auditAcl(OzoneObj ozoneObj, OzoneAcl ozoneAcl, OMAction omAction, Exception exception)
containersAcl() may not work for the case when the added is OR-ed into existing BitSet where .equals will not be the same?
can we print what the object type is as well?
Let's simplify this condition
Is it an exceptional case for ConfigLoaderFactory to not be present here?
Suggest leaving them as null if not set
Please keep this.cell near the related fields (previousFamily & cell count) below
the default should be made a constant somewhere instead of being defined in multiple places
have a default constructor with reasonable default values
Is this System.out required?
It would be safer (for preventing some race conditions) to give the permissions when files are created. Static methods Files.createDirectories and Files.createFile support a second argument for defining permissions. Below is an example:  Files.createDirectories(progressFileDir, PosixFilePermissions.asFileAttribute(EnumSet.of( PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE, ...)
I mean, it should be sufficient to just return ".". It gets converted to an absolute path later.
How do you know that tableName is not, itself, an SQL injection attack?
We log the exception here without throwing. In updateBindings and readBindings we have thrown the exception. Was this intentional?
Can't we use try-with-resources[1] here? Then you don't need to specifically close the resources. [1] <LINK_0>
should we throw an exception here?
So this assumes there's only one file with a given name in a tree? Maybe make these keys be relative paths instead?
canWrite() includes exists(), so no need to test for existence separately.
seems worth throwing an exception if the file isn't found, no?
Don't branch on the exception message, let WindowsFileOperations.readSymlinkOrJunction throw the right exception instead.
Add @CheckReturnValue?
please also assert that this calls enque on the call.
- [x] anyObject() is deprecated method.
this test does not require a project
I think this is the condition for !editable, i.e., readOnly.
while this has been an if-else previously, can we please convert this to simple statements editable = ... setEditable(...)
This forbids moving lightweight tags, and keeps the overwrite button disabled. This should be improved; it's very strange that I can move annotated tags but not lightweight tags. Command-line git allows me to move a lightweight tag with git tag -f myLighweightTag <commitId>. I see no reason why TagOperation shouldn't be able to move a lightweight tag?
Why do you use sleep ? It is highly discouraged, wait for an element instead
Please remove the " throws InterruptedException", I think that you don't need it
Why do you need to do this?
The Exception message should contains the original IOException ?
What is this check needed for? We might as well omit it to allow others to create a packaging type "my-eclipse-target-definition" that for example includes additional steps in the default lifecycle.
make byte-ray.new a constant and use here.
As discussed, a metric would be useful.
two questions regarding this logic. 1. Why isn't this  synchronized(lock) { while(paused) { // not sure why this has to be a "while" and not an "if" wait(); } // hard delete code }  Why are you taking the lock twice in a row? Code looks a bit more complicated than it has to be. 2. Why are you using the same object (in essence the same condition) to notify() both the requirement to pause/unpause and the fact that pause has completed? I don't know if there is a correctness issue but it makes the code confusing. Why not use a ReentrantLock with two Condition instances attached to it?
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
assertThat(violations.isEmpty()).as("Violations are empty!").isFalse(); assertThat(violations.size()).isEqualTo(1);  =>  assertThat(violations).hasSize(1);
assertThat(violations.isEmpty()).as("Violations are not empty!").isTrue();  =>  assertThat(violations).isEmpty();
Please simplify this just to nameModel.getObject() because it is a bit confusing at first sight.
This can't be null if it's instanceof ITask.
With the new out-factored structure, hopefully we can get rid of the "backreference" to the workbench here.
Why not pass the the ITask into the TaskReview and have getIncoming do this check? That way it will always show the current value and we don't need to call setIncoming when opening it.
This should be done in the above if and before calling isLooselyScopedCookie, avoids doing all the work if the cookie is ignored.
Use StepVerifier rather than .block()
java baseUrl + (baseUrl.endsWith("/") ? "" : "/") + "version"
![MAJOR](<LINK_0> 'Severity: MAJOR') Invoke method(s) only conditionally. [![rule](<LINK_1>](<LINK_2>
suggestion: you could use checkFoundWithOptional. Otherwise, we should deprecate the existing method
I like the pattern to use a supplier to compute the error message but why not use the same as the one used for org.sonar.server.ws.WsUtils#checkRequest(condition, errorMessage, arguments...)?
Use the 2-argument constructor.
Use the 2-argument constructor.
Is this the correct monitor to do the "worked" on? I missed this in PS1 review.
dispatchDepth > 0 ? dataLoader.dispatch() : completedFuture(emptyList()) You dont need this. dataLoader.dispatch() does nothing and returns an empty list if there is nothing to do So just return new DispatchedBatchLoader<>(key, dispatchDepth,dataLoader.dispatch());
No.
Are you sure that was not used in a "normal" use case?
if the host doesn't support the v3 format (old vdsm version), we'll fail when trying to add the domain. i think that if there's no pool, we can add the domain as v1 (it's rare enough anyway)..in the worst case, it'll be upgraded.
we missed something on the last patchset, with the current code if getTargetStoragePool() return null we will fail on CDA on isStorageFormatSupportedByStoragePool() so there's might be no point in having else clause at all here. there's something else which is awkward here, let's close that f2f and update in here.
what is the difference between the gluster/posix tests here besides the storage type? if there's no difference..let's share the code.
String.format?
You could use BigInteger.ONE instead.
can we iter once over the list instead of twice? map(pipeline -> pipeline.getName().toString()) ?
Does this ever get called more than once?
be a good citizen and call System.exit too :wink:
Could combine this line with the next one.
use style provided with callback instead
add style as parameter to above 2 methods
Shall we directly pass the mapboxMap to the getRoute method as an argument? Since there seems to be only one usage of the mapboxMap in this activity.
I suggest to resolve these two references separately, you can have two methods: Optional<Image> aboutImage Optional<AboutItem> aboutItem after that the code should be less complex
this should return parent2
the hardcoded value should be replaced by a constant
May this dialog also limit resources with *.json as the other one that browses the workspace?
maybe something like this instead?  File file = new File( directory, targetFile ); if (!file.exists()) { fail( "Could not find file " + targetFile ); } return file;
Please replace the "new" calls (both NinjaInMemoryFileItemStream and NinjaDiskFileItemStream) with a Provider... you can simply inject a Provider<NinjaInMemoryFileItemStream> on top of this file and you are ready to go :) I'd create an init method that then takes "fileItemStream" or "uploadDirectory" in case of NinjaDiskFileItemStream.
why not list.stream().forEach?
This should be ops().run(net.imagej.ops.Ops.Image.Equation.class, out, in). That way if someone writes another specialized CoordinatesEquation op, it could also be matched.
Simpler: ArrayList<T> result = new ArrayList<>(collection);
Is this supposed to be mId = null? mTitle is set in the next block
spacing
seems like a candidate for if (K9.DEBUG)
Use TaskType.STANDBY.
Is there a performance difference between this and original code?
this is the same type of ugly statement that is hard to read
isn't better to call it dimensions ?
There should be a corresponding JsonProperty getter for this
Having a builder instead of a public constructor is usually better
I think this lines are not required, but never mind.
Why not MacPool p1 = command.getParameters().getMacPool(); p1.setRanges(Arrays.asList(range1, range2));
There's no need to save this inside a variable
Why a TreeMap?
Any particular reason an import wasn't used here?
Does it mean that there is not anymore the concept of "groups" of statistics ? Before, we had some group name, and when we asked for i.e. AllCacheGet, then it would return all associated statistics (AllCacheGetCount, AllCacheGetRate, AllCacheGetLatencyMinimum, ...). Hence the .putAll() ;-)
nit: getBytes(CharsetUtil.US_ASCII);
Why writeBytes here? I feel like it's supposed to be readBytes from byteBuf to temp, right?
Cast should be unnecessary.
Use ConfigUtils:isBetaFlavour
Do we want this in master?
If this condition is considered as an error, shouldn't the execution be terminated after printing the error?
This doesn't work if the editor has a file open that is not in the workspace. Don't we have something somewhere (SelectionUtils?) that would make this work also in that case?
Please don't downcast. I'm pretty sure this will result in a CCE in 4.x. Use HandlerUtil's getActiveMenuSelection(ExecutionEvent) method instead.
The [ITextSelection](<LINK_0> provides methods as getStartLine is this another context?
Rewrite as: String methodName = element.getMethodName(); String className = element.getClassName(); int low= 0; int high= filters.length; while (low < high) { int mid= (low + high) >>> 1; Filter filter = filters[mid]; int c = methodName.compareTo(filter.methodName); if (c == 0) c = className.compareTo(filter.className); if (c == 0) { return true; } else if (c < 0) { high = mid; } else { low = mid + 1; } }
Met List:  @Override public boolean inputIsConnected(int index) { return index < inputs.size() && inputs.get(index).isFullyConnected(); }
Why don't we handle that via the Filter? I dislike having a special treatment of certain stacktraces. I think it is OK to add them to the filter (with wildcards) but hard-coding them, seems wrong.
Please include clientTelemetryEnabled in toString() API
We should also rename the string wordings -> maxChannelsPerEndpoint -> maxConnectionsPerEndpoint and maxRequestsPerChannel -> maxRequestsPerConnection
If every other variable is in PascalCase, we should keep the convention in the file. Use TirePressureObject instead of tirePressureObject.
formatting
createEntity and why is EntityType a parameter? in that case it should be part of GameObjectDTO. in either case i dont think this is a solid way to handle creation of objects. We have the possiblity to give the client different collections of objects in joinGame and thus we may have different methods for object creation. I do however think that having the single collection with gameobjects is the best approach, but gameobjects that have fundamental differences (could be character) may need their own collection
please remove or refactor
I'd declare the kieConfiguration as a local variable, with a setter/getter pair. This will allow Camel to generate code to allow users to configure username/password outside of the uris. It will be the default configuration (i.e. if not overridden in the endpoint uri, the parameters present in that local variables will be used). Then, in the createEndpoint, you can "clone" the default kieConfiguration and override settings using parameters/remaining-uri. This is because uri parameters cannot be configured directly using environment variables, while component fields can.
The scmConfigurations list can be null. Is not handled. Any reason? It was handled earlier, in places (for instance, here [metadata == null](<LINK_0>
need to set dataRegion size.
Is it an exceptional case for ConfigLoaderFactory to not be present here?
So we are storing the whole certificate text in the DB? Would not it be better to just store some internal cert ID for CLOUD_PROVIDER_OWNED certs to save storage space?
Let's simplify this condition
succeeded() or succeededSilently().
Why do we need to do this. The Empty view should always be there
It shouldn't be there. ProfileView should be shown in onActivityCreated of relevant activities in which we have to make it appear.
Should this be CF_METRICS_METADATA_NAME ?
I wonder if this should be BatchReadTimer.... I know the Astyanax does Batch, but Datastax doesn't.. so...
Maybe you can use CF_METRICS_METADATA_NAME here too?
In what case can we not create an evaluator?
do you need to add CRC here?
The System.out in a few places should be System.err to make sure that messages go to stderr. I think there are a few examples of this in other bindings.
I am not sure if we want to return null here
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Let's not change the visibility of test classes and methods please.
This case could be avoided by creating a getLabel(ButtonData buttonData) method in the ValueType enum, which then is overridden by each enum value. But it's kind of esoterically.
See ByteByReference.java
what if valuelist is empty? should you check for that?
Error occurred while creating a new XMLEventReader from InputStream.
Error occurred while creating a new XMLStreamReader from InputStream.
I don't think, that this way, it's easier to read. How about leaving the OutputStream outside of the try in it's old verbose format and just have the try around the writer? if the writer is closed, then the underlying stream *should* be closed, too. Alternatively, we could write this:  OutputStream outputStream; // ... same as before try (OutputStream out = outputStream; Writer writer = new BufferedWriter(....  That way, we can still figure out the outputstream on multiple lines, but still use the auto-close feature.
Does this truly need to be done in arjunaCore or could it be guarded in XTS alone? It is fine if it is an arjunaCore issue and we should code to fix it but I need to see an arjunacore test case that shows this or reasoning it can't be sole change in XTS
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
remove String.format
No need to append an empty string :)
There's no use of this variable here, right? We can returne the what's returned from the method directly
Improve this statement by providing more context.. "Unexpected error occurred when start polling event adapters". Just a suggestion (We need to say when exception occurred as well) .
same string used multiple times ==> put in a var.
remove file==base as the entire tree should be effected.
Please use "something <operator> null" convention
Fine to move the command, but since you try to refactor the code, this method should be private
Flo will probably tell you to remove this extra line :D
Let's adjust the formatting :)
Would it be better to use:  java if (thing == null) { continue; }  If there are two factories that could create the thing, you will return "null" here and do not try to use the other factory.
I just learned that addItems actually only adds the group item for the thing (and its groups), but not the items for the channels (which is done through enableChannels). I wonder if we should hence find a better name for the method? Something like "createGroupItems"?
Shouldn't this now throw an IllegalArgumentException in case the thingTypeId is empty?
If the lastException is null or not an instance of AmqpException, we should return null. For example, an IllegalArgumentException is not retriable.
Why not stash the value of the super call in a variable and use that to determine what to log? That would factor in NON_RETRIABLE and other HttpClient behavior that might lead to this method cancelling the retry.
Could you use a format string here:  log.warn("Zookeeper can't be reached, retrying (retryCount = %s out of %s)...", retryCount, this.getN());
matchAll will internally still copy the entire match set, so in case of hybrid matching, this will not perform as expected
I'm not sure but shouldn't we return [unmodifiable list](<LINK_0> here?
isErrorIfHostDoesntExist => isNewHost
if this utils... I would have passed the calling class as parameter to get this defaults... so that you can have multiple... or better just pass InputStream...
This will not insert commas as required.
Why did you catch any RuntimeException based class here? So far as I can see only NullPointerException  and ClassCastException are official thrown.
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
Duplicate getAbsoluteFile()
I don't like that we must first call "getSelectedFile" and then additionaly "confirmFileSave". Could we have a method that merges the logic of the two above? It could be named "getFileWithConfirmation".
Should be Refreshing_X and use NLS.bind()
space before catch
It's a not a big deal, but shouldn't we throw a TechnicalException instead?
can this be called from multiple threads? If yes then there is a concurrency issue. fParameterProviders needs to be handle thread safe in this class.
instanceof check is enough, no need for null checks in this case
I think reference assignment is atomic so this change and some other below don't make any difference.
unnecessary parenthesis?
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
We could just return true here and let auto-boxing take care of the conversion.
Why only adding it to the active window and page?
In case of Multipage editor this will be called twice. Is this intended?
Code cleanup: Remove all throws MiddlewareException and throws MiddlewareQueryException for this class
Create a list of valid variable types and check if it is there. Ideally we should be getting this list from Middleware (maybe from DerivedVariableService)
"Inventory amount" could be extracted as a constant
is there a reason you don't just return this here?
This whole block can be replaced with functional style Java, as per example given in Epdq.
This whole block can be replaced with functional style Java, as per example given in Epdq.
After <LINK_0>, tuple should be singleton.
See if System.arraycopy is supported in GWT emulation library. Copying should get optimized to something more efficient in the browser than iterating over the list one-by-one.
Why is waitingEvent condition required here?
Can just use diamond operator on RHS
I think when you fix indents to tabs, we'll see here less changes :smile:
(CRITICAL) This is not correct. Here you should add to _nextValueId instead of _nextDocId
Using CompletionException would be more appropriate I think. Otherwise we would end up with longer ex-> RuntimeException(ex) -> CompletionException chain of causes.
Nit: new line is unnecessary, and there's a misspelling: suggestion log.error("Encountered an error while awaiting an errant record future's completion.");
This exception is not ignored, so can you fix the variable name?
why?
s/new Guid/Guid.NewGuid/
I hope you realize the two lines are not atomic. Just want to make sure - if you're fine with that - cool.
What about doing one thing at a time?  java View frame = Views.findById(this, R.id.login_icon_frame_layout); frame.setBackground(new BubblyDrawable(getContext()));
get rid of VERSION
Camel case
I would have put it after the createAnnotationAndAddSubscription call.
Put it after updateAnnotation.
Yes this is the first thing i tried. But when I tried to empty the previous mails I couldn't get it to clear. If this works then fine for me.
Just to keep the logic in a same class, why not move all this in the prepareValue method. You would need to pass the operator, but that's fine. This class wouldn't be modified.
I think you've set fStateValue to nullValue in the constructor in this case, so this is pretty much dead code
switch/case here too It's not just for the sake of it ;) But for example, if we ever add new types of ITmfStateValues (which we've done before), we would then get warnings here asking us to handle them, which is exactly what we want.
Why is this here with such a wide exception type?
@yesamer I think it would be clearer to and an "else" statement, or to create two different methods. Wdyt?
This is another behavioral change that I don't want to see in an unrelated PR.
Change Object to String
I would maybe use String.format("%n") for platform specific line separators instead of introducing a new replaceNewLine() method which alters the "code under test". => I'd rather transform the code into :  assertThat(request.body()).isEqualTo(String.format("{%n" + " \"key1\" : \"value1\",%n" + " \"key2\" : \"hello {{test}}\"%n" + "}%n"));  WDYT ?
Don't you want to test PUT and expect OK here?
Do we need to check if manager is null? If not, maybe we should remove geofence manager check?
Do we really need getIdentityManager here? You are already in DeviceManager.
Can't we use lookupConfigString instead? Ideally we want it to be configurable globally in the config instead of per-device.
Have you checked that the test fails if the this assertion fails?
this code may be performance sensitive, isn't it? This call always triggers the arraylist reallocation. It could be improved by allocating an arraylist with size getOperations.size + 1 before filling it with content.
public ModelValidatorContext(StandardEvaluationContext context) does not require spelContext.setTypeLocator(new RestrictedTypeLocator()); ? I suggest you yo use cascading constructors instead of using the same code in the different constructors.
addAll or stream?
You could return directly
addAll? Or stream?
It looks like right now when a connector is made diagnostics aware, There is a lot of boiler plate the connector needs to do to parse out commands and parameters. We could consider creating a library or utils that helps diagnostic aware connectors to reduce this boiler plate. We don't need to do this right now. Something to consider for future enhancements.
same here - might want to propagate exception here?
Might want to propagate exception back to the user?
Likewise, this should probably be /rest/script/sessions, and the sessions controller should be updated. The restlet framework handled servlet paths differently from the MVC framework I believe. Either way, you should verify in a 2.11 geoserver with script installed to be sure of the correct path.
Can you please remove this line from assertResponse and place it for example directly to test methods? It is a side effect and is unrelated to meaning of assertResponse method - according to its name I would expect it just to check response, not setting some method variable.
Since you have replaced containsKey() with contains(), can you also remove all the .asString() in this class, now that contains() takes a HttpHeader?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
This also needs to be reworked once #6327 is merged.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
assertion for channel kind should be added.
so it records stopped time only if all workspaces are stopped? Shouldn't it be all user's workspaces?
If it is clearer then method name clear looks more natural for me than remove
asRuntime(getRuntime()) doesn't seem very clear to me. Maybe asRuntime(getInternalRuntime())?
wrong code format
Use URLConnection here too.
Parameter missing (@lolodomo I will send you a PR with a small change -- you can have then a look at -- it will contain this fix.).
Unkonwn => Unknown
Unkonwn => Unknown
This method name is a bit confusing.
Please do not swallow exceptions silently.
Should be checked by a filter instead. See the MessagesWithBodies filter.
The Manager class provides getAuthenticatedConnectionOrThrow() for this case.
optional nit: File::getName
remove the debug trace
Should not check in any order as the clients should be sorted
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Also this should be Log.d
Why setting Token or MID imply sent = false ?
load() is unnecessary as the constructor above already calls it.
nit: please move this line below requireNonNull(dao, "daoProvider is null"); to keep all non-null checks together and at the beginning of the method.
Alternatively:  assertThat(rs).contains("Coda");
Can you set the message inside the method avoiding passing it as an argument?. It's always the same
Should we also issue a warning to have a log of plugins to be fixed? I think we should, but do not know if this is going to generate just a few lines, or dozens or more of them.
Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.
This is an alternative to have just one assert:  aList.stream().allMatch(num - > bList.contains(num)));
This clean up should be in a finally section
This loop can be replaced by: Stream.forEach()
I assume this should be deleted
It would be good to call OS.getCurrent() once in the constructor, store it in a field, and then use that here.
This value can be static, no need to look it up every time.
This might cause problems with dedicated servers since you refer to a screen class and the minecraft class here. Have you tested this with dedicated servers? If it does cause a problem, consider moving the gui display to MSScreenFactories.
TextComponentTranslation allows ITextComponents to be passed to it, so the user's name should remain as an ITextComponent.
I still think using UP or the hand for the EnumFacing is fishy here. Nobody else is going to know how to open your gui. I think null should be used, unless it's a block and you know which side of the block is being clicked.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
1. The map is final 2. There is no set method to update the map. Why not directly put it in an unmodifiable map in the constructor? So we don't need to create a map on every get.
This is test can give false negatives. e.g. if a real user email can contain 'tmt'. Use a longest string possible for both cases.
This should be moved to a messages.properties file as it is text shown to the user.
Should this method be in the account object instead? Something like isRegistered():boolean?
optional: this can be outside the try{} block
I don't think there is a need for this any longer - Files.move() will copy the file if necessary - I tested it on OS X and Files.move() moved the file to another physical disk. But I suppose it doesn't hurt to leave it here. WDYT?
try (JarFile jarFile = new JarFile(srcFile)) {...}
please add <?> to avoid warning
This is already implemented by AbstractDebugTargetView
generic has come with mars. Consequently that code won't compile against previous platform
Are there unit tests for channelSignIn?
Would it be better to move the null checks to the SignInCredentials constructor? This way, you can guarantee that SignInCredentials will always have non-blank fields. Similarly for SignUp and Email.
Should we have an else that throws a "impossible code path" exception? This way, if we ever add another channel and don't update this code, we'll get an exception instead of a silent failure.
Please extract to a method and call it after you verified this is an image disk
Shaerable??
I would consider to rename the parameter diskImage to oldDiskImage just that we will still have an indication which disk are we updating...
No space between STARTS and WITH??
reference would be concatenated w/o a separator. Is this intended?
flags is native type. why check against null?
resizeWidth variable is unused now, should be removed
Can be refactored into a one-liner: text.setVisible(HORIZONTALSCALE * width / fontWidth >= MINTEXTSIZE).
types --> type
unrelated change
exactRef
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
nit: Add "I_" "D_" prefix
Clickhouse has a different rename syntax (<LINK_0>
nit: formatter with { } around if sounds better?
java assertEquals("Unexpected failure code", ERROR_SUCCESS, result);  Try to provide as much information about the failure - in this case, not only that it has failed but also why.
make public static
This function is being updated by #3161, so I'd remove this change as it will cause a merge conflict.
rename 'visibleField'
Why do we want to check the count? The generated code uses List instance anyway. What if we just inline the compositeFilters variable and remove the if check? It would make the whole this method not that much tested. If you wanted to make it more obvious that nothing happens if the list is empty, why not just do it at the beginning of the method and return right away if so?
Lambda
can you make "9" a constant as we use it most places
Could also use EnumSet.complementOf(EnumSet.of(Blob_Expired, No_Error, ...))
shouldn't this be "ServerErrorCode.Blob_Expired"
handle this with an error log and returning null instead of a viewer? as the view won't work with an incorrect id?
If selected trace is not a kernel trace, the old viewer data remains. You could call updateModel(null) here.
I missed this one before, but if (!eventString.isEmpty())
> isAssignableFrom fails because the classloaders used between the two classes is different I don't understand, this is with a built-in policy implementation right? How can two types that belong to the same JAR get loaded by different classloaders? Regarding Dynamic-ImportPackage: *, as far as I understand this is the nuclear option, so I still see a value in allowing users to pass their classloader to the builder.
Add the original ClassNotFoundException as cause.
Multimap returns an empty collection if the key is not found, which will simplify this code by removing the != null test.
In cleanupNodes above we do a NPE check like: java if (nodeList != null) { // ... }  Shouldn't we do also here?
I think you can leave this in info, as it may be important to know exactly when the node source is removed from the DB
fail is unecesary if an exception doesn't happen test will fail.
yes, I'd log failures, the bundle activator has some methods for logging: Activator.logError()
Use constants
nit: missing space after if
Remove the matching given method call as well.
It seems this given statement is not necessary anymore.
You cannot @Override this method to implement the method from the interface because after obfuscation it will get the srg name. Please consult [the mixin examples](<LINK_0> for how to deal with conflicting methods with the **same** signature/name. _EDIT: actually never mind, I just noticed that the MCP name has an uppercase "ID" while the sponge method has the Pascal-cased "Id" so it's all fine._
here schema is always not null
why do you need all these 4 checks and castings? Will not it just work with: recursiveCheckConstraints(schema, jsonPath, schemaIncompatibilities);
This looks like code duplication. Can you please factor that out of if statement? For instance: 1. determine schema name 2. return candidate
We are using Java 8 here. You can say catch InstantiationException | IllegalAccessException | ...
this should probably fail on receiving interrupt
As a nit, should have a null guard here.
This only runs on Gtk3. How about trying to set this to not run on gtk2 instead? would this work on cocoa/win32?
Is toString() the same as the explicit serialization call?, I.e. serialize().
Using a value that will never occur in practice is a hack to express "always render the initial value". I'd rather express this explicitly, e.g. by omitting the defaultValue parameter.
Log and throw is generally considered an anti-pattern. We should perhaps be able to get rid of the log message in this particular line.
Subsystems should no longer use the ModelController directly. They should create an in-vm client using a factory provided by the associated capability: <LINK_0>
Is warn sufficient here?
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
does it really make sense to allow float and double? It could potentially go out of memory easily, with 0.000001 different than 0.00000001, etc. In Java when you check equality of floats and doubles most IDEs will flag it as a warning.
Constants
no System.gc() before/after?
This temporary change shouldn't be here.
Other test suits have a line with perf.tagAsSummary() as example below. Do we need that here, too? perf.tagAsSummary(pm, TEST_SUITE_NAME + ':' + testName, Dimension.CPU_TIME);
This will truncate to the closest size in GB. I'd do the division in doubles and then round UP to a long
This method should only be called by disk images. You can rename the method to something like 'getImageStorageDomainId' and by that solve that issue.
you can just pass storageDomain.getStoragePoolId(), the called method is handling null pool id, please change that and rebase the patch. other than that seems good to me.
If it got deprecated in Gtk3.10, then it should still work between Gtk3 to <Gtk3.10. You may wanna put this around a version check instead perhaps?
No need to have the styleState variable at all.
This line is in the wrong position, I think, the Parcel must be read in the same order it is written.
Is the purpose of this to show the user the REPL prompt again?
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
Per above, I think this should be changed that the only way to construct it is with an expression, in which case this check isn't necessary (but we could have an assertion for it).
The legacy behavior corresponds to SingleAffinityResourceDefinition.PATH, thus I think we want to use: builder.rejectChildResource(NoAffinityResourceDefinition.PATH)
Pass in true for the second param (discardUndefined), and remove the undefined model node from the values
I think we want to use DiscardAttributeChecker.UNDEFINED here (and for other version transformations), since a value of true should result in rejection.
Are these two if necessary?
Why not to use the constant: Charsets.UTF_8 as on the line 111 above.
Which is perfectly valid, if there is no Internet access available. Hence this must not result in any errors being logged.
Would it be possible to fix workspace object as soon as possible in the chain, so we would avoid ifs like this in the code later?
How about: "Cannot estimate the memory requirements of a devfile-based workspace {}. The memory limits may not be applied correctly."
The error message should also be updated to something like "the name cannot be empty" or something like that. Honestly I don't know why the check was here, as the UI allows for workspace renames.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
It should be: combined.put(entry.getKey(), entry.getValue().toString()); With the current code I get: Parameter value [1] did not match expected type [java.lang.String (n/a)] With the fix it works fine. I tested on Hibernate 5.3.6 and querydsl 4.2.1 with this pull request applied.
the definition can move to the else block
Why are class properties of parameters class set here? If this is something that is never filled by the calling side to the command ,why not define them and use just inside the command class itself? It can be confusing to the caller to see this object and wrongly conclude he needs to fill those parameters. If there is actually a need to fill those parameters from outside, then there are wrongly overriden here, and it's better to have a validation + appropriate error should be thrown if they are missing.
the 'else' part seems redundant here
Throwing an IllegalArgumentException could be confusing since it's not the arguments passed to the invoked method causing the problem. Maybe throw new InvokerInvocationException(ex) or  throw new InvokerInvocationException( new AccessControlException("Illegal access to method" + cachedMethod.getName(), ex) )
Could you move this method next to doHibernateSearchList? This class is already a bit hard to read due to the many methods, so we should take extra care to keep related methods together... Sorry, I know we shouldn't have to do that :/
Consider using getField() instead, ~~it's implementation in OpenJDK 8 seems more performant.~~ Also the semantics of that method apply better in this case, since it is a public field. _Edit: can't confirm first claim_
what if the account id, container id is 1? I think its probably better to do something like "current id + 1" so you are sure it is different
not sure why we need this. Why not just call this from the OperationController?
I hope you plan to work on logging and metrics in a different patch. We need lot of trace logging in general.
Hi @xstefank, This is a minor point, but I would suggest using a status like 456, something that wouldn't arise otherwise. You could get a 404 by getting the URL wrong. -Ron
As discussed on the mailing list, probably best to remove the query.
Client client = ClientBuilder.newClient(); is likely enough instead of the line above. And in any case, you need to close the client, for example using a try-finally block
no need to specify type on RHS
We don't need another ImmutableList.copyOf. You are doing this when parsing.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
We need to do something bette than log an ERROR. Either its a DEBUG/TRACE logging error to ignore this. Or its something that needs to be wrapped and thrown as runtime exception. And is there any API on OSGi you can use to check if the syntax is correct and then just do a if correct then ... else ignore,
Can you update this to use the StringUtils from spring since it is already imported in to the class, I think the equivalent method to call is StringUtils.hasText()
You can make this a bit cleaner by calling data.isData() and data.isHole().
It would not be here, in HttpPanelSender(or ManualHttpRequestEditorDialog?) by having it listen to the option change (OptionsChangedListener?) and update the button when that happens.
Let's indicate to user that it's OpenShift project not Che: Deleting OpenShift project... or "Deleting project [project name]..."
should we use a constant prefix for all the paths of this class ? constant being "/java/code-formatting/" to avoid to miss some endpoint in a future
I thought there was going to be a separate monitor for this CM integration descriptor, the handling of which would be contained in the cm-integration module.
I'm confused about why this capitalization is happening in this "MissingResourceException" catch. I assumed the plan would be to adjust the case in MimeTypeFacets.properties to be whatever consistent naming we want. Right now there are 50 or so lowercase entries with no spaces like "networkdata" and only 1 with title case, which is "Tabular Data".
Added code to print an error message and exit.
what if extension does not return VALID_TO? I guess you have null pointer exception.
hmmmm.... how is this done for this specific session? nevermind... I think yo can just call getData with refersh and the soft timeout will set for you, no?
should be: valid_to = default if we have valid_to from extesion valid_to = min(valid_to, valid_to_from_extension
object.toString() isn't a null-safe call, while sb.append(Object arg) is doing 'String.valueOf(arg), so it has a null-safe Object-to-String conversion. So we just shouldn't call toString() here.
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
String joiner can be used here to simplify looping and checks, not that important in the same time
Better to make "ping" a constant. Fix in all places
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Don't we need to do something slightly opposite? Check for data instance of List and always call onMessageBatch() since it is there on the MessageListener anyway.
use java.util.Objects
use java.util.Objects.equals
This is a little bit asymmetrical with the comparator. The test for equality only considers the port name. This is a trick to support removing an TtyDev from the internal list by its name only. The comparator, instead, considers first interface numbers. However, the Java doc states: > It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is "Note: this comparator imposes orderings that are inconsistent with equals."
Unnecessary (and incompatible); revert.
If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.
Perhaps a IllegalArgumentException instead to propagate this one com.udojava.evalex.Expression.ExpressionException ?
Gson doesn't run on these versions so I don't see any reason to include them.
Unsigned types are not used in the current implementation. So, you can omit them.
You can change the 28 case to a default case, and remove this.
This will not insert commas as required.
Instead of this check you can do: java log.info("New config event received: {}", properties);
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
next time you can leverage switch case for ENUM
Why do the other String.format changes use Locale.ROOT where this does not?
as with the algorithm command I think calling the new constructor with appropriate values would be nice here. This would value all the cool new logic of the new constructor.
1. You could just make calculated limit a field that you set in the constructor instead of reading it here. 2. If you don't do that, I would make it final here. 3. Would it make sense to have a lower default value, like 100? All of these are trivial and probably not necessary.
I find it more intuitive if the @Auth User user is @Auth User authUser and this one is just final User user because the 2nd one can really be any user if the first one is an admin
I think you need to check for a null fetched user; could be an incorrect id.
IIRC, I think the reason for only printing out the exception message rather than the full stack trace was to reduce noise in logs. I think the full stack gets printed if the number of failures reaches some threshold. Maybe reconsider.
this should probably fail on receiving interrupt
printStackTrace directs output to the console and should be replaced with logger debugging
one more test case for a reply != 354 here would be nice
This should work the other way around, POM settings should take precedence over settings.xml
we can do without remote JMX support for the embedded Jetty instance
Ugh. Why do we have updatePresenceStatusForXmppProvider(pps) and updatePresenceStatusForXmppProviders() that implement the same logic twice? :/ I know that's not related to the PR, so I don't expect you to fix it
Consider using ServiceUtils.getService here as well
Style-nit: no brackets around single-line blocks
Perhaps put sendError(ex); after the branch (since it is the last statement in each "leg" of the branch.
Why?
let's do Objects.requireNonNull(predicate, "predicate is null"). I've also forgotten in in various places and will add them later...
Same here, you cannot create a RawType of the given data, why is this accepted without throwing an exception? Need to check other types. Is this our common handling to ignore a correct "deserialization"?
Would it make sense to always encode the return type into the cast function and generally remove the notion of having per type cast function names? So that we don't have to treat object casts in a special way.
Possibly compiled away, but + 'f' ought to be more efficient in principle.
I feel like this test and the above test have switched titles.
A check should return a boolean value and not 'blindly' throw an Exception in my eyes. The responsibility is a check, not to handle that check. If that would be the case the function could be renamed for better code readability to "checkIfFieldInUseAndHandleResult" or something which is better. I would still prefer to return a boolean or maybe even an enum that returns what is in use: "None", "Username" or "Email".
So if there are more than 4 tokens, we're deleting them all? Makes more sense to only delete the oldest right? Deleting them all introduces a sort of random factor for the users. One time they are still logged in, and the other time all devices are signed out.
Consider slicing the ByteBuffer instead of allocating another byte[], a bit more math to compute bounds, but less allocations in the end.
else could be better here..also some duplicate code can be avoided (from 139-142) if that part of the code is made common. Can we also abstract the allocate difference between sequenced and normal elements and use a template pattern here?. Again possibly a future refactoring.
The SerializerException is completely unrelated to the operation codecs - you should throw something else
this can be an info
change to "parent server does not exist and is null"
please reformat. the line is too long.
this should probably fail on receiving interrupt
As a nit, should have a null guard here.
Previously if a RuntimeException was listed as an application exception it would not be wrapped, which is the behaviour expected by the spec.
why not make "update" a constant too?
Does this only return by 250 default?
Seems like info would be more appropriate.
we can set variable directly here.
There are many command with VM in the name so please run add it only for specific commands. The code needs to be generic because we will have soon other events.
side question, but do we really need to check for enabled anymore? should we just deprecate that feature?
When I did expunge(true) on a jboss7 entity, I saw logging of:  2014-01-28 22:18:47,089 WARN brooklyn.management.internal.LocalEntityManager@2524e205 call to stop management of unknown entity (already unmanaged?) JBoss7ServerImpl{id=mPXYvab1}; skipping, and all descendants  This is because Entities.destroyCatching will also unmanage. So you want an if-else, to only do the mgmt.getEntityManager().unmanage(entity) in the else block.
I'd call the variable entityClass
same with return here
Use org.apache.flink.table.utils.EncodingUtils#objectToString
here too we could use getClass().getSimpleName()
We shouldn't use 'String(keyTable[i])' here because sb.append(Object arg) is doing 'String.valueOf(arg), so it already has a null-safe Object-to-String conversion.
not needed, can't happen (don't trust your IDE on this one ;))
There is actually yet another error here: this should be java int start = Util.toIntUnsigned(getValue(ir));
andCardinality(Container) should be called here instead of and(Container).getCardinality()
"".equals or StringUtil.isEmpty.
you need to check that keyValueSeparator is not -1 (ie no = in the line)
I'd recommend using <LINK_0>
why ? how could this happen concurrently ? the workspace modification locks should prevents this.
getDelta() can be null
I would like to see all new code using lambdas where possible.
Decompose this into multiple lines for clarity.
Rather than hiding just the completion button for teardowns, should the entire conclusion fragment be removed? I don't think there is any conclusion text so the only thing we might want is more sharing controls if we ever add those.
Hey, So we used the old statement (triggerUserFormComplete) to denote the distinction between the form saving for an arbitrary reason with user input that means "I want the form to exit", which has some important distinctions, UI wise. I don't think they're relevant without some new UI stuff, but I think it would be good to maintain them
wait.forElementVisible returns WebElement, so you can assign the value to avatar here and then remove the line below completely
is this else if needed at all?
put method contents into private method with WebElement parameter
Should be done before opening a db session - for to fail fast.
since we already perform checks on the project there, I'd put this in searchProject for consistency
I fail to see where the new organization parameter is actually used in this handle method. Currently, it's using the organization of the specified new default QP. It works, but I think it wasn't the point of adding a new organization parameter. The algorithm should have been: 1. retrieve key of organization param or default organization key 2. ensure user has permission on specified organization 3. retrieve specified QP 4. ensure QP belongs to specified organization 5. if specified QP is not already the default QP, unmake the current default and make the specified QP the default one If we're not going with this algorithm, then the "organization" parameter could just be dropped
I don't get the idea of using an array here...
throws ...
I'd like to see our Throwables.throwingOnlyUnchecked used here
Why not passing the expected return value as an argument to mockOffsetResponse(), this way you can control whether the mock object should return true or false.
Just for the beauty of the source code, I would have prefer request and response instead of arg0 and arg1...
you can append "twice()" to the expect
Don't make this an ImmutableSet when the builder gets converted to a FetchHints it will take care of that
This is not semantically correct, the Location header should point to the location of the created resource, not to a different resource. Since multiple resources are created, it would be better to use null for the header, and instead put the list of locations in the response body.
this can be changed to aliasArray.getString
Message seems to be unused. Remove this line?
Use parameterized logging instead of string concatenation
According to [the best practices](<LINK_0>, we should use a backoff if there is a 429 error. However, returning true here will retry the request immediately. Shouldn't it apply the backoff for 429 errors and return false otherwise?
we don't use braces around singe line blocks
We mix two different comparisons styles here: "expected".equals(actual) vs. actual.equals("expected"). I would prefer to use the first one only as it is NPE safe.
Please consider updating of java docs as well. I don't see any java docs that would explain how we store machines names in annotations. I guess, previously java doc of MACHINE_NAME_ANNOTATION_FMT const has some short info.
check if you can use fluent api to add the storm tag
Can't we just log in DEBUG otherwise ?
That is incorrect, in case the logger and eventAdmin is null we get a NPE
This should be strongbox. This leads me to the thought that Strongbox should have instance names (I've raised #693 for this). Cosmetic: Could you please make the first method invocation on the same line as the new instance (and re-align the rest of the chained methods? I've seen the same in a few places across the pull). Thanks!
The pattern we're using in StreamDescriptors is to have the extending classes also override the toConfig method from the base class and call super.toConfig as the first step. Might be a simpler interface for extending classes since there is one less config related interface method. If we do that, you might also not need to call addTableConfig to mutate the passed in tableConfig map in generateConfig.
The previous code that did this had a log about the override. Would it be good to put that here too?
requireNonNull(finalTaskInfos, "finalTaskInfos is null");
We should probably use the same pattern as above, and change this block as follows:  if (mobileInfo != null && mobileInfo.isConnected()) { setHasNetwork(true); return; } setHasNetwork(false); return; }
I don't like double synchronization here (one on jNode and one in map) I suggest using computeIfAbsent method: java UsageInfo usageInfo = usageMap.computeIfAbsent(jNode, key -> new UsageInfo());  as description said it is atomic, so it must solve synchronization problem. Anyway, it must be checked.
Race condition, multiple instances could be constructed at once.
Can we always use braces on conditionals, I think it results in clearer code.
Right, the transactionManager.shutdown() call is redundant with the if () block below.
remove the explicit initialization?
this looks backwards. If (!keepExtensions)?
This should throw the error so the test will fail.
new ArrayList<>(Arrays.asList( should just be Arrays.asList(. you may have to do a Ctrl F and replace all.
if the method takes the Context parameter, shouldn't it be withResponse?
Can use validatePrimaryLanguage here and below.
Is there a particular reason to make the rect a single pixel shorter and narrower than the graphics object? It causes a black border to appear on the right and bottom sides of the display, which doesn't affect the test fidelity but also seems unrelated to the functionality being tested.
Please, refactor this abreviation. <naming
Current assumption why we see some missing parts in WS is that we should apply the current transform to the clipping before we intersect it with requested one. We are investigating in this direction.
nit: Please fix code style.
nit: Please fix code style.
See my question regarding using mocks above.
This is hard to read, please move out the non-null checks.
Check for Preconditions and reduce the member variables to its canonical form as expected in the rest of the code if the preconditions are not met. Applies to other constructors of Key.
upercase tableName with system locale is not a good idea, java uses ENGLISH locale. in example making className named "something" to "SOMETHNG" in turkish doesn't work with java. query parameters should be loweCased and upperCased with system locale but field names, class names should use Locale.ENGLISH .
Use IWorkbenchCommandConstants.EDIT_CONTENT_ASSIST here (also in other places).
You could use the content of the input field to filter the list of proposals. The list of proposals may be very long.
Nit: This treats pattern as a regex, but probably shouldn't.
Please add a constructor LikePredicate(Expression value, Expression pattern, Optional<Expression> escape), we should avoid @Nullable parameter in the constructor.
As above, use constructor taking Optional<Expression> escape.
inline
this state does not exist...
Condition seems unnecessary since INT4 is returned any way.
Note that the Format.toString() case statement only needs explicit cases for those formats that are not a single word; otherwise it defaults to the enum string with first letter upper case. Please remove these 2 lines, rebase and let me know pull request is ready.
How about to replace calls to root.getLoggerContext() to loggerContext, if we already have the context as a field?
Do you still need this if you've created the config file?
The logging actually happens on the "client" side. So we'll need to setup the log level there, maybe using @BeforeClass and @AfterClass? I tried to move this code to the AbstractShutdownHookTest.deploy() method and it seemed to work.
Sorry for the pedantry, but we use { } everywhere :)
I personally prefer to check once if(!(obj instanceof Attribute)) instead of two checks for null and class.
I'd rather use ObjectUtils.nullSafeEquals(..) here.
memory...single 'm'
Can we append cause so admins has a chance to identify the cause and fix?
can we add a log line that we are killing a segment located at location <somethign>
This test method contains no asserts. How do we verify that quota records aggregation is correct rather simply not throwing an exception?
You should do not need this one. You can annotate the class with a jUnit runner
Simply use snapshots instead of 'dsnapshots'.
if not blank
Pointless assignment
Suggest AtomicBoolean instead to make it more clear what it is doing.
this one too
Avoiding to nest the for loop inside the if would make it more readable:  java if (labels == null) { returns names; } for (Map.Entry<String, String> label : labels.entrySet()) { ... }
Possible NPE here unless I am mistaken -- there may be no defaultValue.
fix formatting (some redundant spaces...)
you can reuse the constant in HostModel..
This is not required since you are checking for null in view
Same here. Magic -1 :P
Why not just define the new question index as -1 like what we do in JS file instructorFeedbackEdit.js.  javascript const NEW_QUESTION = -1;
I tried running your test locally; the new question button cannot be clicked because the discard changes confirmation dialog is still open.
remove this line and set it in the following RuntimeException?
Why return if is not the one registered?
nit: Prefer catching RuntimeException over Exception to allow the type system to help if we ever add a checked exception to shouldPublish. suggestion } catch (RuntimeException e) {
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.
Do either of these two 1. Add address.equals(InetAddress.getLocalHost()) to the check as a local inet address may still not match the two specified conditions above. 2. Create an unresolved InetSocketAddress in getRMWebAddress with canonical hostname and check for null InetAddress here
Why do you need this change? Seems you should prefer the autogenerated Shadows.shadowOf()?
"put(key, val)" will take extra lock that you don't need.
Maybe consider using guava here? int[] shape = Ints.toArray(dimensions);
maybe use assert here as that will eliminate the runtime check?
Please construct it, passing in the file?
could you move this entire calculation out of DeclarationGenerator? The file is very large, and this seems like a fairly easy thing to pull out.
Indentation is screwed up. I think it might be nicer to just extract this to a constant.
StringUtil.containsChar
I wonder how null actually gets in here. IMHO we should fix the root cause of it first. Still, it's valid to make it fail-safe here.
Now the format is broken: The closing bracket is missing and also the string placeholder for the exception message is missing. Add it again and provide a e.getMessage() instead of the full exception.
Do we need a new reason code here? Pipeline Failed is getting overloaded.
Here and below, now that the input can be an arbitrary object, we should call format on them to make sure they are escaped properly for output.
Were the two other if statement just never executed because this is the MigrateVMCmd, which should only be migrating a VM from one host to another (i.e. no storage migration)?
unused
Shouldn't this also test an Array that is empty, i.e []? Instead of a String that is empty, ""? Also, I am wondering about multi-dimensional arrays which is kinda the point of deepToString... If the array contains other arrays as elements, the string representation contains their contents and so on. <LINK_0>
Would like to see a check that these docIds are correct.
Throw a NullPointerException if address value is null.
use Arrays.fill instead for loops
static
Again, I don't see anything wrong with the existing use of implicit casting. It's much easier to scan.
Can you add the EntryType type parameter to TaskInfo here?
Should it be an error to call this method if you can't actually get the result set? Feels like it strongly indicates misuse / coding error.
Do we need a new BufferManager on every snapshotApply? or could we just reset?
Why we need to update topologyConfigId here?
Log level could be trace? Since LOG_REPLICATION_ENTRY message is pretty common.
@HDouss how about TimeUnit.MILLISECONDS.sleep(this.delay)? makes it clear we are using ms
Maybe could use some logging here? We don't expect any to happen if there's only a single mutation happening at a time, but when there are many, it would probably help with figuring out what's going on.
Why do we need a retry here? Suggest to nuke the retry-logic and rewrite as follows preserving interruption status  try { Thread.interrupted(); zkClient.close(); } catch (ZkInterruptedException e) { Thread.currentThread().interrupt(); }  or  try { zkClient.close(); } catch (ZkInterruptedException e) { Thread.interrupted(); zkClient.close(); Thread.currentThread().interrupt(); }
Why not simply "100px" as String? (100 is a constant here.) This <number> + <unitType> concatenation is unnecessarily complex, I think. This applies to other such occurences as well.
in VmGuestContainerListModelTable. you had quite thorough null checks for each column/field. If they are necessary please add them also here. Otherwise if you are sure none of the fields will ever be null you should remove it from the VmGuestContainerListModelTable.
Please add- namespaceColumn.makeSortable();
Should we put the check here too?
I don't understand here: why do you need this change here? it doesn't seem to be necessary.
To be safe you should read the bytes before assigning into data: byte[] d = new byte[len]; IO.readFully(in, d, 0, len); data = d;
instead of path separator create new path to make it generic
Why are we getting escape + " instead of single quote? Is it possible to keep it the same?
createCache simply
try using stream api for filtering
In case of creating template from vm snapshot this returns false because method updateLabelList() is called from constructor of UnitVmModel however isNew property is initialized after the constructor is finished. See VmSnapshotListModel#cloneTemplate.
I believe the default is true, so no need to explicitly set it here.
space line
return status != null && status.equals("ON"); is correct and sufficient
This was returning a "domain" Stop before, I cant see that the StopAdapter comes into play here. Or, did I miss something? It seems like there is a lot of types in play for just stop on this API, but if the "domain" stop is retuned then we need to make an API type for the old dev-1.x Stop, too. I can discuss this @abyrd and possible the community - maybe it is better to clean it up.
This feels like an error situation. If no keys come back, how will the authorization server be able to sign keys? I think throwing an IllegalStateException is better than returning the empty set in this case.
if (sigatureAlgorithm == null) throw new HttpException(ErrorResponseCode.INVALID_ALGORITHM);
This should probably be:  PublicKey publicKey = pemEntryIterator.next().tryCast(PublicKey.class); if (publicKey == null) throw (some invalid key message);
Maybe we could spice this up a tad to throw in another nice aesthetic change?
Cloning after calling getEyeLocation is unnecessary
@xpdavid is this the right thing to do?
I don't know this confirmable word :smile: Maybe publisher-confirm would be better? At least that is how PublisherCallbackChannelImpl.toString() represents it...
Did it help in any scenario or is it a defensive programming?
We should exit early if this.discardChannel is not null, no need to store this local variable in that case.
@danielsuter This can be done more elegantly. Will improve it for you.
Ah okay. I think I'd prefer it here. No need to abstract IMO :)
Should this not be Throwable rather than Exception? The two failures reported in WFLY-8515 were LinkageError and NoClassDefFoundError, neither of which would be caught as things stand
extra line
what if wit doesn't contain topics? Should we throw an exception?
Do we really want to move this from trace to debug?
can this be a method reference?
Minor nitpick, but you can probably shorten this code.
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
Please move abortProcessInstance into the final statement, it should be done in any case. Also please delete e.printStackTrace(); - it doesn't bring any value. Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.
I think here you can call await directly on the configured countdown listener and check the outcome of the await method - it should return false, meaning that it timed out. Wdyt? Otherwise we can replace this with plain Thread.sleep().
Basically the same issue as mentioned above, I believe.
Google Java style always uses braces for if and while statements
Maybe we don't need to print the stack trace if we can ignore it
If storeThread == null concurrent tryCommit() or deregisterVersionUsage() may change its value between get() and set(), they are not synchronized like this commit() method. It looks like compareAndSet() should be used here too instead of set() or something else should be changed.
style nit, put the { up with the if clause
nit: this line is long enough its time to split
As you are calling a method in the same class you may want to drop the "VmDeviceUtils." prefix.
please don't swallow exceptions. Re-throw up the chain.
This could be null, we should probably handle this if the JIRA api changes again
Are we guaranteed that non of these entries has a key = href? I think it would be safer and clearer to make the map key something like params.xxx
you should never use assertEquals, it's too error-prone (people flip expected and actual all the time). Prefer using assertThat().isEqualTo() every time.
nit: I think you can just declare Set<LockRequest> here
assertEquals(LOCK_TOKEN_V2, timelock.lock(LockRequestV2.of(ImmutableSet.of(LOCK_A, LOCK_B))));
can we refactor to reduce copy-paste with fromList?
Is it not useful to store this ordering as a static?
Let's add the number of requested buffer slices and the planned number for better debugging
looks like equalsignorecase is redundant as we are lowercasing both images anyway
Pick a consistent variable case (camelCase matches the existing code)
rancher/scheduler-windows starts with "rancher/scheduler". This wont work
Magic numbers here and in the line below
Why do we need the extension? I removed and tested it with abnormally large bases and it seems to work.
You typically want to avoid if-else blocks like this, and separate it into two different tests. One for PR and one for Replicate. The test class is ReplicateCacheListenerDistributedTest. I can't find any PartitionedRegions being created in this test. Does this belong in PRCacheListenerDistributedTest instead?
This is incorrect. If ps is null, you'd still need to close fos. You need to rearrange the try block to acknowledge the existence of two resources - nesting is the usual approach.
Sorry, I don't understand what conversion are you doing here to get the string for the private link
@wezell , missing return statement... This is breaking when compiling the code
Missing opening "(" before getDescription().
speces before and after "+" :)
rename to automationContext
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
This should return 1 if the time difference between start and end is > 0 (in any unit), to ensure we never round something to nothing.
Why the change from 0?
Nit, I don't think this error message is appropriate. I remembered @lei-xia reviewed this in the previous ticket, this path invalidation is not an error in the server. So keeping info (or warn) may be good enough.
Actually if we set the root path as below, we don't need to prepend the root slash, which is not that clean.  @Path("/zookeeper{path: /.+}") public class ZooKeeperAccessor extends AbstractResource {
shouldn't the bucket name be in here somewhere?
you touched that but did not change to assertThat? ;)
typo: Sored -> Stored
Would you explain how this tests late arrivals?
We should simplify this by replacing the if(x){result = true;} by result = x;
I think we should return DiagramUIPlugin.Implementation.getBundledImageDescriptor(DiagramImagesPath.DELETE_FROM_DIAGRAM_ICON) instead of create a new image on each call.
Prefer the usage of FrameworkUtil to get the bundle.
shouldn't you be using SESSION_INFO_LIST_TYPE here instead of going from an array to a list?
just noticed... the key cannot be soft limit if session id is null, please remove condition. anyway, even if so, this condition is unneeded complexity as bellow the key is set anyway.
please reformat. the line is too long.
bad replacement? (not sure about this one)
Extra ", "
Should use ToStringBuilder.
You may want to extract attribute.getAttributes() into something, so as to not repeat the call a few more times.
In cleanupNodes above we do a NPE check like: java if (nodeList != null) { // ... }  Shouldn't we do also here?
chields?
Two thoughts here, both 'nice to have' (it's also ok the way it is). 1) Since you're already cleaning up, maybe it's unnecessary to hold _result as an instance variable? 2) Perhaps fenceNode() should already return FenceOperationResult and not FenceStatusReturnForXmlRpc?
can you not append the vdsName in the message before calling this method? calling vdsReturnValue.getVdsError().getVdsId() - there's an assumption here that vdsId is set for all VdsErrors. is that a valid assumption?
you're assuming that getVdsDao.get() will return a non-null object. Could lead to NPE.
damn. Common.getProjectCache().get(change.getDest().getParentKey()) is faster here (avoids a database query), but its not promised if the client were offline. maybe we should just promise it will be there if we ever get offline support implemented.
if the project doesn't exist, get() returns null, so we NPE during getProject() before we can get to the null test one line below. sadly, if you want to do this proj == null test, you need to store the ProjectCache.Entry result, test for null, and only then can you do getProject() to obtain back the project entity.
whoa, you already have a database connection handle passed into you as "db", why are you opening a new connection handle?
This IMHO introduces a rather surprising piece of global state into the translation. What about extracting a relativeTo(namespace) method that returns the appropriate Function?
funky whitespace
Extract a method isArrayLike(symbol) or maybeHandleArrayLike(symbol)?
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Do this check before the for(), because if this.notificationConfiguration.isEnabled() or this.notificationConfiguration.areEmailsEnabled() are false, you don't event need to load the descriptors and so on...
Please use exception handler to catch the exception and remove try catch block.
Wrap in a if (Logger.isDebugEnabled()) check.
WTF is lala
where is assertion for this test?
"Finish calculating assignment." Usually, we don't like pasting code details in the log. Consider what if we change the method name in the future?
Print algorithm here as well so we know which algorithm we're using?
No need to assign per segment. Fetch the instances with the tag once, and construct the new assignment
You have insertAfter(..) and insertBefore(..) on DataTypeList and its View however use insert(Field)Above(..) and insert(Field)Below(..) here.. would a consistent term be better?
hmmm, maybe add another enum type for this purpose, instead of having null? (I'm not sure, just brain storming)
I'm surprised this is necessary. The regular check: if (!lhsDataType.isComparableTo(rhsDataType)) should cover this. Why doesn't it?
Please use case detection API from Protobuf.
You could maybe move that just before the if using it?
Shouldn't this ("Context.Event") be defined statically somewhere?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
please extract as constant
@ILikeToNguyen Why the change in visibility here?
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
no abbreviations
Just stumbled over this - can we get rid of true and false somehow? - enums maybe?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
Can be simplified to: return observable.timeout(1, SECONDS).toList().toBlockingObservable().first();
We can use TestSubscriber for that purpose.
Wouldn't it be safer to wait for some reasonable amount of time (30s) rather than waiting indefinitely?
Should this do a hasProperty() check if someone else calls this (thats not searchAndUpdateResourceType()) ?
The code here assumes that the ResourceType.getOrdinal() is always in the same order as the enum values. This might at one moment not be the case.. I would prefer to search for the ResourceType returning the correct value when calling type.getOrdinal()
Can't it be a constant? And you can size the set to 3.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I think I prefer "Invalid key" as exception message
Not sure idPos variable is really needed here
filename
suggestion assertThat( out.getShelve() ).isNotSameAs( in.getShelve() );
RU compatibility?
@xxDark can you link to the spec where all of this is explained ?
- this should delegate to call two functions above. - also, here name would be a bit confusing from displayName. Maybe @rongrong could provide suggestion.
Maybe a static helper function isStaticFunctionNamespace(functionHandle); also, why not functionHandle instanceof StaticFunctionHandle?
use rewrite than getVisitor
Here too, I think a DateUtil that goes from BigDecimal -> Timestamp makes sense. We may want to support that as  PDataType.TIMESTAMP.toObject(finalResult, PDataType.DECIMAL)  as this would be symmetric with the Timestamp -> BigDecimal conversion we support.
Subtle difference for the ptr.getLength() == 0 case. Return true in this case as an indication that the expression was able to be evaluated, but the answer was null (as opposed to returning false which means that you weren't able to evaluate the result because you don't have enough information). Often both cases end up evaluating to null, but during filter evaluation on the server side, where we're operating on partial data, it'll cause the expression not to continue to be evaluated as we see more key/values for a row.
Curious as to why you made PI a constant in the other class, but not this computation.
no need to catch exceptions. just let them propagate.
@yesamer Not sure about swallowing this exception that way: if we get here rawValue is expected to be a valid json, but if it throws exception, something bad has happened, IMO. "Given a json in String format, it try to convert it in a <code>JsonNode</code>. In case of success, i.e. the given string is a valid json"...: what would mean a "json in String format" but invalid json?
it looks like we were writing DESIRED_CAPABILITIES twice before
Why this change? Do we still need the doPrivileged?
Why do we need this ? Should be done by DublinCoreService
This looks like the new implementation, you should leverage current one by calling existing method with some transformation.
This should be atomic - looks like it was broken by INT-2856. There is a small timing hole where there's no recipients, or an incomplete list.
This whole block can be replaced with functional style Java, as per example given in Epdq.
This whole block can be replaced with functional style Java, as per example given in Epdq.
It seems busy to stream/map the list into a list and then join into a string. We can go straight there java .put(TESTER_NAMES, testnames.stream() .map(ProjectTesterImpl::maybeQuote) .collect(Collectors.joining(",")));
Isn't it better to resolve the unpack folder whenever it's requested not putting it into system property?
It seems like nulls make their way into a lot of collections in MISO... :worried:
You can make the return type here more specific so that you don't to cast to SchedulerTask elsewhere
It would be simpler to have a dependency collection Task (like base code) after each event tasks instead of making a long dependency list. It is more readable too. Also, it is confusing how the dependency is set if parentTask already have a child. So, it is better to have the tail of parent task chain to add dependents.
This should invoke the other constructor so that taskData can be marked as final.
@navis any reason this is changing?
The fail()method throws AssertionError which is an Exception. Either use ExpectedException or change your catch clause to catch the exact exception you are expecting
I think ; is a typo
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
Maybe some not-null check should be added here.
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
What if the server is not associated with a DC but rather with an RC
should return directly
It seens like the actual intention is to simply fail the test case rather than throwing the exception with can call Junit fail() method and return;
Please avoid unnecessarily nesting if blocks. This method could be written as: if (getName() == null) { return getPersonId(); } else if (getPersonId() == null) { return getName(); } else if (getName().equals(getPersonId())) { return getName(); } else { return getName() + " <" + getPersonId() + ">"; //$NON-NLS-1$ //$NON-NLS-2$ }
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
Did you compiled and notice the test passed? check line 1394.
Is this very time sensitive? We release "2", wait 20ms, then release "main". So on a slow machine (e.g. buildhive) the thread for main could record its message before the thread for 2. If that's the case, can we make this less time sensitive (if necessary by increasing pauses and marking as groups="Integration")?
unused
All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);
This is a little hack for me. Could we avoid these kind of hacks?
Please create a temporary directory and remove it in @AfterClass.
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
Should this return false? I thought we have the theory that blank counts as false, in general.
@vbradnitski the value can be NULL, will be better to use PRIVATE.name().equals(value) or Objects.equals(PRIVATE.name(), value). Also you can use ProjectReadAccessType.valueOf(...)
why do the values "true", "yes" and "1" equal true?
There are some project types that are not AbstractProject like Build Flow and literate, that could potentially be triggered by a gerrit event and have dependencies. I know there are other assumptions in this trigger about AbstractProject that causes problems in these scenarios but those should be fixed as time goes on (hopefully) and maybe we could try to avoid those problems here. Can we find a better class or interface to check for that also has getTriggers?
So, it was really an issue... :+1:
Just merge this with the else and make it an else if?
a lock is freed inside super.ExecuteVmCommand(); , it is means that status of entity in DB is changed after, the race is left
did you verify that flow? I'm not sure if the cluster is set on the template we get in the parameters
These is NullPointer
Unhandled
We can just use == instead of equals:  if (type == BOOLEAN || type == DATE || isVarcharType(type)) { return value; } if (type == BIGINT) { return ((Number) value).longValue(); } if (type == INTEGER) { return ((Number) value).intValue(); } if (type == DOUBLE) { return ((Number) value).doubleValue(); }
This filter allow any double value other than null, e.g. it doesn't filter anything, but nulls. Is this intentional?
Are we able to test this method ? Same for updateStateOfReplicas  method.
Actually, we will have to do this differently. Notice that the method that calls this, setReplicaSealedState(), is synchronized. That is the method that does the get and set, so synchronization should happen within it. So we need to make sure that that method synchronizes on the same object as the participate() call.
do you want to log the list too?
UnlockImage is performed anyway, so it can just be removed out of the if-else.
Why are class properties of parameters class set here? If this is something that is never filled by the calling side to the command ,why not define them and use just inside the command class itself? It can be confusing to the caller to see this object and wrongly conclude he needs to fill those parameters. If there is actually a need to fill those parameters from outside, then there are wrongly overriden here, and it's better to have a validation + appropriate error should be thrown if they are missing.
Use getBackend() instead
use enum name() instead of toString()
Check is cluster supports gluster snapshot?
name() and not toString()
typo
what happens when inputSchema is null? Also, to reduce indentation, we prefer:  if (inputSchema == null) { return; } // Rest of the logic ...
use fieldType rather than fieldSchema in the message.
Is warn sufficient here?
you have the batch service already as a class attribute
If we can't get the refactoring service, then we're going to spam the log for every notification. This should only be logged once: we should remember that the service is not available and not try again to get it.
Do you think this is non-useful? I figured there would be cases where people would want to test code that behaves differently if the SDK claims to be something really old that we'll never fully emulate.
Only very few parts of this function is tested, I think thats why codecov bails out. Are all these checks really needed? Specifically, the check for class equality will cause problems in case someone subclasses Package, right? Also the last two statements can just be written as return name.equals(that.name); To avoid a branch that would otherwise need to be tested.
missing that? >>!description.equals(description)<< always false
I think these all should go into your symbol table class eventually.
redundant ";" character
I don't think it is possible to have global stepping field. I don't see how that can be meaningful.
IMHO this should include a descriptive reflog update, since this is a local repository that a user might be poking around in. cf. the output of "git reflog refs/remotes/origin/master" in a repo of your choice.
style nit: no braces around single line blocks
inline the call?
do we need to ask service for current user role? cannot Principal be added as a method parameter?
This is the only place that add entry to the pool, is it the only way to fill the pool?
please externalize this message
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyTerminating = currentlyTerminatingMap.computeIfAbsent( category, ignored -> new HashSet<>() );
nit: following replacement avoids instantiation of a new HashSet object on each call to this method. suggestion Set<String> currentlyProvisioning = currentlyProvisioningMap.computeIfAbsent( category, ignored -> new HashSet<>() );
creating a set might not always be necessary, a collection should be enough for all the cases where we use getWorkerNodeIDs
If it is possible that provided URI is relative and this line throws NPE, argument can be used on the left side instead
you should use a local variable instead of reallocating the argument, IMO.
If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
Change to use Iterables.partition and return an Iterable
We don't need another ImmutableList.copyOf. You are doing this when parsing.
Doesn't the former condition mean that the Arbiter volume is available only for version 4.1 and lower? In that case removing the version check changes the logic and makes it available for other versions. The Arbiter volume should be probably removed completely.
You know that labelList.getItems() is not null since you just ensured they are not null above.
missing type parameter causing warnings RefList.Builder<Ref> builder = new RefList.Builder<>(refs.size());
As written, this inputStream will only be closed if any of the code above does not throw an exception. Normally to solve this, you would add a finally block after the catch, and close it there, so that it gets closed no matter what. That said, [whoever opens a stream is typically responsible for closing it](<LINK_0> Since the customer will be opening the InputStream, I think we should leave it up to the customer to close it.
Should we not just call the new train method from here?
@magicDGS Sorry, I didn't notice this before, but this would probably be cleaner as a try-with-resources instead of a try/finally, could you change it?
don't printStackTrace, call LOG.error("", e)
Can you explain the need for this?
How is it with .git files (not directories). Text files named '.git' which content is line containing the path in the local filesystem where the real .git file should be located. E.g. cd /tmp git clone --recursive <LINK_0> ls -la /tmp/gerrit/plugins/download-commands cat /tmp/gerrit/plugins/download-commands/.git jgit debug-show-dir-cache | grep download-commands
Might be able to get away with protected
One of requestingUserId or userId is superfluous here, because they are equal :smile:
I may just be missing it but is there a test to validate the setting of the identityProviderId via the get identityProviderId() method. A check on that seems to be missing in this test class?
Kind of picky, but this should be taskFragment instead of mTaskFragment
nit-pick: No good reason to check if view is already GONE, as there is no harm in setting it to GONE when it's already GONE.
suggestion Log.i("INFO", "Starting onClick on fab from FragmentDiets");
Can't you extract FS.detect() from the loop?
Putting it in this class will make it API right? If yes, it needs @since. Or we put it in a class in internal package.
If rev is null, what will happen. Shouldn't it bail at that point? Also, brackets are needed.
Can you also verify the error message? This way, the reader can easily tell what kind of error this test cases tries to check.
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
<LINK_0>
I would prefer to use same code as in method getProjectRelease  final Set<String> releaseIds = project.getReleaseIdToUsage().keySet(); for (string releaseId : releaseIds) { ...
@weisebrazil There should be only one return from a method
Can you replace IDs with names in this log message?
instead of transport!=null, could we use globalConfiguration.isClustered() ? when reading the line, it seems like we are avoiding a null pointer exception (like protecting) for an eventual transport null instead of something that explains that indeed it needs to be clustered to check it's a coordinator
Please delete the temp files you create, easiest way is by using IOUtils.newTempFile.
An AssertionError is completely inappropriate here. No Assertion was made and catching an exception just to throw another one serves no benefit here. You hsould instead properly log the exception rather than creating a new one that makes no real sense here.
Why the + "\n*"?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
java Iterator iterator = value.iterator(); if (!iterator.hasNext()) { // ... } for (int i = 0; iterator.hasNext(); i++) { Object o = iterator.next(); // ... }  is more effective.
I would put the return 0L here. This is probably the one and only place where you do not propagate the exception
I don't quite like how this could end up running forever without stopping, shouldn't we make use of versionUpdateMaxRetries for this cycle as well somehow (or some new variable)?
@vgkholla has a good practice that whenever there is an unexpected exception, we simply throw without cooking it.
You don't want to move them all to hamcrest?
Is this going to cause a problem upon restart? Should we log something higher than debug?
It will be good to provide details regarding original Jar that has a missing dependency.
It'd be better to do it as a fall-back only after the normal approach, as I suppose using the service loader is slower.
Seems this duplicates line 45
Let's make sure error messages are consistent.
Does it need to be public is protected not enough ?
Can we pass the URL directly to getNestedHtml , call the buildRequest and get the html ? So that i can just use getNestedHtml method directly. Also what folder structure do you suggest? Can we create a weibo folder and add all the request files into it?
This line is very long and complex. It would be better to externalize this check in a dedicated method in order to ease readibility.
This can be private, I think
rename to bit
Should this method be final?
rename to hostCandidate
Don't use old equinox state/resolver api. Will need to have a look at how this is implemented in org.eclipse.osgi.internal.framework.legacy.PackageAdminImpl.getBundles(String, String) to guide you
Why is this called cxfBundle?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
here too we could use getClass().getSimpleName()
There is a new utility in Java 7 that can make this a little less verbose. <LINK_0>,%20java.nio.charset.Charset)
Fedora uses 4 levels of hashed containers for identifiers, does it just use 3 for file storage?
This value could be changed during runtime to 0 which should abort it, not cause the thread to never sleep. How should a change from 0 to >0 be handled? I guess admins are used to clicking that reconnect button?
This will run every minute while Jenkins is connected to Gerrit, I don't think that is good, nor what you intended.
Remove or log.
Can we add session handle to log
Should we set queryname same as prepared query name?
The ctx variable is unused anymore.
you dont need this line You can simply do Metrics.newHistogram in the line below
rename this to spanTagCount.received
rename this to pointTagCount.received
This test should also test the case StringUtility.toString(null)
why do the values "true", "yes" and "1" equal true?
Right.
TRSRTransformation.identity would probably be better here. And new matrix only needs to be created in the "default" case.
Replace with retVal = wish1.getIndex().compareTo(wish2.getIndex());
This code performs unnecessary unboxing/boxing cycles. I suggest to use Comparator.comparingDouble(Number::doubleValue) as COMPARATOR, and special-case retVal == null
isUnauthorized 403
I believe the Auth system should remain on in this method.
Every time we change a JSON test using JSONPath a cute kitten is born.
Please change this hardcoded "btc" to checkerInfo.getCurrencyBaseLowerCase()
Use IllegalArgumentException or JsonParseException as those are what RecipeManager catches.
I thought that strict parser should generate orthodoxJson
If this sample is just displaying data from a URL then we don't need read_external_storage permissions
I think we can just move this out of the done loading listener, which would keep the table in scope
maybe call this a screenPoint for clarity
Do we show some icon If visibility equals to public? If no, why? I think it is not good behaviour to show icon for private project but not show some icon for public projects.
Use constant?
invert equals
If I may do some nitpicking on the name, the actual exponent is retry in this statement, the variable called exponent is a factor (exponentialFactor if you like).
Log as _error_ or _warn_?
typically, you don't use getters when inside the same class
I think its good idea to fail with meaningful errors instead of a potential NPE. Although, is this new contract necessary as part of this change? 1. Is it possible for kafkaConsmer.endOffsets(...) to return null in the first place? 2. If yes to above, have we seen any issues around NPE before or is this purely from the standpoint of defensive programming?
is this the only line that requires KafkaOffsetsRepository to return a mutable map?
suggestion LOG.warn("listOffsets request failed.", e);  Thanks! (minor suggestion to make the log message more typical)
API breakage errors. You should declare another method and mark for deprecation this one.
I would write a StringUtility.join that accepts a List<String>.
Using Charset.defaultCharset, whether explicitly or implicitly, is almost always a bad idea.
I think you could read the file contents with many fewer lines of code, especially in Java 8. Something like: java return Files.lines(filename).collect(Collectors.joining(System.lineSeparator()));
Please don't print stack trace like that. Either log it properly or ignore if the information is useless.
Please keep this TODO: only the parser is able to know accurately when to stop reading. (See the history of the go.starlark.net REPL, which is very similar. There were some strange failure modes of the approach implemented in this PR, even though it is strictly an improvement.)
'static' could be added, since it doesn't rely on any particular instance of the class.
use rewrite than getVisitor
ImmutableList.of()
The empty string in the constructor is redundant.
KualiDecimal objects are immutable, so it should be safe to set this variable to the original total directly. Also, I would suggest avoiding the doubleValue() conversion, to avoid the risk of having the calculations messed up.
You should verify with Sherry whether any special handling needs to be done if the object code has a value of "Pending Client" in the extract. I had to add some handling for that in the Collector processing based on the specs, but I don't know whether or not it applies to PDP.
Why this field is final ? It is only used in method scope.
It should be better to use == operator with the constant element as first operand.
I think that CSSDOMSemanticElemntHelper should be an Singleton.
String.format?
Does not compile, but not really important.
Check Args?
If getNextMergedRow() return null or a full row, then we don't need to translate from !isPresent to null.
let's do Objects.requireNonNull(predicate, "predicate is null"). I've also forgotten in in various places and will add them later...
selectedElement for better readability
Please use parent.is here!
@vilchik-elena what if parent is a parenthesised expression?
can be wrapped in one invocation : is method has multiple arity so no need for the ||
Make null-safe: if (m_decimalFormat == null) { return null; }
It's not safe to completely ignore an exception. You should always at least e.printStackTrace() so that other developers have an opportunity to find the exception in the console if needed.
Is this conditional necessary? Why not always store the origin?
*style*. same line
Instead of this, how about having @JsonProperty on the getSegments() method, and having the @JsonCreator constructor accept segments and make the map out of it? It should be equivalent but cleaner -- usually we try to handle serde through annotations.
It is OK to leave it and prevent the user from specifying 'LOCATION' when they use a CREATE EXTERNAL TABLE statement.
nice! Thank you. Really appreciate that and I think it's for the good
typically unknown stats were returned in such case, see com.facebook.presto.cost.ComparisonStatsCalculator#comparisonSymbolToLiteralStats. Also no need for format
I am not sure if inlined version is better
cache?
Entity equal?
remove +?
Ah this was meant to use the guava Lists
is it possible to use hash here to accommodate the case where gradle cache may have different versions of the same artifact present?
does this really need to be public ? (esp. now that the repository_map locking is removed)
Is the old method, <code>updateFeedbackQuestion</code> still used in the code?
Is there a reason why the variable is question1?
should be better if you test for null rather than catch a null pointer exception?
II think this code was also inherited but it might be clearer if the scope of this block was reduced to activity.getResources().getResourceName(item.getItemId()) and we just do a null check on resourceName.
I think only calling setVisible is fine here. We don't need to also toggle "enabled" if you also omit the enabled flag in the menu xml.
Casting to MenuItem is redundant here
This won't work... now your just breaking builds without proper checkout. Please make it throw AbortException.
How about putting the condition in the 3rd param to avoid duplication?
I believe the conditional above will need braces otherwise this is considered outside of the block and will always execute, which may not have been your intent due to the indentation. If you did want it to always execute, you should update the indentation to reflect that.
This should probably just be !parents.add(p) instead of !contains and then eliminate line 222. That would eliminate the double lookup and potentially detect a parent loop one step earlier (I think when a parent points to the original project)?
This loop does not detect and abort potential loops.
I think you should have implemented this method non-recursive as simple while loop. The parent line is linear and it should be quite simple. In addition, the non-recursive implementation would avoid creation of a new ArrayList for each level in the parent line.
There are a couple of copy-paste lines here and there, could you please refactor it a little bit? e.g. extract the reader.readEvents-reader.commit loops to a method. The assertion part (listFiles, checking the count, removing from the expectedLeftFiles, checking the emptiness of it) might be possible to extract too, to improve the readability of the code. (e.g. void assertExpectedLeftFiles(String... expectedFileNames))
I love LinkedHashSet's :-)
nit: the ArrayList size is know in advance, it would be nice to add as constructor parameter to avoid resize
Yes, what Tor said: Please add a dispose() in LayoutCanvasViewer and chain the dispose methods.
This seems to be causing NPEs on shutdown for me.
remove tabs
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
again I think you can use the diamond operator
I think we should close the StringReader after unmarshaling.
@essobedo once used variable can be inline
@piddubnyi full path LastModifiedCachingWire.LAST_MODIFIED
Can we revert back to ArgumentPreparedStatementSetter since OAuth2AuthorizedClientRowMapper will handle the reading of the BLOB.
Member variables should be prefixed with this -> this.databaseClient
Remove braces
Already adding network incompatible change, might be a good idea to encode more boolean flags into byte[], potentially also giving a way to add future changes. It's small amount of data so probably not really worth it as an optimization, but it would allow to add 5 new flags later while still allowing new clients to join old servers.
are you sure this doesn't cause memory leaks? There are enough of them caused by not implementing unloading force generated cubes (and these are just a hack to generate vanilla terrain). Unloading cubes is mostly done by PlayerCubeMap, which as far as I know doesn't care about any cubes it called unload for.
Why are you making storage and adding it to cube even if there isn't one?
I think we should create a defensive copy of the Map
can we call this ConjureBlockingLimiter?
Instead of creating a new RateLimiter for each file deleted, we can guard the rateLimiter.acquire with the null check.
Minor: use AssertJ org.assertj.core.util.List.list and static import for readability.
use standard assertions (no need of soft ones)
remove or assert ;-)
There is actually yet another error here: this should be java int start = Util.toIntUnsigned(getValue(ir));
As before, store this as a static final field, preferably in DataConstants or DataQueries whatever the class it is.
Possibly the better option (not requiring waitForSQSContainerToStart) would be to use different waiting strategy (reference: <LINK_1> java .withExposedPorts(80) .waitingFor(Wait.forHttp("/"));  withe the port exposed by sqs and end the endpoint pointing to the queue we're interested in (<LINK_0>
Will this be OK across different screen sizes? Should we put the 35 in dimens.xml?
Is there a reason why LinearLayout is preferred as the banner container? Is it possible to use FrameLayout since it will only contain a single view (the mChartboostBanner)?
Will be called many many times per drawer slide. Should use a flag to execute it only once per open.
Might be worthwhile to also factor this out into a method getInstructor to be consistent with getStudent below.
I think here can be more consistent with style by just using if as guarding clause.
Same as above, just return the 404 jsonresult with the message you need.
well, of course I can read the code and understand, but - still, maybe enum is better.
same question as before, about the value of heart beat..
i didn't see change in the config.sql to make this value per-version, so it's not ok to call it with version if its 'general' config
No big deal, but if you modify anyway, you can add a break here.
Extract if conditions into named structures (variables or functions), like isThread, ... ? (Especially the last one is difficult to comprehend)
![MINOR](<LINK_0> Remove this unnecessary cast to "LaunchManager". [![rule](<LINK_1>](<LINK_2>
Is not the status code to be Response.Status.INTERNAL_SERVER_ERROR?
suggestion "\nThe broker is either slow or in bad state (like not having enough replicas) in responding to the request, " +
Is it possible context.getAuthenticationInfo() is null or context.getAuthenticationInfo().getUser() is null
instead of creating a new StringBuilder object, you could maybe do something like: text.append("Date: ").append(date.toString())); (you might need "\nDate: " depending on what the line situation is)
return new StringBuilder().append()....toString();
return new StringBuilder().append()....toString();
Missed one
No need to convert OperationCanceledException to status. Just allow it to propagate.
Why not IStatus.OK? ("this status represents the nominal case")
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
Should be topic + partition.
Should this class be parameterized to run all tests both with and without HA?
Not important now, but I wonder if we should consider consolidating these core initializers into one so we only have to iterate over the beans once.
did you consider using org.springframework.beans.factory.ListableBeanFactory.getBeanNamesForAnnotation(Class<? extends Annotation>) here? org.springframework.beans.factory.ListableBeanFactory.getBeanDefinitionNames() should also work and is available in Spring 3
Is it really necessary to set prototype scope for EVERY Provider ? I do believe it can kill some logic if some bean of Provider.class should have singleton scope (in custom code for example).
We talked about using docker-fixtures for tests in this PR, though it is more work to set up.
You need to use a RunListener or similar to ensue that any locks acquired by a build are released when it exits even if the user forgot to use the release step (or forgot to put it in a finally block, or the CPS VM crashed and the build did not exit via the Groovy call stack).
is it should be verify(trigger).onPost(same(...)) (with matcher?)
these 2 for loops should be replaced by a single entryset iteration
Could be more reliable with a LinkedHashSet too.
Again, a null check for selectedRelationshipTypes?
The entire emails is the join link?
Perhaps we should stick to the convention of returning a 404 JsonResult here? Thats what I have been doing in my other PRs.
Rename to verifyInstructorOfCourse(...)? Or verifyEmailOfInstructorOfCourse?
Doing the refactoring of the OH2 bindings, this default implementation does not appear to be helpful. In most cases, the Thing is simply expected to go ONLINE once the bridge is ONLINE. This means that this method needs to be overwritten, so the question arises if super. bridgeStatusChanged() should be called at all or if the logic isn't reimplemented. Both variants are not really nice. I think we should change this line to ThingStatus.ONLINE as this will be the expected behavior in most cases. Whoever needs something else, should override the default impl. @sbussweiler WDYT?
As mentioned in <LINK_0>, I would claim that setting the status ONLINE is many cases a bug. In the example of the hue binding, the handler determines the correct status in onLightStateChanged. So either we do not set a state here at all and wait for the next update (triggered through the regular polling) or we set it to UNKNOWN for the time being. Same should be checked for the other bindings.
Hm, my understanding has been that the base implementation should look like: Java if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) { updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE); }
Does this one need to be changed to '...' too?
If the message is not what you expect (e.g. NPE with null message), the exception raised by the test will be hardly useful. Use org.assertj.core.api.Assertions#assertThatThrownBy:  assertThatThrownBy(() -> assertUpdate(...)) .hasMessage(...)
nit: both these statements can be included with above try (Statement statement = conn.createStatement())
May be you do not need another submonitor conversion here?
If it is clearer then method name clear looks more natural for me than remove
asRuntime(getRuntime()) doesn't seem very clear to me. Maybe asRuntime(getInternalRuntime())?
Immutable?
Generics on the right side are redundant since Java7
why not just return it directly?
cannot convert to double value, same reason
I am just not 100% sure why the conversion to BigInteger is needed here.
We cannot convert to Double for the same reasons motivated below.
As it's a nullable field, null protection would be good just in case: if (occurrence.isValidated() != null && occurrence.isValidated() != validated)
I think this should be isEqualTo (isSameAs checks that the integers are actually the same object)
filter alias more clear than select?
Why are you checking the members inside the compute block? I smell race conditions since the membership change does not have to lock this map.
a switch/case is more beautiful, but I can live with it.
This doesn't read very well, if partition handling is disabled I would expect to never have partially rolled back txs. Edit: I remember having a discussion about the names of some of these methods, I hope it wasn't me who convinced you to use this name :)
I'm not a fan of this solution - it creates an additional coupling between the different commands. How about the following approach - we should only update the status if the image is on a DATA domain: [pseudo code] StorageDomain sd = getStorageDomainDao().get(image.getStorageDoaminIds().get(0); if (sd.getStorageDomainType().isData()) { // update status to illegal... }
Please, consider to add image details in both log messages.
please use getStorageDomainDao() instead of DbFacade.getInstance().getStorageDomainDao()
It seems like we can add two storage domains at the same time
this method checks among other checks if domain is active, which is not exactly an image validation. Please consider renaming the method.
Since we already have the storage domain ID, can't we just use storageDomainDao.get(storageDomainId) and see if it exists?
This is actually adding functionality, since in 3.0 only system-disk is bootable. I think method should have an oldAPI flag, and in such a case break on the first system-disk and skip non-system disks.
please add brackets after the 'and'
after you changed that dao call the if condition is no longer neccessary the loop can be removed completely - replace it with use of Entities.businessEntitiesById
Should this be a write lock because we might delete the page if there is not enough space?
One concern here is if multiple threads can go into restoreOrInit.
pageStore is final.. it will never be null
Should be final
ImmutableList.of
Better to return a List?
Iterator could return multiple items erroneously and pass.
Again might want to check the iterator behavior here.
These assert are not needed here, the fact that append works should be tested elsewhere already.
unnecessary array new: {{true}, {false}} should work here
I don't think it can be significant in practice, but why allocate an array (presumably on the heap) just to read the individual cells and then forget about it? Using 4 locals (on the stack) would be more straightforward (and possible marginally more efficient, though it can probably not be measurable). The only drawback I see is to have to invent 4 names. (Note: same "issue" in the other class).
new Object[] is unnecessary.
We also have to override getEventHoverToolTipInfo(ITimeEvent) to call this, with the event's time. For markers...
Do we need to wrap this in applyResults()?
You could have a non-zero duration that still is hard to pinpoint with the mouse when zoomed out. It should probably just find the x-coordinate of the marker (start and end) with a threshold of a few pixels left and right.
The previous setting INSTRUCTOR_PERMISSION_MODIFY_SESSION is correct for previewing. This is correct for moderation only. Refer to checkAccessControlForStudentFeedbackSubmission.
If we remove the null check, will it results in NPE? (Line 74)
Need to check if instructor exists?
@linzhp why is this needed? after I removed the instanceof the tests are still passing, if this is really required can you update the test to reflect the case?: path instanceof BuildTargetSourcePath
Files.mismatch should do the job <LINK_0>,java.nio.file.Path)
Sure, you are right. This saves a stat call. Done
Yes, we rely on the I18nProviderImpl to be present and running. Not nice, I agree.
What does 'index / 2' represent? Would that question be answered by extracting the value to a variable?
nit, brittle test code smell. If we change this string in production code, this test will fail unnecessarily. Recommend extracting the string to a constant, eg:  @VisibleForTesting static String NOT_ALL_UNITS_CAN_MOVE = "Not all units have enough movement";  I wonder a bit too if maybe the string that is displayed should be a downstream concern. For example, if we were to internationalize the strings (not on our radar, but for the sake of argument), then it will be odd to have the dependency on the string value. Perhaps a cleaner API would return an enum result, then the consumer could map that result to a string. That would make this test read more like:  assertThat(result.getValue(), is(SOME_UNITS_CAN_MOVE));  The other two enum values I would presume would be:  ALL_UNITS_CAN_MOVE NO_UNITS_CAN_MOVE  This also avoids a good bit of nullable args. Nullable return types are essentially a SRP violation code-smell, they represent values that have different meanings depending on the value. IE: if null, this variable means one thing (a flag), if not-null, it's a display string for the user. Having enum values would then imply non-null return type, and code that is closer to the front-end could decide about which display string to use.
"positionX" and "positionY"
Nit: I think the mask is unnecessary, when you cast to byte the higher-order bytes will be discarded. suggestion out[i] = (byte) (msb >> ((7 - i) * 8));
static
Isn't this constant and shared across all producers? Then can't it be static?
Maybe it's overkill, but do you think it would be useful to have a test that tries to get partition N + K, from an event type with N partitions (where K > 0)?
We decided not to use this approach with Thread.sleep if possible, because it's unclean and sometimes can lead to very random behavior. Instead you can do something like: TestUtils.waitFor(() -> assertThat(client.getSessionId(), not(equalTo("UNKNOWN")))); So that you will wait for what you really need, not to abstract 1 second.
Better use ImmutableSet to avoid accidental changes. Might as well use it for the above method as well, should be a NOP in the general case where we are passing immutable already.
We need to have a backup plan here if type isn't a TypeVariable.
Per docs when null is returned, a message should be logged. <LINK_0>
Just remove the try/catch. An exception will fail the test.
Multimap returns an empty collection if the key is not found, which will simplify this code by removing the != null test.
Could you extract to a local variable the substring statement at least ? Thx ;)
Fix warning: suggestion KeyedMultipleInputTransformation<OUT> keyedTransform = (KeyedMultipleInputTransformation<OUT>) transformation;
I like that we create the operator here as now we push further down the runtime-related stuff. In the future we could have a translator that gives, for example, not an operator but sth else.
Why not making the following like:  Collection<Integer> ids = translateInternal(transformation, context); if (isKeyed && !isInputSelectable) { transformation.setChainingStrategy(ChainingStrategy.HEAD); BatchExecutionUtils.applySortingInputs(transformation.getId(), context); }  This will make the if () ... check being checked once. The same for the other translators.
Is it possible that the same project is added to the list twice?
can you make the name more explicit? array doesn't indicate anything.
this method can simply return this list
rulesList will never be null, widget#getVisibility always returns a list instance.
I know you just re-factored this code into another method, but I am asking myself why the getItem() method is called on the itemRegistry vs itemUIregistry in case of the basicui.
The method is "getItemFromRegistry", not "getItemTypeFromRegistry". Shouldn't the error message read "Unable to get item for item name {}" ?
Ditto (same for the new methods).
Collections.emptyList()?
Protected instead? Or, other extensions should be able to access/change the returned AddOn(s)?
MetaObjectStoreEnvironmentBean was added to ensure that our config bean changes were backwardly compatible with the old arjPropertyManager approach to config (ie did not break the old semantics of arjPropertyManager). I would either keep the old code or use arjPropertyManager instead (but the problem then is that we want to discourage the use of arjPropertyManager)
Code consolidation: You'll want to perform the toLowerCase() method here instead of the classes that call this findProgram() method. This increases reusability and ensures toLowerCase() is always called.
This is a bad pattern to follow, for a few reasons: 1. We have multi-catch blocks now, so there's no reason to do blanket catch like this, 2. This will unnecessarily wrap RuntimeExceptions with another RuntimeException, and 3. You should never call new RuntimeException(...); instead, pick a specific runtime exception appropriate to the circumstance.
Smells like a bug. Are you sure it should not be equals?
We need more tests. What happens here is what I've written about in email - if order by has non-literal columns, advice must be empty. We must not give selective advice to the sub=query
nit: I personally like to use for-loop rather than lambda when the mapping operation is non trivial :). But I don't have strong opinion here and it's up to you.
org.apache.commons.lang.StringUtils.isEmpty(String) is available for null safe string checking.
This causes the warning Plate is a raw type. References to generic type Plate<T,S> should be parameterized.
I think you should add proper custom error message in this case.
I believe the preferred method is to do one cache.get(nodeId) and then check to see if that result is null. I believe containsKey should be avoided.
For less verbosity, you can use switch on NodeIdType
You could use functional style expression like: suggestion return node.orElse(null);
Can you repro this on master? If yes - definitely worth filing.
it looks that collectOverriddenMethodsInInterfaces can be moved out of if else as it is called in both cases ?
namedElement.isPublic
Do we really need to make it info level?
suggestion
static
We shoul get the exception (most likely if different type as DynamicUtils is in jbpm-flow so ProcessDefinitionNotFoundException is not available there) here and then wrap it with ProcessDefinitionNotFoundException and rethow it
Could change to ProcessInstance.STATE_ACTIVE ?
one more 'L'
Multi return is forbidden.
@bsudekum Looks like you may want to set a style here via mapView.setStyle(Style.MAPBOX_STREETS) for example.
why not pass this in #init?
@kachayev one question... isn't this assuming that we are talking HTTP/1.1 ? I mean for 1.0 we would need to add the keep-alive imho
suggestion if (LOG.isDebugEnabled()) { LOG.debug("output body: {}", jsonResponse); }
@kachayev this is not correct as you already write a FullHttpResonse and so MUST NOT write an extra LastHttpContent
Same as before: the logic of filtering out NonBinding attributes probably should be external to this implementation.
suggestion return unmodifiableMap(properties.entrySet().stream().collect( toMap(Map.Entry::getKey, e -> e.getValue().property)));  needs toMap being imported statically
what about making resolveExternalServers(String) part of the ServerResolver contract so that we don't need to depend on native server resolver being a subclass of AbstractServerResolver?
I wonder in which case PUT is not found when updating Ttl for certain key. And it might be worth a warn here.
Can we create a variant of getValue(Class<T> type, String key, T defaultValue) that will handle the NoSuchElementException instead of having to handle the exception in all the getXXX methods?
instead of all this code you can call just this(indexDiff, null, null); then marking all members as final should be relatively easy ;)
Add a break to this if? Then, this condition is not needed.
This chunk here seems common to the three functions, plus the new Expectation.OnComplete<..> boilerplate. Maybe it'd make sense to have: abstract class OperationWrapper extends Expectation.OnComplete<OperationResult> { // implement onFailure here } Then the code here would end as: opResult.onComplete(new OperationWrapper() { @Override public void onSuccess(OperationResult r) { ... } } which is less verbose, and less duplication. Doesn't seem mandatory, but it would help a lot with readability for the next one to read it :D
typo: perfrom -> perform
Ew, that just looks icky. Admitedly less efficient ... bypassing the reservation but still not breaking the loop. Likely less than a microsecond of "spin" even if the pool had 500 idle connections. Reads much nicer:  java for (PoolBagEntry bagEntry : bag) { if (removable > 0L && connectionBag.reserve(bagEntry)) { ... } }
Try:  java final List<PoolBagEntry> bag = connectionBag.values(STATE_NOT_IN_USE); int removable = bag.size() - config.getMinimumIdle(); for (PoolBagEntry bagEntry : bag) { if (connectionBag.reserve(bagEntry)) { if (bagEntry.evicted) { closeConnection(bagEntry, "(connection evicted)"); removable--; } else if (removable > 0 && idleTimeout > 0L && clockSource.elapsedMillis(bagEntry.lastAccess, now) > idleTimeout){ closeConnection(bagEntry, "(connection passed idleTimeout)"); removable--; } else { connectionBag.unreserve(bagEntry); } } }
Why 5? With the minimum connectionTimeout of 1000ms this will generate a constant load of 5 connection attempts per second (200ms apart). / 2 gives a much more reasonable retry value.
I think that it would be better if the result message used "Space" instead of "OrganizationalUnit". What do you think?
how about propagating the failure message?
For mocking (even if not now) purposes I would rather have a getJobDao() method instead of explicit singleton call here.
id is the id of the container. so it means in the scope of this container "createItem." + this.getId() can be pre-computed for the container, rather than re-computing it each time. Could you pre-compute this in the container level.
Why decryption is excluded?
return should be one line below. The sample app crashes (wrong missing subscriber exception) as soon as you pause the app.
I'd use a different name, e.g. doStream
Missing types
Does this mean that we get an additional object per invocation? If so, then I'm not in favor of merging this pr.
I think everything from Optional<Status> statusMaybe =   could be replaced by: java return statusMap .flatMap(StatusMap::getToStatus) .map(status -> { if (status instanceof ChargeStatus) { return new MappedChargeStatus((ChargeStatus) status); } if (status instanceof RefundStatus) { return new MappedRefundStatus((RefundStatus) status); } return new UnknownStatus(); }) .orElseGet(IgnoredStatus::new);
getAggregateStatus and getStatusForNode are very similar. Consider reusing
would be helpful to have more context in log messages like this - like what method this is from, or what we were doing with this host in the first place, etc. In this case though is the log warning even useful?
This will not include the line break. Probably should append('\n')
It is the perfect case for a try-with-resources.
@vzool one more printStackTrace ?
Can the filteredHeaderNames be put into a case insensitive TreeSet? Then this nested loop could be converted to a contains.
Won't work correctly with:  FOO=something $FOOBAR
Prefer interface instead of concrete type. suggestion for (Map.Entry<String, Boolean> entry : privilegesMap.entrySet()) {  Same in other places
what about:  SELECT x, array_agg(y FILTER y > 1 ORDER BY y), count(*) FROM (...); SELECT x, array_agg(DISTINCT y ORDER BY y), count(*) FROM (...);  ?
It is a bug! Please notice that there is sort in array_agg(orderstatus ORDER BY orderstatus).
one param per line; leave the first line empty
should just be inside try block
shouldn't it be inside try?
Does the API guarantee all the Account in the returned array is non null?
this line is gone, why?
check is unnecessary
check unnecessary
Move this call down to around like 128.
if withTracker returns the generic type of the OperationContext (C in your implementation), then is it necessary to include the cast to CreateDirectoryContext? It just doesn't seem clean. edit - I looked into it and figured out the issue. Poor use of generics. Change the class definition of CreatePathContext to remove the need to cast old: java public abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>, K> extends OperationContext<T, CreatePathContext> {  new: java public abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>, K extends OperationContext> extends OperationContext<T, K> {
@ttddyy This can be simplified as follows: java String requestUrl = UrlUtils.buildFullRequestUrl(request); MultiValueMap<String, String> params = OAuth2AuthorizationResponseUtils.toMultiMap(request.getParameterMap()); if (requestUrl.startsWith(authorizationRequest.getRedirectUri()) && OAuth2AuthorizationResponseUtils.isAuthorizationResponse(params)) { return true; }
Typo: attemp_t_ToUpdate
ERR_DELETE_ERROR, add if there isn't one already
remove extra space around parenthesis for consistent styling
This is not required since you are checking for null in view
Any reason there are two of the same here?
Is setting entity based on app_mode also required?
This isn't localization friendly. We should move the word Error to our strings.xml file.
If the bug is that this is null at startup, that also applies to the above condition (s != null, results in a direct dereference), that should also be cleaned up before this is accepted.
Space after if. Same HC/ICS stuff as above.
This won't work on blockdevice. Take a look at how the StoreMigrator does it.
This will gonna delete old label scan store if that was used which is a nice thing. In the same time, we will not gonna create the new index as part of migration for those guys and people will be forced to wait during the startup, while they expecting everything is ready to fly. I know that proposed behaviour differs from how it was before at the same time that is something we had complaints in the recent past and as well it sounds like a correct thing to do. WDYT?
Are we sure we want to automatically purge the target directory here? Maybe we should say that the target directory has to be empty and fail if it is not.
We need to rework this method (replaceAntiCsrfTokenValueIfRequired) to ensure that we are able to extract tokens even if not previously registered (i.e. use ExtensionAntiCSRF.getTokensFromResponse with loginMsgWithFreshAcsrfToken, instead of getTokens and getTokenValue)
This throws clause is redundant.
We should also fail if the parameter is included twice. This can be checked using request.getParameterValues("access_token")
Docs (<LINK_0> you must always check isConnected() before initia...
Can you separate it into two lines as because of the condition in check style plugin i.e. you can't put more than 100 characters in one line, the build is failing.
Lets not create a the local variable and just: sendScreenState(pm.isScreenOn());
Number of rows of input does not change since we don't allow reshaping of layers. Thus, checking the number of columns is enough.
Free?
Why change to create?
Google's Java style requires methods to be lower-camel-case. e.g. convertChunkSourcesToModules() This looks like Python code to me. :)
prefer to use the entry set instead (peformance) for (Entry<String, FileModule> entry : namespaceMap.entries())
Explain.
this should be moved out of the try/catch at all filters
why is this ^ here?
no need for this variable
duplicate
This looks strange. I don't think breaking the line here improves readability.
log statementId as well?
HQL/JP-QL
nit: just Map
I think it would be better not to try to handle this exception.
Shouldn't we close the FileReader after the unmarshal? We could also pass the File directly to the JaxbUtils.
we should log a warning here so that users who have wrong permissions on ~/.gitconfig by mistake have a chance to detect the problem
Here we should do the same null check.
The original goal of caching file info is to make read faster by caching the fileInfo for read when we created the ledger, so here we probably need to put fileInfo into both write cache and read cache. And we need to increment refCount by 2 because we put that FileInfo into both read cache and write cache
Here handleEviction is not synchronized with getFileInfo which will cause race condition. Race Condition: 1. Thread A just successfully get a FileInfo from cache but haven't increment the refCount yet at line 221 "fi = readFileInfoCache.get(ledger, loader);" 2. Thread B is trying to get another FileInfo for read and cache is full, so it triggers eviction to evict the fileInfo which is referenced by Thread A. 3. Thread B continues to evict FileInfo and find out the refCount=0, so it close the FileInfo. 4. Thread A now returns the FileInfo which is already closed by Thread B. 5. java.nio.channels.ClosedChannelException will be thrown and cause serious issues
We could extract the duplicated file upload logic: FileInfo -> uploadedFileStorageName.
How many times are we going to visit each field? I have the impression that this recursion will visit attributes multiple times for no reason but maybe I am wrong.
getRawSignature is called frequently. How about caching its result?
The agg function here should be adjusted to support the optional compression param like in the quantile version
Failed to getTable
I think we should consider the case sensitivity here.
can this be narrowed to some kudu related exception?
isUnauthorized 401
isUnauthorized 401
isUnauthorized 403 ?
@CheckForNull
Superfluous check I think-it has been a long time since Executors were reused.
btw, do we need try catch around destroyProcess?
You might want to move this into a shared helper method for other tests which need a temp file with random data.
you need to close this directory stream
Do we need to close the InputStream?
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
It should be: combined.put(entry.getKey(), entry.getValue().toString()); With the current code I get: Parameter value [1] did not match expected type [java.lang.String (n/a)] With the fix it works fine. I tested on Hibernate 5.3.6 and querydsl 4.2.1 with this pull request applied.
let's use LinkedHashMap
Can we please add a CommonConnection.getAllRegionInfos(TableName) method instead?
Is isOnline a time-consuming method? It seems like we should change this to check every 10ms rather than spin-lock.
Please update this to 1 minute. This method can potentially be slow on the server.
cruft removed
One of requestingUserId or userId is superfluous here, because they are equal :smile:
Would it make sense to have a flag somewhere enabling this behavior? Perhaps per-client? There's no standard for that flag so maybe just adding it directly like this can work for now.
same in line 45
( List < TagEntity > ) entityManager.createQuery(... will be enough , as you just iterate through it below.
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
a lock is freed inside super.ExecuteVmCommand(); , it is means that status of entity in DB is changed after, the race is left
did you verify that flow? I'm not sure if the cluster is set on the template we get in the parameters
You don't want to freeLock() before that operation? Maybe you should also change status of template at DB to lock? Global transaction?
use Arrays.fill instead for loops
All of this can be replaced with an ExecutorService
For each?
why relaceFirst instead of replace
Prefer storing the compiled pattern as a constant for this class. Otherwise, we may unnecessarily recompile this regex.
This breaks the handling of Youtube URIs shared from the youtube app. These URIs are of the form <LINK_0> Didn't test sharing from the website.
Format this line
Why linked lists?
You have also check that it's impossible to gain data without encryptionSpi. Seems you have to provide a couple of spring configs.
you don't need the zone in the constructor but it's not that important, also you need to set the text since it won't autogenerate correctly
If you add condition hint to card then you can improve card's usability for users. Search for example: * .addHint(new ConditionHint(LudevicNecroAlchemistCondition.instance, "Player other than you lost life this turn"))); How to add: 1. Extract checkTrigger code to Condition object; 2. Use that condition in checkTrigger; 3. Add condition hint to ability. You can use same condition hints in your another PR (#6430).
Use {this} when referring to card names in text.
Maybe do the commonColumns same way you did in upgradeOutcomeTableRevision2To3 for consistency? Not a big deal just one way or the other so that they match.
Regression Image authentication: the logic here supports images of FeedItem, but not the images of Feed.
Maybe a wider exception would be better idea here if anything rather than sql exception happens. Since we don't deal with the exception itself.
why public?
unnecessary new line
getAllStackTraces() is quite expensive. Given that we have a cache in place, we should soften the actual impact. We should be able to optimize for the default logger arrangement. Typically, log handlers are called on the same thread as the logging happens. Therefore, we should call Thread.currentThread().getId() first to inspect whether we need to obtain all threads or whether we can resolve the thread without further do.
I thought that we did not need to have this mapping in the compute engine
Default size not necessary.
You can make this method more functional if you want :)  java return Arrays.stream(services).flatMap(service -> { Collection<Class<?>> serviceInterfaces = serviceProcessor.extractServiceInterfaces(service); return serviceInterfaces.stream().map(serviceProcessor::introspectServiceInterface); }).collect(Collectors.toMap(ServiceDefinition::serviceName,def -> "service"));
Replace it with something like this: LOG.info("Waiting for resources to get allocated for request {}, no retries will be issued since host affinity is disabled", request);
Can localityManager or readLocality results be null?
Don't need the hostAffinityEnabled check here. You can assume standbyContainer is present only when host-affinity is enabled.
Does it really make sense to have a plugin with multiple secure-stores ? What would be the rationale behind it ?
else is not needed. Remove it and you can dedent the block below.
This will create a new instance every time. Cache the instance in a member variable?
break the line
Does this do anything outside of test mode?
We don't have a test that covers all the browser action. Changing this here could cause a lot of trouble, unless you have exhaustively test all browser action. You need to change your implementation so that this can stay as it is.
again: removing the explicit initialization: worse, not better
I think inverting this if check would improve readability/flow and would be consistent to the other methods in this class
Better to catch exact exceptions instead of general exception
suggestion var service = getCandidateServicesToMatch(serviceId)
I missed this the previous turn, I think; when filemode is false both changes from regular to executable and vice verse should be ignored.
If you combine the last two return statements you might as well only have one. However, I think the old way makes the code easier to read/understand.
Should there be a check to make sure the asset is non-null before modifying it?
You should check whether the global entity already exists, or set it to not persist.
WDYT about making this a bit more flexible so I could specify something like image/\* (for all image mimetypes) ? I guess we could always add that later as it would be totally backwards compatible.
Shouldn't this code run even if mHasWifi is false?
You're claiming @NonNull for all these things, but not actually enforcing it with Preconditions.checkNotNull()?
Same here about the null check.
after this line, call collector.getOrThrowException() to stop execution if there are problems.
nit: it's more readable in these situations to do:  if (inputSchemas.isEmpty()) { return; } // rest of logic  doesn't make much difference here, but is more true if the logic within the block is longer.
why referenceName is null ? would this cause any issue @albertshau ? also is there any issue with using the same reference name from the config ?
Where is the aggregation?
Why do you remove this state? Isn't it safer to left it so that runJob() can avoid re-run even when an unexpected retry occurs?
actually there was a mistake in this string, I should have used T(java.lang.Runtime).getRuntime().exec( ..
Could we please update method name. I think the name should contain just **IfDataTypeIsStructure** or **WhenDataTypeIsStructure**.
Let's have some constants here instead of repeated magic numbers.
Explicit input/output of test setup methods can help make for more explicit unit tests. This method for example could possibly be changed to:  private Unit givenUnitWithAttachment(UnitAttachment unitAttachment) { Unit unit = mock(Unit.class); UnitType unitType = mock(UnitType.class); when(unit.getType).thenReturn(unitType); when(unitType.getAttachment(anyString()).thenReturn(unitAttachment); return unit; }  Then a test, for at least this, can be a bit more self-contained, eg:  players(); attackerRetreat(); Unit unit1 = givenUnitWithAttachment(mockUnit1Attachment); unit2(); final List<String> steps = getStepBuilder() .attackingUnits(List.of(unit1)) .defendingUnits(List.of(unit2)) .isBattleSiteWater(false) .build() .get();  In the above, it's pretty clear the usage of 'unitAttachment' is a side-effect somewhere. Following the above pattern should eventually have unitAttachment become a parameter or a return value of some setup method, so at least you could see where it is configured (which should make the test a bit more self-explanatory and self-contained). WDYT of this approach?
Shouldn't you be getting this option in a way similar to this?  java SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE); boolean force_show = prefs.getBoolean(FORCE_SHOW, false);  Accessing FORCE_SHOW directly is only targeting the String defined in PushConstants, and a String is always true'ish, thus making it not an option to decide on.
Oops, right.
Needs a better error message.
Can you move this functionality to IjProjectPaths?
Accidental debug string?
I wonder if the "connectionProperties" name is not too generic. iisHadoopConnectionProperties?
You can move the inner loop out of the outer loop so that you dont have to set all the fields for each split. That way you will be able to reuse the builder
please use the same error message as the LOG statement
pass e as the second parameter, so the entire stack trace is not lost.
Why the heck are we painting all columns ourselves? We only need to draw column 1 containing the graphical commit tree. This suggests a nice two-liner to fix this: replace above by event.index == 1 and...
The scheduler implements a command to restart a given container. Why is the scheduler not used here?
Wouldn't it be good to parameterize this instead of the raw type?
I think Local.ROOT is probably a better choice.
discussed a bit more, we're going to make both key-values, and make sure to split on just the first colon
Typically we use Map on the left hand side rather than HashMap
These first two test methods are identical except for the slice creation, and can be replaced with a single method and a data provider.
suggestion private static ReferenceContext getDerivedReferenceContextFromSlices(final List<Slice> containerSlices) {
The enclosing try/catch is redundant.
should this have a ,  to match the rest of the pattern?
Is there a reason for not using the MoreObjects.ToStringHelper instead?
If every other variable is in PascalCase, we should keep the convention in the file. Use TirePressureObject instead of tirePressureObject.
I think we should avoid printing stack traces and make the app crash... Could we setup an error activity or handle the error as transparent?
2-times the same thing?
Code style: We do not prefix method with this. Applies to other places in code too.
I don't understand what command parameters have to do with key bindings. The way you implement it you will also skip the adding of parameter values to the tooltip of menu items. Also, why is it necessary to distinguish between menu item and tool item regarding the tooltip?
In this case text.get() is the empty string "" - why are we prepending a newline here? Should it rather be: java if (text.get().equals("")) { return arrayText; } else { return text.get() + "\n" + arrayText; }
I'd replace this with a String join call -- it's more robust and is easier to read.
Can we replace these 2 lines with createTreeWalkerConfig?
<LINK_0> ignoreLines are empty by default, why mention it here ?
inputheader => InputHeader.
Why make it public?
I would say ID_OR_NAME, but it is not that important.
another nice bonus from making these objects independent of an argument, is that now you can create two static constants in the class, and save some cpu cycles and GC. e.g. private static RegexValidation CUSTOM_BOND_NAME_VALIDATION = new ...; and then ref the const's in the validate() method. A nice to have but not a must :)
still not a fan
Nitpicking: "with class" --> "of type"
Don't forget to re-add default TTL here probably.
LOGGER.info? Maybe LOGGER.warn?
This is a bit dangerous, as you may match *anything* that is ending with /monitoring. Example /myapp/roadmap/monitoring ... will end up in JavaMelody instead of displaying (example) the monitoring stations of a road-map :-)
With slf4j, we should use logger.debug("CORSFilter HTTP Request: {}", request.getMethod());. Note the {}.
remove !=null since null instanceof WrappedMessageContext will return false
Still this line can through nullapointer exception. Need to check all scenarios before sending pull request
nit: this line isn't necessary.
Please use ""
check if not null
Please consider to extract to a different method (like isInternalManagedDisk)
Use static strings.
so by this all labels are escaped so you are not able to provide HTML code into the report and with it will be displayed as HTML (eg link to external server in description)?
Should we assert a string valued parameter too?
Avoid variable names like event1
The client aims to be as non-intrusive as possible. Immediate notifications should therefore be used sparingly and only in cases where a user's immediate action is required. Let's say someone only has the client installed for chatting in #aeolus, or maybe he's a client developer who doesn't actually have the game installed but starts it very often. This user gets an annoying notification now, every time he starts the client. This is why we made it a PersistentNotification.
not clear names
There is something wrong with the button text. You set it to default here but it's not set to R.string.replace_bearing when we record bearing (only if we create the widget from scratch and there is an answer).
As in DateWidget you don't need this variable just return binding.getRoot() at the bottom
I think given you want to test the shared behaviour it's good to try and think hard about what the responsibility of onButtonClick really is here. For me what it does is ask for geo data for the widget. It feels to me like there could be an interface called something like GeoDataRequester or GeoDataFetcher with methods like requestPoint, requestShape etc:  binding.simpleButton.setOnClickListener(v -> { geoDataRequester.requestPoint(promp); });  In each of the different geo widgets you can have a test that the requestPoint or whatever is called and then those methods can be tested for some implementation of the interface (ActivityGeoDataRequester). Just to detail my questions here the though process I'm going through is: 1. I have shared code used in multiple places does it make sense to just test the behaviour in each place? 2. If not, what is the shared code responsible for? Is there some kind of interface/object/entity that could be responsible for that?
Before this change, we had the eventDeliveryLock semaphore which was only released upon receiving the ack. So if the ack is lost somewhere, the shard gets stuck for ever. Was there any reason why we didn't release it within restartFrom here? Looks like we are fixing that issue in this change. Shouldn't adding this step into the Semaphore solution fix the issue? What do we gain on top of that by this new solution?
let's update peekNextResult() to return PrefetchRecordsRetrieved type, so no need to typecast here.
nit : Make it more readable like. RequestId - { }. Applicable to all places
Ditto about interfaces
hostsPerTable.get might be null if beginCreateTable but finishInsert didn't. There is a race condition here I think
Why now is proper? If whole predicate is pushed down, then I would expect to see TupleDomain.none() here.
- Suggest we loop through the complete FontData array.
Shouldn't this font be disposed in the finally block after the addStringInPixels() call?
Same thing, using this method here may cause the getLinePixel method to return erroneous result, which may cause regressions in customers (I think code minings actually use this method extensively to compute where to draw for instance)
Should maybe be "SocketException has occurred"
main(), so STDOUT
suggestion } else if (statusCode >= 500 && statusCode < 600) {
May want to check CoreUtils.isNullOrEmpty, this may end up copying a 0 length array.
nit: you can merge both lines above as checkNotNull will return the given argument
You may use 8 * data.length - ByteUtil.numberOfLeadingZeros(data). And check the residual against 0 or 1
why it is not a constant!
Why not use the tmp dir here? If I'm saving videos with the "temp" option, I don't expect to have to clean them up later, but this line requires me to.
what is the need for a navigableMap instead of sortedMap? Personally, I would like to use the least specific interface that provides you with what you need.
An empty loop can be written as while (vcfReader.read() != null);
Remove blank line.
The first argument should be expected value.
as not found typo, should be  was not found
I think will be causing a lot of unnecessary debugging output and we could probably safely remove it.
As we talked @sbespalov , please take a look at tempArtifact and TODO over org.carlspring.strongbox.services.impl.AbstractArtifactManagementService#storeArtifactEntry method
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
remvoe this
How about using something like org.apache.commons.lang.math.NumberUtils.isNumber()
For my 2 cents going to 11 especially if it's inserted multiple times is likely to knock up against length/size constraints. I'd suggest just going nextint(1,2) here.
String#getChars probably faster than this loop
This line is not needed
This line is not needed
Would you please use assumeTrue(String message, boolean b), so failed assumptions have corresponding messages? E.g. assumeToolExists("du")
Is this a safety check? Whats the case where this would be null?
How about a private helper method to remove the above duplicated blocks? That method would take both propertyName and properties as params, to add property to properties if non-null.
stream isn't closed
pass in the metric registry
This change should be reverted too.
pass the metric registry? clusterMap.getMetricRegistry()
There is a pretty frustrating race condition here, unsure if it is worth fixing. - ModelAndConsumer cachedModel = localModelCache.get(modelId); returns from cache successfully - Model is removed from cache as it is only referenced by a pipeline (updated via cluster state change) - Search adds itself as a consume too late and it is evicted The referenced model from the get call will still be around. But the next call for the same model will load from the index again :/. The only way I could see of fixing this is locking here (which defeats the purpose of the fast get). Since the cost is low, it might just be OK to have this as it is recoverable later.
You know the model id here it self right? so why not add it to the message here.
Make this a debug log. if (log.isDebugEnabled) ...
Lines 95-102 should be at the beginning of the execute method rather than in an accessor.
I think this needs to be wrapped in Collections.unmodifiableSet()
Should be able to do a multi-id query using something like criteria.add(Restrictions.in("groupId", groupIds)) Current method allows for nulls to be included in the returned list too I think
Is this really what you want? If you get an exception, you'll be returning null for a query on a record that exists, but that can't be parsed.
(span == null || (span != null && span.serverSpan())) is the same as (span == null || span.serverSpan())
parentSpanId should be checked for empty, and likely for null
Would be good to remove some, if not all, of these log messages before merging.
Precondition to check page Offset is positive?
<LINK_0> - Class#newInstance() is deprecated in Java 9+
The format of the names is inconsistent, also remove duration.
should be just "display"
The 'Network' should be omitted from this context since this is not a specific provider.
Better to just add a throws to getPolicy and not catch IOException if you aren't doing anything with it.
This should probably go to System.err, as goes e.printStackTrace()
I don't think we need to retrieve a liveChatId here (lines 69-78). (The liveChatId is not used elsewhere in this method.)
.first(Audience.class) -> .getAudience() (audiences do have special handling in command causes)
Replace these the filter() and map() with .map(m -> m.get("configuration")).filter(Objects::nonNull). This will avoid double hashing/searching in the map. Same below for "bundle_location"
you're splitting the string and reappending it? Consider putting the operator in front to make it more obvious (and to format it better). ... or simply  java assertThat(map.mkString(", ")) .isEqualTo("(110427681, 5), (663160547, 1), (1571254982, 9)");
processInstanceKey.isValid() == false -> !processInstanceKey.isValid()
this is an internal API - @Nullable + plain return type would be sufficient
i'd think we don't want to use the 2nd level cache here as it might contain a stale instance - we only use the 1st lvl cach to bypass the 1s write delay..
Do we wanna add those array list into accounting? (e.g., inMapStreams)
Having a hard time following this, can we just make it "return dayFloor(dt.minusDays(dt.getDayOfWeek() -1)"? Sorry if I'm being dense, but I can't understand the reason for the withMonth/withDay/withYear code.
I think it might make more sense to log just the failure. I am not sure we are necessarily interested in knowing this was a valid value.
I'm not sure if the fix should be here but the current implementation raises an FP for:  "%%(key)s" % {"other": "str"} # OK. Pylint FP  The problem is that createFromPrintfStyle returns a StringFormat with 0 replacement fields, so we enter checkPositional and then raise because the rhs is not a tuple. Either the StringFormat should return Optional.empty() in such case, or this logic should be updated.
This code is an exact copy paste of the code just 20 lines above, can we avoid this :fearful: ?
If you use "%s".equals(formatPattern) there is no need to check for null first. "%s".equals(null) should be safe to use and return already false.
actualEntry should be a better name
Please move this initialization to the description method, since otherwise a lot of changed entries would result in a huge number of initialized controls.
The empty string in the constructor is redundant.
No need for a mock.
It is probably not necessary to use a mock here. One of the fixture in ServerFixtures should work just as well.
Optional nitpick: all these this-es are unnecessary boilerplate and distracting (for me :P). But leave them in if it's your preferred style..
You don't need this restriction and createAlias calls, I think you should have one restriction in place of the 2 lines above like this: Restrictions.eq("m.patient", new Patient(1)) Alternatively you can load the patient by the patientId first and use the loaded patient object in place of of new Patient(1)
Use Arrays.asList instead.
if you want you can use CollectionsUtils, such as list(Container.class, Template.class....); Also it could be a java.util.Set, the contains will be faster than a java.util.List.
assignedPartitionIds can get large. We may want to log the whole set only in debug mode, in case addPartition gets called many times on startup.
Do we need to collect this into a list if we're doing anything on the output?
Typo: reassigned
Is a service user required here? Doesn't the request require enough security context to be able to derive the Resource type anyhow? Could this simply be:  return resourceTypes.stream().filter(rt -> { if(slingRequest.getResource().isResourceType(rt)) { return true; } else if (slingRequest.getResource().getChild("jcr:content") != null) { return slingRequest.getResource().getChild("jcr:content").isResourceType(rt); } ).anyMatch();
We probably do want a constant for it in the metadata project in any case. I don't object to strings.
I think this should have type Cdr.WorkObject instead of FileObject.
Why don't you use formatCurrentTimeForId() here like the line 217 below? Likewise for the line 115. We can pass the time as a parameter to that function for general cases rather than just current time only.
Same chunk of code in 3 places, it should be refactored out into a method taking a user parameter. That makes it easier if someone needs to change it in the future.
Extract the "USER_ID" to a constant and make it more unique. The HttpSession can be accessed "everywhere" in a servlet container. For example: "org.everit.jira.timetracker.plugin.user.id.hash".
Shouldn't this code run even if mHasWifi is false?
Nit: while you're at it, this "this." is not necessary, I think.
this line shouldn't be there on this branch (sorry, forgot to mention)
Insert a space after if
Could we just make this sourceIsAvailable(source.getId());
This is already done to the initiator field
These should not be needed.
Not needed, the state of these buttons does not need to be reset.
Try changing the tip to this: "Abandon this name change and go back to the previous name". Post a screenshot on how it looks (I want to see if this tool tip is too long to display nicely).
check if you can use fluent api to add the storm tag
You shouldn't be modifying EventRefs in place even the model allows for it. We want our models to be immutable and someone could change content.events() to return a copy of the internal collection. Instead get the events collection, modify it and set the value back in Content
line 96 to 98 can be reduced to if (StringUtils.isNotBlank(eventOnChannel) && event instanceof ChannelTriggeredEvent && !eventOnChannel.equals(((ChannelTriggeredEvent) event).getEvent())) { This may also be a private method private boolean eventMatchesChannelConfiguration(event) so it will only be one if clause around the early return.
gt 120
this smells... never use NULL, never ever :)
gt 120
Why do you use fori loop instead of foreach? BTW I would use stream API here
no need to specify type on RHS
final, Lists.newArrayList(), etc
Any reason to use round-robin? Can't we just put a certain number of keys to split at once?
I don't get this? Why the need for the special case? I would say this is in the wrong place and this wrapper should not have to care about isTaskSideMetaData
Move this check into nextColonIndex instead of doing it twice in this method?
ArchitectureType.forValue(rs.getInt("architecture")
is this new line intentional?
Please create a cleanup patch to extract the mapper to a static instance as per <LINK_0> and stack it before this patch
Same here, Chat takes a token, not the access key. (Look out for CommunicationUserCredential which always wraps a token)
If you create a new HttpClient' all the time and start it, doesn't it need to be stopped again?
I think that it is better to shutdown dispatcher before evicting connection pool. There might be some probability that dispatcher would open new connection after evicting existing ones. WDYT?
codestyle - move ); to next line plz
@NonNull or Objects.requireNotNull?
suggestion Span span = tracer.buildSpan("JenkinsBuild").withTag(DDTags.SERVICE_NAME, "jenkins").start(); // Add span to cache in order to retrieve it in the endTrace method. DatadogUtilities.severe(logger, null, "startTrace - Cache key: " + buildData.getBuildId(null)); DatadogTraceCache.cache.put(buildData.getBuildId(null), span);  You don't need the scope here since the interesting work is happening after this method returns. You may consider adding the build or job id as a tag to the span.
This message looks a little bit misleading, or am I mistaken?
Typically lock() before try.
also here, try to keep tests simple pls
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
This loop does not detect and abort potential loops.
Replace with SubMonitor.convert
Never handle exceptions like that. If you can't handle it, request user help, or rethrow it, thel log it via plugin activator.
Wizard shell
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
let's change this if to - if (Guid.isNullOrEmpty(storagePoolId) || !FeatureSupported.refreshLunSupported(DbFacade.getInstance() .getStoragePoolDao() .get(storagePoolId) .getCompatibilityVersion()))) end eliminate the else cluse from line 105.
In case of passed Guid.Empty pool id we'll get a NPE here.
Why assugning this and not just using storagePoolId
extract into method?
lowestTimeAxisOffset is used above. Looks like a bug in findbugs.
why not pass this in #init?
per the style in rest of this file, add a space after "if": s/if(/if (/ and same for similar if statements below
Style-nit: We avoid { on if/for/while/etc. when there is only one statement in the body.
< 0 doesn't seem like a great overflow check, maybe be more explicit?
I think you need a tearDown method to ensure that Locator and Servers are all stopped in every VM even if any tests failed. You could probably move destroyRegion and destroyDiskStore to tearDown as well (or remove them?). Close clients 1st, then servers, then locator (see the order of VMs in Arrays.asList):  @After public void tearDown() throws Exception { for (VM vm : Arrays.asList(getVM(4), getVM(3), getVM(2), getVM(1), getVM(0)) { vm.invoke(() -> { if (clientCache != null) { clientCache.close(); } if (LOCATOR_LAUNCHER.get() != null) { LOCATOR_LAUNCHER.get().stop(); } if (SERVER_LAUNCHER.get() != null) { SERVER_LAUNCHER.get().stop(); } clientCache = null; LOCATOR_LAUNCHER.set(null); SERVER_LAUNCHER.set(null); } } }  You'll need to hoist anything (such as clientCache) to be a private static field/var in the test class so that you can reference it from tearDown() to close it.
You typically want to avoid if-else blocks like this, and separate it into two different tests. One for PR and one for Replicate. The test class is ReplicateCacheListenerDistributedTest. I can't find any PartitionedRegions being created in this test. Does this belong in PRCacheListenerDistributedTest instead?
This may be shorter: a = a.deepCopy(); b = b.deepCopy(); if (a.resultStart > b.resultStart) { Region o = a; a = b; b = o; } We are OK with overwriting parameters entering a method, especially when the parameter isn't ever used again. Here a and b are dead once the function starts. Its less confusing to just overwrite them and reuse the names.
Why did we switch out the old code back to this?
check not required
Could be static.
Variable with constant like name.
Minor nit; it's better to iterate over the entrySet(); especially since we're now making two passes.
Do we really need a new decoder for each fromBytes()? Could we at least use a single VerifiableProperties. Seems strange to have to create 3 objects for each conversion.
this might not be true for 'executeDelete()' when we implement Multi object delete API. Change this to executeDelete() itself taking the content length.
You would need to error out or S3 service to error out, not to delete with Set()
Having execute{Head,Get,Post,Put,Delete} are just wrappers to execute() for convenience and readability across APIs Spreading the logic of type checking will lead to confusion in future and its not a good idea.
Since there is a default hardcoded test resource group you can get rid of the null or empty check and just use the following here. java String resourcegroupname = Configuration.getGlobalConfiguration().get(AZURE_RESOURCEGROUP_NAME, TEST_RESOURCE_GROUP);  This is effectively a get or default.
Is this line always safe for NPE?
Arrays.stream() might be easier, and the collect call should be on a newline. Maybe something like: java try { return resourceGroupManager.getResourceGroupStateInfo( new ResourceGroupId( Arrays.stream(resourceGroupIdString.split("/")) .map(ResourceGroupStateInfoResource::urlDecode) .collect(toImmutableList()))); }
:ant: multicast is one word.
Why Level.CONFIG?
No if block required here either.
We need to test the regular constructor without a custom serializer.
Will this bring lots of printout? Is this for debugging purpose?
break the line
please fix
now we can use configName
Make sure to actually set the smoker, diabetic, and alcohol values in the PatientItem being created here.
This condition is hard to understand. Do you simply mean if (addressModelNode.isDefined()) ?
This should probably return different implementations.
shouldn't we be logging this instead ?
Should anyone be able to create a new instance of reference instead of GitProjectSetCapability? I would rather make it package-level.
Any possibility of the module string being group:artifact:extension:classifier:version or group:artifact:extension:version? i.e., do we require custom modules to adhere to the 'exec' convention?
tokens.length >= 2 ? .....
please dont remove explicit initialization
Lets not throw too generic exceptions (even just IOException is better), catching Exception catches RuntimeExceptions also.
exiting, so STDERR
This is the line of code from the else branch. Since the version is above honeycomb you should use findPatientView = (SearchView) mFindPatientMenuItem.getActionView(); from the if branch.
Does mLoginListener need a null check?
Since we'll handle the search behavior in <LINK_0>, we should probably remove this addition to keep the changes in their respective pull request.
Should never happen btw
Following the logic below, couldn't this be a set ?
If from can't be null don't declare it @Nullable.
As above: private, 100 chars, use error result instead of doOnError.
This can probably be shortened to:  case R.id.notification_filter_unread: case R.id.notification_filter_all: case R.id.notification_filter_participating: mAll = itemId == R.id.notification_filter_all; mParticipating = itemId == R.id.notification_filter_participating; item.setChecked(true); reloadNotifications(); return true;
Does the constructor need to be fully qualified?
This handler is not used at all, please remove it.
I think in this class it is possible.
This block is common to all tests in this class and could be extracted to a private method, parameterizing the name of the process
Re-use temp file
delete on exit?
java @Rule public TemporaryFolder tmp = new TemporaryFolder();
In the #valueOf(int,int) method, we could simplify the resulting bytecode slightly by eliminating i and using fromIndex as the index variable within the loop. As in: java for (; fromIndex < count; fromIndex++) { ...
brakes will definitely*
move this change to the previous commit
what is this close and open curly brace doing?
reverse params order.
Should be done via a logger
Cosmetic: please align this path parameter with the annotation above.
Cosmetic: Could you please, chop these parameters as one per line and indent them properly? Thanks! :)
More like "Closing .....", not removing, right...?
This is convenient API, but I worry that this obscures the configuration properties outside of code... like if one is manually editing the config file or using the shell to set properties... the code doesn't match the literal property names people use elsewhere. I think a better implementation is to stop requiring properties to be prefixed with "general.custom" and allowing them to have any arbitrary property name in our config. Then, we just let SPI implementations do whatever they want for their property names.
isBlank is another one that handles nulls
The thread pool should be initialized only if stats are enabled.
Only the Lower/Upper constraint should be disabled. In this case, unrelated constraints on the same element will be ignored too
I don't think this will work: collaborations aren't roots of the resource. Some kind of package will be the root of the resource. Probably a resource.getAllContents() iterator is what is needed.
nit: this doesn't have to be done in this PR, but how about making JsonIterator a CloseableIterator? It already implements Iterator and Closeable so it would be pretty simple.
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
I would recommend putting these strings visible to the user in strings.xml
"our" => "out"
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
You should use ThreadContext.putAll() here.
trade off here but I would trade the possible ClassCastException against one uncovered case (that should throw an IllegalStateException )
It's probably easier to test presence of annotation by using symbol metadata:  SymbolMetadata metadata = classTree.symbol().metadata(); Stream.of(JPA_ANNOTATIONS).anyMatch(metadata::isAnnotatedWith);
fileContainsStarImport is more accurate.
Label should be reporting.parameter.onOrAfter
This looks fine, but we should be consistent with how we are exposing parameters from our libraries. I would vote for either: a) Exposing all parameters with the names that they have in the underlying Java classes, so that people know what to expect, or b) Same as (a), but always exposing certain properties with standard names (eg. startDate, endDate, location). With this in mind, I would favor simply exposing all parameters as they are named, modifying only onOrAfter=startDate and onOrBefore=endDate and locationList=location @djazayeri did you have other visions for these libraries and how they expose parameters?
This location parameter should be renamed as in other methods I think
Flush after you write the data....same thing for all the places you write data.
you directly use the member variable tcpSocket, but shouldnt it be the parameter socket?
HttpServletResponse.SC_NOT_FOUND
What do you think changing the name to memory. We do not know whether it is in kilobytes?
why changing the behavior here? what's the motivation around it?
well i wrote this in the patch with the bug fix, but again here: "does it still make sense to log the attempts? it will always be 0" a better log might be "Recovering host {0} to up from error state"
Missing final
Missing final
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
This is already done for you by the super class you extended
let's promote these to variables so we don't have to always cast them
you can skip the exception, no? just set header and error here?
Any reason to use an unmodifiable list as the list is already a newly created one?
If there is a problem with one of the channels this would just silently remove that one. I think we should let the exception out and make the whole Source removed from the config.
Is there a purpose of having the FederatedSources and OAuthSources living in separate variables? For instance: in this getter you combine the lists, so I'm wondering if combining the lists would be plausible for the class as well.
no longer necessary, after changes in xml.
Can we put the string "currentContent" one place and reference it here and in transitions
Suggest you rewrite this to hold the ITitleable in a local variable, and call setTitle once. This will simplify the code.
I wonder why it is fine for DoubleValidation if the value is not String or Double? IIUC it should not pass the validation if you send here any other object that has nothing to do with any number. IMO you should check if the value is String or Number, if not return fail.
Just to keep the logic in a same class, why not move all this in the prepareValue method. You would need to pass the operator, but that's fine. This class wouldn't be modified.
Why did you get rid of using luceneOptions?
Good catch. But I think we should still replace the File.separator with a ..
A List<String> would probably be simpler to use as return value
Added code to print an error message and exit.
Please use a instance-variable for the version, this way we can configure it for each service instance separately. Also extend the service-descritor to support the version-field (and add a default-value)
Did you already tried it with a project stored outside of the workspace location?
We shouldn't catch any IllegalArgumentException here. Can you change DottedVersion.fromString to throw something else, so that we catch a more precise exception? (using an unchecked exception is probably simpler to avoid changing the call sites)
I think it would be safe to use the ArticleIngestion object's timestamp as the return value here. Because the previous version did return a timestamp for caching purposes, this may be important enough to avoid degrading.
Since this method uses a Transciever to respond, should it be named 'serve', not 'read'?
RuntimeIOException maybe?
This inner block down here belongs up with the first block which starts setting productsChanged. The lower if block makes changes based on that state and should no longer be flipping the value anymore.
This block has shown up in another PR, which is a sign that we have dependent work, and is something we should strive to avoid in most cases. Additionally, database operations are slow, and lookups should be avoided in loops if at all possible. Change this to a bulk lookup.
Use null instead of Collections.emptySet() here
break the line
question: are we forced to use the toString() as serialization? if not, I prefer two methods: serialize() and deserialize(s) instead of asymmetric toString() and getValue(s)
please also add the GUID which is important.
What do you think about putting this in a class constant instead to improve visibility/maintainability?
Please do not hardcode strings. Add static field TAG with class name.
Will this work if I am trying to put a jar in the place of a non-empty directory? Which is the case when an exploded bundle is partially copied into storage I believe.
It would have be easier to review if the refactoring to use an ExpectedException would have been done in another commit
we should at least break here, possibly even return this and avoid the duplicate, shouldn't we?
can't you just return null ?
use for (Map.Entry entry : activeConnection.entrySet() ) {
Code has blank lines, please remove them and format.
It looks like if the user provides the username, password and connectionURL in the dbcp config file as well in the runtime properties, the values from dbcp config file would be ignored. Is that the expected behavior?
Hi Martin, I'd rather do that in a later change. I tried to do it in this change but too early and it led to too many modifications, so I prefer to postpone it. I think we have a weird interaction between MergeMode, that we seem to use in the UI to set the markers on Diffs once they have been merged and the DifferenceState. It seems very likely that setting the DifferenceState to a proper value (either MERGED or DISCARDED) would allow us to not use the MergeMode in the UI to compute the icon to use on a merged diff. I want to take the time to consider all that fully.
ms
start
There are other places we perform the same validation. any scope for reducing redundancy?
Do we need to do another lookup here? We have the consumer already, is there a reason we're not just translating it straight away?
verifyAndLookupConsumer will throw an exception if it is not found. The null check is not required.
I think we should leave the NoSuchMethodException here and just wrap it in a FacesException.
You can use ReflectiveOperationException for most of those, and SecurityException is already a RuntimeException and doesn't need to be re-wrapped.
you can make it public for not to use generateArtifact(packageId, packageVersion, 0) method calls below
please directly call CrashReporter.sendUnhandledCaughtException(); and remove the utility function.
if you use "android.R.string.ok" there is no need for changing the strings.xml file
catch more specific exception and it is good idea to log the exception
is this needed for the test?
since this persist is triggered by the maxRows config, would it make sense to persist the one having the maxSize ? as the oldest one may have very small number of rows.
As you already need to touch this file, I think this empty line could be removed.
I discovered sometimes I do want to enable displaying SPARQL. Maybe not for this patch, but is this log level the best way to make it easily accessible or we need to do something else?
why retry?
Catching JsonProcessingException here will encompass JsonMappingException and JsonParseException. Or catch both explicitly.
space after if.
Please change to "clear tokens from local token cache for the user".
Is there any reason that we put the installation check here instead of canSwitchToBroker or other upriver functions before talking to broker?
I think you have an additional "\n" at the end of the new error message.
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
I think Local.ROOT is probably a better choice.
wrapping
Here, you are using DEFAULT_MAXIMUM_BYTES as an un-configurable hard limit (as well as DEFAULT_MINIMUM_BYTES). Meanwhile, you have the configurable fields minimumBytes and maximumBytes. Sometimes you used the DEFAULT_* constants as defaults, sometimes they are hard limits even here or for configurating the *Bytes fields. It shall be more clear which value is a default, which is a hard limit and which is configurable.
I think we can even simplify this a bit, something like:  private void initializeFromOldBits(CircularBitSet oldBitSet) { int startIndex = oldBitSet.occupiedBits <= size ? 0 : oldBitSet.occupiedBits - size; for (int i = startIndex; i < oldBitSet.occupiedBits; i++) setNext(oldBitSet.bitSet.get(i)); }  What do you think?
Should this be try with resources? I don't see the reader closed
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
This is not going to work as Keycloak may be exposed on a different context-path on the reverse proxy. I.e. frontendUrl could be "<LINK_0>" while Keycloak is listening on "<LINK_1>".
Maybe isSame()?
Rather than round-tripping this parsed URI, we could introduce a transient final instance variable parsedUri which would be set by the constructor and used by getInputStream().
Does it need to be package private? Can't we make it just private?
flatMap that stuff
minor: maybe we could simplify this piece of code by unifying into a single 'if'?  if ( (varArgs && arguments.size() < parameterTypes.length - 1) || (!varArgs && arguments.size() != parameterTypes.length) ) { return null; }
This means you're also trying to manually get things from the media folder if a file has no prefix? Why? Also consider that if a jr://file/ URI is set, for example, you'd end up with a path that looks like /path/to/media/folder/jr://file/name
I think we could cut out a lot of the mocking here by having formsDao.getFormMediaPath just return a file path to something that doesn't exist. You could create a temp dir (using File.createTempDir) and then return a path of a directory in there (that you don't create). Then we wouldn't need to mock a File or FileUtils and listFiles might even work as just a static helper rather than needing to pass in the util as a dependency. What do you think?
Keep a list of these directories and delete them in a @TearDown method. Currently this leaves junk in /tmp.
Can be possibly moved to shouldShowLog of PageData class so that all the checks for whether a emailLogEntry should be included is located in one place.
Not sure if related but maybe add some logging if the exception occurs.
I assume this is left over from tests
This step is same for standalone as well as domain ;-)
same as above; why allocate a new array ?
Its probably clearer to call this variable allowedClassNames, I had a long look at the if/else logic because classNames.addAll(desc.allow) is in both the if and else. I understand now because its building a list of allowed class names.
nit - for me creating ke is unneeded. Create the exception directly as the argument
don't we need to update metrics for this as well.
This is not correct. _Always_ re-set the interrupted state of threads. The break statement exits the while condition.
it sounds a bit strange to use PSK_LENGHT_BITS constant for virtualHost length.
what classes are we accounting for with isAssignableFrom?
The bytes can only be cached if the backing buffer isn't reused. If it is reused, then the backing buffer might change and cachedBytes could be stale.
Should be updated to use getSupportActionBar() instead of getActionBar() as in the [guidelines](<LINK_0> to ensure backwards compatibility.
why is it adding null?
refactor into class variable
We're still violating encapsulation principles here. We don't want to modify the collection and assume that's going to be retained. We should be building up the content and then throwing a new collection at the DTO, or figuring out a way to return the addContent method back to the OpenAPI DTOs.
The blank lines before and after method bodies are quite strange. We don't have rules about that but it seems inconsistent to me. It could be valuable to have feedback from others.
You're not passing in the message even though you have a marker there. Think that might throw weird RTEs.
use rewrite than getVisitor
Looks like validPushDown logic can be folded into extractDereferenceExpressions, e.g. extractDereferenceExpressions can be modified to extract only "valid" dereferences.
add unmodifiableList
The duration variable should be qualified with the this keyword.
Cloning after calling getEyeLocation is unnecessary
Can this be private, or is there another use case for default attribute outside the builder's call?
shouldn't we have an array of configs (just like the others)?
A future commit introduces a RowType enum. Is there any reason that change is not part of this commit?
not needed, can't happen (don't trust your IDE on this one ;))
The other formats are actual formats (HTML or MD) whereas simple is just plain-text. Maybe instead of simple, it could be txt or text for plain-text?
Could you add info in the docs on the valid output formats?
Why do we need the scheduler address? It should come from the Hadoop configuration.
Please use com.palantir.logsafe.Preconditions. Granted this doesn't have any args, but it does mean the message will be visible in our internal logging infrastructure without us having to trace back by class and line number.
Could be static.
can you add nullable annotation
Spatial reference is always null, hence, drop this variable is use null below.
let's declare this variable when it is ready to be used
The value is validated 3 times in this function.
Perhaps we could compute time.milliseconds() once at the start of this loop and pass it down to selectReadReplica?
How are you planning on setting this flag? Does the application need to know whether fetched offsets have taken into account ongoing transactions?
This condition doesn't exist anymore?
Same as above, maybe I misunderstand something
Should not it be "5" ? Else you can just do something like assertEquals(results.size(), moduleGroups.size())
As this only happens once and doesnt get any changes that an entity gets, would it be better suited to find all prefabs with ModuleConfigComponent? Now that I have tried it, how do you create the entities at all before preBegin? I tried the AutoCreateComponent, but that didnt work. I must be missing something. Using prefabs instead of entities made it work well for my little test. Could be a good way going forward.
May I suggest a pre-check for getParameterCount() == paramTypes.length in order to avoid possible allocations coming from getParameterTypes()?
feels a bit weird.. just below here you are asserting whether the method starts with "get".. Perhaps move isFluentSetter round or make it just isFluent
Add the original exception as cause.
This can be simplified by using the Kuali's DateTimeServiceImpl
This is wasteful. It goes to all the effort to build an exception message before testing the condition! Just do  if (put != null) { throw some exception }
Can put the closing single quote as part of the subsequent String
I believe that setters normally return the type/value they just set as well.
This is generated code, please remove this or adjust the EMF code generator.
I don't think these are mutually exclusive. The manual shows them here: <LINK_0>
please include the VM's ID as well
please add brackets after the 'and'
please use getVmtGuid
Not that it matters but it would be "sourceFile"
Files.write is deprecated. Please use Files.asCharSink: suggestion Files.asCharSink(toFile, Charsets.UTF_8).write(moduleInfoJson);
Minor: please move private utility methods to bottom.
Please change the line 38 to also use EnumMap<> for consistency.
I think this is a typo -> this.high < this.high -> should be -> this.high < other.high ??
Can this be private, or is there another use case for default attribute outside the builder's call?
Shouldn't we rather compare the whole sequence data?
Logging in Biojava (since Biojava 4) is happening through the slf4j interface. You should change this to use slf4j. You simply need to import on top:  java import org.slf4j.Logger; import org.slf4j.LoggerFactory;  then declare a static variable for the logger:  java private static final Logger logger = LoggerFactory.getLogger(Hsp.class);  and then use it like:  java logger.error("Unexpected error, could not find compound blah blah ", ex);  See for instance org.biojava.nbio.structure.StructureImpl for an example of the above.
@JamesRTaylor Could you also take a look here to make sure that the method is called with right parameters? And is there a chance (and a need) we can avoid creating a new "Statement" each time?
isnt segmentsMapToFind? (not Maps)
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
The unit tests seems to imply this, however I'd like to confirm; this method is only for writing custom properties, right? Since this is a generic JsonBuilder, does it have any sense of what "properties" are? Or is this just for writing any generic subtree of the JSON object?
This part of code (up to line 370) could be extracted to the end of the method. Currently it's duplicated.
You could extract true/false to constants to improve readability of this part (or maybe there are already corresponding constants in Idea SDK?)
close in finally
NP: As this is now abstract, it should say "...json data for component ...".
speces before and after "+" :)
Initializing as null is redundant, remove redundancy.
maybe we could open another commit/pr for this
Shouldn't this return the handler registration object to allow destroying the associated handler?
Change the event to preinit and use getModLog instead
Cosmetic: Curly braces on new line.
Can this be simplified to: java return input -> range == null || range.contains(input.getKey());
Default to off until config is back
Might as well call delegateFirehoseFactory as firehoseFactory from the start. The renaming isn't doing much useful anymore.
can we just close the firehose instead of the factory?
This task should be idempotent, which I think it is so long as DataSegmentMover.move does nothing if run on a segment that has already been moved.
Instead of returning here based on course access, we should make setHasOptionsMenu() dependent on it like: setHasOptionsMenu(courseData.getCourse().getCoursewareAccess().hasAccess())
Use Consts.MODEL_CLOZE. Sadly can't make this a suggestion as it also needs an import
Is this still needed? A similar code snippets is now in the parent class ...
In addition to checking these for null, now that TimestampedEntityTranslator is not extended, we need to manually also translate the created/updated fields.
Should this be synchronized? The previous implementation in ForwardingObservable was.
For consistency across the project, please remove the final keyword from this local variable.
Need something better here?
add e as the cause argument.
no need in passing the size here
Could you remove Error message from log message and give to logger the exception ?
Yes, sorry, forgot about that... and the copyright
It's better to throw a NuxeoException than return an empty list. If this shouldn't happen then we should throw.
Why don't you store the pattern in a final static (instead of only the String and compiling each time)?
You should use here com.google.common.primitives.Ints#compare(romanNumberOne, romanNumberTwo)
Question: If tablename is not null, in that case is m_index defined (from constructor definition it looks that it will be)? Not sure how this function is intended to be used but if this is for debugging/information thn might be useful to return m_index value along with it
Would change this to Objects.requireNotnull
@ivandalbosco You can drop this line as token.getTrivia() can return empty list
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
put some context to wrapper exception.
if exception is rethrown, local context should be collected to exception: throw new IllegalStateException("Unexpected xpath query: " + xpathQuery, ex); as there is no guaranty that cause exception will print it.
we looks like always do getRootAst and then new RootNode. does it make sense to have util method getRootNode.
Why change to use the String instead of char?
Do this check in the constructor instead (or a static factory method). You'll want to be careful in how you calculate the baseType and you'll definitely want to throw if you can't find a baseType for which all elements are coercibleTo. You basically want to find the common base PDataType. Something like the first loop in CaseExpression:  private static List<Expression> coerceIfNecessary(List<Expression> children) throws SQLException {
Why not re-use the existing type factory? (Type factories canonize common types, so mixing them is not recommended.)
We can put one parameter per line as this line is long:  public static Map<List<String>, RichColumnDescriptor> getDescriptors( MessageType fileSchema, MessageType requestedSchema, Map<parquet.schema.Type, HiveColumnHandle> typeColumns) {
| line | > 100
What if the path length is smaller than depth? Will this crash?
is a break; missing here?
LOG.debug("Built url: {}", url); so that .format() doesn't get evaluated if not in debug mode
Will * <LINK_0> * <LINK_1> work as well?
similarly here: java assertThat(Sets.difference(generatedMethods, originalMethods)) .containsOnly("delegate");
Thanks for looking into it!
please use assertJ for this: java assertThat(generatedMethods.contains(originalMethods);
I think here we could just us a file-handler just the configuration is less complex and slight less overhead as there is no WriteHandler.preWrite() invoked. Really not a big deal though.
This should be probably moved after following applyRemoveAllowReload.
My guess is this needs to read and cache the value in setup and then either undefine or set it back to the original value here. My guess is the latter is what would be right in many cases where -Delytron is used, hence the failures in the elytron job.
Can you set the message inside the method avoiding passing it as an argument?. It's always the same
Should we also issue a warning to have a log of plugins to be fixed? I think we should, but do not know if this is going to generate just a few lines, or dozens or more of them.
Should deserve a @VisibleForTesting ?
The PROPER solution would be to make getContainerItem NOT return null, as Null ItemStacks are not valid anymore in 1.11
Please use the method inside the MainProxy to check this.
Could we make this an interface that fluid ingredients implement and use a callback for this logic? I could see this being useful for an RF battery ingredient to have a callback to remove energy, or other similar cases where the ingredient can define special logic on crafting with it
s/id/ID
So this will explode if there is a null still... This is actually a weird case, because  return "[" + a+ ", " + b + "]";  will be just fine. I never thought about it before, but there must be special syntactic sugar that checks nulls in string concatenations.
This should also flag whether the binary is reused.
same thing here, it doesn't need to suddenly start working after the first experiment, plus is this test strictly necessary, considering it's subsumed by attemptsExperimentAgainAfterEnoughTimeHasElapsed
nit, just make this real instead of mocking i.e. () -> FALLBACK_INT
isTrue()
can be inserted to the if bellow (redundant if build is not captured)
I suggest simplifying the code of the above method to:  if (isCaptureBuildInfo()) { return true; } if (isPublishBuildInfo()) { // First check if there is a publish build info task. if there is then use aggregation List<? extends TaskDefinition> taskDefinitions = taskContext.getBuildContext().getRuntimeTaskDefinitions(); if (TaskDefinitionHelper.isBuildPublishTaskExists(taskDefinitions)) { resetPublishBuildInfo(); return true; } } return false;
I see, this code is copied from SSH command, but we always want to improve code, right?
Must be Outcome.Benefit to keep good card
Missing randomDiscard param.
A good case to use a static filter StaticFilters.FILTER_PERMANENT_NON_LAND.
Replace this with The number you have entered (<Number>) is too small, it must be at least 0
No need to send this error, just return false. It would never happen to a block/entity/console.
@JeromSar wants the reason to be optional.
This should use a PageLink method to generate this URL.
The logic does not make sense to me. The edit != null logic should happen before creating any object, otherwise, it will be a redundant object.
do we also want to GC the completed future from partitionReleaseCompletionFutures?
newRefreshToken!=parameters.refreshToken looks always true so redundant: this operator compares references to the strings but not content.
There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; }
can we extract this to a method called getToken?
This is not an integration test, you're working with a mock version of Github. This test method belongs to another class (and another ticket)
it's better to use some Unicode chars in it, for better testing. for example "the raw \u20ac\u0000"
it's better to stop container in finally block
Here I have 4 connections and the dialog shows 4 lines with <unknown> as a label.
No need for Multi since dialog.open returns one path anyway
I think this is not needed
You can remove braces.
why do we need an assertBusy here? why not just use assertUserIsCreated or nothing as the next statement will fail otherwise anyway?
Not sure you need the password as you don't use it.
Typo; Should be authentication in lower case.
StringUtils.isNotBlank()
If the token is blank you don't need to check/fetch the client-id. Return false immediately, and marginally help with performance.
I think this case shouldn't be allowed?
Please check that the data buffer has at least 2 bytes to avoid a NPE.
It probably makes sense to extract a constant for new ICPPFunction[]{}.
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
nit: this is a slightly nasty way around the line length issue.
You can replace this by: java return input.entrySet().stream.collect(Collectors.toMap(entry -> entry.getKey(), entry-> ObjectToByteConverter.ObjectStream.convert(entry.getValue())));
not correct
avoid this containsKey
We could merge this, but that would cause all extenders of this class which are not LineContentAnnotation or LineHeaderAnnotation to not be clickable. So that could be perceived as a functional regression by those. Is this a big issue in your opinion? I am personally fine with it, as this is very new code and I don't think it has much adopters beyond those who are already following, and that even current adopters do work on the CodeMining layer more than on the annotation one. That said, do you think we could figure out an implementation that would work in basic cases, such as x >= fx && y >= fY && y <= fY + fViewer.getTextWidget().getLineHeight(position.getOffset()) && x <= fx + gc.stringExtent(getText()); ?
Is this what we want here? If so we should have it as a Log method then.
I think the cache topology is never null. what case do you have in mind?
is this change really needed?
switch/case here too It's not just for the sake of it ;) But for example, if we ever add new types of ITmfStateValues (which we've done before), we would then get warnings here asking us to handle them, which is exactly what we want.
why not use the field directly? In fact, perhaps checking fSSAssigned instead would be clearer.
I think you've set fStateValue to nullValue in the constructor in this case, so this is pretty much dead code
this does not handle the empty 'lists', it will throw an exception
should be static.
maybe this should no longer be named pliList
How about in-lining o1 and o2 since they are not reused?
This if statement is not necessary as the while loop below would handle the negative case.
If dataRows is empty (hasNext() = false) but batch.size() < BATCH_SIZE, there will be NoSuchElementException thrown in next line.
I would rather get rid of RuleSetAdapter because: * it assumes that rules in RuleSet have particular semantics (e.g: only one rule matches) * it wraps and executes rules in a different way than during actual optimization * it doesn't allow to test how rules interact (e.g: trait rules before other rewrite rules) * it only allows to test rule set which are grouped in RuleSet, but we might want to test not grouped rules (e.g: trait rules and rewrites). * it is a work around RuleAssert limitation of testing singular rule. I would rather test multiple rules explicitly in RuleAssert with assertions.
toSingleton collector?
This is already done in the other method.
Platform.exit()
The client aims to be as non-intrusive as possible. Immediate notifications should therefore be used sparingly and only in cases where a user's immediate action is required. Let's say someone only has the client installed for chatting in #aeolus, or maybe he's a client developer who doesn't actually have the game installed but starts it very often. This user gets an annoying notification now, every time he starts the client. This is why we made it a PersistentNotification.
All other places that access notificationIdsInUse are in methods with descriptive names. We should do the same here. Maybe markNotificationIdAsFree()?
THIS!!! THIS IS THE PROBLEM!!!! Look, it needs to be Integer.parseInt
Integer.parseInt
Object
So I believe if IPath bundlePath and IFile bundleFile is not null that means we have a workspace archive so we should use ArchiveSourceContainer as before. But if those aren't in the workspace we could fallback to using the ExternalArchiveContainer.
This would be better as:  java if (projectsAdded.add(targetProjName)) { IProject targetProj = ... }  That is, use the boolean return value from add to decide whether to add the JavaProjectSourceContainer instead of a separate contains check.
Use a LinkedHashSet to get predictable order (useful when the result of this is shown to the user).
This seems wrong/redundant. The check !file.exists() && !dest.exists() will often return true before reaching here. We will only get the IllegalStateException if !file.exists() && dest.exists(), and the catch block after Files.move already throws the same exception if we are in this state anyway.
Certainly getCanonicalPath() provides clean path. but this method always returns absolute path. It may need to confirm the logic is no problem or not...
Make the method static
This log is too frequent. Please remove it and add only "info" log to the Auditer class itself where we will have better control on using these debug messages.
I would prefer to take care about two different situations: 1] value of attribut is not null - set, 2] value of attribute is null - remove. Same like in the schacHomeOrganizations user virt attribute module.
You can remove this line. It is probably just for debugging.
Perhaps 'Not unpacking {file name}... 'would be better - this gives the impression that there are no unpacked variables in the file - but this may not be the case - config could be overriding this.
log the object id as well.
to connect to secure nimbus
If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster.
You're getting the display name and using it todo a search my userId. Either there is a bug in the UserProxy or this code is wrong.
Should be able to do a multi-id query using something like criteria.add(Restrictions.in("groupId", groupIds)) Current method allows for nulls to be included in the returned list too I think
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
You should use ThreadContext.putAll() here.
Replace by Map<String, String> result = new HashMap<>(map.size());
externalize
externalize
externalize
This would be a good time to change this to fire exception via the log object, i.e. org.infinispan.util.logging.Log.invalidConfigurationIndexingWithInvalidation
Undelete Updated -> Undelete
Replace isFlagSet(Flags.Undelete_Index) with isUndelete(). Same for DELETE and TTLUpdate.
I'm not certain what the correct thing to do here. If there are multiple groups in flight and the outer observable is unsubscribed, do we want to unsubscribe the open groups, enqueue onCompleted elements on them but let them run, or something else? Window has this anomaly as well where the unsubscribed outer may never deliver an onCompleted on the inner windows and thus they stall.
This allows unsubscribing the state while an onNext is in progress which requires extra care for the state object.
I think we do not maintain key order here, which is iteration order of the elements of this Traversable. The result of toMap does not guarantee any specific key order. So we need to do some extra work to order the keys of the LinkedHashMap: java default <K extends Comparable<? super K>, V> Map<K, V> toLinkedMap( Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valueMapper, BiFunction<? super V, ? super V, ? extends V> merge) { final Map<K, V> map = toMap(keyMapper, valueMapper, merge); final Iterator<K, V> entries = iterator().map(t -> { K key = keyMapper.apply(t); V value = map.getOrElse(key, null); // the default value will not be used return Tuple.of(key, value); }); return LinkedHashMap.ofEntries(entries); }
Change this to a public static function that can be called from the adapter, instead of duplicating this logic there.
Need to revert this code. Should always have id and subsystems
Why you take a array of size 4 not 3?
Please change to !message.trim().isEmpty()) {
Strange... the JDT UI settings in our projects should remove trailing whitespace. Please remove.
Why this underscore?
looks like you missed these
Maybe check for if name ends with ':' so we don't do a double one?
An alternative way to phrase this would be to make ObjectIdRef.Unpeeled.getObjectId return non-null: @NonNull @Override public ObjectId getObjectId() { ObjectId id = super.getObjectId(); assert id != null; // checked in constructor return id; }
@cuenyad use factor variable
What is this on-the-fly used for?
add final
Could we use PreparedStatement parameters rather than String.format()? I don't think this would be exploitable but I think we should do it the right way on production code. Also for the other places the idiom is used.
Do we handle case-sensitive schemas? create schema "thisIsCaseSensitive";
break the line
This is early exit, so you can move the else part unindented below.
Thanks for adjusting the dots on line start.
Isn't this the part for which we added a breaking changes entry in master?
I can't remember why it needed this? And I get paranoid about it since I spent months tweaking the multi server configurations to not break.
Hey, So currently there shouldn't be an assumption that there are any "universal" strings in the localization engine like this, so wee should likely move these to something like loggerInterface.logXPathParseError, loggerInterface.logXPathException() or moving the errors to be non-localized.
![Codacy](<LINK_0> Issue found: [Method names should not contain underscores](<LINK_1>
Convert Unspecified to constant. And there's probably a framework constant for this string somewhere.
Are we sure newValue is always non null?
i'm not sure i would put possibly deleted. i would suggest leaving that part off, or, since we can determine that, figure it out and then put it if applicable.
Why was the reflection needed here? is it due to API levels?
there's responseToString below, which increases the similarities with configureConnector
There is already logging for that in the EncryptionUtils.encrypt catch block
I think you want to pass in the errorListener to super
I think you should add proper custom error message in this case.
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
This log doesn't look very useful, we should at least log more information than just the courseId.
This will not work for two reasons: - Java assigns Object variable by reference so essentially your expected and actual are always the same. - Your attribute's subject and content are clean texts; sanitizing them will not cause any difference. You should test this by simply creating a new attribute object, sanitize it, then check the subject and content fields post-sanitization.
What happens if the email is updated but the updatePublicationOwner fails? Admins should probably have a notification on it.
Please write a method ProcessService.getNumberOfChildren(process) which is calling the ProcessDAO to count on database
Missing white space between ) and {.
Error message can be inserted with translations:  Helper.setErrorMessage(ERROR_LOADING_ONE, new Object[] {ObjectType.PROCESS.getTranslationSingular(), id }, logger, e);
rename 'listeners'
not all listener
not all listener
We should abstract updating of dependent phenotypes as out of sync from this service. That is, it should be part of the Middleware API call.
Hi @mderamos, Add code to check if value is not null before using substring.
@vmaletta assertEquals will be more elegant
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
Change this to == and I'll merge it.
Please also provide the method with old signature (calling the new one, taking the max). It is public and there is no reason to break API.
Do we need this? The java doc for "yield" says, its rarely appropriate and used for testing or debugging.
If the tryCreate() is true, and for any reason, unable to create connection, it should be in the loop till the specified timeout (server-timeout), right? throwing an exception here will return before the specified wait time.
This logic is perfect, but for a while I got confused with connection being Connection and this.connection being AtomicReference. Can we rename connection to connectionRef to indicate AtomicReference?
Doing it this way will not update the actual Pod spec. I think we need to add this in createOpenShiftDeployment()  PodSpec podSpec = new PodSpecBuilder() .withContainers(container) .withVolumes(getVolumesFrom(volumes, workspaceID)) .withTerminationGracePeriodSeconds(OPENSHIFT_POD_TERMINATION_GRACE_PERIOD) .build();
do we need such wait ?
Please consider updating of java docs as well. I don't see any java docs that would explain how we store machines names in annotations. I guess, previously java doc of MACHINE_NAME_ANNOTATION_FMT const has some short info.
We should just expose getRemoteAddress()
"SocketServer time spent on write per key"?
"bytesWritten" on similar lines to bytesRead
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
NPE when req == null
Both are 503, what am I missing?
You can use CollectionUtils.toImmutableList
Since you only need the id adding a fetch will speed things up a bit.
Use toImmutableList() in both places
'e' is not logged
Use constants for these types of String literals
Use already defined Constants
You should use here errorFormat instead error and "...{0}",domain.getId" instead "{0}" + domain.getId()"
Please iterate using entrySet
You can have raw block disks - but only if they're preallocated.
Better to log the error
might be safer to use a constant for "cookie".
It's not flexible enough. So when you will need to add another requestCode, you will need to add another else if, which isn't a good practice.
Please refactor DbFacade.getInstance().getLunDao() to a method...
You don't care about the order, and you're doing several remove operations - better use a HashSet
it's kind of confusing to have a set named with "List", consider change that.
Better to constrain it to List<Object> instead of ArrayList<Object>.
You want to use FormField.getFirstValue() here and everywhere below.
For a list the labelData is null
Maybe we could directly pass UpdateMode if isInsert is only used once?
this is a static method
This is hard to read. How about we add a variable?
It seems like we can add two storage domains at the same time
this method checks among other checks if domain is active, which is not exactly an image validation. Please consider renaming the method.
- please replace the condition with storageStaticData.getStorageDomainType().isDataDomain() - what about import storage domain scenario? - what about attach storage domain scenario?
Should this be IllegalStateException? Please correct the message.
you could flip this condition around and use it to determine up front whether you need to create a new block. Then you have the actual write logic in one place. Stylistic I guess, but it's another option.
You know that this will throw a ClassCastException if the condition for logError is met? Why not return null in that instanceof Check?
i think it is probably better to just get the whole thing as lrange(...) in one shot, and probably best to not bother fetching the size (again, doing it as a two-step you are leaving yourself open to concurrency problems. imagine that while thread A is in the middle of iterating through a peekAll, thread B starts rapidly popping members out.)
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
no need to specify type on RHS
replace everywhere "symbol instanceof VariableSymbol" by "symbol.isVariableSymbol()"
useless parenthesis
Extract variableTree.symbol() instead of calling it 3 times.
There's a utility class for this. Check out DisplayUtils.dpToPx()
The message is misleading. It will crash the process. But actually that's fine, it should, if such a severe issue is detected.
This if/else snippet is repeated four times throughout the code. What do you think about creating a method in DisplayUtils to have that code in a single place?
Why are you changing the return values of existing factory methods instead of adding new methods for when you actually need the new logic in ConcurrentParallelHashMapV8? The reason I did this for EquivalentConcurrentHashMapV8 is because we always need to use these type of maps in order to avoid issues collections that call Object.equals instead of the equivalence function.
Why is hard to read generic coding used here?
These should get saved in a data structure so that repeated calls with the same name return the same map.
Returning entity.toString() could be ok. iirc, the stable id should be the same as the canonical path except for the very long canonical paths.
layout isn't used.
this might look weird but is done to allow rolling upgrade of the cluster where overlord is upgraded before middle managers. we can possibly remove this if we decide to not support rolling upgrade for 0.10.0 .
InterruptedIOException
What is this check needed for? We might as well omit it to allow others to create a packaging type "my-eclipse-target-definition" that for example includes additional steps in the default lifecycle.
This seems wrong/redundant. The check !file.exists() && !dest.exists() will often return true before reaching here. We will only get the IllegalStateException if !file.exists() && dest.exists(), and the catch block after Files.move already throws the same exception if we are in this state anyway.
Also, in case there are two inputs to a job w/o the same number of partitions but using GroupByPartition, how do we reconcile and propagate the EoS marker?
Issue: This should probably be passed in from SamzaContainer via the constructor.
Should we be starting/stopping system admins here that are part of the shared systemAdmins? Doesn't it have a start/stop already?
You will probably need to change this auth and the accept type when completing teh request verification in the mock tests.
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
Nice usage of reflection! I'm wondering if this isn't too smart... It will at least break automatic refactoring of Result class. So we should at least externalize the ResultAttribute class and provide a unit test that validates that all possible properties can be extracted. Also, I'd like to have the extraction logic moved to the ResultAttribute class. This would give it an actual responsibility and it would act as more than a dumb data object.
what's the point of doing this?
Consider to use an ImmutableList here
maybe this should no longer be named pliList
As a nit, should have a null guard here.
NP: these exceptions can be compacted in a multi-catch block to not repeat code (the same below).
It should throw exception
Also too many empty lines... Please compact the code a bit.. Thanks!
To avoid confusion, rename the variable to sessionId.
>So I guess simply passing the startTime is the only necessary change? (the ones I made in the monitoring.js file) Yes, I think this is the primary improvement in this PR - if you could remove the other changes that would be great (modulo the v1.0.1). However, I'm not sure I'm convinced that this alone fixes #215. I'd like to have @Suryakandukoori dig in a little more before merging this PR, although he's tied up with some other tasks this week.
This can be collapsed to a single line.
Its worth adding a null check here too.
new ArrayList<>();
These should probably be below our lifecycle methods since that would follow the logical flow more
This will result in a requestLayout and setTabSelected is called as part of onMeasure in this view. Requesting layout during a layout pass can cause problems. We should probably do something something more direct instead of setTabSelected to animate to the currently selected tab after the size has changed to avoid this.
I prefer the ?: syntax, also I think isLight is a leftover from the merge, because it is not needed suggestion mSwitch.setIcon(mLinear ? R.drawable.ic_apps_white_24dp : R.drawable.ic_list_white_24dp);
Nice, i was wondering if this would work for overloaded methods and it appears it does (i.e. findSliceInvoker1 is defined if a previous findSliceInvoker exists.
Try java return methods.stream() .filter(method -> methodName.equals(method.getName())) .findFirst() .ifPresent(method -> calculateMethodCanonicalName(method)) // calculateMethodCanonicalName can return null .orElse(null);
This won't work with generic builders I think.
no need for the additional check if propertyParts.length is ok?
Looks like everything in the append(...) can fit one line.
Possible NPE here unless I am mistaken -- there may be no defaultValue.
That's wrong. Please see org.intellij.erlang.psi.ErlangSpecFun#getReference and isReferenceTo() method.
this loop is slow; why not convert ALLOWED_SPATIAL_JOIN_FUNCTIONS into a set of lowercase function names, then use Set.contains(functionName.toLower())
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Is it possible that nothing is selected? If so, the return type should be optional (-1 is kind of ad hoc). If it's not possible, there should be an assertion failure.
Same thing here with this catch block
It would be good to log these.
the default should be made a constant somewhere instead of being defined in multiple places
have a default constructor with reasonable default values
Please keep this.cell near the related fields (previousFamily & cell count) below
Rename this variable. It is no longer accurate.
This seems to be left-over from the copy-paste
How about making the CommitPeriodically a standalone action and use it from rules which we expect to iterate over large sets? Still a bit hacky, but less than current :)
We should abstract updating of dependent phenotypes as out of sync from this service. That is, it should be part of the Middleware API call.
this method is called in the src Evaluator, when the data has been sent out. Could it be the case the data type is missing?
Apply cleanup (eg. put final in for loop variables). Apply formatter too
If a branch gets deleted can newObjectId be null so that in this case ObjectId.zeroId() should be used as new objectId?
not sure why this switch case is required - just use whatever is passed in?
extra line
Remove this :)
!common.isEmpty()? And have generateInstanceNames first as I guess it'll be cheaper to check..?
redundant with below?
why starting from the identifierToken() and not directly from parameterUsage ? You can directly strart from the parameter parent.
probably no need to collect: filter and foreach should be enough.
As you rely on semantic anyway, I would rather check if owner of method is abstract, that would avoid a loop. Moreover, what happens when there is no semantic ?
I'd like to keep formatting/mark up out of our controllers. Maybe we could put the queryText into its model attribute and use it in searchResults.jsp
Space between if and ( Space between ) and {
Precondition and message don't match.
Fix bug
Another FYI, not a required change: note that there are some "gotchas" when using String.split with a regex. [Here's a nice breakdown](<LINK_0> If this was high-performance code, you'd probably want to compile the Pattern ahead of time, and split using that instead. I only learned about this a couple months back.
Does not compile, but not really important.
I think CDA is not the place to set values
Should be done in the constructor
can we fetch the compatibility version from the VM and not fetch the cluster?
Is the configuration object always available also for already created bridge things? If it could be missing, this (<code>getConfig().get(POLLING_INTERVAL)</code>) could return null and your intValue call will raise a NPE.
I'm not sure how useful it would be, but we could add a tiny bit of jitter here with a small random number.
this duplicates code with RequestUtils and RequestMetadataInterceptor , we could extract this out by creating some method that takes HttpServletRequest as a parameter, returns a Map, then add the info where it is required
We could probably use getItem() method here, for consistency.
Could you please replace this with the middle dot and space characters, eg.   ?
The author in the header should still be displayed. Please only remove the author from the actual page, not from the blurred header.
nit: would case switch be better?
Maybe add @Nullable to taskExecutorManager.
if (this.isTheDefaultInstance...
Extra asserts?
can we add this. in front of setting these fields
feels like this should be all done within createTelephonePaymentService
![MAJOR](<LINK_1> 'Severity: MAJOR') Reduce this lambda expression number of lines from 21 to at most 20. [![rule](<LINK_2>](<LINK_0>
![MAJOR](<LINK_1> 'Severity: MAJOR') Introduce a new variable instead of reusing the parameter "state". [![rule](<LINK_2>](<LINK_0>
please break to a new line.
Why don't you want to use curator TreeCache for that? In that case you won't store the list of caches.
throws NakadiRuntimeException
Let's try to do some refactor here, it is id selector, so you don't like cssSelector and string concatenation with "#"
I think everything from Optional<Status> statusMaybe =   could be replaced by: java return statusMap .flatMap(StatusMap::getToStatus) .map(status -> { if (status instanceof ChargeStatus) { return new MappedChargeStatus((ChargeStatus) status); } if (status instanceof RefundStatus) { return new MappedRefundStatus((RefundStatus) status); } return new UnknownStatus(); }) .orElseGet(IgnoredStatus::new);
Slight concern here is that we'll be notifying these observers before we actually persist the state to the database (which will happen on completion of the persistence method/transaction) so there is still a chance this will sent notifications but the database won't reflect those changes. Also since calling all the observers seems to be in the current thread it will delay the database update by however long each of those observers takes to do their work. Do you think it would be better to fire an asynchronous event instead?
How about to use replace(key, oldValue, newValue) API? It would give us more explicit semantics about the status transition of the operation. emOperationsRequested.replace(op, OpExecutionStatus.In_Progress, OpExecutionStatus.Complete)
String.valueOf
I would just get of any semblance of support for Apache.
could read the method from the response, eliminating the need to call withRequestMethod method
Please re-format this method in your IDE, I suggest using the Eclipse code formatter located at config/engine-code-format.xml (If you're using IntelliJ IDEA, you can install the "Eclipse Code Formatter" plugin.)
If getCurrentStorageItem() is null isn't getCurrentStorageItem().getRole() should through an NPE? I think that it should be like this if (getCurrentStorageItem() == null || getCurrentStorageItem().getRole() == StorageDomainType.ISO || getCurrentStorageItem().getRole() == StorageDomainType.ImportExport)
If the option should be enabled also without a DC, then check that 'none' DC is supported (StorageModel -> UnassignedDataCenterId)
you need to check for null case
Just to stay consistent, I would keep this as its own check. We always use "return true;" on its own at the end normally.
this is redundant with next instanceof check
order of operands
order of operands
call equals on constant
if that previews is showing cleaned-up code, why is this one still here?
change to arg
@sleshchenko looks like this class is changed by mistake
' ' should be enough, no need for a String object
Null is a valid return value ?
Why do we force the code to 4 digits? And btw what will happen if a new reason code is added with 5 digits? In that case, it could be a good idea to put the format in a static variable near the enum.
This pattern makes it easy to know what placeholders are available and to directly navigate to the implementation.
Any reason for doing this?
this if/else is equivalent to this.path = Optional.ofNullable(path);
needs some doc , on why you need this
Add check for null here.
... and here ...
I'm thinking that we should provide a different strategy for some block types, such as table, numeric list and bulleted list - there's no need for <br/> <br/> to terminate these.
consider a assertSupported(BlockTypeStrategy) as altenative to all the instance of checks
Should have a crosscheck that these are not supported by default.
Don't return, just do a continue so other modules can still add their state systems as children.
nice, this makes sense and makes things easier to understand.
While the state system is being built, this query2D from the zoom thread can miss some events. It the case that I am consistently reproducing, the missing interval is in the middle of the query. The gap is filled with a transparent event, and this incomplete zoomed list is never longer updated on subsequent zoom threads (until the window range is changed).
Move this binding to StorageModule.
This will use the name RetryingPrestoThriftServiceStats for the JMX bean. Is that the best name?
Unrelated formatting change?
So the issue was that they had _case in an identifier? Should you be testing for _ afterwards as well?
Let's not delete the file? As of now, the .jtl results file isn't deleted either
Why is this fully qualified?
Could you, please, explain, why verification the command palette had been removed?
What about checking running the test from command pallet?
It's better to use static import here to improve readability of code.
speces before and after "+" :)
Method is taking too much parameters.. Shouldn't we introduce a bean to hold all values and pass it.
Check IOHelper.constructUrl() for properly concatenating parameters to a base url
You could think about extracting the listener to a local variable: java final ChangeListener<Boolean> tabListener = (observable, oldValue, newValue) -> { if (newValue && !repositoryManager.isRepositoryLoaded()) { repositoryManager.triggerRepositoryChange(); } }; this.mainWindow.getApplicationsTab().selectedProperty().addListener(tabListener); this.mainWindow.getContainersTab().selectedProperty().addListener(tabListener);
I think we should have two versions, get (which catches and LogKitten.exes the exception) and getSafe which throws the exception. That way simple code doesn't need to worry about this stuff but complicated code can. (get should just be a call to getSafe with a catch)
**CRITICAL** suggestion super(SegmentRelocator.class.getSimpleName(), config.getSegmentRelocatorFrequencyInSeconds(), config.getSegmentRelocatorInitialDelayInSeconds(), pinotHelixResourceManager, leadControllerManager, controllerMetrics);
Looks like spurious changes with no changed behaviour in this file. Necessary?
Since State is an enum, we should use == here.
Why not use ZooKeeperMasterModel.getDeploymentGroup()?
nit: for src code readability & more explicit error message java Preconditions.checkNotNull(p.getParent(), "Path for page %s can not be root", pageId); Files.createDirectories(p.getParent());
Should we catch throwable here?
Precondition to check page Offset is positive?
IMO its more likely to be an error to not specify the contents. So this should throw an ISException. But it does not really matter.
I think the unmodifiableMap should stay in getRoutes().
IntelliJ IDEA tolds me to remove this unnecessary boxing.
Why do we need new File(file.getAbsolutePath()), instead of just using file?
I'm pretty sure this will have to change based on how the response codes have changed.
Avoid using localhost and obtain is as a parameter from instantiating class.
These is a most ugly way of work, you crated wrapper, passed all parameters and you are passing a list of canDoMessages all over a code in order to fill it. Such approach is wrong (I know that it is used at our code, but sometimes someone should do something smart), you should use return value.
if this is called on edit, then this check will fail.
does this validate only if i change the quota?
Use UTF-8.
this is pointless, we don't need to close byte array output stream
Worth initializing to raw.length+32, to save in-line expansion when writing out the byte array?
Use getSimpleName instead?
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
Lately I've been generating toString() with the "String concat (+) and super.toString() template in AndroidStudio - that way we'll get the Id field logged as well which can be pretty important for debugging
can you add some docs around this method.
Are we going to support VARIANT type? As I know We're handling variant as String in schema.
Unsigned types are not used in the current implementation. So, you can omit them.
Before, if there was an error, it would setToolTableJson(null). Now you don't set it at all. Do you want that? I don't know the answer, just raising the question. In theory, without understanding the whole flow, it seems like if there were already a value in that fiel, it would get cleared before your change, and now it doesn't. This happens in at least 2 other places (ran across this one first). Checking that this is as intended everywhere. Could very well be the bug fix :) But I'm still concerned about old values not being cleared.
:thinking: Is there any situation we would want a dirty dag? Perhaps there should be a default method in LanguageHandlerInterface that auto-cleans all getContent calls and getContent should be protected and only called by that
This same block is in this file 4 times. I would recommend at least making a constant out of "validations", and/or creating a method to avoid duplication.
Missing braces
I'm not sure about the name, because it's definitely not the identifier of a single event. Maybe batchIdentifier is better? Same in the other methods, in ClusterEventManager and its implementations.
Is this supposed to be here? A cache entry expiring isn't a synchronous thing.
can't you reuse these mappings form the VmMapper?
you should be addressing here a isFiltered() flow (as being done in the vm.update())
Can you please extract this block to a create method, similar to the way you did in HostGroup?
I would prefer to initialize these inline in field declaration rather than constructor... If I am not nitpicking too much...
use instead, please, implements IntegrationEvaluationContextAware
I think doInit() implementation should always stay as protected void. At least for our classes and don't allow end-users to invoke it - just only afterPropertiesSet(), as you do it in tests now.
same here:  this.left = checkNotNull(left, "left");
Can you just use the diamond operator here?  Map<String, Map<String, Integer>> ret = new HashMap<>();
insert newline before each .set.. and .build
Remove this line so that you fail on assertion.
Changes looks fine, but there's a lot of duplicated code in this test class. Could you refactor the obvious bits? Also, the other tests use a JWT parser to validate the payload rather than an object mapper. I prefer making this one uniform with the others so we know the payload conforms rather than what an object mapper produces.
unused
if a column was missing, should we ever match it in this case? fn.apply(value) looks a little bit unusual as value is really an element from the Range of the function and not Domain. may be it should be...  return new BooleanValueMatcher(false);  @xvrl ?
should this be BooleanValueMatcher(matchNull) ?
Just ArrayBasedIndexedInts.of(newIds)
Is this really more readable? (IMHO it's not)
Can you not combine these if's to reduce the nesting a bit?
Same, this should be expunge() without arguments.
Seems possible to simplify. I'm not sure, but is this just?  if (profile == null || profile.email == null) { return user.getUsername(); } return profile.email;
I'm not sure this is necessary. Why don't we use a simple constant (like "pac4")? It would help cleaning the code, without losing any benefit.
Need to use UUIDs instead, for performance. Nit: can be final.
Actually, in what way does this change relate to adding a new status command? Because this change affects all other CLI commands perhaps it deserve its own separate commit. Anyway, just making sure this change landed here voluntarily and not as a result of mingling with another context...
I don't think, that this way, it's easier to read. How about leaving the OutputStream outside of the try in it's old verbose format and just have the try around the writer? if the writer is closed, then the underlying stream *should* be closed, too. Alternatively, we could write this:  OutputStream outputStream; // ... same as before try (OutputStream out = outputStream; Writer writer = new BufferedWriter(....  That way, we can still figure out the outputstream on multiple lines, but still use the auto-close feature.
why create a buffer to store some content which we want to throw away in the end? If output is <null> don't initialize a writer and during the call() method when writer is not initialized just read lines.
@vilchik-elena Style: I would have created a variable for (ExpressionStatementTree) statement).expression()
I would use else if here
What about expressions like this.field = null ?
deviceIdentifcation => deviceIdentification
Shouldn't this be: is allowed GET_MBUS_ENCRYPTION_KEY_STATUS_BY_CHANNEL?
The method name has been refactored, but the log statement still uses the old name.
from L257~262, you can use Strings.repeat
we can just call repeat(" ", n)?
as we are changing how the digest is computed anyway, we can simplify this as buf.append(',');
This should be a triggered ability of the enchantment, not a trigger gained by the creature
Use {this} when referring to card names in text.
You can use TargetArtifactPermanent and TargetEnchantmentPermanent instead of creating a filter manually.
A question about the purpose of doing this -1 test. I do not understand how this -1 works in Socket InputStream. I would expect that int read = in.read( buffer ) will block read until we get something from InputStream, unless an exception is thrown. However if we get an exception, we will never get to this if.
I guess this does not create extra cop. Incase we need to return the whole chunk, we shouldn't incur additional memory. Just wanted to confirm as the doc says "Creates a new byte buffer whose content is a shared subsequence of this buffer's content."
I hope you don't mind I extract this one as a separate JIRA: <LINK_0>
Why do we need to change it?
Please consider to add cause.
Dont add prefix for wsPath. It will be added inside getOutDir method.
minor: could also use CacheUtil.getDistributedObjectName(CACHE_NAME) instead of string concatenation
Debugging artifact?
Since this is a verification we should probably use any(CacheLoaderWriter.class) to ensure the loader writer is not null.
Should go into @ After method to make sure it clears authorizations even if an assert statement fails.
suggestion createGrantAuthorizationWithoutAuthentication(PROCESS_DEFINITION, ONE_TASK_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
suggestion createGrantAuthorization(PROCESS_DEFINITION, DEFAULT_PROCESS_KEY, userId, ProcessDefinitionPermissions.READ_HISTORY);  Both works, I guess. But since you used ProcessDefinitionPermissions.NONE in testCheckReadOnHistoricProcessInstanceAndNonePermissionOnProcessDefinition, maybe we should stick to one format.
datum.toString() seems suspicious
it looks like we were writing DESIRED_CAPABILITIES twice before
seems like message is invalid (really draft-03/04 in this use-case?)
The fail()method throws AssertionError which is an Exception. Either use ExpectedException or change your catch clause to catch the exact exception you are expecting
So the message is expected to contain the misspelled csanceling, right?
I think there's also hasMessageStartingWith. AssertJ is crazy...
what if storageDomainDR.getJobId() != null, won't we need to use storageDomainDR.getGeoRepSessionId and storageDomainDR.getStorageDomainId instead of getParameters().getGeoRepSessionId() and getParameters().getStorageDomainId()
else if (storageDomainDR.getJobId() != null) {
This method should only be called by disk images. You can rename the method to something like 'getImageStorageDomainId' and by that solve that issue.
This turned out great, I think it's really easy to understand exactly how we get retries to work properly with this code.
Seen -> Saw. Should we also log this at a higher level, like error? This is a pretty critical error. I'm not even sure we should proceed if we hit this because it means we could be losing data since this method just ignores the data and moves on. It either indicates a serious problem with the underlying consumer or that something got messed up in this HdfsSinkTask code.
This logic only works if you started consuming the data when offset 0 was available. We should just be recording the latest offset for each topic partition with each record.
This can't be true, as Math.min() would return max if nsz would be > maz. :-) I think you really meant to write: if (buf.length == valid) { if (buf.length == max) throw When buf.length == valid we have to grow the buffer to read more data from the file, but we can't grow the buffer because growing it would put the buffer larger than the maximum size the caller wants this method to read and return. Yes there is a small issue here where the whole file might fit and we haven't seen EOF yet, but if we read once more we would see EOF. We can work around that by checking for EOF before throwing: if (buf.length == valid) { if (buf.length == max) { int next = in.read(); if (next < -1) break; throw ...
I think its unnecessary to allocate a ByteArrayOutputStream here. Instead you can write the method as: FileInputStream in = new FileInputStream(path); try { byte[] buf = new byte[limit]; int cnt = 0; for (;;) { int n = in.read(buf, cnt, buf.length - cnt); if (n <= 0) break; cnt += n; } if (cnt == buf.length) return buf; byte[] res = new byte[cnt]; System.arraycopy(buf, 0, res, 0, cnt); return res; } finally { try { in.close(); } catch (IOException ignored) { } }
unnecessary else clause can be removed
Follow the more general approach of getCellValueFromDataTable (include a table index instead of hardcoding 0).
I would have put this line above the previous instruction to make sure #xtree can be found. WDYT?
Can you repro this on master? If yes - definitely worth filing.
How did you convince your IDE that primaryIP is definitely not null here?
Just a matter of taste, but I would name the method without abbreviations: scheduleNetworkInterfacePolling
Wouldn't it make sense to at least log a warning? I mean, in the end it's the user who accidentally made a mistake/typo, the service silently "accepts" this configuration but it somehow does not really work as expected. Or did I miss anything?
If we want to be totally safe here, should we add || pages.isEmpty()?
We have the two letter codes here only for backward compatibility and changing it will break it. I suggest we remove the two letter code for Japanese.
Locale.getDefault().getDisplayVariant() works for me but getScript() returns an empty string.
Wouldn't it be more efficient to just create patient dao once?
Don't you wanna continue the loop and add more patients, just in case only a few fail?
Why are you not using isSynced anymore?
what is the value of getting the instance this way?
detach?
At the very least, extract '(CreateImageTemplateParameters)getParameters().getImagesParameters().get(0)).getVmId());" to its own method...
please move it to resourceManager.resetVmAttributes
* no need for java.util.prefix doesn't required * user proper java naming convention vm_helper --> vmHelper
suggestion throw new IllegalArgumentException("Can't remove yourself!");
Nice. The intent is more clear than using a file in the previous version.
exportAsXLS separate with .
unnecessary .toString() here as well
I'm not quite following what you are doing with the Entity Builder here. It seems like you are using it primarily to convert each TypedEntity returned in this loop to an Entity. If that is the case, you should be creating a new Builder for each TypedEntity and then doing your duplicate comparison within this loop. As it is currently written, it seems like you are just overwriting properties as you iterate through the TypedEntities.
Can you change this to EntityTypeRegistryModule.getInstance()#getForClass?
final Set<Type> majorTypes = EnumSet.noneOf(Type.class);
use Arrays.fill instead for loops
Throw a NullPointerException if address value is null. Can any int array be provided or should establish a concrete length or a min/max length?
Throw a NullPointerException if address value is null.
subMonitor.newChild with 1 tick
subMonitor should be used here
Use two parameter constructor
Why write it back to the field on every call? In any case, it must be done while the lock is held; otherwise we're back to the possibility of a concurrent update.
Maybe consider adding a StomConnectedEvent ?
Printing the classname is not necessary, this information is already added automatically by the logger. I would use the same text as in JsonMessageRequestHandler.
If this is never going to happen, why modify this to be less chatty?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
The message could be a little more descriptive or just use the Throwable constructor to keep the functionality consistent with the previous version.
No need for final, it's already private
extract this rethrowing to a new method
Maybe /druid/indexer/v1? (/mmx/ may look weird in open source)
This is pretty dangerous because alerts bigger than 1MB will break the emitter
This should have the data source name in the message and add the actual identifier as metadata on the alert. The messages are what turn into the email subjects... Also, after the alert happens, this is going to fall out of the if statement and do other things. Are we sure that those other things are what we want it to do?
Keep this as a Set, please. Later on, we're doing overshadowedSegments.contains(segment), and that's scary if overshadowed is any kind of Collection other than a Set (or very short List). By the way, it would be clearer to make this a Set<SegmentId> rather than Set<DataSegment>.
Strange logging "cursor[input.getTime()]". Also maybe just remove this debugging line
Unnecessary change?
isBySegment is always called with false as the default argument, maybe remove the parameter
Consider using Assert.notEmpty() and/or Assert.hasText() instead of the three checks in the isTrue block. Otherwise, nothing wrong with this. Something like this may be a little cleaner:  Assert.notEmpty(configClientProperties.getUri(), "Config server URI is undefined"); Assert.hasText(configClientProperties.getUri()[0], "Config server URI is undefined.");
Couldn't we use an Assert.notEmpty like the one below this?
This code should use instead entrySet
Can we move the path to ApplicationUtils class?
This could just be: return "v.toArray(new IJavaElement[0])"
copying and rebuilding the list everytime an element is added to the chain? Maybe chains are not long to see the adverse impact of this now. But when long chains are build this could be seen as inefficient. Something to think about in future refactorings.
Why not just "else"? Also, please add a space between if and (. There should also be a space between { and else
Again, I'm confused as to how a point delete can also be a column delete.
s/Qualifier/Qualifier
Remove all the sharedpreferences here instead of using clearToken() method. When one logs out, the application should clear all the saved 'SharedPreference values'. clearToken() will only save a blank passcode value and all the remaining sharedpreferences will remain intact. You can save the Instance Domain to make it convenient for the other users to login but it is already handled in LoginActivity.
The uri should be determined from the app id (which is set at compile time). Otherwise this will always lead to the settings of the release app.
Minor ( ): Consider removing the cast to NoteEditorActivity for this case, it is not needed, isn't it?
Add newline before return.
Add newline before return.
Add newline before return.
I realize it's a first cut, but I wonder if we should map some basic headers (method, path (uri), Accept) ??
Either remove "" or put some information in it.
would be nice to have the message in the exception here because this will also show up on health check potentially, and that only shows the direct message iirc. IOTW I don't think "Could not process request." is more telling than the cause.getMessage()
Why are we using Math.min/max() here but not above in unionBlock()?
for clarity we should reanmed the variables to be minInput maxInput, minOutput, maxOutput so it's clear. X and Y are confusing.
Use a switch with direct return (no break) for clarity. Assigning a value and re-assigning it in certain cases is always less readable then just returning a single result for one specific condition. There is no "default case" here, just three options with three corresponding values.
If you create a new Color you have to store it and dispose it later, unless it's a system color.
I think you can have a static variable for the formatter instead of creating a instance each time you use it. privat static ChartYAxisValueFormatter yAxisValueFormatter = new ChartYAxisValueFormatter(); and use it in all places. I think it should work and saves a bit memory
why final variable? :-)
new byte[0] is kind of ugly. Maybe another method that doesn't take it?
use try-with-resource instead: try (Scanner scanner = new Scanner() { }
This code below  ColumnSchema column = table.getSchema().getColumn(kuduMapping.getPrimaryKey().get(0).getName()); KuduScanner.KuduScannerBuilder scannerBuilder = client.newScannerBuilder(table); scannerBuilder.limit(1); scannerBuilder.setProjectedColumnNames(dbFields); scannerBuilder.addPredicate(KuduClientUtils.createEqualPredicate(column, key)); KuduScanner build = scannerBuilder.build();  is duplicated across exists(K key), get(K key, String[] fields) several other places. Can you see whether we can move this code to a common place/method.
The session can be removed between the two calls to sessionRef.get(). Session session = sessionRef != null ? sessionRef.get() : null; if(session == null)
Slightly condensed version .collect(Collectors.toMap(MapSession::getId, Function.identity()));
Extra space after synchronized.
As an improvement over current state of this test, could initialize config with smallInstanceConfig() (also use the same in MemcachedMultiendpointTest)
please use the other methods shorten format: i.e. return ValidationResult.failWith(VdcBllMessages.VDS_NO_UUID) .when(StringUtils.isBlank(host.getUniqueId()) && Config.<Boolean> getValue(ConfigValues.InstallVds));
Could you explain why you change config key name from "kubernetes" to "agent..." ? I guess original code is better. Because Docker has same configuration naming. And "agent..." is longer to define in WF definition.
The check for shiftedKind < ITypeMarshalBuffer.FLAG4 is not needed anymore since shiftedKind can be safely combined with ITypeMarshalBuffer.BASIC_TYPE into a short int.
Makes sense to swap FLAG2 and FLAG3 since volatile functions are less common than the varargs ones.
There is only one bit left between FLAG7 and LAST_FLAG. It makes sense to define ITypeMarshalBuffer.FLAG8 and use it instead of SECOND_LAST_FLAG.
this shouldn't do anything?
rename 'child'?
Better to explicitly pass parameters to the two-parameter ctor.
forEach is designed for side effect, a chained stream seems better to me.
@csivaguru I am not sure this is accurate. Please look at the implementation of scoredTuplePerStream in the super class. Shouldn't you take into account the outputFields and predictedFields. Furthermore, I think that you need to use EvaluatorUtil.decode(targetValue) to account for cases where the values are wrapped in complex objects like maps. That means that you should likely mimic what is done in the superclass toValuesMap(), and then used it in the for loop as you have bellow.
Do we still need nanos? We have lost the precision of nanos anyway, and toNanos() basically scales it by **1000000** i think. We could just use millis if there isnt a specific reason for using nanos.
VmNetworkInterface already has a constant VALID_MAC_ADDRESS_FORMAT which you can use.
You added a parameter but this command is also used from other places, so this will cause compilation failures.
Should be nic?
Why do you wait?
This is fine for a stub implementation. It's not entirely clear when looking at the tests, but this uses the multiget command (<LINK_0> It gets multiple jobs in a single round-trip. This could probably appear in two flavors:  java public List<Job> get(final List<String> jids) {} public List<Job> get(final String... jids) {}
If it is possible, let's try to restructure this a bit so that it is a little more intuitive.
what about case when predicate evaluates to FALSE_LITERAL?
no "else" required after return
The method will grow (i once already wanted to add something here), so what about putting this in a more lengthy but more readable way? (Note, I also changed TopNNode's condition)  if (planNode instanceof JoinNode) { return true; } if (planNode instanceof AggregationNode) { return true; // here you could differentiate between partial/... } if (planNode instanceof TopNNode) { return ((TopNNode) planNode).getStep() != TopNNode.Step.FINAL; } return false;
CodePointIterator might be a better choice here?
byteValue() is redundant
It doesn't really matter, but could be: java return new byte[] { (byte) (val >>> 24), (byte) (val >>> 16), (byte) (val >>> 8), (byte) val };
This line is now unnecessary because disposedOperators is updated in disposeAllOperators before throwing an exception.
I wonder if we shouldn't throw some exception?
nit: it should be a separate hotfix commit.
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
jsonRow != null? So what will be happen when jsonRow is null?
Could you do:  String[] strings = new String[num]; Arrays.fill(strings, ""); return strings;  ? :)
For loop?
Better: append this unconditionally, and only append the other part based on the condition.
Can you use <LINK_0>
I don't like it. For me it should be very simple:  return "ExpressionEvaluatingSelector for: [" + this.expressionString + "]";  The compiler optimizes it to the StringBuilder
Why not reuse existing? public static Type valueOfIgnoreCase(String name) { if (name != null) { return valueOf(name.toUpperCase()); } throw new IllegalArgumentException("Invalid value null"); }
Should this also handle the suffix 'es'?
Try to use constant non null values in front for comparison methods, as their is less chance for a NPE. "COOKIE".equalsIgnoreCase(name)
Please don't introduce labels, as I removed them in anoher pull request because sonarcloud complains about them (and not just sonarcloud)
Interface appended to variable name
I would have expected a Collections.unmodifiableCollection here.
this is as bad as flatMap, we need to look further into this in a next iteration
extract the logic to fetch/build the retry policy to a provate method, for code readability
shouldn't this be synchronized as well?
If you want you could build the whole string directly as: String s = bids.stream().map(snapshot::getBundle).map(this::represent).collect(Collectors.joining());
It looks like the previous impl used log4j to log. Did you intend to just print to stdout now?
Actually trying to get rid of this in replica metadata request too. The logs are already too large
Wouldn't this prevent the constructor from actually throwing FileNotFoundException?
this is going to run out of sync with the callback in the send method. If the awaitUninterruptedly returns false, dataInputStream would reuse the responseByteBuf set by last send.
You might want to move this into a shared helper method for other tests which need a temp file with random data.
private, should only be called from the builder.
Do you want to rename the fields, too?
Please remove this empty line.
String can be externalized.
I think we still have a race here. The launch could technically already be terminated. You can use fLaunch.isTerminated() to know if you should disable the action.
Don't need a capital on Exists. I also think it would be good to have more info here such as: * Warning the suer that the new console will open over the old one * That anything left running in the old one will still be running in the background * How to switch between consoles * How to terminate consoles
Aren't these args backwards?
you don't need to collect inside getMachineNames if you stream it again on next line. Just return Stream or maybe getMachineNames is not necessary here and just inline it. If you want to split the long stream chain I would maybe do something like  Stream<String> machinesInPod = containers.stream().map(c -> Names.machineName(podMeta, c)); return machinesInPod .map(....
Shouldn't that go into QueryResultBuilder?
Are we using lamda notation in this project?
IMO, we should directly pass bundle, instated of intent.
Add a try/catch block and log any errors. Don't want logging to affect any normal operations.
this check is again done in getTaskCategory(..) and is redundant.
Same here. Does this TreeSet is needed?
Does this TreeSet is needed? It looks to simply find the worker of the max used capacity.
Spacing
Looks like there are true/false for query conversely then in other factories - should not be false for create and true for getMechanismNames?
I think it's better to use Boolean.parseBoolean here, i.e., Boolean.parseBoolean((String) props.get(WildFlySasl.SKIP_NORMALIZATION))
suggestion throw new RuntimeException(String.format("Failed to parse geometry from string: %s", argumentValues[i]));
suggestion throw new RuntimeException(String.format("Failed to parse geometry from bytes: %s", BytesUtils.toHexString(argumentValues[i])));
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
Remove conditional + exception. Uniqueness is guaranteed here.
Let's have this enforce that hasher is the equality hasher.
whooops :-)
This would be set on the event. A PRE_DELETE event doesn't have a delta, so you'll never get here. Just remove this.
I would like to see all new code using lambdas where possible.
I think all this can actually be removed, including the then unused import of org.eclipse.core.resources.IResource. Additions and deletions are always interesting, and GitResourceDeltaVisitor.isInteresting(delta) does return true for them.
I'm really sorry for your work, but in my opinion a simple TextInputDialog should be sufficient (instead of a custom dialog): <LINK_0>
Why did you move the mockings here?
maybe something like this instead?  File file = new File( directory, targetFile ); if (!file.exists()) { fail( "Could not find file " + targetFile ); } return file;
No need
Propagate IOE and ConfigInvalidException instead of translating to RuntimeException? I'm not happy about this translation -- unclear what the effects will be. If you propagate checked exceptions, the caller has to think about what to do with it. Most callers already catch IOE and ConfigInvalidException from load().
Should we check for systemConfig.isOutdated() as well?
s/createPolygon()/createMultiPolygon()
s/numnParts/numParts
unnecessary else
"Couldn't rename [" -> Fail to rename
move this check at start of the function.
app = getApplication(appNameOrId) if (app == null) { app = getApplicationByName(appNameOrId) } To avoid calling getApplication and getApplicationByName twice.
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
No need for a list. Just return the first non null value
Maybe we should move  && !authorizationProperties.get(id).getOnDemand() to public boolean isAuthzClient(String id). And enrich AzureActiveDirectoryConfigurationTest.
Since the subject isn't initialized until the callback returns. Won't this most likely lose the race and cause an NPE? I think this could be solved by making an AMLoginInfoTask subclass that provides latching mechanisms like AMSubject and Subject. So the code here would look something like (super approximately): LoginInfo info = new LoginInfo(); info.execute(); info.await(); assertThat(info.result(), ...); // Even more approximate if (info.legacyAuth()) { Subject subject = new Subject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); } else { AMSubject subject = new AMSubject(username, password, null); subject.execute(); subject.await(); assertThat(subject.result(), ...); }
Same nit about L.e(caught)
Missing @Override.
No need to do this, long strings are fairly common and the checkstyle configuration accounts for them, so they shouldn't trigger a warning.
The Presto code base generally rejects nulls rather than being null-friendly, so we should not allow null here. Users should instead pass an empty collection. For example, ConnectorTableMetadata does not accept null properties. Nit: static import unmodifiableMap and emptyMap for readability, as the method names are self-descriptive without the class prefix
this.requirements = requirements.sort(new PriorityComparator()); ? instead of creating duplicite comparator to sort requirements.
I'm not positive that updated won't be called with a null for the config parameter, for whatever reason. It's safest to simply return in that case.
please refactor number into a constant member field
please remove this generic log statement to decrease to level to trace
can you make the name more explicit? array doesn't indicate anything.
Is it possible that the same project is added to the list twice?
consumingSegments must be a set or it will containing duplicates
should cleanup be in finally block?
Alternatively, you can consider this method: <LINK_0>
what is ".jor" ? can we make it as a constant variable a meaningful name?
Pass in true for the second param (discardUndefined), and remove the undefined model node from the values
Given that this is a map attribute, when is this value ever FALSE? Why not use DiscarcAttributeChecker.UNDEFINED?
You also need to transform for the attribute for old version 2.1.0. I recommend looking for usage of ChainedTransformationDescriptionBuilder to make it easier to add transformers in one place going forward.
remove local variable
Again, I don't see anything wrong with the existing use of implicit casting. It's much easier to scan.
<LINK_0>
Runtime Exception
We could use a Matcher here and re-use the Pattern. OTOH this would not be thread-safe anymore and we would need synchronization or ThreadLocal. Probably not worth to be changed.
Runtime Exception as well
Another option would be for WarningAction.onAttached to call Run.setResult automatically. On the other hand I can imagine wanting this drastic effect to be explicit.
reuse i18n messages
better to construct this message in the same way as it is being constructed where the exception is thrown.
I know I have a split opinion. I'd would take a stance that this constructor should be used only when we start writing in V2. Until then, its confusing why the callers are sending in defaults. This makes the caller assume that toBytes() will serialize in V2, which is not. We have to come up with some standardization wrt this new version upgrades in general.
Suggest message be changed to "Return is not equal to expected replicas". The current message implies the return is a list of replicas, which is a strong statement.
why would a NOT_MODIFIED response have a ACCEPT_RANGES header? Is that what is expected?
Nit : you don't need this local, you could just inline the member in the next line. (it doesn't matter)
sgtm
Can this ever be null? If so, we'll end up throwing an exception here. Or maybe it doesn't matter since something else will crash eventually? eg binding a socket to network?
what happens if remove() fails (throws an exception)?
You dont use anything from container except the name. Maybe leave param containerName?
I think it makes sense to limit Che container name like to 50 characters and if preliminaryName is too long then get first 12 characters from Che Plugin Name concatenate Che container name along with '-' separator. @garagatyi Please pay attention to this. Maybe you can suggest a better way.
the path always starts with '/'. If it doesn't start with '/', then it isn't the path. (You're probably accidentally using '/' as a separator between the authority and the path. Actually the '/' is a part of the path.)
I'd prefer to remove/deprecate AsyncTracer in favor of proper APIs to support what we want to measure. <LINK_0>
in addition to this we should add to the request attributes, e.g.:  // convention is package naming requestContext.setProperty("com.palantir.remoting1.traceId", Tracer.getTraceId());
No, This is not right place to dismiss the dialog, do it <LINK_0>
This is not a good way to add the Ids. Do this. java if (isGroupAccount) { savingsPayload.setGroupId(groupId); } else { savingsPayload.setClientId(clientId); }
since the index of returns, the first occurrence is there a chance this will break in CDATA inside CDATA scenario?
Do we need to spoof the location in the packet or can we just create the ender pearl at the correct location server side (by adding 1.75 to throwLoc)?
You can replace 24_60_60*1000 with static variable. Something like DEFAULT_REPORTAL_CLEAN_INTERVAL_MS. Makes things easier to find. Same with the following defaults.
Spotted that double semicolon ;)
curious: why remove anyTree?
It's sad we had multiple params per line before. Let's fix it by having one param per line.
same, one param per line
Locking the configuration shouldn't be necessary. FileBasedConfig extends from Config, and Config is thread-safe via atomic references. So you just need to determine if either file needs to be refreshed, and if so, run its load() method again to pull it in from disk.
Is this call necessary? It is called on line 109.
Not sure, why not use @NotNull?
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
Maybe use message "Config job.name is missing" ?
Print a warn log mentioning that registration will not happen if the participant is null
In general, I think we should start the tasks that need to be started, and then stop the tasks that are supposed to be stopped. The other way around could potentially introduce latency.
times(1) is unnecessary (verify(taskList) implies times(1)).
not your fault nit: please change the type of toCancel to Set<DatastreamTask>
inverting the if-condition allows an early return and thus saves a level of indentation
maybe a log here and for getRemainingBadInstances would be nice.
I would go with stream iteration :)
minor: can be final
a do-while will avoid checking 2 conditions (the while true and the CAS)
move this to the end of class
* There is nothing random anymore in the value of this variable, so the name is wrong. * We have a relatively small set of cases to test, I don't see why going though so much Java code to edit in memory a VSM via hard to read and duplicated logic. Simply craft a VSM with the 8 possible combinations and make the test simply call validation on it. * The test does not cover all the cases.
Gerard, I am not following as well, could you please explain it a bit?
If you use only the flat representation of the super type hierachy there is no need to build a graph data structure (Node<T>).
suggestion FSubscriberTransportFactory subscriberFactory = new FJmsSubscriberTransport.Factory(connection, "Consumer.frugal-examples.VirtualTopic.", true);
Shouldn't use virtual topics to match other examples
nit: Doesn't matter much because these are just examples, but I think it would be more clear to use the methods on the options builder instead of using an opaque properties object, like Option.Builder optionsBuilder = new Options.Builder().server(Options.DEFAULT_URL);
rename to res
rename to launch or config
rename to conf/config
lets make this an internal server error
is the adjusting of the version required after the removal of snapshot version from equals()?
are we not comparing every field in Account ?
please put in a separate method or rename this support method accordingly
double check that the group is still here
double check that the group is still here
I suggest to name it "binding" instead of "b"
The original code is actually wrong. It should have returned false ^ fNot. There is also an error in the TmfFilterAndNode. It returns true when there are no children. It should return false in that case (^ fNot). I guess the unit tests of both these classes should be improved to test: - No child (expect false) - No child (fNot=true) (expect true) - All children don't match (expect false) - All children don't match (fNot=true) (expect true)
Maybe better to return null
Shown on the UI so should be i18n aware.
why not pass this in #init?
we're used to write it as if (!t.isFree()) .
- Does Consul take docker client as a parameter?
Just calling this out as another place it would be helpful to log the zone
This could benefit from checking for IndexOutOfBoundException.
What is the purpose of this logic? From the xml file I can tell that the 0210 thing has this channel, so why do you have this check and addition logic here?
remove this "if", only keep the "else" - you must not set yourself HANDLER_MISSING_ERRORs, this is done by the framework.
no need to check, simply set it to OFFLINE
Why not directly call a canDeleteInstance(input) ?
Shouldn't this be canDeleteInstance(input) && canEditInstance(containter)? Why would we need to delete the container?
Are you sure that this DRepContainer will be use at the end?
I think we should avoid calling getById multiple times.
Not really related to this future, but maybe we should have just one set of "lookup" methods? And always pass parameter to it? Do you remember why we decided to have two sets?
Ignition should be boolean value. If it's not, we can just ignore it.
Did you mean to call this on the view instead of the system table?
wait 15 seconds to match the code?
I don't see why we need to match the error message here.
No big deal but think readTree accepts JsonParser too.
We shouldn't catch any IllegalArgumentException here. Can you change DottedVersion.fromString to throw something else, so that we catch a more precise exception? (using an unchecked exception is probably simpler to avoid changing the call sites)
When would this exception be thrown / can it be caused by user input? If so I would prefer a checked exception here (even if it's a DevfileException or something) since unchecked means more to think about.
just remove the fileSize from here... and that's the only change you will need.
Left-over debug ouput?
Really complicated micro-optimization nitpick: there is a separate get and add call - that's at least 3 lookups. We can reduce this if we introduce a boolean addOneIfAlreadyExists(Tuple) method to TupleMask as a variant of add() that does this in one step. Or maybe leave it as it is :)
we should check mMediaUpoadHandler != null before accessing its methods here, as they are only created in onStartCommand, I believe there's this slight possibility onCreate is called and then onDestroy gets called immediately afterwards (without onStartCommand being called).
Shouldn't this null check come after the getPostByLocalPostId() call below?
We might want to consider logging this with info severity, wdyt?
Here errorMessage needs to have single quotes escaped. The permission error ('You don't have permission to upload media to the site'), for example, causes an error. errorMessage.replaceAll("'", "\\\\'") should do it. We should probably do this everywhere we're sending string literals from Android, since a translated String may contain a single quote even if the default one doesn't.
cat > \"" + filepath + "\" ... would be preferable to handle paths with spaces.
can we use MoreObjects.toStringHelper(this) like we do elsewhere in the codebase?
Looks like this now should be withing if (result && this.fullStatsEnabled) as well.
Does new consumer start not earlier than 10 sec and only if one of consumers 'got tired' from more than 10 message?
maybe reverse?  (isFullStatsEnabled() && this.sendCount.getAndIncrement() % this.sampleSize == 0)  Because we always getAndIncrement() independently of full stat enablement. Have I missed anything?
I don't want to have us get in the habit of manually building JSON strings. We can use the JsonObjectBuilder from the javax.json package, or we can build maps and pass those to Jackson (ObjectMapper) directly.
Why do we need frontend changes when we don't plan to expose Jobs in webadmin within its own view like other entities (hosts, VMs, ...)?
Not an issue, but could be rewritten as  java if (entity.isPersistent()) { // do stuff }  to avoid multiple points of return from the method (and save a line of code).
warning for missing non-nls. Isnt' there a constant for that?
please implement toString using ToStringBuilder which simplifies debug.
Update this message, user will not know about 'commit'; that's internal implementation.
IIRC anonymous users will crash here because they have no user account to get the prefs from.
Maybe make this java sb.append(nullable ? ", nullable" : ", nonnull");
See above about the countries map (here you would loop through the keys)
Hey @mjsax . Sorry, but I didn't follow this change. How does this test pass when it expects the value to be 7, but it's now 3?
What's up with this last one? Should it be in the finally block?
Is this idempotent? PUT should be idempotent. What happens when we call failQuery for a query that's already failed?
I'm wondering whether it's worth to also extract this into a field, like is done for trees. This method isn't on a hot path as far as I can tell, but having the symmetry and separate code might still improve readability of the code. What do you think?
maybe get enclosing element before the loop ? or this operation is not very expensive ? Something like:  TypeElement methodEnclosingType = getEnclosingTypeElement( currentMethod ); for (...){ .... if ( elementUtils.overrides( currentMethod, (ExecutableElement) element, methodEnclosingType ) ) {
Can you repro this on master? If yes - definitely worth filing.
Do you think it would be better to find a way of doing this without sorting a collection on every call?
for me it looks like a fallback strategy, I'm not really sure if we planned to have such functionality.
Maybe use some of the runtime exceptions from MyNakadiRuntimeException1 ?
Since the fields are not final, I don't see the point of setting them to null explicitly.
use Collectors.joining instead: return strings.stream().collect(Collectors.joining(","));
It is best practice to use editor.apply() as commit() should not be called from the UI thread.
Typo: line too long. Let's assert here that error message contains correct error description schema 'DOMAIN' from joining node differs to 'DOMAIN_1'
Haha! I found one redundant symbol on this line!
Typo: line too long. Let's assert here that error message contains correct error description the config of the cache 'poi' has to be merged which is impossible on active grid
maybe use dnsServerAddress.isEmpty()
Its worth adding a null check here too.
why is it Collection of Strings (instead of String)?
Why it is named by testLoadYamlFileFromDirectory ? Does it mean it will include all .flow files in the directory?
consider to put the check in the util class like FlowUtils? i guess it will be used in multiple cases? but not every one will remember to use Double.compare to compare two doubles. At least for me it's not occasionally to just use "==" :)
path or name?
it can destroy vungleBannerAd from the new adapter on refresh.
The only problem with this approach is that Nested views may appear as a search result even if there is TopLevel view with such name. And as a user I would expect them to have higher priority. Maybe it worth checking all TopLevel views first. I would also vote for making a parameterizable method View getView(String name, boolean recursive) and maybe changing only the API calls which are really related to search. Otherwise it it hard to predict the impact of the defaukt behavior change
destroy should be called.
Same as above, What happens when you print the outer DatastreamException
When you have innerexception do you still need to print the exception? Won't the inner exception be printed twice when you print the outer exception?
this log statement seems like it should be outside this method and logged by the invoker instead
What about handling the case where the ASTValue is NOTHING? It should be legal to assign a variable to be nothing, as in, "x is nothing.". Also, is it legal to assign a variable to an object? For example: Fred is a person. X is Fred. (If that's legal, garbage collection becomes harder, so it's probably not legal. But if it's not legal, then the code here will silently do nothing, whereas I think it should give a runtime exception to the user.)
This error msg (and similar for times and minus) seem to have copy paste artifacts.
It's better to assertInstance(value, CStringValue.class) first. This way, if the value is of the wrong kind, the test fails with an assertion failure rather than an exception.
Can you please check the full expected result? One way to do this would be to build the expected Config manually and then compare it to the output of buildCoordinatorStreamConfig.
We should only set the field when the key is present in the manifest, otherwise we will have to alter code in two places when the default behaviour for detectNdkCrashes changes to true.
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
nit: I know this is following existing test case, but since we now have a logger, we can use this:  LOG.info("Got expected exception", uhe);  Sytem.err in test code is not friendly to test output/log interpretation.
shouldn't we add into names?
here we need to use instead this pattern: java java.net.SocketAddress addr; if (channel.hasAttr(REMOTE_ADDRESS_OVERRIDE)) { Attribute< java.net.SocketAddress> attr = channel.hasAttr(REMOTE_ADDRESS_OVERRIDE); addr = attr.get(); } else { addr = chctx.channel().remoteAddress(); }  Calling attr(key) while it is not set will have the side effect to create the attribute. Attributes cannot be removed.
unecessary test : less is more.
Returning the process seems really weird to me. I would make the method void unless there's a good reason otherwise.
would this have been a different exception without the \u0000 ? (i.e, because "command with.." doesn't exist..) for avoidance of doubt, could we use a command that does exist ?
I wonder if something like src/main/java/org/apache/calcite/runtime/CalciteResource.java should be used instead
Suggest to use index instead of a column alias. Also seems like this is a simple count utility. Can you rename it to something like "getTupleCount()" ?
Confused by the return value of this method. Should the results of the connection-checking query influence the return value? Or is the strategy to perform the query and return true no matter what, assuming a SQLException has been thrown if the connection isn't valid?
I believe we added a guard class to the sdk that will do this exact check.
That is fragile. The knowledge about quoting the each element is both here and in org.spine3.base.Stringifiers.isQuotedString. Making any change to either of these places will lead to a hardly-traceable fail.
in general we try to avoid constructing new objects in the incrementToken() method, this generally applies if you own the stemming. The call to StringBuffer would be better placed in the constructor of the filter and then reused. In this case it may be hard to remove all allocations since we don't really the filter code. A nice java feature to keep in mind is that all string related classes extend CharSequence, so sometimes you can just convert all method signatures from String to CharSequence and send the StringBuffer you've built in the constructor saving some allocations.
Since keyFile,passwd & alias are used for both methods, I think it will be nice to put them as private (final) members of the class
Why was the reflection needed here? is it due to API levels?
there's responseToString below, which increases the similarities with configureConnector
It's a bit confusing to call get method to recover something. It's basically using it's side-effect. In getInternalRuntime, do we really need writelock for just getting the runtime? Or is it needed only for restore?? If so, I would rather handle writelock in recoverone method and make getInternalRuntime simpler with just readlock. I agree that this solution is simpler and safer one, but it's not the most readable and intuitive.
@bhaisaab as the _completedTestCount_ is incremented at the _oneMoreTestDone()_ method, I think that this log could be moved to "_com.cloud.utils.testcase.NioTest.oneMoreTestDone()_"; this would remove the need of _Thread.sleep(1000)_ and let the log clean.
Passing args in new line seems a little weird to me. Any specific reasons for doing this? If not we can follow the style we follow for other API calls - client.makeBucket(name, "eu-central-1");
Should be the responsibility of service/requestman layer after Hibernatization
Here and below, since there are no bodies, you can just use {} instead of {\n\n}
random? really? I would have used idFor(). public ObjectId insert(int objectType, byte[] data) { return idFor(type, data); } public ObjectId insert(int type, long len, InputStream in) { return idFor(type, len, in); } or something like that. I forget which of the insert methods is the "bottom" of the call stack before punting to the InputStream version that is required, but I would implement both in terms of idFor and return the actual SHA-1.
Why not set it to postgres in ctor?
You should throw an IOException here, because the source directory can't list the content.
putByte() with loop sounds slow (I saw it was around 5x slower). How about using java.nio.ByteBuffer#put(java.nio.ByteBuffer) and java.nio.Buffer#limit(int) like this?  int currLimitOfSrc = src.limit(); src.limit(src.position() + len); reference.put(src); src.limit(currLimitOfSrc);  It's not urgent and we can improve it later.
Could you make this message more informative?
Interface can be used here.
A validation should be made to compare the oldCategory.getUser() to current authenticated user. Maybe...what do you think?
Unnecessary intermediate collection.
return null.
can be just inlined as setItems(new ArrayList...)
Please keep this.cell near the related fields (previousFamily & cell count) below
Can this be private, or is there another use case for default attribute outside the builder's call?
Don't understand this. This needs to happen only exactly once right? So it was at it's right place in first run?
listView.setHasFixedSize(true);  listView -> recyclerView? Also, you can take <LINK_0> and  RecyclerView.ItemDecoration itemDecoration = new DividerItemDecoration(getActivity(), null); listView.addItemDecoration(itemDecoration);
As this method is duplicated thrice, you should make it a static util method boolean isRTL(Context context) and then use context.getResources().
Companion
just use an EnumRenderer in the view instead of localization in the model (and modify Enums.properties...)
can be just inlined as setItems(new ArrayList...)
split this to 2 tests. you're acting on the same command instance. Have a look at the @Before annotated method. It bootstraps all the test data including the command)
You actually don't need a whole Project Object becaus you only work with lists of project, please change the functionality to only work with lists, by now
Consider to use an ImmutableList here
Perhaps you can remove the temporary variable entirely and use map to make this method a one-liner?
might want to change this to checkButton.setText(Strings.isValid(checkBoxMessage) ? checkBoxMessage : "<NONE>");
lambda?
Why do you need 3 columns here?
let us avoid the thread from crashing...and remove this code.
Type casting should be avoided and seems indicative of a problem with the model. Why are you not passing the configuration via the constructor?.
Missing generics
nit: precondition goes to the top
Keep this static imported?
exist .. and why the underscores? Also, add the tablename for which this error is coming.
can we also include a test where we set includeInsights to be true?
the previous way of formatting the else conditions is preferred. Use } else { on the same line.
display should be something more unique to the resource than the report status. imagine you return a list of RadiologyReport via REST and would only show the display property. use radiologyReport.radiologyOrder.getAccessionNumber() + radiologyReport.reportDate + radiologyReport.principalResultsInterpreter be aware/test for null!
This looks rather scary here: I would think you'd want the return type of #processUpdate to indicate whether there was an event that should cause everything to be reset?
Unclear if this has been a convention throughout Lock Watches, but the decomp - in particular, rejecting a success from post-leader election without a snapshot _here_ - seems a bit unexpected. I'd prefer this just return the version, and updateVersion take care of that filtering. It looks like you do that anyway in updateVersion!
ah, was going to suggest a test to guard our assumption :) Nicely done !
This function doesn't seem to be used anywhere.
Just add an envelope section to createFromEsriGeometry method in this file
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
nit: not sure if datadog cares, but we should skip tag if it's equal to ""
let's have something simpler and more readable like java if(!tags.containsKey(name)){ tags.put(name, new HashSet<>()); } tags.get(name).add(value);
Should this work with versionID? It's already in stg73 branch.
I think this should be after oos.writeObject(o);, in case there is buffered data. In any case, before obtaining the byte[] result.
You can consolidate these into a single try e.g.:  try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos); ObjectOutputStream oos = new ObjectOutputStream(gos)) { oos.writeObject(obj); conf.set(key, new String(Base64.encodeBase64(baos.toByteArray()), "UTF-8")); }
Should these go to logcat?
Why don't we store the build folder as a full path, so we don't have to relativize again and again? We need to keep in mind that this is called for every folder that is ever added/removed/changed.
Instead of generating the file path, checking existence, failing or get the file why not use java File playbackFile = new File(folderFile, testName + ".json"); if (!playbackFile.exists()) { // throw exception } return playbackFile;
If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The startMonitor method below also checks for the return value of this method being null. I guess null would then also be the default.
Removing test because you can not fix it is usually bad idea
As it's a nullable field, null protection would be good just in case: if (occurrence.isValidated() != null && occurrence.isValidated() != validated)
same, "error" seems redundant here
Do we need to check Null of the input parameters?
use SLF4J {} expansion rather than inline; there's a lot of commons-logging era log statements, and changing a line is the time to upgrade them
Need license here too.
nit: final modifier for unmodifiable variable.
Did we mean to remove the subscribeOn here?
Instead of calling into the Utility conversion method we should just chunk the InputStream into ByteBuffers the size of ParallelTransferOptions.getBlockSize. It'll need to be a conversion that runs until the InputStream is depleted and indicates end of file/stream.
modify it as it was implemented in ENG-10264
typo
i < ... is the widely accepted way. Should never ever happen to exceed the maximum, but you never know...
AggregateRoot is not an Entity.
Ideally, this test wouldn't require any change to pass. The aggregateType wasn't used in the past, and unless polymorphism is used, the type shouldn't really matter.
Can you use the information stored in the row for all parameters? That might be slightly more safe in case there ever is a big with any CQL statement? Also the creation time should be set to the creation time and not 0.
i think initialization code should be in constructor but its only my opinion, not mandatory
printing contextId in the message will be helpful for debugging.
Did you mean if (memoryStore < numInitialEvals)?
this doesn't look like new code... was it reinstated after a merge or something?
log the sleep duration maybe? and maybe remove the exception?
It is ok, but looks a little bit strange Above direct access is used (this.hostName = ) but in catch value is set via setter (setHostName("unknown-host"); )
Cloning after calling getEyeLocation is unnecessary
Couldn't this just be configurable?
@xpdavid is this the right thing to do?
Do this check before the for(), because if this.notificationConfiguration.isEnabled() or this.notificationConfiguration.areEmailsEnabled() are false, you don't event need to load the descriptors and so on...
adding to returnEventChunk should be out of the function joinBuilder, and join builder should return the built event. Because the function name does give a hint that it will be added to the return event chunk.
Will this happen
Does that handle 'null' properly?
I think you could read the file contents with many fewer lines of code, especially in Java 8. Something like: java return Files.lines(filename).collect(Collectors.joining(System.lineSeparator()));
It should append CRLF as well.
have a default constructor with reasonable default values
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Can this be private, or is there another use case for default attribute outside the builder's call?
this line can be removed (variable end not used)
Hmmm, I think this JMX attribute became kind of useless the moment we stopped allowing the mix of tx and non-tx operations in the same cache, and now even more so because the number of deadlock checks isn't deterministic. I'd deprecate the attribute and remove this check.
Why bother locking if the size returned is immediately going to be invalid? aka, some other thread may have already changed the size.
stringutils.empty
The reference could change between the first and second checks. You should extract it to a local variable first. Then you can do null-check + call. The second part could need locking, but if you mark the method itself synchronized, as mentioned above, you won't need a synchronized block here at all.
Request.State.OPEN
I think you may be able to .put the added PartitionData into sessionPartitions up front, and capture the value returned by the .put, as it will return the previous value. If the previous value was null, then we add to added, if it was not null we add it to altered. This will save us the additional containsKey check.
nit: not from this patch, but topicPartitionBookkeeper.topicPartitionBookkeeping is really annoying. Maybe we could rename the field to just partitions?
nit: we could use putIfAbsent here
How this change makes anything better?
Try to not use else.  java if (content instanceof List) { return from((List<String>)content).toArray(String.class) } return new String[]{(String)content}  BTW valueArray is not a good name and values is better.
It would be good to change this to private
I think you meant LOGGER.debug("Initialized debug logging"); ?
This is sort of awkwardly phrased, should change to something like: "Should have failed if session.execute called when cluster was closed."
Can it be null? You assume it's not in other places.
Having execute{Head,Get,Post,Put,Delete} are just wrappers to execute() for convenience and readability across APIs Spreading the logic of type checking will lead to confusion in future and its not a good idea.
This should be done in execute()
this might not be true for 'executeDelete()' when we implement Multi object delete API. Change this to executeDelete() itself taking the content length.
Why is this hardcoded to 4 threads? Should there be an option to control this?
We should use Configuration so we can pass STORAGE_CONNECTION_STRING via system properties or environment variables
This should be scoped to when the build method is actually invoked.
suggestion  refresh still shouldn't be necessary.
Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable
Using printedTable might make these assertions a bit more readable.
If this fails, it should be reported like this: ActionReturnValue attachReturnValue = attachToClusters(); if (!attachReturnValue.getSucceeded()) { propagateFailure(attachReturnValue); return; } I wonder if it is possible to rollback the whole command if this fails.
I think the propagation of the failure here can be improved. There are two options - 1(preffered by me). If the attachment of the network to the clusters fails, the whole network command should fail and the added network should be rollbacked. In this case the network attachment should be in the same transaction as adding the network. (Move it to line 81). 2. Even if the attachment of the network fails, the network shouldn't be rollbacked. It means the attachment is nice to have in this command. Therefore, the attachment error shouldn't be propagated and the AddNetworkCommand should be marked as succeed. The attachment error will be printed only to the audit log (please verify it if you choose this approach). In this approach I would even use a different thread for the attachment, since the AddNetworkCommand doesn't need to wait for the attachment to finish its work.
I think it would be nice and readable to move the added lines into a new method.
Think @sandeepSamudrala mentioned in the another pull request. Should add location to the resultObject.
NIT: strange formatting glitches
what about renaming JSON_VALUE_TOPIC as well?
This can be small D double
These members don't appear to be used.
We use small d doubles for simple calculations.
It's good practice to provide as much inforamtion as possible. Please, use constructor of WrongAttributeValueException with additional parameters Attribute and AttributeHolder.
Sonar reports an error on this line: - Remove this useless assignment to local variable "lookupAttributeIndex"
This syntax is quite confusing.
checkNotNull
With <LINK_0> could we remove this method, avoid the loop and use trace.getAnalysisModule(id) instead?
In the events table the columns "Tid" will display the HostThread.toSting() which includes a long Host ID. This is not what I expected for that column. Shouldn't we see the TID value instead? It's confusing for me (at least for me).
s/Started/Starting
If this throws an error it should not need to log it. Perhaps you can throw new RE(e, "Failed to start lookup [%s]:[%s]", lookupBean.getName(), container);
in the end can we log the failed lookups that we were not able to load even after all retries?
No need to cast a Player to a Player here.
else on the next line after the bracket.
No need for the rather unncessary and expensive call with the ItemStack here, you can just use this here.
Why do we want to return here ? Even if we retVal is null, we can initialize retVal here and the list can be added with the output of fPostListenersByPartId.get(listenerPartId)
could probably inline, won't be null
instead of != null here, you could do a instanceof ISegmentGenerationListener. There shouldn't be any ClassCastException, but this way, you would avoid any such error
you can append "twice()" to the expect
This whole logic could be simplified as:  private void verifyExceptionalState(ThrowingRunnable action) { assertThrows(TaskMigratedException.class, action); // This task should be closed as a zombie with all the other tasks during onPartitionsLost assertThat(assignedTasks.runningTaskIds(), equalTo(singleTaskId)); EasyMock.verify(t1); }  so that new test just needs to put in the intended action. Here singleTaskId is a class level parameter I defined to replace the singleton list, which is not highly required.
Should we verify regardless of the NPE?
Swap the equals condition.
We can use the constant - MultitenantConstants.SUPER_TENANT_DOMAIN_NAME here.
shall we use a more meaningful name like 'gson' rather than 'g'?
I don't think it's the job of this class to invalidate a valid offset_s. If the user wants to handle timestamps in nanoseconds using long, the user should check its own overflows.
I think .equals would handle it anyway, but to be safe you should put a L at the end of the literal.
Same as with getBigInteger, but it seems really strange here to force a conversion to Long first.
Instead of always firing this and having the receiver figure out if it should do something, why not determine if we should fire the event here, and have the receiver just do what it needs to do when it receives the event.
Remove these extra variables that aren't used except in a setter.
You should use the ExceptionReporter here, otherwise we might lose exception from the WorkerOperationProcessor.
I Don't like this at all: the superclass is now doing different things based on the subclass. Prefer: factor out into an abstract method where each subclass does their own thing.
We don't need this check, since keyFromPath() is guaranteed never to return a key with a trailing slash. URI guarantees that paths are normalized (no double slashes) and keyFromPath() strips off any trailing slash. Having this check here is confusing because the reader has to puzzle over how this would be possible.
I would have expected a Collections.unmodifiableCollection here.
no need to specify type on RHS
Shouldn't each item in the list be a different Map? If it's the same Map, won't the last put() to "forestName" be the assignment for all tasks? Would it make sense to create a new Map within the loop, copy the properties with putAll(), and then set the "forestName"?
Not sure what Select2Common -> SuggestConstants has to do with the rest of the changes.
I think the granularity should be 1 seconds instead of 5 seconds here.
typo isDivisible
We can't use nanoTime as a replacement for currentTimeMillis - which is a true timestamp. As described in the nanoTime docs This method can only be used to measure elapsed time and is not related to any other notion of system or wall-clock time..
Should this pass true for dryrun, when calling parse?
Shall we use JSONObject in here rather than building json string by hand?
pass the exception itself rather than than just a message
Why do you do it here and not as part of the initDcList()?
what is this line for ?
Unless I'm missing something, this assignment never has any effect, because it's immediately overwritten inside the buildTree() call, so we can just remove it. Pushing this even farther: it's not at all clear to me that we even want a currentPoint instance field. Seems like it would be better to make the following changes: (1) change the buildTree overload with three arguments so that the last argument is the current point (not just its X coordinate) (2) add a P argument to setCurrentPositionFor() and pass the current point to it That way we don't need this piece of class-level state at all, which seems like a better/more robust design.
Duplicate in both createSubject and createEvidenceSubject methods. Consider to refactoring into helper method.
Any reason that we call the get method multiple times? zoneGroupIdNameMap.get(zoneID) is called four times (one time should be enough) groupIdNames.get(groupID) is called twice (onen time should be enough) So, instead of call get and if it is non null call it again, it would be better to store the result to a local variable and reuse it.
else is redundant here
Need to check for more than WHITE_SPACE here, too.
this is rather arbitrary... why the limit? we are always going to be able to get up to the basenode given that the childNode is guaranteed to be a descendant
Why use getSearchKey rather than getDisplayValue?
ex
change
Pass "e" into the LOG call and remove the explicit call to print the stack trace. (Avoid calling e.printStackTrace();)
assertFalse(...);
assertFalse(...);
java @Override protected void setUp() throws Exception { super.setUp();
I would like ot be extra safe here and it becomes smth like OS.GTK3 && !OS.isX11. This way I would be confident it would not have effect on X11.
paranoia: can we first set it to false, and *after* that call GTK.gtk_widget_queue_draw(widget);
if you exchange left and right it would be faster for non overlay case (us) :)
Check what happens with an empty file: Looks like on replay, both openFile() and closeFile() calls are skipped since there are no recovery entries for that file.
I think pending file is not required as your fileQueue becomes list of pending files.
This is not needed after ConcurrentHashSet
I'd instantiate the ProducerArbiter before parent and supply it to SwitchIfEmptySubscriber and child, saving on this 'relaying' allocation. (Remark, our life would be much easier if we could implement Producer in Subscriber, but since request() is protected final, it is unoverridable :( )
Can you please merge duplicating code here? Something like:  java final Subscriber<T> parent = after ? new BoundedAfterSubscriber<T>(child, capacityHint, predicate, prefetch) : new BoundedBeforeSubscriber<T>(child, capacityHint, predicate, prefetch); child.add(parent); child.setProducer(new Producer()  ); return parent;
This will conflict with a zip patch. Could you undo this?
It would make more sense to invert the names (the one with BUTTON1 is used after... call it stateMask2)
I don't think the timing of setExpanded() is the real cause, it is currently done in the correct order. It must some other timing issue that your patch is modifying and helping. Maybe there is something in the Eclipse platform that is not ready at the time that the events are received, maybe something is computed in a deferred thread? It needs further investigation to understand what is missing to properly set the tree item label and when does it actually get set.
In my testing on Linux I see another SWT.Selection between MouseDown and MouseDoubleClick?
Declared but unused.
if we store a boolean in the database, it can be answered by the DTO itself
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
close streams
You can remove the catch clause as it just rethrows the exception.
"plugins" could be replaced with ConfigConstants.DEFAULT_FLINK_PLUGINS_DIRS.
What about new File(internalFileDir, fileName.name()).getAbsolutePath()? I think we should not create paths by concatenating strings
So does the validator ensure that the filename follows a uuid format? What constitutes a valid filename?
You can remove the try/catch/fail. If an exception is thrown it will fail the test.
If response contains result (which it should contain) then you are creating new HashMap instance for no reason. Wouldn't following code be better: Map<String, List<String>> namespacesMap = (Map<String, List<String>>) SSOOAuthServiceUtils.getAvailableNamespaces( getSessionDataContainer().getSsoAccessToken(getParameters().getSessionId())).get("result); if (namespacesMap != null) { namespacesMap = (Map<String, List<String>>) response.get("result"); for (List<String> entry : namespacesMap.values()) { Collections.sort(entry); } } else { namespaceMap = new HashMap<>(); } setReturnValue(namespacesMap); Also if namespaceMap is read only, then even better would be to use Collections.emptyMap();
taskStorage.getStatus(entry.getValue().getId()) might return Optional.absent().
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
Not sure this is finally correct. I think this may still execute measure... two times for the same FileStore. Consider no value known initially, then Thread A: Starts future F1 Thread B: executes future F1, puts lock in map, calls measure... Thread A: times out on the get() on F1, return fallback Thread A: comes again with the same FileStore, still null Thread A: starts again a future F2 Thread C: executes future F2 Thread C: obtains lock from map Thread B: returns from measure... Thread B: sets value Thread B: unlocks Thread C: sucessfully locks the lock, calls measure... Thread B: removes lock from map Thread A: times out on get() on F2, returns fallback Thread C: recomputes the value, eventually puts it into the map Probably should check before line 239 or at the beginning of measure whether there's a value known by now. Same as why my code checked again while the lock is being held.
If we already have a value, we don't need to determine it anymore and can just return the previously computed value even for read-only directories.
canWrite() includes exists(), so no need to test for existence separately.
I don't see why we need a TBaseUtil at all and don't declare "isUnion" private in this class. I usually try to avoid "Util" classes. It could always be moved if some other class needs it.
Have you tried Collections.sort(fields, (o1, o2) -> {})? It'll save you from having to turn this from a list to a stream, then back into a list.
For a list the labelData is null
I think you need to do this and the next line in a finally
I would move the deprecation logic into warnAboutDeprecatedProperties
it should be possible to do this with streaming, no temp folder should be required.
the batch utility service has a function to remove a done file by passing tin the data file name.
Add synchronized here, because of baos and readBuffer. Or make baos and readBuffer local to readStream.
Why do we have the full name here? I did not see another FileUtils being used here.
lets make this an internal server error
You dont use anything from container except the name. Maybe leave param containerName?
Please consider updating of java docs as well. I don't see any java docs that would explain how we store machines names in annotations. I guess, previously java doc of MACHINE_NAME_ANNOTATION_FMT const has some short info.
We could create a new ChatMessage with messageData and remote
you should check if the message severity is ERROR
Don't we need to do something slightly opposite? Check for data instance of List and always call onMessageBatch() since it is there on the MessageListener anyway.
Should this method be private? Or protected? I don't see a need for package visibility.
Don't put :, just detail what went wrong at this level (and include the URL you failed to read). The cause exception will be printed after.
Not sure what JMX has to do with this?
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Should we return emptyMap if we are SUSPENDED as well?
I like the use of Map.Entry here. Nicely done.
Why are you using a Queue here? And then by extension a LinkedList?
This should Log the exception to the logger
missing final
nit: No need to declare these exception types now that we're calling getMajorVersion directly.
use assertEquals instead - it gives better output when things don't match. assertEquals("Test Version", atsVersionCache.getVersion(teamWf).getName());
Can be inlined in the assertThat statement below.
don't we want to remove the place holder in case of failure?
general : the countdown is better be in finally block to avoid any case in which we will wait forever
It looks a bit confusing, succeeded is true but we throw an exception. Is that neccessery if we throw an exception later?
remove "public"
these methods really throw exceptions?
Optional nitpick: all these this-es are unnecessary boilerplate and distracting (for me :P). But leave them in if it's your preferred style..
I don't think this is possible, if the cache is not defined it will be created with the default configuration.
Throw exception instead of logging it
This line isn't happening anymore, right?
use TWR to close
BUGBUG: Should be checking whether the shard contains the start position, not the entire event.
extract this code to a method returning CachingIndexedFastaSequenceFile
Shouldn't this be warning instead of info message? The message "kieMap not present with compilationID and container present" is a bit confusing Is the kie map not present? Or is it present but doesn't contain complationID? Imagine that you are a user who sees this log message. If the message is good he'll immediately know what's wrong and what and where should be fixed. Otherwise he'll have to look at the source code to understand what's wrong :( Also there is probably duplication of log messages on line 194: getLog().info("Kie Map not present"); - we should probably only log this at one place.
This will return an immutable map. Use new HashMap<> instead.
so this effectively only returns an empty TreeMap no?
Another %n?
Null check on ryaInstance
No need for final, it's already private
This block only compares AttributeAccessItem objects to themselves. It should compare them to the AttributeAccessItemDto objects from the corresponding indexes of attributeAccessItemDtoList.
public isn't needed
I think maybe job migrations can be moved into TaCoKitImportHandler.java? and we only need to add RepositoryUpdateManager.updateDBConnection(connectionItem, version, false, false); here?
There are a few checkstyle errors left:  [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:24: 'if' construct must use '{}'s. [NeedBraces] [ERROR] /home/circleci/AntennaPod/./app/src/main/java/de/danoeh/antennapod/dialog/FeedFilterDialog.java:29: Line is longer than 120 characters (found 145). [LineLength] [ERROR] /home/circleci/AntennaPod/./core/src/main/java/de/danoeh/antennapod/core/preferences/UserPreferences.java:1064:51: WhitespaceAround: '{' is not preceded with whitespace. [WhitespaceAround]
I think the dialog should not be cancelled when touching the outside. Back arrow and ok button are fine but I think it is too important to be cancelled accidentally.
Arrays.setAll...
I think we can later implement a logger instead of directly printing to sysout. For now it's okay though. :)
I don't quite like how this could end up running forever without stopping, shouldn't we make use of versionUpdateMaxRetries for this cycle as well somehow (or some new variable)?
Log the full exception here as well, this should be fixed in entire PR.
Hardcoded list of locations have to be removed before merging.
Unnecessary; the call to this(...) does it
Understood. IntelliJ does however suggest this small change: return new HashSet<Location>( asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE));
Shouldn't we be moving the elevator while we're moving the clamp?
It's probably best to have more descriptive names for these. "running," "direction," and "open" would be fine.
Won't this cause an issue if this doesn't get called - for example, if some error occurs? Then we'll never be able to start the AutoEjector again...
This won't work with generic builders I think.
We need to have a backup plan here if type isn't a TypeVariable.
Wouldn't it be better to do this in the constructor and have a final variable with it?
You can use filterableNotification here
This is a pretty drastic change in the logic here and I'm not sure this is what we want to do. So before your change, this would first check if locationGP has text and if it does, try to load that location. Then if locationGP didn't have text or the the location specified by locationGP couldn't be found, it would try to get the default location by calling the private getDefaultLocation() function. If none of those methods returned a location, it would try to get Location 1 (whatever that is) and return it. With this change, this will check if locationGP has text and if it does, it attempts to return that location. If locationGP does not have text (the check on location == null is actually redundant because at this point, we know location is always null), it will call the private getDefaultLocation() function. The function will then return the result of either getLocation(locationGP) (if locationGP has text) or the result of getDefaultLocation(null, locationGP) (if locationGP does not have text. In other words, I could simplify the logic in your change to something like this: java return StringUtils.hasText(locationGP) ? Context.getLocationService().getLocation(locationGP) : getDefaultLocation(null, "");  I don't think there's much to gain from trying to simplify this method much more than it already is... At a certain point, methods get too "simple" and the logic becomes hard to follow.
Should log properly and throw api exception?
avoid increasing visibility?!
initial null seems not needed. Probably can be a for () loop :) for (ISourceModule module; (module = modules.poll()) != null;) { ... }
Add catch clause for OperationCancelledException and return CANCEL_STATUS.
This is insufficient as googleId still leaks
This "else" has created on me a nice debugging session :-)
10 means what? Number of mini-batches? Please make it as variable.
you need a space between : user"+ userName
I like the way you change it (very smart) however I think this change is a very good candidate to create an unit test to test previous code working against new code.
Better initialize in an else block
Nothing harmful, but the null check is done twice.
This should go in a finally block in case an exception is thrown, right?
coding style:  try { ... } catch (ClassNotFoundException e) { // Don't mind... Attempt next class loader |
Minor: Please add whitespace before the final argument.
This function will trigger another event and retry the message, right? Why in the PR it said the message will not be automatically retried?
Alternatively, if the exception is not graceful, we can return null when createHandler() is triggered. This is much better than returning a handler that does nothing (but still consume system resources). Of course, the callers of createHandler() need to be improved to tolerate the null return value.
You can improve this further. Refer AddBrickPopupView.java Line:283 Sorry this did not come to my mind lastime :)
I'd suggest extracting this to a local variable.
View.edit(model) should not add new listeners to model object. This should be the responsibility of associated presenter - for example, in GlusterVolumeSnapshotCreatePopupPresenterWidget: @Override public void init(final GlusterVolumeSnapshotModel model) { super.init(model); model.getForceCreate().getEntityChangedEvent().addListener(...); } View.edit() is responsible for populating UI from model data and can be potentially called multiple times. Model listener registration therefore doesn't belong here, but in AbstractModelBoundPopupPresenterWidget.init(model) method override.
For consistency, I think it would be good to reset the other (Geode-specific) stats here too (not just clientId).
These shouldn't have changed.. The bicep min/max should be 5-90 ... not 0 to180. The change in behavior in setMinMax was fixed .. these changes should be reverted.
types --> type
lots of loc here :) this method was only present for toString ordering
The default toString on the List doesn't do the same thing?
you are right about that. Not sure how I got that impression. Will revert that then.
4.2
I would just delete the version check from master. The logic is very simple and unlikely to cause clashes that are hard to resolve even in the unlikely event of someone adding another field in the lifetime of 7.x.
suggestion if (in.getVersion().onOrAfter(Version.V_8_0_0)) { // TODO BWC for V_7_9_0
Do we need a utility for this? I get this logic happen in different places. We could start making a call to getQualifiedName here
Simplify with Objects.firstNonNull.
why toString() ?
Please refactor to different methods
No, RunVmCommand is executed before the VM is running, The VM's status should be down
Please use CanDoActionAssertUtils.
can this happen? why not checking before cloning the whole list?
Just put runningQueries.keySet() here in the for loop. No need for the extra queryKeys array list that you copy it into.
What is the goal of batching SQL queries together in this way? It seems to just run them all sequentially on separate connections.
Can be replaced with ImmutableList.of().reverse().
Need a space between if and ( like this "if (mSrc..."
checkState(mPut != null) ?
It seems like passing the event id to the super class constructor and also making it a field might be a little confusing. Personally, I prefer the approach used in DataSourceAddedEvent where the id of the object is obtained in getNewValue via long id = (Long) super.getNewValue() and the "extra" field is not required. Thoughts?
Not necessary
Not necessary.
You can't change the semantics of createControl(*) to dispose the toolbar.
There must be a reason why we are hiding translation spinner here (in fact, there is a separate method for updating actionbar spinner).
Should use Box.createHorizontalGlue() instead of the panel.
is /./ necessary?
do most of these need the try-finally blocks (instead of only closing afterwards)? if there's an exception in these tests, does it matter if the file is closed?
Why 2? default-max-chars.csv has a single line so it should have a single set of arguments?
The stream() is not necessary here.
please add brackets
This line can be changed just to a return statement. It will have the same effect, but the DB call will be avoided. Similarly to UpdateVmCommand.java.
handle null case (same for rest below)
also need to handle case where insertionArt == null
also need to handle case where programArt == null
I'd break this up as java StringBuilder sb = new StringBuilder() .append(formatExpression(column.getName(), parameters)) .append(" ").append(column.getType());
we can use toStringHelper
Can you add the other flag values as well?
Shouldn't we be passing an executor here? Was this missed by will's checkstyle PR?
Looks like the code in here is non blocking, so this should be thenCompose instead.
No need to wrap the value, it is already a CompletableFuture<Long>.
warn seems too relaxing for this kind of exception. maybe error?
Where is selector.close(). It is not in NonBlockingConnectionManager::close() (which is where I think it should be).
Wouldn't it be better to wrap and throw as a RuntimeException instead of suppressing with a log message?
java return IntStream.range(0, numSegments) .mapToDouble(s -> new Variance().evaluate(Doubles.toArray(getCoveragesInSegment(s)))) .average();
java final List<Double> means = IntStream.range(0, numSegments) .mapToDouble(s -> new Mean().evaluate(Doubles.toArray(getCoveragesInSegment(s))) .collect(Collectors.toList());
This code is almost a duplicate of getIncrementedSegment(), could be extracted to a method.
Is there any value in asserting that these commands come in the right order? Although the implementation is a List I guess it protects against changes to duplicate checking or something doing an insertion into the wrong place in future. Maybe something like: if (latch.getCount() == 2){ latch.countDown() } else { fail("Wrong order")} for start and similarly with a 1 count for the stop event. WDYT?
What does the *10 do in this context?
Do we need to store this as a field, can't we just return that in the getIpinterfaceId() method?
Rather than duplicating this loop (which only gets the second level in the hierarchy), wouldn't it be better to go recursive?
Hmm. Took me a little while to figure out that isExtension everywhere really means is a static extension. is_Static_Extension would be a better name. Not a big deal, though.
Are you sure you don't want to be using [HaxeReferenceImpl.]resolveHaxeClass() instead? (for lines 33~37)
s/any(List.class)/anyList/
Please use Collections.singletonList()
Please use Collections.singletonList()
should it return the record count?
Can we just break here instead of sleep and reopen file before exiting loop?
Don't do e.printStackTrace(), [as Codacy reports](<LINK_0> But once you use the platform service there won't be an IOException anyway.
Extract for readability.
Thought: I we would use java.nio.file.Path instead of java.io.File we could easily use [Path#of](<LINK_0>,java.lang.String...)) for convinience instead of coding this logic ourselves.
to loop var; objects is typed
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
The try-with-resource pattern automatically handles the ResultSet and PreparedStatement objects, but the Connection, "dbConnection" in this scope, still needs to be closed with "DatabaseUtil.closeAllConnections(dbConnection);"
Since the connection getting passed as a parameter to this method, it shouldn't close the connection inside this method. Need to close the connection in the original place where it originally (create and )close the dbConnection.
Would be good to add one final assertion that the folder created exists at a non-transactional uri after the tx closes, so just make sure that a non-tx client can get a 200 response at the obj uri
Also verify here that the created folder does not exist after the rollback. Also maybe check that the active transaction was cleared?
static import
Single static string somewhere?
Use a static String rather than the same String 4 times?
Nevermind, I see it is the Future.get() that throws the InterruptedException.
Replace with specific exception types.
something could go wrong here, it would be nice to be consistent and not return null but string array of size 0 like on the other functions (in other classes)
we should add a log statement here for more info on what's going on. And I don't know how I feel about returning null.
Why initialize this to a new OkHttpClient instance that is not being used?
Should we have a globally shared Gson instance?
Not in prod, no way!
Timestamps within the last hour are rounded to "0 hr. ago". I personally prefer showing "X min. ago" for those cases and "A moment ago" or "Just now" for timestamps within the last minute.
Maybe just have one TextView for parcelExtra like the other samples? parcelText.setText(String.valueOf(parcelExtra));
Should be DRYer to extract a method to update the texts of all 3 stats text nodes, as they should be updated together (either all or none). So I think it's not a good idea to just update the totalIssueText like in the if branch.
minor, is it method scope for Visible For Testing? If not please change it to private.
let's use LinkedHashMap
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
healthyWritablePartitions
I think it would be better to put the result of partitionsFor in a variable, rather than asking for it twice
is it worthwhile to forego the loop if filter == null? I'm not sure if we can drop the filter if it's not applicable (based on invalid field)?
Does k need to be a new hashmap here? Looks like it is initialized on line 343 already.
return true here and a default return false for all unhandled cases?
Unless there is a strong semantic difference between a list being present but empty or absent, it's not advised to wrap a Collection in an optional type. The empty collection gives you the necessary info.
just FYI, this if block could be replaced by switch statement since it's for Java 7
This should be changed to @%s usage warning: found unsupported restricted type <%s> on %s. instead, or something similar, since these APIs aren't official supported APIs and are subject to change at any time.
Please add single quotes around fieldName and urn
We should also verify that call to Elastic that sends the data is actually made and that it contains the results that were given on inputs. In the end, that's the most important action of your class, so it should be tested.
this still needed?
Does this work return new String(content, charset.name())?
1) what do you want to test between line 65 to line 69? why not write it in a loop? what is the difference between line 67 and other lines? 2) you might consider verifying the mock BookieClient on how many times it is called?
I don't see the difference between testWriteAdvHandle and testWriteAdvHandleWithFixedLedgerId. I image you need to verify the different behavior between without and with ledger id. but the test cases don't actually do this validation.
why do you need writehandle in this test case? registerMockEntryForRead already provides entries for reading, no?
i18n
i18n
again, scala type in java code.
Fix warning: suggestion KeyedMultipleInputTransformation<OUT> keyedTransform = (KeyedMultipleInputTransformation<OUT>) transformation;
Did you mean if (memoryStore < numInitialEvals)?
Can't tell how this works from this RB alone. Is this going to become the logical id for the stream when you create a spec for it in the Planner? And then the physical name by default appends the JOB_NAME and JOB_ID?
space after if.
Please change to "clear tokens from local token cache for the user".
As we talked on Friday, I think we should probably go through all the checkstyle, findbug rules. Those kind of changes for flipping the check, i don't think there are too much needs to do it. Not seeing any benefits we get from here.
IMHO we should do _something_ here. As there is no obvious default action, how about printing some help then?
For all the cases where 'thin' is not supported, I wonder if this method should catch that? So for example, under case "ear": should it check for if (installThinProject) and break without setting supported = true;?
Should be moved with other not treated cases
Debugging? Remove.
writeByteArray(page.getData()) ?
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
I see what you're trying to do. So we can assume things such as the following will be processed correctly, right?  1 2337032 rs1129171 C T,<NON_REF> 480.77 . BaseQRankSum=0.218;ClippingRankSum=0.103;DB;DP=45;MLEAC=1,0;MLEAF=0.500,0.00;MQ=60.00;MQ0=0;MQRankSum=-1.344;ReadPosRankSum=1.046 GT:AD:DP:GQ:PL:SB 0/1:19,26,0:45:99:509,0,330,565,407,97 2:9,10,13,13
Check also equals reference and alternate, both empty and non-empty.
coordinates 1000, 1001
stream & collect
use Guava lists for consistency + throughout code
should be static
what this line is for? I didn't get it
@cvrebert can we move this up?
Maybe you didn't commit it?
nit: a better approach would be create the subdir under the tmpDir initialized in this test suite.  File firstDir = new File(tmpDir, "dir1"); File secondDir = new File(tmpDir, "dir2");
You don't need to change this method signature. I would leave this method private
do we need to sleep(1000) here? can we make this test sequence more deterministic rather than depending on time, to reduce flakiness?
We need to check null before reference dvd[i] here.
I'd suggest to consider conventional hashCode implementation that is consistent with equals method - taking both entity and title into account, both of which can be null: final int prime = 31; int result = super.hashCode(); result = prime * result + ((getEntity() == null) ? 0 : getEntity().hashCode()); result = prime * result + ((getTitle() == null) ? 0 : getTitle().hashCode()); return result; (If two objects are equal according to the equals method, then calling the hashCode method on each of the two objects must produce the same integer result.)
You can use: return Objects.hashCode(scope, doneAt);
This looks like the new implementation, you should leverage current one by calling existing method with some transformation.
Why do we need this ? Should be done by DublinCoreService
There should be a fail() somewhere if you expect the catch to be triggered, otherwise you're not testing anything.
I think the following would also fix the leak and will not call the removeAction twice in any code path java @Override public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) { synchronized (removeListenerActions) { if (destroyed) { callRemoveAction(removeAction); } else { removeListenerActions.put(registrationId, removeAction); } } }
I would have expected a Collections.unmodifiableCollection here.
This effectively limits action button priority to integers, is this what we really want?
This is fine, but even better would be to also catch any ToolError (e.g. a typechecking error) and print the error message on standard error.
I don't think we need to retrieve a liveChatId here (lines 69-78). (The liveChatId is not used elsewhere in this method.)
Let's omit System.err here, as printStackTrace() without parameters is doing the same. (Also in the other file)
This method makes a huge assumption that the user invoked the command as "-option value arg" when really they can also say "-option=value arg". And it doesn't take into account the -- that stops option parsing.
Configuration error: invalid structure for parameter '%s'
not sure why we need this conditional. if I put no_argument as default False, value True and converter Boolean I can achieve the same in properties file without anything in special in implementation, no?
The layout could be passed in the constructor.
Lets use BorderLayout instead, it does not require extra configurations (GridBagConstraints).
git-compare-window-changed-files
rename to path
Does it really need to be 'public static'? Is this method used from somewhere outside?
the "exAdapter.getWorkflowConfigFilename(item);" may be return null value, so before invoking "folder.getFile(fileName)" should check first.
Can we add log that the configuration setting from query is ignored?
We should avoid the creation of objects if a logging level is disabled. String concatenation creates a new String object. This particular line should change to  LOGGER.info("Kill interpreter process for interpreter group: {}", getInterpreterGroupId());
Why you change the path from notebook to recovery?
code formatter missing? At least there should be a space before the curly bracket and you have a lot of tabs in here...
Is it by intention that you set the status outside of the "synchronized" block? Before you set the status within it...
I think it would be better to store the output of getRuleStatus(rUID) in a local variable instead of doing this call twice.
What about the following:  // onFail callback does not update task info to failed state. // With recoverable grouped execution, a single failed task doesn't fail the whole query. Not updating the task info make query not finish in tests because failed task is stuck in RUNNING state. // TODO: This issue only happens in test TestHiveRecoverableGroupedExecution when a worker is closed. Investigate why this is not an issue for production query recovery.  This explains what is missing from onFail, and why it's now a problem (since we don't fail query now). "RequestErrorTracker#requestFailed throws when backoff threshold is reached." explains why the exception will be thrown, in my opinion is a low level detail. The key here is the task somehow failed, but the task info is not updated. It's not a problem before since the query will fail. But now it can make the task stuck :/
Let's make commit on each 100 nodes e.g. (it costs effectively nothing) but may prevent write buffer overflow when running with extremely low mem (write buf size is e.g. 1M). It could be also more effective to make commit on FastSyncDBWriter thread since it can cause DB flush synchronously
please provide e as argument for stacktrace
I think it is better to return an empty collection instead of null.
Shall we throw GeoLocationBasedServiceException  wrapping RegistryException ?
Shall we throw GeoLocationBasedServiceException  wrapping RegistryException ?
Use new lines.
Check if this test of relation is also in BlImpl part. If not, move it there.
Bad indentation for this method.
Why are you keeping the conversion-less method?
I assumed you were going to pass entryFactory here
iteratorIncludingExpired(), to match sizeIncludingExpired()?
in calculateQualifiedVersion(), there are other ways to set the qualifier which are not being validated. rather pull this out into a dedicated validateQualifer method and call it after qualifier was determined.
This is only valid because the empty version is defined as "0.0.0". But AFAIK it could have been "0" as well. So I'd rather use a "0.0.0" (or "1.0.0") constant here.
ah, was going to suggest a test to guard our assumption :) Nicely done !
can you explain this?
Consider using the built-in parsing in the URL/URI classes
why is this needed?
Do you have an opinion either way about (in the future, not now, let's just get this done already) rewriting this and any similar lines to Optional.ofNullable(property).map(prop -> new TypedValue(prop.getQualifiedType(), prop.get(obj)))?
So this simply works by shifting the getHandle() call from outside the ondemand scope, where the handle is closed because that's what ondemand does when its methods return, to inside the proxy invocation where the handle is still live, right?
OOC, in what ways does findSpecial differ from unreflectSpecial? are the two functionally equivalent (ignoring the JDK bugs), except one stards with reflect data (Method) and the other with a signature (MethodType)? if so, is it worthwhile simplifying this to _just_ use findSpecial? also: does this change have any impact on the calculus of who has access? if the types (args or return) are private, package-private or protected, will unreflectSpecial|findSpecial fail whereas the reflected approach would have succeeded, because we explicitly set the modes to all access levels?
this.
@sundaramrajendran Yes, I see the bug now. Thanks! This said, I think ConfigParser needs a few more changes. 1. We should not call readConfigFileContents in any constructor. 2. We should wait to call readConfigFileContents on the first invocation of parse 3. setConfigFile should return the ConfigParser instance to make it more like a builder. E.g. - ConfigParser.setConfigFile(file).parse().getInt(key) 4. Subsequent calls to setConfigFile should not change the static value of configFile once parse has also been called.
maybe we should use a properties file like the rest of our tools
np: s/LocalApplicationRunner/RemoteApplicationRunner
Wrap in a new exception and throw.
debug?
Gson doesn't run on these versions so I don't see any reason to include them.
You can change the 28 case to a default case, and remove this.
Inconsistent Upper and Lower case in description
I guess EhcacheActiveEntity should never be getting any PassiveReplicationMessage since execution strategy prohibits that, right ?
Could you check for null or empty? Via StringUtils.isBlank
Add deviceId and type as parameters to the msg. That would give enough context for logs.
Very unreadable, please extract to a boolean with a meaningful name
Please extract to a method and call it after you verified this is an image disk
I will be safer to check if getImage().getVolumeFormat() != VolumeFormat.COW
Can we use already-defined constants for the following three strings?
PatientDiscoveryDeferredRequestAuditLogger is used in several methods. Can it final object when the class get loaded?
Is this "when" (and the equivalent failure one below) ever reached in these tests?
Same here, with respect to bad exception handling.
Just a style thing, but would it read more easily if the "exit case" were more explicit? I.e.  if (updatedInstance != null) { return updatedInstance; } instanceApi.delete(instance.getId()); InstancePredicates.awaitDeleted(instanceApi).apply(instance); ...
This is a bad pattern to follow, for a few reasons: 1. We have multi-catch blocks now, so there's no reason to do blanket catch like this, 2. This will unnecessarily wrap RuntimeExceptions with another RuntimeException, and 3. You should never call new RuntimeException(...); instead, pick a specific runtime exception appropriate to the circumstance.
Result of replaceAll is ignored. Please, assign it to a variable. suggestion maxUploadSizeString = maxUploadSizeString.replaceAll("\\s+", "");
I'd use << 3 to match MemoryAddressHash
Why maxSize + 1?
relevant non-logging code change here ^^^
We try to remove the Globals class. Is it possible to insert the stateManager via a constructor parameter?
I'm iffy on having this here. This is partially because we let the status update handler write to pending tasks, and partially because it means we are reusing a pending task id. Generally we let the SingularityScheduler do all of the work of creating a pending task to keep responsibility for those types of operations separate. We actually removed bits from the status update handler a little while back so that it would avoid mutating the pending task queue. Instead I'd suggest using requestManager to add to the pending request queue. This will let the scheduler do it's normal thing and rebuild a full new pending task with new unique ID from that pending request
Currently we don't have PERUNOBSERVER role assignable by config to specific credentials (unlike perun admin). This mean, we will always have User, related to this role. So anywhere, check on SELF (without specifying user or where passed user is only own) will let PERUNOBSERVER pass too. Only if it would filter result, we would have to separate them. What do you think @stavamichal @licehammer @martin-kuba ? Will we need PERUNOBSERVER role for accounts without User in Perun or not ? I suppose not, it is always safer to have account with contact info etc.
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
"perunadmin" should be "PERUNADMIN" now, same for all other methods.
Should it be a NoSuchElementException instead of returning null?
How about an int-returning method getTotalItems() that looks like:  if (nextRowIsNew()) { return totalItems + 1; } else { return totalItems; }
Whitespace change, especially since this is in the second commit with nothing near it.
PercentType is a DecimalType and for DecimalType calling toString() is the right thing.
I would prefer not having to deal with string parsing. What do you think about the approach we use for Neo4j? We use a Neo4jParameter class and check if this is an instance for it. This actually connect to what I suggested before and we could keep the code consistent between the two dialects.
I don't think we use final for functions in our code base
agreed that this block should be removed
shouldn't we add into names?
ArrayList should be constructed with fixed capacity.
Why are you using supplyAsync here? createFromInitializingJob should be non-blocking.
factor out into createInitializingJobDetails
Why is this catch block necessary?
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
This could be null, we should probably handle this if the JIRA api changes again
It is not so important but still defaultAttributeAnd -> defaultAttributesAnd
Since this block is repeated in above, shall we move it to a separate private method?
Maybe remove the package name as it is already in the import statements.
suggestion LOGGER.warn("Cannot find any implemenntation of 'WorkbenchUserManager'. Loading default implementation from SSH module");
Instances can be null or empty in case of no instances in ready. Null check and empty check is required here right ?
What about creating own separate methods in client for starting solver and terminating it? It would be more intuitive and user friendly from my point of view. Also it would show what parameters are mandatory for each action.
I wouldn't do these 2 lines: we can't really guarantee that the first initialized score will be above -1k hard and -1m soft. That's why I didn't retain them from the original test.
Minor confusion: If the spans are the same, sort should not have any effect right? Might be missing something here.
I think for contacts it would be better to use Number: instead of Id:. Otherwise it looks good!
should be a while loop here
Check whether array length is even to avoid index out of bound exception in case of data corruption? But I am not sure whether this is really necessary.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
Same here. Let's try to handle the exceptions inside this class.
.take(limit) is the default in RxJava, limit is an alias (but in ReactiveX world, the normal term is take, so lets use that)
I probably agree with this. The Map being returned by a list() method is amusing, but in a REST world it makes sense. One observation is that Location has an id field, and a name field (note the inconsistency with enitty.getDisplayName). It would be possible for location to use the same pattern as entity, and not use the integer keys? But I have no strong feelings here.
What's the point of adding a copy here?
as author is not null and author.getUserId() not null due to previous block check it can be simplified to if (!author.getUserId().equals(userId)) {
User can't be null as long as @RollesAllowed("user") is present on top of this method
url should just point to regular detailed sample url (/rest/tree/sample/{id})
could you remove the tab and use spaces for indents?
Don't use final here.
Won't this cause a trailing comma on each line? To avoid that we could save all metrics in writeQueryResult and do the actual write in postCollect
Shouldn't this be "Custom/"? Because if you look to string s (below) you will have a double slash on the one side and no slash on the other side
You never close the BufferedReader, this will create a ResourceLeak, wrap it in a try with resource statement  try (BufferedReader br = new BufferedReader){ .... }
Can we move the path to ApplicationUtils class?
This uses the platforms default charset, I think we should probably use the more explicit getBytes("UTF-8").
Does the output stream need to be closed?
Does this work return new String(content, charset.name())?
final
this for is exactly the same in all the array tests, let's move it to a private method
Please add ? and % as well
ditto :)
format this as:  a -> a .globalGrouping() ...
this is identity projection, can you use something more complicated like a +1?
Does this work if Column A or Column C has trailing whitespace? It might be better to split on comma and then do a colName.trim() or something along those lines.
Looks wrong. My guess is you want to invert this: if any parent has a member type return 0; if none do return i.
Agh code duplication! But I don't see a simple way around it. I was thinking about some fancy Java 8 streaming thing, but it's not trivial.
possible NPE
Please add null check for volume.getAsyncTask()
Shouldnt we return VDSReturnValue itself here? If some exception, succedded flag is set to false, else getReturnValue would have the status entity populated.
I think it should be: tType = ((ParameterizedType) tType).getActualTypeArguments()[cDept] BTW: In a separate branch I'm working on strategic solution to compare generic types. Will refactor this code to use the common feature.
This is not necessary if the cast is to Class<?>.
We need to have a backup plan here if type isn't a TypeVariable.
suggest rewrite this method
no need for logging here
does the buffer need to be flipped?
buffer size 1, why?
how about:  if (Types.getRawType(type).equals(Optional.class)) { if (response.status() == 204) { return Optional.absent(); } else { return Optional.of(delegate.decode(response, getInnerType(type))); } } else { return delegate.decode(response, type); }
This doesn't seem right. The JsonCodec in this handler supports either JSON or Smile, but not both, so we shouldn't accept both. Also, the error handling logic and getJson() API (used by error handling) assumes JSON. It wouldn't work for Smile which is binary.
suggestion return Optional.of(new String(inputStream.readAllBytes(), StandardCharsets.UTF_8));  I think that's enough examples for now, I hope I got my point across
Not sure if you wanted to leave this hardcoded?
remove this... openFileInput(fileName) should be sufficient and using an Application context is often an anti-pattern
The AllCleanRule should do the work of lines 158..159, so you can skip this code.
replace manual copy with collection copy Collections.addAll(mTagsList, tags);.
Prefer using import static org.junit.Assert.*; which allows you to use assert* without prefix.
Can you add the other flag values as well?
campain in tostring?
And similar to earlier, don't include the newline in the toString. If needed for the output, add in the other class (but it may not be needed there).
Minor thing: "referer != null"
Missing space before {
Another FYI, not a required change: note that there are some "gotchas" when using String.split with a regex. [Here's a nice breakdown](<LINK_0> If this was high-performance code, you'd probably want to compile the Pattern ahead of time, and split using that instead. I only learned about this a couple months back.
can this use increment util?
will this create notifications?
could call toInteger() and drop Integer.parseInt
Please rename variable to something more meaningful other than the character v
minor: this v == null check is unnecessary.
if 'v' is not a member of enum why return it in upper case?
Do we want to turn this on by default in elide-standalone, or did you mean to wrap this in an if block?
Just use something like ZoneId.of("+08:00")? convertToZoneId should be removed eventually.
We generally prefer assertThat(..., is(..)) for better error messages.
spacing
suggestion cacheManager::getCacheManagerInfo);
Can you add a call to "DataCacheFactory.getCache().getCacheManager().clearAll()" as well? In the default configuration it will clear the same cache as the "report-dataset-cache", but if an OEM replaces the DataCache-implementation, we will cover their implementation too.
Sorry, I forgot about one thing! This will no longer be enough, there's VERSION_1_8_0 now. I think a better condition would be: ctx.version.lessThan(ServerVersion.VERSION_1_7_0) || ctx.version.inRange(ServerVersion.VERSION_2_0_0, ServerVersion.VERSION_2_2_0), but feel free to write the condition on your own.
Why is this wrapped to IOException? You can wrap it to another OperationException. @honza-kasik , @rhatlapa WDYT?
The version is available directly on the OnlineCommandContext: ctx.serverVersion
please review code formatting
please verify that the value "Name" was set instead of _any()_
I'd make this simply true but not a big deal.
Needs to shut down the scheduler.
If storeThread == null concurrent tryCommit() or deregisterVersionUsage() may change its value between get() and set(), they are not synchronized like this commit() method. It looks like compareAndSet() should be used here too instead of set() or something else should be changed.
Maybe we don't need to print the stack trace if we can ignore it
this can be merged with the above
these arrays could be static finals. That would save allocating new ones all the time.
add {},
return flagdown; ?
you don't want to check that images are legal and exist?
This section looks great! thanks again for the refactor here.
countVal is not necessary. you can use state.setSumC(State.getSumC() + count) directly.
When will this happen?
I'd inline result variable: DOUBLE.writeDouble(out, strategy == null ? Double.NaN : strategy.calculateEntropy());
Recommend changing this method to use the reference name exclusively. Eg.,  if ( SAMRecord.NO_ALIGNMENT_REFERENCE_NAME.equals(rec.getReferenceName()) ) { return record(null, 0); } else { return record(rec.getReferenceName(), rec.getAlignmentStart()); }
I think this method should either: 1. start with if (rec.getReadUnmappedFlag() || !rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) return false 2. or make it explicit in the javaodoc that it's only legitimate to call this method on a read that is paired with both it and the mate mapped
unnecessary parens here and on lines following suggestion rec.getReferenceName(),
since you are catching.. why not test this :)
This can be improved. The this.readOnly check shows that this method is mixing two concerns: map lookup and caching. I would prefer if caching was done in a separate wrapper class(ReadOnlyHttpHeaders), that is returned when HttpHeaders.readOnlyHttpHeaders is called (instead of backing the map with an unmodifiable MultiValueMap).
Should one of the following happen in case contentType passed is null? - throw an exception, or - set this.contentType = null
nit: just simplify to throws Exception
We should probably remove these printlns or use slf4j.
The error message is not accurate because it indicates that the wait was for timeoutMs, but it was interrupted so it is quite likely that the wait was less. As we don't expect an interrupt anyway rethrowing it seems the easiest way to handle this?
Variable is never used
Cannot happen. @RequestBody is required by default. Remove check.
Also happens for "GET" endpoints, "WRITABLE" is not correct in those cases
Replacing the 2 loops by  java result.putAll(getSuite().getParameters()); result.putAll(m_parameters);  seems a better approach for me.
Have String headerKey = key.toLowerCase(Locale.US) only once to avoid repeated case conversion.
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
what about using org.apache.commons.lang3.BooleanUtils.toBoolean(String) here?
isn't used...so perhaps do not set?
AFAIR instances of ClassAnalyzer are not reused, so this clear() seems useless.
Why this get deleted? Your code depends on this function?
Why we delete the first question?
Is this necessary?
ping
not needed
Please replace empty string with a proper error message
typo!
Add a null check here.
can you create a private method with these common lines to avoid duplication?
new ObjectMapper() Please DI our custom object mapper instead of creating new one:  @Inject private ObjectMapper objectMapper;
Use {} for variable interpolation
new ObjectMapper() As above. Inject it please.
This message is actually considered as continuation of previous log message, so it makes sens to keep them at same level.
task.getId() shouldn't be called by each for loop, and it would be better to change this method to a lambda style. java final String taskId = task.getId(); return taskRunner.getPendingTasks() .stream() .anyMatch(t -> taskId.equals(t.getTaskId()));
unlike other places why await() needs to have a timeout here? It seems, test will fail anyway if that timeout is reached, specifying it here is not doing anything.
overflow = ((xl ^ yl) & (xl ^ zl)) < 0;
Call it 'unused', as this suppresses an annoying static check that runs on Google's Java code.
FWIW, this version requires 4 branches to reach the common case (Long.compare), whereas the version I proposed used a control tree of depth two. Probably not a big deal, especially given the mystery and unpredictability of measurements using the JVM, but something to bear in mind when optimizing (especially in a language like C++ or Go or assembly).
Why put at i-1? Wouldn't it be more natural to use i?
use arrays.copy? or system.copy?
@inverno We have 2 times "Second argument" :)
this looks funky! shall we re-visit?
Will the queue URL always use a "RabbitMQ-" prefix? Might there be a need to change this?
You can use a constant for "DeadLetterChannel". Check whether andes has a constant for this which we can access here.
This could be simplified to  hResult = shellFolder.ParseDisplayName(null, null, directory, pchEaten, ppidl,
I can see how this would affect the 32-bit version. In addition, I think all of the _PTR variants should add a .toPointer() method, which further makes clear that their value can be either integer or pointer. rkey.getValue().toPointer() would make this particular expression more clear, and avoid new Pointer(), which implies something different.
can you import Utils?
silent errors are evil, even the "its almost impossible" ones ;) just surround the entire methods body with try - catch you have a good catch that handles it in the end
I know that we don't have a linter for java projects yet, but what do you think if we'll try to follow some basic formatting rules, common for most languages? Like spaces before and after = and + for example.
Multiple method(*) methods
please add line above to separate 'block'
use 'waitForElementByElement(newestVideoDeleteIcon); and use 'waitForElementByElement(deleteConfirmButton); before each click
Better use a waitFor
you control all the source here, I think it's fair to assume non null + you have Preconditions.checkNotNull
I presume this means we are out of pages..
This is still a bug. super.getResultSet() call is not idempotent. You should replace this with resultSet local variable
1 Euro for every System.out.println pls
log creation on each run() ? that is redundant
Redundant with the e.getMessage? May be something like "Wrong class path: e.getMessage"?
Looks correct. I think you can just do result[1] |= shard() << 6; since bytes in an array by default are zero.
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
use final
Looks like wait forTaskRelease is buggy. it seems to swallow interruptedException and return which means that waitForTaskRelease will return when the thread is interrupted making the caller believe that the task is released whereas it was not. Can you please take care of that issue?
Please use the same order of the fields declarations, otherwise it's too difficult to say if we forgot to assign a field.
Use same order as the field declarations.
Should this be a new Exception class?
Should this be a new Exception class?
Should be final WebTarget resource
file might be a directory - message will then be misleading
child
child
is this line useless?
These two checks are redundant, only the "poison pill" can be by itself in a chunk, and only it can have a start time of -1 (right?). You can keep only one of them.
When we get here, we've hit the "poison pill", so there should be no other real intervals left. I'm assuming you used a for loop because you can't do Iterable.get(0) ? You could use (Guava's) Iterables.getOnlyElement() though.
Why does this give a bad request but the above tests returns an empty data? I suspect the RSQL filter is formatted incorrectly.
json.toString().isEmpty can be very expensive. Just null check is ok
Add markInitialized() after assertion, in case of "-ea" is disabled ducktape hungs while waiting service.
if we fail here we have a stale VM version in hand. we should roleback
Since this is recoverable, can it just be info?
we should be able to test equality of the new Types directly rather than leveraging their names.
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
final
unnecessary array new: {{true}, {false}} should work here
Should this return Flux.error instead of throwing?
@weijjia I am ok with this, but I think it would still be good to make it a class local constant.
calling is.close() might produce exception. Please define: private static void safeClose(final Closeable c) { if (c != null) try { c.close(); } catch (Throwable ignored) {}; } and use it instead of InputStream.close() method
This needs to be new Request(Request.Type.OPEN) now.
honestly I think it would be a lot cleaner if you just release stuff in the tests itself.
side question, but do we really need to check for enabled anymore? should we just deprecate that feature?
Any strong reason why switch from DEBUG to TRACE ?
Changing the semantics in a minor release worries me a bit. Why is a null matcher a match now instead of not a match?
Instead of duplicating the lines, would it be simpler to have matches(request) and matcher(request) call the same underlying private method?
Excuse me, I want confirm with you about "A suggestion for a follow on change would be to add any permissions only projects as candidates even if they are not yet parents since that is likely their sole purpose: to become parents." here can I understand "to add any permissions only projects as candidates " as to delete Line 54?
Since any ancestors should not be added several times, perhaps a Set will do? In that case the seen-logic can be re-factored away?
Instead of performing the candidate search in the get() function above, you could do it in this function and avoid the double control lookup for each candidate. And since this method returns all the info needed to return projects and project.Namekeys, the get() function could then call this one instead of this one calling get().
Assertj has a fluent API. You have to do assertThat(events.size()).isEqulTo(1);
Please use AssertJ
Please use AssertJ
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
COuld we reuse <LINK_0> ?
Don't really need this check which lets you inline the getInterfaces() call into the for
NITPICK: There is a class for this that already exist, can you reuse that.
If the fragment is good, rename to RecentNotificationsFragment and remove the old one.
FIXME: All front facing strings go in strings.xml.
I think we shouldn't just catch and silently ignore? Would be nice if we could somehow alert that there is a malformed URL.
This needs to check for null (no item selected):  211221 [AWT-EventQueue-1] ERROR org.zaproxy.zap.ZAP$UncaughtExceptionLogger - Exception in thread "AWT-EventQueue-1" java.lang.NullPointerException at org.zaproxy.zap.extension.quickstart.AttackPanel.attackUrl(AttackPanel.java:324) at org.zaproxy.zap.extension.quickstart.AttackPanel$3.actionPerformed(AttackPanel.java:295)
Woah, just caught this, we should probably just throw a notification for this, not a runtime exception (or throw a typed exception here and catch/raise an notification later). Otherwise I can prevent your phone from ever being able to start up CommCare by sending you an invalid URL over SMS, which will make it crash on startup.
Typically we use Map on the left hand side rather than HashMap
This constructor needs to be deprecated and a new constructor PullFilter(String filterName, Map<String, String> parameters) needs to be added to allow users to create their own PullFilters with complex arguments in the POST body
How about something like this here: return fAttributes != null ? Collections.unmodifiableMap(fAttributes) : Collections.emptyMap(); and not modifying the other 2 constructors?
This test would also pass if uaMap was completely empty. Can we instead assert the presence and format specific keys in the map, such as bindings_version? I'd rather test for the expected behavior versus "make sure no keys contain a dot" which feels like a tautology.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
let's use LinkedHashMap
Ye, but it causes a PMD warning.. :P I will fix it, that will be easier. ;) <review, layout
I think we can streamline this to one line -- it seems like it would be easier to read.
suggestion if (buttons != null) {
I think it was better with the old static imports.
constant or lineseparator from system?
This deserves a unit test.
I'm not sure that it will be correct to return only 400 for Nakadi Exception and 503 for everything else. I think that in reality there are more options.
again about redundant things - else block here and above is not needed,
Should this be a new Exception class?
unused
What's the purpose of the string replace. This is very specific and only works if folks name their exo variant 'exo'. Can we not hardcore the names here?
> Expecting: <[D:\some\path\foo.jar, D:\some\path]> to contain exactly (and in same order): <[D:\some\path\foo.jar, D:\some\path]> but some elements were not found: <[D:\some\path\foo.jar, D:\some\path]> and others were not expected: <[D:\some\path\foo.jar, D:\some\path]> When I run this locally actual is like C:\some\... while expected is like \some\.... I believe the output is slightly misleading in what the failure is. The utility is telling if the objects match by using Objects.areEqual(..., ...) which is just basically o1.equals(o2) The test passes for me when I change the code to:  .containsExactly(new File("/some/path/foo.jar").getAbsoluteFile(), new File("/some/path/").getAbsoluteFile());  I didn't test how linux would respond.
You can also use IO.close(bb) as IO.close will not throw any exception.
Is reader AutoCloseable?
should this be in a finally block to release in the case where an exception occurs?
Yikes. I didn't see this before. Is it in master?! We shouldn't unwrap ExecutionException like this. It makes it look like the exception happened in this thread, rather than in the other thread. For example, if the other thread was interrupted then ExecutionException.getCause() will return an InterruptedException. Rethrowing the cause make it look like _this_ thread is being interrupted (and looks like the interrupt is being handled incorrectly, because it is just caught and wrapped without marking this thread as Thread.interrupt().
1. Shouldn't it be new RuntimeException(e.getCause()) ? 2. Does this handle if e is IgnoreTransactionRollbackException and e.getCause() is null?
this doesn't look correct. You're doing this ONLY when the exception is a ModuleException. You're ignoring all subclasses (which is what's more frequently used).
formatting
Not .warning?
you should probably check Item.Configure here
This check should be in the Service alongside alias validation
I think I goofed and this needs an toUpperCase.
Should this be set for the whole migration?
Absolute or just path?
OCFile now has a method getRemoteParentPath that may replace this block. Let's take advantage of it :)
Overall looks good. Can we throw exception here instead of returning null?
nit: I somehow liked the old, more concise UNKNOWN_STATS
Is it possible that this could ever return anything other than UNKNOWN_STATS or usecom.facebook.presto.cost.FilterStatsCalculator#UNKNOWN_FILTER_COEFFICIENT here? I don't expect FilterStatsCalculator can estimate anything useful for spatial join. Are you OK with this? This basically means that CBO will generate more-or-less random plan for queries with spatial join.
why does this need an override?
Check args?
Same as above, please use ops().run(...).
Please review the rest of ExprEval for such things
Preconditions.checkNotNull(is, "Input stream required to create temp file for %s*%s", prefix, suffix);
lets make sure we don't get npr in these exceptions
Nice. The intent is more clear than using a file in the previous version.
Let's remove the finals. They're not adding anything.
no need for the temp variable - just return mapper.convertValue(...)'s result
Perhaps this logic should be in DefaultMessageBuilderFactory instead?
Could this be merged with what we have from line 85?
Not a loop anymore. doWatchdog is enough
this makes a bit change as we were previously ignoring issue here which makes sense while stopping
Can this be private, or is there another use case for default attribute outside the builder's call?
Just passing getOffset() directly (not introducing local variable offset) as argument of getAssets() could help improve readability, what do you think?
Try using StringUtils.isTruthy(this.path)? <LINK_0>
It has been wrong before your commit, but as you touched this line could you use {} instead of string concatenation?
This call will lead to an NPE if no thing type is found for the thing.
demo1 seems to be a left over
Since this will appear on client side, my only concern is the date format that may not match what is expected by the user. Also, for the UI this is just a string to be rendered, no further logic since no further information is provided (e.g. type or format).
Should we do this action in a separate transaction? I'm thinking about listener rollbacking the action to avoid creation of record in system.
You can compare directly, no need go through a String: if (!Boolean.TRUE.equals(doc.getContextData(DISABLE_TRASH_RENAMING)))
do not forge to test the isActivated() flag: it is as important than testing the node count... withTopologyService(1, XX topologyService -> assertFalse(topologyService.isActivated()));
you should also verify that the 2 first nodes are activated, but not the last one:  withTopologyService(1, 1, topologyService -> assertTrue(topologyService.isActivated())); withTopologyService(1, 2, topologyService -> assertTrue(topologyService.isActivated())); withTopologyService(1, 3, topologyService -> assertFalse(topologyService.isActivated()));
So now, with #615, if the prepare phase is failing, the node won't be restarted because the Nomad transaction is not applied. So status quo ;-)
IsAccessible is equivalent of isExist so the refresh should be done before ?
I think we should set the error in the RM instead
We should aslo set the fCurrentThreadCtx
HQL/JP-QL
Does this work for named JP-QL queries, too? As per its docs, createNamedQuery() can create both, native and JP-QL queries.
Now that we are adding offset and limit directly, I feel like this functionality (appending the offset & limit string) should move to the SQLQueryConstructor
Why it's here? Please try to understand what onInstall and onUpdate are doing. If keep as you wrote: it will be a duplication.
check the message code
I believe stapler will do the conversion
prevState will be equal to current state if the state object is same.
Do we have to serialize the state in Operator? I think the caller class would be a better place to serialize it.
Why do we have to store the state at all event processing?
long hashCode; try { hashCode = (long) keyBlockHashCode.invokeExact(keyBlock, position); } catch (RuntimeException e) { throw e; } catch (Throwable throwable) { throw new RuntimeException(throwable); }
b is only used once, use for(i = place(key) ) => GC will thank you ;)
nit: error message is slightly misleading, we can say "rawHashTables is empty".
It would make sense to use the constant you declared above.
this can be made private
Object returned by this method is not used e.g. method can return void
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
oh yea. A spy :)
Too many unnecessary blank spaces in this class. Please refactor.
why public? also the ordering of methods is a bit off, run() should come first so it's easier to read
how about logging a warning if the set size is > 1 (which means something is out of sync for this sub)?
this will be called for each assignment twice on startup: * while warming up the cache * when events from ZK start to come in I think we should protect against this kind of obvious duplicates.
why not public?
Missing finals for all tests in this file
This allows null values, though that may be fine.
tab starts this line, we use spaces to indent code
I think these all become unsafe anyway, but it's good hygiene.
Is it ok to go from WAITING straight to RELEASED?
I think this could leverage stream api : deduce().stream().map().filter().firstMatch().orElse...
Does this actually test if the relation has been deleted from the catalog entirely, or just that no partitions exist?
This may be improved to: String customizedRelation= "="; // free text of default search object if (prevType == SyntaxObjectType.CONDITION_RELATION) { customizedRelation = previous.getBody(); } What do you think?
String indices = index != null && !index.isEmpty() ? index : "_all"; SearchRequestBuilder searchRequestBuilder = client.prepareSearch(indices) .setTypes(type) .setSearchType(SearchType.QUERY_AND_FETCH) .setScroll(new TimeValue(scrollTime)) .setQuery(buildSearchQuery()) .setPreference(shardBuilder.toString()) .setSize(scrollSize);
I'd like to consider this as a completeExceptionally case. It doesn't need to return anything.
Copy paste code block? Split it out into a function please.
I think you could remove unnecessary brackets around path
Maybe return mc.map(column -> { ChunkDescriptor chunk = new ChunkDescriptor(columnDescriptor, column, column.getStartingPos(), (int) column.getTotalSize()); return readChunk(f, chunk) }); ?
Why not return here? save declaring a variable and the return at the end of the method? Yeah! I'm lazy and prefer to write less code when possible!
shouldn't this be throwing the exception ?
use some specific exception class to validate. The exception string should also be checked.
make this protected since its an abstract class
throw that please
Since ResultSet is AutoCloseable, isn't it better to change this to try-with-resources?
Let's wrap container creation in test-with-resources block, this way we can also omit the finally block.  try (PostgreSQLContainer postgres = new PostgreSQLContainer();) { postgres.start() // do the test, no call to stop needed }
To make this more portable, could you create and approve a savings account first via the API and then undo the approval on the just created account?
Why do you have to check for null here?
typo
How about in-lining o1 and o2 since they are not reused?
Missing @ Override
suggestion List<E> sortedParts = new ArrayList<>(globalContext.getParts(type));
I think this method has no need to be static
No need to call the decoder if part is already of type 'type'
I'd go for: return ImmutableList.of("node", "show", "-l", nodeName, "--format", "json")
Can you not use a for-each loop here?  for (JsonElement jsonEle: doc.getAsJsonArray()){ // stuff }
To be on the safe side, I think we should add a type check here, as we don't want one stat to prevent all others from being sent in case of a casting error.
Are these two if necessary?
We shouldn't need separate methods for create/update like this. Do what we can in one, pull the unique bits back into the callers for the rest.
Since the default is false, this will basically no-op in the majority of cases. What we should do is, instead, set the locked flag to true during refresh (which also covers manifest import), as that's where non-custom pools are coming in anyway.
This is a very interesting way of handling this. I'm not quite sure how to feel about it yet, so let's leave it as is and see if it establishes a pattern for general output processing of the Java rules output. If so, keep them all; otherwise I would argue this is probably an expensive way of doing a null check.
Could you please log the transaction ID here, instead of the entire transaction?
missing "l" in "resut"
It's ok, but there is an extra set of parentheses here. I think we can delete those that are around the very last inner condition; the ones that start right before the second occurrence of accountState.equals(...).
this makes a bit change as we were previously ignoring issue here which makes sense while stopping
Ping.
This can also be replaced by a single _":m Prelude Data.List Data.Maybe Data.Either"_. Or even better, no literals, but just concatenating a(n observable) list of required modules.
IMO if we know executeTask() doesn't trigger maxIdle expiration, we should assert that
Do we really need to test with more than 1 entry?
I don't think this is necessary, if you're checking the DataContainer directly.
i++ is generally the convention unless you explicitly need to preincrement.
We're on Java 8, so: IntStream.range(start, start+length).toArray()
FWIW, I benchmarked Math.pow(k - m, 2) vs (k-m) * (k-m) and there is no difference in performance.
Same here with not needing the local variable.
Same thing here with the inputStream, probably want to when() the actual object instead of any(InputStream.class)
Do you want to make this when(urlService.inputStreamToByteArray(inputStream)).thenReturn(null); since you on the line above you made that method return inputStream?
this is a public method so better perform some null checks, or at least use assert statements
use original mapper
delete this line
I wonder if we could end up with some issue, having bean as a field here and the setter for the same in the super class... I'd say that we really should use for the MultiMethodRabbitListenerEndpoint the same setters model. Even for the methods.
1) Should the distinct happen here? I doubt it: I'd expect the first caller of getFromStreamList() to have to do the distinct too, so there it's a perf loss to do it in between too. 2) Is the distinct worth anything? Do the From's implement equals/hashcode? When in doubt, leave it out and put in a "TODO Should we distinct?".
Is it ok to display the requestMessage in the log?
We cannot just delete package name from each class. It's required to test that a check supports fully-qualified names. In this exact case probably it's better to move this class to new line
Should we print out the emulator logs somewhere?
Is this code that's not finished? Just checking so you haven't forgotten about it.
Same again with the log level, can you set this to w? Also can you change that message to something like "couldn't list assets at font path" so it's less ambiguous, it's not really failing to load fonts if you get me!
final
use -> throw Throwables.propagate(e); and remove the last throw statement
Nitpick: might be better to use constants for these.
there is a getInteger method, if you have int mailPoint
The default should probably be 10 (10 MB), not one thousand.
This seems unnecessary. What advantage is there here versus before ? Both guarantee the order is respected.
Isn't this doing the exact same thing as before ? When viewer.refresh() runs, connection.getImages(true) has completed. I would avoid touching this if there's no benefit.
I would remove this and keep the flow as it was before.
Should we return emptyMap if we are SUSPENDED as well?
[Checkstyle] INFO: Line is longer than 140 characters (found 146).
I am wondering if we should also check term just before sending commit to Kafka? After rebalance and assigning the same partition it is still possible that we successfully commit offsets from previous term. Probably it is not a problem, I'm just thinking aloud here.
Move this line down. We don't need to instantiate a new object if it's not an IContainer.
Please specifiy the encoding.
we don't use curly brackets around one single line block's
Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?
s/listPartitionsInfo/streamToPartitionInfoMapping
If an assignment strategy doesn't implement movePartitions and if the operator calls movePartitions, It is better to throw rather than silently return. This way it is clear to the operator that movePartitions is not supported for the connectors using this assingment strategy.
This could be null, we should probably handle this if the JIRA api changes again
I wouldn't necessarily change this for the PR, but I would suggest getting into the habit of returning an Optional whenever a function can return null. That way it is made clear in the signature that the caller has to check to see if the value actually exists or not.
suggestion mapper.orElseGet(ObjectMapper::new).convertValue(this, new TypeReference<Map<String, String>>(){});
clean up empty quotes and new line.
Is there any advantage to put that outside the query string itself?
Can we have spaces in the eventType field?
If we move MessageTest to the internet package (and rename it to MimeMessageTest, which is what it is), these can be package-local. Also please annotate @VisibleForTesting
By looking at the org.apache.james.mime4j.message.DefaultMessageBuilder class, I wonder if there's a reason for doing new MimeConfig() instead of using MimeConfig.DEFAULT
The pattern we use most of the time is to have a static factory method (without arguments) that fetches or creates the dependencies and injects them as constructor arguments.
not really this PR, but why isn't there just one ObjectMapper (even static) instead of creating a new one every time? the same can be said about the TypeReference
We should also provide a version that accepts some sort of date, which this version delegating out to it.  java public Map<String, Object> getStats() throws IOException { return getStats(new Date()); } public Map<String, Object> getStats(final Date date) throws IOException { ... }
Should this variable name be updated as well?
is it possible that among the possible NakadiBaseExceptions there would be an authorization exception? I'm not sure if authorization is checked earlier in the code path, but if that's the case, we should handle this one specially. Could you please check that?
On line 133: partitionSession = getPartitionSession(subscriptionId, eventType.getTopic(), cursor); you take topic from event type. I think it does not make much sense.
Weird, but makes sense I think?
Same as above, try to simplify this by adding meaningful local variables.
Is there a particular reason you don't just say: for (LocationAttribute att : location.getActiveAttributes()) { ... ?
Avoid calling getOverload twice.
This can be handled by waitForRunningTaskToComplete accepting a callback function to be executed that can contain the following code.
You should determine if you need a regression model in the scheduler
You might want to get and ACK about the execution of the operation, because otherwise it is really complex to control the behaviour of the distributed system.
Change to a single call with both arguments.
try/catch
try/catch
Please don't extract that into other methods, it makes the tests hard to read. Either you multiply the test classes, each one of them having only one test method and one setup, or you use classes with many test methods but then, each test method must be readable at a glance and not rely on other methods located elsewhere, because it makes the intention of the test unclear.
Could you maybe use BASIC_RESULTS_UNORDERED here instead of the already sorted BASIC_RESULTS? The same for Set_By_Sorted().
The debug message for the replacement is useful too. See AbstractMappingMessageRouter
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
I don't get it here you passed JobReposotory to Job
We should store a job key instead of the actual job class so that we have flexibility to change the class name if we choose -- storing the actual class name has bitten us with Quartz in the past. When receiving a job message, candlepin should look up the Job class via some sort of registry / config.
I think we could only just set the StrictMode in Application.
Are we keeping this public method for a reason? Isnt this a remote param now or are we keeping both?
DatabaseHelper.init(this);
Don't call toString()
I'm confused by those. Those fields (as well as geocodes, error and totalCnt) would have been copied already by the new SearchResult(search) constructor, wouldn't they?
add avilable context info for debug logs
This is bytecode equivalent to using the for-each syntax on an array.
the order looks incorrect. encodes the values first but reads the keys first. should this be reversed?
not a big deal but as the list is empty anyway, no real need to add at the beginning. Moreover I think you could express this method in a one liner with IntStream.range.mapToObj.collect(toList)
Um, surely 1.6.6 is closer to 1.6.5 than it is to 1.6.
The name is very confusing, assert equals seem to indicate it should take 2 parameter and make sure they are the same. I know you mean to assert symbols from Expression and RowExpression are the same, but you really can't tell from here. Maybe just call this assertSymbols.
Seems to be formatted incorrectly
Note that using builder.setNegativeButton(R.string.cancel, null); here will accomplish the same thing.
Add these to the strings.xml file
build.create call is duplicated
I think that if the "new" token is the same as the previous one, we should return an error / not make a new request, assuming that the server will continue to think that value is not valid.
should break request.toBuilder().header(HttpHeaders.AUTHORIZATION, authHeader).build(); into it's own method as you call it twice and the long chain is a little hard to read
You could combine the two checks, if (requestHeader != null && requestHeader.size() > 0)
You need to use the following pattern when using reentrant lock. Otherwise it could happen that the lock won't be unlocked if an exception happens in between lock and unlock. lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() }
One more thing, if we consider the part between the [] to be the event name (that an eventual UST-JUL-TC parser could eventually even interpret as the event name (and same thing with fields, everything separated by '=' could be assigned to a fieldname+value)) then we should use a consistent naming pattern. UST events usually use names_with_underscores, but that's very C-ish. Since we're in Java, should we use CapitalziedCamelCase for event names?
I would have liked to have some less specific way of doing this, but hey! at least the feature is there!
I'd prefer overriding of setEntity() method to listening for events in this case.
For PropertyChangedEvent, "args" will always be an instance of PropertyChangedEventArgs. Therefore you can also cast "args" directly, for example: String propName = ((PropertyChangedEventArgs) args).propertyName; Above should simplify the code a bit. It's up to your consideration, as for me the instanceof is just unnecessary complexity. BTW, we have a BZ exactly for this issue: <LINK_0>
1. Please export lines 82+83 to a method 'selecetLabelChanged'. 2. Please call the method also before add the listener.
Can we collapse these two branches and just pass the parameter (direction == Direction.ASC) ?
I'd rename nthArray to inputNumber and fold if (filterContainer[i] != nthArray) check into for loop like so:  if (scanAllPositions) { int inputNumber = inputNumbers[filterIndex]; for (int i = filterIndex + 1; i < numPositions && inputNumbers[i] == inputNumber; i++) { numNextPositionsToFail++; } } else { int inputNumber = inputNumbers[selectedPositionIndexes[filterIndex]]; for (int i = filterIndex + 1; i < numSelectedPositions && inputNumbers[selectedPositionIndexes[i]] == inputNumber; i++) { numNextPositionsToFail++; } }
nonDeterministic variable is used only once; inlining simplifies the code to:  boolean keepNulls = filter == null || (deterministicFilter && filter.testNull());  However, there must be logic to handle nulls for non-deterministic filters and I don't see where it is. Could you give me a pointer?
<field name>_COLUMN
It would seem more natural to test the basic highlight first.
The status line shows the status of the active part. If we call getStatusLineMessage() on a workbench part, I would think we have to ensure that this part gets focus before attempting to extract info from the status line.
Is this supposed to return the task to the pool (no longer claimed)?
The original exception here may not be related to InvalidClientId, seems a bit dangerous to catchall and throw like this. Maybe bubble up or convert the exception, at least link the exception and add the intial cause.
Use parameterized logging instead of string concatenation.
Just stuff all this logic in "getAllowedCategories" so you have no if statement here. Then the case statement just has return pickRandomInsightCategory(getAllowedCategories(marketingInsightPool, marketingSeenCategories),random);
the two methods with the name "selectMarketingInsightToGenerate" should not share the same name. They do different things. Having a function call itself like this made me think "oh, it's recursive".
Having a hard time following this, can we just make it "return dayFloor(dt.minusDays(dt.getDayOfWeek() -1)"? Sorry if I'm being dense, but I can't understand the reason for the withMonth/withDay/withYear code.
Nit: superfluous as the equals will say got null below
This is changing the behaviour. Previously it would add the result as DATA_CTX_RESULT.
maybe additional else if branch? would be easier to read
nit: it's my personal style preference, but I much prefer instance != null ? instance : result.newModule() rather than the flipped case you have here.
Same issue here. We should keep this as static if at all possible
Simpler: ArrayList<T> result = new ArrayList<>(collection);
Second parameter of Status is the pluginId. Why to pass path here?
Second parameter of Status is the pluginId. Why to pass path here?
Second parameter of Status is the pluginId. Why to pass path here?
Duplicated _for_ loop could be extract as a private method to factorize the code.
This method name is a bit confusing.
skipOnly is named terribly wrong. However as long as it means "continue search only when", you should _not_ modify this if.
let's change the order in the ctor - its clearer when the source is before the dest :)
lets export this to a method
please consider to create the parameters using the constructor with less arguments and then set the actual size (if needed) using its setter in order to reduce the lines of code (see CreateAllSnapshotsFromVmCommand#buildLiveSnapshotParameters)
Must be AIDontUseIt (otherwise AI will discards all own hand for lands).
Must return false on broken/non-applied effect.
BoostSourceEffect has to be removed.
That's true It's fine then.
Maybe add capacity for params?
name choice LGTM
remove newline at the end of methods
I actually think checking the type of the object is safe than the java class property
Why do you have to include this test data for reason concept? Is it required for this test?
May we detail the logger message a lit like > error in registering flow trigger <PojrectName_FlowName> in Quartz,
same as above, put the check in a util method
consider to put the check in the util class like FlowUtils? i guess it will be used in multiple cases? but not every one will remember to use Double.compare to compare two doubles. At least for me it's not occasionally to just use "==" :)
what about : this.myField ? This isField method should probably return the referenced symbol.
remove final modifier.
What about expressions like this.field = null ?
Why not update it in setZoomRatioInternal()? Is it because of float rounding error?
I'm not sure whether we should directly reset all related variables here including - Cancel previous mPendingZoomRationCompleter and set to null - mCamera2CameraControl.setCropRegion(null) - Set mPendingZoomCropRegion as null By using setZoomRationInternal function here, my question is that it will create a new completer object. But there might be no new CaptureResult coming since camera is inactive. That completer will be hold until camera is active again and then receiving new CaptureResult. Or maybe we can use setZoomRationInternal but also set mPendingZoomRationCompleter as null.
It seems this can also be done inside setZoomRatioInternal function. If it can be, the second boolean parameter of setZoomRatioInternal function seems can be removed.
these 3 lines are common in closeXXX() and can be moved to close()
can we avoid writing headerOutLong file in cases where its not needed? may be, we can write headerOutLong on demand at the point when fileSizeLimit is crossed (and stop writing headerOut afterwards)? in most use cases, headerOutLong would not need to be written at all.
Seems that it could be convert into bulk transfer from headerFile.getChannel() to headerOutLong, without a lot of RAF seek() calls
I believe jobId always defaults to 1. Why is it currentTimeMillis here? Wouldn't this cause different path across processors? Perhaps I am missing something
np: s/LocalApplicationRunner/RemoteApplicationRunner
Does this need to be public? If you need in tests, could you make it package private and mark as VisibleForTesting?
please dont remove explicit initialization
Wouldn't the contains method be more reliable here, in case some spacing was different at the beginning or end of the line?
Consider declaring the InputStreamReader in the try with resources so it is closed if the BufferedReader constructor throws an exception.
:ant: Deserves a functional test.
In this 2 lines, the Utils methods are not doing much more than what BouncyCastle is able to do itself. I would suggest replacing them with our own loadPrivateKey and loadPublicKey so that we can use the KeyFactory.getInstance(String algorithm, Provider provider) instead of the KeyFactory.getInstance(String algorithm, String providername) used by the library .
use same type for instanceof and force casting
should be int y
oldDataSerialized = (null != coordinateData) ? "" : coordinateData.serialize(); could also be final.
This "else" has created on me a nice debugging session :-)
Replaceable with Iterators.transform()
This Iterable chain of nested classes is very noisy. Maybe create a simple List of bitmaps, fill it in a for loop with i between startIndex and endIndex, then return bitmapFactory.union(bitmaps)?
Can you go ahead and give the list capacity for filters.size at construction?
Why AttributeModifier needed here? Why just don't update PasswordsPanel.html?
you can do List<String> modelsList = new ArrayList<>(Arrays.asList(modelBuilding, modelHvac, modelWard))
Localize
Why allocate a new array? You already have created the array; why not just set the array element ?
You don't actually need to get the "file system" from the tserver. You can get it from the ServerContext: suggestion this.fs = server.getContext().getVolumeManager();
Not from this PR, but now that you're here this could be final :)
If you make the EMPTY_EXPIRES, you could use it here.
Can you replace IDs with names in this log message?
Immutable?
Suggest leaving them as null if not set
Let's simplify this condition
pls use formatter
check is unnecessary
check unnecessary
check unnecessary
Is there a possibility that jetty.home is not empty, but jetty.base is? In that case, jetty.base will be left empty.
verify that that user.dir system property is used
Pull this out to a field and initialise on the setup
please don't call this a regex
Log in logger, not just print in console.
Extract this to a quote function or similar you can reuse and properly unit test.
The 'finally' block is not needed since calling monitor.done() is not required.
Add catch clause for OperationCancelledException and return CANCEL_STATUS.
won't exit the loop. You need to return here
There are two 'additions' groups, this one and another before the align action. One should probably be changed. I wonder if those two TmfView common actions should be in some same group, with 'additions' group separator added after, for all the subclass actions in that group?
Configure Attribute Visibility...
Add here collapseHandler = new CollapseAllHandler(getTreeViewer()); IHandlerService handlerService = getSite().getService(IHandlerService.class); handlerService.activateHandler(CollapseAllHandler.COMMAND_ID, collapseHandler); to handle the standard key binding for the collapse all command.
use ConcurrentUtils.withLock()
using AtomicInteger makes the need for this lock unnecessary. Also for future reference, notice that the only critical resource here is the map. So if you were to actually synchronize, you should only synchronoize that part. It doesnt make sense to syncrhonize the connect part
should not lock everybody just because one thread is doing test connectivity
It's a common misconception to size a hash map this way. Guava uses the following computation to compensate for deficiency of the HashMap constructor: static int capacity(int expectedSize) { if (expectedSize < 3) { checkNonnegative(expectedSize, "expectedSize"); return expectedSize + 1; } if (expectedSize < Ints.MAX_POWER_OF_TWO) { // This is the calculation used in JDK8 to resize when a putAll // happens; it seems to be the most conservative calculation we // can make. 0.75 is the default load factor. return (int) ((float) expectedSize / 0.75F + 1.0F); } return Integer.MAX_VALUE; // any large value }
Use same order as the field declarations.
This method should be private unless there are plans to use it elsewhere.
You can use a foreach loop of the form for(BibEntry entry : entries).
Shouldn't this be refactored to something like this? entries.append( "- " + entry.getName() + " - " + entry.getMissingPluginId() + "\n"); if ( missingEntries.indexOf( entry ) == missingEntries.size() - 1 ) { entries.append("\n"); }
There is no need to generate mvn(groupId:artifactId) requires. RPM depgenerator handles it itself.
There is a lot happening here. It would be nice to break this up into multiple statements to improve the readability. Something like this: java ClientRegistration clientRegistration = context.getClientRegistration(); boolean isClientCredentials = AuthorizationGrantType.CLIENT_CREDENTIALS .equals(clientRegistration.getAuthorizationGrantType()); if (!isClientCredentials) { return null; } OAuth2AuthorizedClient authorizedClient = context.getAuthorizedClient(); if (!shouldRequestToken(authorizedClient)) { return null; }
wondering which flow is better. Using the following might get rid of the reconnectToGemfire method in Cluster. suggestion String userName = authorizedClient.getPrincipalName(); if (isExpired(authorizedClient.getAccessToken())) { logoutUser(userName); authorizedClient = refreshExpiredClient(authentication, authorizedClient); } userName = authorizedClient.getPrincipalName(); String credentials = authorizedClient.getAccessToken().getTokenValue(); return getClusterWithCredentials(userName, credentials);
This code changes the existing functionality. If accessTokenResponseClient is null, clientCredentials should still be enabled. Please add an else statement containing authorizedClientProviderBuilder.clientCredentials() to ensure clientCredentials is enabled by default.
return Arrays.stream(array).mapToDouble(array2D -> array2D[dim2Index][dim3Index]).toArray()
Can't we use Arrays.stream(queues).map(Queue::getName) instead ?
Looks like even the brackets around i == j is not useful?
FileOutputStream has a different usage of FileNotFoundException than FileInputStream. Here I would propose deleting specific handling of FileNotFoundException and left just IOException, stating that file cannot be created and logging stacktrace.  Throws: FileNotFoundException - if the file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason
suggestion if (this.shadow$hasTagCompound() && this.shadow$getTagCompound().hasKey(Constants.Sponge.SPONGE_DATA, Constants.NBT.TAG_COMPOUND)) {
suggestion if (this.shadow$hasTagCompound() && this.shadow$getTagCompound().hasKey(Constants.Sponge.SPONGE_DATA, Constants.NBT.TAG_COMPOUND)) {
Do we need to check Null of the input parameters?
Why does this just return blank strings?
Put a Sage.rez() around "Forced"
Why add random options without a detailed explanation what the issue is and what these options change?
nit: better to print out host and port.
can we simplify this to something like java future.completeExceptionally(new IllegalStateException("Failed to bootstrap client (address " + address.toString() + " cannot be resolved)"));
This class has Constructor and getter/setter which are never used.
Update this method to also return true if status is HALF_OPEN?
I don't know which pr will contain the final setting for this, but the 2 FAILED statuses should be here also. cc @hreeve-cloudera
Same as above, using GeoWebCacheExtensions.getProperty would allow more options to set a property.
You're still taking the performance hit here, as you're walking the iterator and storing the sourceId in a variable _only_ to be used in the debug. Instead... java if (LOGGER.isDebugEnabled()) { LOGGER.debug( "subscription is a site-based subscription starting with site id {}", sourceIds.iterator().next()); }
We have some keys with camel case such as dspace.baseUrl. Unfortunately, I do not think the values can be lower cased without changing other property-related behavior.
I don't see what is wrong with the existing way to remove a channel other than an extra hash lookup. With Java 8 upgrade, it should be changed to physicalNodes.removeIf(pn -> pn.getClient().equals(client));
selectedElement for better readability
Simple for-each?
we tend to like initialization like this: final A a; if (cond) { a = something; } else { a = null; } This make very clear when a is set to null;
rename to viewer
Colors view, Filters view, maybe LAMI Report view? Maybe there should be distinct concepts for views that send/receive TMF signals, and views that show trace data.
you could _extract method_ here, to avoid duplicated code on instanceFor and canProvide methods (just like type = extractRawType(type)) or just add this 2 lines on getBeanFrom
I'm not sure, but it looks a lot of work to just unwrap a proxy =( I'll take a look to see if I can find some simpler/cheaper solution
just get() no contains
Unsigned types are not used in the current implementation. So, you can omit them.
Should be moved with other not treated cases
Gson doesn't run on these versions so I don't see any reason to include them.
I know that logically the changes in this method are correct due to the last return true. However, the method is already quite complex and big and it might make it more complex to follow certain changes to it. Or in case the default or some logic before it changes.
You could have returned checkIfParameterizedTypeReferenceShouldBeUsed(componentType); in all if-else cases.
I don't think we use final for functions in our code base
mmm not sure if it is gt 120 characters.
Could use Assert.state() here (since IllegalStateException is desired) or Assert.hasText(..) (which would instead throw IllegalArgumentException). In either case though, the 6 lines could be replaced by 2, and it improves test coverage (unless we have tests that make it into each of these if blocks).
Suggest adding "break handlePayload" here too
See above about title, file_name, and content being required parameters.
Yes, this would be a good idea.
You should leave gender here.
isn't the default 2?
All these numbers should probably be defined in static final variables up near the top
The first three should be required.
For null values, we just do not supply those properties in the autoGenerationOption
When will these last two lines ever get executed?
How sure are you that these values were not already false, even before the rest call?
Also include the values here?
why not use the field directly ?
unnecessary nested try block
Nitpick: We can do the if else together here :)
This shouldn't be a warning-level log. Also, is this log really necessary? We already generate quite a bit of logging per upload, with this there are three logs per tick:  05-05 08:27:02.034 31057-12701/org.wordpress.android.beta D/WordPress-API: Dispatching action: MediaAction-UPLOADED_MEDIA 05-05 08:27:02.082 31057-31057/org.wordpress.android.beta W/WordPress-MEDIA: EDITPOSTACTIVITY: 65 - 0.9653928 05-05 08:27:02.093 31057-31057/org.wordpress.android.beta D/WordPress-MEDIA: 65 - progressing 0.9653928  If they're helpful while working on async we could keep them but keep track that we should reduce them later - these logs make it into helpshift reports, and I think there's a size limit that can prevent earlier useful logs from being preserved.
Is this callback even hit in the context of this PR? If not, can we remove it from this PR and add it to the PR that it's used for the first time? Thanks!
I think all of the stuff that modifies the response needs to happen outside of the thread after start is called. Otherwise, the method will have already returned, so I'm not sure what would even happen if you modify the response.
Use **puppet -v** instead, as it is more portable among operating systems (yes, including Windows and Mac).
Lacks permission check. While #doQuietDown does, this logs messages before permission is checked.
Take executor from here <LINK_0> Withiut daemon shutdown of server may not go cleanly.
Introduce jwksRegenerationInterval and schedule separately. Clean up may run much more comparing to jwks regeneration.
Static import
Arguments should be switched.
Better to introduce a method processServerMetrics() like the processWorkerMetrics().
discussed offline. probably better to use getBlobMetricsGroup here to keep metrics grouping consistent with range requests.
Can you add a call to "DataCacheFactory.getCache().getCacheManager().clearAll()" as well? In the default configuration it will clear the same cache as the "report-dataset-cache", but if an OEM replaces the DataCache-implementation, we will cover their implementation too.
Magic number
That can't compile anymore.
Worth checking that the UUID doesn't exist? Veeeeeery unlikely it does, but...
mappedEntity can be final, and you have a few blank lines in this method that don't really improve legibility.
Shouldn't this be just else?
How are we testing these changes?
Perhaps, "PartitionSizeBits should be a positive value no greater than 32?"
We agree to make helper classes immutable -- hence, we should create a new object instead of returning this
Instead of adding inline styles like this could you pass in a class name that we apply to the element instead? This makes maintenance a lot easier as well as making branding applying different styles.
My personal preference is to use brackets even for one line loops and condition. Not a blocker to merging.
I think UnsupportedOperationException would be more appropriate.
Preferably use assertEquals. < testing
do we want to assertFieldCountEquals here?
This test makes me a little weary since it could pass even if clear didn't work but the write to file/load from disk part wasn't working.
Use ImmutableSweepBatchConfig.builder to create the sweepBatchConfig.
I'm pretty sure we only want to set this if currentResults is not null (i.e. this line should be moved to inside the if currentResults != null block). If currentResults is null, we probably want it to stay null so that the first block of updateResultsIfNeeded() can fire.
I would cap this to MAX_BATCH_SIZE.
suggestion assertThat(filter.beforeRequestMessage).contains("/hotel");  This is analogous to the aforementioned .startsWith() change. Please apply to all affected methods.
Just for the beauty of the source code, I would have prefer request and response instead of arg0 and arg1...
Should this and line 69 be log.debug?
I think we should add filtering for returned resources for VOADMIN and VOOBSERVER role. They don't have to get resources of other VOs, just because they have same service assigned. It doesn't have to be part of this pull-request thought. You can create new pull-request with this specific change.
Please add also VOOBSERVER.
You can drop PERUNADMIN check here. And also in all other such methods in this file please.
since this is a method with the word "print" in the name, assume output should go to STDOUT throughout
This method sums over the second and third dimension.
Looks like even the brackets around i == j is not useful?
Is this System.out required?
would it be simpler to read with streams / filter/ Collectors.toList() ?
The variable feels weird. copied gives me the impression that something worked but then I see that you throw an error if copied == true. maybe use something else e.g. failedToCopy? or alternatively return the string and check whether its null?
Remember the special case of issues having only flows with a single location (like cognitive complexity). Here all (single) locations of all flows should be highlighted.
Use the "Unspecified Location" constant in Middleware
ScmInfo#getLatestChangeset() must not return null, so orElseNull() should be replaced by orElseThrow(...)
Minor: can we check if the number contains the decimal point instead?
doesn't look like this variable is being used. Suggest removing if this is the case.
use artifact.getAttributeById(attrUuid, includeDeleted)
How about declaring this 1048576 as MAX_AGGREGATE_SIZE or something and then use that here.
why pass in a SocketChannel when you could pass in whatever .pipeline() returns
just new Http2MultiplexHandler(new ChannelInboundHandlerAdapter()) would do.
It is a bad practice to print stack trace instead of logging or processing exception
but if project really BLANK it's normal behavior
I think we should check the version and call super.getProjectDetails if it is an old one
This code also does not respect devices in single-SIM mode (i.e. phoneCount == 1) where there are both pSIM and eSIM slots, but only one can be active at a time. This case still needs to be accounted for using the old logic.
No need to check this.
is that possible this is null?
nit: you may keep the chain pattern as append returns the builder object. Do not have a strong opinion on the current or the chained version.
Personally I don't find a real benefit and code actually doesn't look better. Why do you want to change this loop? It is actually using more resources than the fore each loop. This is not an hot path but the question is more general. Streams look appealing but sometimes the overhead is not worth
why null?
According to the docs[0], this should be called from onCreate()... But how are you supposed to get the MapView before onCreateView()? [0] "You must call this method from the parent's Activity.onCreate(Bundle) or Fragment.onCreate(Bundle)." <LINK_0>
can we instead set textDirection and textAlignment (like RtlAwareTextView) in xml?
should we also set myLocationEnabled = true here?
Extract the "USER_ID" to a constant and make it more unique. The HttpSession can be accessed "everywhere" in a servlet container. For example: "org.everit.jira.timetracker.plugin.user.id.hash".
as this is not interactive command, I suggest you do not call getDbUser twice, drop the canDoAction entirely.
where do we get the primary key?
category
This could be entirely done as a stream.
What about the cases where the region is PARTITION and parallel is false, or region is REPLICATE and parallel is true? Do those need to be covered?
shouldn't need the throws declaration?
must be of type bytes or string
Can we just throw the IOException? If we want a proper error message, then perhaps include the cause e in the IllegalArgumentException?
I don't think these checks are required - the NullPointerException will be thrown down the chain anyway?
stray system out
Why change to "unacceptable value"? Should we say specifically say "Request has a null value for header"?
it also need to be checked that token not expired at the beginning and expired only when expected time passed.
I suggest to keep validation in the setter for now. Something like this:  java if (token != null && !token.isEmpty()) { if (!token.matches("^[a-zA-Z0-9]{16,}$")) { throw new IllegalArgumentException("Illegal token"); } this.token = token; }
Would make second param a TokenType
Does this line have any effect? Can it be removed?
it is non-standard. and the dialog should be modal, taking up the ui, so the user can't interact with the button anyway while it is open. so i don't see any value in disabling the button while the dialog is open. we usually only disable buttons during an rpc, where we are waiting for the server to respond and the rest of the ui is still live.
Cute. We don't support this anywhere else. Either whack the line, or make a different change which adds multiple name support to AddMemberBox so we can use it in the group management code too.
Does not need to be public
Style-nit: Should be after this.accountCache = accountCache.
oh.. ok actually looking at fields, looks like this object is somewhat mutable. I think this is a separate issue.
You don't need this null-check, the getJavaElement method already does that.
I think that CSSDOMSemanticElemntHelper should be an Singleton.
I think you should be able to call instanceof on a null (which will fail the instanceof)
I believe we just had someone discover this wait strategy doesn't work as expected
If it can not be a constant, then we should extract this in a helper method.
For readability mind putting the entire second conditional on the next line?
@cyberone no need for Mockito.times(1)
We should use better variable names (filter, path, entries). It would make the assertions and verifications clearer.
@ikhvostenkov please name it just json
extra ;?
assert that calling .next() again returns null?
we should use CellUtil.createCell rather than making KeyValues directly. (KeyValues are InterfaceAudience.Private, which means that projects outside of HBase shouldn't refer to them.)
Should we consider other measurement units, like kg?
What if the string doesn't end with a " or '? You'll strip the last character.
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
might be more logical to swap the order of the two lines above (install java, download tarball, unpack tarball)
I thought that global install was not recommended, should use normal when possible? Not a NodeJS expert though so might as well be wrong.
does apt-getting this package really cause the rules to be saved immediately? i think you want to second command to be run irrespective of the result of the former. perhaps also try running iptables-save as presumably that worked somewhere, and it might work somewhere that service iptables save and /sbin/service iptables save doesn't work ... if i've understood correctly? /cc @grkvlt i'd suggest (with import static BashCommands.* here, for brevity):  chain( ok(install("iptables-persistent")), alternatives( iptablesService("save"), "iptables-save" ))
can we add a log line that we are killing a segment located at location <somethign>
Please create a temporary directory and remove it in @AfterClass.
Why an Object, this seems like it's basically a static method?
In this case I don't think it matters, but I think in general as we write new tests with operations we shouldn't use the constants. It's mainly a regression check to ensure the operation names don't change in the constant value.... ...though I should probably bring this up on wildfly-dev and not this PR :)
Do we need this stack trace to be printed or should it just fail?
Thanks for this. We have a util class, ServerReload, that should be used for this kind of thing. It looks like moving this test to it was missed. The block here looks the same as ServerReload.executeReload(managementClient.getControllerClient(), false) so please use that instead. I thought it might be, but the ServerReload.executeReloadAndWaitForCompletion call is not appropriate here as this test is asserting some intermediate state while awaiting completion.
I feel like this is the best place to construct the spring resource URL with either file:// or resource://. this.configDir value could actually be a URL containing file:// or resource:// and then used for loading security, variables, and tables (all using spring resource loader).
By catching the exception, we are not failing the test. Tests like this should just propagate all unexpected exceptions.
instead of multiple return we can store results in a variable, and then have single return.
There is an asGuid helper method. You can see the work I did for AddVmFromSnapshot at BackendVmsResource as a reference.
since Gluster Bricks are business entities, they will be added in the context: .../volumes/{volume:id}/bricks (not here, which is): .../volumes/{volume:id} So we shouldn't verify that the user passed bricks; in fact the user will never pass bricks in this context. This raises the question of what does it mean to create, temporarily, a volume without bricks, and then add bricks to it. Basically, creating an 'empty' volume. We had the same debate recently for Quotas - a Quota has limitations. The limitations are business-entities in their own right, but a Quota with no limitation is meaningless. We eventually decided that creating an 'empty' quota, and adding limitations to it afterwards, is legal. Do you think we can make the same decision here?
Same with the ( and )
This should be outer.
This should be outer.
left outer?
Instead of a null check, why not just move the rest of the method to the try block?
Same here. Instead of notebook, note would be more correct.
is there a race condition? since runParagraph is a loop, what if we abort para 1 but there threadpool thread runs para 2?
Couldn't this if block move before the other if block? If the data has a size of 1 then the lower index will always be data.size() - 1.
use constants here, what +8 and -2 means ?
Hmm,. can we just create topicPartitions as needed? I don't think StopReplicaRequest#topicPartitions needs this level of optimization, and duplicating stuff is always frustrating.
This should probably be done using a progress dialog instead of showing the entire activity as loading. You can do that by extending ProgressDialogTask in the FollowUserTask class
This should not be a ProgressDialogTask, since this code just drops disc cache, it executes pretty fast and there is no need in displaying progress.
We can remove this String definition and use the String value directly, as it's used only once. This applies to few of the below lines as well
Shouldn't it be true ? (legacy SQL used for old jobs)
Nit: I read "/" as "OR" which seems weird where we are both creating and starting. I think the message would be better as just "Creating NodeTypeWatcher" or "Creating and starting NodeTypeWatcher"
Maybe checking with STRING isn't quite enough here. I could imagine a lot of Hive users using the more specific VARCHAR column type.
Shall we catch specific exception?
I removed this change ... Use should not place any files in repo, we can come back to this if become very annoying.
speces before and after "+" :)
![MINOR](<LINK_2> 'Severity: MINOR') "get" returns a string, there's no need to call "toString()". [![rule](<LINK_1>](<LINK_0>
To make it clearer that you're adding a host with a different name than expected, why not putting "differentName" here. Otherwise the names only vary in their case.
![MAJOR](<LINK_0> 'Severity: MAJOR') Put single-quotes around ':' to use the faster "indexOf(char)" method. [![rule](<LINK_1>](<LINK_2>
is it possible to have tests for the encrypt/decrypt methods of this util?
same here, we might want to move some of the common memcached / redis cache code to druid-processing and reuse it.
Please use joinParameters method.
It can be done shorter: return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
removePattern
Why is this here with such a wide exception type?
The type should be included in the context.
suggestion public Object getName() { return eventData.get("event"); }  I'm not sure about this one. It feels redundant prefixing this with Event when the object is already a PusherEvent. It's also more consistent with the swift SDK: <LINK_0> The downside is the property in the JSON object is called event, so it might be a but confusing if it's called "name" on this object. Do you have any thoughts @jameshfisher?
Could this create inconsistency since LivInstances used by all other places in the pipeline are different from here?
return Collections.emptyList()
maybe, would not be keeping the map null better, to ensure uninitialized mapper will not be used accidentally? (even NPE is better then complex debugging why roles are not mapped...)
Immutable?
Glad to see that with this change, one can now navigate the (java) code and notice the different icons the button can display. Previously, one of the cases was set vie the xml layout file.
There is a slight chance that this View will be destroyed when this callback is reached. Therefore this should be protected by a check for isAttachedToWindow().
Please don't remove this mechanism for changing the color. Here we make sure that changes of the colours modify the individual views, e.g. night mode switches to day mode.
nit: missing newline
Currently you're parsing the message JSON twice: once in extractDataFrom and once in getMetaData. This could be improved by modifying extractDataFrom to use the output of getMetaData perhaps.
You don't need a local variable el, you can just do return TransitionTest.this
To make this more bulletproof, can we use the variant of waitFor() that takes no arguments? The Jenkins test harness puts a timeout on each test, so if the code under test has failed, the test would eventually time out. In contrast, this approach has an implicit assumption that the CI system will be running at a particular speed, and I'm not sure that we can rely on the Jenkins project's CI system to have any particular performance guarantees.
[nit] Should we combine the calls to TestUtils.runSwarmClient and TestUtils.waitForNode into a single call to TestUtils.createSwarmClient?
Change allOf to is.
do you really mean "master cluster"
Please add single quotes around fieldName and urn
should be memory (you have mem_usage twice)
So why actually returning something ? I would really prefer to stick to throwing an explicit exception. AFAI understand you only return so you can test it in an existing test : create a dedicated test for the case and keep the explicit failure.
You could keep this declaration after the throw Exception, so you don't do it if the exception is thrown. Really minor thing.
Good
minor, is it method scope for Visible For Testing? If not please change it to private.
Personally, I'd just make a wrapping iterator which "flat maps" the values for a key into key,value pairs
Can we name this something other than it? Even i would be better to me than it.
this for is exactly the same in all the array tests, let's move it to a private method
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
why not 10? it is not very clear what this test does. Why are the arrays different length?
Minor: For consistency: LOG.warn("Failed to read offset file in storage partition directory: {}", offsetFileName, storepath, e)
don't need to throw exceptions - just return null.
Save as final field?
any specific reason we have a separate function for this? I would suggest creating a generic function that takes in the column number as a parameter, then both these functions can call that one with the appropriate column number
Could you perhaps try to use similar approach to [this](<LINK_0> The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.
Could you perhaps try to use similar approach to [this](<LINK_0> The point is not to copy-paste code between Page Objects and also not to put so many ugly selectors directly into the methods.
no need for this change now
please rename variable
don't we want some confirmation window before registering
use Arrays.fill instead for loops
What about Arrays.equals? Also possibly an intrinsic in JDK9.
I think this will hit an ArrayIndexOutOfBoundsException if other.dimension != this.dimension. In other methods, this is checked beforehand. Any reason for not doing it here?
going to assume a potential illegal argument exception here, too, if adSpaceName=""
Since this is hardcoded, should this be destroy ? Is there any effect on UnityAds side if categories/metadata are mispelled/incorrect?
destroy should be called.
please don't use labels
return list.size() > 0 ? list : null
This test will pass even if get() doesn't throw. This should be followed by fail().
The field state should be read into a local variable outside the loop.
The field state should be read into a local variable outside the loop.
Standby task should never be in RESTORING since we always transit from CREATED -> RUNNING -> RESTORING in one call. Did you observe this was not the case from failed system tests? Even in unclean close case you described I did not see why it could be possible..
Could you remove a newline?
Could you remove a newline?
Why have you started to use taskScheduler? I understand the async wish, but that is the first time in our code... Anyway I think it would be better to extract variable for the getApplicationEventPublisher(). Or does compiler do the stuff for us?
use single quote to make this a Char
This optimization is redundant. The JDK implementations of EnumSet already override addAll(Collection) to check whether the received set is an EnumSet, and do a bitwise OR of their bit fields to quickly combine sets. - <LINK_1> - <LINK_0> - <LINK_2>
Is it okay to use unnest like this here? What if one array has more dimensions than the other?
We need to check the rightOperandList also.
I think we may also drop this "== 2" specialization as the method is no longer recursive +1
ArrayList should be constructed with fixed capacity.
"FROM" - we should make sure we are consistent when capitalizing HQL keyword.
This returns an optional. We should actually check if there are none in findFirst().
This can be probably rewritten to use super.getBody() instead of duplicating code here.
Findbugs reports this, as you ignore the result of read(). Please add it to findbugsExcludeFile.xml to ignore it (or you can use return value to check if the read was successful here, not necessary though).
Do we need this instance whenever the method is called? Can't we reuse it?
these should be closed?  try (ByteArrayInputStream bytein = new ByteArrayInputStream(body); GZIPInputStream gzin = new GZIPInputStream(bytein); ByteArrayOutputStream byteout = new ByteArrayOutputStream();) { ... }
Can you please close the response in the end of test?
if (t != null) should be if (!timeout)
might it be useful to log the response body as well?
I think it would be nicer if we removed the intermediate OptimizeTableAnalyzedStatement and instead directly build the request classes. WDYT?
put an empty line after
Nit: the else is redundant since the if block above returns unconditionally
Can we please mock the Future?
Can we please mock the Future?
isTrue()
Not sure whether we should transparently fall back? I think using this interpolator should be an active choice, especially since it does not even handle all default constraints out of the box.
Should we really use it by default? I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](<LINK_0> "arg0", "arg1" etc. as the default names. I feel we should stick to this for now.
Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.
I know I started using just title, but looking at some Google apps, like the Play store app, I think it's better to just use message. so, I recommend to change HistoryActivity instead to be consistent with this.
Camel case
While Capitalised?
Remove this printStackTrace. logger.error will log a stack trace if you do this: logger.error("description of context", e); Basically we never want to see e.printStackTrace in geode code. Always use a logger instead.
Wait, you add the postfix here, because the internal implementation of parse requires it and in order to be able to pass it from the outside you change the parameter from typeName to simpleClassName? Why not keep the signature as is and deal with it only within the parse method?
Wouldn't Arrays.asList() be enough here? Arrays.stream seems to have a lot of memory overhead.
This should not be changed, you should only be changing search methods
Same chunk of code in 3 places, it should be refactored out into a method taking a user parameter. That makes it easier if someone needs to change it in the future.
Here too it looks like whether the tracker is enabled or not might change between the check and the call. Also LockdownVpnTracker.isEnabled() here might be replaced with mLockdownEnabled I thik
When would the offsets be unsorted? Is this more of a precaution or is it common? Is it again the small file optimization?
why ConfigurableApplicationContext, not ApplicationContext?
Suggestion, I would add some basic message saying at least which argument was invalid.
Shouldn't we add this only in case of async actions? Maybe check if action.isAsync() == true, in addition to jobId != null check.
The logoff was needed when this code was executed inside the tread pool, but it is executed in the HTTP request thread now, so it will unexpectedly close the session. Remove it.
Synchronous command may have a job id as well (see ExecutionMessages.properties) - that's the operation we see under the "tasks" tab, it doesn't necessarily mean that the action has asynchronous operations. I believe the we add a flag on the action result to determine if a command has async operations (I believe we should set it to true if the command has callback or if it has async tasks as being checked today).
Setting the style isn't needed for this component as this is the default already.
I don't get it here you passed JobReposotory to Job
types --> type
do we really have to work with classNames here and couldn't use Class objects directly instead? This smells like dynamic-import again :-(
Here this can be package-private and not public. Also we should annotate it as @VisibleForTesting.
You have some indent issues. We enforce a 4 space indentation.
Please use StringUtils.equals
please use {}
compareTo() and equals() have to be consistent with each other, which it is here. But you can enforce it and simplify by simply doing return compareTo(blobId) == 0; at line 353 and avoiding the code duplication.
Use of this.getClass().getName
Is this line really adding the namespace **URI** to the id? While that definitely is more stable, I'm wondering if using string form of the name (produced without the namespace registry, which would wrap the URI in curly brackets) might help to keep the namespace separated from the name (and more easily parsed, if the connector wants to do this). Also, are these IDs properly handled when creating the files/folders?
should there be a filter step in here, so only accounting lines without an override code get the value set to none? Just to confirm, do we need to do this target lines?
set it to the appOptions by default. If it's still null, set it to a new instance.
getAdOptionsFromExtras() can handle a nullable extras, and always returns a nonnull AdColonyAdOptions. How about always call it here, and then you don't need to do a null check on adColonyAdOptions below?
fixed by orphanRemoval = true
This can be static.
Why the + "\n*"?
please extract as constant
asyncInvokeNext already checks if the delay stage is completed.
I would invert the if here too
you could invert the if to avoid negate the condition.
Objects.isNull method exists for being used as lambda, direct use is just an obscure way to write value == null
concise way to do this would be value = value.replaceAll("&", "&amp;").replaceAll(...).replaceAll() I think it would be more readable and concise.
"else if" maybe?
In several tools, we're using "jopt" for argument parsing. Perhaps you want to introduce it here as well?
add a System.exit(-1) after the usage output
@inverno We have 2 times "Second argument" :)
is there a reason the fixture parser isn't in a initFixtureParser() function like these others?
Same simplification to improve the readability of the method as above. Besides I don't see a requirement in XEP-0118 that user tune element's must have at least 'title' set (although it appears sensible). Did I miss it?
This is an unintended grant of permissions to all users. If the owner doesn't exist, this should instead call throwIfNonAdmin
Can you make these 5 seconds a constant like the other timeouts?
Is this project specific? Because it is generally ok to do so.
Why to call finish?
null check?
Beginning to wonder if it isn't worth extracting this to a utility method.
I think that 500 ms looks like a decent default but should be adjusted based on output rate and desired consumer responsiveness.
Not mandatory but we could save some duplication by refactoring these tests
@eg04lt3r we've talked about this approach before in #123. there should be a thread pool.
If storeThread == null concurrent tryCommit() or deregisterVersionUsage() may change its value between get() and set(), they are not synchronized like this commit() method. It looks like compareAndSet() should be used here too instead of set() or something else should be changed.
This is no longer needed if MVs dont support indexes.
Please put @Override on the standalone line
minor: could you add disabledReplicas as well?
As a reply to your TODO in line #126- Seems that your code ("moveMacsFromOldMacPoolToNewOne();") should be moved to line 92. And should be in the same transaction with "getStoragePoolDao().updatePartial(getStoragePool());". Line 91 includes the update of the dc mac pool. So in case of a failure (crashing of the engine for example) after the mac pool update and before moving the macs to the new pool, the dc will be in inconsistent state and needs to be reverted.
the name isn't intuitive, IMHO. perhaps copyUnchangedStoragePoolProperties(), or something down those lines?
Perform update only at case of vdsm call successes, also use only one time updatePartia() . Also change updatePartial() , can also update storage pool format type
Maybe it is better to say _"Provider for DTO type ..."_ ?
Do you want to lose the copy-once optimization? filterOutboundMessage is called at enqueue time. Hence a heap buffer will only be copied once (maybe preferable if pooling is enabled?). The copy immediately before socket write option will require multiple copies of bytes that cannot be flushed in the first socket write call (extra bytes will be copied again when channel is OP_WRITE again). When I was envisioning some type of change, I was thinking that it is preferable to copy at enqueue time if pooling is enabled. Otherwise copying immediately before write (potentially extra copies, but much less pooling required).
I guess logical expressions don't produce a boolean value? Is that why you can't just check for a boolean output type in AbstractExpression?
This is pretty inefficient, the way you would normally do this in JGit is: while (baseUrl.charAt(baseUrl.length() - 1) == '/') baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
0 is the default value for an int field. We do not make assignments to default values in constructors.
we don't use braces around single line blocks
You should instead be asserting that UserService.getUserActivationKey returns the same user and not this dao call
Did you compiled and notice the test passed? check line 1394.
Quelques lignes plus bas: User mockedUser = mock(User.class); when(mockedUser.getEmail()).thenReturn(email); when(mockedUser.getPassword()).thenReturn(password);
Could also do:  ApiDate lastSeen = Optional.ofNullable(r.getLastseen()).map(ApiDate::new).orElse(null);
You didn't want to use minDateTime() and maxDateTime() huh? :P
Is there a reasonable way we could pull this pattern out of the highlight rules instead of duplicating it? Also not clear on how this keyword scope list applies here -- this is for TeX and (a) should not apply to other modes and (b) won't capture keywords in more common types such as Roxygen (e.g. \code)
use apiClass.getName() instead of LoginAPI.class.getName()
What do you think about moving the url strings into constants?
why declaring data out of try block?
what do the 0L, 100L represent?
final
Can we use Guava style list creation?
Wdyt about using a java 8 method to check lists ?  public boolean isRowSorted(List<String> info) { return info.equals(info.stream().sorted().collect(Collectors.toList())); }
we can just call repeat(" ", n)?
How about checking numberOfEntries != 0 instead?
more than 120 characters.
I was more thinking of adding it to the context hashset. If you have a look at completePlace() function in NominatimConnector.java, you'll see that this is what happens when multiple city-like address parts show up.
Why isn't full refresh being done before getting something from the cache? At this point we'll have stale metadata, at least it's at the edge of the TTL for the cache.
This method should declare that it throws this exception so that all usages are forced to handle it
Can you maybe inject the Gson? Will make it that much easier to test.
Why not just the plain test()?
Sure it would be slightly faster, I guess, if the method is looked up at proxy creation time. I wasn't overly concerned about it since this is a debugging class. I'm ok if that's a follow-on improvement, too.
that will fail when we only have 2 arguments in the request, because line 3 is expecting 3 arguments and line 17 only handles less that 2. i mostly do it the other way arround, so if(args.length==2) return call(pc, Caster.toString(args[0]), Caster.toFunction(args[1])); else if(args.length==3) return call(pc, Caster.toString(args[0]), Caster.toFunction(args[1]), args[2]); else throw new FunctionException(pc, "StringSome", 2, 3, args.length);
Too many unnecessary blank spaces in this class. Please refactor.
Let's remove the BsmAdminPageEditWindow(String) constructor.
This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?
This is kinda a duplicate, as we already wait in the confirm() method or is there a particular reason to wait again for another element?
I don't think this is needed because this is a new build step type so there won't be any older jobs to correct
style guide
Would be useful to move to SpinnakerException family for all exceptions. There's a number of places in the PR that need to change beyond this one point. Also happy to explain this (or doc if I haven't) why it's beneficial to do so.
Please externalize these strings.
Is this line removed by mistake?
I'd check for an empty sourceValue and treat this case separately since we dont want to show an error upon opening the dialog ![image](<LINK_0>
If we're going to use this Exception for both Create and Modify, should we rename to something more appropriate like "DomainDaoException" or "DomainTxException"?
what about conflicts? if a credential is already defined I would hope that an import would not overwrite an existing one (as it would loose a secret) but error (or skip with warning)?
This assumes both collections are the same type. To be on the safe side, you should surround both with your own collection (e.g., new ArrayList<>)
Would you please convert to tableTypeClauses.keySet().toArray(new String[0]) here?
Why do you pick b as the variable name? It could be model or m. I am just curious.
only instanciate ret and mt if servers != null and length > 0
Could use the Apache CommonsIO FilenameUtils.separatorsToSystem(String path) to be safe & cut down on verbosity. Also, that same utility has a lot of other useful methods that we could be leveraging throughout: A few: normalize(String filename) //normalize unneeded relative paths to simplify the path. ex: a/b/../b becomes a/b getExtension(String filename) //gets the extension wildcardMatch(String filename, String wildcardMatcher) //allows you to compare extensions or file names easily via wildcard
same suggestion as in testClone().
I'd prefer to avoid the old java.io where possible. Can this be done with java.nio.Paths.get() to avoid casting to and from File.
If we arrive here the statusCallback is notified already in the DownloadBatch.batchCannotContinue method, right?
Mid return may worsen readability
Did this convert it to a Callable or a Runnable? I believe this is why it wasn't inlined before.
Should this get a trailing newline too?
This doesn't quite work. You need to call matches() before you can access the group: Matcher m = versionPattern.matcher(pckIn.readStringRaw()); if (!m.matches()) { throw new IOException(... invalid cert ...) } String version = m.group(1); This is one reason we don't bother with regex. Especially for simple patterns like this. It can be easier to just say: private static final String VERSION = "version "; String s = pckIn.readStringRaw(); if (!s.startsWith(VERSION)) throw ... String version = s.substring(VERSION.length());
optional: This message doesn't look so great --- isn't it a valid ref name, but just a missing ref? We can avoid the test being too prescriptive by making the matching less exact (e.g. by checking that the message contains the ref name). Alternatively, a followup change could improve the message.
maybe this can be a set, so that duplicates get filtered out
We COULD think about treating this as a fatal error. Not 100% sure about this. See my thoughts in the other PR.
activeContext was registered into activeContexts, when an event of ActiveContext happens. Why is it mentioning about running tasks?
if it isn't too much change, lets get rid of SecurityServiceCallback
this is a BadRestRequest() which is bound to fail. This test should be similar to the one in AdminBlobStorageService in the sense that it should create a valid request with the PUT method.
Why should the caller have to provide the RestResponseChannel here? Given the RestRequest you would (or should) know what the RestResponseChannel is, wouldn't you? Why put the burden on the caller and allow for mistakes to be made?
foreach loop, append the comma always and then resize the stringbuilder => shorter, clearer code, and more efficient :)
String.split?
no need to specify type on RHS
why? just don't set _vds, and if _vds is null then do not enforce. I think we talked about this. Always use the engine interfaces.
Don't you want to add some logging here? at least at debug level?
This looks like a lot of repetetive code from GetFingerpringQuery- can't it be reused somehow?
remove the explicit initialization?
try {
While here, would you consider changing all this to a try-with-resources so it's easier to read and there isn't the Timber.e call?
cleanup this temp dir afterwards
temp dirs all over the place
Better IMO to use:  try{ return loadStaticModel(tmpFile); } finally { tmpFile.delete(); }  This is better for long-lived JVMs (and those that don't exit properly).
As Alex suggested, this should just be a continuation of the above if (as another else if) rather than a new if.
I suggest simplifying this a bit by using knownProperties.getIfAbsent( probertyId, noValue )
If Java 8 can be used, this method can be reduced to: return this.properties.stream().filter(p -> p.getName().equals(name)).findFirst().isPresent();
Couple of things here: (a) we can use Preconditions.checkArgument/checkState - less verbose (b) When throwing exceptions, I think it's good practice to include useful information. What dimension? What's the shape of the array? Without that, I need a debugger to get that information, which adds a lot of time required to fix it...
This array must be calculated one time only
Looks like even the brackets around i == j is not useful?
UUID.fromString can throw IllegalArgumentException. There's no reason that we should be attempting to convert the correlation id from the server since there's no reason that it has to be a string. That's not a bug that you introduced, but removing the catch all exceptions clause will allow a new, potentially app crashing failure mode that didn't exist before. Your change is correct. But now we should deal with the failure mode that shouldn't have been there in the first place.
@weijjia Should we log the status code here as well?
why removing?
Shouldn't need the null check here: now that PP-4105 is done, connector should always return delayed_capture
I think cause should be conditional because it can be null. Therefore an explicit StringBuilder instead.
Same as above for toString(): <LINK_0>
still think that we should log when there is a not found mapping
This try/catch would not be needed since GoraException thrown by getDataStore extends IOException :)
If we move this in to the caller then neither of the subclasses of AbstractWrapperStoreProvider need care about the StatisticsService.
If this is only for testing, use stream api
just curious, what would happen if we returned ofResult(page, /*needsMoreData*/ true), even though we were told there is no more data?
Is this the same as getDelegate().getPage(context, id) ? Sometimes getDelegate() is used and sometimes super.
Should be Reflections.getAllInterfaces(Class) to get interfaces on superclass and so forth. Returns a List<Class<?>> instead of an array, but should be OK.
Give feedback about what is missing.
This is super minor (coding style): let's add a single space character between the , and new. You can perform this automatically by selecting the line (better select this single line only) and use "Code -> Reformat Code" from AndroidStudio's menu. Thanks!
why final variable? :-)
why do you need mapper.writerWithView(Event.class).writeValueAsString(event) instead of just mapper.writeValueAsString(event)? same question for mapper.getFactory().createParser(json).readValueAs(Event.class) instead of mapper.readValue(json, Event.class)?
I think you can have a static variable for the formatter instead of creating a instance each time you use it. privat static ChartYAxisValueFormatter yAxisValueFormatter = new ChartYAxisValueFormatter(); and use it in all places. I think it should work and saves a bit memory
unnecessary new line
{}
folder.listFiles() will return empty array if no files in the directory. We do not need to do a null check here since testFolderPath must be path to a directory
Why are you removing metrics at the end ? It's not already done by DbTester ?
Can you add @NonNull @CheckResult @WorkerThread to these two methods as well?
So all our existing users Contributions data - on upgrade - will remain on disk forever?
You should only take into account owning partitions here (avoid renting partitions, moving are not possible because previous assignment is ideal).
Perhaps it's more resource-friendly to use long[] here (value for each partition)
Relatively expensive to create object mappers. Use Jackson.DEFAULT instead, or create static field.
can you explain this logic? Should partial task data not carry the updated date/revision information?
This is pretty important behaviour. It should be tested.
I've just realized that the domain name property will be stored without the "@" character. However, we need to include the "@" while setting the attribute value. So, please could you change the code to something like this?  if (attribute.getFriendlyName().equals(attrNameFenix)) { String domain = "@" + getDomainNameFenix(); filledAttribute.setValue(sha1HashCount(user, domain).toString() + domain);
Should we make this intermediate commit point *configurable*? I'm hoping committing every 10,000 is a sane default, but just wondering out loud if it's worth making this a configuration setting.
Note that we get the message twice when oai.import.batch.size is defaulted. Cosmetic. But do we really need this?
Looks like catching of UriBuilderException is redundant. The same in Openshift infra
try/catch
try/catch
try/catch
Should probably use System.lineSeparator() for the benefit of non-Unix-like consoles.
return StatUtils. percentile(toDoubleArray(colName), 50) directly?
return StatUtils. max(toDoubleArray(colName)) directly?
Remove the * 2
Not needed, delete.
Needs to be in an else-clause, otherwise you'll count twice (newChild() and worked()) and thus reach 100% before the last path.
